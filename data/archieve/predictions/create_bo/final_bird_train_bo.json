{
    "books": [
        {
            "sample_id": 5967,
            "vt": "SELECT book.title FROM book INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id INNER JOIN cust_order AS T3 ON T3.order_id = T2.order_id INNER JOIN customer AS T4 ON T4.customer_id = T3.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of books ordered by a specific customer identified by their first and last names. It retrieves data from the 'book' table and joins it with the 'order_line', 'cust_order', and 'customer' tables to filter the results based on the customer's name."
        },
        {
            "sample_id": 6066,
            "vt": "SELECT DISTINCT customer.first_name, customer.last_name FROM customer INNER JOIN customer_address AS T2 ON T1.customer_id = T2.customer_id INNER JOIN address AS T3 ON T3.address_id = T2.address_id WHERE address.street_number = [placeholder-type:numeric] AND address.street_name = '[placeholder-type:string]' AND address.city = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct first and last names of customers from the 'customer' table who have addresses matching a specific street number, street name, and city. The placeholders in the WHERE clause represent the street number, street name, and city name."
        },
        {
            "sample_id": 5951,
            "vt": "SELECT COUNT(*) FROM order_status INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE order_status.status_value = '[placeholder-type:string]' AND STRFTIME('%Y', order_history.status_date) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of order histories that match a specific order status and year. It joins the 'order_status' table with the 'order_history' table based on the status ID, filtering results by the specified status value and the year extracted from the status date."
        },
        {
            "sample_id": 6081,
            "vt": "SELECT order_line.price FROM book INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE book.title = '[placeholder-type:string]' AND STRFTIME('%Y', book.publication_date) = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the prices of books from the 'book' table that match a specific title and publication year. The query uses an inner join with the 'order_line' table to connect the book's ID with its corresponding order line, allowing for the extraction of price information based on the specified conditions."
        },
        {
            "sample_id": 5914,
            "vt": "SELECT publisher.publisher_name FROM book INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE book.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of publishers from the 'publisher' table for books that match a specific title from the 'book' table. The join operation links the two tables based on the publisher's unique identifier, ensuring that only the relevant publisher names are returned for the specified book title."
        },
        {
            "sample_id": 6055,
            "vt": "SELECT book.title FROM book INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of books from the 'book' table that are published by a specific publisher. The query uses an INNER JOIN to connect the 'book' table with the 'publisher' table based on the publisher's unique identifier. The placeholder in the WHERE clause represents the name of the publisher."
        },
        {
            "sample_id": 6070,
            "vt": "SELECT book.title FROM book INNER JOIN book_language AS T2 ON T1.language_id = T2.language_id WHERE book_language.language_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of books from the 'book' table that are written in a specific language. The query joins the 'book' table with the 'book_language' table to filter the results based on the language name provided as a placeholder."
        },
        {
            "sample_id": 5959,
            "vt": "SELECT publisher.publisher_name FROM publisher WHERE publisher.publisher_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of publishers from the 'publisher' table based on a specific publisher identifier. The placeholder in the WHERE clause represents the unique identifier of the publisher."
        },
        {
            "sample_id": 5996,
            "vt": "SELECT cust_order.order_date FROM book INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id INNER JOIN cust_order AS T3 ON T3.order_id = T2.order_id INNER JOIN customer AS T4 ON T4.customer_id = T3.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the order dates of books ordered by a specific customer identified by their first and last names. It retrieves data from the 'cust_order' table, which contains customer orders, and joins it with the 'order_line' table to link orders to specific books. Additionally, it joins with the 'book' table to access book details. The placeholders in the WHERE clause represent the customer's first and last names."
        },
        {
            "sample_id": 6018,
            "vt": "SELECT COUNT(*) FROM book INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id GROUP BY book.publication_date ORDER BY book.publication_date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of books grouped by their publication date from the 'book' table, joined with the 'order_line' table to include only those books that have been ordered. The results are ordered by publication date and limited to a specified number of entries."
        },
        {
            "sample_id": 5987,
            "vt": "SELECT customer.first_name, customer.last_name FROM book INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id INNER JOIN cust_order AS T3 ON T3.order_id = T2.order_id INNER JOIN customer AS T4 ON T4.customer_id = T3.customer_id WHERE book.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of customers who ordered a specific book from the 'book' table. The query joins multiple tables: 'book' to identify the book by its title, 'order_line' to link the book to the orders, and 'cust_order' to connect those orders to the customers. The placeholder in the WHERE clause represents the title of the book being queried."
        },
        {
            "sample_id": 5966,
            "vt": "SELECT COUNT(*) FROM publisher INNER JOIN book AS T2 ON T1.publisher_id = T2.publisher_id INNER JOIN order_line AS T3 ON T3.book_id = T2.book_id WHERE publisher.publisher_name = '[placeholder-type:string]' AND order_line.price < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of publishers who have published books that have been ordered at a price lower than a specified amount. It joins the 'publisher' table with the 'book' table to link publishers to their books, and then further joins the 'order_line' table to filter based on the price of the orders. The placeholders represent the publisher's name and the maximum price for filtering the orders."
        },
        {
            "sample_id": 5993,
            "vt": "SELECT SUBSTRING(customer.email, INSTR(customer.email, '@') + [placeholder-type:numeric], LENGTH(customer.email) - INSTR(customer.email, '@')) FROM customer GROUP BY SUBSTRING(customer.email, INSTR(customer.email, '@') + [placeholder-type:numeric], LENGTH(customer.email) - INSTR(customer.email, '@')) ORDER BY COUNT(*) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the domain part of customer email addresses from the 'customer' table. It groups the results by the extracted domain and orders them by the count of occurrences, limiting the output to a specified number of domains."
        },
        {
            "sample_id": 6099,
            "vt": "SELECT book.isbn13, order_line.price FROM book INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE order_line.book_id = [placeholder-type:numeric]",
            "ba": "The virtual table displays the ISBN13 and price of a specific book from the 'book' table, joined with the 'order_line' table to retrieve the price associated with that book. The placeholder in the WHERE clause represents the unique identifier of the book."
        },
        {
            "sample_id": 5926,
            "vt": "SELECT SUM(order_line.price) / COUNT(*) FROM order_line INNER JOIN cust_order AS T2 ON T2.order_id = T1.order_id INNER JOIN customer AS T3 ON T3.customer_id = T2.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average price of all books ordered by a specific customer identified by their first and last name. It does this by summing the prices of the books in the 'order_line' table and dividing by the total number of orders made by that customer. The query joins the 'order_line' table with the 'cust_order' table to link orders to customers, and then filters the results based on the customer's first and last names using placeholders for these values."
        },
        {
            "sample_id": 5982,
            "vt": "SELECT COUNT(book.book_id) FROM book_language INNER JOIN book AS T2 ON T1.language_id = T2.language_id WHERE book_language.language_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of books available in a specific language from the 'book' table, which is linked to the 'book_language' table. The placeholder in the WHERE clause represents the name of the language for which the book count is being queried."
        },
        {
            "sample_id": 5916,
            "vt": "SELECT publisher.publisher_name FROM book INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id GROUP BY publisher.publisher_name ORDER BY COUNT(book.book_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of publishers from the 'publisher' table, which are associated with books in the 'book' table. It groups the results by publisher name and orders them based on the count of books published by each publisher. The placeholder in the LIMIT clause allows for specifying the maximum number of publishers to return."
        },
        {
            "sample_id": 5980,
            "vt": "SELECT COUNT(*) FROM book INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of books from the 'book' table that are published by a specific publisher. It joins the 'book' table with the 'publisher' table using the publisher_id to filter the results based on the publisher's name provided as a placeholder."
        },
        {
            "sample_id": 5955,
            "vt": "SELECT book.title FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE author.author_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of books from the 'book' table that are written by a specific author. It uses an inner join to connect the 'book' table with the 'book_author' table to find the corresponding author IDs, and then joins with the 'author' table to filter by the author's name. The placeholder in the WHERE clause represents the author's name."
        },
        {
            "sample_id": 6049,
            "vt": "SELECT address.street_number, address.street_name, address.city FROM customer INNER JOIN customer_address AS T2 ON T1.customer_id = T2.customer_id INNER JOIN address AS T3 ON T3.address_id = T2.address_id INNER JOIN country AS T4 ON T4.country_id = T3.country_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the street number, street name, and city of addresses associated with a specific customer identified by their first and last name. The placeholders in the WHERE clause represent the customer's first and last names."
        },
        {
            "sample_id": 5917,
            "vt": "SELECT book.title FROM book INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE publisher.publisher_name = '[placeholder-type:string]' ORDER BY book.publication_date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of books from the 'book' table that are published by a specific publisher. It joins the 'book' table with the 'publisher' table to filter the results based on the publisher's name. The results are ordered by the publication date of the books, and a limit is applied to restrict the number of titles returned."
        },
        {
            "sample_id": 6037,
            "vt": "SELECT DISTINCT order_status.status_value FROM order_status INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id INNER JOIN cust_order AS T3 ON T3.order_id = T2.order_id WHERE cust_order.order_date LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct order status values from the 'order_status' table by joining it with the 'order_history' and 'cust_order' tables. It filters the results based on a specific order date provided as a placeholder."
        },
        {
            "sample_id": 5970,
            "vt": "SELECT author.author_name FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id INNER JOIN publisher AS T4 ON T4.publisher_id = T1.publisher_id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of authors from the 'author' table who have written books published by a specific publisher. It joins the 'book' table with the 'book_author' table to link books to their authors, and then further joins with the 'publisher' table to filter results based on the publisher's name."
        },
        {
            "sample_id": 5969,
            "vt": "SELECT customer.email FROM book INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id INNER JOIN cust_order AS T3 ON T3.order_id = T2.order_id INNER JOIN customer AS T4 ON T4.customer_id = T3.customer_id WHERE book.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the email addresses of customers who have ordered a specific book. It joins the 'book' table with the 'order_line' table to link books to their respective orders, then connects to the 'cust_order' table to find the customer associated with each order, and finally accesses the 'customer' table to get the email addresses. The placeholder in the WHERE clause represents the title of the book being queried."
        },
        {
            "sample_id": 5932,
            "vt": "SELECT COUNT(book.book_id) FROM book INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of books from the 'book' table that are published by a specific publisher. It joins the 'book' table with the 'publisher' table to filter the results based on the publisher's name provided as a placeholder."
        },
        {
            "sample_id": 6040,
            "vt": "SELECT book.title FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE author.author_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of books from the 'book' table that are written by a specific author. The query joins the 'book' table with the 'book_author' table to link books to their authors, and then further joins with the 'author' table to filter by the author's name using a placeholder."
        },
        {
            "sample_id": 6043,
            "vt": "SELECT AVG(book.num_pages) FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE author.author_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of pages of books written by a specific author. It joins the 'book' table with the 'book_author' table to link books to their authors, and then filters the results based on the author's name using a placeholder for string values."
        },
        {
            "sample_id": 6038,
            "vt": "SELECT MAX(order_line.price) FROM book INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE book.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum price of a book from the 'book' table by joining it with the 'order_line' table. The query filters the results based on the title of the book, which is specified using a placeholder for string values. This allows users to find out the highest price at which a specific book has been ordered."
        },
        {
            "sample_id": 6107,
            "vt": "SELECT CAST(SUM(CASE WHEN book_language.language_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM book_language INNER JOIN book AS T2 ON T1.language_id = T2.language_id INNER JOIN publisher AS T3 ON T3.publisher_id = T2.publisher_id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average price of books published by a specific publisher in a specified language. It sums the prices of books that match the given language name and divides this sum by the total count of books to find the average. The placeholders represent the language name, the price of the books, and the publisher's name."
        },
        {
            "sample_id": 5913,
            "vt": "SELECT book.publication_date FROM book ORDER BY book.num_pages LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the publication dates of books from the 'book' table, ordered by the number of pages in ascending order. The placeholder in the LIMIT clause allows the user to specify how many publication dates they want to retrieve."
        },
        {
            "sample_id": 6058,
            "vt": "SELECT CAST(SUM(CASE WHEN order_status.status_value = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM order_status INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE STRFTIME('%Y', order_history.status_date) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of order statuses from the 'order_status' and 'order_history' tables. It sums the values of a specific order status, applies a multiplier, and divides by the total count of orders for a given year. The placeholders represent the order status value, the numeric value to multiply, and the year for filtering the order history."
        },
        {
            "sample_id": 6088,
            "vt": "SELECT CAST(SUM(CASE WHEN order_line.price > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM order_line INNER JOIN cust_order AS T2 ON T2.order_id = T1.order_id INNER JOIN customer AS T3 ON T3.customer_id = T2.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average price of order lines for a specific customer based on their first and last names. It sums the prices of order lines that exceed a certain threshold and applies a multiplier to the result, then divides by the total count of order lines associated with that customer."
        },
        {
            "sample_id": 6002,
            "vt": "SELECT COUNT(*) FROM customer_address INNER JOIN address_status AS T2 ON T1.status_id = T2.status_id WHERE address_status.address_status = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customer addresses that have a specific status from the 'address_status' table. It joins the 'customer_address' table with the 'address_status' table to filter the results based on the address status provided by the user."
        },
        {
            "sample_id": 6086,
            "vt": "SELECT publisher.publisher_name FROM book INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id GROUP BY publisher.publisher_name ORDER BY COUNT(publisher.publisher_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of publishers from the 'book' table, showing how many books each publisher has published. It groups the results by publisher name and orders them based on the count of books published, limiting the results to a specified number."
        },
        {
            "sample_id": 6069,
            "vt": "SELECT shipping_method.method_name FROM cust_order INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id INNER JOIN shipping_method AS T3 ON T3.method_id = T1.shipping_method_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]' AND cust_order.order_date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the shipping methods used by a specific customer for their orders. It retrieves the method name from the 'shipping_method' table by joining it with the 'cust_order' table, which contains the order details, and the 'customer' table, which holds customer information. The placeholders in the WHERE clause represent the customer's first name, last name, and the order date."
        },
        {
            "sample_id": 6071,
            "vt": "SELECT book_language.language_name FROM book INNER JOIN book_language AS T2 ON T1.language_id = T2.language_id WHERE book.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of languages in which a specific book is available. It retrieves the language name from the 'book_language' table by joining it with the 'book' table based on the language ID. The placeholder in the WHERE clause represents the title of the book."
        },
        {
            "sample_id": 6057,
            "vt": "SELECT book.isbn13 FROM book WHERE book.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the ISBN13 of a book from the 'book' table based on a specific title provided by the user. The placeholder in the WHERE clause represents the title of the book being queried."
        },
        {
            "sample_id": 5948,
            "vt": "SELECT customer.first_name, customer.last_name FROM customer INNER JOIN cust_order AS T2 ON T1.customer_id = T2.customer_id GROUP BY customer.first_name, customer.last_name ORDER BY COUNT(*) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of customers from the 'customer' table who have placed orders. It joins the 'customer' table with the 'cust_order' table to count the number of orders for each customer, grouping the results by their names. The placeholder in the LIMIT clause represents the maximum number of customers to return based on their order count."
        },
        {
            "sample_id": 6047,
            "vt": "SELECT author.author_name FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id ORDER BY book.num_pages LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of authors from the 'author' table who have written books listed in the 'book' table. It joins the 'book' and 'book_author' tables to associate each book with its corresponding author. The results are ordered by the number of pages in each book, and the output is limited to a specified number of authors."
        },
        {
            "sample_id": 5942,
            "vt": "SELECT AVG(book.num_pages) FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE author.author_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of pages of books written by a specific author. It joins the 'book' table with the 'book_author' table to link books to their authors, and then filters the results based on the author's name using a placeholder for string values."
        },
        {
            "sample_id": 5973,
            "vt": "SELECT book.title, publisher.publisher_name FROM book INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE STRFTIME('%Y', book.publication_date) = '[placeholder-type:string]' AND book.num_pages * [placeholder-type:numeric] > (SELECT AVG(book.num_pages) FROM book) * [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of books along with their respective publisher names from the 'book' and 'publisher' tables. It filters the results to include only those books published in a specific year, indicated by a placeholder for the year, and ensures that the number of pages in each book, when multiplied by a specified numeric value, exceeds the average number of pages across all books, also multiplied by a different numeric placeholder."
        },
        {
            "sample_id": 5927,
            "vt": "SELECT CAST(SUM(CASE WHEN order_line.price > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM order_line INNER JOIN cust_order AS T2 ON T2.order_id = T1.order_id INNER JOIN customer AS T3 ON T3.customer_id = T2.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average price of books ordered by a specific customer based on their first and last names. It sums the prices of order lines where the price exceeds a specified threshold, applies a multiplier, and divides by the total count of orders to derive the average. The placeholders represent the threshold price and multiplier for the calculation, as well as the customer's first and last names for filtering."
        },
        {
            "sample_id": 6012,
            "vt": "SELECT COUNT(*) FROM customer WHERE customer.email LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customer' table whose email addresses match a specific pattern. The placeholder in the LIKE clause represents the email pattern to be searched."
        },
        {
            "sample_id": 6017,
            "vt": "SELECT MAX(order_line.price) FROM book INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE book.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum price of a book from the 'book' table by joining it with the 'order_line' table. The query filters the results based on the title of the book, which is specified by a placeholder. This allows users to find out the highest price at which a specific book has been ordered."
        },
        {
            "sample_id": 5929,
            "vt": "SELECT COUNT(*) FROM customer INNER JOIN cust_order AS T2 ON T1.customer_id = T2.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of orders placed by a specific customer identified by their first and last name. It joins the 'customer' table with the 'cust_order' table to correlate customer information with their respective orders."
        },
        {
            "sample_id": 6056,
            "vt": "SELECT COUNT(*) FROM book WHERE STRFTIME('%Y', book.publication_date) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of books published in a specific year from the 'book' table. The placeholder in the WHERE clause represents the year of publication."
        },
        {
            "sample_id": 5943,
            "vt": "SELECT shipping_method.method_name FROM shipping_method ORDER BY shipping_method.cost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of shipping methods from the 'shipping_method' table, ordered by their cost. The placeholder in the LIMIT clause allows the user to specify the maximum number of shipping methods to retrieve."
        },
        {
            "sample_id": 5938,
            "vt": "SELECT country.country_name FROM customer INNER JOIN customer_address AS T2 ON T1.customer_id = T2.customer_id INNER JOIN address AS T3 ON T3.address_id = T2.address_id INNER JOIN country AS T4 ON T4.country_id = T3.country_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]' AND customer_address.status_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the country name of a customer based on their first and last names, as well as the status of their address. It involves joining multiple tables: 'customer', 'customer_address', 'address', and 'country'. The placeholders represent the customer's first name, last name, and the address status."
        },
        {
            "sample_id": 5974,
            "vt": "SELECT customer.email FROM customer WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the email addresses of customers from the 'customer' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the customer being queried."
        },
        {
            "sample_id": 6075,
            "vt": "SELECT book.title FROM book ORDER BY book.num_pages LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of books from the 'book' table, ordered by the number of pages in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of book titles to retrieve."
        },
        {
            "sample_id": 6061,
            "vt": "SELECT author.author_name FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE book.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of authors from the 'author' table for books that match a specific title in the 'book' table. It uses inner joins to connect the 'book' and 'book_author' tables, allowing access to the author information based on the book's ID. The placeholder in the WHERE clause represents the title of the book being queried."
        },
        {
            "sample_id": 5935,
            "vt": "SELECT book.title FROM book INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id GROUP BY book.title ORDER BY COUNT(book.title) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of books from the 'book' table that have been ordered, showing only unique titles. It joins the 'book' table with the 'order_line' table to count how many times each book has been ordered. The results are grouped by book title and ordered by the count of orders, limiting the output to a specified number of titles."
        },
        {
            "sample_id": 6104,
            "vt": "SELECT publisher.publisher_name FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id INNER JOIN publisher AS T4 ON T4.publisher_id = T1.publisher_id WHERE author.author_name = '[placeholder-type:string]' GROUP BY publisher.publisher_name",
            "ba": "The virtual table lists the names of publishers for books written by a specific author. It retrieves data from the 'book' table, joining it with the 'book_author' table to link books to their authors, and then further joining with the 'author' table to filter by the author's name. The results are grouped by publisher name to ensure unique entries."
        },
        {
            "sample_id": 6006,
            "vt": "SELECT customer.first_name, customer.last_name FROM customer INNER JOIN customer_address AS T2 ON T1.customer_id = T2.customer_id GROUP BY customer.first_name, customer.last_name ORDER BY COUNT(customer_address.customer_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of customers from the 'customer' table who have associated addresses in the 'customer_address' table. The query groups the results by the customer's first and last names and orders them based on the count of addresses associated with each customer. The placeholder in the LIMIT clause represents the maximum number of results to return."
        },
        {
            "sample_id": 5920,
            "vt": "SELECT COUNT(*) FROM book INNER JOIN book_language AS T2 ON T1.language_id = T2.language_id WHERE book_language.language_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of books from the 'book' table that are written in a specific language. It joins the 'book' table with the 'book_language' table to filter the results based on the language name provided by the user."
        },
        {
            "sample_id": 6094,
            "vt": "SELECT COUNT(*) FROM book INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE publisher.publisher_name = '[placeholder-type:string]' AND STRFTIME('%Y', book.publication_date) = '[placeholder-type:string]' AND book.num_pages BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of books from the 'book' table that are published by a specific publisher and published in a specific year, while also filtering for books that have a page count within a specified range. The placeholders represent the publisher's name, the publication year, and the range of pages."
        },
        {
            "sample_id": 6036,
            "vt": "SELECT order_history.order_id FROM order_status INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE order_status.status_value = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the order IDs from the 'order_history' table based on a specific order status. It joins the 'order_status' table to filter the results according to the desired status value."
        },
        {
            "sample_id": 6073,
            "vt": "SELECT AVG(book.num_pages) FROM book_author INNER JOIN author AS T2 ON T1.author_id = T2.author_id INNER JOIN book AS T3 ON T3.book_id = T1.book_id WHERE author.author_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of pages of books written by a specific author. It joins the 'book_author' table with the 'author' table to filter by the author's name, and then it retrieves the 'num_pages' from the 'book' table to compute the average."
        },
        {
            "sample_id": 6108,
            "vt": "SELECT SUM(CASE WHEN book.num_pages < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN book.num_pages > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM book INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE order_line.price < [placeholder-type:numeric]",
            "ba": "The virtual table calculates the difference between the total number of pages of books that have fewer pages than a specified value and the total number of pages of books that have more pages than that value. It filters the results based on the price of the books in the order line, ensuring only those with a price below a certain threshold are considered."
        },
        {
            "sample_id": 6109,
            "vt": "SELECT DISTINCT book_language.language_name, book.title FROM order_line INNER JOIN book AS T2 ON T1.book_id = T2.book_id INNER JOIN book_language AS T3 ON T3.language_id = T2.language_id WHERE order_line.price * [placeholder-type:numeric] < (SELECT AVG(order_line.price) FROM order_line) * [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of distinct book languages along with their corresponding book titles from the 'order_line' table. It filters the results based on the condition that the price of the order line multiplied by a specified numeric placeholder is less than the average price of all order lines multiplied by another specified numeric placeholder."
        },
        {
            "sample_id": 6015,
            "vt": "SELECT book.title FROM order_line INNER JOIN book AS T2 ON T1.book_id = T2.book_id ORDER BY order_line.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of books from the 'book' table that have been ordered, sorted by the price of the order lines. The placeholder in the LIMIT clause allows the user to specify how many book titles they want to retrieve."
        },
        {
            "sample_id": 6046,
            "vt": "SELECT book.title FROM book INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id INNER JOIN cust_order AS T3 ON T3.order_id = T2.order_id INNER JOIN customer AS T4 ON T4.customer_id = T3.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of books ordered by a specific customer identified by their first and last name. The query joins multiple tables: 'book' to get the book titles, 'order_line' to link books to orders, 'cust_order' to connect orders to customers, and 'customer' to filter by the customer's name. The placeholders in the WHERE clause represent the customer's first and last names."
        },
        {
            "sample_id": 6098,
            "vt": "SELECT COUNT(*) FROM book INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE publisher.publisher_name = '[placeholder-type:string]' AND STRFTIME('%Y', book.publication_date) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of books from the 'book' table that are published by a specific publisher and were published in a specific year. The placeholders represent the publisher's name and the publication year."
        },
        {
            "sample_id": 5977,
            "vt": "SELECT COUNT(*) FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE author.author_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of books written by a specific author from the 'book' table. It joins the 'book_author' table to link books to their authors and filters the results based on the author's name using a placeholder for string values."
        },
        {
            "sample_id": 6004,
            "vt": "SELECT address.street_name, address.city FROM cust_order INNER JOIN address AS T2 ON T1.dest_address_id = T2.address_id GROUP BY address.street_number, address.street_name, address.city ORDER BY COUNT(cust_order.dest_address_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of street names and cities from the 'address' table that are associated with customer orders. It joins the 'cust_order' table with the 'address' table to link each order to its destination address. The results are grouped by street number, street name, and city to aggregate the data, and are ordered by the count of orders for each destination address. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 6030,
            "vt": "SELECT customer.first_name, customer.last_name FROM customer WHERE customer.last_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of customers from the 'customer' table whose last names match a specific pattern. The placeholder in the WHERE clause represents the last name pattern to filter the results."
        },
        {
            "sample_id": 5945,
            "vt": "SELECT customer.first_name, customer.last_name FROM customer WHERE customer.email = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of customers from the 'customer' table who have a specific email address. The placeholder in the WHERE clause represents the customer's email."
        },
        {
            "sample_id": 5971,
            "vt": "SELECT publisher.publisher_name FROM book INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE book.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of publishers from the 'publisher' table for books that match a specific title from the 'book' table. The join operation links the two tables based on the publisher's unique identifier, allowing for the association of each book with its respective publisher. The placeholder in the WHERE clause represents the title of the book being queried."
        },
        {
            "sample_id": 6106,
            "vt": "SELECT author.author_name FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id ORDER BY book.publication_date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of authors from the 'author' table who have written books listed in the 'book' table. It joins the 'book' table with the 'book_author' table to link books to their respective authors, and orders the results by the publication date of the books. The query limits the number of results returned based on a specified numeric placeholder."
        },
        {
            "sample_id": 5912,
            "vt": "SELECT COUNT(*) FROM book WHERE book.publisher_id = [placeholder-type:numeric] AND book.num_pages > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of books from the 'book' table that are published by a specific publisher and have a page count greater than a specified number. The placeholders represent the publisher's ID and the minimum number of pages required for the count."
        },
        {
            "sample_id": 5944,
            "vt": "SELECT book.title FROM book WHERE STRFTIME('%Y', book.publication_date) = '[placeholder-type:string]' ORDER BY book.publication_date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of books from the 'book' table that were published in a specific year. The placeholder in the WHERE clause represents the year of publication, while the LIMIT clause allows for specifying the maximum number of book titles to return, represented by a numeric placeholder."
        },
        {
            "sample_id": 6054,
            "vt": "SELECT COUNT(*) FROM order_status INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE order_status.status_value = '[placeholder-type:string]' AND STRFTIME('%Y', order_history.status_date) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of order histories that match a specific order status and year. It joins the 'order_status' table with the 'order_history' table on the 'status_id' to filter the results based on the provided status value and the year extracted from the status date."
        },
        {
            "sample_id": 5961,
            "vt": "SELECT author.author_name, publisher.publisher_name FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id INNER JOIN publisher AS T4 ON T4.publisher_id = T1.publisher_id WHERE book.publication_date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of authors and their corresponding publishers for books published on a specific date. The placeholders in the WHERE clause represent the publication date of the books."
        },
        {
            "sample_id": 6093,
            "vt": "SELECT publisher.publisher_name FROM book INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE book.isbn13 = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of publishers from the 'publisher' table for a specific book identified by its ISBN number. The query joins the 'book' table with the 'publisher' table using the publisher's ID to ensure that the correct publisher is associated with the book."
        },
        {
            "sample_id": 6025,
            "vt": "SELECT address.street_number FROM address",
            "ba": "The virtual table retrieves the street numbers from the 'address' table, which contains information about various addresses including their unique identifiers and street details."
        },
        {
            "sample_id": 5921,
            "vt": "SELECT book.title FROM book INNER JOIN book_language AS T2 ON T1.language_id = T2.language_id WHERE book_language.language_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of books from the 'book' table that are written in a specific language. The query joins the 'book' table with the 'book_language' table to filter the results based on the language name provided as a placeholder."
        },
        {
            "sample_id": 5985,
            "vt": "SELECT COUNT(*) FROM customer_address INNER JOIN address AS T2 ON T2.address_id = T1.address_id INNER JOIN country AS T3 ON T3.country_id = T2.country_id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customer addresses associated with a specific country. It joins the 'customer_address' table with the 'address' table to link addresses to customers, and further joins with the 'country' table to filter by the specified country name. The placeholder in the WHERE clause represents the name of the country being queried."
        },
        {
            "sample_id": 5952,
            "vt": "SELECT book.title FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE author.author_name = '[placeholder-type:string]' ORDER BY book.publication_date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of books from the 'book' table that are written by a specific author. It joins the 'book' table with the 'book_author' table to link books to their authors, and then further joins with the 'author' table to filter by the author's name. The results are ordered by the publication date of the books, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 5933,
            "vt": "SELECT book_language.language_name FROM book INNER JOIN book_language AS T2 ON T1.language_id = T2.language_id WHERE book.book_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the name of the language associated with a specific book from the 'book' table by joining it with the 'book_language' table. The placeholder in the WHERE clause represents the unique identifier of the book."
        },
        {
            "sample_id": 6077,
            "vt": "SELECT book.title FROM book_author INNER JOIN author AS T2 ON T1.author_id = T2.author_id INNER JOIN book AS T3 ON T3.book_id = T1.book_id WHERE author.author_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of books written by a specific author from the 'book' table. It joins the 'book_author' table with the 'author' table to filter the results based on the author's name, which is represented by a placeholder in the WHERE clause."
        },
        {
            "sample_id": 6011,
            "vt": "SELECT COUNT(*) FROM author WHERE author.author_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of authors from the 'author' table whose names match a specific pattern. The placeholder in the LIKE clause represents the author's name pattern to search for."
        },
        {
            "sample_id": 6063,
            "vt": "SELECT book.title FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE author.author_name = '[placeholder-type:string]' AND book.publication_date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of books from the 'book' table that are written by a specific author and published on a specific date. The placeholders in the WHERE clause represent the author's name and the publication date of the book."
        },
        {
            "sample_id": 5975,
            "vt": "SELECT address.street_name FROM address WHERE address.city = '[placeholder-type:string]'",
            "ba": "The virtual table describes the street names of addresses from the 'address' table that belong to a specific city. The placeholder in the WHERE clause represents the name of the city."
        },
        {
            "sample_id": 6041,
            "vt": "SELECT COUNT(*) FROM book INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE publisher.publisher_name = '[placeholder-type:string]' AND book.num_pages < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of books from the 'book' table that are published by a specific publisher and have a number of pages less than a specified value. The placeholders represent the publisher's name and the maximum number of pages for filtering the results."
        },
        {
            "sample_id": 5958,
            "vt": "SELECT SUM(shipping_method.cost) FROM customer INNER JOIN cust_order AS T2 ON T1.customer_id = T2.customer_id INNER JOIN shipping_method AS T3 ON T3.method_id = T2.shipping_method_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]' AND STRFTIME('%Y', cust_order.order_date) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total shipping cost for orders placed by a specific customer in a given year. It joins the 'customer' table with the 'cust_order' table to link customers to their orders, and then joins with the 'shipping_method' table to access the cost of the shipping methods used for those orders. The placeholders represent the customer's first name, last name, and the year of the order date."
        },
        {
            "sample_id": 6044,
            "vt": "SELECT CAST(SUM(CASE WHEN shipping_method.method_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM customer INNER JOIN cust_order AS T2 ON T1.customer_id = T2.customer_id INNER JOIN shipping_method AS T3 ON T3.method_id = T2.shipping_method_id WHERE customer.first_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average cost of orders placed by customers with a specific first name, using a specified shipping method. It sums the costs of orders that match the shipping method and divides by the total number of orders for that customer, providing a floating-point result."
        },
        {
            "sample_id": 5990,
            "vt": "SELECT STRFTIME('%Y', cust_order.order_date) FROM cust_order GROUP BY STRFTIME('%Y', cust_order.order_date) ORDER BY COUNT(STRFTIME('%Y', cust_order.order_date)) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the number of customer orders made each year from the 'cust_order' table. It groups the orders by year and counts how many orders were made in each year, allowing users to see trends in order volume over time. The placeholder in the LIMIT clause represents the maximum number of years to display."
        },
        {
            "sample_id": 6097,
            "vt": "SELECT DISTINCT book.title FROM book INNER JOIN book_language AS T2 ON T1.language_id = T2.language_id WHERE book_language.language_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct titles of books from the 'book' table that are written in a specific language. It joins the 'book' table with the 'book_language' table to filter the results based on the language name provided by the user."
        },
        {
            "sample_id": 6005,
            "vt": "SELECT STRFTIME('%J', order_history.status_date) - STRFTIME('%J', cust_order.order_date) FROM cust_order INNER JOIN order_history AS T2 ON T1.order_id = T2.order_id WHERE cust_order.order_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the difference in days between the order date and the status update date for a specific customer order. It retrieves this information by joining the 'cust_order' table with the 'order_history' table based on the order ID, allowing users to see how long it took for the order status to be updated after the order was placed."
        },
        {
            "sample_id": 6039,
            "vt": "SELECT cust_order.order_date FROM cust_order INNER JOIN order_line AS T2 ON T1.order_id = T2.order_id WHERE order_line.price = [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of order dates from the 'cust_order' table for orders that have a specific price in the 'order_line' table. The query uses an inner join to connect the 'cust_order' and 'order_line' tables based on the order ID, ensuring that only orders with the specified price are included."
        },
        {
            "sample_id": 5978,
            "vt": "SELECT author.author_name, book.title FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE book.num_pages > [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of authors and the titles of books from the 'book' table, filtered to show only those books that have a number of pages greater than a specified value. The query uses inner joins to connect the 'book', 'book_author', and 'author' tables, ensuring that only relevant records are retrieved based on the number of pages in each book."
        },
        {
            "sample_id": 5928,
            "vt": "SELECT address.city FROM address WHERE address.address_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the city associated with a specific address from the 'address' table. The placeholder in the WHERE clause represents the unique identifier of the address."
        },
        {
            "sample_id": 6102,
            "vt": "SELECT DISTINCT customer.email FROM order_line INNER JOIN cust_order AS T2 ON T2.order_id = T1.order_id INNER JOIN customer AS T3 ON T3.customer_id = T2.customer_id WHERE order_line.price BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct email addresses of customers who have placed orders with a price falling within a specified range. It joins the 'order_line' table with the 'cust_order' table to link orders to customers, ensuring that only unique email addresses are selected based on the price criteria."
        },
        {
            "sample_id": 5941,
            "vt": "SELECT CAST(SUM(CASE WHEN shipping_method.method_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM shipping_method INNER JOIN cust_order AS T2 ON T1.method_id = T2.shipping_method_id WHERE cust_order.order_date LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average cost of a specific shipping method for customer orders placed on a certain date. It sums the costs of the shipping method based on the provided method name and divides it by the total number of orders on that date, adjusting the result by a specified multiplier."
        },
        {
            "sample_id": 5946,
            "vt": "SELECT COUNT(*) FROM country INNER JOIN address AS T2 ON T1.country_id = T2.country_id INNER JOIN cust_order AS T3 ON T3.dest_address_id = T2.address_id WHERE country.country_name = '[placeholder-type:string]' AND STRFTIME('%Y', cust_order.order_date) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customer orders that were shipped to addresses in a specific country during a specified year. It joins the 'country' table with the 'address' table to link addresses to their respective countries, and then further joins with the 'cust_order' table to filter orders based on the destination address. The placeholders represent the country name and the year of the order date."
        },
        {
            "sample_id": 5989,
            "vt": "SELECT author.author_name FROM author WHERE author.author_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of authors from the 'author' table that match a specific pattern. The placeholder in the WHERE clause represents the search term for the author's name."
        },
        {
            "sample_id": 5925,
            "vt": "SELECT SUM(order_line.price) FROM order_line INNER JOIN cust_order AS T2 ON T2.order_id = T1.order_id INNER JOIN customer AS T3 ON T3.customer_id = T2.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total price of all orders placed by a specific customer identified by their first and last names. It aggregates the prices from the 'order_line' table, joining it with the 'cust_order' table to link orders to customers, and filters the results based on the customer's first and last names using placeholders for these string values."
        },
        {
            "sample_id": 5947,
            "vt": "SELECT COUNT(*) FROM customer INNER JOIN cust_order AS T2 ON T1.customer_id = T2.customer_id INNER JOIN shipping_method AS T3 ON T3.method_id = T2.shipping_method_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]' AND shipping_method.method_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of orders placed by a specific customer using a specific shipping method. It joins the 'customer' table with the 'cust_order' table to link customers to their orders, and then joins the 'shipping_method' table to filter by the chosen shipping method. The placeholders represent the customer's first name, last name, and the shipping method's name."
        },
        {
            "sample_id": 6008,
            "vt": "SELECT author.author_name FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE book.num_pages < (SELECT AVG(book.num_pages) FROM book)",
            "ba": "The virtual table retrieves the names of authors who have written books with fewer pages than the average number of pages across all books. It joins the 'book' table with the 'book_author' table to link books to their respective authors, and it uses a subquery to calculate the average number of pages in the 'book' table."
        },
        {
            "sample_id": 5994,
            "vt": "SELECT COUNT(*) FROM publisher WHERE publisher.publisher_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of publishers from the 'publisher' table whose names match a specific pattern. The placeholder in the LIKE clause represents the name pattern of the publisher."
        },
        {
            "sample_id": 6103,
            "vt": "SELECT book.isbn13 FROM book INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE order_line.price = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the ISBN numbers of books from the 'book' table that have been ordered at a specific price. It joins the 'book' table with the 'order_line' table to filter the results based on the price of the order line, using a placeholder for the numeric value of the price."
        },
        {
            "sample_id": 6083,
            "vt": "SELECT COUNT(*) FROM order_line INNER JOIN cust_order AS T2 ON T2.order_id = T1.order_id INNER JOIN customer AS T3 ON T3.customer_id = T2.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the total number of order lines from the 'order_line' table for a specific customer identified by their first and last name. It joins the 'cust_order' table to link orders to customers and filters the results based on the customer's first and last names using placeholders."
        },
        {
            "sample_id": 5936,
            "vt": "SELECT COUNT(book.title) FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE author.author_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of books written by a specific author from the 'book' table. It joins the 'book_author' table to link books to their authors and filters the results based on the author's name using a placeholder for string values."
        },
        {
            "sample_id": 6076,
            "vt": "SELECT COUNT(*) FROM book_author INNER JOIN author AS T2 ON T1.author_id = T2.author_id WHERE author.author_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of books written by a specific author from the 'book_author' table, joining it with the 'author' table to filter by the author's name. The placeholder in the WHERE clause represents the author's name."
        },
        {
            "sample_id": 6033,
            "vt": "SELECT customer.first_name, customer.last_name FROM address INNER JOIN customer_address AS T2 ON T1.address_id = T2.address_id INNER JOIN customer AS T3 ON T3.customer_id = T2.customer_id WHERE address.city = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of customers from the 'customer' table who have addresses in a specific city. The query joins the 'address' table with the 'customer_address' table to link customers to their addresses, and filters the results based on the specified city using a placeholder for string values."
        },
        {
            "sample_id": 5939,
            "vt": "SELECT COUNT(*) FROM country INNER JOIN address AS T2 ON T1.country_id = T2.country_id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of addresses associated with a specific country from the 'country' and 'address' tables. It uses a join to connect the two tables based on the country ID, filtering the results to only include addresses from the specified country name."
        },
        {
            "sample_id": 5934,
            "vt": "SELECT customer.first_name, customer.last_name FROM customer INNER JOIN cust_order AS T2 ON T1.customer_id = T2.customer_id GROUP BY customer.first_name, customer.last_name ORDER BY COUNT(*) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of customers from the 'customer' table who have placed orders. It joins the 'customer' table with the 'cust_order' table to count the number of orders for each customer, grouping the results by their names. The placeholder in the LIMIT clause represents the maximum number of customers to return based on their order count."
        },
        {
            "sample_id": 5956,
            "vt": "SELECT COUNT(*) FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id INNER JOIN publisher AS T4 ON T4.publisher_id = T1.publisher_id WHERE author.author_name = '[placeholder-type:string]' AND publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of books from the 'book' table that are associated with a specific author and publisher. It joins the 'book' table with the 'book_author' table to link books to their authors, and then further joins with the 'author' table to filter by a specific author's name. Additionally, it joins with the 'publisher' table to filter by a specific publisher's name. The placeholders in the WHERE clause represent the author's name and the publisher's name."
        },
        {
            "sample_id": 5998,
            "vt": "SELECT author.author_name FROM author INNER JOIN book_author AS T2 ON T1.author_id = T2.author_id GROUP BY author.author_name ORDER BY COUNT(book_author.author_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of authors from the 'author' table who have written books, along with the count of books they have authored. The results are grouped by author name and ordered by the number of books in descending order, with a limit on the number of authors returned based on a specified numeric placeholder."
        },
        {
            "sample_id": 6016,
            "vt": "SELECT COUNT(*) FROM book INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE book.title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of times a specific book, identified by its title, has been ordered. It retrieves data from the 'book' table and joins it with the 'order_line' table to correlate the book's title with its order occurrences."
        },
        {
            "sample_id": 6034,
            "vt": "SELECT customer.email FROM customer INNER JOIN cust_order AS T2 ON T1.customer_id = T2.customer_id INNER JOIN shipping_method AS T3 ON T3.method_id = T2.shipping_method_id WHERE shipping_method.method_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the email addresses of customers who have placed orders using a specific shipping method. It joins the 'customer' table with the 'cust_order' table to link customers to their orders, and further joins the 'shipping_method' table to filter the results based on the specified shipping method name."
        },
        {
            "sample_id": 6003,
            "vt": "SELECT book.title FROM order_line INNER JOIN book AS T2 ON T1.book_id = T2.book_id GROUP BY book.title ORDER BY COUNT(order_line.book_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of books from the 'book' table that have been ordered, along with the count of how many times each book has been ordered. The results are grouped by book title and ordered by the number of orders in descending order, with a limit on the number of titles returned based on a specified numeric placeholder."
        },
        {
            "sample_id": 6050,
            "vt": "SELECT author.author_name FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE book.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of authors from the 'author' table for books that match a specific title in the 'book' table. It uses inner joins to connect the 'book' table with the 'book_author' table and then with the 'author' table, ensuring that only authors of the specified book title are selected."
        },
        {
            "sample_id": 6060,
            "vt": "SELECT book.num_pages FROM book WHERE book.title = '[placeholder-type:string]'",
            "ba": "The virtual table provides the number of pages for a specific book from the 'book' table based on its title. The placeholder in the WHERE clause represents the title of the book being queried."
        },
        {
            "sample_id": 6051,
            "vt": "SELECT publisher.publisher_name FROM book INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE book.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of publishers from the 'book' table based on a specific book title. The placeholder in the WHERE clause represents the title of the book for which the publisher's name is being queried."
        },
        {
            "sample_id": 5960,
            "vt": "SELECT COUNT(*) FROM book INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE author.author_name = '[placeholder-type:string]' AND book.num_pages < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of books from the 'book' table that are written by a specific author and have a page count less than a specified number. It joins the 'book' table with the 'book_author' table to link books to their authors, and then filters the results based on the author's name and the number of pages in the book."
        },
        {
            "sample_id": 6007,
            "vt": "SELECT CAST(SUM(CASE WHEN shipping_method.method_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM cust_order INNER JOIN order_line AS T2 ON T1.order_id = T2.order_id INNER JOIN shipping_method AS T3 ON T3.method_id = T1.shipping_method_id",
            "ba": "The virtual table calculates the average price of orders based on a specific shipping method from the 'cust_order' table. It sums the prices from the 'order_line' table where the shipping method matches a specified name, and divides this sum by the total number of orders to get the average. The placeholders represent the shipping method name, price values, and a multiplier for further calculations."
        },
        {
            "sample_id": 5986,
            "vt": "SELECT COUNT(*) FROM order_status INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE order_status.status_value = '[placeholder-type:string]' AND STRFTIME('%Y', order_history.status_date) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of order histories that match a specific order status and year. It joins the 'order_status' table with the 'order_history' table on the 'status_id' to filter the results based on the provided status value and the year extracted from the status date."
        }
    ],
    "app_store": [
        {
            "sample_id": 2538,
            "vt": "SELECT COUNT(user_reviews.sentiment) FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE playstore.installs = '[placeholder-type:string]' AND user_reviews.sentiment = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of user reviews for applications in the 'playstore' table that have a specific number of installs and a specified sentiment rating. It joins the 'playstore' table with the 'user_reviews' table based on the application name, allowing for filtering based on both the install count and the sentiment of the reviews."
        },
        {
            "sample_id": 2574,
            "vt": "SELECT AVG(playstore.rating), CAST(COUNT(CASE WHEN user_reviews.sentiment = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(user_reviews.sentiment) FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE playstore.genres = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rating of applications from the 'playstore' table and the proportion of user reviews with a specific sentiment for apps belonging to a certain genre. The placeholders represent the sentiment type and genre of the app."
        },
        {
            "sample_id": 2559,
            "vt": "SELECT CAST(SUM(CASE WHEN SUBSTRING('[placeholder-type:string]', -[placeholder-type:numeric]) > '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(playstore.app) FROM playstore WHERE playstore.type = '[placeholder-type:string]' AND playstore.rating >= [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average of a specific numeric value from the 'playstore' table, based on certain conditions. It sums up values conditionally based on the last characters of a string and divides by the count of applications that meet the specified type and rating criteria. The placeholders represent the dynamic values that can be adjusted by the user to filter the results accordingly."
        },
        {
            "sample_id": 2520,
            "vt": "SELECT playstore.app FROM playstore WHERE playstore.price = [placeholder-type:numeric] ORDER BY CAST(REPLACE(REPLACE(playstore.installs, ',', ''), '+', '') AS INT) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the applications from the 'playstore' table that are priced at a specific amount. The results are ordered by the number of installs, which is converted to an integer for accurate sorting. The query also limits the number of results returned based on a specified limit."
        },
        {
            "sample_id": 2540,
            "vt": "SELECT SUM(user_reviews.sentiment_polarity) FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE playstore.price = (SELECT MAX(playstore.price) FROM playstore)",
            "ba": "The virtual table calculates the total sentiment polarity score of user reviews for the app with the highest price in the 'playstore' table. It joins the 'playstore' table with the 'user_reviews' table based on the app name, and filters the results to only include the app that has the maximum price."
        },
        {
            "sample_id": 2560,
            "vt": "SELECT DISTINCT playstore.genres FROM playstore WHERE playstore.app = '[placeholder-type:string]'",
            "ba": "The virtual table lists all unique genres associated with a specific application from the 'playstore' table. The placeholder in the WHERE clause represents the name of the application for which the genres are being queried."
        },
        {
            "sample_id": 2554,
            "vt": "SELECT AVG(playstore.reviews) FROM playstore WHERE playstore.rating = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of user reviews for applications in the 'playstore' table that have a specific overall user rating. The placeholder in the WHERE clause represents the rating value to filter the applications accordingly."
        },
        {
            "sample_id": 2537,
            "vt": "SELECT playstore.app FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE playstore.type = '[placeholder-type:string]' AND user_reviews.sentiment = '[placeholder-type:string]' GROUP BY playstore.app ORDER BY COUNT(user_reviews.sentiment) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the applications from the 'playstore' table that are of a specific type (either 'Paid' or 'Free') and have received user reviews with a specific sentiment (either 'Positive', 'Negative', or 'Neutral'). The results are grouped by application name and ordered by the count of reviews, allowing the user to limit the number of applications returned based on their preference."
        },
        {
            "sample_id": 2529,
            "vt": "SELECT playstore.app, user_reviews.sentiment_polarity FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App ORDER BY playstore.price * CAST(REPLACE(REPLACE(playstore.installs, ',', ''), '+', '') AS INT) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the application names along with their corresponding sentiment polarity scores from user reviews. It combines data from the 'playstore' and 'user_reviews' tables using an inner join on the app name. The results are ordered by the product of the app's price and the number of installs, which is converted to an integer after removing commas and the '+' sign. A placeholder is used to limit the number of results returned."
        },
        {
            "sample_id": 2569,
            "vt": "SELECT MAX(user_reviews.sentiment_polarity), playstore.genres FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE playstore.app = '[placeholder-type:string]' AND user_reviews.sentiment_polarity > [placeholder-type:numeric] GROUP BY playstore.genres",
            "ba": "The virtual table retrieves the maximum sentiment polarity score for user reviews of a specific app from the 'playstore' table, grouped by the genres of the app. It filters the results to include only those reviews with a sentiment polarity greater than a specified numeric value."
        },
        {
            "sample_id": 2519,
            "vt": "SELECT COUNT(playstore.app) FROM playstore WHERE playstore.rating = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of applications in the 'playstore' table that have a specific user rating. The placeholder in the WHERE clause represents the rating value being queried."
        },
        {
            "sample_id": 2516,
            "vt": "SELECT AVG(user_reviews.sentiment_polarity), playstore.\"content rating\" FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE playstore.app = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average sentiment polarity of user reviews for a specific app from the 'user_reviews' table, while also retrieving the content rating of that app from the 'playstore' table. The query uses an INNER JOIN to combine data from both tables based on the app name, allowing for a comprehensive view of user sentiment and content rating."
        },
        {
            "sample_id": 2534,
            "vt": "SELECT COUNT(user_reviews.app) FROM user_reviews WHERE user_reviews.app = '[placeholder-type:string]' AND user_reviews.sentiment = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of user reviews for a specific application from the 'user_reviews' table, filtered by the application's name and the sentiment of the reviews. The placeholders represent the app's name and the sentiment type, allowing users to specify which app and sentiment they are interested in."
        },
        {
            "sample_id": 2521,
            "vt": "SELECT DISTINCT playstore.app FROM playstore ORDER BY playstore.reviews LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct application names from the 'playstore' table, ordered by the number of user reviews. The placeholder in the LIMIT clause allows the user to specify the maximum number of applications to retrieve."
        },
        {
            "sample_id": 2527,
            "vt": "SELECT DISTINCT playstore.app, user_reviews.sentiment FROM user_reviews WHERE playstore.app IN (SELECT playstore.app FROM playstore WHERE CAST(SUBSTRING('Last Updated', -4, 4) AS INT) < 2015)",
            "ba": "The virtual table provides a list of distinct applications along with their corresponding user sentiments from the 'user_reviews' table. It filters the applications based on their last updated year, specifically selecting those that were last updated before 2015."
        },
        {
            "sample_id": 2542,
            "vt": "SELECT playstore.app FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE playstore.genres = '[placeholder-type:string]' GROUP BY playstore.app ORDER BY SUM(user_reviews.sentiment_subjectivity) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the applications from the 'playstore' table that belong to a specific genre. It joins the 'playstore' table with the 'user_reviews' table to aggregate the sentiment subjectivity scores of user reviews for each app. The results are grouped by application name and ordered by the total sentiment subjectivity score, with a limit on the number of applications returned."
        },
        {
            "sample_id": 2530,
            "vt": "SELECT AVG(playstore.rating), COUNT(CASE WHEN user_reviews.sentiment = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE playstore.category = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rating of applications from the 'playstore' table and counts the number of user reviews with a specific sentiment for apps in a particular category. The placeholders represent the sentiment type and the app category."
        },
        {
            "sample_id": 2557,
            "vt": "SELECT playstore.app, AVG(user_reviews.sentiment_polarity) FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE user_reviews.sentiment <> '[placeholder-type:string]' GROUP BY playstore.app",
            "ba": "The virtual table provides the average sentiment polarity score for each application listed in the 'playstore' table, based on user reviews from the 'user_reviews' table. It filters out reviews that have a specific sentiment value, represented by a placeholder, and groups the results by application name."
        },
        {
            "sample_id": 2535,
            "vt": "SELECT DISTINCT playstore.app FROM playstore WHERE playstore.installs = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct application names from the 'playstore' table that have a specific number of installs. The placeholder in the WHERE clause represents the number of installs for filtering the results."
        },
        {
            "sample_id": 2539,
            "vt": "SELECT DISTINCT playstore.\"content rating\" FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE user_reviews.translated_review LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct content ratings of applications from the 'playstore' table based on user reviews that contain a specific phrase. It joins the 'playstore' table with the 'user_reviews' table to filter the results according to the translated user reviews."
        },
        {
            "sample_id": 2545,
            "vt": "SELECT COUNT(user_reviews.sentiment) FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE playstore.genres = '[placeholder-type:string]' AND user_reviews.sentiment = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of user reviews for applications in a specific genre and with a specific sentiment from the 'playstore' and 'user_reviews' tables. The placeholders represent the genre of the app and the sentiment of the reviews."
        },
        {
            "sample_id": 2562,
            "vt": "SELECT AVG(playstore.price) FROM playstore WHERE '[placeholder-type:string]' = '[placeholder-type:string]' AND playstore.genres = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average price of applications from the 'playstore' table that belong to a specific category and genre. The placeholders represent the category and genre of the apps being queried."
        },
        {
            "sample_id": 2565,
            "vt": "SELECT AVG(user_reviews.sentiment_polarity), playstore.rating FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE playstore.app = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average sentiment polarity of user reviews for a specific app from the 'user_reviews' table and retrieves the overall user rating of that app from the 'playstore' table. The placeholder in the WHERE clause represents the name of the app being queried."
        },
        {
            "sample_id": 2522,
            "vt": "SELECT COUNT(user_reviews.app), playstore.category FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE playstore.app = '[placeholder-type:string]' AND user_reviews.sentiment = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of user reviews for a specific application from the 'playstore' table, categorized by the application's category. It filters the results based on the application's name and the sentiment of the user reviews, allowing users to analyze how many reviews exist for a particular app and how they are categorized based on user sentiment."
        },
        {
            "sample_id": 2556,
            "vt": "SELECT CAST(COUNT(CASE WHEN (SELECT COUNT(CASE WHEN user_reviews.sentiment = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) - COUNT(CASE WHEN user_reviews.sentiment = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) FROM user_reviews GROUP BY App) > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(user_reviews.sentiment) FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE playstore.rating = [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average of user sentiment for apps in the 'playstore' table based on their ratings. It counts the number of positive and negative sentiments from the 'user_reviews' table, applies a condition to filter by a specific rating, and uses placeholders for the sentiment type and numeric values to allow for dynamic querying."
        },
        {
            "sample_id": 2524,
            "vt": "SELECT playstore.app, user_reviews.translated_review FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE playstore.rating = [placeholder-type:numeric]",
            "ba": "The virtual table describes the application names and their corresponding user reviews from the 'playstore' and 'user_reviews' tables. The query filters the results to include only those applications that have a specific overall user rating, represented by a numeric placeholder."
        },
        {
            "sample_id": 2546,
            "vt": "SELECT playstore.app FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE playstore.installs = '[placeholder-type:string]' AND user_reviews.translated_review = '[placeholder-type:string]' GROUP BY playstore.app ORDER BY COUNT(user_reviews.translated_review) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the applications from the 'playstore' table that have a specific number of installs and a specific user review. The query joins the 'playstore' table with the 'user_reviews' table based on the application name, filtering results based on the number of installs and the translated user review. The results are grouped by application name and ordered by the count of user reviews, with a limit on the number of results returned."
        },
        {
            "sample_id": 2531,
            "vt": "SELECT playstore.rating FROM playstore WHERE playstore.app = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the overall user rating of a specific application from the 'playstore' table. The placeholder in the WHERE clause represents the name of the application being queried."
        },
        {
            "sample_id": 2543,
            "vt": "SELECT user_reviews.translated_review FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE playstore.\"content rating\" = '[placeholder-type:string]' ORDER BY playstore.rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves user reviews for applications from the 'playstore' table, specifically filtering by the content rating of the app. It joins the 'user_reviews' table to access the translated reviews associated with each app. The results are ordered by the app's rating and limited to a specified number of entries."
        },
        {
            "sample_id": 2515,
            "vt": "SELECT DISTINCT playstore.app, playstore.category FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE user_reviews.sentiment_polarity = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of unique applications along with their categories from the 'playstore' table, filtered by the sentiment polarity of user reviews. The placeholder in the WHERE clause represents the sentiment polarity score that is used to filter the results."
        },
        {
            "sample_id": 2514,
            "vt": "SELECT COUNT(playstore.rating), playstore.rating FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE playstore.app = '[placeholder-type:string]' AND user_reviews.sentiment = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of the ratings for a specific application from the 'playstore' table, while also joining with the 'user_reviews' table to filter based on user sentiment. The placeholders represent the application name and the sentiment type."
        },
        {
            "sample_id": 2548,
            "vt": "SELECT CAST(COUNT(CASE WHEN playstore.\"content rating\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(playstore.app) FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE user_reviews.translated_review = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted percentage of apps with a specific content rating from the 'playstore' table, based on user reviews from the 'user_reviews' table. It counts the number of apps that match the specified content rating and divides it by the total number of apps, then multiplies by a specified numeric value for scaling. The placeholder in the WHERE clause represents a specific translated user review."
        },
        {
            "sample_id": 2523,
            "vt": "SELECT DISTINCT playstore.app, playstore.installs FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE user_reviews.sentiment_polarity > [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of unique applications along with their install counts from the 'playstore' table, filtered by user reviews that have a sentiment polarity score greater than a specified threshold. This allows users to identify popular apps that are positively received based on user sentiment."
        },
        {
            "sample_id": 2564,
            "vt": "SELECT DISTINCT playstore.app, playstore.installs FROM playstore INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE user_reviews.sentiment_polarity = [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of unique applications along with their install counts from the 'playstore' table, filtered by the sentiment polarity of user reviews from the 'user_reviews' table. The placeholder in the WHERE clause represents the sentiment polarity score that is used to filter the results."
        }
    ],
    "trains": [
        {
            "sample_id": 697,
            "vt": "SELECT trains.id FROM trains INNER JOIN (SELECT train_id, MAX(position) AS carsNum FROM cars GROUP BY train_id) AS T2 ON T1.id = T2.train_id WHERE trains.direction = '[placeholder-type:string]' AND (SELECT train_id, MAX(position) AS carsNum FROM cars GROUP BY train_id).carsnum < [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of trains from the 'trains' table that are running in a specified direction and have fewer cars than a given number. It uses a subquery to find the maximum position of cars associated with each train, ensuring that only those trains with a car count below the specified threshold are selected."
        },
        {
            "sample_id": 720,
            "vt": "SELECT SUM(CASE WHEN trains.direction = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM trains INNER JOIN (SELECT train_id, COUNT(id) FROM cars WHERE roof = 'none' GROUP BY train_id HAVING COUNT(id) = 1) AS T2 ON T1.id = T2.train_id",
            "ba": "The virtual table calculates the total number of cars with a specific roof type for trains running in a specified direction. It uses a subquery to count the cars with an open roof ('none') for each train, filtering to include only those trains that have exactly one such car. The outer query then sums these counts based on the direction of the trains, which is provided as a placeholder."
        },
        {
            "sample_id": 693,
            "vt": "SELECT cars.train_id FROM cars WHERE cars.shape IN ('[placeholder-type:string]', '[placeholder-type:string]') GROUP BY cars.train_id",
            "ba": "The virtual table retrieves the train IDs from the 'cars' table where the shape of the cars matches specific criteria. The query groups the results by train ID to ensure that each train is listed only once, regardless of how many cars it has with the specified shapes."
        },
        {
            "sample_id": 701,
            "vt": "SELECT trains.direction FROM cars INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE cars.shape = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the direction of trains associated with cars that have a specific shape. It joins the 'cars' table with the 'trains' table based on the train_id, allowing us to filter the results based on the shape of the cars."
        },
        {
            "sample_id": 714,
            "vt": "SELECT SUM(cars.wheels) FROM cars WHERE cars.len = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of wheels from the 'cars' table for cars of a specific length. The placeholder in the WHERE clause represents the length of the cars being queried."
        },
        {
            "sample_id": 696,
            "vt": "SELECT SUM(CASE WHEN cars.shape IN ('[placeholder-type:string]', '[placeholder-type:string]') THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM cars INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE trains.direction = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of cars based on their shapes from the 'cars' table, while joining with the 'trains' table to filter by the direction of the trains. The query uses placeholders for specific shapes and numeric values to determine the count of cars that match the specified criteria. The direction of the trains is also specified using a placeholder."
        },
        {
            "sample_id": 729,
            "vt": "SELECT DISTINCT T3.load_shape FROM (SELECT load_shape, train_id FROM cars WHERE position = 1 ORDER BY train_id DESC) AS T3 UNION ALL SELECT T4.load_shape FROM (SELECT load_shape, train_id FROM cars WHERE position = 1 ORDER BY train_id DESC LIMIT 1) AS T4 UNION ALL SELECT (CAST(COUNT(DISTINCT CASE WHEN T2.direction = 'east' THEN T2.id ELSE NULL END) AS FLOAT) * 100 / COUNT(DISTINCT T2.id)) FROM cars AS T1 INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE T1.position = 1 AND T1.load_shape = (SELECT T4.load_shape FROM (SELECT load_shape, train_id FROM cars AS T WHERE position = 1 ORDER BY train_id DESC LIMIT 1) AS T4)",
            "ba": "The virtual table provides information about the load shapes of cars that are positioned at the head of the trains, along with a calculation of the percentage of trains heading east that have a specific load shape. It combines distinct load shapes from the head cars and calculates the percentage of eastbound trains with the most recent load shape."
        },
        {
            "sample_id": 721,
            "vt": "SELECT trains.direction FROM trains INNER JOIN (SELECT train_id, COUNT(id) AS carsNum FROM cars GROUP BY train_id HAVING carsNum = 3) AS T2 ON T1.id = T2.train_id GROUP BY trains.direction",
            "ba": "The virtual table retrieves the direction of trains that have exactly three cars associated with them. It does this by first counting the number of cars for each train and filtering those counts to only include trains with three cars. Then, it joins this result with the trains table to get the corresponding direction of those trains."
        },
        {
            "sample_id": 726,
            "vt": "SELECT SUM(CASE WHEN trains.direction = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM cars INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE cars.wheels = [placeholder-type:numeric] AND cars.roof = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total sum of a specific numeric value based on the direction of trains and certain attributes of the cars. It joins the 'cars' and 'trains' tables on the train ID, filtering the results by the number of wheels and the type of roof of the cars. The placeholders represent the direction of the trains, a numeric value to sum, and the roof type of the cars."
        },
        {
            "sample_id": 710,
            "vt": "SELECT COUNT(cars.id) FROM cars WHERE cars.shape = '[placeholder-type:string]' AND cars.len = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cars from the 'cars' table that have a specific shape and length. The placeholders in the WHERE clause represent the shape and length of the cars being queried."
        },
        {
            "sample_id": 724,
            "vt": "SELECT trains.direction FROM cars INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE cars.load_num = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the direction of trains associated with cars that have a specific load number. It joins the 'cars' table with the 'trains' table based on the train_id, allowing us to filter the results based on the load number of the cars."
        },
        {
            "sample_id": 700,
            "vt": "SELECT trains.direction FROM cars INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE cars.load_num = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the direction of trains associated with cars that have a specific load number. It joins the 'cars' table with the 'trains' table based on the train_id, allowing us to filter the results based on the load number of the cars."
        },
        {
            "sample_id": 712,
            "vt": "SELECT cars.load_shape FROM cars WHERE cars.shape = '[placeholder-type:string]' AND cars.len = '[placeholder-type:string]'",
            "ba": "The virtual table describes the load shapes of cars from the 'cars' table that have a specific shape and length. The placeholders in the WHERE clause represent the car's shape and length."
        },
        {
            "sample_id": 711,
            "vt": "SELECT COUNT(trains.id) FROM trains WHERE trains.direction = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of trains from the 'trains' table that are running in a specific direction. The placeholder in the WHERE clause represents the direction of the trains, which can be either east or west."
        },
        {
            "sample_id": 727,
            "vt": "SELECT trains.direction FROM trains INNER JOIN (SELECT train_id, MAX(position) AS trailPosi FROM cars GROUP BY train_id) AS T2 ON T1.id = T2.train_id WHERE (SELECT train_id, MAX(position) AS trailPosi FROM cars GROUP BY train_id).trailposi <= [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the direction of trains from the 'trains' table that have cars positioned at or below a specified maximum position. It uses a subquery to find the maximum position of cars for each train and joins this result with the 'trains' table to filter based on the maximum position condition."
        },
        {
            "sample_id": 728,
            "vt": "SELECT CAST(COUNT(CASE WHEN T2.trailPosi >= 4 THEN T1.id ELSE NULL END) AS FLOAT) * 100 / COUNT(T1.id) FROM trains AS T1 INNER JOIN (SELECT train_id, MAX(position) AS trailPosi FROM cars GROUP BY train_id) AS T2 ON T1.id = T2.train_id UNION ALL SELECT T1.direction FROM trains AS T1 INNER JOIN (SELECT train_id, MAX(position) AS trailPosi FROM cars AS t GROUP BY train_id) AS T2 ON T1.id = T2.train_id AND T2.trailPosi >= 4",
            "ba": "The virtual table calculates the percentage of trains that have cars positioned at the tail (position 4) and also retrieves the direction of those trains. It does this by first counting the number of cars in each train that are at position 4, then calculating the percentage of such cars relative to the total number of cars in that train. Additionally, it selects the direction of trains that have at least one car at position 4."
        },
        {
            "sample_id": 690,
            "vt": "SELECT COUNT(trains.id) FROM trains WHERE trains.direction = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of trains from the 'trains' table that are running in a specific direction. The placeholder in the WHERE clause represents the direction of the trains, which can be either east or west."
        },
        {
            "sample_id": 713,
            "vt": "SELECT trains.id FROM trains WHERE trains.direction = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of trains from the 'trains' table based on their running direction. The placeholder in the WHERE clause represents the direction of the trains, which can be either east or west."
        },
        {
            "sample_id": 719,
            "vt": "SELECT COUNT((SELECT T1.train_id FROM cars AS T1 INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE T1.position = 1 AND T2.direction = 'east' AND T1.shape = 'rectangle' GROUP BY T1.train_id).train_id) FROM (SELECT cars.train_id FROM cars AS T1 INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE T1.position = 1 AND T2.direction = 'east' AND T1.shape = 'rectangle' GROUP BY T1.train_id) AS t",
            "ba": "The virtual table counts the number of unique trains that have a specific configuration of cars. It filters for cars that are in the head position (position 1), belong to trains running in the east direction, and have a rectangular shape. The query uses a subquery to first identify the relevant train IDs based on these criteria, and then counts the distinct train IDs from that result."
        },
        {
            "sample_id": 715,
            "vt": "SELECT trains.direction FROM trains GROUP BY trains.direction ORDER BY COUNT(trains.id)",
            "ba": "The virtual table retrieves the direction of trains from the 'trains' table, grouping the results by direction and ordering them based on the count of train IDs in each direction."
        },
        {
            "sample_id": 699,
            "vt": "SELECT SUM(CASE WHEN (SELECT train_id, COUNT(id) AS longCarsNum FROM cars WHERE len = 'long' GROUP BY train_id).longcarsnum > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM trains INNER JOIN (SELECT train_id, COUNT(id) AS longCarsNum FROM cars WHERE len = 'long' GROUP BY train_id) AS T2 ON T1.id = T2.train_id WHERE trains.direction = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of long cars in trains based on their direction. It uses a subquery to count the number of long cars for each train and checks if this count exceeds a specified threshold. The result is then summed up for all trains that match the given direction."
        },
        {
            "sample_id": 691,
            "vt": "SELECT COUNT(cars.id) FROM cars WHERE cars.train_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of cars associated with a specific train in the 'cars' table. The placeholder in the WHERE clause represents the unique identifier of the train."
        },
        {
            "sample_id": 704,
            "vt": "SELECT SUM(CASE WHEN cars.roof = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM cars INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE trains.direction = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of cars based on their roof type from the 'cars' table, while joining with the 'trains' table to filter by the direction of the trains. The placeholders represent the specific roof type and the direction of the trains."
        },
        {
            "sample_id": 694,
            "vt": "SELECT COUNT(cars.id) FROM cars WHERE cars.train_id = [placeholder-type:numeric] AND cars.roof = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cars associated with a specific train and having a particular roof type. The placeholders represent the train's unique identifier and the type of roof."
        }
    ],
    "works_cycles": [
        {
            "sample_id": 7393,
            "vt": "SELECT person.persontype FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.gender = '[placeholder-type:string]' AND employee.maritalstatus = '[placeholder-type:string]' AND STRFTIME('%Y-%m-%d', employee.hiredate) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' GROUP BY person.persontype ORDER BY COUNT(person.persontype) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the type of persons associated with employees from the 'employee' table, filtering based on gender and marital status. It also restricts the results to those hired within a specific date range. The results are grouped by person type and ordered by the count of each type, limiting the output to a specified number of records."
        },
        {
            "sample_id": 7428,
            "vt": "SELECT CASE WHEN COUNT(specialoffer.description) >= [placeholder-type:numeric] THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM specialoffer INNER JOIN SpecialOfferProduct AS T2 ON T1.SpecialOfferID = T2.SpecialOfferID INNER JOIN Product AS T3 ON T2.ProductID = T3.ProductID WHERE product.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a conditional count of special offers associated with a specific product. It checks if the number of special offers for the given product name meets or exceeds a specified threshold. If it does, it returns one string; otherwise, it returns another string. The placeholders represent the threshold count and the product name."
        },
        {
            "sample_id": 7267,
            "vt": "SELECT DISTINCT vendor.name FROM product INNER JOIN ProductVendor AS T2 ON T1.ProductID = T2.ProductID INNER JOIN ProductSubcategory AS T3 ON T1.ProductSubcategoryID = T3.ProductSubcategoryID INNER JOIN Vendor AS T4 ON T2.BusinessEntityID = T4.BusinessEntityID WHERE product.makeflag = [placeholder-type:numeric] AND product.style = '[placeholder-type:string]' AND productsubcategory.name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct names of vendors who supply products that meet specific criteria. It filters products based on whether they are manufactured in-house or purchased, their style, and the subcategory name. The placeholders allow users to specify the manufacturing flag, product style, and subcategory name dynamically."
        },
        {
            "sample_id": 7437,
            "vt": "SELECT person.businessentityid FROM person WHERE person.title = '[placeholder-type:string]' AND person.firstname = '[placeholder-type:string]' AND person.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier for a person from the 'person' table based on their title, first name, and last name. The placeholders in the WHERE clause represent the specific title, first name, and last name of the person being queried."
        },
        {
            "sample_id": 7431,
            "vt": "SELECT CAST(SUM([placeholder-type:numeric] * (STRFTIME('%Y', employeedepartmenthistory.enddate) - STRFTIME('%Y', employeedepartmenthistory.startdate)) + [placeholder-type:numeric] * (STRFTIME('%m', employeedepartmenthistory.enddate) - STRFTIME('%m', employeedepartmenthistory.startdate)) + STRFTIME('%d', employeedepartmenthistory.enddate) - STRFTIME('%d', employeedepartmenthistory.startdate)) AS FLOAT) / COUNT(employeedepartmenthistory.businessentityid) FROM employeedepartmenthistory INNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID WHERE department.name = '[placeholder-type:string]' AND NOT employeedepartmenthistory.enddate IS NULL",
            "ba": "The virtual table calculates the average duration of employment in a specific department by summing the total time employees have spent in that department and dividing it by the number of employees. The calculation considers the difference in years, months, and days between the start and end dates of employment, ensuring that only active records (where the end date is not null) are included. The placeholder in the WHERE clause represents the name of the department being queried."
        },
        {
            "sample_id": 7361,
            "vt": "SELECT transactionhistory.referenceorderid FROM product INNER JOIN TransactionHistory AS T2 ON T1.ProductID = T2.ProductID WHERE product.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the reference order IDs from the 'TransactionHistory' table for products that match a specified name. It joins the 'Product' table with the 'TransactionHistory' table based on the product identification number, allowing users to see which orders are associated with a particular product name."
        },
        {
            "sample_id": 7084,
            "vt": "SELECT DISTINCT productvendor.productid FROM productvendor WHERE productvendor.standardprice - productvendor.lastreceiptcost < [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct product IDs from the 'productvendor' table where the difference between the standard price and the last receipt cost is less than a specified numeric value. This can help identify products that are being sold at a loss or below their standard pricing."
        },
        {
            "sample_id": 7472,
            "vt": "SELECT [placeholder-type:numeric] * SUM(CASE WHEN location.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) / COUNT(workorderrouting.workorderid) FROM location INNER JOIN WorkOrderRouting AS T2 ON T1.LocationID = T2.LocationID",
            "ba": "The virtual table calculates the average quantity of products ordered from a specific location by summing the quantities of work orders associated with that location and dividing by the total number of work orders. The placeholders represent the specific location name and the quantities involved in the calculation."
        },
        {
            "sample_id": 7089,
            "vt": "SELECT customer.customerid FROM salesorderdetail INNER JOIN Customer AS T2 WHERE salesorderdetail.unitprice = [placeholder-type:numeric] AND salesorderdetail.orderqty = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique customer IDs from the 'Customer' table based on specific sales order details. It filters the results by matching the unit price and order quantity from the 'salesorderdetail' table with provided numeric values."
        },
        {
            "sample_id": 7312,
            "vt": "SELECT person.firstname, person.lastname FROM person INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.maritalstatus = '[placeholder-type:string]' AND employee.vacationhours < [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of individuals from the 'person' table who are employees with a specific marital status and have fewer vacation hours than a specified amount. The placeholders in the WHERE clause represent the marital status and the maximum number of vacation hours."
        },
        {
            "sample_id": 7037,
            "vt": "SELECT COUNT(employee.businessentityid) FROM employee INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.currentflag = [placeholder-type:numeric] AND employeepayhistory.rate <= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of employees from the 'employee' table who are currently active and have a pay rate less than or equal to a specified value. The placeholders represent the current status of the employee and the maximum pay rate."
        },
        {
            "sample_id": 7313,
            "vt": "SELECT person.firstname, person.lastname, STRFTIME('%Y', CURRENT_TIMESTAMP()) - STRFTIME('%Y', employee.birthdate) FROM person INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN EmployeeDepartmentHistory AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE employeedepartmenthistory.shiftid = [placeholder-type:numeric] ORDER BY STRFTIME('%Y', CURRENT_TIMESTAMP()) - STRFTIME('%Y', employee.birthdate) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of first and last names of employees along with their ages, calculated by subtracting their birth year from the current year. It retrieves this information from the 'person' and 'employee' tables, joining them based on the unique business entity ID. Additionally, it filters the results based on a specific shift ID from the 'EmployeeDepartmentHistory' table and limits the number of results returned."
        },
        {
            "sample_id": 7212,
            "vt": "SELECT creditcard.cardnumber FROM creditcard WHERE creditcard.expyear < [placeholder-type:numeric]",
            "ba": "The virtual table displays the credit card numbers from the 'creditcard' table for cards that have an expiration year earlier than a specified year. The placeholder in the WHERE clause represents the year to compare against."
        },
        {
            "sample_id": 7154,
            "vt": "SELECT unitmeasure.unitmeasurecode FROM product INNER JOIN UnitMeasure AS T2 ON T1.SizeUnitMeasureCode = T2.UnitMeasureCode OR T1.WeightUnitMeasureCode = T2.UnitMeasureCode WHERE product.productid = [placeholder-type:numeric] GROUP BY product.productid, unitmeasure.unitmeasurecode",
            "ba": "The virtual table retrieves the unit measure codes associated with a specific product from the 'product' table. It joins the 'product' table with the 'unitmeasure' table to get the unit measure codes for both size and weight of the product. The query filters results based on a specific product ID and groups the results by product ID and unit measure code."
        },
        {
            "sample_id": 7189,
            "vt": "SELECT COUNT(employee.businessentityid) FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE person.persontype = '[placeholder-type:string]' AND employee.maritalstatus = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees from the 'employee' table who meet specific criteria based on their person type and marital status. The placeholders in the WHERE clause represent the values for person type and marital status that can be specified by the user."
        },
        {
            "sample_id": 7131,
            "vt": "SELECT emailaddress.emailaddress FROM person INNER JOIN EmailAddress AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE person.persontype = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the email addresses of individuals from the 'person' table who belong to a specific type of person, such as a store contact, individual customer, sales person, employee, vendor contact, or general contact. The placeholder in the WHERE clause represents the type of person being queried."
        },
        {
            "sample_id": 7275,
            "vt": "SELECT COUNT(salesperson.businessentityid) FROM salesperson WHERE salesperson.bonus = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of salespersons from the 'salesperson' table who have a specific bonus amount. The placeholder in the WHERE clause represents the bonus value being queried."
        },
        {
            "sample_id": 7200,
            "vt": "SELECT emailaddress.emailaddress FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN EmailAddress AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE employee.gender = '[placeholder-type:string]' AND employee.maritalstatus = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the email addresses of employees from the 'employee' table, filtering based on their gender and marital status. The placeholders in the WHERE clause represent the specific gender and marital status criteria to be applied."
        },
        {
            "sample_id": 7162,
            "vt": "SELECT productvendor.lastreceiptcost - productvendor.standardprice FROM productvendor INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE product.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the profit margin for products by subtracting the standard price from the last receipt cost for each product vendor. It retrieves this information by joining the 'productvendor' table with the 'product' table based on the product identification number, and filters the results to include only those products that match a specified name."
        },
        {
            "sample_id": 7100,
            "vt": "SELECT productsubcategory.name FROM productsubcategory INNER JOIN Product AS T2 USING (ProductSubcategoryID) WHERE product.color = '[placeholder-type:string]' GROUP BY productsubcategory.name",
            "ba": "The virtual table describes the names of product subcategories from the 'productsubcategory' table, filtered by the color of the products in the 'product' table. The placeholder in the WHERE clause represents the specific color of the products being queried."
        },
        {
            "sample_id": 7449,
            "vt": "SELECT scrapreason.name FROM workorder INNER JOIN ScrapReason AS T2 ON T1.ScrapReasonID = T2.ScrapReasonID WHERE workorder.workorderid = [placeholder-type:numeric]",
            "ba": "The virtual table provides the names of scrap reasons associated with a specific work order from the 'workorder' table. The query uses an inner join to connect the 'workorder' table with the 'scrapreason' table based on the scrap reason ID, filtering results for a particular work order ID specified by a placeholder."
        },
        {
            "sample_id": 7170,
            "vt": "SELECT vendor.preferredvendorstatus FROM vendor INNER JOIN BusinessEntity AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE businessentity.rowguid = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the preferred vendor status from the 'vendor' table for a specific business entity identified by its unique row GUID."
        },
        {
            "sample_id": 7250,
            "vt": "SELECT employee.jobtitle FROM employee WHERE STRFTIME('%Y', employee.hiredate) = '[placeholder-type:string]' GROUP BY employee.hiredate ORDER BY COUNT(employee.jobtitle) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the job titles of employees from the 'employee' table who were hired in a specific year. The placeholder in the WHERE clause represents the year of hiring, while the LIMIT placeholder allows for specifying the maximum number of job titles to return."
        },
        {
            "sample_id": 7161,
            "vt": "SELECT productreview.rating FROM productreview INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE productreview.reviewername = '[placeholder-type:string]' AND product.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the ratings given by reviewers for specific products from the 'productreview' table. It joins with the 'Product' table to filter results based on the reviewer's name and the product's name, both of which are represented by placeholders for string values."
        },
        {
            "sample_id": 7109,
            "vt": "SELECT department.name FROM department WHERE department.groupname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of departments from the 'department' table that belong to a specific group. The placeholder in the WHERE clause represents the name of the group to filter the departments."
        },
        {
            "sample_id": 7335,
            "vt": "SELECT person.firstname, person.lastname FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', employee.birthdate) > '[placeholder-type:string]' ORDER BY employee.sickleavehours LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of employees from the 'employee' table who were born after a specific year. The query joins the 'employee' table with the 'person' table to retrieve the names, applying a filter based on the birth year and ordering the results by the number of sick leave hours available to each employee. The placeholders represent the year for filtering and the limit for the number of results returned."
        },
        {
            "sample_id": 7058,
            "vt": "SELECT employee.vacationhours FROM employeepayhistory INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.businessentityid = (SELECT employee.businessentityid FROM EmployeePayHistory ORDER BY Rate DESC LIMIT 1)",
            "ba": "The virtual table retrieves the vacation hours of the employee who has the highest salary from the 'EmployeePayHistory' table. It uses an inner join to connect the 'Employee' table with the 'EmployeePayHistory' table based on the business entity ID, and filters the results to only include the employee with the maximum salary."
        },
        {
            "sample_id": 7002,
            "vt": "SELECT product.name, shoppingcartitem.quantity FROM product INNER JOIN ShoppingCartItem AS T2 ON T1.ProductID = T2.ProductID WHERE shoppingcartitem.shoppingcartid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products along with their quantities from the shopping cart. It retrieves data from the 'product' table and joins it with the 'shoppingcartitem' table based on the product identification number. The placeholder in the WHERE clause represents the specific shopping cart identification number."
        },
        {
            "sample_id": 7426,
            "vt": "SELECT product.name FROM specialoffer INNER JOIN SpecialOfferProduct AS T2 ON T1.SpecialOfferID = T2.SpecialOfferID INNER JOIN Product AS T3 ON T2.ProductID = T3.ProductID WHERE specialoffer.description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of products that are associated with a specific special offer from the 'specialoffer' table. The query uses an INNER JOIN to connect the 'specialoffer' table with the 'SpecialOfferProduct' table and the 'Product' table, filtering results based on the description of the special offer provided as a placeholder."
        },
        {
            "sample_id": 7140,
            "vt": "SELECT address.addressline1, address.addressline2 FROM address INNER JOIN BusinessEntityAddress AS T2 ON T1.AddressID = T2.AddressID WHERE businessentityaddress.businessentityid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and second lines of addresses from the 'address' table for a specific business entity. The placeholder in the WHERE clause represents the unique identifier for the business entity."
        },
        {
            "sample_id": 7375,
            "vt": "SELECT purchaseorderheader.totaldue FROM purchaseorderheader ORDER BY purchaseorderheader.freight LIMIT [placeholder-type:numeric] OFFSET [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the total due amount from the purchase orders in the 'purchaseorderheader' table, sorted by the freight cost. The placeholders allow for limiting the number of results returned and specifying an offset for pagination."
        },
        {
            "sample_id": 7073,
            "vt": "SELECT COUNT(employee.businessentityid) FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN EmployeePayHistory AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE employee.maritalstatus = '[placeholder-type:string]' AND person.namestyle = [placeholder-type:numeric] AND employeepayhistory.rate = (SELECT employeepayhistory.rate FROM EmployeePayHistory ORDER BY Rate DESC LIMIT 1)",
            "ba": "The virtual table counts the number of employees from the 'employee' table who meet specific criteria. It filters employees based on their marital status and name style, and only includes those whose pay rate matches the highest pay rate recorded in the 'EmployeePayHistory' table."
        },
        {
            "sample_id": 7387,
            "vt": "SELECT vendor.name, vendor.creditrating FROM productvendor INNER JOIN Vendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE productvendor.averageleadtime = [placeholder-type:numeric] ORDER BY productvendor.lastreceiptcost - productvendor.standardprice LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of vendor names and their credit ratings from the 'Vendor' table, filtered by the average lead time of products supplied by those vendors. The results are ordered by the profit margin calculated as the difference between the last receipt cost and the standard price of the products, and limited to a specified number of results."
        },
        {
            "sample_id": 7367,
            "vt": "SELECT productvendor.lastreceiptcost - productvendor.standardprice FROM product INNER JOIN ProductVendor AS T2 ON T1.ProductID = T2.ProductID WHERE product.name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the profit margin for products by subtracting the standard price from the last receipt cost. It retrieves data from the 'product' table and joins it with the 'productvendor' table to access the necessary pricing information. The query filters products based on a specified name using a placeholder for string values."
        },
        {
            "sample_id": 7256,
            "vt": "SELECT purchaseorderdetail.unitprice, vendor.name FROM purchaseorderdetail INNER JOIN PurchaseOrderHeader AS T2 ON T1.PurchaseOrderID = T2.PurchaseOrderID INNER JOIN Vendor AS T3 ON T2.VendorID = T3.BusinessEntityID ORDER BY purchaseorderdetail.unitprice LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of unit prices for products from purchase order details along with the corresponding vendor names. It retrieves data by joining the 'purchaseorderdetail' table with the 'purchaseorderheader' and 'vendor' tables, ensuring that the unit price is associated with the correct vendor. The results are ordered by unit price and limited to a specified number of entries."
        },
        {
            "sample_id": 7266,
            "vt": "SELECT AVG(employeepayhistory.rate) FROM employee INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.gender = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average salary of employees from the 'employee' table, filtered by gender. The placeholder in the WHERE clause represents the gender of the employees whose average salary is being calculated."
        },
        {
            "sample_id": 7236,
            "vt": "SELECT address.city, address.addressline1 FROM businessentityaddress INNER JOIN AddressType AS T2 ON T1.AddressTypeID = T2.AddressTypeID INNER JOIN Address AS T3 ON T1.AddressID = T3.AddressID WHERE businessentityaddress.businessentityid = [placeholder-type:numeric] AND addresstype.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the city and first line of the address from the 'businessentityaddress' table, filtered by a specific business entity ID and address type name. The placeholders represent the business entity ID as a numeric value and the address type name as a string value."
        },
        {
            "sample_id": 7114,
            "vt": "SELECT employee.jobtitle FROM employee ORDER BY employee.sickleavehours LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the job titles of employees from the 'employee' table, sorted by the number of sick leave hours they have available. The placeholder in the LIMIT clause represents the maximum number of job titles to return."
        },
        {
            "sample_id": 7157,
            "vt": "SELECT COUNT(employee.businessentityid) FROM document INNER JOIN Employee AS T2 ON T1.Owner = T2.BusinessEntityID WHERE employee.jobtitle = '[placeholder-type:string]' AND employee.birthdate = '[placeholder-type:string]' AND document.documentsummary IS NULL",
            "ba": "The virtual table counts the number of employees who are associated with documents that have no summary. It filters the employees based on their job title and birthdate, ensuring that only those matching the specified criteria are included in the count."
        },
        {
            "sample_id": 7417,
            "vt": "SELECT employeedepartmenthistory.departmentid FROM person INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE person.firstname = '[placeholder-type:string]' AND person.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the department ID from the 'Department' table for a specific person by joining the 'person' table with the 'EmployeeDepartmentHistory' and 'Department' tables. The query filters results based on the first and last name of the person, which are provided as placeholders."
        },
        {
            "sample_id": 7414,
            "vt": "SELECT person.firstname, person.lastname FROM person INNER JOIN PersonCreditCard AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN CreditCard AS T3 ON T2.CreditCardID = T3.CreditCardID WHERE creditcard.expyear = [placeholder-type:numeric] AND person.persontype = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of individuals from the 'person' table who have a credit card associated with them. The query filters results based on the expiration year of the credit card and the type of person, such as individual customers or vendors."
        },
        {
            "sample_id": 7220,
            "vt": "SELECT COUNT(salesorderheader.totaldue) FROM person INNER JOIN SalesOrderHeader AS T2 ON T1.ModifiedDate = T2.DueDate WHERE person.firstname = '[placeholder-type:string]' AND person.middlename = '[placeholder-type:string]' AND person.lastname = '[placeholder-type:string]' AND person.persontype = '[placeholder-type:string]'",
            "ba": "The virtual table counts the total due amounts from sales orders associated with a specific person identified by their first name, middle name, last name, and person type. It joins the 'person' table with the 'salesorderheader' table based on the modified date of the person and the due date of the sales order."
        },
        {
            "sample_id": 7408,
            "vt": "SELECT emailaddress.emailaddress FROM person INNER JOIN EmailAddress AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE person.firstname = '[placeholder-type:string]' AND person.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the email addresses of individuals from the 'person' table based on their first and last names. The query uses an inner join with the 'EmailAddress' table to link the person's business entity ID with their corresponding email address."
        },
        {
            "sample_id": 7347,
            "vt": "SELECT transactionhistory.transactionid FROM transactionhistory WHERE transactionhistory.transactiontype = '[placeholder-type:string]' ORDER BY transactionhistory.quantity LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves transaction IDs from the 'transactionhistory' table based on a specified transaction type. The results are ordered by the quantity of products involved in each transaction, and the number of records returned is limited by a numeric placeholder."
        },
        {
            "sample_id": 7401,
            "vt": "SELECT store.demographics FROM store WHERE store.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the demographic information of a specific store from the 'store' table based on the store's name. The placeholder in the WHERE clause represents the name of the store being queried."
        },
        {
            "sample_id": 7269,
            "vt": "SELECT product.class, product.productline, product.listprice FROM shoppingcartitem INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID GROUP BY shoppingcartitem.productid ORDER BY SUM(shoppingcartitem.quantity) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the product class, product line, and list price of products that have been added to shopping carts. It aggregates the data by product ID, allowing users to see which products are most frequently added to carts based on the total quantity. The results are ordered by the total quantity of each product in descending order, and the output is limited to a specified number of records."
        },
        {
            "sample_id": 7121,
            "vt": "SELECT contacttype.name FROM contacttype INNER JOIN BusinessEntityContact AS T2 ON T1.ContactTypeID = T2.ContactTypeID WHERE businessentitycontact.businessentityid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of contact types associated with a specific business entity from the 'contacttype' table. The placeholder in the WHERE clause represents the unique identifier for the business entity."
        },
        {
            "sample_id": 7036,
            "vt": "SELECT person.firstname, person.middlename, person.lastname, employee.hiredate FROM employee INNER JOIN Person AS T2 USING (BusinessEntityID) WHERE employee.jobtitle = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first name, middle name, last name, and hire date of employees from the 'employee' table who hold a specific job title. The placeholder in the WHERE clause represents the job title of the employee."
        },
        {
            "sample_id": 7245,
            "vt": "SELECT AVG(employeepayhistory.rate) FROM employee INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID GROUP BY employee.gender",
            "ba": "The virtual table calculates the average salary of employees grouped by their gender from the 'employee' and 'employeepayhistory' tables. The placeholder in the query represents the employee's gender, allowing for analysis of salary differences between male and female employees."
        },
        {
            "sample_id": 7333,
            "vt": "SELECT vendor.name FROM product INNER JOIN ProductVendor AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Vendor AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE product.productnumber = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of vendors associated with a specific product identified by its product number. The query joins the 'product' table with the 'ProductVendor' table to link products with their respective vendors, filtering the results based on the provided product number."
        },
        {
            "sample_id": 7006,
            "vt": "SELECT product.name FROM product INNER JOIN TransactionHistory AS T2 ON T1.ProductID = T2.ProductID WHERE product.class = '[placeholder-type:string]' ORDER BY transactionhistory.quantity LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products from the 'product' table that belong to a specific class. It joins the 'product' table with the 'TransactionHistory' table to filter products based on their transaction history. The placeholder in the WHERE clause represents the product class, and the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 7255,
            "vt": "SELECT [placeholder-type:numeric] - STRFTIME('%Y', employee.birthdate), employeepayhistory.rate FROM employee INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.jobtitle = '[placeholder-type:string]' ORDER BY [placeholder-type:numeric] - STRFTIME('%Y', employee.birthdate) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of employees' ages and their corresponding pay rates from the 'employee' and 'EmployeePayHistory' tables. It filters the results based on a specific job title and orders the employees by their age in descending order, limiting the number of results returned."
        },
        {
            "sample_id": 7419,
            "vt": "SELECT person.firstname, person.lastname FROM person INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE department.name = '[placeholder-type:string]' ORDER BY employeedepartmenthistory.enddate - employeedepartmenthistory.startdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of employees from the 'person' table who have worked in a specific department. It joins the 'EmployeeDepartmentHistory' table to filter employees based on their department history and the 'Department' table to specify the department name. The results are ordered by the duration of employment in that department, and a limit is applied to the number of records returned."
        },
        {
            "sample_id": 7391,
            "vt": "SELECT productvendor.minorderqty FROM vendor INNER JOIN ProductVendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE vendor.activeflag = [placeholder-type:numeric] ORDER BY productvendor.minorderqty LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the minimum order quantity from the 'ProductVendor' table for vendors that are currently active. The query joins the 'vendor' table with the 'ProductVendor' table based on the business entity ID, filtering for vendors with a specific active status. The results are ordered by the minimum order quantity and limited to a specified number of records."
        },
        {
            "sample_id": 7209,
            "vt": "SELECT COUNT(employee.businessentityid) FROM employee WHERE employee.maritalstatus = '[placeholder-type:string]' AND employee.birthdate < '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees from the 'employee' table who are either married or single based on their marital status and were born before a specified date. The placeholders represent the marital status and the birth date criteria."
        },
        {
            "sample_id": 7027,
            "vt": "SELECT salesterritory.name FROM salesterritory WHERE salesterritory.countryregioncode = '[placeholder-type:string]' AND (salesterritory.name = '[placeholder-type:string]' OR salesterritory.name = '[placeholder-type:string]') ORDER BY salesterritory.saleslastyear LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of sales territories from the 'salesterritory' table that belong to a specific country or region, and matches either of two specified territory names. The results are ordered by the sales figures from the previous year and limited to a specified number of records."
        },
        {
            "sample_id": 7360,
            "vt": "SELECT contacttype.name FROM contacttype INNER JOIN BusinessEntityContact AS T2 ON T1.ContactTypeID = T2.ContactTypeID INNER JOIN Store AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE store.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of contact types associated with a specific store from the 'contacttype' table. The query joins the 'BusinessEntityContact' table to link contact types to business entities and further joins the 'Store' table to filter results based on the store's name. The placeholder in the WHERE clause represents the name of the store."
        },
        {
            "sample_id": 7301,
            "vt": "SELECT productreview.emailaddress FROM productreview INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE product.name = '[placeholder-type:string]' ORDER BY productreview.rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the email addresses of reviewers from the 'productreview' table for a specific product, identified by its name. The results are ordered by the rating given to the product, and a limit is applied to the number of email addresses returned."
        },
        {
            "sample_id": 7404,
            "vt": "SELECT product.name FROM product ORDER BY product.standardcost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of products from the 'product' table, ordered by their standard cost. The placeholder in the LIMIT clause allows the user to specify how many product names they want to retrieve."
        },
        {
            "sample_id": 7035,
            "vt": "SELECT person.firstname, person.middlename, person.lastname, employee.jobtitle FROM employee INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Person AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE employee.maritalstatus = '[placeholder-type:string]' AND employee.gender = '[placeholder-type:string]' ORDER BY employeepayhistory.rate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first name, middle name, last name, and job title of employees from the 'employee' table who meet specific marital status and gender criteria. The placeholders in the WHERE clause represent the marital status and gender of the employees, while the LIMIT clause allows for specifying the maximum number of records to return."
        },
        {
            "sample_id": 7070,
            "vt": "SELECT COUNT(employee.businessentityid) FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.currentflag = [placeholder-type:numeric] AND person.title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees from the 'employee' table who are currently active and have a specific title. The placeholders represent the current status of the employee (active or inactive) and the title of the employee."
        },
        {
            "sample_id": 7282,
            "vt": "SELECT product.name FROM productreview INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID GROUP BY productreview.productid ORDER BY COUNT(productreview.productreviewid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of product names from the 'product' table, which are associated with product reviews. It uses an inner join to connect the 'productreview' table with the 'product' table based on the product ID. The results are grouped by product ID to count the number of reviews for each product, and the output is ordered by the count of reviews in descending order. The limit placeholder allows users to specify how many product names they want to retrieve based on the number of reviews."
        },
        {
            "sample_id": 7003,
            "vt": "SELECT product.name FROM product INNER JOIN ShoppingCartItem AS T2 ON T1.ProductID = T2.ProductID WHERE shoppingcartitem.quantity > [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products from the 'product' table that are present in the shopping cart, filtered by a specified quantity of items in the shopping cart. The placeholder in the WHERE clause represents the minimum quantity of items that must be present in the shopping cart for the product to be included in the results."
        },
        {
            "sample_id": 7406,
            "vt": "SELECT COUNT(person.businessentityid) FROM person WHERE person.persontype = '[placeholder-type:string]' AND person.title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of persons from the 'person' table who match a specific person type and title. The placeholders represent the type of person and the title of the person being queried."
        },
        {
            "sample_id": 7093,
            "vt": "SELECT employee.jobtitle FROM employee INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employeedepartmenthistory.departmentid = [placeholder-type:numeric] ORDER BY employeedepartmenthistory.startdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of job titles for employees from the 'employee' table who are associated with a specific department. The query joins the 'employee' table with the 'EmployeeDepartmentHistory' table to filter employees based on their department ID. The results are ordered by the start date of their department history, and a limit is applied to the number of records returned."
        },
        {
            "sample_id": 7141,
            "vt": "SELECT creditcard.expyear FROM creditcard WHERE creditcard.creditcardid = [placeholder-type:numeric]",
            "ba": "The virtual table displays the expiration year of a credit card from the 'creditcard' table based on a specific credit card ID. The placeholder in the WHERE clause represents the unique identifier for the credit card."
        },
        {
            "sample_id": 7369,
            "vt": "SELECT employeepayhistory.rate FROM employeepayhistory WHERE employeepayhistory.payfrequency = [placeholder-type:numeric] ORDER BY employeepayhistory.rate LIMIT [placeholder-type:numeric] OFFSET [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the pay rates of employees from the 'employeepayhistory' table, filtered by a specific pay frequency. The results are ordered by the rate and can be limited to a certain number of entries with an option to skip a specified number of entries."
        },
        {
            "sample_id": 7009,
            "vt": "SELECT product.name, product.listprice FROM product WHERE product.class = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and list prices of products from the 'product' table that belong to a specific class. The placeholder in the WHERE clause represents the product class type."
        },
        {
            "sample_id": 7448,
            "vt": "SELECT [placeholder-type:numeric] / productlistpricehistory.listprice FROM product INNER JOIN ProductListPriceHistory AS T2 ON T1.ProductID = T2.ProductID WHERE product.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the ratio of a specified numeric value to the list price of a product from the 'ProductListPriceHistory' table. It joins the 'Product' table with the 'ProductListPriceHistory' table based on the product ID, and filters the results to include only the product with a specific name provided as a placeholder."
        },
        {
            "sample_id": 7158,
            "vt": "SELECT product.listprice FROM product INNER JOIN ProductListPriceHistory AS T2 ON T1.ProductID = T2.ProductID WHERE product.listprice - product.standardcost > [placeholder-type:numeric] AND STRFTIME('%Y-%m-%d', productlistpricehistory.startdate) >= '[placeholder-type:string]'",
            "ba": "The virtual table displays the list prices of products from the 'product' table that have a profit margin greater than a specified numeric value, and where the price history start date is on or after a specified date. The placeholders allow users to input their desired profit threshold and date for filtering the results."
        },
        {
            "sample_id": 7237,
            "vt": "SELECT product.name FROM specialofferproduct INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE specialofferproduct.specialofferid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products that are associated with a specific special offer from the 'specialofferproduct' table. The query uses an INNER JOIN to link the 'specialofferproduct' table with the 'Product' table based on the product identification number. The placeholder in the WHERE clause represents the unique identifier for the special offer."
        },
        {
            "sample_id": 7051,
            "vt": "SELECT document.title FROM document WHERE document.status = [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of documents from the 'document' table that have a specific processing status. The placeholder in the WHERE clause represents the status of the document, which can indicate whether it is pending approval, approved, or obsolete."
        },
        {
            "sample_id": 7321,
            "vt": "SELECT employeepayhistory.rate, (MAX(employeepayhistory.rate) - MIN(employeepayhistory.rate)) * [placeholder-type:numeric] / MAX(employeepayhistory.rate) FROM person INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE person.firstname = '[placeholder-type:string]' AND person.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the pay rate and the percentage change in pay for a specific employee identified by their first and last name. It retrieves the employee's pay history from the 'EmployeePayHistory' table, computes the difference between the maximum and minimum pay rates, and expresses this difference as a percentage of the maximum pay rate. The placeholders represent the employee's first and last names, as well as a numeric value for scaling the percentage change."
        },
        {
            "sample_id": 7260,
            "vt": "SELECT employeepayhistory.rate FROM employeepayhistory INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Person AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID ORDER BY employee.hiredate LIMIT [placeholder-type:numeric] OFFSET [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the pay rates of employees from the 'employeepayhistory' table, joining it with the 'Employee' and 'Person' tables to ensure that the correct employee information is associated with each pay rate. The results are ordered by the hire date of the employees, and pagination is applied using placeholders for limiting the number of results and specifying the offset."
        },
        {
            "sample_id": 7427,
            "vt": "SELECT COUNT(DISTINCT ProductID) FROM specialoffer INNER JOIN SpecialOfferProduct AS T2 ON T1.SpecialOfferID = T2.SpecialOfferID WHERE specialoffer.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct Product IDs associated with a specific special offer from the 'specialoffer' table. It joins the 'specialoffer' table with the 'SpecialOfferProduct' table to link special offers to their respective products. The placeholder in the WHERE clause represents the description of the special offer being queried."
        },
        {
            "sample_id": 7421,
            "vt": "SELECT creditcard.cardnumber FROM employeedepartmenthistory INNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID INNER JOIN CreditCard AS T3 ON T1.ModifiedDate = T3.ModifiedDate INNER JOIN PersonCreditCard AS T4 ON T3.CreditCardID = T4.CreditCardID WHERE department.name = '[placeholder-type:string]' AND NOT employeedepartmenthistory.enddate IS NULL",
            "ba": "The virtual table retrieves the credit card numbers associated with employees who have worked in a specific department and have not ended their employment in that department. The query joins the 'employeedepartmenthistory' table with the 'Department' table to filter by department name, and it also joins the 'CreditCard' and 'PersonCreditCard' tables to access credit card information."
        },
        {
            "sample_id": 7137,
            "vt": "SELECT CAST(SUM(CASE WHEN culture.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(culture.cultureid) FROM culture INNER JOIN ProductModelProductDescriptionCulture AS T2 ON T1.CultureID = T2.CultureID",
            "ba": "The virtual table calculates a weighted average based on the sum of a specific condition related to culture names and the total count of cultures. It uses a placeholder for the culture name to filter the results and another placeholder for a numeric value to adjust the final calculation. The query joins the 'culture' table with 'ProductModelProductDescriptionCulture' to ensure that only relevant cultures are considered in the calculation."
        },
        {
            "sample_id": 7049,
            "vt": "SELECT billofmaterials.unitmeasurecode FROM billofmaterials ORDER BY billofmaterials.perassemblyqty LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unit measure codes from the 'billofmaterials' table, which contains information about the components used in product assemblies. The results are ordered by the quantity of each component required for assembly, and the number of results returned is limited by a specified numeric placeholder."
        },
        {
            "sample_id": 7277,
            "vt": "SELECT transactionhistory.actualcost FROM transactionhistory WHERE transactionhistory.transactiontype = '[placeholder-type:string]' ORDER BY transactionhistory.actualcost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a view of the actual costs associated with transactions from the 'transactionhistory' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the type of transaction, while the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 7091,
            "vt": "SELECT vendor.creditrating FROM productvendor INNER JOIN Vendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE productvendor.standardprice = [placeholder-type:numeric] AND productvendor.averageleadtime = [placeholder-type:numeric] AND STRFTIME('%Y-%m-%d', productvendor.lastreceiptdate) = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the credit rating of vendors associated with products based on specific criteria. It filters the results from the 'productvendor' table by the standard price and average lead time of the products, and also checks the last receipt date of the products against a specified date."
        },
        {
            "sample_id": 7199,
            "vt": "SELECT person.lastname FROM employee INNER JOIN JobCandidate AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Person AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID WHERE employee.businessentityid IN ([placeholder-type:numeric], [placeholder-type:numeric])",
            "ba": "The virtual table describes the last names of employees who are also job candidates from the 'employee' table. It uses inner joins to connect the 'employee', 'JobCandidate', and 'Person' tables based on their unique identifiers. The placeholders in the WHERE clause represent specific business entity IDs that can be modified to filter the results accordingly."
        },
        {
            "sample_id": 7384,
            "vt": "SELECT department.name FROM shift INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.ShiftId = T2.ShiftId INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID GROUP BY employeedepartmenthistory.departmentid ORDER BY COUNT(shift.name = '[placeholder-type:string]') LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of departments from the 'Department' table, which are associated with shifts in the 'Shift' table. It uses a join with the 'EmployeeDepartmentHistory' table to link shifts to specific departments. The results are grouped by department ID and ordered by the count of shifts that match a specified name, with a limit on the number of results returned."
        },
        {
            "sample_id": 7062,
            "vt": "SELECT COUNT(employee.businessentityid) FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.gender = '[placeholder-type:string]' AND person.persontype = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees from the 'employee' table who match a specific gender and person type. The placeholders in the WHERE clause represent the gender and person type criteria that can be specified by the user."
        },
        {
            "sample_id": 7102,
            "vt": "SELECT CAST(SUM(CASE WHEN employee.vacationhours > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(employeepayhistory.businessentityid) FROM employeepayhistory INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.currentflag = [placeholder-type:numeric] AND employee.sickleavehours > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total vacation hours of active employees who have more sick leave hours than a specified amount. It sums the vacation hours of employees who meet the criteria and divides it by the count of their pay history records, adjusting the result based on a specified multiplier."
        },
        {
            "sample_id": 7398,
            "vt": "SELECT COUNT(specialoffer.specialofferid) FROM specialoffer WHERE specialoffer.type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of special offers from the 'specialoffer' table that match a specific type. The placeholder in the WHERE clause represents the type of special offer being queried."
        },
        {
            "sample_id": 7383,
            "vt": "SELECT SUM(purchaseorderheader.totaldue) FROM vendor INNER JOIN PurchaseOrderHeader AS T2 ON T1.BusinessEntityID = T2.VendorID WHERE vendor.creditrating = [placeholder-type:numeric] AND vendor.preferredvendorstatus = [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total amount due from purchase orders associated with vendors that meet specific credit rating and preferred vendor status criteria. It aggregates the total due from the 'PurchaseOrderHeader' table, filtered by the vendor's credit rating and their preferred vendor status."
        },
        {
            "sample_id": 7300,
            "vt": "SELECT SUM(CASE WHEN product.productline = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM productreview INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID GROUP BY productreview.productid HAVING COUNT(productreview.productreviewid) > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total sum of a specific product line from the 'product' table based on reviews from the 'productreview' table. It uses a conditional statement to sum values based on whether the product line matches a specified string placeholder. The results are grouped by product ID, and only those products with more than a specified number of reviews are included in the final output."
        },
        {
            "sample_id": 7399,
            "vt": "SELECT specialoffer.description FROM specialoffer WHERE specialoffer.type = '[placeholder-type:string]' ORDER BY specialoffer.discountpct LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the special offers available in the 'specialoffer' table, specifically focusing on the description of offers that belong to a certain type. The results are ordered by the discount percentage, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 7344,
            "vt": "SELECT COUNT(*) FROM billofmaterials WHERE billofmaterials.bomlevel = [placeholder-type:numeric] AND billofmaterials.enddate IS NULL",
            "ba": "The virtual table counts the number of bill of materials records from the 'billofmaterials' table where the BOM level matches a specified numeric value and the end date is null, indicating that these components are currently in use."
        },
        {
            "sample_id": 7423,
            "vt": "SELECT emailaddress.emailaddress FROM employeedepartmenthistory INNER JOIN EmailAddress AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID GROUP BY emailaddress.businessentityid ORDER BY COUNT(employeedepartmenthistory.departmentid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the email addresses of employees, grouped by their business entity ID, from the 'employeedepartmenthistory' and 'emailaddress' tables. It counts the number of departments each employee has been associated with and orders the results based on this count. The placeholder in the LIMIT clause allows for specifying the maximum number of email addresses to return."
        },
        {
            "sample_id": 7201,
            "vt": "SELECT product.color FROM product INNER JOIN ProductReview AS T2 ON T1.ProductID = T2.ProductID WHERE product.productid = [placeholder-type:numeric] OR [placeholder-type:numeric] OR [placeholder-type:numeric]",
            "ba": "The virtual table displays the colors of products from the 'product' table that have received reviews. It filters the results based on specific product IDs provided as placeholders."
        },
        {
            "sample_id": 7232,
            "vt": "SELECT person.firstname FROM person WHERE person.persontype = '[placeholder-type:string]' GROUP BY person.firstname ORDER BY COUNT(*) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first names of individuals from the 'person' table filtered by a specific type of person. The results are grouped by first name and ordered by the count of occurrences, with a limit on the number of results returned."
        },
        {
            "sample_id": 7122,
            "vt": "SELECT personphone.businessentityid FROM phonenumbertype INNER JOIN PersonPhone AS T2 ON T1.PhoneNumberTypeID = T2.PhoneNumberTypeID WHERE phonenumbertype.name = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the business entity IDs associated with a specific type of phone number from the 'PersonPhone' table. It joins the 'phonenumbertype' table to filter results based on the name of the phone number type, using a placeholder for the phone number type name and a limit on the number of results returned."
        },
        {
            "sample_id": 7165,
            "vt": "SELECT emailaddress.emailaddress FROM person INNER JOIN EmailAddress AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE person.firstname = '[placeholder-type:string]' AND person.middlename = '[placeholder-type:string]' AND person.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the email addresses of individuals from the 'person' table based on their first name, middle name, and last name. The query uses an inner join with the 'EmailAddress' table to link the person's business entity ID with their corresponding email address."
        },
        {
            "sample_id": 7294,
            "vt": "SELECT COUNT(DISTINCT T3.Name) FROM productvendor INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Vendor AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID WHERE product.name = '[placeholder-type:string]' AND vendor.creditrating = [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct names of vendors who supply a specific product with a given credit rating. The placeholders represent the product name and the vendor's credit rating, allowing users to filter the results based on their criteria."
        },
        {
            "sample_id": 7268,
            "vt": "SELECT employeepayhistory.payfrequency FROM employee INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.jobtitle = '[placeholder-type:string]' ORDER BY employee.hiredate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the pay frequency of employees from the 'employee' table who hold a specific job title. The results are ordered by the hire date of the employees, and the number of records returned is limited by a numeric placeholder."
        },
        {
            "sample_id": 7470,
            "vt": "SELECT workorder.workorderid FROM product INNER JOIN WorkOrder AS T2 ON T1.ProductID = T2.ProductID WHERE product.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of work orders associated with a specific product name from the 'product' table. It uses an inner join to connect the 'product' table with the 'workorder' table based on the product identification number, ensuring that only work orders related to the specified product are selected."
        },
        {
            "sample_id": 7418,
            "vt": "SELECT COUNT(person.businessentityid) FROM person INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE department.name = '[placeholder-type:string]' AND STRFTIME('%Y', employeedepartmenthistory.enddate) > '[placeholder-type:string]' AND STRFTIME('%Y', employeedepartmenthistory.startdate) < '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees from the 'person' table who have a history of working in a specific department. It joins the 'EmployeeDepartmentHistory' table to track the department history of each employee and the 'Department' table to filter by department name. The query also includes conditions to ensure that the employee's department history falls within a specified date range, using placeholders for the department name and the start and end years."
        },
        {
            "sample_id": 7082,
            "vt": "SELECT CAST(SUM(CASE WHEN employee.maritalstatus = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(employee.businessentityid) FROM employee WHERE SUBSTRING(employee.hiredate, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND employee.gender = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average salary of employees based on their marital status and gender. It sums the salaries of employees who match the specified marital status and gender, then divides by the total count of employees who were hired in a specific year, as indicated by the hire date substring. The placeholders represent the marital status, year of hire, and gender of the employees."
        },
        {
            "sample_id": 7341,
            "vt": "SELECT specialoffer.type FROM specialoffer WHERE specialoffer.category = '[placeholder-type:string]'",
            "ba": "The virtual table describes the types of special offers from the 'specialoffer' table that belong to a specific category. The placeholder in the WHERE clause represents the category of the special offer."
        },
        {
            "sample_id": 7213,
            "vt": "SELECT employeepayhistory.rate FROM employee INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', employee.hiredate) - STRFTIME('%Y', employee.birthdate) = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the salary rate of employees from the 'employee' table, joining it with the 'EmployeePayHistory' table to access their pay history. The query filters employees based on their age, calculated by subtracting the year of birth from the year of hire, using a numeric placeholder to specify the desired age difference."
        },
        {
            "sample_id": 7246,
            "vt": "SELECT CAST(SUM(CASE WHEN shift.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(employeedepartmenthistory.businessentityid) FROM shift INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.ShiftId = T2.ShiftId",
            "ba": "The virtual table calculates the average salary of employees working in a specific shift by summing their salaries and dividing by the total number of employees in that shift. The placeholders represent the shift name and the salary values."
        },
        {
            "sample_id": 7323,
            "vt": "SELECT AVG(STRFTIME('%Y', CURRENT_TIMESTAMP()) - STRFTIME('%Y', employee.birthdate)) FROM employee",
            "ba": "The virtual table calculates the average age of employees by subtracting their birth year from the current year. The result is derived from the 'employee' table, specifically using the 'birthdate' column to determine each employee's age."
        },
        {
            "sample_id": 7075,
            "vt": "SELECT personcreditcard.creditcardid FROM person INNER JOIN PersonCreditCard AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE person.persontype = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the credit card identification numbers associated with individuals from the 'person' table who have a specific type of person designation. The placeholder in the WHERE clause represents the type of person, such as individual customer or vendor contact."
        },
        {
            "sample_id": 7352,
            "vt": "SELECT COUNT(*) FROM shipmethod INNER JOIN SalesOrderHeader AS T2 USING (ShipMethodID) WHERE shipmethod.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of sales orders associated with a specific shipping method from the 'shipmethod' table. The placeholder in the WHERE clause represents the name of the shipping method being queried."
        },
        {
            "sample_id": 7308,
            "vt": "SELECT person.firstname, person.lastname FROM person WHERE person.persontype = '[placeholder-type:string]' ORDER BY person.businessentityid",
            "ba": "The virtual table describes the first and last names of individuals from the 'person' table who belong to a specific type of person. The placeholder in the WHERE clause represents the type of person, such as Store Contact, Individual, Sales person, Employee, Vendor contact, or General contact."
        },
        {
            "sample_id": 7193,
            "vt": "SELECT salesperson.businessentityid, SUM(salesperson.salesquota) FROM salesperson INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', salespersonquotahistory.quotadate) = '[placeholder-type:string]' GROUP BY salesperson.businessentityid ORDER BY SUM(salesperson.salesytd) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total sales quota for each salesperson from the 'salesperson' table, joining with the 'salespersonquotahistory' table to filter by a specific year. The results are grouped by the salesperson's unique identifier and ordered by their year-to-date sales total, with a limit on the number of results returned."
        },
        {
            "sample_id": 7452,
            "vt": "SELECT DISTINCT product.productid FROM productcosthistory INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE productcosthistory.standardcost < (SELECT SUM(productcosthistory.standardcost) / COUNT(productcosthistory.productid) FROM Product)",
            "ba": "The virtual table identifies distinct product IDs from the 'productcosthistory' table where the standard cost of the product is less than the average standard cost of all products. This is achieved by joining the 'productcosthistory' with the 'product' table to ensure that only valid product IDs are considered. The average standard cost is calculated using a subquery that sums the standard costs and divides by the count of product IDs."
        },
        {
            "sample_id": 7064,
            "vt": "SELECT person.namestyle FROM employeepayhistory INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE NOT employeepayhistory.rate IS NULL ORDER BY employeepayhistory.rate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the name style of employees from the 'Person' table based on their pay history. It filters out records where the pay rate is null and orders the results by the pay rate, limiting the output to a specified number of records."
        },
        {
            "sample_id": 7038,
            "vt": "SELECT department.name FROM department INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.DepartmentID = T2.DepartmentID ORDER BY employeedepartmenthistory.startdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of departments from the 'department' table, joining it with the 'EmployeeDepartmentHistory' table to filter the results based on the department's historical records. The results are ordered by the start date of the employee's department history, and a limit is applied to restrict the number of records returned."
        },
        {
            "sample_id": 7446,
            "vt": "SELECT productproductphoto.productid FROM productphoto INNER JOIN ProductProductPhoto AS T2 ON T1.ProductPhotoID = T2.ProductPhotoID WHERE productphoto.largephotofilename LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the product identification numbers from the 'productphoto' table, which contains images of products, by joining it with the 'ProductProductPhoto' table that associates products with their respective photos. The query filters the results based on a specified pattern in the 'largephotofilename' column, allowing users to search for products with large images that match a certain filename pattern."
        },
        {
            "sample_id": 7046,
            "vt": "SELECT address.postalcode FROM address ORDER BY address.modifieddate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves postal codes from the 'address' table, sorted by the last modified date of each address record. The result is limited to a specified number of entries, allowing users to view the most recently updated postal codes."
        },
        {
            "sample_id": 7026,
            "vt": "SELECT purchaseorderdetail.orderqty FROM purchaseorderdetail ORDER BY purchaseorderdetail.unitprice LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the ordered quantities of products from the 'purchaseorderdetail' table, sorted by the unit price of each product. The placeholder in the LIMIT clause allows for specifying the maximum number of records to return."
        },
        {
            "sample_id": 7019,
            "vt": "SELECT SUM(purchaseorderdetail.orderqty) FROM product INNER JOIN PurchaseOrderDetail AS T2 ON T1.ProductID = T2.ProductID WHERE product.productline = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total quantity of products ordered from the 'PurchaseOrderDetail' table, filtered by the product line specified. It joins the 'product' table to access the product line information and aggregates the order quantities based on that filter."
        },
        {
            "sample_id": 7139,
            "vt": "SELECT address.city, stateprovince.name, stateprovince.isonlystateprovinceflag FROM stateprovince INNER JOIN Address AS T2 ON T1.StateProvinceID = T2.StateProvinceID WHERE address.addressid = [placeholder-type:numeric]",
            "ba": "The virtual table provides a view of cities and their corresponding state or province names along with a flag indicating whether the state or province code exists. It retrieves this information by joining the 'stateprovince' table with the 'address' table based on the state province ID, filtered by a specific address ID."
        },
        {
            "sample_id": 7257,
            "vt": "SELECT employee.businessentityid, STRFTIME('%Y', employee.hiredate) - STRFTIME('%Y', employee.birthdate) FROM purchaseorderheader INNER JOIN Employee AS T2 ON T1.EmployeeID = T2.BusinessEntityID ORDER BY purchaseorderheader.totaldue LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of employee IDs along with their age calculated from the difference between their hire date and birth date. It retrieves this information by joining the 'purchaseorderheader' table with the 'employee' table based on the employee ID. The results are ordered by the total amount due from the purchase orders, and a limit is applied to restrict the number of records returned."
        },
        {
            "sample_id": 7388,
            "vt": "SELECT productvendor.lastreceiptcost - productvendor.standardprice, vendor.name FROM productvendor INNER JOIN Vendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE productvendor.maxorderqty = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the profit margin for products by subtracting the standard price from the last receipt cost for each vendor. It retrieves the vendor's name and displays the profit margin for products that have a specified maximum order quantity."
        },
        {
            "sample_id": 7234,
            "vt": "SELECT COUNT(salesorderdetail.orderqty) FROM salesorderdetail WHERE salesorderdetail.productid IN (SELECT salesorderdetail.productid FROM Product WHERE Name = 'Minipump')",
            "ba": "The virtual table counts the total quantity of orders for a specific product identified by its name from the 'salesorderdetail' table. It filters the results based on the product ID obtained from the 'Product' table where the product name matches a specified value."
        },
        {
            "sample_id": 7133,
            "vt": "SELECT COUNT(person.businessentityid) FROM person INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE person.persontype = '[placeholder-type:string]' AND employee.maritalstatus = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of persons from the 'person' table who are of a specific type and have a certain marital status. The placeholders in the WHERE clause represent the type of person and their marital status."
        },
        {
            "sample_id": 7253,
            "vt": "SELECT AVG([placeholder-type:numeric] - STRFTIME('%Y', employee.birthdate)) FROM person INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE person.persontype = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average age of individuals from the 'person' table who are of a specific type, by joining with the 'employee' table to access their birthdate. The placeholder in the WHERE clause represents the type of person being queried, such as 'Individual' or 'Employee'."
        },
        {
            "sample_id": 7031,
            "vt": "SELECT COUNT(product.productid) FROM product INNER JOIN BillOfMaterials AS T2 ON T1.ProductID = T2.ProductAssemblyID WHERE product.makeflag = [placeholder-type:numeric] AND product.daystomanufacture = [placeholder-type:numeric] AND billofmaterials.bomlevel = [placeholder-type:numeric] AND product.reorderpoint <= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of products from the 'product' table that meet specific criteria related to their manufacturing and inventory settings. It filters products based on whether they are manufactured in-house, the number of days required for manufacturing, the bill of materials level, and ensures that the reorder point is not exceeded."
        },
        {
            "sample_id": 7370,
            "vt": "SELECT COUNT(creditcard.creditcardid) FROM creditcard WHERE creditcard.cardtype = '[placeholder-type:string]' AND creditcard.expyear < [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of credit cards from the 'creditcard' table that match a specific card type and have an expiration year earlier than a specified year. The placeholders represent the card type and the expiration year respectively."
        },
        {
            "sample_id": 7134,
            "vt": "SELECT SUM(CASE WHEN culture.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN culture.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM culture INNER JOIN ProductModelProductDescriptionCulture AS T2 ON T1.CultureID = T2.CultureID WHERE culture.name = '[placeholder-type:string]' OR culture.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between two sums based on the culture names from the 'culture' table. It uses a conditional aggregation to sum numeric values associated with specific culture names, allowing for a comparison between two different cultures. The query joins the 'culture' table with the 'ProductModelProductDescriptionCulture' table to filter and aggregate the relevant data."
        },
        {
            "sample_id": 7010,
            "vt": "SELECT product.productline FROM product WHERE product.finishedgoodsflag = [placeholder-type:numeric] GROUP BY product.productline ORDER BY COUNT(product.finishedgoodsflag) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of product lines from the 'product' table that are marked as finished goods. It groups the results by product line and orders them based on the count of finished goods, allowing for a limit on the number of results returned."
        },
        {
            "sample_id": 7380,
            "vt": "SELECT product.name, productreview.rating FROM product INNER JOIN ProductReview AS T2 ON T1.ProductID = T2.ProductID WHERE product.daystomanufacture = (SELECT product.daystomanufacture FROM Product ORDER BY DaysToManufacture LIMIT 1) ORDER BY product.listprice - product.standardcost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names and ratings of products from the 'product' table that have the shortest manufacturing time. It joins the 'product' table with the 'productreview' table to get the ratings for each product. The query filters products based on the minimum days to manufacture, and it orders the results by the profit margin (list price minus standard cost). The number of results returned is limited by a numeric placeholder."
        },
        {
            "sample_id": 7028,
            "vt": "SELECT person.firstname, person.middlename, person.lastname FROM person INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Document AS T3 ON T3.Owner = T2.BusinessEntityID WHERE employee.jobtitle = '[placeholder-type:string]' AND document.documentlevel = [placeholder-type:numeric] AND document.status = [placeholder-type:numeric] GROUP BY person.firstname, person.middlename, person.lastname",
            "ba": "The virtual table retrieves the first name, middle name, and last name of individuals from the 'person' table who are also employees. It filters the results based on the job title of the employee, the document level, and the status of the document. The results are grouped by the names of the individuals."
        },
        {
            "sample_id": 7346,
            "vt": "SELECT salestaxrate.salestaxrateid FROM salestaxrate WHERE salestaxrate.name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier for sales tax rates from the 'salestaxrate' table where the tax rate description matches a specified pattern."
        },
        {
            "sample_id": 7425,
            "vt": "SELECT COUNT(employeedepartmenthistory.businessentityid) FROM employeedepartmenthistory INNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID WHERE department.groupname = '[placeholder-type:string]' AND STRFTIME('%Y', employeedepartmenthistory.startdate) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees in a specific department group for a given year based on their employment history. It joins the 'employeedepartmenthistory' table with the 'Department' table to filter by the department group name and the year of employment start date."
        },
        {
            "sample_id": 7340,
            "vt": "SELECT salesterritory.territoryid FROM salesterritory ORDER BY salesterritory.salesytd LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique identifiers for sales territories from the 'salesterritory' table, ordered by the year-to-date sales figures. The placeholder in the LIMIT clause allows for specifying the maximum number of territories to retrieve."
        },
        {
            "sample_id": 7314,
            "vt": "SELECT person.firstname, person.lastname FROM person INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN EmployeeDepartmentHistory AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID INNER JOIN Department AS T4 ON T3.DepartmentID = T4.DepartmentID WHERE STRFTIME('%Y', employee.hiredate) = '[placeholder-type:string]' AND department.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of employees from the 'person' table who were hired in a specific year and belong to a specific department. The placeholders in the WHERE clause represent the year of hiring and the department's name."
        },
        {
            "sample_id": 7163,
            "vt": "SELECT salesperson.bonus FROM salesperson INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE person.firstname = '[placeholder-type:string]' AND person.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the bonus information for salespersons from the 'salesperson' table, joining it with the 'person' table to filter based on the first and last names of the person. The placeholders in the WHERE clause represent the first and last names of the individual whose bonus is being queried."
        },
        {
            "sample_id": 7196,
            "vt": "SELECT person.lastname, employee.jobtitle FROM person INNER JOIN Document AS T2 ON T1.BusinessEntityID = T2.Owner INNER JOIN Employee AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID WHERE document.title = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of last names and job titles of individuals from the 'person' and 'employee' tables who are associated with a specific document title. The query uses inner joins to connect the 'person' table with the 'document' table based on the owner of the document and then further connects to the 'employee' table to retrieve job titles."
        },
        {
            "sample_id": 7223,
            "vt": "SELECT salesorderheader.shiptoaddressid FROM salesorderheader INNER JOIN Address AS T2 ON T1.BillToAddressID = T2.AddressID WHERE salesorderheader.salesorderid = [placeholder-type:numeric] GROUP BY salesorderheader.shiptoaddressid",
            "ba": "The virtual table retrieves the shipping address ID associated with a specific sales order from the 'salesorderheader' table. It joins the 'salesorderheader' table with the 'Address' table to link the billing address ID to the corresponding address details. The query groups the results by the shipping address ID to ensure unique entries for each sales order."
        },
        {
            "sample_id": 7331,
            "vt": "SELECT product.name FROM productvendor INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Vendor AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID WHERE productvendor.maxorderqty = [placeholder-type:numeric] AND product.standardcost > [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products from the 'product' table that are associated with vendors in the 'productvendor' table. It filters the results based on the maximum order quantity allowed for each vendor and the standard cost of the products, using placeholders for numeric values to specify these criteria."
        },
        {
            "sample_id": 7136,
            "vt": "SELECT businessentityaddress.businessentityid FROM address INNER JOIN BusinessEntityAddress AS T2 ON T1.AddressID = T2.AddressID WHERE address.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier for business entities associated with addresses in a specific city. It joins the 'address' table with the 'businessentityaddress' table to filter results based on the city name provided."
        },
        {
            "sample_id": 7435,
            "vt": "SELECT productcosthistory.productid FROM productcosthistory WHERE productcosthistory.startdate LIKE '[placeholder-type:string]' ORDER BY productcosthistory.standardcost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the product IDs from the 'productcosthistory' table where the start date matches a specified pattern. The results are ordered by the standard cost of the products, and a limit is applied to the number of records returned."
        },
        {
            "sample_id": 7290,
            "vt": "SELECT product.name FROM productlistpricehistory INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID GROUP BY product.name ORDER BY COUNT(productlistpricehistory.listprice) > [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of product names from the 'product' table, which are associated with their respective price history records in the 'productlistpricehistory' table. The results are grouped by product name and ordered based on the count of their list prices, filtered by a specified numeric threshold."
        },
        {
            "sample_id": 7345,
            "vt": "SELECT COUNT(document.documentnode) FROM document WHERE document.status = [placeholder-type:numeric] AND document.documentsummary IS NULL",
            "ba": "The virtual table counts the number of documents from the 'document' table that have a specific status and do not have a summary. The placeholder in the WHERE clause represents the status of the document."
        },
        {
            "sample_id": 7433,
            "vt": "SELECT (MAX(product.listprice) - MIN(product.listprice)) * [placeholder-type:numeric] / MIN(product.listprice) FROM product INNER JOIN ProductSubcategory AS T2 ON T1.ProductSubcategoryID = T2.ProductSubcategoryID INNER JOIN ProductCategory AS T3 ON T2.ProductCategoryID = T3.ProductCategoryID WHERE productcategory.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage change in the list price of products within a specific category. It does this by taking the difference between the maximum and minimum list prices of products, multiplying it by a placeholder for a numeric value, and then dividing by the minimum list price. The query joins the 'product' table with 'ProductSubcategory' and 'ProductCategory' to filter results based on the specified category name."
        },
        {
            "sample_id": 7078,
            "vt": "SELECT CAST(COUNT(CASE WHEN person.persontype = '[placeholder-type:string]' THEN person.persontype ELSE NULL END) AS FLOAT) / COUNT(person.persontype) FROM person INNER JOIN Employee AS T2 WHERE person.persontype = '[placeholder-type:string]' AND person.namestyle = [placeholder-type:numeric] AND employee.maritalstatus = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of a specific type of person from the 'person' table based on their name style and marital status. It counts the number of persons matching the specified type and divides it by the total count of persons to get a ratio. The placeholders represent the type of person, name style, and marital status respectively."
        },
        {
            "sample_id": 7132,
            "vt": "SELECT employee.jobtitle FROM person INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE person.firstname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the job titles of employees from the 'Employee' table who are associated with a specific person identified by their first name. The placeholder in the WHERE clause represents the first name of the person."
        },
        {
            "sample_id": 7235,
            "vt": "SELECT personcreditcard.businessentityid FROM creditcard INNER JOIN PersonCreditCard AS T2 ON T1.CreditCardID = T2.CreditCardID WHERE creditcard.cardnumber = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the business entity ID associated with a specific credit card number from the 'creditcard' table. It uses an inner join with the 'PersonCreditCard' table to link the credit card information to the corresponding person."
        },
        {
            "sample_id": 7467,
            "vt": "SELECT location.name FROM productinventory INNER JOIN Location AS T2 ON T1.LocationID = T2.LocationID WHERE productinventory.productid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of locations from the 'productinventory' table where a specific product is stored. The placeholder in the WHERE clause represents the product identification number."
        },
        {
            "sample_id": 7281,
            "vt": "SELECT productreview.reviewername FROM productreview WHERE productreview.rating = (SELECT productreview.rating FROM ProductReview ORDER BY Rating DESC LIMIT 1)",
            "ba": "The virtual table describes the names of reviewers from the 'productreview' table who have given the highest rating to a product. The placeholder in the WHERE clause represents the rating value, which is dynamically determined by a subquery that selects the maximum rating from all product reviews."
        },
        {
            "sample_id": 7403,
            "vt": "SELECT product.safetystocklevel FROM product WHERE product.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the safety stock level of a product from the 'product' table based on the product's name. The placeholder in the WHERE clause represents the specific name of the product being queried."
        },
        {
            "sample_id": 7348,
            "vt": "SELECT vendor.name FROM vendor WHERE vendor.preferredvendorstatus = [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of vendors from the 'vendor' table who have a specific preferred vendor status. The placeholders in the WHERE clause represent the preferred vendor status and the limit on the number of results returned."
        },
        {
            "sample_id": 7332,
            "vt": "SELECT person.firstname, person.lastname, employee.jobtitle FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.gender = '[placeholder-type:string]' AND employee.maritalstatus = '[placeholder-type:string]' ORDER BY employee.birthdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first name, last name, and job title of employees from the 'employee' table who meet specific gender and marital status criteria. The placeholders in the WHERE clause represent the gender and marital status of the employees, while the LIMIT clause allows for specifying the maximum number of records to return."
        },
        {
            "sample_id": 7222,
            "vt": "SELECT COUNT(customer.customerid) FROM salesterritory INNER JOIN Customer AS T2 ON T1.TerritoryID = T2.TerritoryID WHERE salesterritory.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers associated with a specific sales territory from the 'Customer' table. It joins the 'salesterritory' table to filter based on the territory name provided by the user."
        },
        {
            "sample_id": 7456,
            "vt": "SELECT productlistpricehistory.productid FROM productlistpricehistory WHERE productlistpricehistory.startdate LIKE '[placeholder-type:string]' ORDER BY productlistpricehistory.listprice LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the product IDs from the 'productlistpricehistory' table where the start date matches a specified pattern. The results are ordered by the list price, and a limit is applied to the number of records returned."
        },
        {
            "sample_id": 7142,
            "vt": "SELECT person.businessentityid FROM person WHERE person.firstname = '[placeholder-type:string]' AND person.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier for a person from the 'person' table based on their first and last names. The placeholders in the WHERE clause represent the first and last names of the person being queried."
        },
        {
            "sample_id": 7247,
            "vt": "SELECT COUNT(employee.businessentityid) FROM employee WHERE employee.maritalstatus = '[placeholder-type:string]' AND STRFTIME('%Y', employee.birthdate) < '[placeholder-type:string]' AND employee.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees from the 'employee' table who meet specific criteria based on marital status, birth year, and gender. The placeholders represent the marital status, the year of birth, and the gender of the employees being queried."
        },
        {
            "sample_id": 7151,
            "vt": "SELECT phonenumbertype.phonenumbertypeid FROM phonenumbertype WHERE phonenumbertype.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier for phone number types from the 'phonenumbertype' table based on a specified name for the phone number type."
        },
        {
            "sample_id": 7044,
            "vt": "SELECT vendor.name, productvendor.lastreceiptcost - productvendor.standardprice FROM productvendor INNER JOIN Vendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE vendor.creditrating = [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of vendor names along with the profit calculated as the difference between the last receipt cost and the standard price of products supplied by those vendors. The data is filtered to include only vendors with a specific credit rating."
        },
        {
            "sample_id": 7005,
            "vt": "SELECT DISTINCT product.name, product.listprice FROM product INNER JOIN TransactionHistory AS T2 ON T1.ProductID = T2.ProductID WHERE transactionhistory.quantity > [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of distinct product names and their corresponding list prices from the 'product' table, filtered by transaction history where the quantity of products sold exceeds a specified numeric value. This allows users to identify products that have had significant sales activity."
        },
        {
            "sample_id": 7116,
            "vt": "SELECT productvendor.lastreceiptcost - productvendor.standardprice FROM productvendor WHERE productvendor.businessentityid = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the profit margin for products by subtracting the standard price from the last receipt cost for each vendor. The placeholder in the WHERE clause represents the unique identifier for the vendor."
        },
        {
            "sample_id": 7221,
            "vt": "SELECT emailaddress.emailaddress FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN EmailAddress AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE employee.jobtitle = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the email addresses of employees from the 'employee' table who hold a specific job title. The query uses inner joins to connect the 'employee' table with the 'person' table and the 'emailaddress' table, ensuring that only employees with the specified job title are included in the results."
        },
        {
            "sample_id": 7359,
            "vt": "SELECT addresstype.name FROM businessentityaddress INNER JOIN AddressType AS T2 ON T1.AddressTypeID = T2.AddressTypeID INNER JOIN Store AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID WHERE store.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of address types associated with a specific store from the 'businessentityaddress' table. The query joins the 'AddressType' table to retrieve the address type names and filters the results based on the store's name using a placeholder for string values."
        },
        {
            "sample_id": 7422,
            "vt": "SELECT COUNT(employeedepartmenthistory.businessentityid) FROM employeedepartmenthistory INNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID INNER JOIN PersonCreditCard AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID INNER JOIN CreditCard AS T4 ON T3.CreditCardID = T4.CreditCardID WHERE creditcard.expyear = [placeholder-type:numeric] AND department.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees in a specific department who have a credit card with a specified expiration year. It joins the 'employeedepartmenthistory' table with the 'Department', 'PersonCreditCard', and 'CreditCard' tables to filter the results based on the department name and the credit card expiration year."
        },
        {
            "sample_id": 7395,
            "vt": "SELECT salesterritory.\"group\", stateprovince.name FROM salestaxrate INNER JOIN StateProvince AS T2 ON T1.StateProvinceID = T2.StateProvinceID INNER JOIN SalesTerritory AS T3 ON T2.TerritoryID = T3.TerritoryID ORDER BY salestaxrate.taxrate LIMIT [placeholder-type:numeric] OFFSET [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of sales territory groups along with their corresponding state or province names. It retrieves this information by joining the 'salestaxrate' table with the 'StateProvince' and 'SalesTerritory' tables based on their respective IDs. The results are ordered by the tax rate and can be limited and offset using numeric placeholders for pagination."
        },
        {
            "sample_id": 7173,
            "vt": "SELECT phonenumbertype.name FROM personphone INNER JOIN PhoneNumberType AS T2 USING (PhoneNumberTypeID) WHERE personphone.businessentityid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of phone number types associated with a specific person from the 'personphone' table. The placeholder in the WHERE clause represents the unique identifier for the person."
        },
        {
            "sample_id": 7310,
            "vt": "SELECT person.firstname, person.lastname, employee.hiredate FROM person INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN EmployeeDepartmentHistory AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE NOT employeedepartmenthistory.enddate IS NULL",
            "ba": "The virtual table describes the first and last names of employees along with their hire dates from the 'person' and 'employee' tables. It filters the results to include only those employees who have a recorded end date in their department history, indicating they are no longer in that department."
        },
        {
            "sample_id": 7047,
            "vt": "SELECT JULIANDAY(billofmaterials.enddate) - JULIANDAY(billofmaterials.startdate) FROM billofmaterials ORDER BY JULIANDAY(billofmaterials.enddate) - JULIANDAY(billofmaterials.startdate) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the duration of each component used in the assembly items from the 'billofmaterials' table by subtracting the start date from the end date. The results are ordered by the duration, and a limit is applied to restrict the number of records returned."
        },
        {
            "sample_id": 7412,
            "vt": "SELECT creditcard.cardnumber FROM person INNER JOIN PersonCreditCard AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN CreditCard AS T3 ON T2.CreditCardID = T3.CreditCardID WHERE person.firstname = '[placeholder-type:string]' AND person.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the credit card number associated with a person from the 'person' table by joining it with the 'PersonCreditCard' and 'CreditCard' tables. The query filters results based on the first and last name of the person, which are provided as placeholders."
        },
        {
            "sample_id": 7239,
            "vt": "SELECT salesreason.name FROM salesorderheadersalesreason INNER JOIN SalesReason AS T2 ON T1.SalesReasonID = T2.SalesReasonID WHERE salesorderheadersalesreason.salesorderid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of sales reasons associated with specific sales orders from the 'salesorderheadersalesreason' table. The placeholder in the WHERE clause represents the unique identifier of the sales order."
        },
        {
            "sample_id": 7061,
            "vt": "SELECT COUNT(employeepayhistory.businessentityid) FROM employeepayhistory INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.currentflag = [placeholder-type:numeric] AND employee.gender = '[placeholder-type:string]' AND employeepayhistory.payfrequency = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of employee pay history records from the 'employeepayhistory' table, filtering based on the current employment status and gender of employees, as well as the pay frequency."
        },
        {
            "sample_id": 7074,
            "vt": "SELECT COUNT(employee.businessentityid) FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.currentflag = [placeholder-type:numeric] AND person.emailpromotion = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of employees from the 'employee' table who are currently active and have a specific email promotion preference. The placeholders represent the current status of the employee and their email promotion choice."
        },
        {
            "sample_id": 7468,
            "vt": "SELECT product.name FROM workorder INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE workorder.workorderid = [placeholder-type:numeric]",
            "ba": "The virtual table provides the names of products associated with a specific work order from the 'workorder' table. The placeholder in the WHERE clause represents the unique identifier of the work order."
        },
        {
            "sample_id": 7194,
            "vt": "SELECT COUNT(employee.businessentityid) FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE person.firstname = '[placeholder-type:string]' AND employee.maritalstatus = '[placeholder-type:string]' AND employee.organizationlevel = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of employees from the 'employee' table who match specific criteria. It joins the 'employee' table with the 'person' table to filter based on the first name of the person, marital status of the employee, and the organization level of the employee."
        },
        {
            "sample_id": 7177,
            "vt": "SELECT (productvendor.lastreceiptcost - productvendor.standardprice) / productvendor.standardprice FROM productvendor INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE product.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the profit margin percentage for products by comparing the last receipt cost to the standard price from the 'productvendor' table. It joins the 'productvendor' table with the 'product' table to filter results based on the product name provided as a placeholder."
        },
        {
            "sample_id": 7254,
            "vt": "SELECT department.groupname FROM employeedepartmenthistory INNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID GROUP BY department.groupname ORDER BY COUNT(employeedepartmenthistory.businessentityid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of department group names from the 'Department' table, showing how many employees have worked in each department. It uses an inner join with the 'employeedepartmenthistory' table to count the number of employees associated with each department group. The results are grouped by the department group name and ordered by the count of employees, with a limit on the number of results returned."
        },
        {
            "sample_id": 7129,
            "vt": "SELECT phonenumbertype.name FROM personphone INNER JOIN PhoneNumberType AS T2 ON T1.PhoneNumberTypeID = T2.PhoneNumberTypeID GROUP BY phonenumbertype.name ORDER BY COUNT(phonenumbertype.name)",
            "ba": "The virtual table retrieves the names of phone number types associated with persons, grouping them by type and ordering the results based on the count of each type."
        },
        {
            "sample_id": 7445,
            "vt": "SELECT location.name FROM workorderrouting INNER JOIN Location AS T2 ON T1.LocationID = T2.LocationID WHERE workorderrouting.workorderid = [placeholder-type:numeric]",
            "ba": "The virtual table provides the names of locations associated with a specific work order from the 'workorderrouting' table. It uses an inner join to connect the 'workorderrouting' table with the 'Location' table based on the location ID, filtering results by a specified work order ID."
        },
        {
            "sample_id": 7090,
            "vt": "SELECT personcreditcard.businessentityid FROM creditcard INNER JOIN PersonCreditCard AS T2 ON T1.CreditCardID = T2.CreditCardID WHERE creditcard.cardtype = '[placeholder-type:string]' AND creditcard.expmonth = [placeholder-type:numeric] AND creditcard.expyear = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the business entity IDs of persons who have a specific type of credit card with a given expiration month and year. The placeholders represent the card type as a string and the expiration month and year as numeric values."
        },
        {
            "sample_id": 7174,
            "vt": "SELECT employee.jobtitle FROM person INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE person.firstname = '[placeholder-type:string]' AND person.middlename = '[placeholder-type:string]' AND person.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the job titles of employees from the 'Employee' table based on the person's first name, middle name, and last name. The placeholders in the WHERE clause represent the respective names of the person."
        },
        {
            "sample_id": 7304,
            "vt": "SELECT SUM(CASE WHEN product.productline = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM productreview INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE product.finishedgoodsflag = [placeholder-type:numeric] GROUP BY productreview.productid ORDER BY COUNT(productreview.productreviewid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total ratings for products based on their product line from the 'productreview' table. It joins with the 'product' table to filter only finished goods and groups the results by product ID. The placeholders represent the specific product line, finished goods flag, and limit for the number of results returned."
        },
        {
            "sample_id": 7362,
            "vt": "SELECT address.addressline1 FROM address INNER JOIN BusinessEntityAddress AS T2 ON T1.AddressID = T2.AddressID WHERE businessentityaddress.businessentityid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first street address line of a specific business entity from the 'address' table. The join with 'BusinessEntityAddress' allows filtering based on the unique identifier of the business entity, represented by a numeric placeholder."
        },
        {
            "sample_id": 7378,
            "vt": "SELECT COUNT(salespersonquotahistory.businessentityid) FROM salespersonquotahistory WHERE salespersonquotahistory.salesquota < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of records in the 'salespersonquotahistory' table where the sales quota is less than a specified value. The placeholder in the WHERE clause represents the sales quota threshold."
        },
        {
            "sample_id": 7017,
            "vt": "SELECT product.name, purchaseorderdetail.unitprice FROM product INNER JOIN PurchaseOrderDetail AS T2 ON T1.ProductID = T2.ProductID WHERE purchaseorderdetail.rejectedqty = [placeholder-type:numeric] ORDER BY purchaseorderdetail.linetotal LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products along with their unit prices from the 'product' table, filtered by the quantity of rejected items in the 'PurchaseOrderDetail' table. The placeholders represent the number of rejected items and the limit on the number of results returned."
        },
        {
            "sample_id": 7415,
            "vt": "SELECT COUNT(person.firstname) FROM person INNER JOIN PersonCreditCard AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN CreditCard AS T3 ON T2.CreditCardID = T3.CreditCardID WHERE creditcard.cardtype = '[placeholder-type:string]' AND person.persontype = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of persons from the 'person' table who have a specific type of credit card and belong to a certain person type. The placeholders in the WHERE clause represent the credit card type and the person type respectively."
        },
        {
            "sample_id": 7261,
            "vt": "SELECT vendor.name FROM productvendor INNER JOIN Vendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE productvendor.maxorderqty BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] ORDER BY productvendor.lastreceiptcost - productvendor.standardprice LIMIT [placeholder-type:numeric] OFFSET [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of vendors from the 'productvendor' table who have a maximum order quantity within a specified range. The results are ordered by the profit margin calculated as the difference between the last receipt cost and the standard price of the products they supply. The query also includes pagination through the use of LIMIT and OFFSET placeholders."
        },
        {
            "sample_id": 7302,
            "vt": "SELECT COUNT(product.productid) FROM productvendor INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE productvendor.onorderqty IS NULL OR productvendor.onorderqty = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of products from the 'product' table that are associated with vendors in the 'productvendor' table. It filters the results to include only those products where the quantity currently on order is either null or matches a specified numeric value."
        },
        {
            "sample_id": 7416,
            "vt": "SELECT COUNT(department.departmentid) FROM person INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE person.firstname = '[placeholder-type:string]' AND person.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of departments associated with a specific person identified by their first and last name. It joins the 'person' table with the 'EmployeeDepartmentHistory' table to link individuals to their respective departments, and then further joins with the 'Department' table to access department details."
        },
        {
            "sample_id": 7350,
            "vt": "SELECT COUNT(employeedepartmenthistory.businessentityid) FROM employeedepartmenthistory INNER JOIN Shift AS T2 ON T1.ShiftId = T2.ShiftId WHERE shift.shiftid = [placeholder-type:numeric] AND STRFTIME('%Y', shift.starttime) >= '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees in the 'employeedepartmenthistory' table who are associated with a specific shift. It joins the 'employeedepartmenthistory' table with the 'Shift' table to filter results based on a given shift ID and ensures that the start time of the shift is within a specified year."
        },
        {
            "sample_id": 7105,
            "vt": "SELECT COUNT(employeepayhistory.businessentityid) FROM employeepayhistory WHERE employeepayhistory.rate * employeepayhistory.payfrequency > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of employee pay history records from the 'employeepayhistory' table where the product of the rate and pay frequency exceeds a specified numeric value. The placeholder in the WHERE clause represents the threshold amount for filtering the records."
        },
        {
            "sample_id": 7045,
            "vt": "SELECT COUNT(*) FROM address WHERE address.addressline2 <> '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of addresses from the 'address' table where the second address line is not empty. The placeholder in the WHERE clause represents a condition to filter out addresses that have a second line specified."
        },
        {
            "sample_id": 7259,
            "vt": "SELECT product.listprice - product.standardcost, product.name FROM product INNER JOIN ProductReview AS T2 ON T1.ProductID = T2.ProductID WHERE productreview.reviewername = '[placeholder-type:string]' ORDER BY productreview.rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the profit margin for products by subtracting the standard cost from the list price. It retrieves the product name and profit for products that have been reviewed by a specific reviewer. The results are ordered by the review rating, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 7231,
            "vt": "SELECT SUM(purchaseorderheader.totaldue) FROM purchaseorderheader WHERE purchaseorderheader.orderdate LIKE '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total amount due from purchase orders created on a specific date. It retrieves the total due from the 'purchaseorderheader' table, filtering the results based on the order date provided by the user."
        },
        {
            "sample_id": 7146,
            "vt": "SELECT shift.starttime FROM shift WHERE shift.shiftid = '[placeholder-type:string]'",
            "ba": "The virtual table provides the start time of a specific shift from the 'shift' table based on the unique identifier for the shift."
        },
        {
            "sample_id": 7434,
            "vt": "SELECT SUM(product.listprice - product.standardcost) / COUNT(product.productid) FROM product INNER JOIN ProductSubcategory AS T2 ON T1.ProductSubcategoryID = T2.ProductSubcategoryID INNER JOIN ProductCategory AS T3 ON T2.ProductCategoryID = T3.ProductCategoryID WHERE productcategory.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average profit margin of products from a specific product category by subtracting the standard cost from the list price and dividing the total profit by the count of products in that category. The placeholder in the WHERE clause represents the name of the product category."
        },
        {
            "sample_id": 7130,
            "vt": "SELECT contacttype.name FROM contacttype INNER JOIN BusinessEntityContact AS T2 ON T1.ContactTypeID = T2.ContactTypeID GROUP BY contacttype.name ORDER BY COUNT(contacttype.name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of contact type names from the 'contacttype' table, which are associated with business entities through the 'BusinessEntityContact' table. The results are grouped by contact type name and ordered by the count of occurrences, allowing users to see the most common contact types. The placeholder in the LIMIT clause represents the maximum number of results to return."
        },
        {
            "sample_id": 7204,
            "vt": "SELECT CAST(SUM(CASE WHEN employee.gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(employee.businessentityid) FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE person.emailpromotion = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average salary of employees based on their gender from the 'employee' table. It uses a conditional sum to differentiate between genders and applies a multiplier to the result. The query also filters employees based on their email promotion preference."
        },
        {
            "sample_id": 7176,
            "vt": "SELECT CAST(SUM(CASE WHEN NOT document.documentsummary IS NULL THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / COUNT(document.documentsummary) FROM document INNER JOIN Employee AS T2 ON T1.Owner = T2.BusinessEntityID WHERE employee.jobtitle = '[placeholder-type:string]' AND employee.hiredate = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of documents that have a summary, grouped by the owner of the documents who are employees with a specific job title and hire date. It uses a conditional sum to count only those documents that have a non-null summary, and divides this by the total count of documents to get the average. The placeholders represent the job title and hire date of the employees."
        },
        {
            "sample_id": 7012,
            "vt": "SELECT product.name, product.productline, productreview.rating, product.listprice FROM product INNER JOIN ProductReview AS T2 ON T1.ProductID = T2.ProductID ORDER BY productreview.rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names, product lines, ratings, and list prices of products from the 'product' table, joined with the 'productreview' table to include ratings. The results are ordered by the product ratings and limited to a specified number of entries."
        },
        {
            "sample_id": 7071,
            "vt": "SELECT person.demographics FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN EmployeePayHistory AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE employee.maritalstatus = '[placeholder-type:string]' ORDER BY employeepayhistory.rate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves demographic information of employees from the 'employee' table, joining with the 'person' table to access personal details and the 'EmployeePayHistory' table to sort by their pay rate. The query filters employees based on their marital status, which is specified by a placeholder, and limits the results to a specified number."
        },
        {
            "sample_id": 7216,
            "vt": "SELECT COUNT(employeedepartmenthistory.businessentityid) FROM department INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.DepartmentID = T2.DepartmentID INNER JOIN Shift AS T3 ON T2.ShiftId = T3.ShiftId WHERE department.name = '[placeholder-type:string]' AND shift.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees in a specific department and shift. It joins the 'department' table with the 'EmployeeDepartmentHistory' table to link employees to their respective departments, and then further joins with the 'Shift' table to filter by the specific shift name. The placeholders represent the department name and shift name that the user can specify."
        },
        {
            "sample_id": 7459,
            "vt": "SELECT COUNT(workorder.workorderid) FROM workorder WHERE workorder.enddate > workorder.duedate",
            "ba": "The virtual table counts the number of work orders from the 'workorder' table where the end date of the work order is later than its due date. This indicates work orders that were completed after their expected completion date."
        },
        {
            "sample_id": 7327,
            "vt": "SELECT salesterritory.name FROM store INNER JOIN SalesPerson AS T2 ON T1.SalesPersonID = T2.BusinessEntityID INNER JOIN Person AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID INNER JOIN SalesTerritory AS T4 ON T2.TerritoryID = T4.TerritoryID WHERE store.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of sales territories associated with a specific store. It retrieves data from the 'store', 'SalesPerson', 'Person', and 'SalesTerritory' tables, linking them through their respective identifiers. The placeholder in the WHERE clause represents the name of the store being queried."
        },
        {
            "sample_id": 7241,
            "vt": "SELECT salesperson.businessentityid FROM salesterritory INNER JOIN SalesPerson AS T2 ON T1.TerritoryID = T2.TerritoryID WHERE salesterritory.name = '[placeholder-type:string]' AND salesterritory.countryregioncode = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique identifiers of salespersons from the 'SalesPerson' table who are associated with a specific sales territory and country region. The placeholders in the WHERE clause represent the territory name and country region code."
        },
        {
            "sample_id": 7389,
            "vt": "SELECT person.firstname, person.lastname FROM purchaseorderheader INNER JOIN Person AS T2 ON T1.EmployeeID = T2.BusinessEntityID WHERE person.persontype = '[placeholder-type:string]' AND purchaseorderheader.status = [placeholder-type:numeric] GROUP BY person.firstname, person.lastname ORDER BY COUNT(purchaseorderheader.purchaseorderid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of persons who are employees associated with purchase orders in a specific status. The query filters based on the type of person and the status of the purchase order, grouping the results by the person's name and ordering them by the count of purchase orders, with a limit on the number of results returned."
        },
        {
            "sample_id": 7451,
            "vt": "SELECT productinventory.quantity FROM location INNER JOIN ProductInventory AS T2 ON T1.LocationID = T2.LocationID WHERE productinventory.productid = [placeholder-type:numeric] AND location.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides the quantity of a specific product in a specified location. It retrieves data from the 'ProductInventory' table, which tracks inventory levels for products at different locations, and the 'Location' table, which contains details about each location. The placeholders allow users to specify the product ID and the name of the location they are interested in."
        },
        {
            "sample_id": 7276,
            "vt": "SELECT COUNT(salestaxrate.salestaxrateid) FROM salestaxrate WHERE salestaxrate.name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of sales tax rates from the 'salestaxrate' table that match a specific name pattern. The placeholder in the WHERE clause represents the name of the sales tax rate being searched for."
        },
        {
            "sample_id": 7396,
            "vt": "SELECT AVG(product.listprice - product.standardcost), COUNT(DISTINCT T1.Size), COUNT(DISTINCT T1.Style) FROM product INNER JOIN ProductSubcategory AS T2 ON T1.ProductSubcategoryID = T2.ProductSubcategoryID WHERE product.class = '[placeholder-type:string]' AND productsubcategory.name = '[placeholder-type:string]' GROUP BY product.class, product.color",
            "ba": "The virtual table calculates the average profit margin of products by subtracting their standard cost from their list price. It also counts the distinct sizes and styles of products within a specific product subcategory. The results are grouped by product class and color, allowing for a detailed analysis of product profitability and diversity in terms of size and style."
        },
        {
            "sample_id": 7243,
            "vt": "SELECT person.firstname, person.middlename, person.lastname FROM salesperson INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE salesperson.territoryid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first, middle, and last names of salespersons from the 'salesperson' table who are assigned to a specific territory. The placeholder in the WHERE clause represents the territory's ID."
        },
        {
            "sample_id": 7150,
            "vt": "SELECT currency.currencycode FROM currency WHERE currency.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the currency code from the 'currency' table based on the specified currency name. The placeholder in the WHERE clause represents the name of the currency being queried."
        },
        {
            "sample_id": 7155,
            "vt": "SELECT address.addressline1, address.addressline2 FROM address WHERE businessentityaddress.addressid IN (SELECT businessentityaddress.addressid FROM BusinessEntityAddress WHERE BusinessEntityID = 4)",
            "ba": "The virtual table describes the first and second lines of addresses from the 'address' table for a specific business entity identified by its ID. The placeholder in the WHERE clause represents the unique identifier of the business entity whose addresses are being queried."
        },
        {
            "sample_id": 7182,
            "vt": "SELECT SUM(billofmaterials.perassemblyqty), unitmeasure.name FROM billofmaterials INNER JOIN UnitMeasure AS T2 ON T1.UnitMeasureCode = T2.UnitMeasureCode WHERE billofmaterials.unitmeasurecode IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]') GROUP BY unitmeasure.name",
            "ba": "The virtual table summarizes the total quantity of components required for product assemblies, grouped by their unit of measure. It retrieves data from the 'billofmaterials' table and joins it with the 'unitmeasure' table to get the corresponding unit measure names. The query filters the results based on specific unit measure codes provided as placeholders."
        },
        {
            "sample_id": 7430,
            "vt": "SELECT CASE WHEN product.makeflag = [placeholder-type:numeric] THEN product.name END FROM product INNER JOIN ProductSubcategory AS T2 ON T1.ProductSubcategoryID = T2.ProductSubcategoryID INNER JOIN ProductCategory AS T3 ON T2.ProductCategoryID = T3.ProductCategoryID WHERE productsubcategory.productsubcategoryid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products from the 'product' table that are manufactured in-house, based on a specified product subcategory. The placeholders represent the manufacturing flag and the product subcategory ID."
        },
        {
            "sample_id": 7147,
            "vt": "SELECT contacttype.name FROM contacttype WHERE contacttype.contacttypeid = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of contact types from the 'contacttype' table based on a specific contact type ID. The placeholder in the WHERE clause represents the unique identifier for the contact type."
        },
        {
            "sample_id": 7083,
            "vt": "SELECT CAST(SUM(CASE WHEN person.emailpromotion = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(CASE WHEN person.persontype = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM person WHERE person.firstname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of email promotion preferences for individuals of a specific type, filtered by their first name. It sums the email promotion values based on whether the person wishes to receive promotions and divides this by the total count of individuals of the specified type, multiplying by a given factor to adjust the result."
        },
        {
            "sample_id": 7244,
            "vt": "SELECT specialoffer.description FROM specialofferproduct INNER JOIN SpecialOffer AS T2 ON T1.SpecialOfferID = T2.SpecialOfferID WHERE specialofferproduct.productid = [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of special offer descriptions associated with a specific product from the 'specialofferproduct' table. It joins with the 'specialoffer' table to retrieve the relevant descriptions based on the product ID provided."
        },
        {
            "sample_id": 7185,
            "vt": "SELECT person.firstname, person.middlename, person.lastname FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.jobtitle = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first, middle, and last names of employees from the 'employee' table who hold a specific job title. The placeholder in the WHERE clause represents the job title of the employee."
        },
        {
            "sample_id": 7233,
            "vt": "SELECT person.firstname, person.middlename, person.lastname FROM employee INNER JOIN Person AS T2 USING (BusinessEntityID) WHERE employee.jobtitle = '[placeholder-type:string]' GROUP BY person.firstname, person.middlename, person.lastname",
            "ba": "The virtual table describes the first, middle, and last names of employees from the 'employee' table who hold a specific job title. The placeholder in the WHERE clause represents the job title of the employees."
        },
        {
            "sample_id": 7092,
            "vt": "SELECT COUNT(product.productid) FROM product WHERE product.name LIKE '[placeholder-type:string]' OR product.name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of products from the 'product' table that match specific name criteria. The placeholders in the WHERE clause represent the names of the products being searched for, allowing for flexible queries based on user input."
        },
        {
            "sample_id": 7385,
            "vt": "SELECT [placeholder-type:numeric] * (product.listprice - product.standardcost) FROM product INNER JOIN ProductSubcategory AS T2 ON T1.ProductSubcategoryID = T2.ProductSubcategoryID WHERE product.class = '[placeholder-type:string]' AND product.color = '[placeholder-type:string]' AND product.size = [placeholder-type:numeric] AND productsubcategory.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the profit for products based on their list price and standard cost. It retrieves data from the 'product' table and joins it with the 'productsubcategory' table to filter products by specific criteria such as class, color, size, and subcategory name. The placeholders represent the values that can be specified by the user for these attributes."
        },
        {
            "sample_id": 7048,
            "vt": "SELECT COUNT(billofmaterials.billofmaterialsid) FROM billofmaterials WHERE billofmaterials.enddate IS NULL",
            "ba": "The virtual table counts the number of bill of materials records from the 'billofmaterials' table where the end date is not specified, indicating that these components are still in use in their respective assemblies."
        },
        {
            "sample_id": 7238,
            "vt": "SELECT creditcard.creditcardid FROM person INNER JOIN PersonCreditCard AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN CreditCard AS T3 ON T2.CreditCardID = T3.CreditCardID WHERE person.firstname = '[placeholder-type:string]' AND person.middlename = '[placeholder-type:string]' AND person.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the credit card IDs associated with a specific person by joining the 'person', 'personcreditcard', and 'creditcard' tables. It filters the results based on the person's first name, middle name, and last name, which are provided as placeholders."
        },
        {
            "sample_id": 7015,
            "vt": "SELECT COUNT(product.productid), AVG(productreview.rating) FROM product INNER JOIN ProductReview AS T2 ON T1.ProductID = T2.ProductID WHERE product.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of products and the average rating from reviews for a specific product name. It joins the 'product' table with the 'productreview' table based on the product ID, filtering results to only include the specified product name."
        },
        {
            "sample_id": 7349,
            "vt": "SELECT COUNT(vendor.businessentityid) FROM vendor WHERE vendor.preferredvendorstatus = [placeholder-type:numeric] AND vendor.activeflag = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of vendors from the 'vendor' table that meet specific criteria. The placeholders represent the preferred vendor status and the active status of the vendors."
        },
        {
            "sample_id": 7424,
            "vt": "SELECT COUNT(employeedepartmenthistory.businessentityid) FROM employeedepartmenthistory INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T1.DepartmentID = T3.DepartmentID WHERE department.name = '[placeholder-type:string]' AND person.emailpromotion = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of employees in a specific department who have opted for email promotions. It retrieves data from the 'employeedepartmenthistory' table, joining it with the 'Person' and 'Department' tables to filter based on the department name and the email promotion preference."
        },
        {
            "sample_id": 7135,
            "vt": "SELECT address.addressline1 FROM address INNER JOIN BusinessEntityAddress AS T2 USING (AddressID) WHERE businessentityaddress.businessentityid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first street address line of a specific business entity from the 'address' table. The placeholder in the WHERE clause represents the unique identifier for the business entity."
        },
        {
            "sample_id": 7228,
            "vt": "SELECT salesperson.businessentityid FROM salesperson ORDER BY salesperson.salesytd LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique identifiers of salespersons from the 'salesperson' table, ordered by their year-to-date sales figures. The placeholder in the LIMIT clause allows for specifying the maximum number of salespersons to retrieve."
        },
        {
            "sample_id": 7262,
            "vt": "SELECT [placeholder-type:numeric] - STRFTIME('%Y', employee.hiredate) FROM document INNER JOIN Employee AS T2 ON T1.Owner = T2.BusinessEntityID WHERE document.status = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the difference between a specified numeric value and the year of hire for employees from the 'Employee' table, while also filtering documents based on their status. The join condition links the document's owner to the employee's business entity ID."
        },
        {
            "sample_id": 7119,
            "vt": "SELECT vendor.businessentityid FROM vendor WHERE vendor.creditrating = (SELECT vendor.creditrating FROM Vendor ORDER BY CreditRating DESC LIMIT 1)",
            "ba": "The virtual table retrieves the unique identifier of the vendor with the highest credit rating from the 'vendor' table."
        },
        {
            "sample_id": 7342,
            "vt": "SELECT specialoffer.discountpct FROM specialoffer WHERE specialoffer.type = '[placeholder-type:string]' ORDER BY specialoffer.discountpct LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the discount percentages from the 'specialoffer' table for offers of a specific type. The placeholder in the WHERE clause represents the type of special offer, while the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 7258,
            "vt": "SELECT employee.jobtitle, employeepayhistory.rate, person.firstname, person.middlename, person.lastname FROM employeepayhistory INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Person AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID ORDER BY employeepayhistory.rate LIMIT [placeholder-type:numeric] OFFSET [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of employees along with their job titles and pay rates, including their first, middle, and last names. It combines data from the 'employeepayhistory', 'employee', and 'person' tables, ensuring that the employee's pay history is accurately linked to their personal information. The results are ordered by the pay rate, and pagination is applied using placeholders for limiting the number of results and specifying the offset."
        },
        {
            "sample_id": 7376,
            "vt": "SELECT [placeholder-type:numeric] * (product.listprice - product.standardcost) FROM product WHERE NOT product.weight IS NULL ORDER BY product.weight LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the profit for products in the 'product' table by subtracting the standard cost from the list price. It filters out products that do not have a specified weight and orders the results by weight. The query limits the number of results returned based on a specified numeric placeholder."
        },
        {
            "sample_id": 7215,
            "vt": "SELECT person.firstname, person.middlename, person.lastname FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.jobtitle = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first, middle, and last names of employees from the 'employee' table who hold a specific job title. The placeholder in the WHERE clause represents the job title of the employee."
        },
        {
            "sample_id": 7143,
            "vt": "SELECT location.locationid FROM location WHERE location.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique identification numbers of locations from the 'location' table that match a specific name. The placeholder in the WHERE clause represents the name of the location being queried."
        },
        {
            "sample_id": 7273,
            "vt": "SELECT purchaseorderdetail.orderqty - purchaseorderdetail.receivedqty, purchaseorderheader.vendorid FROM purchaseorderheader INNER JOIN PurchaseOrderDetail AS T2 ON T1.PurchaseOrderID = T2.PurchaseOrderID ORDER BY purchaseorderdetail.orderqty - purchaseorderdetail.receivedqty LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the difference between the ordered quantity and the received quantity of products from purchase orders, along with the associated vendor ID. It retrieves this information by joining the 'purchaseorderheader' and 'purchaseorderdetail' tables, allowing users to see how many items are still pending receipt for a specified number of records."
        },
        {
            "sample_id": 7118,
            "vt": "SELECT productreview.reviewername FROM productreview WHERE productreview.rating = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of reviewers from the 'productreview' table who have given a specific rating to a product. The placeholder in the WHERE clause represents the rating given by the reviewer."
        },
        {
            "sample_id": 7379,
            "vt": "SELECT shift.starttime, shift.endtime FROM employee INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Shift AS T3 ON T2.ShiftId = T3.ShiftId WHERE STRFTIME('%Y', employee.birthdate) < '[placeholder-type:string]' ORDER BY employee.birthdate LIMIT [placeholder-type:numeric] OFFSET [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the start and end times of shifts for employees who were born before a specified year. It joins the 'employee' table with the 'EmployeeDepartmentHistory' table to access the shift information, filtering based on the birthdate of the employees. The results are ordered by birthdate and can be limited and offset for pagination purposes."
        },
        {
            "sample_id": 7363,
            "vt": "SELECT businessentityaddress.businessentityid FROM address INNER JOIN BusinessEntityAddress AS T2 ON T1.AddressID = T2.AddressID WHERE address.city = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique business entity IDs from the 'BusinessEntityAddress' table by joining it with the 'Address' table based on the address ID. It filters the results to include only those addresses that match a specified city, and limits the number of results returned."
        },
        {
            "sample_id": 7086,
            "vt": "SELECT CAST(SUM(CASE WHEN salesorderdetail.orderqty < [placeholder-type:numeric] AND salesorderdetail.unitpricediscount = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / COUNT(salesorderdetail.salesorderid) FROM salesorderdetail",
            "ba": "The virtual table calculates the average of a specific value from the 'salesorderdetail' table, based on certain conditions related to order quantity and unit price discount. It sums up the values where the order quantity is less than a specified threshold and matches a given unit price discount, then divides this sum by the count of sales orders to get an average."
        },
        {
            "sample_id": 7171,
            "vt": "SELECT vendor.activeflag FROM vendor INNER JOIN BusinessEntityContact AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE businessentitycontact.personid = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the active status of vendors from the 'vendor' table, specifically focusing on those vendors associated with a particular person identified by their person ID. The query uses an inner join with the 'BusinessEntityContact' table to link the vendor information to the corresponding person."
        },
        {
            "sample_id": 7265,
            "vt": "SELECT COUNT(transactionhistory.transactionid) FROM transactionhistory INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE transactionhistory.quantity BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND product.reorderpoint <= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of transactions recorded in the 'transactionhistory' table for products that meet specific quantity criteria and reorder point conditions. The placeholders represent the range of quantities to filter transactions and the minimum reorder point for products."
        },
        {
            "sample_id": 7164,
            "vt": "SELECT COUNT(DISTINCT T1.Name) FROM salestaxrate INNER JOIN StateProvince AS T2 ON T1.StateProvinceID = T2.StateProvinceID WHERE stateprovince.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct names of sales tax rates associated with a specific state or province from the 'salestaxrate' table. It joins the 'salestaxrate' table with the 'StateProvince' table to filter the results based on the name of the state or province provided in the placeholder."
        },
        {
            "sample_id": 7115,
            "vt": "SELECT address.addressline1, address.addressline2 FROM address WHERE address.addressid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and second lines of an address from the 'address' table for a specific address identified by its unique address ID. The placeholder in the WHERE clause represents the address ID."
        },
        {
            "sample_id": 7436,
            "vt": "SELECT product.productid FROM product WHERE product.color = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique identifiers of products from the 'product' table that match a specific color. The placeholder in the WHERE clause represents the color of the product being queried."
        },
        {
            "sample_id": 7175,
            "vt": "SELECT COUNT(*) FROM productcategory INNER JOIN ProductSubcategory AS T2 ON T1.ProductCategoryID = T2.ProductCategoryID WHERE productcategory.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of product subcategories associated with a specific product category from the 'productcategory' table. The placeholder in the WHERE clause represents the name of the product category being queried."
        },
        {
            "sample_id": 7099,
            "vt": "SELECT DISTINCT transactionhistory.transactiontype FROM product INNER JOIN TransactionHistory AS T2 ON T1.ProductID = T2.ProductID WHERE product.size = [placeholder-type:numeric] AND product.color = '[placeholder-type:string]' AND product.safetystocklevel = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct transaction types from the 'TransactionHistory' table for products that match specific criteria. It filters products based on their size, color, and safety stock level, allowing users to analyze the types of transactions associated with products that meet these attributes."
        },
        {
            "sample_id": 7023,
            "vt": "SELECT product.name, product.listprice - product.standardcost FROM product INNER JOIN ProductReview AS T2 ON T1.ProductID = T2.ProductID ORDER BY productreview.rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the names of products along with their profit margins, calculated as the difference between the list price and standard cost. It retrieves data from the 'product' table and joins it with the 'productreview' table to include product ratings. The results are ordered by the product rating, and a limit is applied to restrict the number of records returned."
        },
        {
            "sample_id": 7272,
            "vt": "SELECT (product.listprice - product.standardcost) * SUM(shoppingcartitem.quantity), product.name FROM shoppingcartitem INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID GROUP BY shoppingcartitem.productid, product.name, product.listprice, product.standardcost, shoppingcartitem.quantity ORDER BY SUM(shoppingcartitem.quantity) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total profit from products in the shopping cart by subtracting the standard cost from the list price and multiplying it by the quantity of each product. It retrieves the product name and groups the results by product ID, name, list price, standard cost, and quantity. The results are ordered by the total quantity sold and limited to a specified number of records."
        },
        {
            "sample_id": 7202,
            "vt": "SELECT SUM(salesperson.salesquota) FROM salesperson INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE salesperson.businessentityid = [placeholder-type:numeric] AND STRFTIME('%Y', salespersonquotahistory.quotadate) = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total sales quota for a specific salesperson from the 'salesperson' table, filtered by the salesperson's unique identifier and the year of the sales quota history."
        },
        {
            "sample_id": 7225,
            "vt": "SELECT COUNT(employee.businessentityid) FROM employee INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.jobtitle LIKE '[placeholder-type:string]' AND employeepayhistory.rate < (SELECT AVG(employeepayhistory.rate) FROM Employee AS T1 INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.JobTitle LIKE 'Production Technician%')",
            "ba": "The virtual table counts the number of employees from the 'employee' table who have a specific job title and earn less than the average salary of employees with a job title starting with 'Production Technician'."
        },
        {
            "sample_id": 7217,
            "vt": "SELECT purchaseorderheader.purchaseorderid FROM vendor INNER JOIN PurchaseOrderHeader AS T2 ON T1.BusinessEntityID = T2.VendorID WHERE vendor.creditrating = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique purchase order IDs from the 'PurchaseOrderHeader' table, which are associated with vendors that have a specific credit rating. The query uses an INNER JOIN to connect the 'vendor' table with the 'PurchaseOrderHeader' table based on the vendor's business entity ID and the vendor ID in the purchase order header. The placeholder in the WHERE clause represents the credit rating of the vendor."
        },
        {
            "sample_id": 7270,
            "vt": "SELECT person.firstname, person.middlename, person.lastname FROM salesperson INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID ORDER BY salesperson.commissionpct LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first name, middle name, and last name of salespersons from the 'salesperson' table, joined with the 'person' table to retrieve full names. The results are ordered by the commission percentage of the salespersons, and a limit is applied to restrict the number of records returned."
        },
        {
            "sample_id": 7392,
            "vt": "SELECT STRFTIME('%Y', employee.hiredate) - STRFTIME('%Y', employee.birthdate), person.firstname, person.middlename, person.lastname FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.vacationhours <= [placeholder-type:numeric] ORDER BY STRFTIME('%Y', employee.hiredate) - STRFTIME('%Y', employee.birthdate) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of employees along with their first, middle, and last names, while also calculating their years of service by subtracting their birth year from their hire year. It filters the results to include only those employees who have vacation hours less than or equal to a specified number, and orders the results by their years of service. The output is limited to a specified number of records."
        },
        {
            "sample_id": 7462,
            "vt": "SELECT productinventory.locationid, productinventory.shelf, productinventory.bin FROM product INNER JOIN ProductInventory AS T2 ON T1.ProductID = T2.ProductID WHERE product.name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the inventory details of products from the 'product' table, specifically the location ID, shelf, and bin where each product is stored. The placeholder in the WHERE clause allows for filtering products based on their name."
        },
        {
            "sample_id": 7214,
            "vt": "SELECT salesterritory.name FROM salesperson INNER JOIN SalesTerritory AS T2 ON T1.TerritoryID = T2.TerritoryID WHERE salesperson.businessentityid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of sales territories associated with a specific salesperson from the 'salesperson' table. The placeholder in the WHERE clause represents the unique identifier of the salesperson."
        },
        {
            "sample_id": 7087,
            "vt": "SELECT salesperson.businessentityid FROM salesperson WHERE salesperson.salesytd > salesperson.saleslastyear + salesperson.saleslastyear * [placeholder-type:numeric] AND salesperson.bonus > [placeholder-type:numeric]",
            "ba": "The virtual table identifies salespersons from the 'salesperson' table who have achieved year-to-date sales greater than their previous year's sales increased by a specified percentage, and who also have a bonus greater than a specified amount."
        },
        {
            "sample_id": 7263,
            "vt": "SELECT product.daystomanufacture FROM product INNER JOIN ProductReview AS T2 ON T1.ProductID = T2.ProductID WHERE productreview.rating = [placeholder-type:numeric] AND product.class = '[placeholder-type:string]' ORDER BY productreview.rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides information about the number of days required to manufacture products from the 'product' table. It filters the results based on the product reviews, specifically looking for products that have a certain rating and belong to a specific class. The placeholders allow users to specify the desired rating and class, as well as limit the number of results returned."
        },
        {
            "sample_id": 7453,
            "vt": "SELECT (productlistpricehistory.listprice - productcosthistory.standardcost) * [placeholder-type:numeric] / productcosthistory.standardcost FROM productlistpricehistory INNER JOIN ProductCostHistory AS T2 ON T1.ProductID = T2.ProductID WHERE productlistpricehistory.productid = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the profit margin percentage for a specific product by comparing its list price to its standard cost. The formula used is ((List Price - Standard Cost) / Standard Cost) * 100, where the placeholders represent the product ID and the numeric value for the calculation."
        },
        {
            "sample_id": 7198,
            "vt": "SELECT DISTINCT salesperson.businessentityid FROM salesperson INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE salesperson.territoryid = [placeholder-type:numeric] AND STRFTIME('%Y', salespersonquotahistory.quotadate) = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct business entity IDs of salespersons from the 'salesperson' table who are associated with a specific territory and have a sales quota history for a particular year. The query uses an inner join with the 'SalesPersonQuotaHistory' table to filter the results based on the territory ID and the year extracted from the quota date."
        },
        {
            "sample_id": 7374,
            "vt": "SELECT product.name, product.reorderpoint FROM product WHERE product.sizeunitmeasurecode = '[placeholder-type:string]' ORDER BY product.size LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names and reorder points of products from the 'product' table that match a specific size unit measure code. The placeholder in the WHERE clause represents the size unit measure code, while the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 7318,
            "vt": "SELECT vendor.name FROM vendor INNER JOIN ProductVendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE productvendor.productid = [placeholder-type:numeric] ORDER BY productvendor.averageleadtime LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of vendors who supply a specific product, along with their average lead time for delivery. The query joins the 'vendor' table with the 'ProductVendor' table to filter vendors based on the product ID provided. The results are ordered by the average lead time, and a limit can be set on the number of vendors returned."
        },
        {
            "sample_id": 7125,
            "vt": "SELECT productvendor.averageleadtime, vendor.name FROM productvendor INNER JOIN Vendor AS T2 USING (businessentityid) WHERE vendor.businessentityid = [placeholder-type:numeric] GROUP BY productvendor.averageleadtime, vendor.name",
            "ba": "The virtual table provides information about the average lead time for products from specific vendors. It retrieves the average lead time and the vendor's name by joining the 'productvendor' table with the 'vendor' table based on the business entity ID. The results are grouped by average lead time and vendor name, allowing for a summary of lead times associated with each vendor."
        },
        {
            "sample_id": 7311,
            "vt": "SELECT person.firstname, person.lastname FROM person INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', employee.hiredate) >= '[placeholder-type:string]' AND employee.salariedflag = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of employees from the 'person' table who are hired in a specific year or later and are classified as salaried employees. The placeholders in the WHERE clause represent the year of hire and the salaried flag status."
        },
        {
            "sample_id": 7354,
            "vt": "SELECT productsubcategory.name FROM productsubcategory INNER JOIN ProductCategory AS T2 ON T1.ProductCategoryID = T2.ProductCategoryID WHERE productcategory.name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of product subcategories from the 'productsubcategory' table that are associated with a specific product category. The query uses an inner join to connect the 'productsubcategory' table with the 'ProductCategory' table based on the product category ID, filtering results based on the specified product category name."
        },
        {
            "sample_id": 7355,
            "vt": "SELECT salesterritory.name FROM salesperson INNER JOIN SalesTerritory AS T2 ON T1.TerritoryID = T2.TerritoryID GROUP BY salesperson.territoryid ORDER BY SUM(salesperson.salesquota) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of sales territories from the 'SalesTerritory' table, which are associated with salespersons. It aggregates the sales quotas of each salesperson by territory and orders the results based on the total sales quota. The placeholder in the LIMIT clause allows for specifying the maximum number of territories to return."
        },
        {
            "sample_id": 7153,
            "vt": "SELECT product.name FROM product INNER JOIN ProductModel AS T2 ON T1.ProductModelID = T2.ProductModelID WHERE product.productid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products from the 'product' table that are associated with a specific product model. The placeholder in the WHERE clause represents the unique identifier of the product."
        },
        {
            "sample_id": 7394,
            "vt": "SELECT product.listprice - product.standardcost FROM productreview INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE productreview.reviewername = '[placeholder-type:string]' ORDER BY productreview.rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the profit margin for products based on their list price and standard cost, filtering the results to include only those reviews submitted by a specific reviewer. The results are ordered by the rating given in the product reviews, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 7013,
            "vt": "SELECT DISTINCT product.name FROM product WHERE product.listprice - product.standardcost > [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct product names from the 'product' table where the difference between the product's list price and standard cost exceeds a specified numeric value. This allows users to identify products that have a significant profit margin."
        },
        {
            "sample_id": 7293,
            "vt": "SELECT productvendor.standardprice FROM productvendor INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE product.name = '[placeholder-type:string]' GROUP BY productvendor.standardprice ORDER BY COUNT(productvendor.standardprice) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of standard prices for products from the 'productvendor' table, filtered by the product name. It groups the results by standard price and orders them based on the count of occurrences, allowing users to see how many vendors offer each standard price for a specific product. The placeholders represent the product name and the limit on the number of results returned."
        },
        {
            "sample_id": 7039,
            "vt": "SELECT person.firstname, person.middlename, person.lastname, employee.gender FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE person.persontype = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first name, middle name, last name, and gender of employees from the 'employee' table who are of a specific person type. The placeholder in the WHERE clause represents the type of person being queried."
        },
        {
            "sample_id": 7305,
            "vt": "SELECT SUM(productvendor.standardprice) / COUNT(productvendor.businessentityid) FROM productvendor INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE product.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average standard price of a product from the 'productvendor' table, which contains vendor pricing information for products. It joins with the 'Product' table to filter the results based on the product name provided by the user. The placeholder in the WHERE clause represents the specific product name for which the average price is being calculated."
        },
        {
            "sample_id": 7377,
            "vt": "SELECT purchaseorderheader.taxamt, purchaseorderheader.purchaseorderid FROM purchaseorderheader ORDER BY purchaseorderheader.taxamt LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of purchase orders along with their associated tax amounts from the 'purchaseorderheader' table. The results are ordered by the tax amount, and a limit is applied to restrict the number of records returned based on a specified numeric value."
        },
        {
            "sample_id": 7203,
            "vt": "SELECT DISTINCT salesperson.businessentityid FROM salesperson INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', salespersonquotahistory.quotadate) = '[placeholder-type:string]' AND salesperson.salesquota < salesperson.saleslastyear",
            "ba": "The virtual table identifies distinct salespersons from the 'salesperson' table who have a sales quota history that falls within a specific year and whose current sales quota is less than their sales from the previous year. The placeholder in the WHERE clause represents the year for which the sales quota history is being queried."
        },
        {
            "sample_id": 7168,
            "vt": "SELECT transactionhistoryarchive.transactiontype FROM transactionhistoryarchive INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE product.name = '[placeholder-type:string]' AND STRFTIME('%Y-%m-%d', transactionhistoryarchive.transactiondate) = '[placeholder-type:string]'",
            "ba": "The virtual table describes the transaction types from the 'transactionhistoryarchive' table for a specific product name and transaction date. The placeholders in the WHERE clause represent the product name and the formatted transaction date."
        },
        {
            "sample_id": 7190,
            "vt": "SELECT COUNT(employee.businessentityid) FROM employee INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE employee.jobtitle LIKE '[placeholder-type:string]' AND employee.maritalstatus = '[placeholder-type:string]' AND person.persontype = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees from the 'employee' table who match specific criteria. It filters employees based on their job title, marital status, and person type, using placeholders for these values."
        },
        {
            "sample_id": 7113,
            "vt": "SELECT COUNT(product.productid) FROM product WHERE product.finishedgoodsflag = [placeholder-type:numeric] AND product.color = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of products from the 'product' table that are marked as finished goods and match a specific color. The placeholders represent the finished goods flag as a numeric value and the color as a string value."
        },
        {
            "sample_id": 7358,
            "vt": "SELECT productinventory.shelf FROM product INNER JOIN ProductInventory AS T2 ON T1.ProductID = T2.ProductID WHERE product.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the shelves where products are stored in the inventory. It retrieves the shelf information from the 'ProductInventory' table by joining it with the 'Product' table based on the product identification number. The placeholder in the WHERE clause represents the name of the product being queried."
        },
        {
            "sample_id": 7413,
            "vt": "SELECT creditcard.expyear FROM person INNER JOIN PersonCreditCard AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN CreditCard AS T3 ON T2.CreditCardID = T3.CreditCardID WHERE person.firstname = '[placeholder-type:string]' AND person.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the expiration year of credit cards associated with a specific person identified by their first and last names. It joins the 'person' table with the 'personcreditcard' table to link individuals to their credit cards, and then further joins with the 'creditcard' table to access the credit card details."
        },
        {
            "sample_id": 7208,
            "vt": "SELECT product.name FROM product WHERE product.productid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products from the 'product' table that match a specific product identification number. The placeholder in the WHERE clause represents the unique identifier for the product."
        },
        {
            "sample_id": 7390,
            "vt": "SELECT vendor.name FROM productvendor INNER JOIN Vendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID ORDER BY productvendor.maxorderqty LIMIT [placeholder-type:numeric] OFFSET [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of vendors associated with products, ordered by the maximum order quantity. The query uses an inner join between the 'productvendor' and 'vendor' tables to link product vendor records with their corresponding vendor details. The results can be limited and offset by numeric placeholders, allowing for pagination of the vendor names."
        },
        {
            "sample_id": 7463,
            "vt": "SELECT productcategory.name FROM productsubcategory INNER JOIN ProductCategory AS T2 ON T1.ProductCategoryID = T2.ProductCategoryID WHERE productsubcategory.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of product categories from the 'productsubcategory' table that are associated with a specific subcategory name. The placeholder in the WHERE clause represents the name of the product subcategory."
        },
        {
            "sample_id": 7400,
            "vt": "SELECT specialoffer.description, specialoffer.discountpct FROM specialoffer WHERE specialoffer.category = '[placeholder-type:string]' ORDER BY specialoffer.discountpct LIMIT [placeholder-type:numeric] OFFSET [placeholder-type:numeric]",
            "ba": "The virtual table describes the special offers available in the 'specialoffer' table, specifically focusing on the discount descriptions and their respective discount percentages. The query filters the results based on a specified category of the special offer and allows for pagination through the use of placeholders for limit and offset values."
        },
        {
            "sample_id": 7226,
            "vt": "SELECT CAST(SUM(CASE WHEN salesterritory.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(salesorderheader.salesorderid) FROM salesorderheader INNER JOIN SalesTerritory AS T2 ON T1.TerritoryID = T2.TerritoryID",
            "ba": "The virtual table calculates the average sales amount for a specific sales territory by summing the sales amounts from the 'salesorderheader' table where the territory name matches a specified value. It uses a placeholder for the territory name and another placeholder for a numeric value to adjust the final result. The calculation is performed by summing the sales amounts and dividing by the count of sales orders in that territory."
        },
        {
            "sample_id": 7088,
            "vt": "SELECT SUM(CASE WHEN addresstype.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END), SUM(CASE WHEN addresstype.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM businessentityaddress INNER JOIN AddressType AS T2 ON T1.AddressTypeID = T2.AddressTypeID",
            "ba": "The virtual table summarizes the total counts of addresses based on their types from the 'businessentityaddress' table, joining with the 'AddressType' table to filter by specific address types. The placeholders represent the address type name and the numeric values for the counts."
        },
        {
            "sample_id": 7307,
            "vt": "SELECT product.name FROM productreview INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE product.makeflag = [placeholder-type:numeric] GROUP BY product.name ORDER BY SUM(productreview.rating) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of product names from the 'product' table, filtered by whether the product is manufactured in-house or purchased. It aggregates the ratings from the 'productreview' table, grouping the results by product name and ordering them based on the total rating sum. The placeholders allow for dynamic input of the make flag and the limit on the number of results returned."
        },
        {
            "sample_id": 7339,
            "vt": "SELECT salesperson.businessentityid FROM salesperson ORDER BY salesperson.saleslastyear LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique identifiers of salespersons from the 'salesperson' table, ordered by their total sales from the previous year. The placeholder in the LIMIT clause allows for specifying the maximum number of salespersons to retrieve."
        }
    ],
    "retail_complains": [
        {
            "sample_id": 242,
            "vt": "SELECT CASE WHEN SUM(CASE WHEN callcenterlogs.\"complaint id\" = '[placeholder-type:string]' THEN callcenterlogs.priority END) > SUM(CASE WHEN callcenterlogs.\"complaint id\" = '[placeholder-type:string]' THEN callcenterlogs.priority END) THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM callcenterlogs",
            "ba": "The virtual table calculates the priority of complaints from the 'callcenterlogs' table based on a specific complaint ID. It uses a conditional statement to compare the sum of priorities for two different complaint IDs, represented by placeholders. The result will indicate which complaint ID has a higher total priority based on the provided values."
        },
        {
            "sample_id": 377,
            "vt": "SELECT MAX(client.age) FROM client WHERE client.sex = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum age of clients from the 'client' table, filtered by the specified sex. The placeholder in the WHERE clause represents the gender of the clients being queried."
        },
        {
            "sample_id": 366,
            "vt": "SELECT AVG(CAST(SUBSTRING(callcenterlogs.ser_time, [placeholder-type:numeric], [placeholder-type:numeric]) AS FLOAT)) FROM callcenterlogs WHERE callcenterlogs.\"date received\" BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average server time from the 'callcenterlogs' table for complaints received within a specified date range. The placeholders represent the start and end dates for filtering the records, while the server time is extracted and converted to a float for averaging."
        },
        {
            "sample_id": 334,
            "vt": "SELECT COUNT(client.client_id) FROM client INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.\"rand client\" WHERE client.sex = '[placeholder-type:string]' AND callcenterlogs.priority = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of clients from the 'client' table who have logged complaints in the 'callcenterlogs' table. It filters the results based on the client's sex and the priority of the complaints. The placeholders represent the specific sex of the client and the priority level of the complaint."
        },
        {
            "sample_id": 312,
            "vt": "SELECT COUNT(client.email) FROM client INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.\"rand client\" WHERE (callcenterlogs.\"date received\" LIKE '[placeholder-type:string]' OR callcenterlogs.\"date received\" LIKE '[placeholder-type:string]') AND client.email LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of unique client emails from the 'client' table who have logged complaints in the 'callcenterlogs' table. It filters the results based on specific complaint dates and a specified email pattern."
        },
        {
            "sample_id": 273,
            "vt": "SELECT client.first, client.middle, client.last, client.year, client.month, client.day, client.email FROM client WHERE client.age > [placeholder-type:numeric] ORDER BY client.age",
            "ba": "The virtual table describes the first, middle, and last names, as well as the birth date (year, month, day) and email of clients from the 'client' table who are older than a specified age. The placeholder in the WHERE clause represents the minimum age of the clients to be included in the results."
        },
        {
            "sample_id": 326,
            "vt": "SELECT client.day, client.month, client.year FROM client ORDER BY client.year, client.month, client.day LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the day, month, and year of birth for clients from the 'client' table. The results are ordered by year, then month, and then day, allowing for a chronological listing of birth dates. The placeholder in the LIMIT clause indicates the maximum number of records to return, which can be adjusted as needed."
        },
        {
            "sample_id": 391,
            "vt": "SELECT COUNT(client.client_id) FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE client.city = '[placeholder-type:string]' AND events.\"date received\" LIKE '[placeholder-type:string]' AND events.issue = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of clients from the 'client' table who have submitted events related to specific issues. It filters the results based on the client's city, the date the event was received, and the specific issue being reported. The placeholders represent the city name, the date of the event, and the issue type."
        },
        {
            "sample_id": 284,
            "vt": "SELECT STRFTIME('%Y', events.\"date received\"), CAST(SUM(CASE WHEN events.\"company response to consumer\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / COUNT(events.\"complaint id\") FROM callcenterlogs INNER JOIN client AS T2 ON T1.\"rand client\" = T2.client_id INNER JOIN events AS T3 ON T1.\"Complaint ID\" = T3.\"Complaint ID\" WHERE client.city = '[placeholder-type:string]' GROUP BY STRFTIME('%Y', events.\"date received\")",
            "ba": "The virtual table summarizes the average response rate of companies to consumer complaints over the years, filtered by a specific city. It calculates the total number of complaints that received a response and divides it by the total number of complaints for each year."
        },
        {
            "sample_id": 404,
            "vt": "SELECT client.phone FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE events.product = '[placeholder-type:string]' ORDER BY client.age LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the phone numbers of clients from the 'client' table who have submitted complaints about a specific product. It joins the 'client' table with the 'events' table based on the client ID to filter the results according to the specified product. The results are ordered by the age of the clients, and a limit is applied to control the number of returned records."
        },
        {
            "sample_id": 372,
            "vt": "SELECT client.social, client.state FROM client INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN state AS T3 ON T2.state_abbrev = T3.StateCode WHERE client.phone = '[placeholder-type:string]'",
            "ba": "The virtual table provides the social number and state of clients from the 'client' table, by joining it with the 'district' and 'state' tables. The join conditions ensure that the correct district and state information is associated with each client. The query filters results based on a specific phone number provided as a placeholder."
        },
        {
            "sample_id": 340,
            "vt": "SELECT CAST(SUM(CASE WHEN client.age > [placeholder-type:numeric] AND client.age <= [placeholder-type:numeric] THEN [placeholder-type:numeric] * STRFTIME('%H', callcenterlogs.ser_time) + STRFTIME('%M', callcenterlogs.ser_time) + STRFTIME('%S', callcenterlogs.ser_time) / [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN client.age > [placeholder-type:numeric] AND client.age <= [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END), CAST(SUM(CASE WHEN client.age > [placeholder-type:numeric] AND client.age <= [placeholder-type:numeric] THEN [placeholder-type:numeric] * STRFTIME('%H', callcenterlogs.ser_time) + STRFTIME('%M', callcenterlogs.ser_time) + STRFTIME('%S', callcenterlogs.ser_time) / [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN client.age > [placeholder-type:numeric] AND client.age <= [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END), CAST(SUM(CASE WHEN client.age > [placeholder-type:numeric] THEN [placeholder-type:numeric] * STRFTIME('%H', callcenterlogs.ser_time) + STRFTIME('%M', callcenterlogs.ser_time) + STRFTIME('%S', callcenterlogs.ser_time) / [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN client.age > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM client INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.\"rand client\"",
            "ba": "The virtual table calculates the average server time for complaints based on the age of clients. It aggregates the server time for clients within specified age ranges and computes the average for those groups. The placeholders represent the age limits and numeric values used in the calculations."
        },
        {
            "sample_id": 244,
            "vt": "SELECT COUNT(client.client_id) FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE client.first = '[placeholder-type:string]' AND client.last = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of clients from the 'client' table who have submitted events. It joins the 'client' table with the 'events' table based on the client ID. The query filters the results to include only those clients whose first and last names match the specified placeholders."
        },
        {
            "sample_id": 301,
            "vt": "SELECT COUNT(client.age) FROM reviews INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE reviews.product = '[placeholder-type:string]' AND reviews.stars = [placeholder-type:numeric] AND client.age < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of clients from the 'client' table who have provided reviews for a specific product and given a certain number of stars, while also filtering for clients who are younger than a specified age. The query joins the 'reviews' table with the 'client' table based on the district ID to ensure that only relevant clients are considered."
        },
        {
            "sample_id": 397,
            "vt": "SELECT DISTINCT callcenterlogs.\"date received\" FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID INNER JOIN callcenterlogs AS T3 ON T2.\"Complaint ID\" = T3.\"Complaint ID\" WHERE client.age BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND client.sex = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct complaint dates from the 'callcenterlogs' table, filtering based on the client's age range and sex. It joins the 'client' table to access client details and the 'events' table to link complaints to clients."
        },
        {
            "sample_id": 330,
            "vt": "SELECT client.first, client.middle, client.last FROM district INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE district.division = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first, middle, and last names of clients from the 'client' table who belong to a specific division in the 'district' table. The placeholder in the WHERE clause represents the division name."
        },
        {
            "sample_id": 304,
            "vt": "SELECT client.state FROM callcenterlogs INNER JOIN client AS T2 ON T1.\"rand client\" = T2.client_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id INNER JOIN state AS T4 ON T3.state_abbrev = T4.StateCode WHERE callcenterlogs.priority = [placeholder-type:numeric] GROUP BY client.state ORDER BY COUNT(client.state) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the states associated with call center logs filtered by complaint priority. It joins multiple tables to correlate client information with their respective districts and states, allowing for an analysis of how many complaints originate from each state based on a specified priority level. The results are grouped by state and ordered by the count of complaints, with a limit on the number of states returned."
        },
        {
            "sample_id": 318,
            "vt": "SELECT district.division FROM client INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE client.first = '[placeholder-type:string]' AND client.last = '[placeholder-type:string]'",
            "ba": "The virtual table describes the division of a district associated with a specific client based on their first and last names. It retrieves this information by joining the 'client' table with the 'district' table using the district ID, ensuring that the correct division is identified for the specified client."
        },
        {
            "sample_id": 249,
            "vt": "SELECT callcenterlogs.ser_time FROM client INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.\"rand client\" WHERE client.first = '[placeholder-type:string]' AND client.last = '[placeholder-type:string]' AND callcenterlogs.\"date received\" = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the server time from call center logs for a specific client based on their first and last names, as well as the date the complaint was received. It involves joining the 'client' table with the 'callcenterlogs' table using the client ID to filter the results accordingly."
        },
        {
            "sample_id": 317,
            "vt": "SELECT district.state_abbrev FROM reviews INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE reviews.stars = [placeholder-type:numeric] GROUP BY district.state_abbrev ORDER BY COUNT(district.state_abbrev) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the state abbreviations from the 'district' table based on the reviews given by clients. It joins the 'reviews' table with the 'district' table to filter the results by the number of stars given in the reviews. The results are grouped by state abbreviation and ordered by the count of reviews for each state, limiting the output to a specified number of states."
        },
        {
            "sample_id": 375,
            "vt": "SELECT COUNT(client.sex) FROM client WHERE client.sex = '[placeholder-type:string]' AND client.age > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of clients from the 'client' table based on their sex and age. The placeholders represent the specific sex of the clients and the minimum age threshold for counting."
        },
        {
            "sample_id": 360,
            "vt": "SELECT callcenterlogs.\"date received\" FROM callcenterlogs INNER JOIN events AS T2 ON T1.\"Complaint ID\" = T2.\"Complaint ID\" WHERE events.\"submitted via\" = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the dates when complaints were received from the 'callcenterlogs' table, specifically for those complaints that have been submitted via a specified method. It joins the 'callcenterlogs' table with the 'events' table to ensure that only relevant complaints are considered based on the submission method provided."
        },
        {
            "sample_id": 270,
            "vt": "SELECT CAST(SUM(CASE WHEN client.sex = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(client.sex) FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE events.\"date received\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of a specific metric based on the sex of clients from the 'client' table, while also considering the events associated with those clients. It uses a conditional sum to differentiate between male and female clients, applying a multiplier to the sum based on a placeholder value. The results are then normalized by dividing by the count of clients of the specified sex, filtered by a specific complaint date from the 'events' table."
        },
        {
            "sample_id": 313,
            "vt": "SELECT CAST(SUM(reviews.stars) AS FLOAT) / COUNT(reviews.stars) FROM state INNER JOIN district AS T2 ON T1.StateCode = T2.state_abbrev INNER JOIN reviews AS T3 ON T2.district_id = T3.district_id WHERE state.state = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rating of reviews for a specific state by joining the 'state', 'district', and 'reviews' tables. It sums up the stars from the reviews and divides by the count of reviews to get the average. The placeholder in the WHERE clause represents the name of the state for which the average rating is being calculated."
        },
        {
            "sample_id": 320,
            "vt": "SELECT DISTINCT events.product FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE client.year > [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct products associated with clients who were born after a certain year. It combines data from the 'client' and 'events' tables, filtering clients based on their birth year."
        },
        {
            "sample_id": 296,
            "vt": "SELECT state.region FROM reviews INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN state AS T3 ON T2.state_abbrev = T3.StateCode WHERE reviews.stars = [placeholder-type:numeric] GROUP BY state.region ORDER BY COUNT(state.region) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the regions associated with reviews from the 'reviews' table. It joins the 'district' table to link each review to its corresponding district and then further joins the 'state' table to categorize these districts by their respective regions. The query filters the results based on a specific star rating and groups the results by region, allowing for an ordered count of reviews per region, limited to a specified number of results."
        },
        {
            "sample_id": 294,
            "vt": "SELECT COUNT(callcenterlogs.outcome) FROM callcenterlogs WHERE callcenterlogs.outcome <> '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of outcomes from the 'callcenterlogs' table where the outcome does not match a specified value. The placeholder in the WHERE clause represents the outcome that should be excluded from the count."
        },
        {
            "sample_id": 369,
            "vt": "SELECT client.year, client.month, client.day, client.email, client.phone FROM client INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE district.city = '[placeholder-type:string]' ORDER BY client.year, client.month, client.day LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the birth date, email, and phone number of clients from the 'client' table who reside in a specific city. It joins the 'client' table with the 'district' table to filter clients based on their district's city. The results are ordered by the client's birth date and limited to a specified number of records."
        },
        {
            "sample_id": 254,
            "vt": "SELECT district.division FROM client INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE client.first = '[placeholder-type:string]' AND client.last = '[placeholder-type:string]'",
            "ba": "The virtual table describes the division of a district associated with a specific client based on their first and last names. It retrieves this information by joining the 'client' table with the 'district' table using the district ID, ensuring that the correct division is linked to the client's details."
        },
        {
            "sample_id": 344,
            "vt": "SELECT client.first, client.middle, client.last FROM client WHERE client.email = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first, middle, and last names of clients from the 'client' table who have a specific email address. The placeholder in the WHERE clause represents the client's email address."
        },
        {
            "sample_id": 327,
            "vt": "SELECT COUNT(events.\"timely response?\") FROM events WHERE events.\"timely response?\" = '[placeholder-type:string]' AND events.\"consumer disputed?\" = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of events from the 'events' table where the response from the company is timely and whether the consumer disputed the response. The placeholders represent the values for timely response and consumer dispute status."
        },
        {
            "sample_id": 251,
            "vt": "SELECT client.first, client.middle, client.last FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE events.\"company response to consumer\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first, middle, and last names of clients from the 'client' table who have a specific response from the company regarding their complaints. The query joins the 'client' table with the 'events' table based on the client ID to filter clients based on the company's response."
        },
        {
            "sample_id": 376,
            "vt": "SELECT client.first, client.last FROM client WHERE client.city = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of clients from the 'client' table who reside in a specific city. The placeholder in the WHERE clause represents the name of the city."
        },
        {
            "sample_id": 255,
            "vt": "SELECT client.first, client.middle, client.last FROM client INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE district.division = '[placeholder-type:string]' AND client.sex = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first, middle, and last names of clients from the 'client' table who belong to a specific district division and have a specified sex. The placeholders in the WHERE clause represent the division of the district and the sex of the client."
        },
        {
            "sample_id": 337,
            "vt": "SELECT client.state FROM state INNER JOIN district AS T2 ON T1.StateCode = T2.state_abbrev INNER JOIN client AS T3 ON T2.district_id = T3.district_id WHERE client.email = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the state information of clients from the 'client' table based on their email address. It joins the 'client' table with the 'district' table to get the district information, and then joins with the 'state' table to get the corresponding state code. The placeholder in the WHERE clause represents the client's email address."
        },
        {
            "sample_id": 240,
            "vt": "SELECT callcenterlogs.\"date received\" FROM callcenterlogs WHERE callcenterlogs.ser_time = (SELECT MAX(callcenterlogs.ser_time) FROM callcenterlogs)",
            "ba": "The virtual table retrieves the most recent complaint date from the 'callcenterlogs' table based on the longest server time recorded for processing complaints. The placeholder in the query allows for dynamic filtering based on server time."
        },
        {
            "sample_id": 374,
            "vt": "SELECT client.social, [placeholder-type:numeric] * (STRFTIME('%Y', events.\"date sent to company\") - STRFTIME('%Y', events.\"date received\")) + [placeholder-type:numeric] * (STRFTIME('%M', events.\"date sent to company\") - STRFTIME('%M', events.\"date received\")) + (STRFTIME('%d', events.\"date sent to company\") - STRFTIME('%d', events.\"date received\")), events.\"company response to consumer\" FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID ORDER BY [placeholder-type:numeric] * (STRFTIME('%Y', events.\"date sent to company\") - STRFTIME('%Y', events.\"date received\")) + [placeholder-type:numeric] * (STRFTIME('%M', events.\"date sent to company\") - STRFTIME('%M', events.\"date received\")) + (STRFTIME('%d', events.\"date sent to company\") - STRFTIME('%d', events.\"date received\")) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the social number of clients along with the calculated delay in response time from the company for their complaints. The delay is computed by taking the difference in years, months, and days between the date the complaint was received and the date it was sent to the company. The results are ordered by this calculated delay, and a limit is applied to the number of records returned."
        },
        {
            "sample_id": 275,
            "vt": "SELECT state.state FROM state WHERE state.region = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of states from the 'state' table that belong to a specific region. The placeholder in the WHERE clause represents the region's name."
        },
        {
            "sample_id": 350,
            "vt": "SELECT callcenterlogs.\"complaint id\" FROM client INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.\"rand client\" WHERE client.year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the complaint IDs from the 'callcenterlogs' table for clients born in a specific year. It joins the 'client' table with the 'callcenterlogs' table based on the client ID, ensuring that only complaints associated with clients of a certain birth year are selected."
        },
        {
            "sample_id": 252,
            "vt": "SELECT COUNT(client.city) FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE events.\"timely response?\" = '[placeholder-type:string]' AND client.city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of clients from the 'client' table who have received a timely response to their complaints, filtered by a specific city. The placeholders in the WHERE clause represent the response timeliness and the city name."
        },
        {
            "sample_id": 324,
            "vt": "SELECT CAST(SUM(CASE WHEN client.sex = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(client.sex) FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE events.product = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average based on the sex of clients who have submitted complaints about a specific product. It sums up a conditional value based on the client's sex and divides it by the total count of clients of that sex, then multiplies by a specified numeric value. The query joins the 'client' table with the 'events' table to filter the results based on the product in question."
        },
        {
            "sample_id": 357,
            "vt": "SELECT events.product FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE client.age > [placeholder-type:numeric] ORDER BY client.client_id LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the products associated with clients who are older than a specified age. It joins the 'client' table with the 'events' table based on the client ID, ensuring that only clients above the given age are considered. The results are ordered by client ID and limited to a specified number of entries."
        },
        {
            "sample_id": 373,
            "vt": "SELECT client.first, client.middle, client.last, client.phone FROM client INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE district.division = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first, middle, and last names along with the phone numbers of clients from the 'client' table who belong to a specific division in the 'district' table. The placeholder in the WHERE clause represents the division name."
        },
        {
            "sample_id": 309,
            "vt": "SELECT client.address_1, client.address_2 FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE events.\"timely response?\" = '[placeholder-type:string]' AND events.\"consumer disputed?\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the addresses of clients from the 'client' table who have associated events. It filters the results based on whether the company's response to the consumer was timely and whether the consumer disputed the response. The placeholders in the WHERE clause represent the values for these conditions."
        },
        {
            "sample_id": 295,
            "vt": "SELECT COUNT(callcenterlogs.\"complaint id\") FROM callcenterlogs INNER JOIN events AS T2 ON T1.\"Complaint ID\" = T2.\"Complaint ID\" WHERE events.product = '[placeholder-type:string]' AND callcenterlogs.server = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of complaints from the 'callcenterlogs' table that are associated with specific products and servers. It joins the 'callcenterlogs' table with the 'events' table based on the complaint ID, filtering results based on the specified product and server values."
        },
        {
            "sample_id": 268,
            "vt": "SELECT client.month, client.day FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE events.\"complaint id\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the month and day of birth of clients from the 'client' table who have a specific complaint recorded in the 'events' table. The query uses an inner join to connect the 'client' and 'events' tables based on the client ID, ensuring that only clients with a matching complaint ID are selected. The placeholder in the WHERE clause represents the unique identifier for the complaint."
        },
        {
            "sample_id": 401,
            "vt": "SELECT DISTINCT reviews.product FROM state INNER JOIN district AS T2 ON T1.StateCode = T2.state_abbrev INNER JOIN reviews AS T3 ON T2.district_id = T3.district_id WHERE state.region = '[placeholder-type:string]' AND reviews.stars = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct products from the 'reviews' table based on the specified region and star rating. It joins the 'state' table to filter by region and the 'district' table to link districts to their respective states."
        },
        {
            "sample_id": 328,
            "vt": "SELECT COUNT(callcenterlogs.ser_time) FROM callcenterlogs WHERE STRFTIME('%M', callcenterlogs.ser_time) > '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of entries in the 'callcenterlogs' table where the server time (ser_time) exceeds a specified minute value. The placeholder in the WHERE clause represents the minute threshold for filtering the records."
        },
        {
            "sample_id": 282,
            "vt": "SELECT client.first, client.middle, client.last FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE client.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND client.sex = '[placeholder-type:string]' AND events.\"submitted via\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first, middle, and last names of clients from the 'client' table who have submitted events within a specific year range, filtered by their sex and the method of submission."
        },
        {
            "sample_id": 382,
            "vt": "SELECT COUNT(client.email) FROM client INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN state AS T3 ON T2.state_abbrev = T3.StateCode WHERE state.region = '[placeholder-type:string]' AND client.email LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of clients from the 'client' table who are located in a specific region and have a specific email format. It joins the 'client' table with the 'district' table to associate clients with their respective districts, and then further joins with the 'state' table to filter by region. The placeholders represent the region and the email pattern to be searched."
        },
        {
            "sample_id": 310,
            "vt": "SELECT COUNT(events.\"submitted via\") FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE client.sex = '[placeholder-type:string]' AND client.year = [placeholder-type:numeric] AND events.\"submitted via\" <> '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of events submitted via a specific method for clients of a certain sex and birth year. It joins the 'client' table with the 'events' table based on the client ID, filtering by the client's sex and year of birth, while excluding a specific submission method."
        },
        {
            "sample_id": 279,
            "vt": "SELECT district.division FROM reviews INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE reviews.product = '[placeholder-type:string]' AND reviews.stars > (SELECT AVG(reviews.stars) FROM reviews AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id)",
            "ba": "The virtual table retrieves the division of districts from the 'reviews' table where the product matches a specified value and the star rating is greater than the average star rating of all reviews for that product."
        },
        {
            "sample_id": 322,
            "vt": "SELECT events.issue FROM callcenterlogs INNER JOIN events AS T2 ON T1.\"Complaint ID\" = T2.\"Complaint ID\" WHERE callcenterlogs.ser_time = (SELECT MAX(callcenterlogs.ser_time) FROM callcenterlogs)",
            "ba": "The virtual table retrieves the issues associated with the most recent complaint logged in the call center. It joins the 'callcenterlogs' table with the 'events' table based on the complaint ID, ensuring that only the latest complaint's issue is selected."
        },
        {
            "sample_id": 265,
            "vt": "SELECT reviews.reviews FROM reviews INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE district.city = '[placeholder-type:string]' AND reviews.date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the reviews from the 'reviews' table for a specific city and date. The placeholders in the WHERE clause represent the city name and the review date."
        },
        {
            "sample_id": 365,
            "vt": "SELECT callcenterlogs.\"complaint id\", callcenterlogs.call_id, callcenterlogs.phonefinal FROM callcenterlogs WHERE STRFTIME('%Y', callcenterlogs.\"date received\") = '[placeholder-type:string]' AND callcenterlogs.server = '[placeholder-type:string]'",
            "ba": "The virtual table provides a view of complaint details from the 'callcenterlogs' table, specifically focusing on the complaint ID, call ID, and final phone number. It filters the results based on the year of the complaint date and the server handling the complaint, using placeholders for both the year and server name."
        },
        {
            "sample_id": 395,
            "vt": "SELECT reviews.date FROM district INNER JOIN reviews AS T2 ON T1.district_id = T2.district_id WHERE reviews.product = '[placeholder-type:string]' AND district.city = '[placeholder-type:string]' AND district.state_abbrev = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the dates of reviews for a specific product from the 'reviews' table, filtered by the city and state of the district. It joins the 'district' table to ensure that the reviews correspond to the correct district based on the provided city and state abbreviation."
        },
        {
            "sample_id": 405,
            "vt": "SELECT COUNT(events.\"complaint id\") FROM callcenterlogs INNER JOIN events AS T2 ON T1.\"Complaint ID\" = T2.\"Complaint ID\" WHERE events.\"submitted via\" = '[placeholder-type:string]' AND STRFTIME('%Y', callcenterlogs.\"date received\") = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of complaints from the 'callcenterlogs' table that have corresponding entries in the 'events' table. It filters the results based on the submission method of the complaint and the year in which the complaint was received."
        },
        {
            "sample_id": 406,
            "vt": "SELECT DISTINCT events.product, events.issue FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE client.age * [placeholder-type:numeric] > (SELECT AVG(client.age) * [placeholder-type:numeric] FROM client)",
            "ba": "The virtual table provides a distinct list of products and issues from the 'events' table, filtered by clients whose age is above the average age of all clients. The query joins the 'client' table with the 'events' table based on the client ID, and applies a condition to ensure that only clients older than a certain age (represented by a placeholder) are included in the results."
        },
        {
            "sample_id": 262,
            "vt": "SELECT CASE WHEN events.\"consumer consent provided?\" IN (NULL, '[placeholder-type:string]', '[placeholder-type:string]') THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE client.first = '[placeholder-type:string]' AND client.middle = '[placeholder-type:string]' AND client.last = '[placeholder-type:string]' AND client.sex = '[placeholder-type:string]' AND events.\"date received\" = '[placeholder-type:string]'",
            "ba": "The virtual table provides a mechanism to evaluate whether consumer consent was provided for specific events related to clients. It checks the consent status and returns a specific value based on that status. The query joins the 'client' and 'events' tables to filter results based on the client's first name, middle name, last name, sex, and the date the event was received."
        },
        {
            "sample_id": 342,
            "vt": "SELECT CAST(SUM(CASE WHEN client.sex = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(client.client_id) FROM client WHERE client.city = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average based on the sex of clients from the 'client' table, specifically for clients residing in a specified city. It uses a conditional sum to differentiate between male and female clients, applying a multiplier to the sum based on a placeholder value. The result is then divided by the total count of clients in that city to derive the average."
        },
        {
            "sample_id": 286,
            "vt": "SELECT COUNT(client.client_id) FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE events.tags = '[placeholder-type:string]' AND client.city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of clients from the 'client' table who have submitted events with specific tags and reside in a particular city. The placeholders represent the tag and city values that can be modified by the user."
        },
        {
            "sample_id": 311,
            "vt": "SELECT events.\"consumer complaint narrative\" FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE client.first = '[placeholder-type:string]' AND client.last = '[placeholder-type:string]'",
            "ba": "The virtual table describes the consumer complaint narratives from the 'events' table for clients with specific first and last names. The placeholders in the WHERE clause represent the first and last names of the clients."
        },
        {
            "sample_id": 289,
            "vt": "SELECT callcenterlogs.\"complaint id\" FROM callcenterlogs ORDER BY callcenterlogs.ser_time LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique complaint IDs from the 'callcenterlogs' table, which records various complaints received by a call center. The results are ordered by the server time associated with each complaint, and the number of results returned is limited by a numeric placeholder."
        },
        {
            "sample_id": 316,
            "vt": "SELECT COUNT(reviews.stars) FROM reviews INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE district.city = '[placeholder-type:string]' AND reviews.stars = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of reviews with a specific star rating from the 'reviews' table, filtered by a specific city from the 'district' table. The placeholders represent the city name and the star rating."
        },
        {
            "sample_id": 345,
            "vt": "SELECT client.first FROM client INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.\"rand client\" WHERE callcenterlogs.priority = (SELECT MAX(callcenterlogs.priority) FROM callcenterlogs)",
            "ba": "The virtual table retrieves the first names of clients from the 'client' table who have the highest priority complaints recorded in the 'callcenterlogs' table. It uses an inner join to connect the two tables based on the client ID, ensuring that only clients associated with the highest priority complaints are selected."
        },
        {
            "sample_id": 297,
            "vt": "SELECT client.year FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE events.\"sub-product\" = '[placeholder-type:string]' GROUP BY client.year ORDER BY COUNT(client.year) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the years of birth of clients from the 'client' table who have submitted complaints about a specific sub-product. It joins the 'client' table with the 'events' table based on the client ID, groups the results by year of birth, and orders them by the count of clients in each year, limiting the results to a specified number."
        },
        {
            "sample_id": 384,
            "vt": "SELECT CAST(SUM(CASE WHEN callcenterlogs.priority = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(callcenterlogs.\"complaint id\") FROM callcenterlogs INNER JOIN events AS T2 ON T1.\"Complaint ID\" = T2.\"Complaint ID\" WHERE STRFTIME('%Y', callcenterlogs.\"date received\") = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of complaint priorities from the 'callcenterlogs' table for a specific year. It sums the priorities based on a condition and divides it by the total count of complaints received in that year, providing insight into the severity of complaints over time."
        },
        {
            "sample_id": 264,
            "vt": "SELECT district.district_id, district.city FROM reviews INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE reviews.date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the district IDs and cities from the 'district' table that are associated with reviews made on a specific date. The placeholder in the WHERE clause represents the date of the reviews."
        },
        {
            "sample_id": 257,
            "vt": "SELECT [placeholder-type:numeric] * (SUM(CASE WHEN STRFTIME('%Y', events.\"date received\") = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN STRFTIME('%Y', events.\"date received\") = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END)) / SUM(CASE WHEN STRFTIME('%Y', events.\"date received\") = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE client.city = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a specific metric based on the events received in a given year for clients located in a specified city. It aggregates data from the 'client' and 'events' tables, using the client ID to join them. The placeholders represent the year for filtering events, a numeric value for scaling the result, and the city for which the data is being queried."
        },
        {
            "sample_id": 407,
            "vt": "SELECT CAST(SUM(CASE WHEN district.division = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(district.division) FROM district INNER JOIN reviews AS T2 ON T1.district_id = T2.district_id WHERE reviews.stars = [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average of reviews for districts based on their division. It sums the values conditionally based on the division type and multiplies by a specified weight, then divides by the count of divisions to get the average. The query filters the results to include only those reviews that match a specific star rating."
        },
        {
            "sample_id": 347,
            "vt": "SELECT client.last FROM client INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.\"rand client\" WHERE client.age > [placeholder-type:numeric] AND callcenterlogs.server = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the last names of clients from the 'client' table who have made complaints logged in the 'callcenterlogs' table. It filters the results based on the client's age being greater than a specified numeric value and the server used for the complaint being a specific string value."
        },
        {
            "sample_id": 271,
            "vt": "SELECT CAST(SUM(CASE WHEN events.\"consumer consent provided?\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(events.\"consumer consent provided?\") FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE client.sex = '[placeholder-type:string]' AND client.first = '[placeholder-type:string]' AND client.middle = '[placeholder-type:string]' AND client.last = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average based on consumer consent provided for complaints associated with clients. It sums the values based on whether consent was provided, multiplies by a specified factor, and divides by the total count of consent entries. The query filters results based on the client's sex and full name (first, middle, last)."
        },
        {
            "sample_id": 302,
            "vt": "SELECT COUNT(client.sex) FROM client INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.\"rand client\" WHERE client.sex = '[placeholder-type:string]' AND callcenterlogs.priority = [placeholder-type:numeric] AND client.year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of clients from the 'client' table who have a specific sex, have made complaints with a certain priority level in the 'callcenterlogs' table, and were born in a specific year. The placeholders represent the sex of the client, the priority of the complaint, and the year of birth."
        },
        {
            "sample_id": 389,
            "vt": "SELECT COUNT(client.client_id) FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE STRFTIME('%Y', events.\"date received\") BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND events.\"submitted via\" = '[placeholder-type:string]' AND client.sex = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of clients from the 'client' table who have submitted complaints within a specific date range, through a specified submission method, and are of a certain sex. It joins the 'client' table with the 'events' table to filter the results based on the provided criteria."
        },
        {
            "sample_id": 292,
            "vt": "SELECT events.\"complaint id\" FROM events WHERE STRFTIME('%J', events.\"date sent to company\") - STRFTIME('%J', events.\"date received\") = (SELECT MAX(STRFTIME('%J', events.\"date sent to company\") - STRFTIME('%J', events.\"date received\")) FROM events WHERE \"Date sent to company\" = '2014-09-25') AND events.\"date sent to company\" = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the complaint ID from the 'events' table for complaints that have the maximum delay between the date received and the date sent to the company, specifically for a given date when the complaints were sent to the company. The placeholder in the WHERE clause represents the specific date when the complaints were sent."
        },
        {
            "sample_id": 362,
            "vt": "SELECT client.email FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE events.\"submitted via\" = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the email addresses of clients from the 'client' table who have submitted complaints through a specific channel. The query joins the 'client' table with the 'events' table based on the client ID, ensuring that only those clients who have submitted complaints via the specified method are included in the results."
        },
        {
            "sample_id": 263,
            "vt": "SELECT [placeholder-type:numeric] * (STRFTIME('%Y', events.\"date sent to company\") - STRFTIME('%Y', events.\"date received\")) + [placeholder-type:numeric] * (STRFTIME('%M', events.\"date sent to company\") - STRFTIME('%M', events.\"date received\")) + (STRFTIME('%d', events.\"date sent to company\") - STRFTIME('%d', events.\"date received\")) FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE events.\"date received\" = '[placeholder-type:string]' AND client.sex = '[placeholder-type:string]' AND client.first = '[placeholder-type:string]' AND client.middle = '[placeholder-type:string]' AND client.last = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total time taken to respond to complaints by subtracting the date received from the date sent to the company. It retrieves this information for clients based on specific criteria such as their first name, middle name, last name, sex, and the date the complaint was received."
        },
        {
            "sample_id": 392,
            "vt": "SELECT CAST((SUM(CASE WHEN STRFTIME('%J', events.\"date sent to company\") - STRFTIME('%J', events.\"date received\") > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END)) AS FLOAT) * [placeholder-type:numeric] / COUNT(client.client_id) FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE client.city = '[placeholder-type:string]' AND STRFTIME('%Y', events.\"date received\") = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average delay in days for complaints received in a specific city during a specific year. It sums the delays for complaints that exceed a certain threshold and divides by the total number of clients in that city. The placeholders represent the threshold for delay, a multiplier for scaling the result, the city name, and the year of the complaints."
        },
        {
            "sample_id": 245,
            "vt": "SELECT events.\"sub-product\" FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE client.first = '[placeholder-type:string]' AND client.last = '[placeholder-type:string]' AND events.\"date received\" = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the sub-product information from the 'events' table for a specific client identified by their first and last names, along with the date the event was received. It involves joining the 'client' table with the 'events' table based on the client ID."
        },
        {
            "sample_id": 285,
            "vt": "SELECT CAST(SUM(CASE WHEN events.\"consumer disputed?\" = '[placeholder-type:string]' AND client.city = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(client.client_id) FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID",
            "ba": "The virtual table calculates a weighted average of complaints based on whether the consumer disputed the outcome, filtered by the client's city. It sums the values based on the condition of dispute and divides by the total number of clients to provide an average score, which is then adjusted by a specified multiplier."
        },
        {
            "sample_id": 333,
            "vt": "SELECT client.address_1, client.address_2 FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE events.\"date received\" = '[placeholder-type:string]' AND events.\"submitted via\" = '[placeholder-type:string]'",
            "ba": "The virtual table provides the addresses of clients from the 'client' table who have submitted complaints on a specific date and through a specific channel. The placeholders in the WHERE clause represent the date of receipt of the complaint and the method of submission."
        },
        {
            "sample_id": 283,
            "vt": "SELECT events.\"submitted via\" FROM callcenterlogs INNER JOIN client AS T2 ON T1.\"rand client\" = T2.client_id INNER JOIN events AS T3 ON T1.\"Complaint ID\" = T3.\"Complaint ID\" WHERE client.state = '[placeholder-type:string]' GROUP BY callcenterlogs.\"complaint id\" ORDER BY COUNT(callcenterlogs.\"complaint id\") LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the submission methods of complaints from the 'callcenterlogs' table, filtered by the state of the clients. It joins the 'client' and 'events' tables to correlate client information and complaint details. The results are grouped by complaint ID to count occurrences, and the output is ordered by the number of complaints, limiting the results to a specified number."
        },
        {
            "sample_id": 348,
            "vt": "SELECT COUNT(callcenterlogs.\"rand client\") FROM client INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.\"rand client\" WHERE client.city = '[placeholder-type:string]' AND callcenterlogs.outcome = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of complaints logged in the call center for clients residing in a specific city, filtered by the outcome of those complaints. It joins the 'client' table with the 'callcenterlogs' table based on the client ID to ensure that only relevant complaints are considered."
        },
        {
            "sample_id": 288,
            "vt": "SELECT (CAST(SUM(CASE WHEN client.age BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] THEN client.age ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN client.age BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END)) - (CAST(SUM(CASE WHEN client.age > [placeholder-type:numeric] THEN client.age ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN client.age > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END)) FROM client INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN state AS T3 ON T2.state_abbrev = T3.StateCode WHERE state.region = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference in average age between two age groups of clients based on their district and state region. It uses conditional aggregation to sum the ages of clients within specified age ranges and divides by the count of clients in those ranges. The result is filtered by the region of the state, which is represented by a placeholder for string values."
        },
        {
            "sample_id": 331,
            "vt": "SELECT client.social FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID GROUP BY client.client_id ORDER BY COUNT(client.client_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the social security numbers of clients from the 'client' table. It joins the 'client' table with the 'events' table based on the client ID, grouping the results by client ID to aggregate the data. The results are ordered by the count of occurrences of each client ID, and a limit is applied to restrict the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 363,
            "vt": "SELECT AVG(client.age) FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE events.\"company response to consumer\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average age of clients from the 'client' table who have submitted complaints, filtered by whether the company has responded to those complaints. The placeholder in the WHERE clause represents the response status of the company."
        },
        {
            "sample_id": 243,
            "vt": "SELECT client.first, client.middle, client.last FROM client WHERE client.year > [placeholder-type:numeric]",
            "ba": "The virtual table describes the first, middle, and last names of clients from the 'client' table who were born after a specific year. The placeholder in the WHERE clause represents the year of birth."
        },
        {
            "sample_id": 258,
            "vt": "SELECT callcenterlogs.ser_time FROM callcenterlogs INNER JOIN events AS T2 ON T1.\"Complaint ID\" = T2.\"Complaint ID\" WHERE events.client_id = '[placeholder-type:string]' AND callcenterlogs.\"date received\" = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the server time from the 'callcenterlogs' table for specific complaints. It joins the 'callcenterlogs' and 'events' tables based on the complaint ID to ensure that the server time corresponds to the correct complaint. The query filters results based on a specific client ID and the date the complaint was received, both of which are represented by placeholders."
        },
        {
            "sample_id": 346,
            "vt": "SELECT client.email FROM client INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.\"rand client\" WHERE callcenterlogs.type = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the email addresses of clients from the 'client' table who have logged complaints in the 'callcenterlogs' table. The query filters the results based on the type of complaint, which is specified by a placeholder for string values."
        },
        {
            "sample_id": 361,
            "vt": "SELECT client.first, client.middle, client.last FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE events.issue = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first, middle, and last names of clients from the 'client' table who have submitted complaints related to a specific issue. The query joins the 'client' table with the 'events' table to filter clients based on the issue they reported, using a placeholder for the issue type."
        },
        {
            "sample_id": 308,
            "vt": "SELECT COUNT(reviews.reviews) FROM reviews INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE client.age BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND reviews.reviews LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of reviews from the 'reviews' table that are associated with clients in a specific age range and match a certain review text pattern. It joins the 'reviews' table with the 'client' table based on the district ID to filter the results accordingly."
        },
        {
            "sample_id": 303,
            "vt": "SELECT client.first, client.middle, client.last FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE events.tags = '[placeholder-type:string]' AND events.\"consumer consent provided?\" <> '[placeholder-type:string]' AND NOT events.\"consumer consent provided?\" IS NULL AND events.\"consumer consent provided?\" <> '[placeholder-type:string]'",
            "ba": "The virtual table describes the first, middle, and last names of clients from the 'client' table who have associated events. It filters the results based on specific tags and ensures that the consumer consent for those tags is provided, excluding any null or empty values."
        },
        {
            "sample_id": 267,
            "vt": "SELECT COUNT(reviews.stars) FROM reviews INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE reviews.product = '[placeholder-type:string]' AND district.city = '[placeholder-type:string]' AND reviews.date = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of reviews for a specific product in a specific city on a specific date. It joins the 'reviews' table with the 'district' table to filter the results based on the city associated with each review."
        },
        {
            "sample_id": 341,
            "vt": "SELECT CAST(SUM(CASE WHEN client.age > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(client.age) FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID",
            "ba": "The virtual table calculates a weighted average of the ages of clients based on a specified age threshold. It sums up the ages of clients who are older than the given threshold and applies a multiplier to this sum, then divides by the total count of clients' ages to get the average. The query involves joining the 'client' table with the 'events' table using the client ID to ensure that only relevant clients with associated events are considered in the calculation."
        },
        {
            "sample_id": 354,
            "vt": "SELECT callcenterlogs.call_id FROM client INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.\"rand client\" WHERE client.first LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the call IDs from the 'callcenterlogs' table for clients whose first names match a specified value. It uses an inner join to connect the 'client' table with the 'callcenterlogs' table based on the client ID, ensuring that only relevant call records are selected."
        },
        {
            "sample_id": 336,
            "vt": "SELECT DISTINCT events.issue FROM client INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE client.first = '[placeholder-type:string]' AND client.middle = '[placeholder-type:string]' AND client.last = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct issues from the 'events' table related to clients based on their first, middle, and last names. It joins the 'client' table with the 'events' table to filter the results according to the specified client names."
        },
        {
            "sample_id": 266,
            "vt": "SELECT reviews.product FROM reviews INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE district.city = '[placeholder-type:string]' AND reviews.date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the products reviewed in a specific city and on a specific date. It retrieves the product information from the 'reviews' table, joining it with the 'district' table to filter based on the city. The placeholders represent the city name and the review date."
        },
        {
            "sample_id": 371,
            "vt": "SELECT MAX(callcenterlogs.ser_time) FROM callcenterlogs INNER JOIN events AS T2 ON T1.\"Complaint ID\" = T2.\"Complaint ID\" WHERE events.issue = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum server time from the 'callcenterlogs' table, which indicates the longest duration taken to process complaints. It joins with the 'events' table to filter the results based on a specific issue related to the complaints. The placeholder in the WHERE clause represents the issue being queried."
        },
        {
            "sample_id": 364,
            "vt": "SELECT AVG(client.age) FROM client INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.\"rand client\" WHERE callcenterlogs.type = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average age of clients from the 'client' table who have logged complaints in the 'callcenterlogs' table. The query joins the 'client' and 'callcenterlogs' tables based on the client ID, filtering the results by a specific type of complaint using a placeholder for string values."
        },
        {
            "sample_id": 290,
            "vt": "SELECT COUNT(client.email) FROM client WHERE NOT client.email LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of clients from the 'client' table whose email does not match a specified pattern. The placeholder in the WHERE clause represents the email pattern to be excluded."
        }
    ],
    "movie_platform": [
        {
            "sample_id": 101,
            "vt": "SELECT COUNT(ratings.user_id) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_title = '[placeholder-type:string]' AND ratings.user_trialist = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users who rated a specific movie from the 'ratings' table, joining it with the 'movies' table to filter by the movie title. It also includes a condition to check if the user was a trialist when they rated the movie, using placeholders for both the movie title and the trialist status."
        },
        {
            "sample_id": 108,
            "vt": "SELECT movies.movie_title FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE ratings.critic_likes > [placeholder-type:numeric]",
            "ba": "The virtual table displays the titles of movies that have received a significant number of likes on user-written critiques. It retrieves data from the 'ratings' table, which contains user ratings and associated critiques, and joins it with the 'movies' table to access the movie titles. The condition filters for critiques that have more likes than a specified threshold."
        },
        {
            "sample_id": 78,
            "vt": "SELECT COUNT(ratings.rating_id) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_title = '[placeholder-type:string]' AND ratings.rating_timestamp_utc >= '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of ratings for a specific movie title from the 'movies' table, filtering by the movie's title and a specified rating timestamp. The placeholders represent the movie title and the date from which to count ratings."
        },
        {
            "sample_id": 56,
            "vt": "SELECT movies.movie_url FROM movies WHERE movies.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the URL of a movie from the 'movies' table based on the specified movie title. The placeholder in the WHERE clause represents the title of the movie being queried."
        },
        {
            "sample_id": 98,
            "vt": "SELECT SUM(lists.list_followers) FROM lists_users INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE lists_users.user_avatar_image_url = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of followers across all lists created by users who have a specific avatar image URL. It joins the 'lists_users' table with the 'lists' table to access the 'list_followers' column, filtering the results based on the user's avatar image URL."
        },
        {
            "sample_id": 29,
            "vt": "SELECT movies.movie_title FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id ORDER BY ratings.critic_likes LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of movies that have been rated, ordered by the number of likes received on the critics' comments. The query joins the 'ratings' table with the 'movies' table to access the movie titles associated with each rating. The result is limited to a specified number of entries, allowing users to see the most liked critics' comments for rated movies."
        },
        {
            "sample_id": 105,
            "vt": "SELECT movies.movie_title FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE ratings.rating_timestamp_utc LIKE '[placeholder-type:string]' GROUP BY movies.movie_title ORDER BY COUNT(movies.movie_title) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of movies from the 'movies' table that have been rated, based on a specific timestamp. It joins the 'ratings' table to filter the movies rated within a certain time frame, grouping the results by movie title and ordering them by the count of ratings. The placeholders allow users to specify the desired timestamp and limit the number of results returned."
        },
        {
            "sample_id": 82,
            "vt": "SELECT CAST(SUM(CASE WHEN ratings.rating_score = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rating score for a specific movie title from the 'movies' table. It sums up the ratings that match a specified score and multiplies it by a placeholder value, then divides by the total count of ratings. The placeholders represent the rating score to filter, a numeric value for multiplication, and the movie title to identify the specific movie."
        },
        {
            "sample_id": 104,
            "vt": "SELECT lists.list_title, lists_users.user_avatar_image_url FROM lists_users INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE lists_users.user_id = [placeholder-type:numeric] ORDER BY lists.list_creation_timestamp_utc LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of lists and the avatar images of users who created those lists from the 'lists' and 'lists_users' tables. It filters the results based on a specific user ID and orders the lists by their creation timestamp, limiting the number of results returned."
        },
        {
            "sample_id": 109,
            "vt": "SELECT SUM(ratings.rating_score) / COUNT(ratings.rating_id) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE ratings.rating_timestamp_utc LIKE '[placeholder-type:string]' AND movies.movie_title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rating score of movies from the 'ratings' table, joining it with the 'movies' table to access movie titles. It filters the results based on a specific rating timestamp and movie title, both represented by placeholders."
        },
        {
            "sample_id": 19,
            "vt": "SELECT COUNT(*) FROM ratings WHERE ratings.movie_id = [placeholder-type:numeric] AND ratings.rating_score <= [placeholder-type:numeric] AND ratings.user_eligible_for_trial = [placeholder-type:numeric] AND ratings.user_has_payment_method = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of ratings for a specific movie that meet certain criteria. It filters ratings based on the movie ID, the rating score being less than or equal to a specified value, and the user's eligibility for trial and payment method status."
        },
        {
            "sample_id": 42,
            "vt": "SELECT ratings.critic_likes FROM movies INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id WHERE ratings.user_trialist = [placeholder-type:numeric] AND ratings.rating_score = [placeholder-type:numeric] AND movies.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the number of likes associated with critics for a specific movie from the 'movies' and 'ratings' tables. It filters the results based on whether the user was a trialist and the rating score given to the movie."
        },
        {
            "sample_id": 15,
            "vt": "SELECT movies.director_name FROM movies WHERE movies.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the name of the director from the 'movies' table based on a specific movie title provided by the user. The placeholder in the WHERE clause represents the title of the movie for which the director's name is being queried."
        },
        {
            "sample_id": 67,
            "vt": "SELECT ratings.critic FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the critics' comments from the 'ratings' table for movies that match a specific title. The query uses an inner join to connect the 'ratings' table with the 'movies' table based on the movie ID, ensuring that only ratings for the specified movie title are selected."
        },
        {
            "sample_id": 24,
            "vt": "SELECT lists_users.user_eligible_for_trial, lists.list_followers FROM lists INNER JOIN lists_users AS T2 ON T1.user_id = T1.user_id AND T1.list_id = T2.list_id WHERE lists.list_title = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the eligibility for trial of users who created lists and the number of followers on those lists. It combines data from the 'lists' and 'lists_users' tables based on the user ID and list ID, filtering for a specific list title."
        },
        {
            "sample_id": 31,
            "vt": "SELECT COUNT(movies.movie_title), ratings.critic FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.director_name = '[placeholder-type:string]' AND movies.movie_popularity > [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of movie titles along with the critics' comments for movies directed by a specific director. It filters the results based on the director's name and the popularity of the movies, ensuring that only those with a popularity score above a certain threshold are included."
        },
        {
            "sample_id": 132,
            "vt": "SELECT COUNT(lists_users.user_id) FROM lists_users INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE lists.list_followers > [placeholder-type:numeric] AND lists_users.user_has_payment_method = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users who have created lists on Mubi, filtering for those lists that have a certain number of followers and where the users have a payment method."
        },
        {
            "sample_id": 51,
            "vt": "SELECT lists.list_description FROM lists WHERE lists.list_title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the list description from the 'lists' table for a specific list title. The placeholder in the WHERE clause represents the title of the list."
        },
        {
            "sample_id": 160,
            "vt": "SELECT DISTINCT movies.movie_id, SUM(ratings.rating_score = [placeholder-type:numeric]) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id ORDER BY movies.movie_popularity LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of movie ratings by aggregating the total scores for each movie from the 'ratings' table, while also joining with the 'movies' table to include movie details. The results are filtered to show only distinct movie IDs and are ordered by the popularity of the movies. The placeholders allow for dynamic input of specific rating scores and limits on the number of results returned."
        },
        {
            "sample_id": 16,
            "vt": "SELECT lists.list_title FROM lists ORDER BY lists.list_followers LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table presents the titles of lists from the 'lists' table, ordered by the number of followers each list has. The query limits the results to a specified number of lists, allowing users to see the most popular lists based on follower count."
        },
        {
            "sample_id": 76,
            "vt": "SELECT movies.movie_title FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE ratings.user_id = [placeholder-type:numeric] AND ratings.critic_likes = [placeholder-type:numeric] AND ratings.critic_comments = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of movies rated by a specific user, filtered by the number of likes and comments associated with the user's critic. It joins the 'ratings' table with the 'movies' table to access movie details based on the user's ratings."
        },
        {
            "sample_id": 18,
            "vt": "SELECT lists_users.list_id FROM lists_users WHERE lists_users.user_id = [placeholder-type:numeric] ORDER BY lists_users.list_creation_date_utc LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the list IDs of lists created by a specific user from the 'lists_users' table. The results are ordered by the creation date of the lists, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 12,
            "vt": "SELECT movies.movie_title, ratings.user_id, ratings.rating_score, ratings.critic FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE NOT ratings.critic IS NULL",
            "ba": "The virtual table presents a selection of movie titles along with user ratings and associated critiques from the 'ratings' and 'movies' tables. It filters out any ratings that do not include a critic's comment, ensuring that only those ratings with feedback are displayed."
        },
        {
            "sample_id": 9,
            "vt": "SELECT ratings.user_id FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_title = '[placeholder-type:string]' AND ratings.rating_score = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the user IDs of users who have rated a specific movie with a particular score. It joins the 'ratings' table with the 'movies' table to filter the results based on the movie title and the rating score."
        },
        {
            "sample_id": 133,
            "vt": "SELECT movies.movie_title FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_release_year = [placeholder-type:numeric] ORDER BY ratings.rating_score LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the titles of movies from the 'movies' table that have been rated, filtered by their release year. The query joins the 'ratings' table to associate ratings with the corresponding movies, and it orders the results by the rating score. The placeholders represent the specific release year of the movies and the limit on the number of results to return."
        },
        {
            "sample_id": 75,
            "vt": "SELECT COUNT(ratings.rating_id) FROM ratings WHERE movies.movie_id = (SELECT movies.movie_id FROM movies ORDER BY movie_popularity DESC LIMIT 1)",
            "ba": "The virtual table provides the count of ratings for the most popular movie from the 'movies' table. It uses a subquery to first identify the movie with the highest popularity, and then counts the number of ratings associated with that movie."
        },
        {
            "sample_id": 136,
            "vt": "SELECT CAST(SUM(CASE WHEN lists_users.user_subscriber = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id INNER JOIN lists_users AS T3 ON T1.user_id = T3.user_id WHERE movies.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rating score for a specific movie title from the 'movies' table, considering only the ratings from users who are subscribers. It uses a conditional sum to differentiate between subscriber and non-subscriber ratings, and then computes the average by dividing the total score by the count of ratings. The placeholders represent the subscriber status, the movie title, and the necessary numeric values for calculations."
        },
        {
            "sample_id": 60,
            "vt": "SELECT lists.list_title FROM lists INNER JOIN lists_users AS T2 ON T1.list_id = T2.list_id AND T1.user_id = T2.user_id WHERE lists.user_id = [placeholder-type:numeric] AND lists_users.user_eligible_for_trial = [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of lists created by users from the 'lists' table, filtered by a specific user ID and whether the user was eligible for a trial when creating the list. The placeholders represent the user ID and trial eligibility status."
        },
        {
            "sample_id": 55,
            "vt": "SELECT movies.movie_release_year FROM movies WHERE movies.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the release year of a specific movie from the 'movies' table based on the movie's title. The placeholder in the WHERE clause represents the title of the movie being queried."
        },
        {
            "sample_id": 147,
            "vt": "SELECT lists_users.user_id, lists_users.user_subscriber FROM lists_users INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE lists.list_title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table provides information about users who have created lists on Mubi, specifically their user IDs and subscription status. It retrieves this data by joining the 'lists_users' table with the 'lists' table based on the list ID. The query filters the results to include only those lists that match a specified title, represented by a placeholder for string values."
        },
        {
            "sample_id": 30,
            "vt": "SELECT MAX(movies.movie_popularity), MIN(ratings.rating_timestamp_utc) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_release_year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND ratings.rating_score = [placeholder-type:numeric] AND ratings.user_has_payment_method = [placeholder-type:numeric]",
            "ba": "The virtual table provides insights into movie popularity and rating timestamps from the 'ratings' and 'movies' tables. It retrieves the maximum popularity of movies released within a specified year range, along with the earliest rating timestamp for those movies that meet certain rating criteria and user payment status."
        },
        {
            "sample_id": 141,
            "vt": "SELECT DISTINCT lists.list_id FROM lists_users INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE lists_users.user_subscriber = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves unique list IDs from the 'lists' table for users who are subscribers. It uses an inner join between the 'lists_users' and 'lists' tables to ensure that only lists created by subscribers are selected. The placeholder in the WHERE clause represents the subscriber status, which is a numeric value indicating whether the user is a subscriber."
        },
        {
            "sample_id": 120,
            "vt": "SELECT movies.movie_title FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE ratings.rating_score = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of movies from the 'movies' table that have received a specific rating score from users. The query uses an inner join between the 'ratings' and 'movies' tables to connect movie ratings with their corresponding movie titles. The placeholder in the WHERE clause represents the rating score that is being filtered."
        },
        {
            "sample_id": 148,
            "vt": "SELECT lists.list_title, [placeholder-type:numeric] * (STRFTIME('%Y', 'now') - STRFTIME('%Y', lists.list_creation_timestamp_utc)) + [placeholder-type:numeric] * (STRFTIME('%m', 'now') - STRFTIME('%m', lists.list_creation_timestamp_utc)) + STRFTIME('%d', 'now') - STRFTIME('%d', lists.list_creation_timestamp_utc) FROM lists WHERE lists.list_followers > [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of lists from the 'lists' table that have a number of followers exceeding a specified threshold. It also calculates the age of each list in days based on its creation timestamp, using placeholders for numeric values to represent the number of followers and the calculated age."
        },
        {
            "sample_id": 158,
            "vt": "SELECT COUNT(ratings.user_id) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_title = '[placeholder-type:string]' AND ratings.rating_score = [placeholder-type:numeric] AND ratings.user_trialist = [placeholder-type:numeric] AND ratings.rating_timestamp_utc BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users who rated a specific movie with a given score, filtering by whether the user was a trialist and the date range of the rating."
        },
        {
            "sample_id": 2,
            "vt": "SELECT movies.movie_title, movies.movie_release_year FROM movies ORDER BY LENGTH(movies.movie_popularity) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of movie titles and their release years from the 'movies' table, ordered by the length of the popularity metric. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 100,
            "vt": "SELECT movies.movie_title FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_release_year = [placeholder-type:numeric] AND ratings.user_id = [placeholder-type:numeric]",
            "ba": "The virtual table displays the titles of movies from the 'movies' table that have been rated by a specific user in a given release year. The placeholders represent the year of release and the user ID."
        },
        {
            "sample_id": 126,
            "vt": "SELECT COUNT(ratings.critic) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_popularity = (SELECT MAX(movies.movie_popularity) FROM movies)",
            "ba": "The virtual table counts the number of critics for the most popular movie in the 'movies' table. It does this by joining the 'ratings' table with the 'movies' table to access the movie's popularity and filter for the movie with the highest popularity score."
        },
        {
            "sample_id": 68,
            "vt": "SELECT COUNT(*) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_title = '[placeholder-type:string]' AND ratings.critic_likes > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of ratings for a specific movie title from the 'movies' table, where the number of likes on the critic's review exceeds a specified threshold. The placeholders represent the movie title and the minimum number of likes required."
        },
        {
            "sample_id": 131,
            "vt": "SELECT COUNT(ratings.user_id) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id INNER JOIN ratings_users AS T3 ON T1.user_id = T3.user_id WHERE movies.movie_title = '[placeholder-type:string]' AND ratings_users.user_has_payment_method = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users who have rated a specific movie and have a payment method on Mubi. It joins the 'ratings' table with the 'movies' table to filter by the movie title and also joins with the 'ratings_users' table to check if the user has a payment method."
        },
        {
            "sample_id": 45,
            "vt": "SELECT movies.movie_title, MAX(ratings.rating_score) FROM movies INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_popularity BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] GROUP BY movies.movie_title",
            "ba": "The virtual table provides a list of movie titles along with their highest rating scores from the 'movies' and 'ratings' tables. It filters movies based on their popularity, allowing users to specify a range for the popularity score."
        },
        {
            "sample_id": 26,
            "vt": "SELECT movies.director_url FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE ratings.user_id = [placeholder-type:numeric] AND ratings.critic_likes = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the URL of the director for movies rated by a specific user, filtered by the number of likes their critic received. It joins the 'ratings' table with the 'movies' table based on the movie ID, ensuring that only ratings from a particular user and those with a specified number of likes are considered."
        },
        {
            "sample_id": 143,
            "vt": "SELECT COUNT(lists_users.list_id) FROM lists_users INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE lists.list_followers >= [placeholder-type:numeric] AND lists_users.user_subscriber = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of lists created by users who are subscribers, filtered by the number of followers on those lists. It joins the 'lists_users' table with the 'lists' table to access the necessary columns for this count."
        },
        {
            "sample_id": 85,
            "vt": "SELECT COUNT(*) FROM movies WHERE movies.movie_release_year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of movies from the 'movies' table that were released in a specific year. The placeholder in the WHERE clause represents the release year of the movies."
        },
        {
            "sample_id": 96,
            "vt": "SELECT COUNT(ratings.user_id) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE ratings.rating_score = [placeholder-type:numeric] AND movies.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users who have rated a specific movie with a given score. It joins the 'ratings' table with the 'movies' table to filter ratings based on the movie title and the rating score."
        },
        {
            "sample_id": 94,
            "vt": "SELECT movies.movie_title FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id ORDER BY ratings.critic_likes LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of movies that have been rated, sorted by the number of likes received on the critics' comments. The query joins the 'ratings' table with the 'movies' table to access the movie titles associated with each rating. The results are limited to a specified number of entries, allowing users to focus on the most liked critics' comments."
        },
        {
            "sample_id": 36,
            "vt": "SELECT AVG(lists.list_movie_number), lists_users.user_avatar_image_url FROM lists INNER JOIN lists_users AS T2 ON T1.list_id = T2.list_id AND T1.user_id = T2.user_id WHERE lists_users.user_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of movies in lists created by a specific user and retrieves the user's avatar image URL. It joins the 'lists' and 'lists_users' tables based on the list ID and user ID to ensure that the data corresponds to the correct user."
        },
        {
            "sample_id": 118,
            "vt": "SELECT SUM(lists.list_followers) FROM lists_users INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE lists.list_title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of followers for lists that match a specific title from the 'lists' table. It joins the 'lists_users' table to associate users with their respective lists, filtering based on the list title provided as a placeholder."
        },
        {
            "sample_id": 22,
            "vt": "SELECT lists_users.user_id FROM lists_users WHERE lists_users.user_subscriber = [placeholder-type:numeric] GROUP BY lists_users.user_id HAVING MAX(SUBSTRING(lists_users.list_creation_date_utc, [placeholder-type:numeric], [placeholder-type:numeric])) - MIN(SUBSTRING(lists_users.list_creation_date_utc, [placeholder-type:numeric], [placeholder-type:numeric])) >= [placeholder-type:numeric]",
            "ba": "The virtual table identifies users who have created lists on Mubi and filters them based on their subscription status. It groups the results by user ID and calculates the difference between the maximum and minimum creation dates of the lists they created. The query ensures that only those users whose lists span a certain duration are included, as specified by the placeholder."
        },
        {
            "sample_id": 119,
            "vt": "SELECT COUNT(ratings.user_id) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_title = '[placeholder-type:string]' AND ratings.rating_score = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users who have rated a specific movie with a given score. It joins the 'ratings' table with the 'movies' table to filter the results based on the movie title and the rating score provided by the user."
        },
        {
            "sample_id": 135,
            "vt": "SELECT CAST(SUM(CASE WHEN ratings.rating_score = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(ratings.user_id) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rating score for a specific movie based on user ratings. It sums the scores of ratings that match a specified score and applies a multiplier to this sum, then divides by the total count of users who rated the movie. The placeholder in the WHERE clause represents the title of the movie being queried."
        },
        {
            "sample_id": 95,
            "vt": "SELECT COUNT(lists_users.user_id) FROM lists_users INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE lists.list_followers > [placeholder-type:numeric] AND lists_users.list_creation_date_utc LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users who have created lists on Mubi, filtering for lists that have a number of followers greater than a specified threshold and were created on a specific date. The placeholders represent the minimum number of followers and the creation date of the lists."
        },
        {
            "sample_id": 11,
            "vt": "SELECT movies.movie_title FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE CAST(SUBSTRING(ratings.rating_timestamp_utc, [placeholder-type:numeric], [placeholder-type:numeric]) AS INT) = [placeholder-type:numeric] AND CAST(SUBSTRING(ratings.rating_timestamp_utc, [placeholder-type:numeric], [placeholder-type:numeric]) AS INT) > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of movies from the 'movies' table that have been rated, based on specific conditions related to the rating timestamp. The placeholders represent numeric values that will be used to filter the ratings based on their timestamp, ensuring that only those ratings that meet the specified criteria are included in the results."
        },
        {
            "sample_id": 66,
            "vt": "SELECT COUNT(ratings.user_id) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_title = '[placeholder-type:string]' AND ratings.rating_score = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users who have rated a specific movie with a given score. It joins the 'ratings' table with the 'movies' table to filter the results based on the movie title and the rating score."
        },
        {
            "sample_id": 97,
            "vt": "SELECT lists_users.user_cover_image_url FROM lists_users INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE lists.list_title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the cover image URL of users who created lists on Mubi, specifically filtering for lists that have a title matching a certain pattern. The placeholder in the WHERE clause allows for dynamic input of the list title to search for."
        },
        {
            "sample_id": 6,
            "vt": "SELECT ratings_users.user_avatar_image_url, ratings_users.rating_date_utc FROM movies INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id INNER JOIN ratings_users AS T3 ON T3.user_id = T2.user_id WHERE ratings_users.user_id = [placeholder-type:numeric] ORDER BY ratings_users.rating_date_utc LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the avatar image URL and the rating date of users who rated movies. It combines data from the 'movies', 'ratings', and 'ratings_users' tables. The query filters results based on a specific user ID and limits the number of returned records."
        },
        {
            "sample_id": 27,
            "vt": "SELECT AVG(ratings.rating_score), movies.director_name FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rating score of a movie and retrieves the director's name from the 'movies' table. It filters the results based on the specified movie title."
        },
        {
            "sample_id": 146,
            "vt": "SELECT lists.list_title, DATETIME(CURRENT_TIMESTAMP(), '[placeholder-type:string]') - DATETIME(lists.list_update_timestamp_utc) FROM lists ORDER BY lists.list_update_timestamp_utc LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of titles from the 'lists' table along with the time difference between the current timestamp and the last update timestamp of each list. The results are ordered by the last update timestamp, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 144,
            "vt": "SELECT AVG(lists.list_followers) FROM lists WHERE lists.list_movie_number > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of followers for lists in the 'lists' table that contain more than a specified number of movies. The placeholder in the WHERE clause represents the minimum number of movies a list must have to be included in the average calculation."
        },
        {
            "sample_id": 38,
            "vt": "SELECT lists.list_followers FROM lists INNER JOIN lists_users AS T2 ON T1.user_id = T2.user_id AND T1.list_id = T2.list_id WHERE lists_users.list_creation_date_utc BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND lists_users.user_eligible_for_trial = [placeholder-type:numeric]",
            "ba": "The virtual table provides the number of followers for lists created by users within a specific date range. It joins the 'lists' and 'lists_users' tables to filter the results based on the creation date of the lists and whether the user was eligible for a trial when creating the list. The placeholders represent the date range and eligibility status."
        },
        {
            "sample_id": 41,
            "vt": "SELECT COUNT(ratings.user_id) FROM movies INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id WHERE ratings.user_trialist = [placeholder-type:numeric] AND ratings.rating_score <= [placeholder-type:numeric] AND movies.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users who rated a specific movie on Mubi, filtering by whether they were trialists and the rating score they provided. It joins the 'movies' table with the 'ratings' table to access the necessary movie and rating information."
        },
        {
            "sample_id": 4,
            "vt": "SELECT AVG(movies.movie_popularity) FROM movies WHERE movies.director_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average popularity of movies directed by a specific director. It retrieves data from the 'movies' table, focusing on the 'movie_popularity' column, and filters the results based on the director's name provided as a placeholder."
        },
        {
            "sample_id": 140,
            "vt": "SELECT CAST(SUM(CASE WHEN lists_users.user_subscriber = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(lists_users.list_id) FROM lists_users",
            "ba": "The virtual table calculates the average score of lists created by users based on their subscription status. It sums up a specific value for users who are subscribers and another for those who are not, then divides this total by the count of lists to get the average. The placeholders represent the values to be summed and the multiplier for the average calculation."
        },
        {
            "sample_id": 32,
            "vt": "SELECT ratings_users.user_avatar_image_url FROM ratings INNER JOIN ratings_users AS T2 ON T1.user_id = T2.user_id WHERE ratings_users.user_id = [placeholder-type:numeric] AND ratings.rating_score = [placeholder-type:numeric] AND ratings_users.rating_date_utc = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the avatar image URLs of users who rated movies, based on specific conditions. It joins the 'ratings' table with the 'ratings_users' table to link user ratings with their respective user details. The query filters results by a specific user ID, a rating score, and a rating date, allowing for targeted retrieval of user avatar images associated with particular ratings."
        },
        {
            "sample_id": 65,
            "vt": "SELECT COUNT(lists.list_id) FROM lists_users WHERE lists.user_id = (SELECT lists.user_id FROM lists WHERE list_title = '250 Favourite Films')",
            "ba": "The virtual table counts the number of lists created by users who have a specific list title, in this case, '250 Favourite Films'. It retrieves the user ID associated with that list title from the 'lists' table and uses it to filter the 'lists_users' table to count how many lists belong to that user."
        },
        {
            "sample_id": 112,
            "vt": "SELECT movies.movie_release_year FROM movies GROUP BY movies.movie_release_year ORDER BY COUNT(movies.movie_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of movie release years from the 'movies' table, grouped by each release year. It orders the results based on the count of movies released in each year and limits the output to a specified number of years."
        },
        {
            "sample_id": 69,
            "vt": "SELECT ratings.user_id FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_title = '[placeholder-type:string]' AND ratings.critic_comments = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the user IDs of individuals who have rated a specific movie and have provided a certain number of comments on their critique. It joins the 'ratings' table with the 'movies' table to filter results based on the movie title and the number of comments associated with the rating."
        },
        {
            "sample_id": 10,
            "vt": "SELECT DISTINCT movies.movie_title, movies.movie_popularity FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE ratings.rating_score = [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of movie titles along with their popularity ratings from the 'movies' table, filtered by a specific rating score from the 'ratings' table. The placeholder in the WHERE clause represents the rating score that is used to filter the results."
        },
        {
            "sample_id": 155,
            "vt": "SELECT lists.user_id FROM lists WHERE lists.list_comments = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the user IDs of users who have created lists with a specific number of comments on them. The placeholder in the WHERE clause represents the number of comments that the user is interested in filtering by."
        },
        {
            "sample_id": 114,
            "vt": "SELECT COUNT(movies.movie_id) FROM movies WHERE movies.director_id = (SELECT movies.director_id FROM movies ORDER BY movie_popularity DESC LIMIT 1)",
            "ba": "The virtual table counts the number of movies directed by the most popular director based on user ratings. It first identifies the director with the highest popularity score and then counts how many movies are associated with that director."
        },
        {
            "sample_id": 0,
            "vt": "SELECT movies.movie_title FROM movies WHERE movies.movie_release_year = [placeholder-type:numeric] ORDER BY movies.movie_popularity LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of movies from the 'movies' table that were released in a specific year. The results are ordered by the popularity of the movies, and the number of results returned is limited to a specified amount."
        },
        {
            "sample_id": 124,
            "vt": "SELECT lists_users.user_has_payment_method FROM lists_users INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE lists.list_movie_number = (SELECT MAX(lists.list_movie_number) FROM lists)",
            "ba": "The virtual table retrieves the payment method status of users who created lists on Mubi. It specifically focuses on users associated with the list that has the highest number of movies added to it. The query joins the 'lists_users' table with the 'lists' table to filter based on the maximum movie count."
        },
        {
            "sample_id": 156,
            "vt": "SELECT movies.movie_title, AVG(ratings.rating_score) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.director_name = '[placeholder-type:string]' ORDER BY movies.movie_popularity LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of movie titles along with their average rating scores from the 'ratings' table, filtered by the director's name. The results are ordered by the movie's popularity and limited to a specified number of entries."
        },
        {
            "sample_id": 64,
            "vt": "SELECT lists_users.user_avatar_image_url FROM lists INNER JOIN lists_users AS T2 ON T1.list_id = T2.list_id AND T1.user_id = T2.user_id WHERE lists.list_title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the avatar image URL of users who created lists on Mubi, specifically filtering for lists with a given title. It combines data from the 'lists' and 'lists_users' tables based on matching user IDs and list IDs."
        },
        {
            "sample_id": 44,
            "vt": "SELECT MIN(movies.movie_release_year) FROM movies WHERE movies.director_name = (SELECT movies.director_name FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_release_year BETWEEN 1960 AND 1985 GROUP BY T2.director_name ORDER BY COUNT(T2.director_name) DESC LIMIT 1)",
            "ba": "The virtual table retrieves the earliest release year of movies directed by the most prolific director, based on the number of movies rated between 1960 and 1985. It first identifies the director with the highest count of rated movies in that time frame and then finds the minimum release year of their films."
        },
        {
            "sample_id": 90,
            "vt": "SELECT movies.director_id FROM movies WHERE movies.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the director ID of a movie from the 'movies' table based on the specified movie title. The placeholder in the WHERE clause represents the title of the movie being queried."
        },
        {
            "sample_id": 28,
            "vt": "SELECT lists.list_movie_number, lists_users.user_has_payment_method FROM lists INNER JOIN lists_users AS T2 ON T1.list_id = T2.list_id ORDER BY lists.list_movie_number LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the number of movies in each list along with the payment method status of the user who created the list. It combines data from the 'lists' and 'lists_users' tables, linking them through the 'list_id'. The results are ordered by the number of movies in each list, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 40,
            "vt": "SELECT movies.director_name FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_release_year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] GROUP BY movies.director_name HAVING COUNT(movies.movie_id) > [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of director names from the 'movies' table who have directed a significant number of movies released within a specified range of years. The placeholders represent the start and end years for the movie release year range, as well as a minimum count of movies directed by each director."
        },
        {
            "sample_id": 117,
            "vt": "SELECT SUM(lists.list_followers) FROM lists INNER JOIN lists_users AS T2 ON T1.list_id = T2.list_id GROUP BY lists.user_id ORDER BY COUNT(lists.list_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table aggregates the total number of followers for each user's lists from the 'lists' table. It joins the 'lists' table with the 'lists_users' table to associate each list with its creator. The results are grouped by the user ID, allowing us to see the total followers per user. The output is ordered by the count of lists each user has created, and it limits the results to a specified number of users."
        },
        {
            "sample_id": 25,
            "vt": "SELECT movies.movie_release_year, ratings.user_id FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE ratings.movie_id = (SELECT movies.movie_id FROM movies WHERE director_name = 'Quentin Tarantino' ORDER BY movie_release_year ASC LIMIT 1 OFFSET 2) AND ratings.rating_score = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the release year of movies and the user ID of users who rated a specific movie directed by Quentin Tarantino. It filters the ratings based on a specific rating score and selects the third movie in chronological order of release from the director's filmography."
        },
        {
            "sample_id": 23,
            "vt": "SELECT COUNT(ratings.user_id) FROM movies INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_title = '[placeholder-type:string]' AND ratings.rating_score = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users who rated a specific movie with a given score. It joins the 'movies' table with the 'ratings' table based on the movie ID, filtering for a specific movie title and rating score."
        },
        {
            "sample_id": 122,
            "vt": "SELECT lists_users.user_avatar_image_url FROM ratings INNER JOIN lists_users AS T2 ON T1.user_id = T2.user_id WHERE ratings.rating_timestamp_utc LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the user avatar image URLs from the 'lists_users' table for users who have rated movies in the 'ratings' table. The query joins these two tables based on the user ID, ensuring that only the relevant user avatars are selected. The placeholder in the WHERE clause is used to filter the results based on a specific rating timestamp."
        },
        {
            "sample_id": 81,
            "vt": "SELECT AVG(ratings.rating_score) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rating score of a specific movie from the 'ratings' table by joining it with the 'movies' table. The placeholder in the WHERE clause represents the title of the movie for which the average rating is being calculated."
        },
        {
            "sample_id": 79,
            "vt": "SELECT ratings.rating_score FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id INNER JOIN lists AS T3 ON T3.user_id = T1.user_id WHERE movies.movie_title = '[placeholder-type:string]' AND lists.list_title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the rating scores for movies from the 'ratings' table, specifically for movies that match a given title and are associated with lists that also match a specified title. The query joins the 'ratings' table with the 'movies' table to access movie details and with the 'lists' table to filter by list title."
        },
        {
            "sample_id": 84,
            "vt": "SELECT movies.director_name FROM movies WHERE movies.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the name of the director from the 'movies' table based on a specific movie title provided by the user. The placeholder in the WHERE clause represents the title of the movie for which the director's name is being queried."
        },
        {
            "sample_id": 39,
            "vt": "SELECT ratings.rating_url FROM movies INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id WHERE ratings.user_id = [placeholder-type:numeric] AND ratings.rating_score = [placeholder-type:numeric] AND movies.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the URLs of ratings for a specific movie based on the user's ID and the rating score. It joins the 'movies' table with the 'ratings' table to filter the results according to the specified user and score, while also ensuring that the movie title matches the provided string."
        },
        {
            "sample_id": 93,
            "vt": "SELECT movies.movie_title FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_release_year = [placeholder-type:numeric] ORDER BY ratings.rating_score LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the titles of movies from the 'movies' table that have been rated, filtered by their release year. The query joins the 'ratings' table to access the ratings associated with each movie, and it orders the results by the rating score to show the highest-rated movies first. The placeholders allow users to specify the desired release year and limit the number of results returned."
        },
        {
            "sample_id": 86,
            "vt": "SELECT movies.movie_title FROM movies WHERE movies.movie_release_year = [placeholder-type:numeric] ORDER BY movies.movie_popularity LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of movies from the 'movies' table that were released in a specific year. The results are ordered by the popularity of the movies, and the number of results returned is limited to a specified amount."
        },
        {
            "sample_id": 111,
            "vt": "SELECT movies.movie_title FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.director_name = '[placeholder-type:string]' GROUP BY movies.movie_title ORDER BY SUM(ratings.rating_score) / COUNT(ratings.rating_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of movies directed by a specific director from the 'movies' table. It calculates the average rating score for each movie by joining the 'ratings' table and groups the results by movie title. The results are ordered by the average rating score in descending order, and a limit is applied to restrict the number of returned movie titles."
        },
        {
            "sample_id": 162,
            "vt": "SELECT COUNT(ratings.user_id), movies.movie_image_url FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE DATETIME(ratings.rating_timestamp_utc) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of users who rated movies along with the corresponding movie image URLs. It retrieves data from the 'ratings' table and joins it with the 'movies' table based on the movie ID. The results are filtered to include only those ratings that fall within a specified date range, represented by placeholders for the start and end dates."
        },
        {
            "sample_id": 139,
            "vt": "SELECT lists.list_title FROM lists WHERE STRFTIME('%Y', lists.list_update_timestamp_utc) = '[placeholder-type:string]' ORDER BY lists.list_update_timestamp_utc LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of lists from the 'lists' table that were last updated in a specific year. The query filters the results based on the year extracted from the 'list_update_timestamp_utc' column and orders the results by the update timestamp. Additionally, it limits the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 47,
            "vt": "SELECT AVG(movies.movie_popularity) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.director_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average popularity of movies directed by a specific director from the 'movies' table. It joins the 'ratings' table to associate ratings with the corresponding movies, filtering the results based on the director's name provided as a placeholder."
        },
        {
            "sample_id": 127,
            "vt": "SELECT ratings.user_id FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE ratings.rating_score = [placeholder-type:numeric] AND ratings.rating_timestamp_utc LIKE '[placeholder-type:string]' AND movies.movie_title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the user IDs of users who have rated movies based on specific criteria. It joins the 'ratings' table with the 'movies' table to filter ratings by a specified score, a timestamp pattern, and a movie title pattern."
        },
        {
            "sample_id": 61,
            "vt": "SELECT COUNT(*) FROM lists INNER JOIN lists_users AS T2 ON T1.list_id = T2.list_id AND T1.user_id = T2.user_id WHERE lists.user_id = [placeholder-type:numeric] AND lists.list_movie_number > [placeholder-type:numeric] AND lists_users.user_has_payment_method = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of lists created by a specific user that have more than a certain number of movies and where the user has a payment method."
        },
        {
            "sample_id": 73,
            "vt": "SELECT COUNT(ratings.user_id) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE movies.movie_title = '[placeholder-type:string]' AND ratings.user_trialist = [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of users who have rated a specific movie, identified by its title, from the 'ratings' table. It joins the 'ratings' table with the 'movies' table to filter the results based on the movie title and whether the user was a trialist when they rated the movie. The placeholders represent the movie title and the trialist status."
        },
        {
            "sample_id": 33,
            "vt": "SELECT lists.list_followers, lists_users.user_subscriber = [placeholder-type:numeric] FROM lists INNER JOIN lists_users AS T2 ON T1.user_id = T2.user_id AND T2.list_id = T2.list_id WHERE lists_users.user_id = [placeholder-type:numeric] ORDER BY lists.list_followers LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides information about the number of followers for lists created by users, along with a condition to check if the user is a subscriber. It joins the 'lists' and 'lists_users' tables based on user IDs and list IDs, filtering results for a specific user and ordering them by the number of followers. The placeholders represent the user ID and the limit for the number of results returned."
        },
        {
            "sample_id": 115,
            "vt": "SELECT COUNT(ratings_users.user_subscriber) FROM ratings_users WHERE ratings_users.user_has_payment_method = [placeholder-type:numeric] AND ratings_users.rating_date_utc > '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users who are subscribers and have a payment method, filtering by the date of their ratings. The placeholders represent the criteria for filtering the results based on whether the user has a payment method and the date after which the ratings were made."
        },
        {
            "sample_id": 123,
            "vt": "SELECT lists_users.user_avatar_image_url FROM lists_users INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE lists.list_title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the user avatar image URLs from the 'lists_users' table for users who created lists with titles matching a specific pattern. The query joins the 'lists_users' table with the 'lists' table to filter the results based on the list title, which is represented by a placeholder for string values."
        },
        {
            "sample_id": 134,
            "vt": "SELECT COUNT(ratings.rating_score) FROM ratings INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE ratings.rating_score < [placeholder-type:numeric] AND movies.movie_release_year = [placeholder-type:numeric] AND movies.movie_popularity = (SELECT MAX(movies.movie_popularity) FROM movies WHERE movie_release_year = 1995)",
            "ba": "The virtual table counts the number of ratings for movies that have a rating score below a specified threshold and were released in a specific year. Additionally, it filters the movies to only include those that have the highest popularity for the specified release year."
        },
        {
            "sample_id": 62,
            "vt": "SELECT lists.list_description FROM lists INNER JOIN lists_users AS T2 ON T1.list_id = T2.list_id AND T1.user_id = T2.user_id WHERE lists.user_id = [placeholder-type:numeric] ORDER BY lists.list_followers LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the descriptions of lists created by a specific user from the 'lists' table. It joins the 'lists' table with the 'lists_users' table to ensure that the lists belong to the specified user. The results are ordered by the number of followers each list has, and a limit is applied to control the number of results returned."
        }
    ],
    "disney": [
        {
            "sample_id": 4712,
            "vt": "SELECT director.director FROM characters INNER JOIN director AS T2 ON T1.movie_title = T2.name INNER JOIN movies_total_gross AS T3 ON T3.movie_title = T1.movie_title WHERE SUBSTRING(movies_total_gross.release_date, LENGTH(movies_total_gross.release_date) - [placeholder-type:numeric], LENGTH(movies_total_gross.release_date)) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' ORDER BY CAST(REPLACE(TRIM(movies_total_gross.total_gross, '[placeholder-type:string]'), ',', '') AS FLOAT) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of directors from the 'director' table who have directed movies released within a specific date range. It joins the 'characters' table to link movies with their directors and the 'movies_total_gross' table to filter based on the release date. The results are ordered by the total gross of the movies, and the query limits the number of results returned."
        },
        {
            "sample_id": 4710,
            "vt": "SELECT DISTINCT director.director FROM characters INNER JOIN director AS T2 ON T1.movie_title = T2.name INNER JOIN movies_total_gross AS T3 ON T1.movie_title = T3.movie_title WHERE CAST(REPLACE(TRIM(movies_total_gross.total_gross, '[placeholder-type:string]'), ',', '') AS FLOAT) > [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct directors of movies that have a total gross exceeding a specified numeric value. It combines data from the 'characters', 'director', and 'movies_total_gross' tables, ensuring that only directors of movies with significant financial success are included in the results."
        },
        {
            "sample_id": 4679,
            "vt": "SELECT CAST(COUNT(CASE WHEN NOT characters.song IS NULL THEN movies_total_gross.movie_title ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(movies_total_gross.movie_title) FROM characters INNER JOIN movies_total_gross AS T2 ON T1.movie_title = T2.movie_title",
            "ba": "The virtual table calculates the proportion of movies that have an associated song from the 'characters' table compared to the total number of movies in the 'movies_total_gross' table. It uses a conditional count to determine how many movies have a non-null song and divides that by the total count of movies, adjusting the result by a numeric placeholder."
        },
        {
            "sample_id": 4680,
            "vt": "SELECT movies_total_gross.movie_title, movies_total_gross.genre FROM movies_total_gross WHERE SUBSTRING(movies_total_gross.release_date, LENGTH(movies_total_gross.release_date) - [placeholder-type:numeric], LENGTH(movies_total_gross.release_date)) = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles and genres of movies from the 'movies_total_gross' table that were released in a specific year. The placeholder in the WHERE clause represents the year of release, extracted from the release date."
        },
        {
            "sample_id": 4664,
            "vt": "SELECT director.director, COUNT(director.name) FROM director GROUP BY director.director ORDER BY COUNT(director.name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the number of movies directed by each director from the 'director' table. It groups the results by the director's name and counts the number of movies associated with each director. The placeholder in the LIMIT clause allows for specifying the maximum number of directors to display based on their productivity."
        },
        {
            "sample_id": 4697,
            "vt": "SELECT CAST(COUNT(CASE WHEN movies_total_gross.genre = '[placeholder-type:string]' THEN movies_total_gross.movie_title ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(movies_total_gross.movie_title), GROUP_CONCAT(movies_total_gross.movie_title), GROUP_CONCAT(director.director) FROM movies_total_gross INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE SUBSTRING(movies_total_gross.release_date, LENGTH(movies_total_gross.release_date) - [placeholder-type:numeric], LENGTH(movies_total_gross.release_date)) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of movies of a specific genre released within a certain date range, along with a concatenated list of those movie titles and their respective directors. The placeholders represent the genre, numeric values for date extraction, and the date range for filtering the release dates."
        },
        {
            "sample_id": 4701,
            "vt": "SELECT voice-actors.movie FROM \"voice-actors\" WHERE voice-actors.\"voice-actor\" = '[placeholder-type:string]'",
            "ba": "The virtual table lists the movies associated with a specific voice actor from the 'voice-actors' table. The placeholder in the WHERE clause represents the name of the voice actor."
        },
        {
            "sample_id": 4641,
            "vt": "SELECT characters.hero FROM characters INNER JOIN director AS T2 ON T2.name = T1.movie_title WHERE director.director = '[placeholder-type:string]'",
            "ba": "The virtual table describes the main characters (heroes) of movies directed by a specific director. The query joins the 'characters' table with the 'director' table to filter the results based on the director's name provided as a placeholder."
        },
        {
            "sample_id": 4654,
            "vt": "SELECT movies_total_gross.mpaa_rating FROM movies_total_gross INNER JOIN characters AS T2 ON T2.movie_title = T1.movie_title WHERE characters.villian = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the MPAA rating of movies from the 'movies_total_gross' table, specifically for movies that feature a certain villain. It joins the 'movies_total_gross' table with the 'characters' table to filter the results based on the villain's name provided as a placeholder."
        },
        {
            "sample_id": 4735,
            "vt": "SELECT CAST(COUNT(CASE WHEN CAST(REPLACE(TRIM(movies_total_gross.total_gross, '[placeholder-type:string]'), ',', '') AS FLOAT) > [placeholder-type:numeric] THEN movies_total_gross.movie_title ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(movies_total_gross.movie_title) FROM movies_total_gross INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE director.director = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage of movies directed by a specific director that have a total gross exceeding a specified amount. It counts the number of movies with a total gross greater than the placeholder value and divides it by the total number of movies directed by that director, multiplying the result by another placeholder value for scaling purposes."
        },
        {
            "sample_id": 4658,
            "vt": "SELECT director.name FROM movies_total_gross INNER JOIN director AS T2 ON T2.name = T1.movie_title WHERE director.director = '[placeholder-type:string]' ORDER BY CAST(REPLACE(SUBSTRING(movies_total_gross.total_gross, [placeholder-type:numeric]), ',', '') AS INT) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of directors from the 'director' table who have directed movies that are included in the 'movies_total_gross' table. The query filters the results based on a specific director's name and orders the movies by their total gross, allowing for a limit on the number of results returned."
        },
        {
            "sample_id": 4621,
            "vt": "SELECT SUM(CASE WHEN revenue.\"year\" = [placeholder-type:numeric] THEN revenue.total ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN revenue.\"year\" = [placeholder-type:numeric] THEN revenue.total ELSE [placeholder-type:numeric] END) FROM revenue",
            "ba": "The virtual table calculates the difference in total box office gross for a specific year compared to another year from the 'revenue' table. The placeholders represent the years for which the total gross is being compared."
        },
        {
            "sample_id": 4681,
            "vt": "SELECT characters.villian FROM characters WHERE characters.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the villain character from a specific movie in the 'characters' table. The placeholder in the WHERE clause represents the title of the movie."
        },
        {
            "sample_id": 4630,
            "vt": "SELECT COUNT((SELECT T2.name FROM \"movies_total_gross\" AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T2.director = 'Wolfgang Reitherman' AND T1.genre = 'Comedy' GROUP BY T2.name).name) FROM (SELECT director.name FROM \"movies_total_gross\" AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T2.director = 'Wolfgang Reitherman' AND T1.genre = 'Comedy' GROUP BY T2.name) AS t3",
            "ba": "The virtual table counts the number of unique movies directed by Wolfgang Reitherman in the Comedy genre. It retrieves movie titles from the 'movies_total_gross' table and joins it with the 'director' table to filter by the specified director and genre."
        },
        {
            "sample_id": 4725,
            "vt": "SELECT characters.hero FROM movies_total_gross INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title WHERE movies_total_gross.genre = '[placeholder-type:string]' ORDER BY CAST(REPLACE(TRIM(movies_total_gross.inflation_adjusted_gross, '[placeholder-type:string]'), ',', '') AS FLOAT) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the main characters (heroes) from movies that belong to a specific genre. It joins the 'movies_total_gross' table with the 'characters' table to filter movies based on their genre and orders the results by the inflation-adjusted gross of the movies, limiting the number of results based on a specified numeric value."
        },
        {
            "sample_id": 4657,
            "vt": "SELECT director.director FROM director INNER JOIN \"voice-actors\" AS T2 ON T1.name = T2.movie WHERE voice-actors.\"voice-actor\" = '[placeholder-type:string]' GROUP BY director.director ORDER BY COUNT(director.director) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the directors of movies based on the voice actor's name. It joins the 'director' table with the 'voice-actors' table to find all movies associated with a specific voice actor. The results are grouped by director and ordered by the count of movies they have directed, allowing for a limit on the number of directors returned."
        },
        {
            "sample_id": 4724,
            "vt": "SELECT SUM(revenue.total) FROM revenue WHERE revenue.\"year\" BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total box office gross for movies released within a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the revenue data."
        },
        {
            "sample_id": 4643,
            "vt": "SELECT director.director FROM director INNER JOIN \"voice-actors\" AS T2 ON T2.movie = T1.name WHERE voice-actors.character = '[placeholder-type:string]' AND voice-actors.\"voice-actor\" = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the name of the director for a specific movie based on the character and the voice actor associated with that character. It joins the 'director' table with the 'voice-actors' table to filter results according to the specified character and voice actor."
        },
        {
            "sample_id": 4625,
            "vt": "SELECT COUNT(characters.movie_title) FROM characters INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE SUBSTRING(characters.release_date, INSTR(characters.release_date, '-') + [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND director.director = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies from the 'characters' table that were directed by a specific director and released in a specific year. The placeholders represent the year and the director's name."
        },
        {
            "sample_id": 4653,
            "vt": "SELECT movies_total_gross.total_gross FROM movies_total_gross INNER JOIN characters AS T2 ON T2.movie_title = T1.movie_title WHERE characters.song = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the total gross earnings of movies from the 'movies_total_gross' table that are associated with a specific song. It joins the 'movies_total_gross' table with the 'characters' table to filter the results based on the song associated with the movie."
        },
        {
            "sample_id": 4720,
            "vt": "SELECT COUNT(characters.movie_title) FROM characters WHERE SUBSTRING(characters.release_date, LENGTH(characters.release_date) - [placeholder-type:numeric], LENGTH(characters.release_date)) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies from the 'characters' table that were released within a specific range of years. The placeholders represent the start and end years of the range."
        },
        {
            "sample_id": 4675,
            "vt": "SELECT director.director FROM characters INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE NOT characters.song IS NULL GROUP BY director.director",
            "ba": "The virtual table lists the names of directors who have directed movies that feature songs, by joining the 'characters' and 'director' tables. The query filters out any characters that do not have an associated song, ensuring that only those directors whose movies include songs are included in the results."
        },
        {
            "sample_id": 4711,
            "vt": "SELECT characters.song FROM movies_total_gross INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title ORDER BY CAST(REPLACE(TRIM(movies_total_gross.total_gross, '[placeholder-type:string]'), ',', '') AS FLOAT) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the songs associated with movies from the 'movies_total_gross' table, joining it with the 'characters' table to link movie titles. The results are ordered by the total gross of the movies, which is converted to a float for accurate sorting. The query limits the number of results returned based on a specified numeric placeholder."
        },
        {
            "sample_id": 4690,
            "vt": "SELECT movies_total_gross.movie_title, movies_total_gross.total_gross, movies_total_gross.mpaa_rating FROM movies_total_gross INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title INNER JOIN director AS T3 ON T3.name = T1.movie_title WHERE characters.hero = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about movies, including their titles, total gross earnings, and MPAA ratings. It combines data from the 'movies_total_gross', 'characters', and 'director' tables. The query filters the results to show only those movies where the main character (hero) matches a specified name."
        },
        {
            "sample_id": 4644,
            "vt": "SELECT characters.release_date FROM characters INNER JOIN \"voice-actors\" AS T2 ON T2.movie = T1.movie_title WHERE voice-actors.character = '[placeholder-type:string]' AND voice-actors.\"voice-actor\" = '[placeholder-type:string]'",
            "ba": "The virtual table provides the release date of a movie from the 'characters' table based on a specific character and their corresponding voice actor. The placeholders represent the character's name and the voice actor's name, allowing users to filter the results accordingly."
        },
        {
            "sample_id": 4696,
            "vt": "SELECT director.director, movies_total_gross.mpaa_rating FROM movies_total_gross INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE movies_total_gross.genre = '[placeholder-type:string]' AND SUBSTRING(movies_total_gross.release_date, LENGTH(movies_total_gross.release_date) - [placeholder-type:numeric], LENGTH(movies_total_gross.release_date)) = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the directors and their corresponding MPAA ratings for movies of a specific genre released in a particular year. The placeholders allow users to specify the genre and the year of release."
        },
        {
            "sample_id": 4629,
            "vt": "SELECT COUNT(voice-actors.movie) FROM characters INNER JOIN \"voice-actors\" AS T2 ON T1.movie_title = T2.movie WHERE voice-actors.\"voice-actor\" = '[placeholder-type:string]' AND SUBSTRING(characters.release_date, INSTR(characters.release_date, '-') + [placeholder-type:numeric]) > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of movies featuring a specific voice actor from the 'characters' and 'voice-actors' tables. It filters the results based on the voice actor's name and checks if the release date of the movie is after a certain year, using placeholders for both the voice actor's name and the year."
        },
        {
            "sample_id": 4719,
            "vt": "SELECT characters.movie_title FROM characters ORDER BY SUBSTRING(characters.release_date, LENGTH(characters.release_date) - [placeholder-type:numeric], LENGTH(characters.release_date)) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies from the 'characters' table, ordered by their release date. The placeholders allow for specifying how many movie titles to retrieve and which part of the release date to consider for ordering."
        },
        {
            "sample_id": 4705,
            "vt": "SELECT characters.song FROM characters INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE director.director = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the songs associated with movies directed by a specific director from the 'characters' and 'director' tables. The placeholder in the WHERE clause represents the name of the director."
        },
        {
            "sample_id": 4655,
            "vt": "SELECT COUNT((SELECT T1.movie FROM \"voice-actors\" AS T1 INNER JOIN movies_total_gross AS T2 ON T1.movie = T2.movie_title WHERE MPAA_rating = 'PG' AND \"voice-actor\" = 'Bill Thompson' GROUP BY T1.movie).movie) FROM (SELECT voice-actors.movie FROM \"voice-actors\" AS T1 INNER JOIN movies_total_gross AS T2 ON T1.movie = T2.movie_title WHERE MPAA_rating = 'PG' AND \"voice-actor\" = 'Bill Thompson' GROUP BY T1.movie) AS t",
            "ba": "The virtual table counts the number of movies featuring a specific voice actor that have a PG rating. It joins the 'voice-actors' table with the 'movies_total_gross' table to filter movies based on the MPAA rating and the voice actor's name."
        },
        {
            "sample_id": 4729,
            "vt": "SELECT COUNT(DISTINCT \"voice-actor\") FROM \"voice-actors\" WHERE voice-actors.movie = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct voice actors associated with a specific movie from the 'voice-actors' table. The placeholder in the WHERE clause represents the title of the movie for which the count of unique voice actors is being requested."
        },
        {
            "sample_id": 4647,
            "vt": "SELECT characters.hero FROM characters INNER JOIN movies_total_gross AS T2 ON T2.movie_title = T1.movie_title WHERE movies_total_gross.genre = '[placeholder-type:string]' AND characters.release_date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the main characters (heroes) from the 'characters' table for movies that belong to a specific genre and were released on a specific date. The placeholders in the WHERE clause represent the genre of the movie and the release date."
        },
        {
            "sample_id": 4683,
            "vt": "SELECT movies_total_gross.movie_title, CAST(REPLACE(TRIM(movies_total_gross.inflation_adjusted_gross, '[placeholder-type:string]'), ',', '') AS FLOAT) / CAST(REPLACE(TRIM(movies_total_gross.total_gross, '[placeholder-type:string]'), ',', '') AS FLOAT) FROM movies_total_gross ORDER BY CAST(REPLACE(TRIM(movies_total_gross.total_gross, '[placeholder-type:string]'), ',', '') AS FLOAT) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the estimated inflation rate for movies by dividing the inflation-adjusted gross by the total gross from the 'movies_total_gross' table. The results are ordered by the total gross, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 4651,
            "vt": "SELECT COUNT(movies_total_gross.movie_title) FROM movies_total_gross WHERE movies_total_gross.mpaa_rating = '[placeholder-type:string]' AND movies_total_gross.genre = '[placeholder-type:string]' AND CAST(SUBSTRING(movies_total_gross.release_date, INSTR(movies_total_gross.release_date, ', ') + [placeholder-type:numeric]) AS INT) BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of movies from the 'movies_total_gross' table that match a specific MPAA rating and genre, while also filtering the release date to fall within a specified range. The placeholders represent the MPAA rating, genre, and the numeric values for the year range."
        },
        {
            "sample_id": 4692,
            "vt": "SELECT movies_total_gross.movie_title, movies_total_gross.total_gross FROM movies_total_gross INNER JOIN \"voice-actors\" AS T2 ON T1.movie_title = T2.movie WHERE voice-actors.\"voice-actor\" = '[placeholder-type:string]' AND CAST(REPLACE(TRIM(movies_total_gross.inflation_adjusted_gross, '[placeholder-type:string]'), ',', '') AS FLOAT) * [placeholder-type:numeric] / CAST(REPLACE(TRIM(movies_total_gross.total_gross, '[placeholder-type:string]'), ',', '') AS FLOAT) * [placeholder-type:numeric] < [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles and total gross earnings of movies from the 'movies_total_gross' table, specifically for those movies that feature a voice actor matching a specified name. It also includes a condition that compares the inflation-adjusted gross to the total gross, adjusted by certain numeric factors, to filter for movies that meet a specific popularity threshold."
        },
        {
            "sample_id": 4624,
            "vt": "SELECT characters.villian FROM director INNER JOIN characters AS T2 ON T1.name = T2.movie_title WHERE director.director = '[placeholder-type:string]' AND NOT characters.villian IS NULL",
            "ba": "The virtual table retrieves the villains from movies directed by a specific director. It joins the 'director' table with the 'characters' table to filter the results based on the director's name, ensuring that only movies with a defined villain are included."
        },
        {
            "sample_id": 4634,
            "vt": "SELECT movies_total_gross.genre FROM characters INNER JOIN movies_total_gross AS T2 ON T2.movie_title = T1.movie_title WHERE characters.villian = '[placeholder-type:string]'",
            "ba": "The virtual table describes the genre of movies from the 'movies_total_gross' table that feature a specific villain. The query joins the 'characters' table with the 'movies_total_gross' table based on the movie title, allowing us to filter by the villain's name."
        },
        {
            "sample_id": 4706,
            "vt": "SELECT characters.release_date FROM characters INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE director.director = '[placeholder-type:string]' AND characters.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the release date of a specific movie from the 'characters' table, joining it with the 'director' table to filter by the director's name. The placeholders represent the director's name and the movie title."
        },
        {
            "sample_id": 4704,
            "vt": "SELECT COUNT(characters.movie_title) FROM characters WHERE SUBSTRING(characters.release_date, LENGTH(characters.release_date) - [placeholder-type:numeric], LENGTH(characters.release_date)) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies from the 'characters' table that were released within a specific range of years. The placeholders represent the start and end years of the release date range."
        },
        {
            "sample_id": 4707,
            "vt": "SELECT characters.villian FROM characters INNER JOIN \"voice-actors\" AS T2 ON T1.movie_title = T2.movie WHERE voice-actors.\"voice-actor\" = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the villain character from the 'characters' table based on the voice actor's name. It joins the 'characters' table with the 'voice-actors' table to find the corresponding villain for a specific voice actor."
        },
        {
            "sample_id": 4718,
            "vt": "SELECT CAST(COUNT(CASE WHEN movies_total_gross.genre = '[placeholder-type:string]' THEN voice-actors.\"voice-actor\" ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(voice-actors.\"voice-actor\") FROM movies_total_gross INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title INNER JOIN \"voice-actors\" AS T3 ON T3.movie = T1.movie_title",
            "ba": "The virtual table calculates the proportion of voice actors associated with movies of a specific genre compared to the total number of voice actors. It uses a conditional count to determine how many voice actors belong to movies of the specified genre, and then divides this by the total count of voice actors, adjusting the result by a numeric placeholder."
        },
        {
            "sample_id": 4662,
            "vt": "SELECT characters.villian FROM characters WHERE characters.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the villain character from a specific movie in the 'characters' table. The placeholder in the WHERE clause represents the title of the movie."
        },
        {
            "sample_id": 4715,
            "vt": "SELECT movies_total_gross.genre FROM movies_total_gross INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title WHERE characters.hero = '[placeholder-type:string]'",
            "ba": "The virtual table describes the genre of movies from the 'movies_total_gross' table that feature a specific hero character. The query joins the 'movies_total_gross' table with the 'characters' table to filter the results based on the hero's name, represented by a placeholder."
        },
        {
            "sample_id": 4640,
            "vt": "SELECT characters.song FROM movies_total_gross INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title WHERE CAST(SUBSTRING(movies_total_gross.release_date, INSTR(movies_total_gross.release_date, ', ') + [placeholder-type:numeric]) AS INT) BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] ORDER BY CAST(REPLACE(SUBSTRING(movies_total_gross.total_gross, [placeholder-type:numeric]), ',', '') AS FLOAT) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the songs associated with movies from the 'movies_total_gross' table, filtering the results based on the release date range and ordering them by total gross. The placeholders allow users to specify the year range and limit the number of results returned."
        },
        {
            "sample_id": 4709,
            "vt": "SELECT characters.movie_title FROM characters INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE director.director = '[placeholder-type:string]' AND SUBSTRING(characters.release_date, LENGTH(characters.release_date) - [placeholder-type:numeric], LENGTH(characters.release_date)) < '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of movies from the 'characters' table that were directed by a specific director and released before a certain year. The query uses an inner join to connect the 'characters' table with the 'director' table based on the movie title, filtering results by the director's name and the release date."
        },
        {
            "sample_id": 4670,
            "vt": "SELECT director.name, voice-actors.\"voice-actor\" FROM director INNER JOIN \"voice-actors\" AS T2 ON T1.name = T2.movie WHERE director.director = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of directors and their corresponding voice actors from the 'director' and 'voice-actors' tables. It filters the results based on a specific director's name provided as a placeholder."
        },
        {
            "sample_id": 4730,
            "vt": "SELECT SUM(CAST(REPLACE(TRIM(movies_total_gross.inflation_adjusted_gross, '[placeholder-type:string]'), ',', '') AS FLOAT)) / SUM(CAST(REPLACE(TRIM(movies_total_gross.total_gross, '[placeholder-type:string]'), ',', '') AS FLOAT)) FROM movies_total_gross WHERE SUBSTRING(movies_total_gross.release_date, LENGTH(movies_total_gross.release_date) - [placeholder-type:numeric], LENGTH(movies_total_gross.release_date)) = '[placeholder-type:string]' GROUP BY SUBSTRING(movies_total_gross.release_date, LENGTH(movies_total_gross.release_date) - [placeholder-type:numeric], LENGTH(movies_total_gross.release_date)) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the ratio of the total inflation-adjusted gross to the total gross of movies released in a specific year. It uses placeholders to filter the release date and to handle string values for the inflation-adjusted gross and total gross columns."
        },
        {
            "sample_id": 4684,
            "vt": "SELECT movies_total_gross.movie_title, movies_total_gross.release_date FROM movies_total_gross WHERE movies_total_gross.mpaa_rating = '[placeholder-type:string]' AND movies_total_gross.genre = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles and release dates of movies from the 'movies_total_gross' table that match a specific MPAA rating and genre. The placeholders in the WHERE clause represent the MPAA rating and genre of the movies."
        },
        {
            "sample_id": 4726,
            "vt": "SELECT director.director FROM movies_total_gross INNER JOIN director AS T2 ON T1.movie_title = T2.name ORDER BY CAST(REPLACE(TRIM(movies_total_gross.total_gross, '[placeholder-type:string]'), ',', '') AS FLOAT) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of directors from the 'director' table who have directed movies listed in the 'movies_total_gross' table. The results are ordered by the total gross of the movies, with a limit on the number of directors returned. The total gross is processed to remove any commas and convert it to a float for accurate sorting."
        },
        {
            "sample_id": 4695,
            "vt": "SELECT voice-actors.\"voice-actor\" FROM \"voice-actors\" INNER JOIN characters AS T2 ON T1.movie = T2.movie_title WHERE characters.movie_title = '[placeholder-type:string]' AND voice-actors.character = '[placeholder-type:string]'",
            "ba": "The virtual table describes the voice actors associated with a specific character in a specific movie. It retrieves the name of the voice actor from the 'voice-actors' table by joining it with the 'characters' table based on the movie title. The placeholders represent the movie title and the character's name."
        },
        {
            "sample_id": 4723,
            "vt": "SELECT voice-actors.\"voice-actor\" FROM \"voice-actors\" WHERE voice-actors.character = '[placeholder-type:string]'",
            "ba": "The virtual table describes the voice actors associated with a specific character from the 'voice-actors' table. The placeholder in the WHERE clause represents the name of the character for which we want to find the corresponding voice actor."
        },
        {
            "sample_id": 4672,
            "vt": "SELECT movies_total_gross.movie_title FROM movies_total_gross INNER JOIN characters AS T2 ON T2.movie_title = T1.movie_title WHERE characters.song IS NULL ORDER BY CAST(REPLACE(TRIM(movies_total_gross.total_gross, '[placeholder-type:string]'), ',', '') AS FLOAT) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies from the 'movies_total_gross' table that do not have an associated song in the 'characters' table. The query joins the 'movies_total_gross' and 'characters' tables on the movie title, filtering for records where the song is null. The results are ordered by the total gross of the movies, with a limit on the number of results returned."
        },
        {
            "sample_id": 4734,
            "vt": "SELECT SUM(CASE WHEN CAST(REPLACE(TRIM(movies_total_gross.inflation_adjusted_gross, '[placeholder-type:string]'), ',', '') AS FLOAT) > [placeholder-type:numeric] THEN CAST(REPLACE(TRIM(movies_total_gross.inflation_adjusted_gross, '[placeholder-type:string]'), ',', '') AS FLOAT) ELSE [placeholder-type:numeric] END) * [placeholder-type:numeric] / SUM(CAST(REPLACE(TRIM(movies_total_gross.inflation_adjusted_gross, '[placeholder-type:string]'), ',', '') AS FLOAT)) FROM movies_total_gross",
            "ba": "The virtual table calculates a weighted average of inflation-adjusted gross revenues for movies, where the gross is considered only if it exceeds a specified threshold. The calculation involves summing the adjusted gross values that meet the condition and multiplying by a specified factor, then dividing by the total sum of all inflation-adjusted gross values."
        },
        {
            "sample_id": 4694,
            "vt": "SELECT voice-actors.\"voice-actor\", characters.villian FROM \"voice-actors\" INNER JOIN characters AS T2 ON T1.movie = T2.movie_title WHERE characters.movie_title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the voice actors and their corresponding villains from the 'voice-actors' and 'characters' tables. It retrieves the names of voice actors who voiced characters in a specific movie, along with the villains associated with that movie. The placeholder in the WHERE clause represents the title of the movie."
        },
        {
            "sample_id": 4656,
            "vt": "SELECT COUNT((SELECT T1.name FROM director AS T1 INNER JOIN movies_total_gross AS T2 ON T1.name = T2.movie_title WHERE T1.director = 'Gary Trousdale' AND T2.genre = 'Adventure' GROUP BY T1.name).name) FROM (SELECT director.name FROM director AS T1 INNER JOIN movies_total_gross AS T2 ON T1.name = T2.movie_title WHERE T1.director = 'Gary Trousdale' AND T2.genre = 'Adventure' GROUP BY T1.name) AS t",
            "ba": "The virtual table counts the number of unique movies directed by a specific director in a particular genre. It retrieves the names of movies directed by 'Gary Trousdale' that fall under the 'Adventure' genre, ensuring that only distinct movie titles are considered in the count."
        },
        {
            "sample_id": 4660,
            "vt": "SELECT COUNT(*) FROM director INNER JOIN movies_total_gross AS T2 ON T1.name = T2.movie_title WHERE director.director = '[placeholder-type:string]' AND movies_total_gross.mpaa_rating = '[placeholder-type:string]' AND movies_total_gross.genre = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies directed by a specific director that meet certain criteria. It joins the 'director' table with the 'movies_total_gross' table to filter movies based on the director's name, the MPAA rating, and the genre of the movie. The placeholders represent the director's name, the MPAA rating, and the genre respectively."
        },
        {
            "sample_id": 4688,
            "vt": "SELECT characters.movie_title, director.director FROM characters INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE characters.hero = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of movies along with their directors from the 'characters' and 'director' tables, filtered by a specific hero character. The placeholder in the WHERE clause represents the name of the hero character."
        },
        {
            "sample_id": 4667,
            "vt": "SELECT voice-actors.\"voice-actor\" FROM characters INNER JOIN \"voice-actors\" AS T2 ON T2.character = T1.hero WHERE voice-actors.movie = characters.movie_title",
            "ba": "The virtual table retrieves the names of voice actors who provided the voice for the main characters in various movies. It joins the 'characters' table, which contains information about the main characters and their respective movies, with the 'voice-actors' table, which lists the voice actors and the characters they portray. The join condition ensures that only those voice actors who voiced the heroes in the movies are selected."
        },
        {
            "sample_id": 4632,
            "vt": "SELECT movies_total_gross.movie_title FROM \"movies_total_gross\" INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE movies_total_gross.mpaa_rating = '[placeholder-type:string]' AND director.director = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of movies from the 'movies_total_gross' table that have a specific MPAA rating and are directed by a particular director. The placeholders in the WHERE clause represent the MPAA rating and the director's name."
        },
        {
            "sample_id": 4626,
            "vt": "SELECT director.director FROM characters INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE characters.song = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of directors from the 'director' table for movies that feature a specific song. It joins the 'characters' table with the 'director' table based on the movie title, allowing us to filter results by the song associated with the characters."
        },
        {
            "sample_id": 4642,
            "vt": "SELECT voice-actors.\"voice-actor\" FROM characters INNER JOIN \"voice-actors\" AS T2 ON T2.movie = T1.movie_title WHERE characters.movie_title = '[placeholder-type:string]' AND voice-actors.character = characters.hero",
            "ba": "The virtual table describes the voice actors associated with the main characters of a specific movie from the 'characters' table. The query joins the 'characters' table with the 'voice-actors' table to retrieve the names of voice actors for the hero character in the specified movie."
        },
        {
            "sample_id": 4628,
            "vt": "SELECT characters.release_date FROM \"voice-actors\" INNER JOIN characters AS T2 ON T1.movie = T2.movie_title WHERE voice-actors.\"voice-actor\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the release dates of movies from the 'characters' table, filtered by a specific voice actor's name. The query uses an inner join to connect the 'voice-actors' table with the 'characters' table based on the movie title, allowing us to retrieve the release date of movies associated with a particular voice actor."
        },
        {
            "sample_id": 4713,
            "vt": "SELECT characters.hero FROM movies_total_gross INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title WHERE movies_total_gross.genre = '[placeholder-type:string]'",
            "ba": "The virtual table describes the main characters (heroes) of movies from the 'characters' table that belong to a specific genre as indicated in the 'movies_total_gross' table. The placeholder in the WHERE clause represents the genre of the movie."
        },
        {
            "sample_id": 4622,
            "vt": "SELECT CASE WHEN revenue.\"studio entertainment[ni 1]\" > revenue.\"disney media networks\" THEN revenue.\"studio entertainment[ni 1]\" ELSE revenue.\"disney media networks\" END FROM revenue WHERE revenue.\"year\" = [placeholder-type:numeric]",
            "ba": "The virtual table identifies the higher revenue between the studio entertainment segment and the media networks segment of the Walt Disney Company for a specific year. The placeholder in the WHERE clause represents the year of interest."
        },
        {
            "sample_id": 4668,
            "vt": "SELECT director.director FROM movies_total_gross INNER JOIN director AS T2 ON T1.movie_title = T2.name AND CAST(SUBSTRING(release_date, INSTR(release_date, ', ') + 1) AS INT) BETWEEN 1990 AND 2000 GROUP BY director.director",
            "ba": "The virtual table lists the directors of movies that were released between 1990 and 2000. It retrieves this information by joining the 'movies_total_gross' table with the 'director' table based on the movie title. The results are grouped by the director's name to ensure each director is listed only once."
        },
        {
            "sample_id": 4702,
            "vt": "SELECT director.director FROM director WHERE director.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the name of the director from the 'director' table based on a specific movie title. The placeholder in the WHERE clause represents the movie title for which the director's name is being queried."
        },
        {
            "sample_id": 4638,
            "vt": "SELECT voice-actors.\"voice-actor\" FROM \"voice-actors\" WHERE voice-actors.character = '[placeholder-type:string]'",
            "ba": "The virtual table describes the voice actors associated with a specific character from the 'voice-actors' table. The placeholder in the WHERE clause represents the name of the character for which we want to find the corresponding voice actor."
        },
        {
            "sample_id": 4677,
            "vt": "SELECT movies_total_gross.movie_title FROM director INNER JOIN movies_total_gross AS T2 ON T1.name = T2.movie_title WHERE director.director = '[placeholder-type:string]' ORDER BY CAST(REPLACE(TRIM(movies_total_gross.total_gross, '[placeholder-type:string]'), ',', '') AS FLOAT) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies directed by a specific director from the 'director' table. It joins the 'director' table with the 'movies_total_gross' table to filter movies based on the director's name. The results are ordered by the total gross of the movies, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 4650,
            "vt": "SELECT director.director FROM director GROUP BY director.director ORDER BY COUNT(director.name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the directors from the 'director' table, grouping them by their names to count how many movies each director has made. It orders the results by the number of movies in descending order and limits the output to a specified number of directors."
        }
    ],
    "beer_factory": [
        {
            "sample_id": 5338,
            "vt": "SELECT rootbeer.rootbeerid FROM rootbeer INNER JOIN rootbeerbrand AS T2 ON T2.BrandID = T1.BrandID WHERE rootbeerbrand.brandname IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table lists the unique identifiers of root beers from the 'rootbeer' table that are associated with specific brands. The brands are filtered based on their names, which are provided as placeholders for string values."
        },
        {
            "sample_id": 5299,
            "vt": "SELECT COUNT(customers.customerid) FROM customers INNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN rootbeer AS T3 ON T2.RootBeerID = T3.RootBeerID INNER JOIN rootbeerbrand AS T4 ON T3.BrandID = T4.BrandID WHERE customers.gender = '[placeholder-type:string]' AND rootbeerbrand.artificialsweetener = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table who have made transactions for root beers that contain artificial sweeteners. It filters the results based on the gender of the customers and whether the root beer brand includes artificial sweeteners, using placeholders for both criteria."
        },
        {
            "sample_id": 5238,
            "vt": "SELECT COUNT(customers.customerid) FROM customers INNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]' AND STRFTIME('%Y-%m', transaction.transactiondate) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of transactions made by a specific customer identified by their first and last names during a specified month and year. It joins the 'customers' table with the 'transaction' table to filter the results based on the customer's name and the transaction date."
        },
        {
            "sample_id": 5302,
            "vt": "SELECT CAST(COUNT(CASE WHEN rootbeerbrand.brandname = '[placeholder-type:string]' THEN customers.customerid ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(customers.customerid) FROM customers INNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN rootbeer AS T3 ON T2.RootBeerID = T3.RootBeerID INNER JOIN rootbeerbrand AS T4 ON T3.BrandID = T4.BrandID WHERE customers.city = '[placeholder-type:string]' AND customers.gender = '[placeholder-type:string]' AND transaction.transactiondate LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of customers who have purchased a specific root beer brand in a given city and gender, over a specified transaction date. It counts the number of unique customers who bought the specified brand and divides it by the total number of customers in that city, multiplying by a numeric placeholder to adjust the result. The placeholders represent the brand name, city, gender, and transaction date respectively."
        },
        {
            "sample_id": 5306,
            "vt": "SELECT DISTINCT geolocation.latitude, geolocation.longitude FROM \"transaction\" INNER JOIN geolocation AS T2 ON T1.LocationID = T2.LocationID WHERE transaction.creditcardtype = '[placeholder-type:string]'",
            "ba": "The virtual table provides distinct latitude and longitude coordinates from the 'geolocation' table based on transactions filtered by credit card type. The placeholder in the WHERE clause represents the specific credit card type used in the transactions."
        },
        {
            "sample_id": 5270,
            "vt": "SELECT COUNT(customers.customerid) FROM customers WHERE customers.first = '[placeholder-type:string]' AND customers.city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table who have a specific first name and live in a specified city. The placeholders in the WHERE clause represent the first name of the customer and the city they reside in."
        },
        {
            "sample_id": 5323,
            "vt": "SELECT COUNT(customers.customerid) FROM customers INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID WHERE rootbeerreview.starrating = [placeholder-type:numeric] AND customers.city = '[placeholder-type:string]' AND customers.gender = '[placeholder-type:string]' AND customers.subscribedtoemaillist = '[placeholder-type:string]' AND rootbeerreview.reviewdate BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table who have provided a review for root beer, filtered by specific criteria. It includes conditions for the star rating of the review, the city of the customer, their gender, their subscription status to the email list, and a date range for when the review was made."
        },
        {
            "sample_id": 5293,
            "vt": "SELECT CAST(COUNT(rootbeer.rootbeerid) AS FLOAT) / COUNT(DISTINCT T2.PurchaseDate) FROM rootbeerbrand INNER JOIN rootbeer AS T2 ON T1.BrandID = T2.BrandID INNER JOIN \"transaction\" AS T3 ON T2.RootBeerID = T3.RootBeerID WHERE rootbeerbrand.caffeinated = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of root beers sold per purchase date for a specific brand based on whether the root beer is caffeinated or not. It joins the 'rootbeerbrand', 'rootbeer', and 'transaction' tables to gather the necessary data, filtering by the caffeinated status of the root beer."
        },
        {
            "sample_id": 5325,
            "vt": "SELECT rootbeerbrand.brandname FROM rootbeer INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID WHERE rootbeerbrand.firstbrewedyear < '[placeholder-type:string]' AND rootbeer.containertype = '[placeholder-type:string]' ORDER BY rootbeerbrand.firstbrewedyear LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of root beer brands from the 'rootbeerbrand' table that were first brewed before a specified year and are available in a specific container type. The placeholders represent the year and container type, allowing users to filter the results based on their criteria."
        },
        {
            "sample_id": 5362,
            "vt": "SELECT geolocation.latitude, geolocation.longitude FROM location INNER JOIN geolocation AS T2 ON T1.LocationID = T2.LocationID WHERE location.locationname = '[placeholder-type:string]'",
            "ba": "The virtual table provides the latitude and longitude coordinates of a specific location from the 'location' table by joining it with the 'geolocation' table. The placeholder in the WHERE clause represents the name of the location being queried."
        },
        {
            "sample_id": 5337,
            "vt": "SELECT transaction.rootbeerid FROM customers INNER JOIN \"transaction\" AS T2 ON T2.CustomerID = T1.CustomerID WHERE (customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]') OR (customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]')",
            "ba": "The virtual table retrieves the unique identifiers of root beers purchased by customers based on their first and last names. It joins the 'customers' table with the 'transaction' table to filter transactions for specific customers identified by their names."
        },
        {
            "sample_id": 5352,
            "vt": "SELECT COUNT(transaction.transactionid) FROM \"transaction\" INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE location.locationname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of transactions from the 'transaction' table for a specific location. It joins the 'transaction' table with the 'location' table to filter transactions based on the location name provided by the user."
        },
        {
            "sample_id": 5301,
            "vt": "SELECT rootbeerbrand.breweryname FROM rootbeer INNER JOIN \"transaction\" AS T2 ON T1.RootBeerID = T2.RootBeerID INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID WHERE transaction.transactiondate LIKE '[placeholder-type:string]' GROUP BY rootbeerbrand.brandid ORDER BY COUNT(rootbeer.brandid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the brewery names of root beer brands sold in transactions that occurred on a specific date. The query joins the 'rootbeer', 'transaction', and 'rootbeerbrand' tables to filter and group the results based on the transaction date, allowing users to see which breweries had the most sales on that date. The placeholders represent the transaction date and the limit on the number of results returned."
        },
        {
            "sample_id": 5329,
            "vt": "SELECT SUM(transaction.purchaseprice) FROM \"transaction\" INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE location.locationname = '[placeholder-type:string]' AND transaction.creditcardtype = '[placeholder-type:string]' AND transaction.transactiondate BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total purchase price of transactions from the 'transaction' table, filtered by a specific location name, credit card type, and a date range for the transaction date. The placeholders represent the location name, credit card type, and the start and end dates for the transaction period."
        },
        {
            "sample_id": 5250,
            "vt": "SELECT CAST(COUNT(rootbeer.brandid) AS FLOAT) / [placeholder-type:numeric] FROM rootbeer INNER JOIN \"transaction\" AS T2 ON T1.RootBeerID = T2.RootBeerID INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID WHERE transaction.transactiondate LIKE '[placeholder-type:string]' AND rootbeerbrand.brandname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of transactions for a specific root beer brand on a given date. It does this by counting the number of occurrences of the brand's ID in the 'rootbeer' table, joining it with the 'transaction' table to filter by transaction date, and then dividing by a specified numeric placeholder to get the average."
        },
        {
            "sample_id": 5260,
            "vt": "SELECT transaction.transactiondate FROM customers INNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]' ORDER BY transaction.transactiondate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the transaction dates for a specific customer from the 'customers' and 'transaction' tables. It filters the results based on the customer's first and last names, and orders the transactions by date, limiting the number of results returned."
        },
        {
            "sample_id": 5272,
            "vt": "SELECT rootbeerbrand.brandname FROM customers INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN rootbeerbrand AS T3 ON T2.BrandID = T3.BrandID WHERE customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]' AND rootbeerreview.starrating = [placeholder-type:numeric]",
            "ba": "The virtual table lists the brand names of root beers reviewed by a specific customer based on their first and last names, along with a specified star rating for the review. The query joins the 'customers', 'rootbeerreview', and 'rootbeerbrand' tables to filter the results accordingly."
        },
        {
            "sample_id": 5346,
            "vt": "SELECT rootbeerbrand.brandname FROM rootbeer INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID GROUP BY rootbeerbrand.brandid ORDER BY COUNT(rootbeer.brandid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the brand names of root beers from the 'rootbeerbrand' table. It retrieves the data by joining the 'rootbeer' table with the 'rootbeerbrand' table based on the brand ID. The results are grouped by brand ID to count the occurrences of each brand in the 'rootbeer' table, and then ordered by this count. The LIMIT clause allows for specifying a maximum number of results to return, represented by a numeric placeholder."
        },
        {
            "sample_id": 5267,
            "vt": "SELECT rootbeerbrand.brandname FROM rootbeerbrand ORDER BY rootbeerbrand.firstbrewedyear LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of root beer brands from the 'rootbeerbrand' table, ordered by the year they were first brewed. The placeholder in the LIMIT clause allows the user to specify how many brand names they want to retrieve."
        },
        {
            "sample_id": 5360,
            "vt": "SELECT location.locationname FROM rootbeer INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE rootbeer.containertype = '[placeholder-type:string]' GROUP BY location.locationid ORDER BY COUNT(rootbeer.locationid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of locations where root beers of a specific container type are sold. The results are grouped by location and ordered by the count of root beers available at each location, with a limit on the number of locations returned."
        },
        {
            "sample_id": 5342,
            "vt": "SELECT (SELECT COUNT(rootbeer.brandid) FROM rootbeer AS T1 INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID WHERE T2.State = 'LA' AND T1.ContainerType = 'Bottle') - (SELECT COUNT(rootbeer.brandid) FROM rootbeer AS T3 INNER JOIN rootbeerbrand AS T4 ON T3.BrandID = T4.BrandID WHERE T4.State = 'MO' AND T3.ContainerType = 'Bottle')",
            "ba": "The virtual table calculates the difference in the number of root beer brands available in bottles between two states: Louisiana and Missouri. It does this by counting the number of brands in Louisiana and subtracting the count of brands in Missouri, both filtered by the container type 'Bottle'."
        },
        {
            "sample_id": 5242,
            "vt": "SELECT DISTINCT rootbeerbrand.brandname FROM customers INNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN rootbeer AS T3 ON T2.RootBeerID = T3.RootBeerID INNER JOIN rootbeerbrand AS T4 ON T3.BrandID = T4.BrandID WHERE customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]' AND transaction.transactiondate = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct brand names of root beers purchased by a specific customer on a particular transaction date. It combines data from the 'customers', 'transaction', 'rootbeer', and 'rootbeerbrand' tables, filtering based on the customer's first and last names and the transaction date."
        },
        {
            "sample_id": 5300,
            "vt": "SELECT COUNT(CASE WHEN rootbeerbrand.canesugar = '[placeholder-type:string]' THEN rootbeer.brandid ELSE NULL END) - COUNT(CASE WHEN rootbeerbrand.cornsyrup = '[placeholder-type:string]' THEN rootbeer.brandid ELSE NULL END) FROM rootbeer INNER JOIN \"transaction\" AS T2 ON T1.RootBeerID = T2.RootBeerID INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID",
            "ba": "The virtual table calculates the difference between the count of root beers that contain cane sugar and those that contain corn syrup. It does this by joining the 'rootbeer' table with the 'transaction' table and the 'rootbeerbrand' table to access the necessary attributes for filtering."
        },
        {
            "sample_id": 5290,
            "vt": "SELECT CAST(COUNT(CASE WHEN transaction.creditcardtype = '[placeholder-type:string]' THEN transaction.transactionid ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(transaction.transactionid) FROM \"transaction\"",
            "ba": "The virtual table calculates the percentage of transactions made with a specific credit card type from the 'transaction' table. It counts the total number of transactions and the number of transactions that match the specified credit card type, then computes the percentage based on these counts. The placeholder in the COUNT function represents the credit card type, while the numeric placeholder is used to scale the result appropriately."
        },
        {
            "sample_id": 5248,
            "vt": "SELECT COUNT(customers.customerid) FROM customers INNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN rootbeer AS T3 ON T2.RootBeerID = T3.RootBeerID INNER JOIN rootbeerbrand AS T4 ON T3.BrandID = T4.BrandID WHERE customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]' AND rootbeerbrand.artificialsweetener = '[placeholder-type:string]' AND rootbeerbrand.honey = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers who have made transactions for root beers that contain artificial sweeteners and honey. It joins the 'customers' table with the 'transaction' table to link customers to their purchases, then further joins with the 'rootbeer' table to access the specific root beers purchased, and finally joins with the 'rootbeerbrand' table to filter based on the characteristics of the root beers. The placeholders represent the customer's first name, last name, and the attributes of the root beer brand."
        },
        {
            "sample_id": 5296,
            "vt": "SELECT COUNT(rootbeer.brandid) FROM \"transaction\" INNER JOIN geolocation AS T2 ON T1.LocationID = T2.LocationID INNER JOIN location AS T3 ON T1.LocationID = T3.LocationID INNER JOIN rootbeer AS T4 ON T1.RootBeerID = T4.RootBeerID WHERE geolocation.latitude = [placeholder-type:numeric] AND geolocation.longitude = -[placeholder-type:numeric] AND rootbeer.containertype = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of root beer brands sold in transactions that match specific geographical coordinates and container type. It joins the 'transaction' table with 'geolocation', 'location', and 'rootbeer' tables to filter the results based on latitude, longitude, and the type of container used for the root beer."
        },
        {
            "sample_id": 5276,
            "vt": "SELECT COUNT(transaction.rootbeerid) FROM customers INNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]' AND transaction.transactiondate BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of transactions for a specific customer based on their first and last names, and filters the transactions within a specified date range. The placeholders represent the customer's first name, last name, and the start and end dates for the transaction period."
        },
        {
            "sample_id": 5353,
            "vt": "SELECT rootbeerreview.starrating FROM customers INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN rootbeerbrand AS T3 ON T2.BrandID = T3.BrandID WHERE customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]' AND rootbeerbrand.brandname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the star ratings of root beer reviews made by a specific customer identified by their first and last names. It joins the 'customers' table with the 'rootbeerreview' table to link customer information with their reviews, and further joins the 'rootbeerbrand' table to filter the results based on a specific brand name. The placeholders in the WHERE clause represent the customer's first name, last name, and the brand name of the root beer being reviewed."
        },
        {
            "sample_id": 5268,
            "vt": "SELECT customers.first, customers.last FROM customers ORDER BY customers.firstpurchasedate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of customers from the 'customers' table, ordered by their first purchase date. The placeholder in the LIMIT clause represents the maximum number of records to return."
        },
        {
            "sample_id": 5239,
            "vt": "SELECT COUNT(customers.customerid) FROM customers INNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.gender = '[placeholder-type:string]' AND STRFTIME('%Y-%m', transaction.transactiondate) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table who have made transactions in a specific month and year, filtered by their gender. The placeholders represent the gender of the customers and the specific month and year of the transactions."
        },
        {
            "sample_id": 5309,
            "vt": "SELECT rootbeerbrand.brandname FROM customers INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN rootbeerbrand AS T3 ON T2.BrandID = T3.BrandID WHERE customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]'",
            "ba": "The virtual table lists the brand names of root beers reviewed by a specific customer identified by their first and last names. The query joins the 'customers' table with the 'rootbeerreview' table to link customer reviews to the corresponding root beer brands in the 'rootbeerbrand' table. The placeholders in the WHERE clause represent the customer's first and last names."
        },
        {
            "sample_id": 5357,
            "vt": "SELECT DISTINCT geolocation.latitude, geolocation.longitude FROM geolocation INNER JOIN \"transaction\" AS T2 ON T2.LocationID = T1.LocationID INNER JOIN customers AS T3 ON T3.CustomerID = T2.CustomerID WHERE customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]' AND transaction.transactiondate LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct latitude and longitude coordinates from the 'geolocation' table for customers based on their first and last names, as well as the transaction date. The placeholders represent the customer's first name, last name, and the specific transaction date."
        },
        {
            "sample_id": 5339,
            "vt": "SELECT COUNT(rootbeer.containertype) FROM customers INNER JOIN \"transaction\" AS T2 ON T2.CustomerID = T1.CustomerID INNER JOIN rootbeer AS T3 ON T3.RootBeerID = T2.RootBeerID WHERE rootbeer.containertype = '[placeholder-type:string]' AND customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of root beer containers purchased by a specific customer identified by their first and last names. It joins the 'customers' table with the 'transaction' table to link customer transactions and then further joins with the 'rootbeer' table to filter by the type of container. The placeholders represent the container type and the customer's first and last names."
        },
        {
            "sample_id": 5305,
            "vt": "SELECT DISTINCT rootbeerbrand.brandname FROM rootbeerbrand INNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID WHERE rootbeerreview.starrating = [placeholder-type:numeric] AND rootbeerreview.reviewdate BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct brand names of root beer from the 'rootbeerbrand' table that have received a specific star rating within a defined date range for their reviews. The placeholders represent the star rating and the date range for filtering the reviews."
        },
        {
            "sample_id": 5344,
            "vt": "SELECT customers.first, customers.last, transaction.creditcardtype FROM customers INNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY customers.customerid ORDER BY SUM(transaction.purchaseprice) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of customers along with their first and last names, and the type of credit card they used for transactions. It aggregates the transaction data by customer, grouping them based on their unique customer ID, and orders the results by the total purchase price in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 5318,
            "vt": "SELECT CAST(COUNT(CASE WHEN rootbeerreview.starrating = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(rootbeerreview.customerid) FROM rootbeerreview INNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID WHERE transaction.creditcardtype = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average star rating of root beer reviews based on a specific credit card type used in transactions. It counts the number of reviews that match a given star rating and multiplies it by a specified numeric value, then divides by the total number of customer reviews to get the average. The placeholders represent the star rating, a numeric multiplier, and the credit card type."
        },
        {
            "sample_id": 5249,
            "vt": "SELECT transaction.transactiondate FROM customers INNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.gender = '[placeholder-type:string]' GROUP BY transaction.transactiondate HAVING COUNT(transaction.customerid) > [placeholder-type:numeric]",
            "ba": "The virtual table displays the transaction dates from the 'transaction' table for customers of a specific gender. It filters the results based on the gender of the customers and groups the results by transaction date, only including those dates where the count of transactions exceeds a specified numeric threshold."
        },
        {
            "sample_id": 5308,
            "vt": "SELECT DISTINCT customers.city FROM customers INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID WHERE rootbeerreview.starrating = [placeholder-type:numeric] AND rootbeerreview.reviewdate BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct cities from the 'customers' table where customers have provided reviews for root beers. It filters the reviews based on a specific star rating and a date range for the review date."
        },
        {
            "sample_id": 5310,
            "vt": "SELECT rootbeerbrand.brandname FROM rootbeerbrand INNER JOIN rootbeerreview AS T2 ON T2.BrandID = T1.BrandID WHERE rootbeerreview.starrating = [placeholder-type:numeric] GROUP BY rootbeerbrand.brandname ORDER BY COUNT(rootbeerbrand.brandname) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of root beer brands from the 'rootbeerbrand' table that have received a specific star rating from customer reviews. It uses an inner join with the 'rootbeerreview' table to filter brands based on the star rating provided. The results are grouped by brand name and ordered by the count of reviews, allowing for a limit on the number of brands returned."
        },
        {
            "sample_id": 5254,
            "vt": "SELECT geolocation.latitude, geolocation.longitude FROM location INNER JOIN geolocation AS T2 ON T1.LocationID = T2.LocationID WHERE location.locationname = '[placeholder-type:string]'",
            "ba": "The virtual table provides the latitude and longitude coordinates of a specific location by joining the 'location' and 'geolocation' tables. The placeholder in the WHERE clause represents the name of the location being queried."
        },
        {
            "sample_id": 5237,
            "vt": "SELECT rootbeerbrand.city FROM rootbeerbrand WHERE rootbeerbrand.breweryname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the cities where root beer brands are brewed, filtered by a specific brewery name. The placeholder in the WHERE clause represents the name of the brewery."
        },
        {
            "sample_id": 5333,
            "vt": "SELECT rootbeerbrand.brandname, rootbeerbrand.currentretailprice - rootbeerbrand.wholesalecost FROM rootbeerbrand INNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID WHERE rootbeerreview.starrating = [placeholder-type:numeric] AND rootbeerreview.reviewdate BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table describes the brand names of root beers along with their profit margins, calculated as the difference between the current retail price and the wholesale cost. It filters the results based on a specific star rating and a range of review dates."
        },
        {
            "sample_id": 5356,
            "vt": "SELECT DISTINCT rootbeerbrand.brandname FROM rootbeerbrand INNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID WHERE rootbeerbrand.canesugar = '[placeholder-type:string]' AND rootbeerbrand.honey = '[placeholder-type:string]' AND rootbeerreview.starrating = [placeholder-type:numeric] AND rootbeerreview.reviewdate LIKE '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct brand names of root beer from the 'rootbeerbrand' table that meet specific criteria. It filters brands based on whether they contain cane sugar and honey, as well as the star rating from reviews and the review date."
        },
        {
            "sample_id": 5282,
            "vt": "SELECT geolocation.latitude, geolocation.longitude FROM location INNER JOIN geolocation AS T2 ON T1.LocationID = T2.LocationID WHERE location.locationname = '[placeholder-type:string]'",
            "ba": "The virtual table provides the latitude and longitude coordinates of a specific location by joining the 'location' and 'geolocation' tables. The placeholder in the WHERE clause represents the name of the location being queried."
        },
        {
            "sample_id": 5327,
            "vt": "SELECT AVG(rootbeerreview.starrating) FROM customers INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID WHERE rootbeerreview.brandid = [placeholder-type:numeric] AND customers.gender = '[placeholder-type:string]' AND rootbeerreview.reviewdate BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average star rating of root beers reviewed by customers from the 'customers' table, filtered by a specific brand ID, gender of the customer, and a date range for the review date. The placeholders represent the brand ID, gender, and the start and end dates for filtering the reviews."
        },
        {
            "sample_id": 5315,
            "vt": "SELECT geolocation.latitude, geolocation.longitude FROM location INNER JOIN geolocation AS T2 ON T1.LocationID = T2.LocationID WHERE location.zipcode = [placeholder-type:numeric]",
            "ba": "The virtual table provides the latitude and longitude coordinates of locations from the 'location' table that match a specific zip code. The query uses an inner join to connect the 'location' table with the 'geolocation' table based on their shared location ID, allowing for the retrieval of geographic coordinates associated with a given zip code."
        },
        {
            "sample_id": 5277,
            "vt": "SELECT rootbeerbrand.brandname FROM rootbeerbrand INNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID WHERE rootbeerreview.starrating = [placeholder-type:numeric]",
            "ba": "The virtual table describes the brand names of root beers from the 'rootbeerbrand' table that have received a specific star rating in reviews. The placeholder in the WHERE clause represents the star rating given by customers."
        },
        {
            "sample_id": 5326,
            "vt": "SELECT COUNT(transaction.customerid) FROM customers INNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]' AND transaction.creditcardtype = '[placeholder-type:string]' AND transaction.transactiondate BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of transactions made by a specific customer based on their first and last name, the type of credit card used, and a date range for the transactions. The placeholders represent the customer's first name, last name, credit card type, and the start and end dates for the transaction period."
        },
        {
            "sample_id": 5354,
            "vt": "SELECT rootbeerbrand.brandname FROM rootbeerbrand INNER JOIN rootbeerreview AS T2 ON T2.BrandID = T1.BrandID WHERE rootbeerreview.starrating = [placeholder-type:numeric] AND rootbeerreview.review = '[placeholder-type:string]'",
            "ba": "The virtual table lists the brand names of root beers from the 'rootbeerbrand' table that have received a specific star rating and contain a particular review comment. The placeholders in the WHERE clause represent the star rating and the review content that users can specify."
        },
        {
            "sample_id": 5264,
            "vt": "SELECT CAST(COUNT(CASE WHEN rootbeerreview.starrating = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(rootbeerreview.starrating) FROM rootbeerbrand INNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID WHERE rootbeerbrand.brandname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average star rating of a specific root beer brand from the 'rootbeerbrand' and 'rootbeerreview' tables. It counts the number of reviews that match a specified star rating and multiplies it by a given weight, then divides this by the total number of reviews for that brand. The placeholder in the WHERE clause represents the brand's name, while the numeric placeholders represent the star rating and weight used in the calculation."
        },
        {
            "sample_id": 5288,
            "vt": "SELECT rootbeerbrand.brandname FROM rootbeerbrand WHERE rootbeerbrand.firstbrewedyear BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' ORDER BY rootbeerbrand.firstbrewedyear",
            "ba": "The virtual table lists the names of root beer brands from the 'rootbeerbrand' table that were first brewed within a specified range of years. The placeholders in the WHERE clause represent the start and end years of the brewing period, allowing users to filter brands based on their brewing history."
        },
        {
            "sample_id": 5253,
            "vt": "SELECT DISTINCT transaction.creditcardnumber FROM customers INNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct credit card numbers used by customers from the 'customers' table who have a specific first and last name. The placeholders in the WHERE clause represent the customer's first and last names."
        },
        {
            "sample_id": 5359,
            "vt": "SELECT COUNT(rootbeer.rootbeerid) FROM rootbeer INNER JOIN \"transaction\" AS T2 ON T1.RootBeerID = T2.RootBeerID WHERE rootbeer.containertype = '[placeholder-type:string]' AND transaction.creditcardtype = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of root beers sold based on their container type and the type of credit card used for the transaction. It joins the 'rootbeer' table with the 'transaction' table to filter the results according to the specified container type and credit card type."
        },
        {
            "sample_id": 5280,
            "vt": "SELECT location.locationname FROM rootbeer INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID INNER JOIN location AS T3 ON T1.LocationID = T3.LocationID WHERE rootbeerbrand.brandname = '[placeholder-type:string]' AND location.locationname IN ('[placeholder-type:string]', '[placeholder-type:string]') GROUP BY rootbeer.locationid ORDER BY COUNT(rootbeer.brandid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of locations where a specific root beer brand is sold. It filters the results based on the brand name and restricts the locations to a specified set. The results are grouped by location and ordered by the count of different root beer brands available at each location, with a limit on the number of results returned."
        },
        {
            "sample_id": 5316,
            "vt": "SELECT DISTINCT rootbeerbrand.brandname FROM rootbeer INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID INNER JOIN geolocation AS T3 ON T1.LocationID = T3.LocationID WHERE geolocation.latitude = '[placeholder-type:string]' AND geolocation.longitude = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct brand names of root beer from the 'rootbeerbrand' table, which are associated with specific locations based on their geographical coordinates. The query joins the 'rootbeer' table with the 'rootbeerbrand' table to get the brand names and also joins with the 'geolocation' table to filter the results based on latitude and longitude values provided as placeholders."
        },
        {
            "sample_id": 5292,
            "vt": "SELECT CAST(COUNT(CASE WHEN location.locationname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(transaction.transactionid) FROM \"transaction\" INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID",
            "ba": "The virtual table calculates the percentage of transactions that occurred at a specific location, represented by its name. It counts the total number of transactions and compares it to the number of transactions at the specified location, adjusting the result by a given multiplier."
        },
        {
            "sample_id": 5252,
            "vt": "SELECT COUNT(rootbeerreview.customerid) FROM customers INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of reviews made by a specific customer identified by their first and last names from the 'customers' table, joining it with the 'rootbeerreview' table to link customer reviews."
        },
        {
            "sample_id": 5234,
            "vt": "SELECT rootbeerbrand.brandname FROM rootbeerbrand WHERE NOT rootbeerbrand.facebookpage IS NULL",
            "ba": "The virtual table lists the names of root beer brands from the 'rootbeerbrand' table that have an associated Facebook page, indicating their presence on social media."
        },
        {
            "sample_id": 5261,
            "vt": "SELECT rootbeerbrand.breweryname FROM rootbeerbrand INNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID WHERE rootbeerreview.starrating = [placeholder-type:numeric] GROUP BY rootbeerbrand.brandid ORDER BY COUNT(rootbeerreview.starrating) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of breweries associated with root beer brands that have received a specific star rating from customer reviews. The query joins the 'rootbeerbrand' table with the 'rootbeerreview' table to filter brands based on their star ratings, grouping the results by brand ID and ordering them by the count of reviews. The placeholders allow users to specify the desired star rating and limit the number of results returned."
        },
        {
            "sample_id": 5233,
            "vt": "SELECT COUNT(rootbeerbrand.brandid) FROM rootbeerbrand WHERE rootbeerbrand.country = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of root beer brands from the 'rootbeerbrand' table that are located in a specific country. The placeholder in the WHERE clause represents the country name."
        },
        {
            "sample_id": 5322,
            "vt": "SELECT DISTINCT customers.email, customers.phonenumber FROM customers INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID WHERE rootbeerreview.starrating > [placeholder-type:numeric] AND customers.city = '[placeholder-type:string]' AND rootbeerreview.reviewdate BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of unique email addresses and phone numbers of customers who have given a star rating higher than a specified value for root beer reviews. It filters the customers based on their city and the date range of the reviews."
        },
        {
            "sample_id": 5285,
            "vt": "SELECT rootbeerbrand.brandname, transaction.customerid FROM rootbeer INNER JOIN \"transaction\" AS T2 ON T1.RootBeerID = T2.RootBeerID INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID GROUP BY rootbeerbrand.brandid ORDER BY rootbeerbrand.currentretailprice - rootbeerbrand.wholesalecost, COUNT(rootbeer.brandid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of root beer brands along with the customer IDs of those who purchased them. It joins the 'rootbeer' table with the 'transaction' table to link purchases to specific root beers, and further joins with the 'rootbeerbrand' table to retrieve brand names. The results are grouped by brand ID and ordered by the profit margin (current retail price minus wholesale cost) and the count of purchases for each brand. A limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 5343,
            "vt": "SELECT CAST(COUNT(CASE WHEN location.locationname = '[placeholder-type:string]' THEN transaction.transactionid ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(CASE WHEN location.locationname = '[placeholder-type:string]' THEN transaction.transactionid ELSE NULL END) FROM \"transaction\" INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID",
            "ba": "The virtual table calculates the percentage of transactions that occurred at a specific location, represented by a placeholder for the location name. It counts the total number of transactions at that location and multiplies it by a numeric placeholder, then divides it by the total number of transactions at the same location to get the desired percentage."
        },
        {
            "sample_id": 5297,
            "vt": "SELECT CAST(COUNT(CASE WHEN rootbeerreview.starrating > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(rootbeerreview.customerid) FROM customers INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.subscribedtoemaillist = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage of customers who have given a star rating higher than a specified value for root beer reviews. It does this by counting the number of reviews with a star rating above the placeholder value and dividing it by the total number of reviews from customers who are subscribed to the email list. The result is then multiplied by a placeholder numeric value to adjust the final output."
        },
        {
            "sample_id": 5286,
            "vt": "SELECT customers.first, customers.last, customers.phonenumber FROM customers WHERE customers.gender = '[placeholder-type:string]' AND customers.city = '[placeholder-type:string]' AND customers.subscribedtoemaillist = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names along with the phone numbers of customers from the 'customers' table who meet specific criteria. The placeholders in the WHERE clause represent the customer's gender, city, and their subscription status to the email list."
        },
        {
            "sample_id": 5340,
            "vt": "SELECT COUNT(transaction.rootbeerid) FROM rootbeerbrand INNER JOIN rootbeer AS T2 ON T1.BrandID = T2.BrandID INNER JOIN \"transaction\" AS T3 ON T2.RootBeerID = T3.RootBeerID WHERE rootbeerbrand.state = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of transactions for root beers from a specific brand located in a specified state. It joins the 'rootbeerbrand' table with the 'rootbeer' table to link brands to their respective root beers, and then further joins with the 'transaction' table to count how many times these root beers have been purchased. The placeholder in the WHERE clause represents the state code for filtering the results."
        },
        {
            "sample_id": 5332,
            "vt": "SELECT rootbeerreview.review FROM rootbeerbrand INNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID WHERE rootbeerbrand.brandname = '[placeholder-type:string]' AND rootbeerreview.reviewdate = '[placeholder-type:string]'",
            "ba": "The virtual table describes the reviews of a specific root beer brand from the 'rootbeerbrand' and 'rootbeerreview' tables. It retrieves the review content based on the brand name and the review date provided by the user."
        },
        {
            "sample_id": 5243,
            "vt": "SELECT COUNT(customers.customerid) FROM customers INNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN rootbeer AS T3 ON T2.RootBeerID = T3.RootBeerID WHERE customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]' AND transaction.transactiondate = '[placeholder-type:string]' AND rootbeer.containertype = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of transactions made by a specific customer on a specific date for a specific type of root beer container. It joins the 'customers' table with the 'transaction' table to link customer information with their transactions, and further joins the 'rootbeer' table to filter by the type of container used for the root beer purchased."
        },
        {
            "sample_id": 5281,
            "vt": "SELECT COUNT(rootbeer.brandid) FROM rootbeer INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID WHERE rootbeer.containertype = '[placeholder-type:string]' AND rootbeerbrand.brandname = '[placeholder-type:string]' AND rootbeer.purchasedate LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of root beer brands from the 'rootbeer' table that match specific criteria. It filters the results based on the type of container, the brand name, and the purchase date of the root beer. The placeholders represent the container type, brand name, and a date pattern for filtering the purchase date."
        },
        {
            "sample_id": 5321,
            "vt": "SELECT customers.first, customers.last FROM customers INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID WHERE rootbeerreview.starrating = [placeholder-type:numeric] AND rootbeerreview.review = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of customers who have provided a specific star rating and review for a root beer. The placeholders in the WHERE clause represent the star rating and the review content."
        },
        {
            "sample_id": 5278,
            "vt": "SELECT COUNT(customers.customerid) FROM customers INNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN rootbeer AS T3 ON T2.RootBeerID = T3.RootBeerID INNER JOIN rootbeerbrand AS T4 ON T3.BrandID = T4.BrandID WHERE customers.first = '[placeholder-type:string]' AND customers.last = '[placeholder-type:string]' AND rootbeerbrand.brandname LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of transactions made by a specific customer for a specific root beer brand. It joins the 'customers' table with the 'transaction' table to link customers to their purchases, then joins the 'rootbeer' table to identify the specific root beers purchased, and finally joins the 'rootbeerbrand' table to filter by the brand name. The placeholders represent the customer's first name, last name, and the brand name of the root beer."
        },
        {
            "sample_id": 5317,
            "vt": "SELECT AVG(rootbeerbrand.currentretailprice - rootbeerbrand.wholesalecost) FROM rootbeer INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID WHERE rootbeer.containertype = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average profit margin for root beer brands based on the difference between their current retail price and wholesale cost. It filters the results to include only those root beers that are sold in a specific type of container, represented by a placeholder for string values."
        },
        {
            "sample_id": 5275,
            "vt": "SELECT customers.first, customers.last FROM customers INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN rootbeerbrand AS T3 ON T2.BrandID = T3.BrandID WHERE rootbeerbrand.brandname = '[placeholder-type:string]' AND rootbeerreview.starrating = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of customers who have reviewed a specific root beer brand with a certain star rating. The placeholders in the WHERE clause represent the brand name and the star rating given by the customers."
        },
        {
            "sample_id": 5284,
            "vt": "SELECT rootbeerbrand.brandname, CAST(SUM(CASE WHEN rootbeer.purchasedate >= '[placeholder-type:string]' AND rootbeer.purchasedate <= '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / COUNT(rootbeer.brandid) FROM rootbeerbrand INNER JOIN rootbeer AS T2 ON T1.BrandID = T2.BrandID WHERE rootbeerbrand.breweryname = '[placeholder-type:string]' GROUP BY rootbeer.brandid",
            "ba": "The virtual table summarizes the average purchase price of root beers from a specific brewery over a defined date range. It calculates the total purchase price for root beers purchased within the specified dates and divides it by the count of root beers from that brand. The placeholders represent the date range and the brewery name."
        },
        {
            "sample_id": 5266,
            "vt": "SELECT COUNT(customers.customerid) FROM customers WHERE customers.gender = '[placeholder-type:string]' AND customers.subscribedtoemaillist = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table who meet specific criteria based on their gender and email subscription status. The placeholders in the WHERE clause represent the gender of the customers and whether they are subscribed to the email list."
        },
        {
            "sample_id": 5246,
            "vt": "SELECT COUNT(rootbeer.brandid) FROM rootbeer INNER JOIN \"transaction\" AS T2 ON T1.RootBeerID = T2.RootBeerID INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID WHERE transaction.transactiondate LIKE '[placeholder-type:string]' AND rootbeerbrand.twitter IS NULL",
            "ba": "The virtual table counts the number of root beer brands from the 'rootbeer' table that have been sold in transactions on a specific date, while also ensuring that the corresponding brand does not have a Twitter presence. The placeholders in the WHERE clause represent the transaction date and the absence of a Twitter account for the brand."
        },
        {
            "sample_id": 5348,
            "vt": "SELECT CAST((SUM(CASE WHEN rootbeerbrand.brandname = '[placeholder-type:string]' THEN transaction.purchaseprice ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN rootbeerbrand.brandname = '[placeholder-type:string]' THEN transaction.purchaseprice ELSE [placeholder-type:numeric] END)) AS FLOAT) * [placeholder-type:numeric] / SUM(CASE WHEN rootbeerbrand.brandname = '[placeholder-type:string]' THEN transaction.purchaseprice ELSE [placeholder-type:numeric] END) FROM rootbeer INNER JOIN \"transaction\" AS T2 ON T1.RootBeerID = T2.RootBeerID INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID",
            "ba": "The virtual table calculates the profit margin for a specific root beer brand by comparing the total purchase price of transactions involving that brand to a specified value. It uses placeholders for the brand name and numeric values to allow users to input their desired parameters."
        },
        {
            "sample_id": 5349,
            "vt": "SELECT DISTINCT customers.city FROM customers WHERE customers.state = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct cities of customers from the 'customers' table who reside in a specific state. The placeholder in the WHERE clause represents the state code."
        }
    ],
    "address": [
        {
            "sample_id": 5156,
            "vt": "SELECT area_code.area_code, country.county FROM area_code INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code INNER JOIN zip_data AS T3 ON T1.zip_code = T3.zip_code WHERE zip_data.city = '[placeholder-type:string]'",
            "ba": "The virtual table provides the area code and county information for a specific city based on its zip code. It combines data from the 'area_code', 'country', and 'zip_data' tables, filtering results to match the specified city name."
        },
        {
            "sample_id": 5211,
            "vt": "SELECT alias.alias FROM alias INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.population_2020 = (SELECT MAX(zip_data.population_2020) FROM zip_data)",
            "ba": "The virtual table retrieves the aliases of cities from the 'alias' table that correspond to the zip codes with the highest population recorded in 2020 from the 'zip_data' table. The query uses an inner join to connect the 'alias' and 'zip_data' tables based on the zip code, ensuring that only the aliases for the most populated areas are selected."
        },
        {
            "sample_id": 5227,
            "vt": "SELECT zip_congress.district FROM zip_data INNER JOIN zip_congress AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the district information associated with a specific city from the 'zip_data' table by joining it with the 'zip_congress' table. The placeholder in the WHERE clause represents the name of the city for which the district is being queried."
        },
        {
            "sample_id": 5091,
            "vt": "SELECT COUNT(zip_data.zip_code) FROM zip_data INNER JOIN avoid AS T2 ON T1.zip_code = T2.zip_code WHERE avoid.bad_alias = '[placeholder-type:string]' AND zip_data.time_zone = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of zip codes from the 'zip_data' table that are associated with bad aliases from the 'avoid' table. It filters the results based on a specific bad alias and a specified time zone."
        },
        {
            "sample_id": 5152,
            "vt": "SELECT alias.alias, zip_data.elevation FROM alias INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE alias.zip_code = [placeholder-type:numeric]",
            "ba": "The virtual table describes the aliases of cities along with their elevation from the 'zip_data' table. The query joins the 'alias' table with the 'zip_data' table based on the zip code, filtering for a specific zip code using a placeholder for numeric values."
        },
        {
            "sample_id": 5128,
            "vt": "SELECT cbsa.cbsa_name, cbsa.cbsa_type FROM cbsa INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE zip_data.city = '[placeholder-type:string]' AND zip_data.state = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and types of cbsa officers from the 'cbsa' table who are associated with a specific city and state. The placeholders in the WHERE clause represent the city and state names."
        },
        {
            "sample_id": 5200,
            "vt": "SELECT DISTINCT country.county FROM country INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.population_2010 > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a distinct list of counties from the 'country' table that are associated with zip codes in the 'zip_data' table, specifically filtering for those zip codes where the population in 2010 exceeds a specified numeric value. The placeholder in the WHERE clause represents the population threshold."
        },
        {
            "sample_id": 5119,
            "vt": "SELECT cbsa.cbsa_name, zip_data.latitude, zip_data.longitude FROM cbsa INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE zip_data.zip_code = [placeholder-type:numeric] GROUP BY cbsa.cbsa_name, zip_data.latitude, zip_data.longitude",
            "ba": "The virtual table provides the names of cbsa officers along with the latitude and longitude of postal points associated with them. It retrieves data from the 'cbsa' table and joins it with the 'zip_data' table based on the cbsa code. The results are filtered by a specific zip code, and the output is grouped by the officer's name and the geographical coordinates."
        },
        {
            "sample_id": 5194,
            "vt": "SELECT avoid.bad_alias FROM avoid INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the bad aliases associated with a specific city from the 'avoid' table by joining it with the 'zip_data' table based on the zip code. The placeholder in the WHERE clause represents the name of the city for which we want to find bad aliases."
        },
        {
            "sample_id": 5141,
            "vt": "SELECT zip_data.latitude, zip_data.longitude FROM zip_data INNER JOIN zip_congress AS T2 ON T1.zip_code = T2.zip_code INNER JOIN congress AS T3 ON T2.district = T3.cognress_rep_id WHERE congress.first_name = '[placeholder-type:string]' AND congress.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the latitude and longitude of postal points from the 'zip_data' table, specifically for those associated with a particular congressional representative. It joins the 'zip_data' table with the 'zip_congress' table to link zip codes to congressional districts, and then further joins with the 'congress' table to filter results based on the first and last names of the congressional representatives."
        },
        {
            "sample_id": 5147,
            "vt": "SELECT country.zip_code FROM country INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE country.county = '[placeholder-type:string]' ORDER BY zip_data.land_area LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves zip codes from the 'country' table by joining it with the 'zip_data' table. It filters the results based on a specific county name and orders the results by the land area of the corresponding zip codes. The query limits the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 5129,
            "vt": "SELECT zip_data.city, zip_data.zip_code, area_code.area_code FROM area_code INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.median_age >= [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of cities and their corresponding zip codes along with the area codes from the 'area_code' table. It filters the results to include only those entries from the 'zip_data' table where the median age is above a specified threshold, using placeholders for numeric values. The results are limited to a specified number of entries."
        },
        {
            "sample_id": 5190,
            "vt": "SELECT CAST(SUM(CASE WHEN country.county = '[placeholder-type:string]' THEN zip_data.households ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(zip_data.households) FROM country INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code",
            "ba": "The virtual table calculates the weighted average of households in a specific county based on the total number of households in the corresponding zip codes. It uses a conditional sum to include only those households from the specified county, while also considering the total households across all zip codes for normalization. The result is scaled by a numeric placeholder to adjust the final output as needed."
        },
        {
            "sample_id": 5196,
            "vt": "SELECT zip_data.state FROM avoid INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code GROUP BY zip_data.state ORDER BY COUNT(avoid.bad_alias) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the states from the 'zip_data' table that are associated with bad aliases found in the 'avoid' table. It performs an inner join between the 'avoid' and 'zip_data' tables based on the zip code, groups the results by state, and orders them by the count of bad aliases in descending order. The result is limited to a specified number of states."
        },
        {
            "sample_id": 5088,
            "vt": "SELECT DISTINCT country.county FROM zip_data INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.daylight_savings = '[placeholder-type:string]'",
            "ba": "The virtual table lists the unique counties from the 'country' table that are associated with zip codes in the 'zip_data' table where the location observes daylight savings time. The placeholder in the WHERE clause represents whether daylight savings is implemented or not."
        },
        {
            "sample_id": 5144,
            "vt": "SELECT area_code.zip_code FROM area_code INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.state = '[placeholder-type:string]' GROUP BY area_code.zip_code HAVING COUNT(area_code.area_code) > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the zip codes associated with area codes from the 'area_code' table, filtered by a specific state. It groups the results by zip code and only includes those with more than a specified number of area codes."
        },
        {
            "sample_id": 5107,
            "vt": "SELECT COUNT(zip_data.city) FROM congress INNER JOIN state AS T2 ON T1.abbreviation = T2.abbreviation INNER JOIN zip_data AS T3 ON T2.abbreviation = T3.state WHERE congress.first_name = '[placeholder-type:string]' AND congress.last_name = '[placeholder-type:string]' AND zip_data.employees = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of cities associated with a specific congress representative based on their first and last names, while also filtering for cities that have a certain number of employees. It joins the 'congress' table with the 'state' table to match the state abbreviation and then joins with the 'zip_data' table to access city information."
        },
        {
            "sample_id": 5167,
            "vt": "SELECT avoid.bad_alias FROM avoid INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the bad aliases associated with a specific city from the 'avoid' table. It joins the 'avoid' table with the 'zip_data' table to filter results based on the city name provided in the placeholder."
        },
        {
            "sample_id": 5131,
            "vt": "SELECT DISTINCT area_code.area_code FROM area_code INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code INNER JOIN state AS T3 ON T2.state = T3.abbreviation WHERE country.county = '[placeholder-type:string]' AND state.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct area codes from the 'area_code' table based on a specific county and state name. It joins the 'area_code' table with the 'country' table to filter by county and then joins with the 'state' table to filter by state name. The placeholders represent the county and state name that the user can specify."
        },
        {
            "sample_id": 5202,
            "vt": "SELECT CAST(COUNT(CASE WHEN zip_data.households > [placeholder-type:numeric] THEN country.zip_code ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(country.zip_code) FROM country INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code",
            "ba": "The virtual table calculates the proportion of zip codes in the 'country' table that have a number of households exceeding a specified threshold. It counts the number of such zip codes and multiplies this count by a specified numeric value, then divides by the total count of zip codes in the 'country' table. This provides a weighted average based on the number of households."
        },
        {
            "sample_id": 5145,
            "vt": "SELECT DISTINCT country.county FROM country INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves a distinct list of counties from the 'country' table based on the zip code associated with a specific city. The query joins the 'country' table with the 'zip_data' table to filter results by the city name provided as a placeholder."
        },
        {
            "sample_id": 5175,
            "vt": "SELECT zip_data.zip_code, congress.first_name, congress.last_name FROM zip_data INNER JOIN zip_congress AS T2 ON T1.zip_code = T2.zip_code INNER JOIN congress AS T3 ON T2.district = T3.cognress_rep_id WHERE zip_data.organization = '[placeholder-type:string]'",
            "ba": "The virtual table describes the zip codes along with the first and last names of congress representatives associated with those zip codes from the 'zip_data' and 'congress' tables. The query filters the results based on a specific organization using a placeholder for string values."
        },
        {
            "sample_id": 5084,
            "vt": "SELECT SUM(zip_data.male_population) FROM zip_data INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE country.county = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total male population from the 'zip_data' table for a specific county. It joins the 'zip_data' table with the 'country' table based on the zip code, allowing for filtering by county name."
        },
        {
            "sample_id": 5207,
            "vt": "SELECT country.county, area_code.area_code FROM area_code INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE area_code.zip_code = [placeholder-type:numeric]",
            "ba": "The virtual table provides a view of the county and area code associated with a specific zip code. It combines data from the 'area_code' and 'country' tables, linking them through the zip code. The placeholder in the WHERE clause allows users to specify the zip code they are interested in."
        },
        {
            "sample_id": 5216,
            "vt": "SELECT CAST(COUNT(CASE WHEN zip_data.county_fips < [placeholder-type:numeric] THEN zip_data.zip_code ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(zip_data.zip_code) FROM alias INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE alias.alias = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted count of zip codes from the 'zip_data' table based on a condition related to the county FIPS code. It joins the 'alias' table to filter zip codes that match a specific alias. The result is a ratio of the count of zip codes with a county FIPS code less than a specified value, multiplied by a placeholder numeric value, to the total count of zip codes."
        },
        {
            "sample_id": 5132,
            "vt": "SELECT zip_congress.zip_code, congress.first_name, congress.last_name FROM congress INNER JOIN zip_congress AS T2 ON T1.cognress_rep_id = T2.district WHERE congress.state = '[placeholder-type:string]' ORDER BY congress.land_area LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the zip codes along with the first and last names of congress representatives from the 'congress' table, filtered by a specific state. It joins the 'congress' table with the 'zip_congress' table to match representatives with their respective districts. The results are ordered by the land area of the districts and limited to a specified number of entries."
        },
        {
            "sample_id": 5179,
            "vt": "SELECT country.county FROM state INNER JOIN country AS T2 ON T1.abbreviation = T2.state WHERE state.name = '[placeholder-type:string]' GROUP BY country.county",
            "ba": "The virtual table lists the counties from the 'country' table that are associated with a specific state. It joins the 'state' table to filter the results based on the state's name, using a placeholder for the state name in the WHERE clause. The results are grouped by county to ensure unique entries."
        },
        {
            "sample_id": 5100,
            "vt": "SELECT zip_data.latitude, zip_data.longitude FROM area_code INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE area_code.area_code = '[placeholder-type:string]' GROUP BY zip_data.latitude, zip_data.longitude",
            "ba": "The virtual table provides the latitude and longitude of postal points from the 'zip_data' table, filtered by a specific area code. The query joins the 'area_code' table with the 'zip_data' table based on matching zip codes, allowing users to retrieve geographic coordinates associated with a given area code."
        },
        {
            "sample_id": 5192,
            "vt": "SELECT country.county FROM country INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the county information from the 'country' table based on the zip code associated with a specific city. The query uses an inner join to connect the 'country' table with the 'zip_data' table, ensuring that only records matching the specified city are included in the results."
        },
        {
            "sample_id": 5086,
            "vt": "SELECT zip_data.zip_code FROM zip_data INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE country.county = '[placeholder-type:string]' ORDER BY zip_data.white_population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves zip codes from the 'zip_data' table that are associated with a specific county in the 'country' table. The results are ordered by the white population in the corresponding zip code area, and the number of results returned is limited to a specified numeric value."
        },
        {
            "sample_id": 5169,
            "vt": "SELECT COUNT(zip_data.zip_code) FROM state INNER JOIN zip_data AS T2 ON T1.abbreviation = T2.state WHERE state.name = '[placeholder-type:string]' AND zip_data.daylight_savings = '[placeholder-type:string]' AND zip_data.region = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of zip codes from the 'zip_data' table that are associated with a specific state, while also filtering for those that observe daylight savings and belong to a particular region. The placeholders represent the state name, daylight savings status, and region respectively."
        },
        {
            "sample_id": 5099,
            "vt": "SELECT COUNT(DISTINCT T2.zip_code) FROM state INNER JOIN zip_data AS T2 ON T1.abbreviation = T2.state WHERE state.abbreviation = '[placeholder-type:string]' AND zip_data.type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct zip codes from the 'zip_data' table that are associated with a specific state and type of postal point. It joins the 'state' table to filter the results based on the state's abbreviation and the type of postal point specified."
        },
        {
            "sample_id": 5225,
            "vt": "SELECT area_code.zip_code, area_code.area_code FROM area_code INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.type = '[placeholder-type:string]' AND zip_data.elevation > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the zip codes and their corresponding area codes from the 'area_code' table, filtering based on the type of postal point and elevation criteria from the 'zip_data' table."
        },
        {
            "sample_id": 5219,
            "vt": "SELECT zip_data.zip_code, zip_data.latitude, zip_data.longitude FROM cbsa INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE cbsa.cbsa_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the zip code, latitude, and longitude of postal points associated with a specific cbsa officer's name from the 'cbsa' and 'zip_data' tables. The placeholder in the WHERE clause represents the name of the cbsa officer."
        },
        {
            "sample_id": 5217,
            "vt": "SELECT country.county FROM country INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.population_2020 > [placeholder-type:numeric] * (SELECT AVG(zip_data.population_2020) FROM zip_data)",
            "ba": "The virtual table retrieves the county names from the 'country' table for zip codes that are associated with a population greater than the average population of all zip codes in the 'zip_data' table, using a join to connect the two tables based on the zip code."
        },
        {
            "sample_id": 5118,
            "vt": "SELECT COUNT(country.county) FROM state INNER JOIN country AS T2 ON T1.abbreviation = T2.state WHERE state.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of counties in a specific state by joining the 'state' and 'country' tables. The placeholder in the WHERE clause represents the name of the state for which the county count is being requested."
        },
        {
            "sample_id": 5160,
            "vt": "SELECT country.county FROM state INNER JOIN country AS T2 ON T1.abbreviation = T2.state INNER JOIN zip_data AS T3 ON T2.zip_code = T3.zip_code WHERE zip_data.city = '[placeholder-type:string]' GROUP BY country.county",
            "ba": "The virtual table retrieves the counties associated with a specific city by joining the 'state', 'country', and 'zip_data' tables. It filters the results based on the city name provided as a placeholder and groups the results by county to ensure unique entries."
        },
        {
            "sample_id": 5110,
            "vt": "SELECT congress.party FROM congress INNER JOIN state AS T2 ON T1.abbreviation = T2.abbreviation INNER JOIN zip_data AS T3 ON T2.abbreviation = T3.state WHERE zip_data.zip_code = [placeholder-type:numeric] GROUP BY congress.party",
            "ba": "The virtual table retrieves the political party affiliations of congress representatives based on a specific zip code. It joins the 'congress' table with the 'state' table to match state abbreviations and further joins with the 'zip_data' table to filter results by the provided zip code. The results are grouped by party to show distinct party affiliations."
        },
        {
            "sample_id": 5183,
            "vt": "SELECT SUM(zip_data.population_2010) FROM country INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE country.county = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total population from the year 2010 for a specific county by joining the 'country' and 'zip_data' tables. The placeholder in the WHERE clause represents the name of the county being queried."
        },
        {
            "sample_id": 5159,
            "vt": "SELECT AVG(zip_data.elevation) FROM alias INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE alias.alias = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average elevation of postal points associated with a specific alias from the 'alias' table. It joins the 'alias' table with the 'zip_data' table on the zip code to filter the relevant postal points based on the provided alias."
        },
        {
            "sample_id": 5204,
            "vt": "SELECT DISTINCT country.county FROM area_code INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code INNER JOIN zip_data AS T3 ON T1.zip_code = T3.zip_code WHERE area_code.area_code = '[placeholder-type:string]' AND zip_data.type = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct county names from the 'country' table based on specific area codes and postal point types. It joins the 'area_code' table with the 'country' table and the 'zip_data' table to filter results according to the provided area code and postal point type."
        },
        {
            "sample_id": 5206,
            "vt": "SELECT COUNT(area_code.area_code) FROM area_code INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.daylight_savings = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of area codes associated with zip codes that have a specific daylight savings status. It joins the 'area_code' table with the 'zip_data' table based on the zip code, filtering the results based on whether daylight savings is implemented or not."
        },
        {
            "sample_id": 5181,
            "vt": "SELECT DISTINCT cbsa.cbsa_name FROM cbsa INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE zip_data.avg_house_value = (SELECT MAX(zip_data.avg_house_value) FROM zip_data) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct names of cbsa officers from the 'cbsa' table, joining it with the 'zip_data' table to filter based on the average house value. It specifically looks for the maximum average house value across all postal points and limits the results to a specified number."
        },
        {
            "sample_id": 5220,
            "vt": "SELECT avoid.zip_code, zip_data.city, zip_data.latitude, zip_data.longitude FROM avoid INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE avoid.bad_alias = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about zip codes that have been flagged with a bad alias. It includes the zip code, the corresponding city, and the geographical coordinates (latitude and longitude) of the postal point. The data is retrieved by joining the 'avoid' table, which contains bad aliases, with the 'zip_data' table, which holds detailed information about each zip code. The query filters results based on a specific bad alias provided by the user."
        },
        {
            "sample_id": 5197,
            "vt": "SELECT COUNT(CASE WHEN zip_data.city = '[placeholder-type:string]' THEN avoid.bad_alias ELSE NULL END) - COUNT(CASE WHEN zip_data.city = '[placeholder-type:string]' THEN avoid.bad_alias ELSE NULL END) FROM avoid INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code",
            "ba": "The virtual table calculates the difference between two counts of bad aliases associated with a specific city from the 'zip_data' table. It uses a conditional count to determine how many bad aliases exist for the specified city, and then subtracts this count from itself, which will always result in zero. This query structure seems to be incorrect as it does not provide meaningful information."
        },
        {
            "sample_id": 5186,
            "vt": "SELECT state.name FROM state INNER JOIN country AS T2 ON T1.abbreviation = T2.state GROUP BY country.state ORDER BY COUNT(country.county) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of states from the 'state' table that are associated with countries in the 'country' table. It groups the results by the state and orders them based on the count of counties associated with each state, limiting the results to a specified number."
        },
        {
            "sample_id": 5161,
            "vt": "SELECT alias.alias FROM alias INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.type = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves aliases of cities from the 'alias' table that correspond to specific zip codes in the 'zip_data' table. The query filters the results based on the type of postal point, which is specified by a placeholder for string values, and limits the number of results returned using a placeholder for numeric values."
        },
        {
            "sample_id": 5146,
            "vt": "SELECT COUNT(zip_data.zip_code) FROM cbsa INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE cbsa.cbsa_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of zip codes associated with a specific cbsa officer's name from the 'cbsa' and 'zip_data' tables. The placeholder in the WHERE clause represents the name of the cbsa officer."
        },
        {
            "sample_id": 5137,
            "vt": "SELECT CAST(SUM(zip_data.population_2020) AS FLOAT) / COUNT(zip_data.zip_code) FROM zip_data",
            "ba": "The virtual table calculates the average population of postal points from the 'zip_data' table based on the population data from the year 2020. It sums up the total population across all postal points and divides it by the count of unique zip codes to derive the average."
        },
        {
            "sample_id": 5108,
            "vt": "SELECT t.state, congress.first_name, congress.last_name FROM zip_data INNER JOIN congress AS T1 ON t.state = T1.abbreviation GROUP BY t.state ORDER BY SUM(t.asian_population) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of congress representatives' first and last names grouped by state, along with the state information. It retrieves data from the 'zip_data' table and joins it with the 'congress' table based on the state abbreviation. The results are ordered by the total Asian population in each state, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 5149,
            "vt": "SELECT CAST(zip_data.asian_population AS FLOAT) * [placeholder-type:numeric] / zip_data.population_2010 FROM cbsa INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE cbsa.cbsa_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of the Asian population in a specific CBSA area relative to the total population in 2010. It retrieves data from the 'cbsa' table and joins it with the 'zip_data' table based on the CBSA code. The result is a floating-point value representing the percentage of the Asian population, scaled by a numeric placeholder."
        },
        {
            "sample_id": 5222,
            "vt": "SELECT COUNT(zip_data.zip_code) FROM cbsa INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE cbsa.cbsa_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of zip codes associated with a specific cbsa officer's name from the 'cbsa' and 'zip_data' tables. The placeholder in the WHERE clause represents the name of the cbsa officer."
        },
        {
            "sample_id": 5095,
            "vt": "SELECT SUM(zip_data.female_median_age) / COUNT(zip_data.zip_code) FROM zip_data INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE country.county = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average female median age from the 'zip_data' table for a specific county. It does this by summing the 'female_median_age' values and dividing by the count of zip codes associated with that county. The query joins the 'zip_data' table with the 'country' table to filter results based on the specified county."
        },
        {
            "sample_id": 5198,
            "vt": "SELECT zip_data.state FROM cbsa INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE cbsa.cbsa_type = '[placeholder-type:string]' GROUP BY zip_data.state HAVING COUNT(cbsa.cbsa_type) > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the states from the 'zip_data' table that are associated with a specific type of cbsa officer from the 'cbsa' table. It uses an inner join to connect the two tables based on the cbsa code, filtering the results by the cbsa type and grouping them by state. The query also ensures that only states with a count of cbsa officers greater than a specified number are included in the results."
        },
        {
            "sample_id": 5151,
            "vt": "SELECT DISTINCT state.name, country.state FROM state INNER JOIN country AS T2 ON T1.abbreviation = T2.state INNER JOIN zip_data AS T3 ON T2.zip_code = T3.zip_code WHERE zip_data.elevation = [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of state names and their corresponding country states by joining the 'state' and 'country' tables based on the state abbreviation. It further joins the 'zip_data' table to filter results based on the elevation of the postal points, represented by a numeric placeholder."
        },
        {
            "sample_id": 5093,
            "vt": "SELECT DISTINCT avoid.bad_alias FROM zip_data INNER JOIN avoid AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.female_median_age > [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct bad aliases associated with zip codes from the 'zip_data' table, filtered by female median age being greater than a specified numeric value. The join operation connects the 'zip_data' and 'avoid' tables based on matching zip codes, allowing for the retrieval of bad aliases that meet the age condition."
        },
        {
            "sample_id": 5215,
            "vt": "SELECT AVG(zip_data.white_population) FROM area_code INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE area_code.area_code = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average white population from the 'zip_data' table, which contains demographic information about various postal points. It joins with the 'area_code' table to filter the results based on a specific area code. The placeholder in the WHERE clause represents the area code for which the average white population is being calculated."
        },
        {
            "sample_id": 5218,
            "vt": "SELECT COUNT(zip_congress.zip_code) FROM congress INNER JOIN zip_congress AS T2 ON T1.cognress_rep_id = T2.district WHERE congress.first_name = '[placeholder-type:string]' AND congress.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of zip codes associated with a specific congress representative identified by their first and last name. It joins the 'congress' table with the 'zip_congress' table to link representatives to their respective districts and zip codes."
        },
        {
            "sample_id": 5148,
            "vt": "SELECT zip_data.population_2020 - zip_data.population_2010 FROM zip_data INNER JOIN zip_congress AS T2 ON T1.zip_code = T2.zip_code INNER JOIN congress AS T3 ON T2.district = T3.cognress_rep_id WHERE congress.first_name = '[placeholder-type:string]' AND congress.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the population change between 2020 and 2010 for specific zip codes associated with congressional districts. It retrieves the difference in population by joining the 'zip_data' table with the 'zip_congress' table to link zip codes to their respective congressional districts, and then further joins with the 'congress' table to filter results based on the first and last names of congress representatives."
        },
        {
            "sample_id": 5168,
            "vt": "SELECT zip_data.zip_code, zip_data.city, congress.first_name, congress.last_name FROM zip_data INNER JOIN zip_congress AS T2 ON T1.zip_code = T2.zip_code INNER JOIN congress AS T3 ON T2.district = T3.cognress_rep_id GROUP BY zip_congress.district ORDER BY zip_data.population_2020 LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of zip codes and corresponding cities along with the first and last names of congress representatives associated with those zip codes. It combines data from the 'zip_data', 'zip_congress', and 'congress' tables, grouping the results by district and ordering them by the population in 2020. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 5115,
            "vt": "SELECT zip_data.latitude, zip_data.longitude FROM area_code INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE area_code.area_code = [placeholder-type:numeric]",
            "ba": "The virtual table provides the latitude and longitude of postal points from the 'zip_data' table, which are linked to specific area codes from the 'area_code' table. The placeholder in the WHERE clause represents the area code being queried."
        },
        {
            "sample_id": 5092,
            "vt": "SELECT avoid.bad_alias FROM zip_data INNER JOIN avoid AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.avg_house_value = (SELECT MAX(zip_data.avg_house_value) FROM zip_data) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the bad aliases associated with zip codes from the 'zip_data' table, specifically focusing on the zip code that has the highest average house value. The query uses an inner join to connect the 'zip_data' and 'avoid' tables based on the zip code, ensuring that only relevant bad aliases are selected. The result is limited to a specified number of entries."
        },
        {
            "sample_id": 5116,
            "vt": "SELECT zip_congress.zip_code FROM congress INNER JOIN zip_congress AS T2 ON T1.cognress_rep_id = T2.district WHERE congress.first_name = '[placeholder-type:string]' AND congress.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the zip codes associated with congressional representatives based on their first and last names. It joins the 'congress' table with the 'zip_congress' table to find the relevant zip codes for the specified representatives."
        },
        {
            "sample_id": 5125,
            "vt": "SELECT zip_data.city, zip_data.state FROM avoid INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE avoid.bad_alias = '[placeholder-type:string]' GROUP BY zip_data.city, zip_data.state",
            "ba": "The virtual table describes the cities and states from the 'zip_data' table that are associated with bad aliases listed in the 'avoid' table. The placeholder in the WHERE clause represents the specific bad alias being queried."
        },
        {
            "sample_id": 5188,
            "vt": "SELECT zip_data.avg_income_per_household FROM avoid INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE avoid.bad_alias = '[placeholder-type:string]'",
            "ba": "The virtual table provides the average income per household from the 'zip_data' table for zip codes that are associated with bad aliases in the 'avoid' table. The placeholder in the WHERE clause represents the specific bad alias being queried."
        },
        {
            "sample_id": 5191,
            "vt": "SELECT cbsa.cbsa_name, cbsa.cbsa_type FROM cbsa INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE zip_data.city = '[placeholder-type:string]' GROUP BY cbsa.cbsa_name, cbsa.cbsa_type",
            "ba": "The virtual table describes the names and types of cbsa officers associated with a specific city from the 'zip_data' table. The query joins the 'cbsa' table with the 'zip_data' table based on the cbsa code, filtering results to only include those from the specified city."
        },
        {
            "sample_id": 5090,
            "vt": "SELECT SUM(zip_data.asian_population) FROM zip_data INNER JOIN avoid AS T2 ON T1.zip_code = T2.zip_code WHERE avoid.bad_alias = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total Asian population from the 'zip_data' table, filtering out entries that have a bad alias from the 'avoid' table. The placeholder in the WHERE clause represents the specific bad alias to be excluded from the results."
        },
        {
            "sample_id": 5189,
            "vt": "SELECT DISTINCT zip_data.state FROM state INNER JOIN zip_data AS T2 ON T1.abbreviation = T2.state WHERE zip_data.female_population > (SELECT AVG(zip_data.female_population) FROM zip_data)",
            "ba": "The virtual table lists distinct states from the 'state' table that have a corresponding entry in the 'zip_data' table, where the female population in those zip codes exceeds the average female population across all zip codes."
        },
        {
            "sample_id": 5138,
            "vt": "SELECT zip_data.male_population FROM cbsa INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE cbsa.cbsa_name = '[placeholder-type:string]' GROUP BY zip_data.male_population",
            "ba": "The virtual table provides the male population data from the 'zip_data' table, filtered by the name of the cbsa officer from the 'cbsa' table. It uses an inner join to connect the two tables based on the cbsa code, allowing for aggregation of male population figures grouped by their respective values."
        },
        {
            "sample_id": 5114,
            "vt": "SELECT COUNT(DISTINCT T2.bad_alias) FROM zip_congress INNER JOIN avoid AS T2 ON T1.zip_code = T2.zip_code INNER JOIN congress AS T3 ON T1.district = T3.cognress_rep_id WHERE congress.first_name = '[placeholder-type:string]' AND congress.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct bad aliases associated with zip codes for a specific congress representative identified by their first and last name. It joins the 'zip_congress' table with the 'avoid' table to find bad aliases and the 'congress' table to filter by the representative's name."
        },
        {
            "sample_id": 5164,
            "vt": "SELECT zip_data.zip_code, zip_data.city FROM state INNER JOIN zip_data AS T2 ON T1.abbreviation = T2.state WHERE state.name = '[placeholder-type:string]' AND zip_data.total_beneficiaries > [placeholder-type:numeric]",
            "ba": "The virtual table describes the zip codes and cities from the 'zip_data' table that are associated with a specific state. It filters the results based on the state name and ensures that only those zip codes with a total number of beneficiaries exceeding a specified numeric value are included."
        },
        {
            "sample_id": 5155,
            "vt": "SELECT SUM(zip_data.asian_population) FROM alias INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE alias.alias = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total Asian population from the 'zip_data' table for a specific city alias. It joins the 'alias' table with the 'zip_data' table based on the zip code, filtering the results to include only those records that match the specified city alias."
        },
        {
            "sample_id": 5224,
            "vt": "SELECT COUNT(DISTINCT T2.zip_code), COUNT(DISTINCT T2.county) FROM state INNER JOIN country AS T2 ON T1.abbreviation = T2.state WHERE state.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of distinct zip codes and counties associated with a specific state. It joins the 'state' table with the 'country' table based on the state abbreviation, filtering results to include only those from the specified state name."
        },
        {
            "sample_id": 5210,
            "vt": "SELECT area_code.area_code FROM area_code INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.water_area = (SELECT MAX(zip_data.water_area) FROM zip_data)",
            "ba": "The virtual table retrieves the area code associated with the zip code that has the maximum water area from the 'zip_data' table. It uses an inner join to connect the 'area_code' table with the 'zip_data' table based on the zip code, ensuring that only the relevant area code for the zip code with the largest water area is selected."
        },
        {
            "sample_id": 5154,
            "vt": "SELECT area_code.area_code FROM area_code INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.white_population BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table retrieves area codes from the 'area_code' table based on a condition that filters the 'zip_data' table for white population counts within a specified range. The query uses an inner join to connect the two tables through the zip code, ensuring that only relevant area codes associated with the specified white population criteria are selected."
        },
        {
            "sample_id": 5187,
            "vt": "SELECT SUM(CASE WHEN zip_congress.district = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM zip_data INNER JOIN zip_congress AS T2 ON T1.zip_code = T2.zip_code",
            "ba": "The virtual table calculates the total sum of a specific numeric value based on a condition related to congressional districts from the 'zip_congress' table. It joins the 'zip_data' table with the 'zip_congress' table using the zip code as the key, allowing for aggregation of data that meets the specified district criteria."
        },
        {
            "sample_id": 5121,
            "vt": "SELECT SUM(zip_data.male_median_age) / COUNT(zip_data.median_age) FROM country INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE country.county = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average male median age from the 'zip_data' table for a specific county. It does this by summing the male median ages and dividing by the count of median ages, while joining with the 'country' table to filter results based on the specified county."
        },
        {
            "sample_id": 5136,
            "vt": "SELECT CAST(COUNT(CASE WHEN congress.state = '[placeholder-type:string]' THEN congress.cognress_rep_id ELSE NULL END) AS FLOAT) / COUNT(CASE WHEN congress.state = '[placeholder-type:string]' THEN congress.cognress_rep_id ELSE NULL END) FROM congress",
            "ba": "The virtual table calculates the ratio of congress representatives from a specific state to the total number of congress representatives from that state. It uses placeholders for the state name to allow users to specify which state's representatives they are interested in."
        },
        {
            "sample_id": 5102,
            "vt": "SELECT country.county FROM zip_data INNER JOIN country AS T4 ON T3.zip_code = T4.zip_code GROUP BY country.county ORDER BY zip_data.female_population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a list of counties from the 'country' table that are associated with zip codes in the 'zip_data' table. The results are grouped by county and ordered by the female population in the corresponding zip codes, with a limit on the number of results returned."
        },
        {
            "sample_id": 5124,
            "vt": "SELECT avoid.bad_alias FROM avoid INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.city = '[placeholder-type:string]' AND zip_data.state = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the bad aliases associated with a specific city and state from the 'avoid' table. It joins the 'avoid' table with the 'zip_data' table to filter results based on the city and state provided by the user."
        },
        {
            "sample_id": 5205,
            "vt": "SELECT zip_data.elevation FROM alias INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE alias.alias = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the elevation data from the 'zip_data' table based on the alias of a city. It joins the 'alias' table with the 'zip_data' table using the zip code to filter the results for a specific city alias."
        },
        {
            "sample_id": 5173,
            "vt": "SELECT zip_data.zip_code, cbsa.cbsa_name FROM cbsa INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE zip_data.city = '[placeholder-type:string]'",
            "ba": "The virtual table describes the zip codes and the names of cbsa officers associated with a specific city. The query retrieves this information by joining the 'cbsa' table with the 'zip_data' table based on the cbsa code, filtering results to only include those that match the specified city name."
        },
        {
            "sample_id": 5111,
            "vt": "SELECT SUM(zip_data.male_population) FROM zip_data INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE country.county = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total male population from the 'zip_data' table for a specific county. It joins the 'zip_data' table with the 'country' table based on the zip code, allowing for filtering by county name."
        },
        {
            "sample_id": 5185,
            "vt": "SELECT zip_data.city FROM cbsa INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE cbsa.cbsa_type = '[placeholder-type:string]'",
            "ba": "The virtual table describes the cities associated with specific CBSA officers from the 'cbsa' and 'zip_data' tables. It retrieves the city names from the 'zip_data' table where the corresponding CBSA officer's type matches a specified type. The placeholder in the WHERE clause represents the type of the CBSA officer."
        },
        {
            "sample_id": 5163,
            "vt": "SELECT CAST((SUM(zip_data.population_2020) - SUM(zip_data.population_2010)) AS FLOAT) * [placeholder-type:numeric] / SUM(zip_data.population_2010) FROM country INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.city = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage change in population from 2010 to 2020 for a specific city, based on data from the 'zip_data' and 'country' tables. It sums the populations for both years, computes the difference, and then divides by the population of 2010 to find the growth rate. The result is scaled by a numeric placeholder, allowing for adjustments in the calculation."
        },
        {
            "sample_id": 5083,
            "vt": "SELECT zip_data.zip_code FROM zip_data INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE country.county = '[placeholder-type:string]' ORDER BY zip_data.avg_house_value LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves zip codes from the 'zip_data' table that are associated with a specific county in the 'country' table. The results are ordered by the average house value in ascending order, and the number of results returned is limited to a specified numeric value."
        },
        {
            "sample_id": 5097,
            "vt": "SELECT DISTINCT alias.alias FROM zip_data INNER JOIN alias AS T2 ON T1.zip_code = T2.zip_code WHERE zip_data.city = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of unique aliases for cities based on their zip codes. It retrieves this information by joining the 'zip_data' table, which contains details about postal points, with the 'alias' table that holds the aliases for those zip codes. The query filters the results to only include aliases for a specific city, indicated by a placeholder for the city name."
        },
        {
            "sample_id": 5142,
            "vt": "SELECT DISTINCT zip_data.state FROM area_code INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE area_code.area_code = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct states from the 'zip_data' table based on the area code provided. It joins the 'area_code' table with the 'zip_data' table using the zip code to filter the results according to the specified area code."
        },
        {
            "sample_id": 5209,
            "vt": "SELECT zip_data.city FROM state INNER JOIN country AS T2 ON T1.abbreviation = T2.state INNER JOIN zip_data AS T3 ON T2.zip_code = T3.zip_code WHERE state.name = '[placeholder-type:string]' AND country.county = '[placeholder-type:string]'",
            "ba": "The virtual table describes the cities from the 'zip_data' table that are located in a specific state and belong to a specific county. The query uses inner joins to connect the 'state' and 'country' tables based on the state abbreviation, and then links to the 'zip_data' table using the zip code. The placeholders in the WHERE clause represent the state name and county name."
        },
        {
            "sample_id": 5109,
            "vt": "SELECT DISTINCT state.name FROM country INNER JOIN state AS T2 ON T1.state = T2.abbreviation WHERE country.county = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct names of states from the 'country' table, filtered by a specific county. It uses an inner join with the 'state' table to match the state abbreviation with the corresponding state name."
        }
    ],
    "soccer_2016": [
        {
            "sample_id": 1943,
            "vt": "SELECT player.player_name FROM player INNER JOIN Season AS T2 ON T1.Player_Id = T2.Man_of_the_Series = T2.Orange_Cap",
            "ba": "The virtual table describes the names of players who have been awarded both the Man of the Series and the Orange Cap in a specific season. It combines data from the 'player' table and the 'season' table to identify these players based on their unique identifiers."
        },
        {
            "sample_id": 1854,
            "vt": "SELECT CAST(SUM(CASE WHEN rolee.role_desc = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(rolee.role_id) FROM rolee INNER JOIN Player_Match AS T2 ON T2.Role_Id = T1.Role_Id INNER JOIN Player AS T3 ON T3.Player_Id = T2.Player_Id WHERE player.dob LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average based on the roles of players in matches. It sums up a specific numeric value for players with a given role description, applies a multiplier, and divides by the count of roles to get the average. The query filters players based on their date of birth."
        },
        {
            "sample_id": 1968,
            "vt": "SELECT [placeholder-type:numeric] - SUBSTRING(player.dob, [placeholder-type:numeric], [placeholder-type:numeric]) FROM player WHERE player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the age of a player by calculating the difference between the current year and the year extracted from the player's date of birth. The query filters the results based on the player's name, which is provided as a placeholder."
        },
        {
            "sample_id": 2024,
            "vt": "SELECT COUNT(DISTINCT T2.Match_Id) FROM team INNER JOIN Match AS T2 ON T1.team_id = T2.match_winner INNER JOIN Player_Match AS T3 ON T1.Team_Id = T3.Team_Id INNER JOIN Season AS T4 ON T2.Season_Id = T4.Season_Id WHERE team.team_name = '[placeholder-type:string]' AND season.season_year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of distinct matches won by a specific team in a given season. It joins the 'team' table with the 'match' table to identify matches won by the team, and further joins with the 'player_match' and 'season' tables to filter results based on the team's name and the season year."
        },
        {
            "sample_id": 1996,
            "vt": "SELECT venue.venue_name FROM venue INNER JOIN Match AS T2 ON T1.venue_id = T2.venue_id WHERE match.match_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of venues from the 'venue' table associated with a specific match. The placeholder in the WHERE clause represents the unique identifier for the match."
        },
        {
            "sample_id": 2007,
            "vt": "SELECT [placeholder-type:numeric] - STRFTIME('%Y', player.dob) FROM player WHERE player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the age of a player by subtracting the player's birth year from the current year. It retrieves this information from the 'player' table, filtering the results based on the player's name provided as a placeholder."
        },
        {
            "sample_id": 1926,
            "vt": "SELECT CAST(COUNT(CASE WHEN match.win_margin < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / TOTAL(venue.venue_id) FROM venue INNER JOIN Match AS T2 ON T1.Venue_Id = T2.Venue_Id WHERE venue.venue_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted count of matches held at a specific venue based on the winning margin. It counts the number of matches where the win margin is less than a specified threshold and multiplies this count by a placeholder value, then divides by the total number of matches at that venue. The placeholder in the WHERE clause represents the name of the venue."
        },
        {
            "sample_id": 1915,
            "vt": "SELECT player.player_name FROM player_match INNER JOIN Team AS T2 ON T1.Team_Id = T2.Team_Id INNER JOIN Player AS T3 ON T1.Player_Id = T3.Player_Id WHERE team.team_name = '[placeholder-type:string]' GROUP BY player.player_name ORDER BY COUNT(player_match.role_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players from the 'player' table who are part of a specific team. The query joins the 'player_match' table to associate players with their respective teams and filters the results based on the team name provided as a placeholder. Additionally, it groups the results by player names and orders them by the count of roles each player has in matches, limiting the output to a specified number of players."
        },
        {
            "sample_id": 1834,
            "vt": "SELECT player.player_name FROM player WHERE player.player_id = (SELECT match.man_of_the_match FROM \"Match\" ORDER BY match_date ASC LIMIT 1)",
            "ba": "The virtual table retrieves the name of the player who was awarded the 'man of the match' in the earliest match recorded in the 'match' table."
        },
        {
            "sample_id": 2012,
            "vt": "SELECT player.player_name FROM player INNER JOIN Match AS T2 ON T1.Player_Id = T2.Man_of_the_Match INNER JOIN Player_Match AS T3 ON T3.Player_Id = T1.Player_Id INNER JOIN Season AS T4 ON T2.Season_Id = T4.Season_Id WHERE season.season_year = [placeholder-type:numeric] GROUP BY player.player_name",
            "ba": "The virtual table describes the names of players who have been awarded the 'Man of the Match' in a specific season. It retrieves player names from the 'player' table, joining it with the 'match' table to find matches where players received this award, and further joins with the 'player_match' and 'season' tables to filter results based on the specified season year."
        },
        {
            "sample_id": 2010,
            "vt": "SELECT player.player_name FROM player INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_ID WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of players from the 'player' table who belong to a specific country. The query uses an INNER JOIN to connect the 'player' table with the 'country' table based on the country ID, filtering results by the specified country name."
        },
        {
            "sample_id": 1987,
            "vt": "SELECT SUM(CASE WHEN win_by.win_type = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"match\" INNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id",
            "ba": "The virtual table calculates the total wins based on a specific winning type from the 'match' table, using a conditional sum to differentiate between different win types. The placeholders represent the win type and the numeric values for the sum calculation."
        },
        {
            "sample_id": 2036,
            "vt": "SELECT COUNT(match.match_id) FROM match WHERE match.win_margin = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of matches from the 'match' table where the winning margin is equal to a specified value. The placeholder in the WHERE clause represents the winning margin for filtering the results."
        },
        {
            "sample_id": 1799,
            "vt": "SELECT player.player_name FROM match INNER JOIN Player AS T2 ON T2.Player_Id = T1.Man_of_the_Match WHERE match.match_date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of players who were awarded the 'Man of the Match' in matches held on a specific date. It retrieves player names from the 'player' table by joining it with the 'match' table based on the 'man_of_the_match' field, which indicates the player who received this award for that match."
        },
        {
            "sample_id": 1978,
            "vt": "SELECT umpire.umpire_id, umpire.umpire_name FROM umpire INNER JOIN Country AS T2 ON T1.Umpire_Country = T2.Country_Id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique identifiers and names of umpires from the 'umpire' table who are associated with a specific country. The placeholder in the WHERE clause represents the name of the country."
        },
        {
            "sample_id": 1923,
            "vt": "SELECT country.country_name FROM bowling_style INNER JOIN Player AS T2 ON T1.Bowling_Id = T2.Bowling_skill INNER JOIN Country AS T3 ON T2.Country_Name = T3.Country_Id WHERE bowling_style.bowling_skill = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of countries associated with players who have a specific bowling skill. It joins the 'bowling_style' table with the 'player' table to link bowling skills to players, and then further joins with the 'country' table to get the country names based on the player's country ID. The placeholder in the WHERE clause represents the specific bowling skill being queried."
        },
        {
            "sample_id": 2032,
            "vt": "SELECT CASE WHEN COUNT(match.man_of_the_match) > [placeholder-type:numeric] THEN player.player_name ELSE [placeholder-type:numeric] END FROM player INNER JOIN Match AS T2 ON T1.Player_Id = T2.Man_of_the_Match INNER JOIN Player_Match AS T3 ON T3.Player_Id = T1.Player_Id INNER JOIN Season AS T4 ON T2.Season_Id = T4.Season_Id WHERE season.season_year = [placeholder-type:numeric]",
            "ba": "The virtual table provides a conditional selection of player names based on the count of matches won by the player as 'man of the match' in a specific season. If the count exceeds a specified number, it returns the player's name; otherwise, it returns a numeric placeholder."
        },
        {
            "sample_id": 1853,
            "vt": "SELECT DISTINCT CASE WHEN match.win_margin < (SELECT AVG(match.win_margin) * [placeholder-type:numeric] FROM Match WHERE Match_Date LIKE '2011%') THEN team.team_name END, CASE WHEN match.win_margin < (SELECT AVG(match.win_margin) * [placeholder-type:numeric] FROM Match WHERE Match_Date LIKE '2011%') THEN team.team_name END FROM match INNER JOIN Team AS T2 ON T2.Team_Id = T1.Team_1 INNER JOIN Team AS T3 ON T3.Team_Id = T1.Team_2 WHERE match.match_date LIKE '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of teams that won matches with a winning margin less than a specified percentage of the average winning margin for matches played in the year 2011. The query uses placeholders to filter the match date and the percentage multiplier for the average winning margin."
        },
        {
            "sample_id": 1999,
            "vt": "SELECT SUM(CASE WHEN rolee.role_id = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN rolee.role_id > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM player_match INNER JOIN Player AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Rolee AS T3 ON T1.Role_Id = T3.Role_Id WHERE player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between two sums based on player roles from the 'player_match' table. It uses conditional aggregation to sum values based on specific role IDs and compares them. The result is filtered by the player's name, allowing users to analyze performance metrics for a specific player."
        },
        {
            "sample_id": 1979,
            "vt": "SELECT player.player_name FROM player INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Team AS T3 ON T2.Team_Id = T3.Team_Id INNER JOIN Rolee AS T4 ON T2.Role_Id = T4.Role_Id WHERE team.team_name = '[placeholder-type:string]' AND rolee.role_desc = '[placeholder-type:string]' GROUP BY player.player_name",
            "ba": "The virtual table describes the names of players from the 'player' table who are part of a specific team and have a specific role. The query uses inner joins to connect the 'player', 'player_match', 'team', and 'rolee' tables, filtering results based on the team name and role description provided as placeholders."
        },
        {
            "sample_id": 1857,
            "vt": "SELECT ball_by_ball.match_id FROM ball_by_ball WHERE ball_by_ball.over_id = [placeholder-type:numeric] GROUP BY ball_by_ball.match_id LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique match identifiers from the 'ball_by_ball' table for a specific over, grouping the results by match ID and limiting the output to a specified number of matches."
        },
        {
            "sample_id": 1895,
            "vt": "SELECT SUM(CASE WHEN wicket_taken.fielders = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM wicket_taken WHERE wicket_taken.over_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total number of wickets taken by a specific fielder in a particular over of a match. The placeholder for the fielder's ID allows users to specify which fielder's wickets they are interested in, while the placeholder for the over ID allows them to focus on a specific over within the match."
        },
        {
            "sample_id": 1805,
            "vt": "SELECT player.player_name FROM player ORDER BY player.dob LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of players from the 'player' table, sorted by their date of birth. The placeholder in the LIMIT clause allows the user to specify how many player names to retrieve."
        },
        {
            "sample_id": 2011,
            "vt": "SELECT venue.venue_name FROM venue INNER JOIN City AS T2 ON T1.City_ID = T2.City_ID WHERE city.city_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of venues from the 'venue' table that are located in a specific city. The query uses an INNER JOIN to connect the 'venue' table with the 'city' table based on the city ID, filtering results by the specified city name."
        },
        {
            "sample_id": 2021,
            "vt": "SELECT COUNT(player.player_id) FROM player INNER JOIN Bowling_Style AS T2 ON T1.Bowling_skill = T2.Bowling_Id WHERE bowling_style.bowling_skill = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of players from the 'player' table who have a specific bowling skill. It joins the 'player' table with the 'bowling_style' table to filter players based on their bowling skill, represented by a placeholder."
        },
        {
            "sample_id": 1898,
            "vt": "SELECT wicket_taken.player_out FROM wicket_taken INNER JOIN Out_Type AS T2 ON T1.Kind_Out = T2.Out_Id WHERE out_type.out_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the players who got out in matches, filtered by a specific type of out. The placeholder in the WHERE clause represents the name of the out type."
        },
        {
            "sample_id": 1813,
            "vt": "SELECT country.country_name FROM season INNER JOIN Player AS T2 ON T1.Man_of_the_Series = T2.Player_Id INNER JOIN Country AS T3 ON T2.Country_Name = T3.Country_Id WHERE season.season_id = [placeholder-type:numeric] AND NOT season.purple_cap IS NULL",
            "ba": "The virtual table retrieves the names of countries from the 'country' table for players who were awarded the 'Man of the Series' in a specific season. It filters the results to include only those seasons where the 'purple cap' is not null, indicating that there was a leading wicket-taker in that season."
        },
        {
            "sample_id": 2033,
            "vt": "SELECT CAST(SUM(CASE WHEN country.country_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / COUNT(player.player_id) FROM player INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_ID WHERE STRFTIME('%Y', player.dob) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average of a specific numeric value for players from a specified country, filtered by their date of birth within a certain year range. The placeholders represent the country name and the year range for filtering the players."
        },
        {
            "sample_id": 1974,
            "vt": "SELECT CAST(SUM(CASE WHEN match.match_winner = team.team_id THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(match.match_id) FROM \"match\" INNER JOIN Team AS T2 ON T1.Team_1 = T2.Team_Id OR T1.Team_2 = T2.Team_Id WHERE team.team_name = '[placeholder-type:string]' AND match.match_date LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average winning margin for a specific team in matches held on a particular date. It sums the winning margins for matches won by the specified team and divides it by the total number of matches played on that date. The placeholders represent the winning margin, the team name, and the match date."
        },
        {
            "sample_id": 1893,
            "vt": "SELECT CAST(COUNT(CASE WHEN match.win_margin > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / TOTAL(match.match_id) FROM \"match\"",
            "ba": "The virtual table calculates the percentage of matches where the winning margin exceeds a specified threshold. It counts the number of matches with a win margin greater than a given value and divides it by the total number of matches, multiplying the result by a specified factor for scaling purposes."
        },
        {
            "sample_id": 1904,
            "vt": "SELECT venue.venue_name FROM \"match\" INNER JOIN Venue AS T2 ON T1.Venue_Id = T2.Venue_Id GROUP BY venue.venue_name ORDER BY COUNT(venue.venue_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of venues where matches have been held, grouped by venue name. It orders the results based on the count of matches held at each venue and limits the output to a specified number of venues."
        },
        {
            "sample_id": 1867,
            "vt": "SELECT player.player_name, country.country_name FROM player_match INNER JOIN Team AS T2 ON T2.Team_Id = T1.Team_Id INNER JOIN Match AS T3 ON T3.Match_Id = T1.Match_Id INNER JOIN Player AS T4 ON T4.Player_Id = T1.Player_Id INNER JOIN Country AS T5 ON T5.Country_Id = T4.Country_Name WHERE team.team_name = '[placeholder-type:string]' AND match.match_date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of players and their corresponding countries from the 'player' and 'country' tables. It filters the results based on a specific team name and match date, allowing users to find out which players from a particular team participated in a match on a given date."
        },
        {
            "sample_id": 1906,
            "vt": "SELECT player.player_name FROM season INNER JOIN Player AS T2 ON T1.Man_of_the_Series = T2.Player_Id WHERE season.man_of_the_series > [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players who have been awarded the 'Man of the Series' in seasons where the 'Man of the Series' player ID is greater than a specified numeric value. The query joins the 'season' table with the 'player' table to retrieve the relevant player names based on the condition provided."
        },
        {
            "sample_id": 1871,
            "vt": "SELECT team.team_name, COUNT(player_match.match_id) FROM player INNER JOIN Player_Match AS T2 ON T2.Player_Id = T1.Player_Id INNER JOIN Team AS T3 ON T3.Team_Id = T2.Team_Id WHERE player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of matches played by a specific player, identified by their name, along with the name of the team they belong to. It combines data from the 'player', 'player_match', and 'team' tables to achieve this."
        },
        {
            "sample_id": 2041,
            "vt": "SELECT COUNT(*) FROM player INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_ID WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of players from a specific country by joining the 'player' table with the 'country' table based on the country ID. The placeholder in the WHERE clause represents the name of the country for which the count of players is being requested."
        },
        {
            "sample_id": 1860,
            "vt": "SELECT match.match_id FROM match WHERE match.match_date LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique match identifier from the 'match' table for matches that occurred on a specific date. The placeholder in the WHERE clause represents the date of the match."
        },
        {
            "sample_id": 1976,
            "vt": "SELECT player.player_name, country.country_name FROM player INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_Id ORDER BY player.dob LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players along with their respective countries from the 'player' and 'country' tables. The query joins these two tables based on the country ID, ensuring that each player's country is accurately represented. The results are ordered by the players' date of birth, and a limit is applied to restrict the number of records returned."
        },
        {
            "sample_id": 2017,
            "vt": "SELECT COUNT(player_match.player_id) FROM player_match INNER JOIN Match AS T2 ON T1.Match_Id = T2.Match_Id INNER JOIN Rolee AS T3 ON T1.Role_Id = T3.Role_Id WHERE rolee.role_desc = '[placeholder-type:string]' AND match.match_date LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of players who participated in matches with a specific role on a given date. It joins the 'player_match' table with the 'match' table to filter by match date and the 'rolee' table to filter by role description."
        },
        {
            "sample_id": 1861,
            "vt": "SELECT wicket_taken.match_id FROM wicket_taken INNER JOIN Out_Type AS T2 ON T2.Out_Id = T1.Kind_Out WHERE out_type.out_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the match IDs from the 'wicket_taken' table where the type of out corresponds to a specific out name. It uses an inner join with the 'out_type' table to filter the results based on the out type name provided by the user."
        },
        {
            "sample_id": 1941,
            "vt": "SELECT match.match_id FROM \"match\" INNER JOIN Player AS T2 ON T1.Man_of_the_Match = T2.Player_Id WHERE player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique match identifier from the 'match' table for matches where a specific player has been awarded the 'Man of the Match'. The query joins the 'match' table with the 'player' table to filter based on the player's name."
        },
        {
            "sample_id": 2034,
            "vt": "SELECT CAST(SUM(CASE WHEN batting_style.batting_hand = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(player.player_id) FROM player INNER JOIN Batting_Style AS T2 ON T1.Batting_hand = T2.Batting_Id",
            "ba": "The virtual table calculates the average runs scored by players based on their batting hand from the 'player' table, joining with the 'batting_style' table to filter players by their batting hand. The result is scaled by a specified factor, and the total runs are summed up for players with the specified batting hand, while also counting the total number of players to compute the average."
        },
        {
            "sample_id": 1887,
            "vt": "SELECT city.city_name FROM venue INNER JOIN City AS T2 ON T1.City_Id = T2.City_Id WHERE venue.venue_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of cities where venues are located, filtered by a specific venue name. The placeholder in the WHERE clause represents the venue's name."
        },
        {
            "sample_id": 2015,
            "vt": "SELECT player.player_name FROM player INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Rolee AS T3 ON T2.Role_Id = T3.Role_Id WHERE rolee.role_desc = '[placeholder-type:string]' GROUP BY player.player_name",
            "ba": "The virtual table describes the names of players from the 'player' table who have a specific role in a match. The query joins the 'player' table with the 'player_match' table to associate players with their roles, and then it further joins with the 'rolee' table to filter based on the role description. The placeholder in the WHERE clause represents the specific role that is being queried."
        },
        {
            "sample_id": 2014,
            "vt": "SELECT rolee.role_desc FROM player INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Rolee AS T3 ON T2.Role_Id = T3.Role_Id WHERE player.player_name = '[placeholder-type:string]' GROUP BY rolee.role_desc",
            "ba": "The virtual table describes the roles of a specific player in matches from the 'player' and 'player_match' tables. It retrieves the role descriptions by joining the 'player' table with the 'player_match' table and the 'rolee' table. The placeholder in the WHERE clause represents the player's name, allowing users to specify which player's roles they want to query."
        },
        {
            "sample_id": 1838,
            "vt": "SELECT CAST(SUM(CASE WHEN batting_style.batting_hand = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(player.player_id) FROM batting_style INNER JOIN Player AS T2 ON T2.Batting_hand = T1.Batting_Id",
            "ba": "The virtual table calculates the average runs scored by players based on their batting hand from the 'batting_style' and 'player' tables. It uses a conditional sum to differentiate between left-handed and right-handed batsmen, applying a multiplier to the result. The placeholders represent the batting hand type, numeric values for runs, and a multiplier for the average calculation."
        },
        {
            "sample_id": 2019,
            "vt": "SELECT win_by.win_type FROM match INNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id WHERE match.match_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the winning type of a specific match from the 'match' table by joining it with the 'win_by' table. The placeholder in the WHERE clause represents the unique identifier for the match."
        },
        {
            "sample_id": 1875,
            "vt": "SELECT match.toss_winner FROM match WHERE match.toss_decide = [placeholder-type:numeric]",
            "ba": "The virtual table provides information about the team that won the toss in a cricket match from the 'match' table, filtered by a specific toss decision using a placeholder for numeric values."
        },
        {
            "sample_id": 1935,
            "vt": "SELECT SUM(CASE WHEN venue.venue_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"match\" INNER JOIN Venue AS T2 ON T1.Venue_Id = T2.Venue_Id WHERE match.match_date BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total of a specific numeric value based on a condition related to the venue name from the 'match' table. It joins the 'match' table with the 'venue' table to filter matches that occurred within a specified date range. The placeholders represent the venue name and the date range for filtering the matches."
        },
        {
            "sample_id": 1899,
            "vt": "SELECT CAST(SUM(CASE WHEN batting_style.batting_hand = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(player.country_name) FROM batting_style INNER JOIN Player AS T2 ON T1.Batting_id = T2.Batting_hand",
            "ba": "The virtual table calculates a weighted average of a specific statistic based on the batting hand of players from the 'Player' table. It sums up values conditionally based on whether the player's batting hand matches a specified value, and then scales this sum by a placeholder numeric value, dividing it by the count of players from a specific country."
        },
        {
            "sample_id": 1939,
            "vt": "SELECT player.player_name FROM bowling_style INNER JOIN Player AS T2 ON T1.Bowling_Id = T2.Bowling_skill WHERE bowling_style.bowling_skill = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of players who have a specific bowling skill from the 'Player' table. It uses an inner join with the 'bowling_style' table to filter players based on their bowling skill, represented by a placeholder."
        },
        {
            "sample_id": 1843,
            "vt": "SELECT team.team_name FROM player INNER JOIN Player_Match AS T2 ON T2.Player_Id = T1.Player_Id INNER JOIN Team AS T3 ON T3.Team_Id = T2.Team_Id WHERE player_match.match_id = [placeholder-type:numeric] AND team.team_name = '[placeholder-type:string]' GROUP BY team.team_name",
            "ba": "The virtual table lists the names of teams from the 'team' table that have players participating in a specific match. The query joins the 'player' and 'player_match' tables to filter players based on the match ID and then checks for a specific team name using placeholders for both numeric and string values."
        },
        {
            "sample_id": 1959,
            "vt": "SELECT country.country_name FROM umpire INNER JOIN country AS T2 ON T2.Country_Id = T1.Umpire_Country WHERE umpire.umpire_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of countries from which umpires originate, based on the name of a specific umpire. The query joins the 'umpire' table with the 'country' table to retrieve the country name associated with the umpire's country ID."
        },
        {
            "sample_id": 1829,
            "vt": "SELECT SUM(CASE WHEN player.player_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM player INNER JOIN Season AS T2 ON T1.Player_Id = T2.Orange_Cap",
            "ba": "The virtual table calculates the total runs scored by a specific player, identified by their name, who has won the Orange Cap in a particular season. The query uses a conditional statement to sum the runs based on whether the player's name matches the specified placeholder. The result will provide insights into the performance of that player during the season they won the Orange Cap."
        },
        {
            "sample_id": 1901,
            "vt": "SELECT COUNT(win_by.win_id) FROM \"match\" INNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id WHERE win_by.win_type = '[placeholder-type:string]' AND match.win_margin < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of matches from the 'match' table that have a specific winning type and a winning margin less than a specified value. It joins the 'match' table with the 'win_by' table to filter the results based on the winning type and margin criteria."
        },
        {
            "sample_id": 1911,
            "vt": "SELECT COUNT(match.team_1) FROM \"match\" WHERE match.team_1 = match.toss_winner AND match.toss_decide = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of matches from the 'match' table where the first team (team_1) is the same as the toss winner and the toss decision made after winning the toss is specified by a placeholder for numeric values."
        },
        {
            "sample_id": 1957,
            "vt": "SELECT player.player_name FROM player INNER JOIN Bowling_Style AS T2 ON T1.Bowling_skill = T2.Bowling_Id WHERE bowling_style.bowling_skill = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of players from the 'player' table who have a specific bowling skill. The query uses an INNER JOIN to connect the 'player' table with the 'bowling_style' table based on the bowling skill ID, allowing for filtering by a specific bowling skill using a placeholder."
        },
        {
            "sample_id": 1787,
            "vt": "SELECT COUNT(player.player_id) FROM player WHERE SUBSTRING(player.dob, [placeholder-type:numeric], [placeholder-type:numeric]) > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of players from the 'player' table whose date of birth falls within a specified range. The placeholders represent the starting and ending positions of the substring to extract the year from the date of birth, as well as the year to compare against."
        },
        {
            "sample_id": 2009,
            "vt": "SELECT COUNT(player.player_id) FROM player INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_ID WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of players from a specific country by joining the 'player' table with the 'country' table based on the country ID. The placeholder in the WHERE clause represents the name of the country for which the player count is being queried."
        },
        {
            "sample_id": 1816,
            "vt": "SELECT city.city_name FROM city INNER JOIN Venue AS T2 ON T1.City_Id = T2.City_Id GROUP BY city.city_id ORDER BY COUNT(venue.venue_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of cities from the 'city' table that have associated venues. It joins the 'city' table with the 'venue' table to count the number of venues in each city, grouping the results by city ID. The output is ordered by the count of venues in descending order, and a placeholder is used to limit the number of results returned."
        },
        {
            "sample_id": 1949,
            "vt": "SELECT player.dob FROM player GROUP BY player.dob ORDER BY COUNT(player.dob) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the birth dates of players from the 'player' table, grouping them to find unique dates. It orders the results by the count of players sharing the same birth date and limits the output to a specified number of results."
        },
        {
            "sample_id": 1849,
            "vt": "SELECT rolee.role_desc FROM player INNER JOIN Player_Match AS T2 ON T2.Player_Id = T1.Player_Id INNER JOIN Rolee AS T3 ON T3.Role_Id = T2.Role_Id WHERE player_match.match_id = [placeholder-type:numeric] AND player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the roles of players in a specific match based on their player name. It retrieves the role description from the 'rolee' table by joining it with the 'player' and 'player_match' tables, filtering by the match ID and player name."
        },
        {
            "sample_id": 1815,
            "vt": "SELECT SUM(CASE WHEN country.country_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM city INNER JOIN Country AS T2 ON T1.Country_Id = T2.Country_Id",
            "ba": "The virtual table calculates the total sum of a specific numeric value based on a condition related to the country name from the 'city' and 'country' tables. It uses a CASE statement to determine which numeric value to sum depending on whether the country name matches a specified placeholder."
        },
        {
            "sample_id": 1877,
            "vt": "SELECT player.dob FROM match INNER JOIN Player AS T2 ON T2.Player_Id = T1.Man_of_the_Match",
            "ba": "The virtual table retrieves the date of birth of the player who was awarded the man of the match in a specific match. It joins the 'match' table with the 'player' table to link the match details with the player's information."
        },
        {
            "sample_id": 1802,
            "vt": "SELECT MAX(match.win_margin) FROM player INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Match AS T3 ON T2.Match_Id = T3.Match_Id WHERE player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum winning margin from the 'match' table for a specific player by joining the 'player' and 'player_match' tables. It filters the results based on the player's name provided as a placeholder."
        },
        {
            "sample_id": 1869,
            "vt": "SELECT country.country_name FROM country INNER JOIN Umpire AS T2 ON T2.Umpire_Country = T1.Country_Id WHERE umpire.umpire_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of countries from the 'country' table where the umpires are from, based on a specific umpire's name. The query uses an INNER JOIN to connect the 'country' table with the 'umpire' table, filtering results to match the provided umpire's name."
        },
        {
            "sample_id": 1796,
            "vt": "SELECT bowling_style.bowling_skill FROM player INNER JOIN Bowling_Style AS T2 ON T1.Bowling_skill = T2.Bowling_Id INNER JOIN Country AS T3 ON T1.Country_Name = T3.Country_Id WHERE country.country_name = '[placeholder-type:string]' GROUP BY bowling_style.bowling_skill",
            "ba": "The virtual table retrieves the bowling skills of players from the 'player' table who belong to a specific country. It joins the 'bowling_style' table to get the corresponding bowling skills and the 'country' table to filter players based on their country name. The placeholder in the WHERE clause represents the name of the country."
        },
        {
            "sample_id": 2022,
            "vt": "SELECT outcome.outcome_type FROM match INNER JOIN Outcome AS T2 ON T1.Outcome_type = T2.Outcome_Id WHERE match.match_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the outcome type of a specific match from the 'match' table by joining it with the 'outcome' table. The placeholder in the WHERE clause represents the unique identifier for the match."
        },
        {
            "sample_id": 1817,
            "vt": "SELECT batting_style.batting_hand FROM player INNER JOIN Batting_Style AS T2 ON T1.Batting_hand = T2.Batting_Id WHERE player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the batting hand of a player from the 'player' table based on the player's name. The query joins the 'player' table with the 'batting_style' table to retrieve the batting hand information."
        },
        {
            "sample_id": 1833,
            "vt": "SELECT team.team_name FROM team INNER JOIN (SELECT COUNT(Team_1) AS a, Team_1 FROM Match WHERE Team_1 <> Match_Winner GROUP BY Team_1 UNION SELECT COUNT(Team_2) AS a, Team_2 FROM Match WHERE Team_2 <> Match_Winner GROUP BY Team_2 ORDER BY a DESC LIMIT 1) AS T2 ON T1.Team_Id = T2.Team_1",
            "ba": "The virtual table lists the name of the team that has lost the most matches in a given dataset. It does this by counting the number of times each team appears as Team_1 and Team_2 in the Match table, excluding instances where they were the match winner. The results are combined using a UNION operation and sorted in descending order to identify the team with the highest count of losses."
        },
        {
            "sample_id": 1809,
            "vt": "SELECT player.player_name FROM player INNER JOIN Match AS T2 ON T1.Player_Id = T2.Man_of_the_Match WHERE match.match_date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of players who were awarded the 'Man of the Match' title in matches that occurred on a specific date. The query retrieves player names from the 'player' table and joins it with the 'match' table to filter results based on the match date."
        },
        {
            "sample_id": 1942,
            "vt": "SELECT SUM(CASE WHEN match.match_date BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"match\" INNER JOIN Player AS T2 ON T2.Player_Id = T1.Man_of_the_Match INNER JOIN Country AS T3 ON T3.Country_Id = T2.Country_Name WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of matches won by players from a specific country who were awarded 'Man of the Match' during a specified date range. It aggregates the results based on the match date and filters the data to include only those matches where the winning player belongs to the specified country."
        },
        {
            "sample_id": 1962,
            "vt": "SELECT player.player_name FROM \"match\" INNER JOIN Player_Match AS T2 ON T1.Match_Winner = T2.Team_Id INNER JOIN Player AS T3 ON T2.Player_Id = T3.Player_Id WHERE match.season_id = [placeholder-type:numeric] ORDER BY match.match_date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players from the 'Player' table who were part of the winning team in matches during a specific season. The query joins the 'match' table to identify the winning team and then links to the 'Player_Match' table to find the players associated with that team. The results are filtered by the season ID and ordered by the match date, with a limit on the number of results returned."
        },
        {
            "sample_id": 1928,
            "vt": "SELECT player.player_id FROM player ORDER BY player.bowling_skill LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique identifiers of players from the 'player' table, ordered by their bowling skill. The placeholder in the LIMIT clause allows for specifying the maximum number of players to retrieve."
        },
        {
            "sample_id": 1973,
            "vt": "SELECT player.player_name FROM player INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_Id WHERE country.country_name = '[placeholder-type:string]' AND player.dob LIKE '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of players from the 'player' table who belong to a specific country and were born on a specific date. The query uses an INNER JOIN to connect the 'player' table with the 'country' table based on the country ID. The placeholders represent the country name and the date of birth of the players."
        },
        {
            "sample_id": 1851,
            "vt": "SELECT SUM(CASE WHEN venue.venue_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM match INNER JOIN Venue AS T2 ON T2.Venue_Id = T1.Venue_Id",
            "ba": "The virtual table calculates the total runs scored in matches held at a specific venue. It uses a conditional sum to differentiate between runs based on whether the venue name matches a specified value. The placeholders represent the venue name and the numeric values for runs."
        },
        {
            "sample_id": 1791,
            "vt": "SELECT COUNT(CASE WHEN country.country_name = '[placeholder-type:string]' THEN player.player_id ELSE NULL END) FROM player INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_Id",
            "ba": "The virtual table counts the number of players from a specific country by joining the 'player' table with the 'country' table. The placeholder in the WHERE clause represents the name of the country for which the count of players is being requested."
        },
        {
            "sample_id": 1924,
            "vt": "SELECT venue.venue_name FROM venue INNER JOIN Match AS T2 ON T1.Venue_Id = T2.Venue_Id INNER JOIN Team AS T3 ON T2.Team_1 = T3.Team_Id WHERE team.team_name = '[placeholder-type:string]' GROUP BY venue.venue_name",
            "ba": "The virtual table describes the names of venues where matches were played by a specific team. It retrieves venue names from the 'venue' table, joining it with the 'match' table to filter matches based on the team name. The placeholder in the WHERE clause represents the name of the team."
        },
        {
            "sample_id": 1970,
            "vt": "SELECT COUNT(match.match_id) FROM \"match\" WHERE match.match_date LIKE '[placeholder-type:string]' AND match.win_margin < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of matches from the 'match' table that occurred on a specific date and had a winning margin less than a specified value. The placeholders represent the date format and the numeric winning margin threshold."
        },
        {
            "sample_id": 1814,
            "vt": "SELECT country.country_name FROM city INNER JOIN Country AS T2 ON T1.Country_Id = T2.Country_Id WHERE city.city_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of countries from the 'country' table based on the specified city name from the 'city' table. It uses an inner join to connect the two tables through the country ID, allowing for the extraction of the country name associated with a given city."
        },
        {
            "sample_id": 1803,
            "vt": "SELECT CAST(SUM(match.win_margin) AS FLOAT) / COUNT(*) FROM player INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Match AS T3 ON T2.Match_Id = T3.Match_Id WHERE player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average winning margin of matches for a specific player by summing the win margins from the 'match' table and dividing it by the total number of matches played by that player. The query joins the 'player', 'player_match', and 'match' tables to gather the necessary data, filtering by the player's name."
        },
        {
            "sample_id": 1856,
            "vt": "SELECT batsman_scored.over_id, batsman_scored.ball_id, batsman_scored.innings_no FROM batsman_scored WHERE batsman_scored.match_id = [placeholder-type:numeric] ORDER BY batsman_scored.runs_scored LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides information about the overs and balls in which runs were scored by batsmen during a specific match. It includes the over ID, ball ID, and innings number for each scoring event. The placeholders allow users to specify the match ID and limit the number of results returned."
        },
        {
            "sample_id": 2005,
            "vt": "SELECT COUNT(match.match_id) FROM match WHERE match.match_date LIKE '[placeholder-type:string]' AND NOT match.match_winner IS NULL",
            "ba": "The virtual table counts the number of matches from the 'match' table that occurred on a specific date, ensuring that only matches with a declared winner are included in the count. The placeholder in the WHERE clause represents the date of the match."
        },
        {
            "sample_id": 1914,
            "vt": "SELECT SUM(CASE WHEN player.player_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"match\" INNER JOIN Player AS T2 ON T1.Man_of_the_Match = T2.Player_Id",
            "ba": "The virtual table calculates the total runs scored by a specific player in matches where they were awarded 'Man of the Match'. It uses a conditional sum to differentiate between runs scored by the specified player and others, allowing for a comparison of performance."
        },
        {
            "sample_id": 1910,
            "vt": "SELECT DISTINCT ball_by_ball.over_id FROM ball_by_ball WHERE ball_by_ball.striker = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct over identifiers from the 'ball_by_ball' table for a specific player who is currently batting. The placeholder represents the unique identifier of the player on strike."
        },
        {
            "sample_id": 1963,
            "vt": "SELECT player.player_name FROM player INNER JOIN Season AS T2 ON T1.Player_Id = T2.Purple_Cap ORDER BY season.season_year - SUBSTRING(player.dob, [placeholder-type:numeric], [placeholder-type:numeric]) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of players who have won the Purple Cap in the IPL, which is awarded to the leading wicket-taker. The query joins the 'player' table with the 'season' table to filter players based on their winning status and orders them by their age calculated from their date of birth. The placeholders allow for dynamic input of specific values for age calculation and limit on the number of results returned."
        },
        {
            "sample_id": 1950,
            "vt": "SELECT match.match_date FROM \"match\" ORDER BY match.win_margin LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of match dates from the 'match' table, ordered by the winning margin of each match. The placeholder in the LIMIT clause allows the user to specify the number of match dates they wish to retrieve."
        },
        {
            "sample_id": 1824,
            "vt": "SELECT season.orange_cap FROM season GROUP BY season.orange_cap HAVING COUNT(season.season_year) > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the player IDs of those who have won the Orange Cap in the IPL seasons, grouped by the player ID. It filters the results to include only those players who have won the Orange Cap in more than a specified number of seasons, represented by a numeric placeholder."
        },
        {
            "sample_id": 1855,
            "vt": "SELECT COUNT(ball_by_ball.over_id) FROM ball_by_ball WHERE ball_by_ball.match_id = [placeholder-type:numeric] AND ball_by_ball.innings_no = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of overs in a specific innings of a match from the 'ball_by_ball' table. The placeholders represent the unique match identifier and the innings number."
        },
        {
            "sample_id": 1916,
            "vt": "SELECT player.player_name FROM season INNER JOIN Match AS T2 ON T1.Man_of_the_Series = T2.Man_of_the_Match INNER JOIN Player AS T3 ON T2.Man_of_the_Match = T3.Player_Id GROUP BY player.player_name ORDER BY COUNT(season.man_of_the_series) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players who have been awarded the 'Man of the Series' title in cricket seasons. It retrieves player names by joining the 'season' table with the 'match' table to find matches where players were awarded 'Man of the Match'. The results are grouped by player names and ordered by the count of 'Man of the Series' awards, limiting the output to a specified number of players."
        },
        {
            "sample_id": 2001,
            "vt": "SELECT COUNT(player.player_name) FROM player WHERE player.dob LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of players from the 'player' table who were born in a specific year. The placeholder in the WHERE clause represents the year of birth in a string format."
        },
        {
            "sample_id": 1864,
            "vt": "SELECT player.player_name, player.dob FROM country INNER JOIN Player AS T2 ON T2.Country_Name = T1.Country_Id WHERE player.dob LIKE '[placeholder-type:string]' AND country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and dates of birth of players from the 'Player' table who belong to a specific country. The query joins the 'country' table to filter players based on their country name and also allows for filtering players by their date of birth using a placeholder."
        },
        {
            "sample_id": 1948,
            "vt": "SELECT match.match_id FROM \"match\" ORDER BY match.match_winner LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique match identifiers from the 'match' table, ordered by the match winner. The placeholder in the LIMIT clause allows for specifying the number of matches to retrieve."
        },
        {
            "sample_id": 1932,
            "vt": "SELECT SUM(batsman_scored.runs_scored) FROM batsman_scored WHERE batsman_scored.match_id = [placeholder-type:numeric] AND batsman_scored.innings_no = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total runs scored by batsmen in a specific match and innings. The placeholders represent the unique identifiers for the match and the innings number."
        },
        {
            "sample_id": 1951,
            "vt": "SELECT match.season_id FROM \"match\" GROUP BY match.season_id ORDER BY COUNT(match.match_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique season IDs from the 'match' table, grouping the results by season ID and ordering them based on the count of matches in each season. The placeholder allows for limiting the number of seasons returned."
        },
        {
            "sample_id": 1972,
            "vt": "SELECT SUM(CASE WHEN player.player_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM player_match INNER JOIN Player AS T2 ON T1.Player_Id = T2.Player_Id",
            "ba": "The virtual table calculates the total runs scored by a specific player in matches, using a conditional sum based on the player's name. It joins the 'player_match' table with the 'player' table to access player details and their corresponding match performance."
        },
        {
            "sample_id": 1982,
            "vt": "SELECT team.team_name FROM team INNER JOIN Match AS T2 ON T1.Team_Id = T2.Team_1 OR T1.Team_Id = T2.Team_2 INNER JOIN Win_By AS T3 ON T2.Win_Type = T3.Win_Id WHERE SUBSTRING(match.match_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND win_by.win_type = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of teams that have won matches based on specific criteria. It joins the 'team' table with the 'match' table to identify matches involving the teams, and further joins with the 'win_by' table to filter results based on the type of win. The query also includes conditions to filter matches by date and winning type, using placeholders for dynamic input."
        },
        {
            "sample_id": 1969,
            "vt": "SELECT CAST(SUM(CASE WHEN match.toss_winner = match.match_winner THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN match.match_date LIKE '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"match\"",
            "ba": "The virtual table calculates the winning percentage of the toss winners in matches held on a specific date. It sums up the number of matches where the toss winner is also the match winner and divides it by the total number of matches played on that date. The placeholders represent numeric values for the counts and a string value for the match date."
        },
        {
            "sample_id": 1812,
            "vt": "SELECT player.dob FROM season INNER JOIN Player AS T2 ON T1.Man_of_the_Series = T2.Player_Id WHERE season.season_year = [placeholder-type:numeric] AND NOT season.orange_cap IS NULL",
            "ba": "The virtual table retrieves the date of birth of players who were awarded the Man of the Series in a specific season, provided that the season also has an Orange Cap winner. The query joins the 'season' table with the 'player' table to access player details based on the season year and checks for the presence of an Orange Cap winner."
        },
        {
            "sample_id": 1885,
            "vt": "SELECT venue.venue_name FROM city INNER JOIN Venue AS T2 ON T2.City_Id = T1.City_Id WHERE city.city_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of venues located in a specific city. It retrieves the venue names from the 'venue' table by joining it with the 'city' table based on the city ID. The placeholder in the WHERE clause represents the name of the city for which the venue names are being queried."
        },
        {
            "sample_id": 1937,
            "vt": "SELECT toss_decision.toss_name, match.toss_decide, match.toss_winner FROM \"match\" INNER JOIN Toss_Decision AS T2 ON T1.Toss_Decide = T2.Toss_Id WHERE match.match_id = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the toss decision made in a specific match, including the name of the toss decision, the actual decision made (whether to bat or bowl), and the team that won the toss."
        },
        {
            "sample_id": 1801,
            "vt": "SELECT player_match.role_id FROM player INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Rolee AS T3 ON T2.Role_Id = T3.Role_Id INNER JOIN Match AS T4 ON T2.Match_Id = T4.Match_Id WHERE player.player_name = '[placeholder-type:string]' AND match.match_date = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the role of a player in a specific match based on the player's name and the match date. It joins the 'player' table with the 'player_match' table to find the corresponding role, and further joins with the 'match' table to filter by the match date."
        },
        {
            "sample_id": 2039,
            "vt": "SELECT team.team_name FROM team INNER JOIN Match AS T2 ON T1.team_id = T2.match_winner INNER JOIN Win_By AS T3 ON T2.win_type = T3.win_id WHERE match.match_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of teams that have won a specific match. It joins the 'team' table with the 'match' table to identify the winning team based on the match ID, and further joins with the 'win_by' table to get the winning type associated with that match."
        },
        {
            "sample_id": 1826,
            "vt": "SELECT SUM(CASE WHEN country.country_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM country INNER JOIN Umpire AS T2 ON T1.Country_ID = T2.Umpire_Country",
            "ba": "The virtual table calculates the total number of umpires from a specific country by summing a conditional case based on the country name. It joins the 'country' table with the 'umpire' table to relate umpires to their respective countries."
        },
        {
            "sample_id": 2038,
            "vt": "SELECT team.team_name FROM team INNER JOIN Match AS T2 ON T1.team_id = T2.match_winner WHERE match.win_margin = [placeholder-type:numeric] AND match.match_date = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of teams that have won matches with a specific winning margin on a particular match date. It joins the 'team' table with the 'match' table to filter the results based on the winning margin and match date."
        },
        {
            "sample_id": 1990,
            "vt": "SELECT COUNT(venue.venue_name) FROM venue INNER JOIN City AS T2 ON T1.City_Id = T2.City_Id INNER JOIN Country AS T3 ON T2.Country_Id = T3.Country_Id WHERE country.country_name = '[placeholder-type:string]' AND city.city_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of venues located in a specific city within a specific country. It joins the 'venue' table with the 'city' table and the 'country' table to filter the results based on the provided country and city names."
        },
        {
            "sample_id": 1945,
            "vt": "SELECT umpire.umpire_name, umpire.umpire_id FROM umpire INNER JOIN Country AS T2 ON T1.Umpire_Country = T2.Country_Id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and unique identifiers of umpires from the 'umpire' table who are associated with a specific country. The placeholder in the WHERE clause represents the name of the country."
        },
        {
            "sample_id": 1956,
            "vt": "SELECT umpire.umpire_name FROM umpire INNER JOIN country AS T2 ON T2.Country_Id = T1.Umpire_Country WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of umpires from the 'umpire' table who are associated with a specific country. The query uses an INNER JOIN to connect the 'umpire' table with the 'country' table based on the country ID, filtering the results by the specified country name."
        },
        {
            "sample_id": 1828,
            "vt": "SELECT country.country_name FROM country INNER JOIN Player AS T2 ON T1.Country_Id = T2.Country_Name GROUP BY player.country_name ORDER BY COUNT(player.country_name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table, which are associated with players in the 'player' table. It groups the results by country name and orders them based on the count of players from each country, limiting the results to a specified number."
        },
        {
            "sample_id": 1825,
            "vt": "SELECT COUNT(match.match_id) FROM \"match\" WHERE match.season_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the total number of matches played in a specific season from the 'match' table. The placeholder in the WHERE clause represents the unique identifier for the season."
        },
        {
            "sample_id": 1975,
            "vt": "SELECT CAST(SUM(CASE WHEN batting_style.batting_hand = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN batting_style.batting_hand = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM player INNER JOIN Batting_Style AS T2 ON T1.Batting_hand = T2.Batting_Id",
            "ba": "The virtual table calculates the ratio of runs scored by players based on their batting hand from the 'player' table, which is joined with the 'batting_style' table to filter players by their batting hand. The placeholders represent the batting hand and the numeric values for runs scored."
        },
        {
            "sample_id": 1903,
            "vt": "SELECT player.player_name, country.country_name FROM season INNER JOIN Player AS T2 ON T1.Man_of_the_Series = T2.Player_Id INNER JOIN Country AS T3 ON T2.Country_Name = T3.Country_Id WHERE season.season_year = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players who were awarded the Man of the Series in a specific season along with their corresponding country names. The query joins the 'season' table with the 'player' table to get the player details and then joins with the 'country' table to fetch the country names. The placeholder in the WHERE clause represents the year of the season."
        },
        {
            "sample_id": 1820,
            "vt": "SELECT player.player_name FROM player ORDER BY player.dob LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of players from the 'player' table, sorted by their date of birth. The placeholder in the LIMIT clause allows the user to specify the number of player names to retrieve."
        },
        {
            "sample_id": 1865,
            "vt": "SELECT player.player_name FROM player INNER JOIN Match AS T2 ON T2.Man_of_the_Match = T1.Player_Id INNER JOIN Season AS T3 ON T3.Season_Id = T2.Season_Id WHERE season.season_year = [placeholder-type:numeric] GROUP BY player.player_name",
            "ba": "The virtual table lists the names of players who have been awarded the 'Man of the Match' title in a specific season. It retrieves data from the 'player', 'match', and 'season' tables, filtering results based on the year of the season provided as a placeholder."
        },
        {
            "sample_id": 1852,
            "vt": "SELECT match.win_margin FROM match INNER JOIN Team AS T2 ON T2.Team_Id = T1.Team_1 INNER JOIN Team AS T3 ON T3.Team_Id = T1.Team_2 WHERE (team.team_name = '[placeholder-type:string]' AND team.team_name = '[placeholder-type:string]' AND match.match_date = '[placeholder-type:string]') OR (team.team_name = '[placeholder-type:string]' AND team.team_name = '[placeholder-type:string]' AND match.match_date = '[placeholder-type:string]')",
            "ba": "The virtual table retrieves the winning margin of a match between two specified teams on a specific date from the 'match' table. It uses inner joins to connect the 'match' table with the 'team' table to identify the teams involved in the match."
        },
        {
            "sample_id": 1938,
            "vt": "SELECT SUM(CASE WHEN player.dob < '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM player INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_Id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of players born before a specified date from the 'player' table, filtered by a specific country. It uses a conditional sum to differentiate between players based on their birth dates, and joins with the 'country' table to ensure the results are limited to the specified country."
        },
        {
            "sample_id": 1884,
            "vt": "SELECT city.city_name FROM city INNER JOIN Venue AS T2 ON T2.City_Id = T1.City_Id WHERE venue.venue_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of cities from the 'city' table that are associated with a specific venue. The query uses an INNER JOIN to connect the 'city' table with the 'venue' table based on the city ID, filtering results by a specific venue name provided as a placeholder."
        },
        {
            "sample_id": 1822,
            "vt": "SELECT COUNT(player.player_id) FROM player WHERE player.dob BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of players from the 'player' table whose date of birth falls within a specified range. The placeholders represent the start and end dates of the range."
        },
        {
            "sample_id": 1998,
            "vt": "SELECT CAST(SUM(CASE WHEN match.match_winner = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(match.match_winner) FROM team INNER JOIN Match AS T2 ON T1.Team_Id = T2.Match_Winner WHERE match.match_date LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of match winners' scores for a specific team over a given date range. It sums the scores of matches won by the specified team and divides it by the total number of matches played on that date, applying a multiplier to adjust the result. The placeholders represent the team ID, score values, and the date filter."
        },
        {
            "sample_id": 1985,
            "vt": "SELECT COUNT(wicket_taken.match_id) FROM wicket_taken WHERE wicket_taken.innings_no = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of wickets taken in a specific innings of a match from the 'wicket_taken' table. The placeholder in the WHERE clause represents the innings number for which the count is required."
        },
        {
            "sample_id": 2004,
            "vt": "SELECT city.city_name FROM city WHERE city.country_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of cities from the 'city' table that belong to a specific country. The placeholder in the WHERE clause represents the unique identifier for the country."
        },
        {
            "sample_id": 1919,
            "vt": "SELECT player.player_name FROM player INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_Id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of players from the 'player' table who belong to a specific country. The query uses an INNER JOIN to connect the 'player' table with the 'country' table based on the country ID, filtering results by the specified country name."
        },
        {
            "sample_id": 1836,
            "vt": "SELECT SUM(CASE WHEN batting_style.batting_hand = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM batting_style INNER JOIN Player AS T2 ON T1.Batting_Id = T2.Batting_hand INNER JOIN Country AS T3 ON T2.Country_Name = T3.Country_Id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total runs scored by players from a specific country based on their batting hand. It uses a conditional sum to differentiate between left-handed and right-handed batsmen, allowing for a comparison of their performance. The placeholders represent the batting hand and the country name, which can be modified to filter results accordingly."
        },
        {
            "sample_id": 1925,
            "vt": "SELECT COUNT(batsman_scored.runs_scored) FROM batsman_scored INNER JOIN Ball_by_Ball AS T2 ON T1.Match_Id = T2.Match_Id INNER JOIN Match AS T3 ON T2.Match_Id = T3.Match_Id INNER JOIN Team AS T4 ON T3.Team_1 = T4.Team_Id WHERE ball_by_ball.team_batting = [placeholder-type:numeric] OR ball_by_ball.team_batting = [placeholder-type:numeric] AND team.team_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the total runs scored by batsmen in a specific match for a particular team. It joins the 'batsman_scored' table with the 'ball_by_ball' table to correlate runs with specific balls bowled, and further joins with the 'match' and 'team' tables to filter results based on the teams involved in the match."
        },
        {
            "sample_id": 1846,
            "vt": "SELECT city.city_name FROM city INNER JOIN Country AS T2 ON T2.Country_Id = T1.Country_id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of cities from the 'city' table that are located in a specific country. The placeholder in the WHERE clause represents the name of the country."
        },
        {
            "sample_id": 1806,
            "vt": "SELECT SUM(CASE WHEN match.toss_winner = (SELECT team.team_id FROM Team WHERE Team_Name = 'Sunrisers Hyderabad') THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"match\"",
            "ba": "The virtual table calculates the total number of matches won by a specific team based on whether they won the toss or not. It uses a conditional sum to differentiate between matches where the team won the toss and those where they did not, with placeholders for numeric values representing the counts in each case."
        },
        {
            "sample_id": 1912,
            "vt": "SELECT SUM(CASE WHEN match.match_date LIKE '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"match\"",
            "ba": "The virtual table calculates the total number of matches played on a specific date, using a conditional sum to differentiate between matches that occurred on that date and those that did not. The placeholders represent the date to filter matches and the numeric values for the sum calculation."
        },
        {
            "sample_id": 1894,
            "vt": "SELECT player.player_name FROM player WHERE player.dob BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' ORDER BY player.dob",
            "ba": "The virtual table describes the names of players from the 'player' table who were born within a specific date range. The placeholders in the WHERE clause represent the start and end dates of the birth range."
        },
        {
            "sample_id": 1966,
            "vt": "SELECT batsman_scored.ball_id, batsman_scored.runs_scored, batsman_scored.innings_no FROM batsman_scored WHERE batsman_scored.match_id = [placeholder-type:numeric] AND batsman_scored.over_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the runs scored by batsmen in a specific match and over. It includes the unique identifier for each ball, the number of runs scored, and the innings number. The placeholders represent the match ID and over ID for which the data is being queried."
        },
        {
            "sample_id": 1790,
            "vt": "SELECT match.match_id FROM \"match\" WHERE SUBSTRING(match.match_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique match identifier from the 'match' table based on a specific date range. The placeholders represent the start and end positions for extracting the date substring, as well as the specific date value to filter the matches."
        },
        {
            "sample_id": 1930,
            "vt": "SELECT player.player_name FROM player ORDER BY player.dob LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of players from the 'player' table, sorted by their date of birth. The placeholder in the LIMIT clause indicates the maximum number of player names to be retrieved."
        },
        {
            "sample_id": 1810,
            "vt": "SELECT player.player_name FROM player_match INNER JOIN Rolee AS T2 ON T1.Role_Id = T2.Role_Id INNER JOIN Player AS T3 ON T1.Player_Id = T3.Player_Id WHERE player_match.match_id = '[placeholder-type:string]' AND rolee.role_desc = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of players who participated in a specific match and held a particular role. The placeholders represent the match identifier and the role description, allowing users to filter results based on these criteria."
        },
        {
            "sample_id": 1880,
            "vt": "SELECT team.team_name FROM match INNER JOIN Team AS T2 ON T2.Team_Id = T1.Team_2 WHERE match.team_1 = (SELECT team.team_id FROM Team WHERE Team_Name = 'Pune Warriors') GROUP BY team.team_name",
            "ba": "The virtual table lists the names of teams that played against the 'Pune Warriors' in matches. It retrieves the team names from the 'match' table by joining it with the 'team' table, filtering for matches where 'Pune Warriors' was one of the teams, specifically as team 1. The results are grouped by team name to ensure unique entries."
        },
        {
            "sample_id": 1981,
            "vt": "SELECT extra_runs.match_id FROM extra_runs INNER JOIN Extra_Type AS T2 ON T1.Extra_Type_Id = T2.Extra_Id WHERE extra_type.extra_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the match IDs from the 'extra_runs' table where the extra type matches a specified name. It uses an inner join with the 'extra_type' table to filter results based on the extra type's name."
        },
        {
            "sample_id": 2016,
            "vt": "SELECT player.player_name FROM player INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Team AS T3 ON T2.Team_Id = T3.Team_Id WHERE team.team_id = [placeholder-type:numeric] GROUP BY player.player_name",
            "ba": "The virtual table describes the names of players from the 'player' table who are part of a specific team. The query joins the 'player' table with the 'player_match' table to associate players with their respective teams, and then filters the results based on the team ID provided as a placeholder. The results are grouped by player names to ensure uniqueness."
        },
        {
            "sample_id": 1921,
            "vt": "SELECT SUM(CASE WHEN win_by.win_type <> '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"match\" INNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id",
            "ba": "The virtual table calculates the total number of matches won by a specific type of win from the 'match' table, using a conditional sum based on the win type. The placeholders represent the win type and the numeric values for the sum calculation."
        },
        {
            "sample_id": 2002,
            "vt": "SELECT COUNT(player.player_name) FROM player WHERE player.dob LIKE '[placeholder-type:string]' AND player.bowling_skill = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of players from the 'player' table who were born on a specific date and have a certain bowling skill. The placeholders represent the date of birth and the bowling skill ID."
        },
        {
            "sample_id": 1879,
            "vt": "SELECT SUM(CASE WHEN team.team_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM match INNER JOIN Team AS T2 ON T2.Team_Id = T1.Match_Winner",
            "ba": "The virtual table calculates the total score based on a condition that checks if the team name matches a specified value. It sums up the scores from the 'match' table, joining it with the 'team' table to identify the winning team. The placeholders represent the team name and the numeric values for scoring."
        },
        {
            "sample_id": 1821,
            "vt": "SELECT SUM(CASE WHEN SUBSTRING(match.match_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"match\" WHERE SUBSTRING(match.match_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of matches played in a specific month and year by extracting the month from the match date. The placeholders represent the starting position and length for the substring operation to isolate the month from the date, as well as the specific month and year to filter the results."
        },
        {
            "sample_id": 1917,
            "vt": "SELECT season.season_year, season.orange_cap FROM player INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Match AS T3 ON T2.Match_Id = T3.Match_Id INNER JOIN Season AS T4 ON T3.Season_Id = T4.Season_Id WHERE player.player_name = '[placeholder-type:string]' GROUP BY season.season_year, season.orange_cap",
            "ba": "The virtual table provides a summary of the seasons in which a specific player has won the Orange Cap, which is awarded to the leading run-scorer in the Indian Premier League (IPL). It retrieves the season year and the player ID of the Orange Cap winner by joining the 'player', 'player_match', 'match', and 'season' tables. The placeholder in the WHERE clause represents the name of the player whose Orange Cap wins are being queried."
        },
        {
            "sample_id": 1845,
            "vt": "SELECT SUM(CASE WHEN outcome.outcome_type = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM match INNER JOIN Outcome AS T2 ON T2.Outcome_Id = T1.Outcome_type",
            "ba": "The virtual table calculates the total of a specific outcome type from the 'match' table, using a conditional sum based on the outcome type. The placeholders represent the outcome type and the numeric values to be summed based on the condition."
        },
        {
            "sample_id": 1891,
            "vt": "SELECT CAST(SUM(CASE WHEN [placeholder-type:numeric] < batsman_scored.over_id AND batsman_scored.over_id < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(batsman_scored.runs_scored) FROM batsman_scored WHERE batsman_scored.innings_no = [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average of runs scored by a batsman in a specific innings, based on the overs played. It sums the runs scored in a range of overs defined by placeholders and scales this sum by a specified factor, then divides it by the total runs scored in that innings."
        },
        {
            "sample_id": 1842,
            "vt": "SELECT country.country_name FROM venue INNER JOIN City AS T2 ON T2.City_Id = T1.City_Id INNER JOIN Country AS T3 ON T3.Country_Id = T2.Country_id WHERE venue.venue_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of countries from the 'country' table based on the venue's name. It joins the 'venue' table with the 'city' table to get the corresponding city information and then further joins with the 'country' table to filter by the specified venue name."
        },
        {
            "sample_id": 1882,
            "vt": "SELECT match.match_id FROM match INNER JOIN Venue AS T2 ON T2.Venue_Id = T1.Venue_Id WHERE venue.venue_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique match identifiers from the 'match' table, filtering the results based on a specific venue name. The placeholder in the WHERE clause represents the name of the venue."
        },
        {
            "sample_id": 1823,
            "vt": "SELECT SUM(CASE WHEN match.team_1 = [placeholder-type:numeric] OR match.team_2 = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"match\" WHERE SUBSTRING(match.match_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total runs scored by a specific team in matches held during a particular month and year. The placeholders represent the team ID, the numeric values for the runs, and the month and year for filtering the match date."
        },
        {
            "sample_id": 2035,
            "vt": "SELECT CAST(SUM(CASE WHEN match.win_type = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(match.win_type) FROM match INNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id",
            "ba": "The virtual table calculates the weighted average of winning margins for matches based on a specific winning type. It sums the winning margins for matches that meet the specified win type condition and divides this sum by the count of matches that have that win type, applying a scaling factor to the result."
        },
        {
            "sample_id": 1830,
            "vt": "SELECT match.season_id FROM \"match\" INNER JOIN Venue AS T2 ON T1.Venue_Id = T2.Venue_Id WHERE venue.venue_name = '[placeholder-type:string]' GROUP BY match.season_id ORDER BY COUNT(match.season_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique season IDs from the 'match' table, filtering the results based on a specific venue name. It groups the results by season ID and orders them by the count of matches played in each season, limiting the output to a specified number of results."
        },
        {
            "sample_id": 1837,
            "vt": "SELECT player.player_name FROM team INNER JOIN Player_Match AS T2 ON T1.Team_id = T2.Team_id INNER JOIN Rolee AS T3 ON T2.Role_Id = T3.Role_Id INNER JOIN Player AS T4 ON T2.Player_Id = T4.Player_Id WHERE team.team_name = '[placeholder-type:string]' AND team.team_id = [placeholder-type:numeric] AND rolee.role_desc = '[placeholder-type:string]' AND rolee.role_id = [placeholder-type:numeric] GROUP BY player.player_id ORDER BY COUNT(rolee.role_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players from a specific team who have a certain role in the match. The query filters players based on the team's name and ID, as well as the role's description and ID. It groups the results by player ID and orders them by the count of roles, limiting the output to a specified number of players."
        },
        {
            "sample_id": 2030,
            "vt": "SELECT COUNT(match.match_id) FROM match INNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id WHERE win_by.win_type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of matches from the 'match' table that have a specific winning type. It joins the 'match' table with the 'win_by' table to filter the results based on the winning type specified by the placeholder."
        },
        {
            "sample_id": 1839,
            "vt": "SELECT player.player_name FROM player WHERE player.dob = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of players from the 'player' table who were born on a specific date. The placeholder in the WHERE clause represents the player's date of birth."
        },
        {
            "sample_id": 1983,
            "vt": "SELECT CAST(COUNT(wicket_taken.player_out) AS FLOAT) / COUNT(wicket_taken.match_id), SUM(CASE WHEN out_type.out_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM wicket_taken INNER JOIN Out_Type AS T2 ON T1.Kind_Out = T2.Out_Id WHERE wicket_taken.innings_no = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of players out per match and the total runs scored from a specific type of out in a given innings. It joins the 'wicket_taken' table with the 'out_type' table to filter the out types based on a specified name, while also counting the total matches and summing the runs for that out type."
        },
        {
            "sample_id": 2023,
            "vt": "SELECT city.city_name FROM player INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_Id INNER JOIN City AS T3 ON T2.Country_Id = T3.Country_Id ORDER BY player.dob LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of cities where players are from, by joining the 'player' table with the 'country' and 'city' tables. The query filters the results based on the player's date of birth and limits the output to a specified number of records."
        },
        {
            "sample_id": 1886,
            "vt": "SELECT match.match_winner FROM venue INNER JOIN Match AS T2 ON T1.Venue_Id = T2.Venue_Id WHERE venue.venue_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table displays the match winners from the 'match' table, filtered by a specific venue name. The placeholder in the WHERE clause allows users to specify the venue they are interested in."
        },
        {
            "sample_id": 1841,
            "vt": "SELECT team.team_name FROM match INNER JOIN Team AS T2 ON T2.Team_Id = T1.Team_1 ORDER BY match.win_margin LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of teams that participated in matches, specifically focusing on the first team in each match. The results are ordered by the winning margin of the matches, allowing users to see which teams had the highest winning margins. The placeholder in the LIMIT clause indicates that users can specify how many team names they want to retrieve."
        },
        {
            "sample_id": 1933,
            "vt": "SELECT SUM(CASE WHEN batsman_scored.runs_scored > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM batsman_scored WHERE [placeholder-type:numeric] < batsman_scored.match_id < [placeholder-type:numeric] AND batsman_scored.innings_no = [placeholder-type:numeric] AND batsman_scored.over_id = [placeholder-type:numeric] AND batsman_scored.ball_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total runs scored by batsmen in a specific match, over, and ball, applying a conditional sum based on whether the runs scored exceed a certain threshold. The placeholders represent the threshold for runs, the match ID range, the innings number, the over ID, and the ball ID."
        }
    ],
    "computer_student": [
        {
            "sample_id": 1022,
            "vt": "SELECT taughtby.p_id FROM course INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id WHERE course.courselevel = '[placeholder-type:string]' GROUP BY taughtby.p_id ORDER BY COUNT(taughtby.p_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the identifiers of persons who teach courses at a specific level from the 'course' and 'taughtby' tables. It filters the courses based on the specified course level and groups the results by person ID, ordering them by the count of courses they teach, with a limit on the number of results returned."
        },
        {
            "sample_id": 992,
            "vt": "SELECT advisedby.p_id_dummy FROM advisedby INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE person.yearsinprogram = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the advisor IDs from the 'advisedby' table for persons who are in a specific year of their program. It uses an inner join with the 'person' table to filter based on the year of the program."
        },
        {
            "sample_id": 1013,
            "vt": "SELECT advisedby.p_id_dummy, person.hasposition FROM advisedby INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE person.yearsinprogram = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the advisors of individuals, specifically their advisor's ID and whether the advisor holds a position in the faculty. The data is retrieved by joining the 'advisedby' table with the 'person' table, filtering for individuals based on their year in the program."
        },
        {
            "sample_id": 1014,
            "vt": "SELECT course.course_id, taughtby.p_id FROM course INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id WHERE course.courselevel = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the course IDs and the IDs of the persons teaching those courses from the 'course' and 'taughtby' tables. It filters the results based on the specified course level, which is represented by a placeholder for string values, and limits the number of results returned using a placeholder for numeric values."
        },
        {
            "sample_id": 1023,
            "vt": "SELECT COUNT(advisedby.p_id_dummy) FROM advisedby INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE person.yearsinprogram = '[placeholder-type:string]' AND person.student = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of advisors for students in a specific year of their program. It joins the 'advisedby' table with the 'person' table to filter based on the year of the program and whether the person is a student."
        },
        {
            "sample_id": 1029,
            "vt": "SELECT person.yearsinprogram FROM advisedby INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE person.student = [placeholder-type:numeric] GROUP BY person.yearsinprogram ORDER BY COUNT(advisedby.p_id_dummy) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the years in the program for students who are advised by faculty members. It joins the 'advisedby' table with the 'person' table to filter out only those records where the person is a student. The results are grouped by the year in the program and ordered by the count of advisors, limiting the output to a specified number of results."
        },
        {
            "sample_id": 1005,
            "vt": "SELECT person.p_id, course.courselevel FROM person INNER JOIN taughtBy AS T2 ON T1.p_id = T2.p_id INNER JOIN course AS T3 ON T3.course_id = T2.course_id WHERE person.hasposition = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique identifiers of persons and their corresponding course levels from the 'person' and 'course' tables. It filters the results based on whether the person holds a position in the faculty, using a placeholder for the position status."
        },
        {
            "sample_id": 1011,
            "vt": "SELECT person.p_id, person.hasposition FROM person INNER JOIN taughtBy AS T2 ON T1.p_id = T2.p_id INNER JOIN course AS T3 ON T3.course_id = T2.course_id WHERE course.courselevel = '[placeholder-type:string]' AND taughtby.course_id < [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers and position status of individuals from the 'person' table who are associated with courses of a specific level and have a course ID less than a specified numeric value. The query joins the 'person' table with the 'taughtby' table to find out which individuals are teaching courses, and then further joins with the 'course' table to filter based on the course level and ID."
        },
        {
            "sample_id": 1027,
            "vt": "SELECT person.yearsinprogram FROM advisedby INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE person.student = [placeholder-type:numeric] GROUP BY person.p_id HAVING COUNT(person.p_id) > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the years in the program for students who are advised by faculty members. It joins the 'advisedby' table with the 'person' table to filter out only those records where the person is a student. The results are grouped by the person's ID, and only those students who have more than a specified number of advisors are included in the final output."
        },
        {
            "sample_id": 1015,
            "vt": "SELECT COUNT(*) FROM advisedby WHERE advisedby.p_id_dummy = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students advised by a specific advisor from the 'advisedby' table. The placeholder in the WHERE clause represents the unique identifier of the advisor."
        },
        {
            "sample_id": 1002,
            "vt": "SELECT CAST(SUM(CASE WHEN course.courselevel = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM course",
            "ba": "The virtual table calculates the weighted average of a specific course level from the 'course' table. It sums up the values based on whether the course level matches a specified level, applies a multiplier, and divides by the total count of courses to get the average. The placeholders represent the course level, numeric values for summation, and a numeric multiplier for the calculation."
        },
        {
            "sample_id": 1033,
            "vt": "SELECT COUNT(course.course_id) FROM course WHERE course.courselevel = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of courses from the 'course' table that belong to a specific course level. The placeholder in the WHERE clause represents the course level being queried."
        },
        {
            "sample_id": 993,
            "vt": "SELECT COUNT(DISTINCT T4.p_id) FROM person INNER JOIN taughtBy AS T2 ON T1.p_id = T2.p_id INNER JOIN course AS T3 ON T3.course_id = T2.course_id INNER JOIN advisedBy AS T4 ON T4.p_id = T1.p_id WHERE person.professor = [placeholder-type:numeric] AND course.courselevel = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct persons who are either professors or students, based on their role, and who are enrolled in courses of a specific level. The query joins multiple tables: 'person' to identify individuals, 'taughtby' to link persons to courses they teach, 'course' to filter by course level, and 'advisedby' to ensure the person is being advised. The placeholders represent the role of the person (professor or student) and the course level (e.g., Level_300, Level_400, Level_500)."
        },
        {
            "sample_id": 982,
            "vt": "SELECT course.course_id, course.courselevel FROM course INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id GROUP BY course.course_id, course.courselevel ORDER BY COUNT(course.course_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of course IDs and their corresponding levels from the 'course' table. It joins with the 'taughtby' table to associate courses with the individuals teaching them. The results are grouped by course ID and level, and ordered by the count of how many times each course is taught, limiting the output to a specified number of results."
        },
        {
            "sample_id": 973,
            "vt": "SELECT taughtby.course_id FROM advisedby INNER JOIN person AS T2 ON T1.p_id = T2.p_id INNER JOIN taughtBy AS T3 ON T2.p_id = T3.p_id WHERE advisedby.p_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the course IDs from the 'taughtby' table for a specific person identified by their ID in the 'advisedby' table. It uses inner joins to connect the 'advisedby' table with the 'person' table to get the advisor's details and then links to the 'taughtby' table to find the courses taught by that person."
        },
        {
            "sample_id": 1018,
            "vt": "SELECT taughtby.p_id FROM taughtby GROUP BY taughtby.p_id ORDER BY COUNT(taughtby.course_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of persons from the 'taughtby' table, grouping them by their ID and ordering the results based on the number of courses they are associated with. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 998,
            "vt": "SELECT taughtby.p_id FROM taughtby INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE person.professor = [placeholder-type:numeric] GROUP BY taughtby.p_id ORDER BY COUNT(*) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the IDs of individuals from the 'taughtby' table who are associated with courses they teach. It joins the 'taughtby' table with the 'person' table to filter based on whether the individual is a professor. The results are grouped by the person ID and ordered by the count of courses they teach, with a limit on the number of results returned."
        },
        {
            "sample_id": 984,
            "vt": "SELECT COUNT(*) FROM taughtby WHERE taughtby.course_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of entries in the 'taughtby' table for a specific course identified by its course ID. The placeholder in the WHERE clause represents the course ID for which the count of instructors or professors is being queried."
        },
        {
            "sample_id": 1028,
            "vt": "SELECT COUNT(*) FROM course INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id WHERE course.courselevel = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of courses from the 'course' table that match a specific course level. It uses an inner join with the 'taughtby' table to link courses with the individuals teaching them. The placeholder in the WHERE clause represents the course level being queried."
        },
        {
            "sample_id": 1025,
            "vt": "SELECT COUNT(*) FROM person INNER JOIN taughtBy AS T2 ON T1.p_id = T2.p_id INNER JOIN course AS T3 ON T3.course_id = T2.course_id WHERE person.hasposition = '[placeholder-type:string]' AND person.professor = [placeholder-type:numeric] AND course.courselevel = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of persons who are either professors or students, based on their position in the faculty, and filters the results by the course level they are associated with."
        },
        {
            "sample_id": 970,
            "vt": "SELECT COUNT(course.course_id) FROM course WHERE course.courselevel = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of courses from the 'course' table that belong to a specific course level. The placeholder in the WHERE clause represents the course level being queried."
        },
        {
            "sample_id": 994,
            "vt": "SELECT COUNT(*) FROM course INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id INNER JOIN person AS T3 ON T2.p_id = T3.p_id WHERE person.professor = [placeholder-type:numeric] AND course.courselevel = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of courses taught by professors at a specific course level. It joins the 'course' table with the 'taughtby' table to link courses with the individuals teaching them, and then further joins with the 'person' table to filter based on whether the individual is a professor. The placeholders represent the professor status and the course level being queried."
        },
        {
            "sample_id": 985,
            "vt": "SELECT taughtby.course_id FROM taughtby WHERE taughtby.course_id = [placeholder-type:numeric] OR taughtby.course_id = [placeholder-type:numeric] GROUP BY taughtby.course_id ORDER BY COUNT(taughtby.course_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves course IDs from the 'taughtby' table, filtering for specific course IDs and grouping the results. It orders the grouped results by the count of occurrences of each course ID and limits the output to a specified number of results."
        },
        {
            "sample_id": 991,
            "vt": "SELECT course.courselevel FROM course INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id WHERE taughtby.p_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the course level of courses taught by a specific person identified by their ID. The query joins the 'course' table with the 'taughtby' table to filter the results based on the person's ID, represented by a numeric placeholder."
        },
        {
            "sample_id": 1034,
            "vt": "SELECT COUNT(*) FROM person WHERE person.yearsinprogram = '[placeholder-type:string]' OR person.yearsinprogram = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of persons from the 'person' table who are in specific years of their program. The placeholders represent the years being queried."
        },
        {
            "sample_id": 987,
            "vt": "SELECT advisedby.p_id_dummy FROM advisedby GROUP BY advisedby.p_id_dummy HAVING COUNT(advisedby.p_id_dummy) > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of advisors from the 'advisedby' table, grouping them by their ID. It filters the results to include only those advisors who have advised more than a specified number of students, represented by a placeholder for numeric values."
        },
        {
            "sample_id": 1035,
            "vt": "SELECT COUNT(*) FROM person INNER JOIN taughtBy AS T2 ON T1.p_id = T2.p_id WHERE person.professor = [placeholder-type:numeric] AND person.hasposition <> [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of persons from the 'person' table who are professors and do not hold a position in the faculty. It uses an inner join with the 'taughtby' table to link persons to the courses they teach, filtering based on the professor status and position held."
        },
        {
            "sample_id": 1008,
            "vt": "SELECT course.course_id, course.courselevel FROM course INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id WHERE taughtby.p_id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table describes the course IDs and their corresponding levels from the 'course' table for courses taught by a range of professors identified by their IDs. The placeholders in the WHERE clause represent the numeric range of professor IDs."
        },
        {
            "sample_id": 1009,
            "vt": "SELECT course.courselevel, course.course_id FROM course INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id WHERE taughtby.p_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the course levels and IDs of courses taught by a specific person from the 'course' table. The placeholder in the WHERE clause represents the unique identifier of the person teaching the course."
        },
        {
            "sample_id": 1024,
            "vt": "SELECT COUNT(*) FROM (SELECT COUNT(taughtby.p_id) FROM course AS T1 INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id WHERE T1.courseLevel = 'Level_400' GROUP BY T2.p_id HAVING COUNT(DISTINCT T1.course_id) <= 2)",
            "ba": "The virtual table counts the number of professors who are teaching at most two Level 400 courses. It does this by first joining the 'course' and 'taughtby' tables to filter for Level 400 courses, then grouping the results by professor ID and counting the distinct courses taught by each professor. Finally, it counts how many professors meet the criteria of teaching two or fewer Level 400 courses."
        },
        {
            "sample_id": 1007,
            "vt": "SELECT advisedby.p_id, person.p_id FROM advisedby INNER JOIN person AS T2 ON T1.p_id_dummy = T2.p_id WHERE person.hasposition = '[placeholder-type:string]'",
            "ba": "The virtual table describes the relationship between persons and their advisors from the 'advisedby' table, filtering for those who have a specific position in the faculty. The placeholders represent the position status of the persons."
        },
        {
            "sample_id": 974,
            "vt": "SELECT advisedby.p_id FROM advisedby INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE person.yearsinprogram = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the IDs of persons who are being advised, by joining the 'advisedby' table with the 'person' table. It filters the results based on the year of the program that the person is currently in, using a placeholder for the specific year."
        },
        {
            "sample_id": 995,
            "vt": "SELECT course.course_id FROM taughtby INNER JOIN course AS T2 ON T1.course_id = T2.course_id INNER JOIN advisedBy AS T3 ON T3.p_id = T1.p_id WHERE taughtby.p_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique course identifiers from the 'course' table for courses taught by a specific person. It uses joins to connect the 'taughtby' table, which links courses to instructors, with the 'course' table to get course details, and the 'advisedby' table to ensure the correct person is identified as the instructor."
        },
        {
            "sample_id": 988,
            "vt": "SELECT COUNT(*) FROM course INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id INNER JOIN person AS T3 ON T3.p_id = T2.p_id WHERE course.courselevel = '[placeholder-type:string]' AND person.professor = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of individuals associated with courses of a specific level who are professors. It combines data from the 'course', 'taughtby', and 'person' tables to filter based on the course level and the role of the person as a professor."
        },
        {
            "sample_id": 1021,
            "vt": "SELECT COUNT(*) FROM person INNER JOIN taughtBy AS T2 ON T1.p_id = T2.p_id INNER JOIN course AS T3 ON T3.course_id = T2.course_id WHERE person.hasposition = '[placeholder-type:string]' AND person.professor = [placeholder-type:numeric] AND course.courselevel = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of persons who are either professors or students, based on their position in the faculty, and filters the results by the course level they are associated with. The placeholders represent the specific values for the person's position, whether they are a professor or student, and the course level."
        },
        {
            "sample_id": 1020,
            "vt": "SELECT taughtby.p_id FROM course INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id WHERE course.courselevel = '[placeholder-type:string]' GROUP BY taughtby.p_id ORDER BY COUNT(taughtby.course_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the identifiers of persons who teach courses at a specific level from the 'course' and 'taughtby' tables. It filters the courses based on the specified course level and groups the results by person ID, ordering them by the count of courses they teach, with a limit on the number of results returned."
        },
        {
            "sample_id": 1012,
            "vt": "SELECT taughtby.p_id FROM course INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id WHERE course.courselevel = '[placeholder-type:string]' AND course.course_id > [placeholder-type:numeric] AND course.course_id < [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the identifiers of persons who are teaching courses from the 'course' table, filtered by specific course levels and a range of course IDs. The placeholders allow for dynamic input of the course level and the numeric range for course IDs."
        },
        {
            "sample_id": 978,
            "vt": "SELECT course.course_id, course.courselevel FROM taughtby INNER JOIN person AS T2 ON T1.p_id = T2.p_id INNER JOIN course AS T3 ON T3.course_id = T1.course_id WHERE person.hasposition = '[placeholder-type:string]'",
            "ba": "The virtual table describes the course IDs and their corresponding levels from the 'course' table for individuals who have a specific position in the faculty. The query uses inner joins to connect the 'taughtby' table with the 'person' table to filter based on the position of the person, using a placeholder for the position value."
        },
        {
            "sample_id": 1000,
            "vt": "SELECT CAST(COUNT(taughtby.course_id) AS FLOAT) / COUNT(DISTINCT T2.p_id) FROM taughtby INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE person.professor = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of courses taught by professors from the 'taughtby' table. It counts the total number of courses taught and divides it by the number of distinct professors, filtering the results based on whether the person is a professor using a placeholder for numeric values."
        },
        {
            "sample_id": 1017,
            "vt": "SELECT COUNT(*) FROM person WHERE person.hasposition = [placeholder-type:numeric] AND person.inphase = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of persons from the 'person' table who have a specific position and are undergoing a certain phase of qualification. The placeholders represent the values for the position and phase of qualification."
        },
        {
            "sample_id": 1032,
            "vt": "SELECT COUNT(*) FROM (SELECT COUNT(taughtby.course_id) FROM taughtBy GROUP BY course_id HAVING COUNT(course_id) > 4)",
            "ba": "The virtual table counts the number of courses that have more than four instructors assigned to them. It does this by first grouping the records in the 'taughtby' table by 'course_id' and counting the number of instructors for each course. Then, it filters these groups to only include those with a count greater than four, and finally counts how many such groups exist."
        },
        {
            "sample_id": 980,
            "vt": "SELECT DISTINCT taughtby.p_id FROM course INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id WHERE course.courselevel = '[placeholder-type:string]' OR course.courselevel = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct identifiers of individuals who are associated with courses at specific levels from the 'course' and 'taughtby' tables. The placeholders in the WHERE clause represent the course levels being queried, allowing for flexibility in specifying either one or two course levels."
        },
        {
            "sample_id": 1030,
            "vt": "SELECT COUNT(advisedby.p_id_dummy) FROM advisedby INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE person.inphase = '[placeholder-type:string]' AND person.student = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of advisors for students who are undergoing a specific phase of qualification. It joins the 'advisedby' table with the 'person' table to filter based on the qualification phase and whether the person is a student."
        }
    ],
    "genes": [
        {
            "sample_id": 2511,
            "vt": "SELECT CAST(COUNT(genes.geneid) AS FLOAT) * [placeholder-type:numeric] / (SELECT COUNT(genes.geneid) FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE T2.Expression_Corr < 0) FROM genes INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE interactions.expression_corr < [placeholder-type:numeric] AND genes.essential = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of essential genes that have a negative expression correlation with other genes, based on a specified threshold. It counts the number of essential genes with a negative correlation and divides it by the total number of genes with a negative correlation, then multiplies by a placeholder numeric value to adjust the result."
        },
        {
            "sample_id": 2496,
            "vt": "SELECT interactions.expression_corr FROM genes INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE genes.chromosome = [placeholder-type:numeric] OR genes.chromosome = [placeholder-type:numeric] ORDER BY interactions.expression_corr LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the expression correlation scores between genes from the 'interactions' table, filtered by specific chromosome values from the 'genes' table. The results are ordered by the correlation scores and limited to a specified number of entries."
        },
        {
            "sample_id": 2492,
            "vt": "SELECT classification.localization FROM genes INNER JOIN Classification AS T2 ON T1.GeneID = T2.GeneID ORDER BY genes.chromosome LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the localization information of genes from the 'classification' table by joining it with the 'genes' table. The results are ordered by the chromosome of the genes, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 2500,
            "vt": "SELECT CAST(SUM(CASE WHEN genes.chromosome > [placeholder-type:numeric] AND genes.chromosome > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(genes.geneid) FROM genes INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 INNER JOIN Genes AS T3 ON T3.GeneID = T2.GeneID2 WHERE interactions.expression_corr > [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average based on the chromosome values of genes, filtering interactions based on a specified expression correlation score. It joins the 'genes' table with the 'interactions' table to assess relationships between gene pairs, applying conditions to sum values and count gene occurrences."
        },
        {
            "sample_id": 2489,
            "vt": "SELECT genes.chromosome FROM genes INNER JOIN Classification AS T2 ON T1.GeneID = T2.GeneID WHERE classification.localization = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the chromosome information of genes from the 'genes' table that are associated with a specific localization in the 'classification' table. The placeholder in the WHERE clause represents the localization criteria to filter the results."
        },
        {
            "sample_id": 2503,
            "vt": "SELECT COUNT(classification.geneid) FROM classification WHERE classification.localization IN ('[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table counts the number of unique gene identifiers from the 'classification' table where the localization matches specific values. The placeholders represent the locations to filter the results."
        },
        {
            "sample_id": 2497,
            "vt": "SELECT interactions.geneid1, interactions.geneid2 FROM genes INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE genes.localization = '[placeholder-type:string]' AND genes.chromosome = [placeholder-type:numeric]",
            "ba": "The virtual table describes the gene interactions between two genes based on their localization and chromosome. It retrieves the identifiers of the interacting genes from the 'interactions' table, while filtering the 'genes' table for a specific localization and chromosome number."
        },
        {
            "sample_id": 2505,
            "vt": "SELECT SUM(genes.localization = '[placeholder-type:string]' AND genes.phenotype = '[placeholder-type:string]'), CAST(SUM(genes.localization = '[placeholder-type:string]') AS FLOAT) * [placeholder-type:numeric] / COUNT(genes.geneid) FROM genes",
            "ba": "The virtual table calculates the sum of genes that match a specific localization and phenotype from the 'genes' table. It also computes a weighted average of the localization matches based on a numeric placeholder, providing insights into the distribution of gene localizations in relation to their phenotypes."
        },
        {
            "sample_id": 2508,
            "vt": "SELECT interactions.geneid1 FROM genes INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE genes.localization = '[placeholder-type:string]' AND genes.class = '[placeholder-type:string]' AND genes.essential = '[placeholder-type:string]' AND interactions.expression_corr <> [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the identifiers of genes that interact with other genes based on specific criteria. It filters genes by their localization, class, and essential status, while also excluding those interactions that have a certain expression correlation score."
        },
        {
            "sample_id": 2498,
            "vt": "SELECT COUNT(genes.geneid) FROM genes INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE genes.localization <> '[placeholder-type:string]' AND genes.function = '[placeholder-type:string]' AND genes.essential = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of genes from the 'genes' table that meet specific criteria. It filters out genes based on their localization, function, and essential status. The query joins the 'genes' table with the 'interactions' table to ensure that only genes involved in interactions are considered."
        },
        {
            "sample_id": 2504,
            "vt": "SELECT Expression_Corr FROM Interactions WHERE Type = 'Physical' UNION ALL SELECT CAST(SUM(Expression_Corr < 0) AS FLOAT) * 100 / COUNT(*) FROM Interactions WHERE Type = 'Physical'",
            "ba": "The virtual table provides the expression correlation scores of gene interactions classified as 'Physical'. It also calculates the percentage of negatively correlated interactions among these physical interactions, giving insights into the overall relationship dynamics between genes."
        },
        {
            "sample_id": 2501,
            "vt": "SELECT AVG(interactions.expression_corr) FROM genes INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE genes.class = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average expression correlation score of gene interactions from the 'genes' and 'interactions' tables. It filters the results based on a specific class of genes, represented by a placeholder in the WHERE clause."
        },
        {
            "sample_id": 2494,
            "vt": "SELECT genes.function FROM genes INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 ORDER BY interactions.expression_corr LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the functions of genes from the 'genes' table that are involved in interactions with other genes. It joins the 'genes' table with the 'interactions' table based on the gene identifiers, filtering for those interactions where the first gene is linked to the second gene. The results are ordered by the expression correlation score, and a limit is applied to restrict the number of returned records."
        }
    ],
    "talkingdata": [
        {
            "sample_id": 1100,
            "vt": "SELECT AVG(gender_age.age) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE phone_brand_device_model2.phone_brand = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average age of users based on their device's phone brand. It joins the 'gender_age' table, which contains user age information, with the 'phone_brand_device_model2' table, which includes details about the device's brand. The query filters the results to include only those devices that match a specific phone brand, represented by a placeholder."
        },
        {
            "sample_id": 1210,
            "vt": "SELECT COUNT(gender_age.device_id) FROM gender_age INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id INNER JOIN app_events_relevant AS T3 ON T2.event_id = T3.event_id WHERE gender_age.age < [placeholder-type:numeric] AND gender_age.gender = '[placeholder-type:string]' AND app_events_relevant.is_active = [placeholder-type:numeric] AND app_events_relevant.is_installed = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of devices from the 'gender_age' table that meet specific criteria. It filters devices based on age, gender, and the installation and activity status of the app events relevant to those devices."
        },
        {
            "sample_id": 1082,
            "vt": "SELECT gender_age.age FROM phone_brand_device_model2 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE phone_brand_device_model2.device_model = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the age of users based on their device model from the 'phone_brand_device_model2' and 'gender_age' tables. It uses an inner join to connect these tables through the 'device_id', ensuring that only relevant records are selected. The placeholder in the WHERE clause allows for filtering by a specific device model."
        },
        {
            "sample_id": 1170,
            "vt": "SELECT app_labels.label_id, label_categories.category FROM app_labels INNER JOIN label_categories AS T2 ON T1.label_id = T2.label_id WHERE app_labels.app_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the label IDs and their corresponding categories from the 'app_labels' and 'label_categories' tables. It retrieves this information by joining the two tables on the label ID, filtering the results based on a specific app ID provided as a placeholder."
        },
        {
            "sample_id": 1132,
            "vt": "SELECT label_categories.category FROM label_categories INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id WHERE app_labels.app_id = '[placeholder-type:string]'",
            "ba": "The virtual table describes the categories of labels associated with a specific app from the 'label_categories' table. It retrieves the category information by joining the 'label_categories' table with the 'app_labels' table based on the label_id, filtering the results for a specific app_id using a placeholder."
        },
        {
            "sample_id": 1166,
            "vt": "SELECT COUNT(events.event_id) FROM events WHERE events.longitude = -[placeholder-type:numeric]",
            "ba": "The virtual table counts the number of events recorded in the 'events' table that have a specific longitude value. The placeholder in the WHERE clause represents the longitude coordinate for which the event count is being queried."
        },
        {
            "sample_id": 1204,
            "vt": "SELECT COUNT(app_labels.app_id) FROM app_labels WHERE app_labels.label_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of app users associated with a specific label from the 'app_labels' table. The placeholder in the WHERE clause represents the label's unique identifier."
        },
        {
            "sample_id": 1192,
            "vt": "SELECT gender_age.\"group\" FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE phone_brand_device_model2.phone_brand = '[placeholder-type:string]'",
            "ba": "The virtual table describes the age group of users based on their device's gender and age information from the 'gender_age' table, filtered by the specific phone brand from the 'phone_brand_device_model2' table. The placeholder in the WHERE clause represents the phone brand name."
        },
        {
            "sample_id": 1164,
            "vt": "SELECT COUNT(events.event_id) FROM events WHERE events.device_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of events recorded in the 'events' table for a specific device identified by its device_id. The placeholder in the WHERE clause represents the unique identifier for the device."
        },
        {
            "sample_id": 1154,
            "vt": "SELECT events.event_id FROM gender_age INNER JOIN events AS T2 ON T1.device_id = T2.device_id ORDER BY gender_age.age LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique event IDs from the 'events' table, which are associated with devices that have gender and age information. It performs an inner join between the 'gender_age' table and the 'events' table based on the device ID, ensuring that only events linked to specific devices are selected. The results are ordered by the age of the users and limited to a specified number of entries."
        },
        {
            "sample_id": 1140,
            "vt": "SELECT MIN(gender_age.age) FROM gender_age WHERE gender_age.gender = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the minimum age of users from the 'gender_age' table, filtered by a specific gender. The placeholder in the WHERE clause represents the gender of the users, allowing for dynamic querying based on user input."
        },
        {
            "sample_id": 1169,
            "vt": "SELECT COUNT(events.event_id) FROM events WHERE events.longitude = [placeholder-type:numeric] AND events.latitude = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of events recorded in the 'events' table that match specific geographical coordinates defined by longitude and latitude. The placeholders represent the longitude and latitude values that can be specified by the user."
        },
        {
            "sample_id": 1050,
            "vt": "SELECT gender_age.age FROM app_events INNER JOIN events_relevant AS T2 ON T1.event_id = T2.event_id INNER JOIN gender_age AS T3 ON T2.device_id = T3.device_id WHERE app_events.is_active = [placeholder-type:numeric] AND events_relevant.longitude = [placeholder-type:numeric] AND events_relevant.latitude = [placeholder-type:numeric] AND SUBSTRING(events_relevant.timestamp, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' ORDER BY gender_age.age LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the ages of users based on specific event data from the 'app_events' and 'events_relevant' tables, while also considering the user's activity status and geographical location. The query filters results by checking if the app is active, the longitude and latitude of the event, and a substring of the timestamp. The results are ordered by age and limited to a specified number of entries."
        },
        {
            "sample_id": 1242,
            "vt": "SELECT phone_brand_device_model2.phone_brand, phone_brand_device_model2.device_model FROM phone_brand_device_model2 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id WHERE events_relevant.timestamp = '[placeholder-type:string]'",
            "ba": "The virtual table describes the phone brand and device model from the 'phone_brand_device_model2' table, filtered by a specific timestamp from the 'events_relevant' table. The placeholder in the WHERE clause represents the event's timestamp."
        },
        {
            "sample_id": 1214,
            "vt": "SELECT gender_age.device_id FROM gender_age INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id WHERE gender_age.gender = '[placeholder-type:string]' AND gender_age.age < [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the device IDs from the 'gender_age' table for users who meet specific criteria regarding their gender and age. It joins with the 'events_relevant' table to ensure that the device IDs correspond to relevant events."
        },
        {
            "sample_id": 1155,
            "vt": "SELECT COUNT(events.event_id) FROM events INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id WHERE gender_age.gender = '[placeholder-type:string]' GROUP BY events.event_id, gender_age.age ORDER BY gender_age.age LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of events from the 'events' table, joining it with the 'gender_age' table to filter by gender. It groups the results by event ID and age, ordering them by age, and limits the output to a specified number of results."
        },
        {
            "sample_id": 1103,
            "vt": "SELECT COUNT(app_events.app_id) FROM app_events WHERE app_events.is_installed = [placeholder-type:numeric] AND app_events.is_active = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of app users from the 'app_events' table based on their installation and activity status. The placeholders represent whether the app is installed and whether the user is active."
        },
        {
            "sample_id": 1218,
            "vt": "SELECT events.event_id FROM events WHERE events.longitude = [placeholder-type:numeric] AND events.latitude = [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique event IDs from the 'events' table based on specific geographical coordinates (longitude and latitude). The placeholders allow users to specify the desired longitude, latitude, and limit for the number of results returned."
        },
        {
            "sample_id": 1041,
            "vt": "SELECT COUNT(gender_age.gender) FROM gender_age WHERE gender_age.gender = '[placeholder-type:string]' AND gender_age.\"group\" = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users from the 'gender_age' table based on their gender and age group. The placeholders represent the specific gender and age group criteria for filtering the results."
        },
        {
            "sample_id": 1238,
            "vt": "SELECT COUNT(events.event_id) FROM events WHERE events.device_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of events recorded in the 'events' table for a specific device identified by its device_id. The placeholder in the WHERE clause represents the unique identifier for the device."
        },
        {
            "sample_id": 1046,
            "vt": "SELECT phone_brand_device_model2.device_model FROM phone_brand_device_model2 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id ORDER BY gender_age.age LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the device models from the 'phone_brand_device_model2' table, joining it with the 'gender_age' table to filter based on device IDs. The results are ordered by the age of the users associated with those devices, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 1119,
            "vt": "SELECT phone_brand_device_model2.phone_brand FROM phone_brand_device_model2 WHERE phone_brand_device_model2.device_model = '[placeholder-type:string]'",
            "ba": "The virtual table describes the phone brands associated with a specific device model from the 'phone_brand_device_model2' table. The placeholder in the WHERE clause represents the device model being queried."
        },
        {
            "sample_id": 1042,
            "vt": "SELECT COUNT(gender_age.gender) FROM gender_age WHERE gender_age.age > [placeholder-type:numeric] AND gender_age.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users of a specific gender who are above a certain age from the 'gender_age' table. The placeholders represent the age threshold and the gender to filter the results accordingly."
        },
        {
            "sample_id": 1235,
            "vt": "SELECT SUM(CASE WHEN gender_age.\"group\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) / COUNT(gender_age.device_id) FROM gender_age INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id WHERE SUBSTRING(events_relevant.timestamp, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average of a specific age group from the 'gender_age' table by summing up the values based on a condition and dividing it by the count of devices. It joins with the 'events_relevant' table to filter events based on a specific timestamp range. The placeholders represent the age group, numeric values for summation, and the timestamp range for filtering."
        },
        {
            "sample_id": 1044,
            "vt": "SELECT gender_age.gender FROM gender_age WHERE gender_age.age = (SELECT MIN(gender_age.age) FROM gender_age)",
            "ba": "The virtual table retrieves the gender of the user who is the youngest among all users in the 'gender_age' table. It does this by selecting the 'gender' column where the 'age' matches the minimum age found in the same table."
        },
        {
            "sample_id": 1123,
            "vt": "SELECT COUNT(events.event_id) FROM events WHERE SUBSTRING(events.\"timestamp\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of events from the 'events' table that occur within a specific time range. The placeholders represent the starting and ending positions for extracting the relevant part of the timestamp, and the specific value to match against."
        },
        {
            "sample_id": 1185,
            "vt": "SELECT gender_age.gender FROM gender_age WHERE gender_age.device_id = -[placeholder-type:numeric]",
            "ba": "The virtual table retrieves the gender of a user based on their device ID from the 'gender_age' table. The placeholder in the WHERE clause represents the specific device ID for which the gender information is being queried."
        },
        {
            "sample_id": 1134,
            "vt": "SELECT SUM(CASE WHEN events.timestamp = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) / SUM(CASE WHEN events.timestamp = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM events INNER JOIN app_events AS T2 ON T1.event_id = T2.event_id WHERE app_events.is_active = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the ratio of two sums based on event timestamps from the 'events' table and filters the results based on the active status of the app events. The placeholders represent specific timestamp values and numeric values for the calculations, as well as the active status of the app events."
        },
        {
            "sample_id": 1122,
            "vt": "SELECT events.timestamp FROM events WHERE events.event_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the timestamp of a specific event from the 'events' table based on the event's unique identifier. The placeholder in the WHERE clause represents the event ID that the user is interested in."
        },
        {
            "sample_id": 1127,
            "vt": "SELECT COUNT(gender_age.device_id) FROM app_events INNER JOIN events AS T2 ON T1.event_id = T2.event_id INNER JOIN gender_age AS T3 ON T2.device_id = T3.device_id WHERE SUBSTRING(events.\"timestamp\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND app_events.is_active = [placeholder-type:numeric] AND gender_age.age = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of unique devices from the 'gender_age' table that are associated with active app events. It filters the results based on a specific substring of the event timestamp and the age of the users, while also ensuring that only active events are considered."
        },
        {
            "sample_id": 1205,
            "vt": "SELECT gender_age_train.device_id FROM gender_age_train WHERE gender_age_train.age BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND gender_age_train.gender = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the device IDs from the 'gender_age_train' table for users whose age falls within a specified range and who belong to a specific gender category. The placeholders represent the age range and gender to filter the results accordingly."
        },
        {
            "sample_id": 1208,
            "vt": "SELECT (SELECT T1.phone_brand, COUNT(T4.is_active) AS num FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id INNER JOIN events_relevant AS T3 ON T2.device_id = T3.device_id INNER JOIN app_events_relevant AS T4 ON T3.event_id = T4.event_id WHERE T4.is_active = 1 GROUP BY T1.phone_brand).phone_brand FROM (SELECT phone_brand_device_model2.phone_brand, COUNT(app_events_relevant.is_active) FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id INNER JOIN events_relevant AS T3 ON T2.device_id = T3.device_id INNER JOIN app_events_relevant AS T4 ON T3.event_id = T4.event_id WHERE T4.is_active = 1 GROUP BY T1.phone_brand) AS t ORDER BY (SELECT T1.phone_brand, COUNT(T4.is_active) AS num FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id INNER JOIN events_relevant AS T3 ON T2.device_id = T3.device_id INNER JOIN app_events_relevant AS T4 ON T3.event_id = T4.event_id WHERE T4.is_active = 1 GROUP BY T1.phone_brand).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the number of active users grouped by their phone brand from the relevant app events. It counts the active events for each phone brand and orders them accordingly, allowing for a limit on the number of results returned."
        },
        {
            "sample_id": 1052,
            "vt": "SELECT label_categories.category FROM events_relevant INNER JOIN app_events_relevant AS T2 ON T1.event_id = T2.event_id INNER JOIN app_labels AS T3 ON T3.app_id = T2.app_id INNER JOIN label_categories AS T4 ON T3.label_id = T4.label_id ORDER BY events_relevant.timestamp LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the categories of labels associated with events that are relevant to specific applications. It joins multiple tables: 'events_relevant' to get event details, 'app_events_relevant' to link events to applications, 'app_labels' to find the labels for those applications, and 'label_categories' to get the corresponding categories of those labels. The results are ordered by the timestamp of the events and limited to a specified number of entries."
        },
        {
            "sample_id": 1086,
            "vt": "SELECT label_categories.category FROM label_categories INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id WHERE app_labels.app_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the categories of labels associated with a specific app identified by its app_id. It retrieves the category from the label_categories table by joining it with the app_labels table based on the label_id, filtering the results to include only those that match the specified app_id."
        },
        {
            "sample_id": 1056,
            "vt": "SELECT SUM(CASE WHEN gender_age.gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) * [placeholder-type:numeric] / COUNT(gender_age.device_id), SUM(CASE WHEN gender_age.gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) * [placeholder-type:numeric] / COUNT(gender_age.device_id) FROM phone_brand_device_model2 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE phone_brand_device_model2.phone_brand = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of two numeric values based on the gender of users associated with specific devices. It aggregates data from the 'phone_brand_device_model2' and 'gender_age' tables, filtering results by a specified phone brand. The placeholders represent the gender, numeric values for calculations, and the phone brand to filter the results."
        },
        {
            "sample_id": 1117,
            "vt": "SELECT SUM(CASE WHEN label_categories.category = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) / COUNT(label_categories.label_id), SUM(CASE WHEN label_categories.category = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) / COUNT(label_categories.label_id) FROM label_categories INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id",
            "ba": "The virtual table calculates the average of two conditional sums based on the category of labels from the 'label_categories' table. It uses a CASE statement to differentiate between two categories, summing their respective numeric values and dividing by the count of label IDs. The query joins the 'label_categories' table with the 'app_labels' table to filter the results based on the relevant labels."
        },
        {
            "sample_id": 1054,
            "vt": "SELECT (SELECT T2.category, COUNT(T1.app_id) AS num FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T2.label_id = T1.label_id GROUP BY T1.app_id, T2.category).category FROM (SELECT label_categories.category, COUNT(app_labels.app_id) FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T2.label_id = T1.label_id GROUP BY T1.app_id, T2.category) AS t ORDER BY (SELECT T2.category, COUNT(T1.app_id) AS num FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T2.label_id = T1.label_id GROUP BY T1.app_id, T2.category).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the count of app users categorized by their behavior labels. It retrieves the category of labels and the number of app users associated with each category. The query uses subqueries to join the 'app_labels' and 'label_categories' tables, grouping by app_id and category to count the occurrences. The final result is ordered by the count of users in each category, with a limit on the number of results returned, specified by a numeric placeholder."
        },
        {
            "sample_id": 1199,
            "vt": "SELECT COUNT(gender_age.device_id) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE gender_age.age BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND phone_brand_device_model2.phone_brand = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of devices from the 'gender_age' table that fall within a specified age range and are associated with a specific phone brand. The placeholders represent the age range and the phone brand name."
        },
        {
            "sample_id": 1115,
            "vt": "SELECT (SELECT T1.\"group\", COUNT(T1.\"group\") AS num FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'OPPO' GROUP BY T1.\"group\").\"group\" FROM (SELECT gender_age.\"group\", COUNT(gender_age.\"group\") FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'OPPO' GROUP BY T1.\"group\") AS t ORDER BY (SELECT T1.\"group\", COUNT(T1.\"group\") AS num FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'OPPO' GROUP BY T1.\"group\").num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the distribution of age groups among users of the OPPO phone brand by counting the number of users in each age group. It retrieves the age group and the corresponding count of users, ordering the results based on the count of users in each group. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 1237,
            "vt": "SELECT (SELECT \"group\", COUNT(\"group\") AS num FROM gender_age GROUP BY \"group\").num FROM (SELECT gender_age.\"group\", COUNT(gender_age.\"group\") FROM gender_age GROUP BY \"group\") AS t",
            "ba": "The virtual table summarizes the count of users grouped by age categories from the 'gender_age' table. It retrieves the number of users in each age group, providing insights into the distribution of users across different age demographics."
        },
        {
            "sample_id": 1083,
            "vt": "SELECT phone_brand_device_model2.device_model FROM phone_brand_device_model2 WHERE gender_age.device_id IN (SELECT gender_age.device_id FROM gender_age WHERE age = (SELECT MAX(age) FROM gender_age))",
            "ba": "The virtual table retrieves the device model from the 'phone_brand_device_model2' table for the device(s) associated with the oldest user(s) based on age. It uses a subquery to first find the maximum age from the 'gender_age' table, and then filters the device IDs that correspond to this maximum age."
        },
        {
            "sample_id": 1136,
            "vt": "SELECT SUM(CASE WHEN phone_brand_device_model2.phone_brand = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN phone_brand_device_model2.phone_brand = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM phone_brand_device_model2",
            "ba": "The virtual table calculates the difference between two sums based on the phone brand from the 'phone_brand_device_model2' table. It uses conditional aggregation to sum values for a specific phone brand and subtracts another sum for potentially different conditions, represented by placeholders for string and numeric values."
        },
        {
            "sample_id": 1057,
            "vt": "SELECT events.longitude, events.latitude FROM \"events\" WHERE SUBSTRING(events.\"timestamp\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the longitude and latitude of events from the 'events' table based on a specific condition applied to the 'timestamp' column. The placeholders allow for dynamic input of numeric values to specify the starting position and length of the substring, as well as a string value for comparison."
        },
        {
            "sample_id": 1196,
            "vt": "SELECT COUNT(gender_age.device_id) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE phone_brand_device_model2.device_model = '[placeholder-type:string]' AND gender_age.age > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of devices from the 'gender_age' table that match a specific device model and have users older than a certain age. The placeholders represent the device model and the age threshold."
        },
        {
            "sample_id": 1068,
            "vt": "SELECT DISTINCT phone_brand_device_model2.phone_brand, phone_brand_device_model2.device_model FROM phone_brand_device_model2 INNER JOIN events AS T2 ON T2.device_id = T1.device_id WHERE events.longitude = [placeholder-type:numeric] AND events.latitude = [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct phone brands and device models from the 'phone_brand_device_model2' table that are associated with events occurring at specific geographical coordinates. The placeholders in the WHERE clause represent the longitude and latitude values for filtering the events."
        },
        {
            "sample_id": 1051,
            "vt": "SELECT phone_brand_device_model2.device_model FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE gender_age.\"group\" = '[placeholder-type:string]' AND gender_age.gender = '[placeholder-type:string]' ORDER BY phone_brand_device_model2.device_id LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the device models from the 'phone_brand_device_model2' table for users of a specific gender and age group. The placeholders in the WHERE clause represent the gender and age group criteria, while the LIMIT clause restricts the number of results returned."
        },
        {
            "sample_id": 1070,
            "vt": "SELECT gender_age.device_id FROM phone_brand_device_model2 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE phone_brand_device_model2.device_model = '[placeholder-type:string]' AND gender_age.gender = '[placeholder-type:string]' AND phone_brand_device_model2.phone_brand = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves device IDs from the 'phone_brand_device_model2' table, joining it with the 'gender_age' table to filter based on specific device model, gender, and phone brand criteria. The placeholders allow users to specify the desired device model, gender, and phone brand, as well as limit the number of results returned."
        },
        {
            "sample_id": 1143,
            "vt": "SELECT gender_age.gender FROM gender_age INNER JOIN events AS T2 ON T1.device_id = T2.device_id WHERE events.timestamp = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the gender of users from the 'gender_age' table by joining it with the 'events' table based on the device ID. The query filters the results to include only those events that occurred at a specific timestamp, represented by a placeholder."
        },
        {
            "sample_id": 1175,
            "vt": "SELECT COUNT(events.device_id) FROM events INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE phone_brand_device_model2.phone_brand = '[placeholder-type:string]' AND STRFTIME('%Y-%m-%d', events.\"timestamp\") = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of devices from the 'events' table that are associated with a specific phone brand and a specific date. It joins the 'events' table with the 'phone_brand_device_model2' table to filter the results based on the phone brand and the event timestamp."
        },
        {
            "sample_id": 1094,
            "vt": "SELECT COUNT(gender_age.device_id) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE gender_age.gender = '[placeholder-type:string]' AND phone_brand_device_model2.phone_brand = '[placeholder-type:string]' AND gender_age.age < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of devices from the 'gender_age' table that match specific criteria. It filters the results based on the gender of the user, the brand of the device, and the age of the user being less than a specified value. The placeholders in the WHERE clause represent the gender, phone brand, and age limit."
        },
        {
            "sample_id": 1150,
            "vt": "SELECT COUNT(*) FROM (SELECT COUNT(DISTINCT T1.category) FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id INNER JOIN app_events AS T3 ON T2.app_id = T3.app_id WHERE T3.event_id = 2 AND T3.is_active = 0 GROUP BY T1.category) AS t",
            "ba": "The virtual table counts the number of distinct categories from the 'label_categories' table that are associated with apps in the 'app_labels' table, filtered by a specific event in the 'app_events' table where the event is inactive."
        },
        {
            "sample_id": 1102,
            "vt": "SELECT MAX(gender_age.age) FROM gender_age WHERE gender_age.gender = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum age of users from the 'gender_age' table, filtered by a specific gender. The placeholder in the WHERE clause represents the gender of the user, allowing for dynamic querying based on user input."
        },
        {
            "sample_id": 1219,
            "vt": "SELECT SUM(CASE WHEN events.latitude <> [placeholder-type:numeric] AND events.longitude <> [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN events.latitude = [placeholder-type:numeric] AND events.longitude = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM events WHERE events.device_id = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between two sums based on the latitude and longitude of events associated with a specific device. It sums a specified numeric value for events that have different latitude and longitude from the provided placeholders, and subtracts the sum of the same numeric value for events that match the provided latitude and longitude. The placeholder in the WHERE clause represents the device ID for which this calculation is performed."
        },
        {
            "sample_id": 1200,
            "vt": "SELECT SUM(CASE WHEN gender_age.age > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) / COUNT(gender_age.device_id) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE phone_brand_device_model2.phone_brand = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average of a specific numeric value based on the age of users from the 'gender_age' table, filtered by a specific phone brand from the 'phone_brand_device_model2' table. It uses a conditional statement to sum values based on whether the user's age exceeds a specified threshold, and divides this sum by the count of devices to get the average. The placeholders represent the age threshold, the numeric values to be summed, and the phone brand name."
        },
        {
            "sample_id": 1096,
            "vt": "SELECT phone_brand_device_model2.phone_brand FROM phone_brand_device_model2 WHERE gender_age.device_id IN (SELECT * FROM (SELECT device_id FROM gender_age WHERE gender = 'F' ORDER BY age LIMIT 1) AS T)",
            "ba": "The virtual table retrieves the phone brand of devices used by the youngest female user from the 'gender_age' table. It filters the devices based on the gender being female and orders them by age to select the youngest one."
        },
        {
            "sample_id": 1099,
            "vt": "SELECT SUM(CASE WHEN phone_brand_device_model2.phone_brand = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) / COUNT(events.device_id) FROM events INNER JOIN phone_brand_device_model2 AS T2 ON T1.event_id = T2.device_id WHERE events.event_id = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average of a specific condition based on the phone brand from the 'phone_brand_device_model2' table and the total number of devices from the 'events' table. It uses a conditional SUM to differentiate between the specified phone brand and others, while counting the total number of devices associated with a particular event."
        },
        {
            "sample_id": 1148,
            "vt": "SELECT label_categories.category FROM label_categories INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id WHERE app_labels.app_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the category of labels associated with a specific app identified by its app_id. It joins the 'label_categories' table with the 'app_labels' table to filter the results based on the app_id provided as a placeholder."
        },
        {
            "sample_id": 1058,
            "vt": "SELECT app_events.app_id, CASE WHEN app_events.is_installed = [placeholder-type:numeric] THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM app_events WHERE app_events.event_id = [placeholder-type:numeric]",
            "ba": "The virtual table provides a selection of app IDs from the 'app_events' table, along with a conditional statement that checks whether the app is installed or not. Depending on the value of 'is_installed', it returns different string values. The query filters results based on a specific event ID."
        },
        {
            "sample_id": 1118,
            "vt": "SELECT SUM(CASE WHEN phone_brand_device_model2.phone_brand = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) / SUM(CASE WHEN phone_brand_device_model2.device_id = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM phone_brand_device_model2 INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id WHERE gender_age.gender = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the ratio of a specific phone brand's count to the total count of devices for a specified gender. It uses a conditional sum to count the number of devices that match the given phone brand and divides it by the total number of devices for the specified device ID, filtered by gender."
        },
        {
            "sample_id": 1121,
            "vt": "SELECT gender_age.\"group\" FROM gender_age WHERE gender_age.age = '[placeholder-type:string]'",
            "ba": "The virtual table describes the age group of users from the 'gender_age' table based on a specific age. The placeholder in the WHERE clause represents the age of the user."
        },
        {
            "sample_id": 1191,
            "vt": "SELECT label_categories.category FROM label_categories INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id WHERE app_labels.app_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the category of labels associated with a specific app from the 'label_categories' table. It joins the 'label_categories' table with the 'app_labels' table to filter the results based on the app's ID, represented by a placeholder for numeric values."
        },
        {
            "sample_id": 1137,
            "vt": "SELECT gender_age.device_id FROM gender_age WHERE gender_age.age = (SELECT MIN(gender_age.age) FROM gender_age)",
            "ba": "The virtual table retrieves the device ID of the user with the minimum age from the 'gender_age' table. This is achieved by selecting the 'device_id' column where the 'age' matches the minimum age found in a subquery that calculates the minimum age from the same table."
        },
        {
            "sample_id": 1088,
            "vt": "SELECT DISTINCT events.longitude, events.latitude FROM app_events INNER JOIN events AS T2 ON T2.event_id = T1.event_id WHERE events.event_id = [placeholder-type:numeric] AND app_events.is_active = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct longitude and latitude coordinates from the 'events' table based on specific event criteria. It joins the 'app_events' table to filter results for active users associated with a particular event."
        },
        {
            "sample_id": 1066,
            "vt": "SELECT COUNT(events.event_id) FROM gender_age INNER JOIN events AS T2 ON T2.device_id = T1.device_id WHERE gender_age.gender = '[placeholder-type:string]' AND SUBSTRING(events.\"timestamp\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND gender_age.age = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of events from the 'events' table that are associated with devices used by users of a specific gender and age. It joins the 'gender_age' table with the 'events' table based on the device ID. The query filters results based on the specified gender, a substring of the timestamp, and the user's age."
        },
        {
            "sample_id": 1129,
            "vt": "SELECT COUNT(phone_brand_device_model2.device_id) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE gender_age.gender = '[placeholder-type:string]' AND phone_brand_device_model2.phone_brand = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of devices from the 'phone_brand_device_model2' table that correspond to users of a specific gender from the 'gender_age' table. The placeholders in the WHERE clause represent the gender and phone brand being queried."
        },
        {
            "sample_id": 1060,
            "vt": "SELECT COUNT(phone_brand_device_model2.device_id) FROM phone_brand_device_model2 WHERE phone_brand_device_model2.device_model = '[placeholder-type:string]' AND phone_brand_device_model2.phone_brand = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of devices from the 'phone_brand_device_model2' table that match a specific device model and phone brand. The placeholders in the WHERE clause represent the device model and phone brand to filter the results accordingly."
        },
        {
            "sample_id": 1126,
            "vt": "SELECT COUNT(phone_brand_device_model2.device_id) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE gender_age.\"group\" = '[placeholder-type:string]' AND phone_brand_device_model2.device_model = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of devices from the 'phone_brand_device_model2' table that correspond to a specific gender age group and device model. The placeholders in the WHERE clause represent the group of ages and the specific device model being queried."
        },
        {
            "sample_id": 1159,
            "vt": "SELECT AVG(gender_age.age) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE phone_brand_device_model2.phone_brand = '[placeholder-type:string]' AND gender_age.gender = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average age of users based on their gender and phone brand. It joins the 'gender_age' table, which contains user age and gender information, with the 'phone_brand_device_model2' table, which provides details about the device brand associated with each user. The placeholders in the WHERE clause represent the specific phone brand and gender of interest."
        },
        {
            "sample_id": 1087,
            "vt": "SELECT DISTINCT label_categories.category FROM label_categories INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id INNER JOIN app_events AS T3 ON T2.app_id = T3.app_id WHERE app_events.event_id = [placeholder-type:numeric] AND app_events.is_active = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct categories of labels associated with specific app events. It joins the 'label_categories' table with the 'app_labels' table to link labels to apps, and then further joins with the 'app_events' table to filter based on a specific event ID and the active status of the app. The placeholders represent the event ID and the active status of the app."
        },
        {
            "sample_id": 1222,
            "vt": "SELECT phone_brand_device_model2.device_model FROM phone_brand_device_model2 WHERE phone_brand_device_model2.phone_brand = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the device models from the 'phone_brand_device_model2' table that belong to a specific phone brand. The placeholders in the WHERE clause represent the phone brand's name and the limit on the number of results returned."
        },
        {
            "sample_id": 1108,
            "vt": "SELECT phone_brand_device_model2.device_model FROM phone_brand_device_model2 INNER JOIN events AS T2 ON T1.device_id = T2.event_id INNER JOIN app_events AS T3 ON T2.event_id = T3.event_id WHERE app_events.is_active = [placeholder-type:numeric] AND app_events.is_installed = [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the device models from the 'phone_brand_device_model2' table for devices that have associated events in the 'events' table and app events in the 'app_events' table. It filters the results based on whether the app is active and installed, using placeholders for these numeric values. Additionally, it limits the number of results returned."
        },
        {
            "sample_id": 1131,
            "vt": "SELECT COUNT(app_events.app_id) FROM app_events INNER JOIN events AS T2 ON T1.event_id = T2.event_id INNER JOIN gender_age AS T3 ON T2.event_id = T3.device_id WHERE SUBSTRING(events.\"timestamp\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND app_events.is_active = '[placeholder-type:string]' AND gender_age.\"group\" = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of app events associated with active users of a specific age group during a specified time period. It joins the 'app_events' table with the 'events' table to link events to their corresponding app events, and then further joins with the 'gender_age' table to filter users based on their age group. The placeholders represent the specific time range, active status, and age group criteria."
        },
        {
            "sample_id": 1109,
            "vt": "SELECT COUNT(app_labels.app_id) FROM app_labels INNER JOIN label_categories AS T2 ON T1.label_id = T2.label_id WHERE label_categories.category = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of app users associated with a specific behavior category from the 'app_labels' table. It joins the 'app_labels' table with the 'label_categories' table to filter the results based on the specified category. The placeholder in the WHERE clause represents the category name."
        },
        {
            "sample_id": 1180,
            "vt": "SELECT phone_brand_device_model2.phone_brand, phone_brand_device_model2.device_model FROM events INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE events.event_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the phone brand and device model associated with a specific event from the 'events' table. It joins the 'events' table with the 'phone_brand_device_model2' table using the device_id to ensure that the correct device information is linked to the event. The placeholder in the WHERE clause represents the unique identifier for the event being queried."
        },
        {
            "sample_id": 1062,
            "vt": "SELECT label_categories.label_id FROM label_categories WHERE label_categories.category IN ('[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table retrieves the label IDs from the 'label_categories' table for specific categories. The placeholders represent the categories of interest that the user wants to filter by."
        },
        {
            "sample_id": 1141,
            "vt": "SELECT gender_age.age FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE phone_brand_device_model2.phone_brand = '[placeholder-type:string]' ORDER BY gender_age.age LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the ages of users from the 'gender_age' table who are associated with a specific phone brand. It joins the 'gender_age' table with the 'phone_brand_device_model2' table on the device ID to filter the results based on the specified phone brand. The results are ordered by age and limited to a specified number of entries."
        },
        {
            "sample_id": 1163,
            "vt": "SELECT SUM(CASE WHEN app_events.is_active = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) / SUM(CASE WHEN app_events.is_active = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM app_events WHERE app_events.event_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the ratio of active users to total users for a specific event in the 'app_events' table. It uses conditional aggregation to sum the active users and total users based on the 'is_active' status, filtered by a specific event ID."
        },
        {
            "sample_id": 1097,
            "vt": "SELECT COUNT(phone_brand_device_model2.device_id) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE gender_age.\"group\" = '[placeholder-type:string]' AND phone_brand_device_model2.phone_brand = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of devices from the 'phone_brand_device_model2' table that correspond to a specific gender age group and phone brand. The placeholders in the WHERE clause represent the group of ages and the brand of the phone."
        },
        {
            "sample_id": 1198,
            "vt": "SELECT COUNT(gender_age.device_id) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE gender_age.gender = '[placeholder-type:string]' AND phone_brand_device_model2.phone_brand = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of devices from the 'gender_age' table that match a specific gender and phone brand. It joins the 'gender_age' table with the 'phone_brand_device_model2' table on the device_id to filter the results based on the specified gender and phone brand."
        },
        {
            "sample_id": 1055,
            "vt": "SELECT COUNT(app_labels.app_id) FROM label_categories INNER JOIN app_labels AS T2 ON T2.label_id = T1.label_id WHERE label_categories.category = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of app users associated with a specific label category from the 'label_categories' and 'app_labels' tables. The placeholder in the WHERE clause represents the label category being queried."
        },
        {
            "sample_id": 1072,
            "vt": "SELECT gender_age.age, gender_age.gender FROM phone_brand_device_model2 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE phone_brand_device_model2.phone_brand = '[placeholder-type:string]' AND phone_brand_device_model2.device_model = '[placeholder-type:string]'",
            "ba": "The virtual table describes the age and gender of users based on their device information from the 'phone_brand_device_model2' and 'gender_age' tables. The placeholders in the WHERE clause represent the specific phone brand and device model being queried."
        },
        {
            "sample_id": 1120,
            "vt": "SELECT COUNT(phone_brand_device_model2.device_id) FROM phone_brand_device_model2 WHERE phone_brand_device_model2.device_model = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of devices from the 'phone_brand_device_model2' table that match a specific device model. The placeholder in the WHERE clause represents the device model being queried."
        },
        {
            "sample_id": 1045,
            "vt": "SELECT (SELECT T2.category, COUNT(T1.app_id) AS num FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T2.label_id = T1.label_id GROUP BY T1.app_id, T2.category).category FROM (SELECT label_categories.category, COUNT(app_labels.app_id) FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T2.label_id = T1.label_id GROUP BY T1.app_id, T2.category) AS t ORDER BY (SELECT T2.category, COUNT(T1.app_id) AS num FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T2.label_id = T1.label_id GROUP BY T1.app_id, T2.category).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the count of app users categorized by their behavior labels. It retrieves the category of labels and the number of app users associated with each category. The query uses subqueries to join the 'app_labels' and 'label_categories' tables, grouping by app_id and category to count the occurrences. The results are ordered by the count of app users in each category, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 1040,
            "vt": "SELECT COUNT(events.event_id) FROM \"events\" WHERE events.latitude = [placeholder-type:numeric] AND events.longitude = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of events recorded in the 'events' table that match a specific geographical location defined by latitude and longitude. The placeholders represent the latitude and longitude values that can be specified by the user."
        },
        {
            "sample_id": 1190,
            "vt": "SELECT SUM(gender_age.age) / COUNT(gender_age.device_id) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE phone_brand_device_model2.device_model = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average age of users based on their device model from the 'gender_age' and 'phone_brand_device_model2' tables. It sums the ages of users and divides by the count of devices to get the average age for a specific device model, represented by a placeholder."
        },
        {
            "sample_id": 1113,
            "vt": "SELECT label_categories.category FROM label_categories INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id ORDER BY app_labels.label_id LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the categories of labels from the 'label_categories' table, joining it with the 'app_labels' table to filter based on label IDs. The results are ordered by the label ID from the 'app_labels' table and limited to a specified number of entries."
        },
        {
            "sample_id": 1063,
            "vt": "SELECT DISTINCT phone_brand_device_model2.phone_brand, phone_brand_device_model2.device_model FROM events INNER JOIN phone_brand_device_model2 AS T2 ON T2.device_id = T1.device_id WHERE events.timestamp LIKE '[placeholder-type:string]' AND events.longitude = [placeholder-type:numeric] AND events.latitude = [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct phone brands and device models from the 'phone_brand_device_model2' table that are associated with events recorded in the 'events' table. The query filters these events based on a specific timestamp, longitude, and latitude, using placeholders for the timestamp string and numeric values for longitude and latitude."
        },
        {
            "sample_id": 1176,
            "vt": "SELECT SUM(CASE WHEN gender_age.gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) / SUM(CASE WHEN gender_age.gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE phone_brand_device_model2.phone_brand = '[placeholder-type:string]' AND phone_brand_device_model2.device_model = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the ratio of a specific gender's count to the total count of devices for a given phone brand and device model. It uses a conditional sum to differentiate between genders and aggregates the results accordingly."
        },
        {
            "sample_id": 1073,
            "vt": "SELECT SUM(CASE WHEN label_categories.category = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) * [placeholder-type:numeric] / COUNT(app_labels.app_id) FROM label_categories INNER JOIN app_labels AS T2 ON T2.label_id = T1.label_id",
            "ba": "The virtual table calculates a weighted sum of a specific category from the 'label_categories' table, adjusting the result based on the count of app labels associated with each app. The placeholders represent the category to filter by, the numeric values for the sum calculation, and a multiplier for scaling the result."
        },
        {
            "sample_id": 1216,
            "vt": "SELECT AVG(gender_age.age) FROM gender_age INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id INNER JOIN app_events_relevant AS T3 ON T2.event_id = T3.event_id WHERE app_events_relevant.is_installed = [placeholder-type:numeric] AND app_events_relevant.is_active = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average age of users based on their device information, filtering for specific app installation and activity statuses. It joins the 'gender_age' table with 'events_relevant' and 'app_events_relevant' to ensure that only relevant events and user data are considered. The placeholders in the WHERE clause represent the installation and activity status of the app."
        },
        {
            "sample_id": 1194,
            "vt": "SELECT COUNT(gender_age.device_id) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE gender_age.gender = '[placeholder-type:string]' AND phone_brand_device_model2.device_model = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of devices from the 'gender_age' table that match a specific gender and device model. It joins the 'gender_age' table with the 'phone_brand_device_model2' table on the device_id to filter the results based on the specified gender and device model."
        },
        {
            "sample_id": 1167,
            "vt": "SELECT COUNT(app_labels.app_id) FROM app_labels WHERE app_labels.label_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of app users associated with a specific label from the 'app_labels' table. The placeholder in the WHERE clause represents the label's unique identifier."
        },
        {
            "sample_id": 1090,
            "vt": "SELECT events.event_id FROM phone_brand_device_model2 INNER JOIN events AS T2 ON T2.device_id = T1.device_id WHERE phone_brand_device_model2.phone_brand = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the event IDs from the 'events' table based on the device's phone brand. It joins the 'phone_brand_device_model2' table with the 'events' table using the device ID, filtering the results to include only those devices that match a specific phone brand."
        },
        {
            "sample_id": 1188,
            "vt": "SELECT COUNT(gender_age.device_id) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE phone_brand_device_model2.device_model = '[placeholder-type:string]' AND gender_age.age < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of devices from the 'gender_age' table that match a specific device model and have users below a certain age. The placeholders represent the device model and the age limit."
        },
        {
            "sample_id": 1162,
            "vt": "SELECT label_categories.label_id FROM label_categories WHERE label_categories.category = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the label IDs from the 'label_categories' table based on a specific category. The placeholder in the WHERE clause represents the category for which the label IDs are being queried."
        },
        {
            "sample_id": 1091,
            "vt": "SELECT COUNT(phone_brand_device_model2.device_id) FROM phone_brand_device_model2 INNER JOIN events AS T2 ON T2.device_id = T1.device_id WHERE phone_brand_device_model2.phone_brand = '[placeholder-type:string]' AND events.event_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of devices from the 'phone_brand_device_model2' table that are associated with a specific event in the 'events' table. It filters the results based on a specified phone brand and event ID, using placeholders for these values."
        },
        {
            "sample_id": 1111,
            "vt": "SELECT COUNT(gender_age.device_id) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE phone_brand_device_model2.phone_brand = '[placeholder-type:string]' AND gender_age.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of devices from the 'gender_age' table that match a specific phone brand and gender. It joins the 'gender_age' table with the 'phone_brand_device_model2' table on the device_id to filter the results based on the specified phone brand and gender."
        },
        {
            "sample_id": 1183,
            "vt": "SELECT COUNT(app_events.app_id) FROM app_events WHERE app_events.is_active = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of active app users from the 'app_events' table based on their installation status. The placeholder in the WHERE clause represents whether the app is active or not."
        },
        {
            "sample_id": 1177,
            "vt": "SELECT COUNT(gender_age.device_id) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE gender_age.gender = '[placeholder-type:string]' AND phone_brand_device_model2.device_model = '[placeholder-type:string]' AND gender_age.\"group\" = '[placeholder-type:string]' AND phone_brand_device_model2.phone_brand = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of devices from the 'gender_age' table that match specific criteria related to gender, device model, age group, and phone brand. The placeholders represent the values for gender, device model, age group, and phone brand respectively."
        },
        {
            "sample_id": 1207,
            "vt": "SELECT (SELECT T2.timestamp, COUNT(T2.event_id) AS num FROM gender_age AS T1 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id WHERE T1.gender = 'M' AND T1.age = 40 GROUP BY T2.timestamp).timestamp FROM (SELECT events_relevant.timestamp, COUNT(events_relevant.event_id) FROM gender_age AS T1 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id WHERE T1.gender = 'M' AND T1.age = 40 GROUP BY T2.timestamp) AS t ORDER BY (SELECT T2.timestamp, COUNT(T2.event_id) AS num FROM gender_age AS T1 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id WHERE T1.gender = 'M' AND T1.age = 40 GROUP BY T2.timestamp).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves timestamps of events for male users aged 40, counting the number of events that occurred at each timestamp. The results are ordered by the count of events, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 1157,
            "vt": "SELECT CASE WHEN SUM(CASE WHEN label_categories.category = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN label_categories.category = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) > [placeholder-type:numeric] THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM app_labels INNER JOIN label_categories AS T2 ON T1.label_id = T2.label_id",
            "ba": "The virtual table calculates a conditional value based on the sum of certain categories from the 'label_categories' table, comparing two sums derived from the 'app_labels' table. It uses placeholders to represent specific category values and numeric thresholds, allowing users to customize the query for different categories and conditions."
        },
        {
            "sample_id": 1093,
            "vt": "SELECT COUNT(events.event_id) FROM events INNER JOIN phone_brand_device_model2 AS T2 ON T1.event_id = T2.device_id WHERE STRFTIME('%Y', events.timestamp) = '[placeholder-type:string]' AND phone_brand_device_model2.phone_brand = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of events from the 'events' table that occurred in a specific year and are associated with a specific phone brand. It joins the 'events' table with the 'phone_brand_device_model2' table to filter events based on the device's brand."
        },
        {
            "sample_id": 1146,
            "vt": "SELECT events.longitude, events.latitude FROM events INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE phone_brand_device_model2.device_model = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the longitude and latitude of events from the 'events' table, specifically for devices that match a certain device model. The query uses an INNER JOIN to connect the 'events' table with the 'phone_brand_device_model2' table based on the device_id, ensuring that only events from the specified device model are included in the results."
        },
        {
            "sample_id": 1101,
            "vt": "SELECT COUNT(gender_age.device_id) FROM gender_age WHERE gender_age.\"group\" = '[placeholder-type:string]' AND gender_age.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of devices from the 'gender_age' table that belong to a specific age group and gender. The placeholders represent the age group and gender criteria for filtering the results."
        },
        {
            "sample_id": 1152,
            "vt": "SELECT phone_brand_device_model2.device_model FROM events INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE events.longitude = [placeholder-type:numeric] AND events.latitude = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the device models from the 'phone_brand_device_model2' table based on the geographical coordinates (longitude and latitude) of events recorded in the 'events' table. The placeholders represent specific longitude and latitude values to filter the results accordingly."
        },
        {
            "sample_id": 1095,
            "vt": "SELECT (SELECT T1.category, COUNT(T2.app_id) AS num FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id GROUP BY T1.label_id).category FROM (SELECT label_categories.category, COUNT(app_labels.app_id) FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id GROUP BY T1.label_id) AS t ORDER BY (SELECT T1.category, COUNT(T2.app_id) AS num FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id GROUP BY T1.label_id).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the number of app users associated with each behavior category from the 'label_categories' table. It counts the number of app IDs linked to each label ID and orders the results based on the count, limiting the output to a specified number of categories."
        },
        {
            "sample_id": 1125,
            "vt": "SELECT COUNT(app_labels.app_id) FROM label_categories INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id WHERE label_categories.category = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of app users associated with a specific label category from the 'label_categories' and 'app_labels' tables. The placeholder in the WHERE clause represents the category of the label being queried."
        },
        {
            "sample_id": 1092,
            "vt": "SELECT events.timestamp FROM events INNER JOIN phone_brand_device_model2 AS T2 ON T1.event_id = T2.device_id WHERE phone_brand_device_model2.phone_brand = '[placeholder-type:string]' AND events.event_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the timestamps of events from the 'events' table, specifically for devices of a certain phone brand. It joins the 'events' table with the 'phone_brand_device_model2' table to filter the results based on the specified phone brand and event ID."
        },
        {
            "sample_id": 1203,
            "vt": "SELECT app_events.app_id FROM app_events WHERE app_events.is_active = [placeholder-type:numeric] AND app_events.is_installed = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the app IDs from the 'app_events' table for apps that are either installed or not installed, based on the active status of the users. The placeholders represent the conditions for whether the app is installed and whether the user is active."
        },
        {
            "sample_id": 1182,
            "vt": "SELECT events.timestamp FROM events WHERE events.event_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the timestamp of a specific event from the 'events' table based on the event's unique identifier. The placeholder in the WHERE clause represents the event ID that the user wants to query."
        },
        {
            "sample_id": 1059,
            "vt": "SELECT COUNT(events.event_id) FROM events WHERE SUBSTRING(events.\"timestamp\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of events from the 'events' table that occur within a specific time range, as indicated by the placeholders for the start and end of the timestamp. The placeholder in the WHERE clause represents a specific substring of the timestamp that is being filtered."
        },
        {
            "sample_id": 1139,
            "vt": "SELECT gender_age.gender FROM gender_age WHERE gender_age.age = (SELECT MAX(gender_age.age) FROM gender_age)",
            "ba": "The virtual table retrieves the gender of the user who is the oldest among all users in the 'gender_age' table. It does this by selecting the 'gender' column where the 'age' matches the maximum age found in the same table."
        },
        {
            "sample_id": 1181,
            "vt": "SELECT (SELECT T2.age, T2.gender, COUNT(T1.device_id) AS num FROM events AS T1 INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id WHERE T1.device_id BETWEEN -9215352913819630000 AND -9222956879900150000 GROUP BY T2.age, T2.gender).age, (SELECT T2.age, T2.gender, COUNT(T1.device_id) AS num FROM events AS T1 INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id WHERE T1.device_id BETWEEN -9215352913819630000 AND -9222956879900150000 GROUP BY T2.age, T2.gender).gender FROM (SELECT gender_age.age, gender_age.gender, COUNT(events.device_id) FROM events AS T1 INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id WHERE T1.device_id BETWEEN -9215352913819630000 AND -9222956879900150000 GROUP BY T2.age, T2.gender) AS t ORDER BY (SELECT T2.age, T2.gender, COUNT(T1.device_id) AS num FROM events AS T1 INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id WHERE T1.device_id BETWEEN -9215352913819630000 AND -9222956879900150000 GROUP BY T2.age, T2.gender).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the count of devices categorized by age and gender from the 'events' and 'gender_age' tables. It filters the events based on a specific range of device IDs and groups the results by age and gender. The final output is ordered by the count of devices, allowing users to see the distribution of device usage across different age and gender groups, with a limit on the number of results returned."
        },
        {
            "sample_id": 1039,
            "vt": "SELECT gender_age.device_id FROM gender_age WHERE gender_age.age = (SELECT MAX(gender_age.age) FROM gender_age)",
            "ba": "The virtual table retrieves the device IDs from the 'gender_age' table for users who are the oldest based on their age. The query uses a subquery to find the maximum age in the 'gender_age' table, ensuring that only the device IDs of the oldest users are selected."
        },
        {
            "sample_id": 1184,
            "vt": "SELECT COUNT(phone_brand_device_model2.device_id) FROM phone_brand_device_model2 WHERE phone_brand_device_model2.device_model = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of devices from the 'phone_brand_device_model2' table that match a specific device model. The placeholder in the WHERE clause represents the device model being queried."
        },
        {
            "sample_id": 1189,
            "vt": "SELECT SUM(CASE WHEN gender_age.age < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) / COUNT(gender_age.device_id) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE phone_brand_device_model2.phone_brand = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average of a specific age group based on gender from the 'gender_age' table, while filtering the results by a specific phone brand from the 'phone_brand_device_model2' table. The placeholders represent the age thresholds and the phone brand name."
        },
        {
            "sample_id": 1220,
            "vt": "SELECT gender_age.device_id FROM gender_age WHERE gender_age.gender = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the device IDs from the 'gender_age' table for users of a specific gender. The placeholder in the WHERE clause represents the gender of the user, and the LIMIT clause allows for controlling the number of results returned."
        },
        {
            "sample_id": 1079,
            "vt": "SELECT MAX(gender_age.age) FROM gender_age",
            "ba": "The virtual table retrieves the maximum age from the 'gender_age' table, which contains information about users' ages associated with their device IDs."
        },
        {
            "sample_id": 1078,
            "vt": "SELECT COUNT(gender_age.device_id) FROM gender_age WHERE gender_age.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of devices from the 'gender_age' table based on the specified gender. The placeholder in the WHERE clause represents the gender of the user, which can be either male or female."
        },
        {
            "sample_id": 1116,
            "vt": "SELECT (SELECT T2.device_model, COUNT(T2.device_model) AS num FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T1.gender = 'F' GROUP BY T2.device_model).device_model FROM (SELECT phone_brand_device_model2.device_model, COUNT(phone_brand_device_model2.device_model) FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T1.gender = 'F' GROUP BY T2.device_model) AS t ORDER BY (SELECT T2.device_model, COUNT(T2.device_model) AS num FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T1.gender = 'F' GROUP BY T2.device_model).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of device models used by female users, along with a count of how many times each device model is used. The results are ordered by the number of occurrences of each device model, and the output is limited to a specified number of results. The placeholders in the query allow for dynamic input of the limit on the number of device models returned."
        },
        {
            "sample_id": 1067,
            "vt": "SELECT DISTINCT gender_age.age, gender_age.gender, COUNT(events.event_id) FROM gender_age INNER JOIN \"events\" AS T2 ON T2.device_id = T1.device_id WHERE events.longitude = -[placeholder-type:numeric] AND events.latitude = [placeholder-type:numeric] GROUP BY gender_age.age, gender_age.gender, events.longitude, events.latitude",
            "ba": "The virtual table summarizes the count of events grouped by the age and gender of users, filtered by specific geographical coordinates (longitude and latitude). It combines data from the 'gender_age' table, which contains demographic information, and the 'events' table, which records event occurrences along with their respective locations."
        },
        {
            "sample_id": 1089,
            "vt": "SELECT events.timestamp FROM app_events INNER JOIN events AS T2 ON T2.event_id = T1.event_id WHERE app_events.is_active = [placeholder-type:numeric] AND events.event_id = [placeholder-type:numeric] ORDER BY events.timestamp LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the timestamps of events from the 'events' table that are associated with active applications from the 'app_events' table. It filters the results based on whether the application is active and a specific event ID, ordering the results by the timestamp and limiting the number of results returned."
        },
        {
            "sample_id": 1213,
            "vt": "SELECT COUNT(gender_age.device_id) FROM gender_age INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE gender_age.age > [placeholder-type:numeric] AND phone_brand_device_model2.device_model <> '[placeholder-type:string]' AND phone_brand_device_model2.phone_brand <> '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of unique devices from the 'gender_age' table that meet specific criteria. It filters devices based on age and excludes certain device models and brands. The placeholders represent the age threshold, device model to exclude, and phone brand to exclude."
        }
    ],
    "retail_world": [
        {
            "sample_id": 6324,
            "vt": "SELECT products.productname FROM products INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE suppliers.country = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of products from the 'products' table that are supplied by suppliers located in a specific country. The query uses an INNER JOIN to connect the 'products' table with the 'suppliers' table based on the supplier ID, and it filters the results based on the country of the suppliers using a placeholder for string values."
        },
        {
            "sample_id": 6344,
            "vt": "SELECT categories.categoryname FROM products INNER JOIN Categories AS T2 ON T1.CategoryID = T2.CategoryID WHERE products.productname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the category names of products from the 'products' table that belong to a specific product name. The placeholder in the WHERE clause represents the name of the product."
        },
        {
            "sample_id": 6656,
            "vt": "SELECT employees.firstname, employees.lastname FROM employees INNER JOIN Orders AS T2 ON T1.EmployeeID = T2.EmployeeID WHERE orders.orderid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of employees who have processed a specific order from the 'Orders' table. The placeholder in the WHERE clause represents the unique identifier of the order."
        },
        {
            "sample_id": 6315,
            "vt": "SELECT products.productname FROM products INNER JOIN \"Order Details\" AS T2 ON T1.ProductID = T2.ProductID WHERE order details.orderid = [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of products from the 'products' table that are associated with a specific order. The query joins the 'products' table with the 'orderdetails' table to filter products based on a given order ID."
        },
        {
            "sample_id": 6359,
            "vt": "SELECT COUNT(suppliers.supplierid) FROM suppliers WHERE suppliers.country = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of suppliers from the 'suppliers' table that are located in a specific country. The placeholder in the WHERE clause represents the country name."
        },
        {
            "sample_id": 6549,
            "vt": "SELECT products.productname FROM products INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE suppliers.country = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of products from the 'products' table that are supplied by suppliers located in a specific country. The placeholder in the WHERE clause represents the country of the suppliers."
        },
        {
            "sample_id": 6534,
            "vt": "SELECT categories.categoryid, categories.description FROM categories WHERE categories.categoryname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique identifier and detailed description of categories from the 'categories' table that match a specific category name. The placeholder in the WHERE clause represents the name of the category being queried."
        },
        {
            "sample_id": 6320,
            "vt": "SELECT COUNT(order details.orderid) FROM products INNER JOIN \"Order Details\" AS T2 ON T1.ProductID = T2.ProductID WHERE products.productname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of order details associated with a specific product from the 'products' table. It joins the 'products' table with the 'orderdetails' table to link products with their respective order details. The placeholder in the WHERE clause represents the name of the product for which the count is being calculated."
        },
        {
            "sample_id": 6495,
            "vt": "SELECT COUNT(customers.city) FROM customers WHERE customers.country = '[placeholder-type:string]' AND customers.city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers located in a specific city within a specified country. The placeholders in the WHERE clause represent the country and city names."
        },
        {
            "sample_id": 6411,
            "vt": "SELECT suppliers.contactname FROM products INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE products.productname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the contact names of suppliers for a specific product from the 'products' table by joining it with the 'suppliers' table based on the supplier ID. The placeholder in the WHERE clause represents the name of the product being queried."
        },
        {
            "sample_id": 6349,
            "vt": "SELECT suppliers.country FROM products INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE products.productname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the country of suppliers for a specific product from the 'products' table by joining it with the 'suppliers' table. The placeholder in the WHERE clause represents the name of the product being queried."
        },
        {
            "sample_id": 6629,
            "vt": "SELECT order details.productid FROM customers INNER JOIN \"Order Details\" AS T2 WHERE customers.country = '[placeholder-type:string]' GROUP BY order details.productid ORDER BY COUNT(order details.productid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of product IDs from the 'Order Details' table, filtered by customers from a specific country. It groups the results by product ID and orders them based on the count of each product ID, limiting the results to a specified number."
        },
        {
            "sample_id": 6463,
            "vt": "SELECT COUNT(orders.employeeid) FROM employees INNER JOIN Orders AS T2 ON T1.EmployeeID = T2.EmployeeID WHERE employees.firstname = '[placeholder-type:string]' AND employees.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of orders associated with a specific employee identified by their first and last name. It joins the 'employees' table with the 'orders' table to link employees to their respective orders, filtering based on the provided first and last name placeholders."
        },
        {
            "sample_id": 6635,
            "vt": "SELECT orders.customerid, categories.categoryname FROM orders INNER JOIN \"Order Details\" AS T2 ON T1.OrderID = T2.OrderID INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID INNER JOIN Categories AS T4 ON T3.CategoryID = T4.CategoryID ORDER BY orders.customerid, categories.categoryname",
            "ba": "The virtual table provides a list of customer IDs along with the corresponding category names of products they ordered. It combines data from multiple tables: 'orders', 'orderdetails', 'products', and 'categories'. The results are sorted by customer ID and category name."
        },
        {
            "sample_id": 6348,
            "vt": "SELECT suppliers.contactname FROM products INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE products.productname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the contact names of suppliers for a specific product from the 'products' table. The query uses an INNER JOIN to connect the 'products' table with the 'suppliers' table based on the supplier ID. The placeholder in the WHERE clause represents the name of the product for which we want to find the supplier's contact name."
        },
        {
            "sample_id": 6508,
            "vt": "SELECT COUNT(orders.customerid) FROM customers INNER JOIN Orders AS T2 ON T1.CustomerID = T2.CustomerID WHERE STRFTIME('%Y', orders.orderdate) = '[placeholder-type:string]' GROUP BY customers.country",
            "ba": "The virtual table counts the number of orders placed by customers, grouped by their country. It joins the 'customers' table with the 'orders' table to associate each order with the corresponding customer. The query filters the results to include only those orders that were placed in a specific year, represented by a placeholder for the year."
        },
        {
            "sample_id": 6666,
            "vt": "SELECT employees.firstname, employees.lastname FROM employees INNER JOIN Orders AS T2 ON T1.EmployeeID = T2.EmployeeID WHERE orders.orderid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of employees who processed a specific order from the 'orders' table. The placeholder in the WHERE clause represents the unique identifier of the order."
        },
        {
            "sample_id": 6614,
            "vt": "SELECT categories.categoryname, categories.description FROM products INNER JOIN Categories AS T2 ON T1.CategoryID = T2.CategoryID WHERE products.productname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the category name and description of a product from the 'products' table by joining it with the 'categories' table. The placeholder in the WHERE clause represents the name of the product being queried."
        },
        {
            "sample_id": 6316,
            "vt": "SELECT order details.quantity FROM products INNER JOIN \"Order Details\" AS T2 ON T1.ProductID = T2.ProductID WHERE order details.orderid = [placeholder-type:numeric] AND products.productname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the quantity of ordered products from the 'Order Details' table, which is linked to the 'Products' table. The query filters results based on a specific order ID and a product name."
        },
        {
            "sample_id": 6502,
            "vt": "SELECT CAST(COUNT(CASE WHEN customers.city = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(customers.city) FROM customers INNER JOIN Orders AS T2 ON T1.CustomerID = T2.CustomerID WHERE STRFTIME('%Y', orders.orderdate) = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the percentage of customers from a specific city who have placed orders in a given year. It does this by counting the number of customers from that city and dividing it by the total number of customers, then multiplying by a specified factor."
        },
        {
            "sample_id": 6506,
            "vt": "SELECT COUNT(customers.customerid) FROM customers INNER JOIN Orders AS T2 ON T1.CustomerID = T2.CustomerID WHERE STRFTIME('%Y', orders.orderdate) = '[placeholder-type:string]' AND customers.country = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table who have placed orders in a specific year and belong to a specific country. The placeholders in the WHERE clause represent the year of the order date and the customer's country."
        },
        {
            "sample_id": 6602,
            "vt": "SELECT SUM(CASE WHEN order details.quantity < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END), CAST(SUM(CASE WHEN order details.quantity < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / COUNT(products.productid) FROM products INNER JOIN \"Order Details\" AS T2 ON T1.ProductID = T2.ProductID",
            "ba": "The virtual table calculates the total quantity of products ordered and the average quantity per product from the 'products' and 'orderdetails' tables. It uses conditional logic to sum quantities based on a specified threshold, represented by placeholders for numeric values."
        },
        {
            "sample_id": 6425,
            "vt": "SELECT employees.lastname FROM employees INNER JOIN Orders AS T2 ON T1.EmployeeID = T2.EmployeeID WHERE orders.orderid = [placeholder-type:numeric] AND orders.customerid = '[placeholder-type:string]'",
            "ba": "The virtual table describes the last names of employees who processed a specific order for a specific customer. It retrieves data from the 'employees' table and joins it with the 'orders' table to filter based on the order ID and customer ID."
        },
        {
            "sample_id": 6330,
            "vt": "SELECT CAST(SUM(order details.quantity) AS FLOAT) / COUNT(order details.orderid) FROM products INNER JOIN \"Order Details\" AS T2 ON T1.ProductID = T2.ProductID WHERE products.productname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average quantity of a specific product ordered from the 'products' and 'orderdetails' tables. It sums up the quantities from the 'orderdetails' table and divides it by the count of orders for that product. The placeholder in the WHERE clause represents the name of the product being queried."
        },
        {
            "sample_id": 6583,
            "vt": "SELECT COUNT(shippers.shipperid) FROM shippers",
            "ba": "The virtual table counts the number of unique shippers from the 'shippers' table. The result will provide the total count of shippers available in the database."
        },
        {
            "sample_id": 6580,
            "vt": "SELECT COUNT(suppliers.supplierid) FROM suppliers WHERE suppliers.country = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of suppliers from the 'suppliers' table based on their country. The placeholder in the WHERE clause represents the specific country for which the count of suppliers is requested."
        },
        {
            "sample_id": 6379,
            "vt": "SELECT employees.firstname, employees.lastname FROM employees INNER JOIN Orders AS T2 ON T1.EmployeeID = T2.EmployeeID GROUP BY employees.firstname, employees.lastname ORDER BY COUNT(*) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of employee names from the 'employees' table who have processed orders. It joins the 'employees' table with the 'orders' table to associate employees with their respective orders. The results are grouped by the employee's first and last names, and ordered by the count of orders they have processed, limiting the output to a specified number of entries."
        },
        {
            "sample_id": 6469,
            "vt": "SELECT COUNT(products.supplierid) FROM products INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE suppliers.country = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of products supplied by suppliers from a specific country. It joins the 'products' table with the 'suppliers' table to filter the results based on the supplier's country."
        },
        {
            "sample_id": 6622,
            "vt": "SELECT COUNT(suppliers.supplierid) FROM suppliers WHERE suppliers.country = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of suppliers from the 'suppliers' table based on their country. The placeholder in the WHERE clause represents the specific country for which the count of suppliers is requested."
        },
        {
            "sample_id": 6374,
            "vt": "SELECT products.productid FROM products INNER JOIN \"Order Details\" AS T2 ON T1.ProductID = T2.ProductID GROUP BY products.productid ORDER BY COUNT(*) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists unique product IDs from the 'products' table, which are associated with order details. It uses an inner join to connect the 'products' table with the 'orderdetails' table based on the product ID. The results are grouped by product ID and ordered by the count of occurrences in the order details, limiting the output to a specified number of results."
        },
        {
            "sample_id": 6339,
            "vt": "SELECT SUM(order details.quantity) FROM orders INNER JOIN \"Order Details\" AS T2 ON T1.OrderID = T2.OrderID WHERE orders.customerid = '[placeholder-type:string]' AND orders.orderdate LIKE '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total quantity of products ordered by a specific customer on a particular date. It combines data from the 'orders' and 'orderdetails' tables, linking them through the order ID. The placeholders represent the customer ID and the order date, allowing users to specify which customer's orders and which date they are interested in."
        },
        {
            "sample_id": 6669,
            "vt": "SELECT shippers.phone FROM orders INNER JOIN Shippers AS T2 ON T1.ShipVia = T2.ShipperID WHERE orders.orderid = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the phone number of the shipping company associated with a specific order from the 'orders' table. It uses an inner join to connect the 'orders' table with the 'shippers' table based on the shipper ID, allowing for the extraction of relevant shipping information for a given order ID."
        },
        {
            "sample_id": 6585,
            "vt": "SELECT categories.categoryname FROM categories WHERE categories.description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the category names from the 'categories' table that match a specific description. The placeholder in the WHERE clause represents the detailed description of the category."
        },
        {
            "sample_id": 6481,
            "vt": "SELECT SUM(order details.quantity) FROM products INNER JOIN \"Order Details\" AS T2 ON T1.ProductID = T2.ProductID WHERE products.productname LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total quantity of a specific product ordered from the 'products' table by joining it with the 'orderdetails' table. The placeholder in the WHERE clause allows for filtering based on the product name."
        },
        {
            "sample_id": 6343,
            "vt": "SELECT COUNT(products.productid) FROM products INNER JOIN Categories AS T2 ON T1.CategoryID = T2.CategoryID WHERE categories.categoryname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of products from the 'products' table that belong to a specific category. It joins the 'products' table with the 'categories' table to filter products based on the category name provided in the placeholder."
        },
        {
            "sample_id": 6514,
            "vt": "SELECT suppliers.country FROM suppliers GROUP BY suppliers.country ORDER BY COUNT(suppliers.supplierid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the countries of suppliers from the 'suppliers' table, grouping them by country and ordering the results based on the count of suppliers in each country. The placeholder in the LIMIT clause allows for specifying the maximum number of countries to return."
        },
        {
            "sample_id": 6658,
            "vt": "SELECT employees.country FROM employees INNER JOIN Orders AS T2 ON T1.EmployeeID = T2.EmployeeID WHERE orders.orderid = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the country of employees who are associated with a specific order from the 'Orders' table. It uses an inner join to connect the 'employees' table with the 'orders' table based on the employee's ID. The placeholder in the WHERE clause represents the unique identifier of the order."
        },
        {
            "sample_id": 6578,
            "vt": "SELECT COUNT(order details.quantity) FROM products INNER JOIN \"Order Details\" AS T2 ON T1.ProductID = T2.ProductID WHERE products.productname = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of the total quantity of ordered products from the 'products' table, specifically for a product identified by its name. It utilizes an inner join with the 'orderdetails' table to link product IDs and aggregate the quantity of orders for the specified product name."
        },
        {
            "sample_id": 6413,
            "vt": "SELECT products.productname FROM customers INNER JOIN Orders AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN \"Order Details\" AS T3 ON T2.OrderID = T3.OrderID INNER JOIN Products AS T4 ON T3.ProductID = T4.ProductID WHERE customers.postalcode = [placeholder-type:numeric] ORDER BY order details.quantity LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of products ordered by customers from the 'customers' table, filtered by a specific postal code. It joins the 'orders' table to link customers to their orders, then joins the 'orderdetails' table to access the details of each order, and finally joins the 'products' table to retrieve the product names. The results are ordered by the quantity of products ordered and limited to a specified number of results."
        },
        {
            "sample_id": 6334,
            "vt": "SELECT COUNT(orders.orderid) FROM employees INNER JOIN Orders AS T2 ON T1.EmployeeID = T2.EmployeeID WHERE employees.firstname = '[placeholder-type:string]' AND employees.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of orders placed by a specific employee identified by their first and last name. It joins the 'employees' table with the 'orders' table to correlate employees with their respective orders."
        }
    ],
    "authors": [
        {
            "sample_id": 3585,
            "vt": "SELECT paper.keyword, paper.year FROM paper WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the keywords and year of a paper from the 'paper' table based on a specific title. The placeholder in the WHERE clause represents the title of the paper being queried."
        },
        {
            "sample_id": 3661,
            "vt": "SELECT COUNT(paperauthor.name) FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Journal AS T3 ON T1.JournalId = T3.Id WHERE journal.fullname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of authors associated with papers published in a specific journal. It joins the 'paper' table with the 'paperauthor' table to link papers to their authors, and then joins with the 'journal' table to filter by the journal's full name. The placeholder in the WHERE clause represents the full name of the journal."
        },
        {
            "sample_id": 3540,
            "vt": "SELECT CAST(SUM(CASE WHEN paper.year = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / COUNT(paper.id) FROM paper WHERE paper.year >= [placeholder-type:numeric] AND paper.year < [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average of a specific numeric value from the 'paper' table for papers published within a certain year range. The placeholders represent the year to filter the papers and the numeric values to be summed and counted."
        },
        {
            "sample_id": 3679,
            "vt": "SELECT author.name, paper.year FROM author INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.AuthorId INNER JOIN Paper AS T3 ON T2.PaperId = T3.Id WHERE paperauthor.paperid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of authors and the years of their respective papers from the 'author' and 'paper' tables. It uses inner joins to connect the 'author' table with the 'paperauthor' table and then with the 'paper' table, allowing for the retrieval of author names and the publication years of their papers. The placeholder in the WHERE clause represents a specific paper ID."
        },
        {
            "sample_id": 3648,
            "vt": "SELECT paperauthor.name FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of authors from the 'paperauthor' table who have contributed to a specific paper identified by its title. The query joins the 'paper' table with the 'paperauthor' table to retrieve the relevant author names associated with that paper title."
        },
        {
            "sample_id": 3639,
            "vt": "SELECT COUNT(author.name) FROM author WHERE author.affiliation = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of authors from the 'author' table who are affiliated with a specific organization. The placeholder in the WHERE clause represents the name of the organization."
        },
        {
            "sample_id": 3644,
            "vt": "SELECT paper.title FROM paperauthor INNER JOIN Paper AS T2 ON T1.PaperId = T2.Id WHERE paperauthor.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of papers from the 'paper' table that are authored by a specific author. The query uses an inner join between the 'paperauthor' and 'paper' tables to link the authors to their respective papers, filtering by the author's name using a placeholder."
        },
        {
            "sample_id": 3565,
            "vt": "SELECT paperauthor.authorid, paper.title FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paperauthor.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the author IDs and titles of papers from the 'paper' table that have been authored by a specific author. The placeholder in the WHERE clause represents the author's name."
        },
        {
            "sample_id": 3606,
            "vt": "SELECT paper.title FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Journal AS T3 ON T1.JournalId = T3.Id WHERE paperauthor.name = '[placeholder-type:string]' AND paper.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of papers from the 'paper' table that are co-authored by a specific author and published within a certain year range. The placeholders in the WHERE clause represent the author's name and the range of years for publication."
        },
        {
            "sample_id": 3551,
            "vt": "SELECT DISTINCT paper.title, paper.journalid FROM conference INNER JOIN Paper AS T2 ON T1.Id = T2.ConferenceId WHERE conference.fullname = '[placeholder-type:string]' AND paper.year = [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct titles of papers along with their associated journal IDs from the 'paper' table, filtered by a specific conference's full name and the publication year of the papers. The placeholders represent the conference's full name and the year of publication."
        },
        {
            "sample_id": 3659,
            "vt": "SELECT paper.title FROM journal INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE journal.fullname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of papers published in a specific journal from the 'journal' and 'paper' tables. The placeholder in the WHERE clause represents the full name of the journal."
        },
        {
            "sample_id": 3586,
            "vt": "SELECT CAST(SUM(CASE WHEN paper.year > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(paper.id) FROM paper",
            "ba": "The virtual table calculates a weighted average of the years of papers published, where the years are filtered based on a specified threshold. It sums the years of papers that are published after a certain year and applies a multiplier to the result, then divides by the total count of papers to get the average."
        },
        {
            "sample_id": 3513,
            "vt": "SELECT COUNT(paper.id) FROM journal INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE paper.year = [placeholder-type:numeric] AND journal.fullname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of papers published in a specific journal during a specified year. It joins the 'journal' and 'paper' tables based on the journal ID, filtering the results by the publication year and the full name of the journal."
        },
        {
            "sample_id": 3558,
            "vt": "SELECT conference.homepage FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the homepage URL of a conference from the 'conference' table based on the title of a paper from the 'paper' table. The query uses an INNER JOIN to connect the two tables through the conference ID, ensuring that only the relevant conference homepage is selected for the specified paper title."
        },
        {
            "sample_id": 3569,
            "vt": "SELECT conference.shortname FROM conference WHERE conference.fullname LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the short name of conferences from the 'conference' table that match a specified full name pattern. The placeholder in the WHERE clause allows for flexible input to search for conferences based on their full names."
        },
        {
            "sample_id": 3525,
            "vt": "SELECT paperauthor.paperid, paperauthor.authorid FROM paperauthor WHERE paperauthor.affiliation LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the paper IDs and author IDs from the 'paperauthor' table for authors affiliated with a specific organization. The placeholder in the WHERE clause represents the name of the organization."
        },
        {
            "sample_id": 3613,
            "vt": "SELECT paperauthor.name FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of authors from the 'paperauthor' table who have contributed to a specific paper identified by its title. The query joins the 'paper' table with the 'paperauthor' table to retrieve the relevant author names based on the paper's title, which is represented by a placeholder."
        },
        {
            "sample_id": 3536,
            "vt": "SELECT paper.id FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE conference.homepage LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the IDs of papers that were presented at conferences with a specific homepage URL. It joins the 'paper' table with the 'conference' table to filter the results based on the conference's homepage."
        },
        {
            "sample_id": 3595,
            "vt": "SELECT DISTINCT paperauthor.affiliation FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct affiliations of authors from the 'paperauthor' table for a specific paper title. It joins the 'paper' table to link the paper's ID with the corresponding author affiliations, ensuring that only unique affiliations are returned for the specified paper title."
        },
        {
            "sample_id": 3627,
            "vt": "SELECT CASE WHEN paper.year = [placeholder-type:numeric] THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paperauthor.name = '[placeholder-type:string]' AND paper.conferenceid = [placeholder-type:numeric] AND paper.journalid = [placeholder-type:numeric]",
            "ba": "The virtual table provides a way to retrieve information about papers based on their publication year, author name, and the conference or journal they are associated with. It uses a conditional statement to check if the paper's year matches a specified value, returning different strings based on this condition. The query joins the 'paper' table with the 'paperauthor' table to filter results by the author's name and the IDs of the conference and journal."
        },
        {
            "sample_id": 3643,
            "vt": "SELECT paper.title FROM journal INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE journal.shortname = '[placeholder-type:string]' ORDER BY paper.year LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of papers published in a specific journal, identified by its short name. The results are ordered by the year of publication and limited to a specified number of entries."
        },
        {
            "sample_id": 3633,
            "vt": "SELECT COUNT(paper.id) FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE conference.shortname = '[placeholder-type:string]' AND paper.year = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of papers published in a specific conference for a given year. It joins the 'paper' table with the 'conference' table to filter the results based on the conference's short name and the publication year of the papers."
        },
        {
            "sample_id": 3665,
            "vt": "SELECT paper.year, journal.fullname FROM paper INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the year of publication and the full name of the journal for a specific paper title from the 'paper' table. The query joins the 'paper' table with the 'journal' table to retrieve the relevant journal information based on the journal ID associated with the paper. The placeholder in the WHERE clause represents the title of the paper being queried."
        },
        {
            "sample_id": 3610,
            "vt": "SELECT COUNT(paper.id) FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE conference.fullname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of papers published in a specific conference. It joins the 'paper' table with the 'conference' table to filter the results based on the full name of the conference provided by the user."
        },
        {
            "sample_id": 3670,
            "vt": "SELECT COUNT(paper.conferenceid) FROM conference INNER JOIN Paper AS T2 ON T1.Id = T2.ConferenceId WHERE conference.fullname = '[placeholder-type:string]' AND paper.year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of papers presented at a specific conference in a given year. It joins the 'conference' table with the 'paper' table to filter results based on the conference's full name and the publication year of the papers."
        },
        {
            "sample_id": 3619,
            "vt": "SELECT paper.title FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE conference.homepage = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of papers from the 'paper' table that were presented at a specific conference. The query joins the 'paper' table with the 'conference' table to filter papers based on the conference's homepage URL, represented by a placeholder."
        },
        {
            "sample_id": 3534,
            "vt": "SELECT DISTINCT paperauthor.name FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paper.conferenceid = [placeholder-type:numeric] AND paper.journalid < [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct author names from the 'paperauthor' table for papers that were presented at a specific conference and published in a specific journal. The placeholders represent the conference ID and a numeric value for the journal ID, allowing users to filter results based on these criteria."
        },
        {
            "sample_id": 3601,
            "vt": "SELECT paper.title, paperauthor.name FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Journal AS T3 ON T1.JournalId = T3.Id WHERE journal.fullname = '[placeholder-type:string]' AND paper.year = [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of papers along with the names of their authors from the 'paper' and 'paperauthor' tables. It filters the results based on the full name of the journal and the year of publication, using placeholders for these values."
        },
        {
            "sample_id": 3669,
            "vt": "SELECT paper.title FROM paperauthor INNER JOIN Paper AS T2 ON T1.PaperId = T2.Id WHERE paperauthor.name = '[placeholder-type:string]' ORDER BY paper.year LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of papers authored by a specific author from the 'paperauthor' table, joining it with the 'paper' table to access the paper details. The query filters results based on the author's name and orders the papers by their publication year, limiting the number of results returned."
        },
        {
            "sample_id": 3614,
            "vt": "SELECT COUNT(paper.id) FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE paper.year = [placeholder-type:numeric] AND conference.shortname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of papers published in a specific conference during a given year. It joins the 'paper' table with the 'conference' table to filter the results based on the year of publication and the short name of the conference."
        },
        {
            "sample_id": 3681,
            "vt": "SELECT conference.fullname FROM conference INNER JOIN Paper AS T2 ON T1.Id = T2.ConferenceId WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the full name of a conference from the 'conference' table based on the title of a specific paper. The query uses an inner join to connect the 'conference' table with the 'paper' table, filtering results where the title of the paper matches a specified value."
        },
        {
            "sample_id": 3636,
            "vt": "SELECT CAST(SUM(CASE WHEN paper.conferenceid = [placeholder-type:numeric] AND paper.journalid = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / COUNT(paper.id) FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paperauthor.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average of a specific numeric value from the 'paper' table, filtered by conference and journal IDs, while also considering the author's name from the 'paperauthor' table. The result is a float value representing the average based on the specified conditions."
        },
        {
            "sample_id": 3562,
            "vt": "SELECT paper.title FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE conference.fullname = '[placeholder-type:string]' AND paper.title <> '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the titles of papers from the 'paper' table that were presented at a specific conference. It filters the results based on the full name of the conference and excludes a specific paper title from the results."
        },
        {
            "sample_id": 3612,
            "vt": "SELECT paper.title FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paperauthor.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of papers from the 'paper' table that have a specific author name associated with them. The query uses an inner join with the 'paperauthor' table to link papers to their authors, filtering based on the author's name provided as a placeholder."
        },
        {
            "sample_id": 3581,
            "vt": "SELECT paperauthor.name FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Conference AS T3 ON T1.ConferenceId = T3.Id WHERE conference.fullname LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of authors from the 'paperauthor' table who have contributed to papers presented at a specific conference. The query joins the 'paper' table to identify the relevant papers and the 'conference' table to filter by the conference's full name, using a placeholder for the conference name."
        },
        {
            "sample_id": 3560,
            "vt": "SELECT paperauthor.paperid, conference.shortname FROM author INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.AuthorId INNER JOIN Paper AS T3 ON T2.PaperId = T3.Id INNER JOIN Conference AS T4 ON T3.ConferenceId = T4.Id WHERE paper.year = [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the paper IDs and short names of conferences for papers published in a specific year. The placeholders represent the year of publication and the limit on the number of results returned."
        },
        {
            "sample_id": 3596,
            "vt": "SELECT paper.title, journal.fullname FROM paper INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id WHERE paper.year < [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of papers along with the full names of the journals in which they were published, specifically for papers published before a certain year. The placeholders in the WHERE clause represent the year cutoff and the limit on the number of results returned."
        },
        {
            "sample_id": 3546,
            "vt": "SELECT paper.id, paper.title, paper.year, journal.fullname FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Journal AS T3 ON T1.JournalId = T3.Id GROUP BY paperauthor.authorid ORDER BY COUNT(paperauthor.authorid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of papers along with their titles, publication years, and the full names of the journals in which they were published. It aggregates the data by counting the number of authors associated with each paper, allowing users to see which papers have the most authors. The placeholder in the LIMIT clause indicates the maximum number of results to return, which can be adjusted as needed."
        },
        {
            "sample_id": 3556,
            "vt": "SELECT COUNT(paper.id) FROM paper WHERE paper.year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of papers from the 'paper' table that were published in a specific year. The placeholder in the WHERE clause represents the year of publication."
        },
        {
            "sample_id": 3618,
            "vt": "SELECT COUNT(paper.id) FROM paper INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id WHERE journal.fullname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of papers published in a specific journal. It joins the 'paper' table with the 'journal' table based on the journal ID, filtering the results to only include papers from a journal with a specified full name."
        },
        {
            "sample_id": 3611,
            "vt": "SELECT paperauthor.name FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of authors from the 'paperauthor' table who have contributed to a specific paper identified by its title. The query joins the 'paper' table with the 'paperauthor' table to retrieve the relevant author names associated with that paper title."
        },
        {
            "sample_id": 3557,
            "vt": "SELECT conference.fullname FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the full name of conferences from the 'conference' table where a specific paper title is associated with a conference. The placeholder in the WHERE clause represents the title of the paper."
        },
        {
            "sample_id": 3657,
            "vt": "SELECT author.name FROM author WHERE author.affiliation = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of authors from the 'author' table who are affiliated with a specific organization. The placeholder in the WHERE clause represents the name of the organization with which the authors are affiliated."
        },
        {
            "sample_id": 3547,
            "vt": "SELECT DISTINCT paper.title, paper.year, conference.shortname, paperauthor.name FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Conference AS T3 ON T1.ConferenceId = T3.Id WHERE paper.id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct titles and publication years of papers along with the short names of the conferences they were presented at and the names of their authors. The placeholders in the WHERE clause represent the specific paper's ID being queried."
        },
        {
            "sample_id": 3509,
            "vt": "SELECT paper.keyword FROM paper WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the keywords associated with a specific paper from the 'paper' table based on the paper's title. The placeholder in the WHERE clause represents the title of the paper being queried."
        },
        {
            "sample_id": 3523,
            "vt": "SELECT SUM(CASE WHEN journal.fullname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN journal.fullname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM journal INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId",
            "ba": "The virtual table calculates the difference between two sums based on the journal's full name from the 'journal' table. It uses conditional aggregation to sum values based on whether the journal's full name matches a specified value. The query joins the 'journal' table with the 'paper' table to access the relevant data for the calculation."
        },
        {
            "sample_id": 3628,
            "vt": "SELECT conference.fullname FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the full name of conferences from the 'conference' table where a specific paper title is associated with a conference. The placeholder in the WHERE clause represents the title of the paper."
        },
        {
            "sample_id": 3675,
            "vt": "SELECT conference.fullname, conference.homepage FROM conference WHERE conference.shortname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the full name and homepage URL of a conference from the 'conference' table that matches a specific short name. The placeholder in the WHERE clause represents the short name of the conference."
        },
        {
            "sample_id": 3677,
            "vt": "SELECT COUNT(paperauthor.paperid) FROM author INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.AuthorId WHERE author.affiliation = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of papers associated with authors from a specific affiliation. It joins the 'author' table with the 'paperauthor' table to link authors to their respective papers, filtering by the author's affiliation using a placeholder for the organization name."
        },
        {
            "sample_id": 3591,
            "vt": "SELECT paper.title FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paperauthor.name LIKE '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of papers from the 'paper' table that have been authored by individuals whose names match a specified pattern. The query uses an inner join with the 'paperauthor' table to connect papers with their respective authors, filtering based on the author's name using a placeholder for string values. Additionally, it limits the number of results returned using a numeric placeholder."
        },
        {
            "sample_id": 3539,
            "vt": "SELECT CAST(SUM(CASE WHEN paper.conferenceid = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(paper.conferenceid) FROM paper INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id WHERE paper.journalid BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND journal.shortname LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of a specific numeric value from the 'paper' table based on the conference ID, while also filtering results based on the journal ID range and the journal's short name. The placeholders represent the conference ID, numeric values for calculations, and the journal's short name for filtering."
        },
        {
            "sample_id": 3552,
            "vt": "SELECT paper.title, paper.year, paper.keyword FROM paperauthor INNER JOIN Paper AS T2 ON T1.PaperId = T2.Id WHERE paperauthor.authorid = [placeholder-type:numeric] AND paperauthor.affiliation = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles, publication years, and keywords of papers authored by a specific author affiliated with a particular organization. The placeholders in the WHERE clause represent the author's ID and the affiliation's name."
        },
        {
            "sample_id": 3584,
            "vt": "SELECT COUNT(paperauthor.paperid) FROM paperauthor WHERE paperauthor.affiliation LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of papers associated with authors from a specific affiliation in the 'paperauthor' table. The placeholder in the WHERE clause allows for filtering based on the author's affiliation, which is a string value."
        },
        {
            "sample_id": 3575,
            "vt": "SELECT DISTINCT paper.year, journal.fullname FROM journal INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE journal.shortname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct years and full names of journals from the 'journal' table that are associated with papers published in a specific journal identified by its short name. The placeholder in the WHERE clause represents the short name of the journal."
        },
        {
            "sample_id": 3510,
            "vt": "SELECT paper.title FROM journal INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE journal.fullname = '[placeholder-type:string]' AND paper.year = [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of papers published in a specific journal during a specified year. The placeholders in the WHERE clause represent the journal's full name and the publication year."
        },
        {
            "sample_id": 3676,
            "vt": "SELECT paper.title FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paperauthor.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of papers from the 'paper' table that have a specific author name associated with them. The query uses an INNER JOIN to connect the 'paper' table with the 'paperauthor' table, allowing it to filter results based on the author's name provided as a placeholder."
        },
        {
            "sample_id": 3650,
            "vt": "SELECT paper.year FROM conference INNER JOIN Paper AS T2 ON T1.Id = T2.ConferenceId WHERE conference.fullname = '[placeholder-type:string]' GROUP BY paper.year ORDER BY COUNT(paper.id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the years of papers presented at a specific conference, identified by its full name. It joins the 'conference' table with the 'paper' table to filter papers based on the conference they were presented at. The results are grouped by year and ordered by the count of papers, allowing for a limit on the number of years returned."
        },
        {
            "sample_id": 3668,
            "vt": "SELECT COUNT(paper.journalid) FROM journal INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE journal.fullname = '[placeholder-type:string]' AND paper.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of papers published in a specific journal within a given year range. It joins the 'journal' table with the 'paper' table to filter the results based on the journal's full name and the publication year of the papers."
        },
        {
            "sample_id": 3630,
            "vt": "SELECT DISTINCT conference.homepage FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique homepage URLs of conferences from the 'conference' table that are associated with a specific paper title from the 'paper' table. The query uses an INNER JOIN to connect the two tables based on the conference ID, ensuring that only relevant conference homepages are selected for the given paper title."
        },
        {
            "sample_id": 3664,
            "vt": "SELECT CAST(COUNT(DISTINCT T2.AuthorId) AS FLOAT) / COUNT(DISTINCT T1.Title) FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paper.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the ratio of distinct authors to distinct papers published within a specified year range. It joins the 'paper' table with the 'paperauthor' table to count the unique authors associated with each paper, and then divides this count by the total number of distinct paper titles published in that year range."
        },
        {
            "sample_id": 3594,
            "vt": "SELECT journal.fullname FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Journal AS T3 ON T1.JournalId = T3.Id WHERE paperauthor.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the full names of journals from the 'journal' table that have published papers authored by a specific author. The placeholder in the WHERE clause represents the author's name."
        },
        {
            "sample_id": 3645,
            "vt": "SELECT COUNT(paper.id) FROM conference INNER JOIN Paper AS T2 ON T1.Id = T2.ConferenceId WHERE conference.fullname = '[placeholder-type:string]' AND paper.year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of papers published in a specific conference during a particular year. It joins the 'conference' table with the 'paper' table based on the conference ID, filtering by the full name of the conference and the year of publication."
        },
        {
            "sample_id": 3521,
            "vt": "SELECT COUNT(paper.title) FROM paperauthor INNER JOIN Paper AS T2 ON T1.PaperId = T2.Id WHERE paperauthor.name = '[placeholder-type:string]' AND paper.year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of papers authored by a specific author in a given year. It joins the 'paperauthor' table with the 'paper' table to filter results based on the author's name and the publication year of the papers."
        },
        {
            "sample_id": 3660,
            "vt": "SELECT paperauthor.name, paperauthor.affiliation FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and affiliations of authors from the 'paperauthor' table who have contributed to a specific paper. The query joins the 'paper' table to filter results based on the title of the paper, using a placeholder for the title."
        },
        {
            "sample_id": 3541,
            "vt": "SELECT conference.fullname, conference.homepage FROM conference WHERE conference.shortname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the full name and homepage URL of a conference from the 'conference' table that matches a specific short name. The placeholder in the WHERE clause represents the short name of the conference."
        },
        {
            "sample_id": 3516,
            "vt": "SELECT paperauthor.name FROM paperauthor INNER JOIN Paper AS T2 ON T1.PaperId = T2.Id WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of authors from the 'paperauthor' table who have contributed to a specific paper. The query joins the 'paperauthor' table with the 'paper' table to filter authors based on the title of the paper provided as a placeholder."
        },
        {
            "sample_id": 3530,
            "vt": "SELECT paper.title, conference.shortname FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Conference AS T3 ON T1.ConferenceId = T3.Id WHERE paper.year = [placeholder-type:numeric] AND paperauthor.name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of papers along with their corresponding conference short names from the 'paper' table. It filters the results based on the publication year and the author's name, allowing users to find specific papers by a particular author in a given year."
        },
        {
            "sample_id": 3631,
            "vt": "SELECT COUNT(paperauthor.authorid) FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of authors associated with a specific paper title from the 'paper' table. It uses an inner join with the 'paperauthor' table to link papers to their respective authors. The placeholder in the WHERE clause represents the title of the paper being queried."
        },
        {
            "sample_id": 3607,
            "vt": "SELECT COUNT(author.name) FROM author WHERE author.affiliation = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of authors affiliated with a specific organization from the 'author' table. The placeholder in the WHERE clause represents the name of the organization."
        },
        {
            "sample_id": 3663,
            "vt": "SELECT COUNT(paper.id) FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE conference.fullname = '[placeholder-type:string]' AND paper.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of papers published in a specific conference within a given year range. It joins the 'paper' table with the 'conference' table to filter the results based on the conference's full name and the publication year of the papers."
        },
        {
            "sample_id": 3590,
            "vt": "SELECT conference.fullname FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE paper.id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the full name of a conference from the 'conference' table based on the conference ID associated with a specific paper in the 'paper' table. The placeholder in the WHERE clause represents the unique identifier of the paper."
        },
        {
            "sample_id": 3649,
            "vt": "SELECT paper.title, paper.journalid FROM paper INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id WHERE paper.year >= [placeholder-type:numeric] AND paper.year <= [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of papers along with their associated journal IDs from the 'paper' table, filtered by a specific range of publication years. The placeholders in the WHERE clause represent the start and end years for filtering the papers."
        },
        {
            "sample_id": 3641,
            "vt": "SELECT COUNT(paper.id) FROM paper WHERE paper.conferenceid = [placeholder-type:numeric] AND paper.journalid = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of papers from the 'paper' table that were published in a specific conference and a specific journal. The placeholders in the WHERE clause represent the IDs of the conference and journal respectively."
        },
        {
            "sample_id": 3567,
            "vt": "SELECT COUNT(paper.id) FROM paper WHERE paper.year BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND paper.conferenceid = [placeholder-type:numeric] AND paper.journalid = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of papers published in a specific conference and journal within a given year range. The placeholders represent the start and end years for filtering the papers, as well as the specific conference and journal identifiers."
        },
        {
            "sample_id": 3662,
            "vt": "SELECT conference.fullname FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the full name of conferences from the 'conference' table where a specific paper title is associated with a conference. The placeholder in the WHERE clause represents the title of the paper."
        },
        {
            "sample_id": 3597,
            "vt": "SELECT journal.shortname, journal.fullname FROM paper INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id WHERE paper.keyword LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the short and full names of journals from the 'journal' table that are associated with papers containing specific keywords. The placeholder in the WHERE clause represents the keyword to filter the papers."
        },
        {
            "sample_id": 3626,
            "vt": "SELECT paper.keyword FROM journal INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE journal.fullname = '[placeholder-type:string]' AND paper.year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves keywords associated with papers published in a specific journal during a particular year. It joins the 'journal' table with the 'paper' table based on the journal's ID, filtering results by the journal's full name and the publication year of the papers."
        },
        {
            "sample_id": 3637,
            "vt": "SELECT paper.title FROM paper WHERE paper.year > [placeholder-type:numeric] ORDER BY paper.year LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of papers from the 'paper' table that were published after a specific year. The results are ordered by the year of publication and limited to a specified number of entries."
        },
        {
            "sample_id": 3522,
            "vt": "SELECT CAST(COUNT(paper.id) AS FLOAT) / COUNT(DISTINCT T2.Year) FROM journal INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE journal.fullname = '[placeholder-type:string]' AND paper.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of papers published per year in a specific journal over a given range of years. It joins the 'journal' and 'paper' tables to filter papers based on the journal's full name and the specified year range."
        },
        {
            "sample_id": 3508,
            "vt": "SELECT COUNT(author.id) FROM author WHERE author.affiliation = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of authors affiliated with a specific organization from the 'author' table. The placeholder in the WHERE clause represents the name of the organization."
        },
        {
            "sample_id": 3544,
            "vt": "SELECT author.name, author.id FROM author WHERE author.affiliation = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and IDs of authors from the 'author' table who are affiliated with a specific organization. The placeholder in the WHERE clause represents the name of the organization with which the author is affiliated."
        },
        {
            "sample_id": 3532,
            "vt": "SELECT DISTINCT paper.title FROM paperauthor INNER JOIN Paper AS T2 ON T1.PaperId = T2.Id WHERE paperauthor.affiliation = '[placeholder-type:string]' AND paper.year = [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct titles of papers authored by individuals affiliated with a specific organization, filtered by the year of publication. The placeholders represent the author's affiliation and the publication year."
        },
        {
            "sample_id": 3543,
            "vt": "SELECT CAST(SUM(CASE WHEN author.affiliation IS NULL THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / COUNT(*) FROM author",
            "ba": "The virtual table calculates the ratio of authors with missing affiliations to the total number of authors from the 'author' table. It uses a conditional SUM to count the number of authors without an affiliation and divides it by the total count of authors, providing a measure of how many authors lack this information."
        },
        {
            "sample_id": 3572,
            "vt": "SELECT paperauthor.affiliation FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paper.keyword = '[placeholder-type:string]'",
            "ba": "The virtual table describes the affiliations of authors from the 'paperauthor' table for papers that contain a specific keyword. The query joins the 'paper' table with the 'paperauthor' table to filter the results based on the keyword associated with the papers."
        },
        {
            "sample_id": 3653,
            "vt": "SELECT journal.homepage FROM paper INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id GROUP BY paper.journalid ORDER BY COUNT(paper.journalid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the homepage URLs of journals from the 'journal' table that are associated with papers in the 'paper' table. It uses an inner join to connect the two tables based on the journal ID, groups the results by journal ID, and orders them by the count of papers associated with each journal. The result is limited to a specified number of entries."
        },
        {
            "sample_id": 3514,
            "vt": "SELECT COUNT(paper.id) FROM journal INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE paper.year = [placeholder-type:numeric] AND journal.shortname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of papers published in a specific journal during a specified year. It joins the 'journal' table with the 'paper' table based on the journal ID, filtering the results by the publication year and the journal's short name."
        },
        {
            "sample_id": 3602,
            "vt": "SELECT paper.title, paperauthor.name FROM paperauthor INNER JOIN Paper AS T2 ON T1.PaperId = T2.Id WHERE paperauthor.affiliation = '[placeholder-type:string]' AND paper.year = [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of papers along with the names of their authors from the 'paperauthor' table, filtered by a specific author affiliation and the publication year of the papers. The placeholders represent the author's affiliation and the year of publication."
        },
        {
            "sample_id": 3578,
            "vt": "SELECT paperauthor.name FROM paperauthor INNER JOIN Paper AS T2 ON T1.PaperId = T2.Id WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of authors from the 'paperauthor' table who have contributed to a specific paper. The query joins the 'paperauthor' table with the 'paper' table to filter authors based on the title of the paper. The placeholder in the WHERE clause represents the title of the paper being queried."
        },
        {
            "sample_id": 3533,
            "vt": "SELECT paperauthor.name, journal.shortname FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Journal AS T3 ON T1.JournalId = T3.Id WHERE paper.journalid BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND paper.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of authors and the short names of journals from the 'paper', 'paperauthor', and 'journal' tables. It filters the results based on a range of journal IDs and a specific title pattern for the papers."
        },
        {
            "sample_id": 3680,
            "vt": "SELECT author.name, paper.keyword FROM author INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.AuthorId INNER JOIN Paper AS T3 ON T2.PaperId = T3.Id WHERE paperauthor.paperid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of authors and the keywords associated with their papers. It retrieves data from the 'author' table and joins it with the 'paperauthor' and 'paper' tables to filter results based on a specific paper ID. The placeholder in the WHERE clause represents the unique identifier of the paper."
        },
        {
            "sample_id": 3632,
            "vt": "SELECT conference.shortname FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE paper.year = '[placeholder-type:string]' GROUP BY paper.conferenceid ORDER BY COUNT(paper.id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the short names of conferences from the 'conference' table where papers were published in a specific year. The query joins the 'paper' table with the 'conference' table to filter the results based on the year of publication. It groups the results by conference ID and orders them by the count of papers associated with each conference, limiting the output to a specified number of results."
        },
        {
            "sample_id": 3635,
            "vt": "SELECT CAST(SUM(CASE WHEN conference.fullname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN conference.fullname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id",
            "ba": "The virtual table calculates the ratio of the total number of papers published in a specific conference to the total number of papers published overall. It uses a conditional aggregation to sum the papers based on whether they belong to the specified conference, and divides this by the total sum of papers. The placeholders represent the conference's full name and numeric values for counting papers."
        },
        {
            "sample_id": 3674,
            "vt": "SELECT COUNT(author.name) FROM author WHERE author.affiliation = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of authors affiliated with a specific organization from the 'author' table. The placeholder in the WHERE clause represents the name of the organization."
        },
        {
            "sample_id": 3564,
            "vt": "SELECT COUNT(DISTINCT T2.Name) FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paper.title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct authors of a specific paper based on its title. It joins the 'paper' table with the 'paperauthor' table to find all authors associated with that paper."
        },
        {
            "sample_id": 3537,
            "vt": "SELECT journal.homepage, paperauthor.authorid FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Journal AS T3 ON T1.JournalId = T3.Id WHERE paper.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND paper.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table provides the homepage URLs of journals along with the author IDs for papers published within a specific year range and matching a certain title pattern. The placeholders allow users to specify the year range and title criteria dynamically."
        },
        {
            "sample_id": 3563,
            "vt": "SELECT paperauthor.name FROM paper INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE paper.year = [placeholder-type:numeric] AND paper.keyword = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of authors from the 'paperauthor' table for papers published in a specific year and with a specific keyword. The query joins the 'paper' table to filter papers based on their publication year and keyword, using placeholders for the year and keyword values."
        },
        {
            "sample_id": 3542,
            "vt": "SELECT author.affiliation FROM author WHERE author.affiliation IN ('[placeholder-type:string]', '[placeholder-type:string]') GROUP BY author.affiliation ORDER BY COUNT(author.id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the affiliations of authors from the 'author' table, filtering for specific affiliations provided as placeholders. It groups the results by affiliation and orders them based on the count of authors associated with each affiliation, limiting the output to a specified number of results."
        },
        {
            "sample_id": 3531,
            "vt": "SELECT COUNT(paper.conferenceid), conference.homepage FROM conference INNER JOIN Paper AS T2 ON T1.Id = T2.ConferenceId WHERE paper.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND paper.conferenceid = [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of papers published in a specific conference within a given year range, along with the homepage URL of that conference. The placeholders represent the year range and the conference ID."
        },
        {
            "sample_id": 3548,
            "vt": "SELECT paper.id, paper.year, paper.keyword FROM paperauthor INNER JOIN Paper AS T2 ON T1.PaperId = T2.Id WHERE paperauthor.authorid < [placeholder-type:numeric] AND paperauthor.affiliation = '[placeholder-type:string]'",
            "ba": "The virtual table describes the details of papers authored by a specific author, including the paper ID, year of publication, and keywords associated with the paper. The query filters the results based on the author's ID and their affiliation, allowing users to retrieve information about papers linked to a particular author and organization."
        },
        {
            "sample_id": 3573,
            "vt": "SELECT conference.fullname FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE paper.conferenceid <> [placeholder-type:numeric] AND paper.journalid = [placeholder-type:numeric] AND paper.year <> [placeholder-type:numeric]",
            "ba": "The virtual table describes the full names of conferences from the 'conference' table that are associated with papers in the 'paper' table. The query filters out papers that are linked to a specific conference ID, while also ensuring that the journal ID matches a specified value and the year of publication is not equal to a certain year. This allows users to retrieve conference names for papers that meet these criteria."
        },
        {
            "sample_id": 3583,
            "vt": "SELECT CAST((SUM(CASE WHEN journal.shortname LIKE '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END)) AS FLOAT) * [placeholder-type:numeric] / COUNT(journal.shortname) FROM journal INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE paper.year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average of a specific metric based on the short name of journals from the 'journal' table. It sums up values conditionally based on whether the journal's short name matches a specified pattern, multiplies this sum by a numeric placeholder, and divides it by the count of journal short names. The results are filtered to include only papers from a specific year, indicated by a numeric placeholder."
        },
        {
            "sample_id": 3621,
            "vt": "SELECT SUM(CASE WHEN conference.fullname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN conference.fullname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE paper.year > [placeholder-type:numeric] AND paper.year < [placeholder-type:numeric]",
            "ba": "The virtual table calculates the difference between two sums based on the conference's full name and the publication year of papers. It uses conditional aggregation to sum values based on whether the conference's full name matches a specified string. The query filters papers published within a specific range of years."
        },
        {
            "sample_id": 3528,
            "vt": "SELECT DISTINCT paper.title, conference.shortname FROM paper INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE paper.conferenceid BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct titles of papers along with their corresponding short names from the 'conference' table. It retrieves this information by joining the 'paper' table with the 'conference' table based on the conference ID. The query filters the results to include only those papers whose conference IDs fall within a specified numeric range."
        },
        {
            "sample_id": 3672,
            "vt": "SELECT COUNT(paperauthor.paperid) FROM paperauthor WHERE paperauthor.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of papers associated with a specific author based on their name from the 'paperauthor' table. The placeholder in the WHERE clause represents the author's name."
        }
    ],
    "regional_sales": [
        {
            "sample_id": 2703,
            "vt": "SELECT sales team.\"sales team\" FROM \"sales orders\" INNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE REPLACE(sales orders.\"unit price\", ',', '') = (SELECT REPLACE(sales orders.\"unit price\", ',', '') FROM \"Sales Orders\" AS T1 INNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID ORDER BY REPLACE(T1.\"Unit Price\", ',', '') DESC LIMIT 1) ORDER BY REPLACE(sales orders.\"unit price\", ',', '') LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of sales teams from the 'sales orders' table, specifically those associated with the highest unit price of orders. It uses an inner join to connect the 'sales orders' table with the 'sales team' table based on the sales team ID. The query filters for sales orders that have a unit price equal to the maximum unit price found in the 'sales orders' table, and it limits the results to a specified number of sales teams."
        },
        {
            "sample_id": 2643,
            "vt": "SELECT CAST(SUM(CASE WHEN REPLACE(sales orders.\"unit price\", ',', '') - REPLACE(sales orders.\"unit cost\", ',', '') > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(sales orders.ordernumber) FROM \"sales orders\" INNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE sales team.\"sales team\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average profit margin for a specific sales team by summing the profits from sales orders where the profit exceeds a certain threshold. It uses placeholders for the profit threshold and a multiplier to adjust the final result, while filtering the results based on the sales team's name."
        },
        {
            "sample_id": 2675,
            "vt": "SELECT SUM(CASE WHEN sales orders.\"order quantity\" = [placeholder-type:numeric] AND sales orders.\"sales channel\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"sales orders\"",
            "ba": "The virtual table calculates the total order quantity from the 'sales orders' table based on specific conditions. It sums the order quantities where the order quantity matches a specified numeric value and the sales channel matches a specified string value. The placeholders represent the values that can be modified by the user to filter the results accordingly."
        },
        {
            "sample_id": 2684,
            "vt": "SELECT products.\"product name\", customers.\"customer names\" FROM customers INNER JOIN \"Sales Orders\" AS T2 ON T2._CustomerID = T1.CustomerID INNER JOIN Products AS T3 ON T3.ProductID = T2._ProductID WHERE sales orders.orderdate = '[placeholder-type:string]' AND sales orders.deliverydate = '[placeholder-type:string]'",
            "ba": "The virtual table describes the product names and customer names from the 'customers' and 'products' tables, respectively. It retrieves this information by joining the 'sales orders' table to link customers with their orders and products. The placeholders in the WHERE clause represent specific order and delivery dates for filtering the results."
        },
        {
            "sample_id": 2622,
            "vt": "SELECT SUM(CASE WHEN sales orders.\"discount applied\" = [placeholder-type:numeric] AND customers.\"customer names\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"sales orders\" INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID",
            "ba": "The virtual table calculates the total order quantity from the 'sales orders' table, applying a condition based on the discount applied and the customer's name. It joins the 'sales orders' table with the 'customers' table to filter the results based on the specified customer name and discount value."
        },
        {
            "sample_id": 2598,
            "vt": "SELECT customers.\"customer names\", sales orders.deliverydate FROM customers INNER JOIN \"Sales Orders\" AS T2 ON T2._CustomerID = T1.CustomerID INNER JOIN Products AS T3 ON T3.ProductID = T2._ProductID WHERE sales orders.\"sales channel\" = '[placeholder-type:string]' AND products.\"product name\" = '[placeholder-type:string]' AND sales orders.orderdate LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of customers and their corresponding delivery dates from the 'customers' and 'sales orders' tables. It filters the results based on a specific sales channel, product name, and order date using placeholders for string values."
        },
        {
            "sample_id": 2637,
            "vt": "SELECT SUM(CASE WHEN store locations.county = '[placeholder-type:string]' AND sales orders.orderdate LIKE '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"sales orders\" INNER JOIN \"Store Locations\" AS T2 ON T2.StoreID = T1._StoreID",
            "ba": "The virtual table summarizes the total order quantity from the 'sales orders' table for a specific county and order date. The placeholders represent the county name and the order date, allowing users to filter the results based on their input."
        },
        {
            "sample_id": 2580,
            "vt": "SELECT DISTINCT customers.\"customer names\" FROM customers INNER JOIN \"Sales Orders\" AS T2 ON T2._CustomerID = T1.CustomerID INNER JOIN Products AS T3 ON T3.ProductID = T2._ProductID WHERE products.\"product name\" = '[placeholder-type:string]' AND SUBSTRING(sales orders.orderdate, -[placeholder-type:numeric]) = '[placeholder-type:string]' AND sales orders.\"discount applied\" = (SELECT sales orders.\"discount applied\" FROM Customers AS T1 INNER JOIN \"Sales Orders\" AS T2 ON T2._CustomerID = T1.CustomerID INNER JOIN Products AS T3 ON T3.ProductID = T2._ProductID WHERE T3.\"Product Name\" = 'Cocktail Glasses' AND T2.OrderDate LIKE '%/%/20' ORDER BY T2.\"Discount Applied\" DESC LIMIT 1)",
            "ba": "The virtual table retrieves distinct customer names from the 'customers' table who have placed orders for a specific product and meet certain criteria regarding the order date and discount applied. The query joins the 'customers' table with the 'sales orders' table and the 'products' table to filter based on the product name and the order date substring, while also checking for a specific discount applied that is determined by a subquery."
        },
        {
            "sample_id": 2691,
            "vt": "SELECT sales team.region FROM \"sales orders\" INNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE sales orders.warehousecode = '[placeholder-type:string]' GROUP BY sales team.region ORDER BY COUNT(sales orders.ordernumber) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the regions associated with sales orders from a specific warehouse. It retrieves the region from the 'sales team' table by joining it with the 'sales orders' table based on the sales team ID. The results are grouped by region and ordered by the count of orders, allowing users to see which regions have the most sales from that warehouse, with a limit on the number of results returned."
        },
        {
            "sample_id": 2706,
            "vt": "SELECT DISTINCT sales orders.ordernumber, sales orders.warehousecode FROM \"sales orders\" INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID WHERE customers.\"customer names\" = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of order numbers and their corresponding warehouse codes from the 'sales orders' table, filtered by a specific customer's name. The placeholder in the WHERE clause represents the name of the customer being queried."
        },
        {
            "sample_id": 2698,
            "vt": "SELECT AVG(store locations.\"land area\") FROM \"sales orders\" INNER JOIN \"Store Locations\" AS T2 ON T2.StoreID = T1._StoreID WHERE sales orders.\"unit price\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average land area of store locations based on sales orders where the unit price matches a specified value. It joins the 'sales orders' table with the 'store locations' table using the store ID to ensure that the land area is associated with the correct store for which the sales order was made. The placeholder in the WHERE clause represents the unit price of the products sold."
        },
        {
            "sample_id": 2682,
            "vt": "SELECT subquery_q0.t FROM (SELECT DISTINCT CASE WHEN sales orders.warehousecode = '[placeholder-type:string]' THEN regions.region END FROM Regions AS T1 INNER JOIN \"Store Locations\" AS T2 ON T2.StateCode = T1.StateCode INNER JOIN \"Sales Orders\" AS T3 ON T3._StoreID = T2.StoreID) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table identifies distinct regions from the 'Regions' table based on the warehouse code from the 'Sales Orders' table. It joins the 'Store Locations' table to filter the results according to the state code, ensuring that only relevant regions are selected. The placeholder in the WHERE clause represents the specific warehouse code being queried."
        },
        {
            "sample_id": 2615,
            "vt": "SELECT SUM(REPLACE(sales orders.\"unit price\", ',', '') - REPLACE(sales orders.\"unit cost\", ',', '')) / COUNT(sales orders.ordernumber) FROM \"sales orders\" INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID WHERE products.\"product name\" = '[placeholder-type:string]' AND sales orders.\"order quantity\" > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average profit per order for a specific product from the 'sales orders' table. It does this by summing the difference between the 'unit price' and 'unit cost' of the product, while also counting the number of orders for that product. The query filters the results based on the product name and ensures that only orders with a quantity greater than a specified number are included."
        },
        {
            "sample_id": 2737,
            "vt": "SELECT AVG(store locations.\"household income\") FROM \"store locations\" WHERE store locations.\"city name\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average household income from the 'store locations' table for a specific city. The placeholder in the WHERE clause represents the name of the city for which the average household income is being calculated."
        },
        {
            "sample_id": 2678,
            "vt": "SELECT COUNT(DISTINCT T) FROM (SELECT CASE WHEN regions.region = '[placeholder-type:string]' THEN regions.state ELSE NULL END FROM Regions) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table counts the distinct states from the 'Regions' table that belong to a specific region. The placeholder in the WHERE clause represents the region's name."
        },
        {
            "sample_id": 2709,
            "vt": "SELECT SUM(CASE WHEN store locations.state = '[placeholder-type:string]' THEN sales orders.\"unit price\" ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN store locations.state = '[placeholder-type:string]' THEN sales orders.\"unit price\" ELSE [placeholder-type:numeric] END) FROM products INNER JOIN \"Sales Orders\" AS T2 ON T2._ProductID = T1.ProductID INNER JOIN \"Store Locations\" AS T3 ON T3.StoreID = T2._StoreID WHERE products.\"product name\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between the total unit price of products sold in a specific state and the total unit price of products sold in other states. It uses placeholders for the state name and product name to allow users to specify their desired values."
        },
        {
            "sample_id": 2605,
            "vt": "SELECT SUM(CASE WHEN sales orders.orderdate = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"sales orders\"",
            "ba": "The virtual table calculates the total order quantity from the 'sales orders' table for a specific order date. The placeholder in the SUM function represents the order date, while the numeric placeholders represent the quantities to be summed based on the condition."
        },
        {
            "sample_id": 2681,
            "vt": "SELECT DISTINCT sales team.\"sales team\" FROM customers INNER JOIN \"Sales Orders\" AS T2 ON T2._CustomerID = T1.CustomerID INNER JOIN \"Sales Team\" AS T3 ON T3.SalesTeamID = T2._SalesTeamID WHERE customers.\"customer names\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct sales team names associated with a specific customer from the 'customers' and 'sales orders' tables. The query joins these tables based on the customer ID and further joins the 'sales team' table to retrieve the sales team names. The placeholder in the WHERE clause represents the name of the customer."
        },
        {
            "sample_id": 2661,
            "vt": "SELECT SUM(CASE WHEN sales orders.warehousecode = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN sales orders.warehousecode = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"sales orders\"",
            "ba": "The virtual table calculates the difference in total order quantities from two different warehouse codes in the 'sales orders' table. The placeholders represent the warehouse codes and the quantities to be summed for each condition."
        },
        {
            "sample_id": 2634,
            "vt": "SELECT sales orders.ordernumber FROM \"sales orders\" WHERE REPLACE(sales orders.\"unit price\", ',', '') = (SELECT REPLACE(sales orders.\"unit price\", ',', '') FROM \"Sales Orders\" ORDER BY REPLACE(\"Unit Price\", ',', '') DESC LIMIT 1)",
            "ba": "The virtual table retrieves the order numbers from the 'sales orders' table where the unit price matches the highest unit price found in the same table. The placeholder in the query represents the unit price, which is formatted to remove any commas for accurate comparison."
        },
        {
            "sample_id": 2729,
            "vt": "SELECT CAST(COUNT(sales orders.ordernumber) AS FLOAT) / [placeholder-type:numeric] FROM \"sales orders\" INNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE (sales team.\"sales team\" = '[placeholder-type:string]' AND sales orders.shipdate LIKE '[placeholder-type:string]') OR (sales team.\"sales team\" = '[placeholder-type:string]' AND sales orders.shipdate LIKE '[placeholder-type:string]') OR (sales team.\"sales team\" = '[placeholder-type:string]' AND sales orders.shipdate LIKE '[placeholder-type:string]')",
            "ba": "The virtual table calculates the average number of sales orders shipped by a specific sales team over a given period. It joins the 'sales orders' table with the 'sales team' table to filter results based on the sales team name and the shipping date. The placeholders represent the sales team name and the specific shipping dates for which the average is calculated."
        },
        {
            "sample_id": 2594,
            "vt": "SELECT DISTINCT store locations.storeid, store locations.\"city name\", regions.region FROM regions INNER JOIN \"Store Locations\" AS T2 ON T2.StateCode = T1.StateCode WHERE store locations.county = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique store IDs, city names, and regions from the 'store locations' and 'regions' tables. It filters the results based on a specific county, using a placeholder for the county name."
        },
        {
            "sample_id": 2600,
            "vt": "SELECT DISTINCT store locations.\"city name\" FROM regions INNER JOIN \"Store Locations\" AS T2 ON T2.StateCode = T1.StateCode WHERE store locations.state = '[placeholder-type:string]' AND store locations.\"water area\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct city names from the 'store locations' table that are associated with a specific state and have a specified water area. The query uses an inner join between the 'regions' and 'store locations' tables to filter the results based on the state and water area criteria."
        },
        {
            "sample_id": 2720,
            "vt": "SELECT products.\"product name\" FROM \"sales orders\" INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID ORDER BY REPLACE(sales orders.\"unit price\", ',', '') - REPLACE(sales orders.\"unit cost\", ',', '') LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of products from the 'products' table that are associated with sales orders. It calculates the net profit for each product by subtracting the unit cost from the unit price, and orders the results based on this profit. The query limits the number of results returned based on a specified numeric placeholder."
        },
        {
            "sample_id": 2696,
            "vt": "SELECT store locations.latitude, store locations.longitude FROM \"sales orders\" INNER JOIN \"Store Locations\" AS T2 ON T2.StoreID = T1._StoreID WHERE sales orders.warehousecode = '[placeholder-type:string]' GROUP BY store locations.storeid ORDER BY COUNT(sales orders.warehousecode) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the latitude and longitude of store locations from the 'sales orders' table, filtered by a specific warehouse code. It groups the results by store ID and orders them based on the count of sales orders associated with each warehouse, limiting the output to a specified number of results."
        },
        {
            "sample_id": 2583,
            "vt": "SELECT DISTINCT subquery_q0.t FROM (SELECT CASE WHEN sales orders.orderdate LIKE '[placeholder-type:string]' AND customers.\"customer names\" = '[placeholder-type:string]' THEN sales orders.ordernumber ELSE NULL END FROM \"Sales Orders\" AS T1 INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table retrieves distinct order numbers from the 'Sales Orders' table based on specific conditions related to the order date and customer name. It uses a subquery to check if the order date matches a specified pattern and if the customer's name matches a given name, returning the order number if both conditions are met."
        },
        {
            "sample_id": 2645,
            "vt": "SELECT DISTINCT store locations.\"city name\", store locations.latitude, store locations.longitude FROM \"store locations\" WHERE store locations.county = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct city names along with their latitude and longitude from the 'store locations' table for a specific county. The placeholder in the WHERE clause represents the name of the county."
        },
        {
            "sample_id": 2631,
            "vt": "SELECT sales team.\"sales team\" FROM \"sales orders\" INNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE sales orders.orderdate LIKE '[placeholder-type:string]' GROUP BY sales team.\"sales team\" ORDER BY COUNT(sales orders.ordernumber) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of sales team names from the 'sales orders' table, filtered by a specific order date. It joins the 'sales orders' table with the 'sales team' table to associate each order with its corresponding sales team. The results are grouped by sales team names and ordered by the count of orders, allowing for a limit on the number of results returned."
        },
        {
            "sample_id": 2735,
            "vt": "SELECT customers.\"customer names\" FROM customers INNER JOIN \"Sales Orders\" AS T2 ON T2._CustomerID = T1.CustomerID INNER JOIN \"Store Locations\" AS T3 ON T3.StoreID = T2._StoreID WHERE store locations.\"city name\" = '[placeholder-type:string]' AND sales orders.procureddate LIKE '[placeholder-type:string]' ORDER BY REPLACE(sales orders.\"unit price\", ',', '') - REPLACE(sales orders.\"unit cost\", ',', '') LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of customers who have placed orders from specific store locations in a given city, filtered by the procurement date of the orders. The placeholders represent the city name, procurement date, and limit for the number of results."
        },
        {
            "sample_id": 2674,
            "vt": "SELECT DISTINCT subquery_q0.t FROM (SELECT CASE WHEN sales orders._customerid = [placeholder-type:numeric] THEN sales orders.procureddate ELSE NULL END FROM \"Sales Orders\") WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table provides a distinct list of procurement dates from the 'sales orders' table for a specific customer, identified by their unique customer ID. The placeholder in the WHERE clause allows for the input of a specific customer ID to filter the results accordingly."
        },
        {
            "sample_id": 2588,
            "vt": "SELECT sales orders.ordernumber, REPLACE(sales orders.\"unit price\", ',', '') - REPLACE(sales orders.\"unit cost\", ',', '') FROM \"sales orders\" INNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE sales team.\"sales team\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the order numbers and net profit (calculated as unit price minus unit cost) from the 'sales orders' table for a specific sales team. The placeholder in the WHERE clause represents the name of the sales team."
        },
        {
            "sample_id": 2715,
            "vt": "SELECT CASE WHEN MAX(store locations.population) THEN store locations.storeid END FROM \"store locations\"",
            "ba": "The virtual table identifies the store with the maximum population from the 'store locations' table. It uses a conditional statement to return the store ID if the maximum population is found."
        },
        {
            "sample_id": 2683,
            "vt": "SELECT subquery_q0.t FROM (SELECT DISTINCT CASE WHEN products.\"product name\" = '[placeholder-type:string]' AND sales team.\"sales team\" = '[placeholder-type:string]' THEN store locations.\"city name\" ELSE NULL END FROM \"Store Locations\" AS T1 INNER JOIN \"Sales Orders\" AS T2 ON T2._StoreID = T1.StoreID INNER JOIN \"Sales Team\" AS T3 ON T3.SalesTeamID = T2._SalesTeamID INNER JOIN Products AS T4 ON T4.ProductID = T2._ProductID) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table describes the distinct city names from the 'Store Locations' table where a specific product name and sales team name match the provided placeholders. It uses inner joins to connect the 'Sales Orders', 'Sales Team', and 'Products' tables to filter the results based on the specified product and sales team."
        },
        {
            "sample_id": 2730,
            "vt": "SELECT sales orders.\"unit price\" * sales orders.\"discount applied\", products.\"product name\" FROM \"sales orders\" INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID ORDER BY REPLACE(sales orders.\"unit price\", ',', '') - REPLACE(sales orders.\"unit cost\", ',', '') LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total price after discount for each product sold in the sales orders, displaying the product name alongside. It joins the sales orders with the products table based on the product ID, and orders the results by the net profit (unit price minus unit cost). The limit on the number of results is specified by a placeholder for numeric values."
        },
        {
            "sample_id": 2608,
            "vt": "SELECT subquery_q0.t FROM (SELECT CASE WHEN regions.statecode = '[placeholder-type:string]' THEN regions.state ELSE NULL END FROM Regions) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table retrieves the full state name from the 'regions' table based on a specific state code. The placeholder in the WHERE clause represents the state code that is being queried."
        },
        {
            "sample_id": 2663,
            "vt": "SELECT DISTINCT store locations.storeid, regions.region FROM regions INNER JOIN \"Store Locations\" AS T2 ON T2.StateCode = T1.StateCode WHERE store locations.state = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique store IDs and their corresponding regions from the 'store locations' and 'regions' tables. The query filters the results based on a specific state, represented by a placeholder for string values."
        },
        {
            "sample_id": 2609,
            "vt": "SELECT COUNT(DISTINCT T) FROM (SELECT CASE WHEN regions.region = '[placeholder-type:string]' THEN regions.statecode ELSE NULL END FROM Regions) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table counts the distinct state codes from the 'regions' table where the region matches a specified value. The placeholder in the WHERE clause represents the region's name."
        },
        {
            "sample_id": 2578,
            "vt": "SELECT sales team.\"sales team\", sales team.region FROM \"sales orders\" INNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE sales orders.ordernumber = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the sales team and the region associated with a specific sales order. It retrieves the sales team name and the corresponding region by joining the 'sales orders' table with the 'sales team' table based on the sales team ID. The placeholder in the WHERE clause represents the unique order number for which the details are being queried."
        },
        {
            "sample_id": 2619,
            "vt": "SELECT subquery_q0.t FROM (SELECT DISTINCT CASE WHEN customers.\"customer names\" = '[placeholder-type:string]' THEN sales orders.\"discount applied\" END FROM Customers AS T1 INNER JOIN \"Sales Orders\" AS T2 ON T2._CustomerID = T1.CustomerID) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table retrieves distinct discount values applied to sales orders for a specific customer from the 'Customers' table. It uses a subquery to join the 'Sales Orders' table with the 'Customers' table based on the customer ID, filtering for a specific customer name. The result will show discounts that were applied to orders made by that customer."
        },
        {
            "sample_id": 2732,
            "vt": "SELECT sales orders.\"sales channel\" FROM \"sales orders\" WHERE sales orders.orderdate LIKE '[placeholder-type:string]' GROUP BY sales orders.\"sales channel\" ORDER BY COUNT(sales orders.\"sales channel\") LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the sales channels used for orders placed on a specific date from the 'sales orders' table. It groups the results by the sales channel and orders them based on the count of orders for each channel, allowing users to see which sales channels were most utilized on that date. The placeholders represent the date of the orders and the limit on the number of results returned."
        },
        {
            "sample_id": 2724,
            "vt": "SELECT customers.\"customer names\" FROM (SELECT customers.\"customer names\", sales orders.\"unit price\" - sales orders.\"unit cost\" FROM Customers AS T1 INNER JOIN \"Sales Orders\" AS T2 ON T2._CustomerID = T1.CustomerID) ORDER BY subquery_q0.\"net profit\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of customers along with their net profit from sales orders. It retrieves customer names from the 'customers' table and calculates net profit by subtracting the unit cost from the unit price in the 'sales orders' table. The results are ordered by net profit, and a limit is applied to restrict the number of records returned."
        },
        {
            "sample_id": 2575,
            "vt": "SELECT sales team.region FROM \"sales team\" GROUP BY sales team.region ORDER BY COUNT(DISTINCT \"Sales Team\") LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the regions associated with sales teams from the 'sales team' table. It groups the results by region and orders them based on the count of distinct sales teams in each region, limiting the output to a specified number of regions."
        },
        {
            "sample_id": 2654,
            "vt": "SELECT DISTINCT sales orders.ordernumber, products.\"product name\" FROM \"sales orders\" INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID WHERE sales orders.\"sales channel\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique order numbers and product names from the 'sales orders' table, filtered by a specific sales channel. The placeholder in the WHERE clause represents the sales channel type, such as In-Store, Online, Distributor, or Wholesale."
        },
        {
            "sample_id": 2688,
            "vt": "SELECT MAX(sales orders.\"discount applied\") FROM \"sales orders\" INNER JOIN \"Store Locations\" AS T2 ON T2.StoreID = T1._StoreID WHERE store locations.state = '[placeholder-type:string]' AND store locations.\"land area\" = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the maximum discount applied from the 'sales orders' table, filtering the results based on the state and land area of the store locations. The placeholders represent the specific state name and land area value."
        },
        {
            "sample_id": 2616,
            "vt": "SELECT subquery_q0.t FROM (SELECT DISTINCT CASE WHEN regions.region = '[placeholder-type:string]' THEN store locations.\"city name\" END FROM Regions AS T1 INNER JOIN \"Store Locations\" AS T2 ON T2.StateCode = T1.StateCode) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table lists distinct city names from the 'store locations' table that belong to a specific region identified in the 'regions' table. The placeholder in the WHERE clause represents the region's name."
        },
        {
            "sample_id": 2655,
            "vt": "SELECT SUM(CASE WHEN sales orders.orderdate LIKE '[placeholder-type:string]' AND sales orders.\"sales channel\" = '[placeholder-type:string]' AND store locations.\"city name\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"sales orders\" INNER JOIN \"Store Locations\" AS T2 ON T2.StoreID = T1._StoreID",
            "ba": "The virtual table summarizes the total order quantity from the 'sales orders' table based on specific conditions. It filters the orders by a given order date, sales channel, and city name from the 'store locations' table. The placeholders represent the values that can be modified to generate specific queries for different scenarios."
        },
        {
            "sample_id": 2641,
            "vt": "SELECT SUM(CASE WHEN SUBSTRING(sales orders.orderdate, -[placeholder-type:numeric]) IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]') AND customers.\"customer names\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"sales orders\" INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID",
            "ba": "The virtual table calculates the total order quantity from the 'sales orders' table for specific order dates and a particular customer name. It uses a conditional sum to check if the last few characters of the order date match any of the specified values, and if the customer name matches the given placeholder. The result will provide insights into the order quantities for that customer during the specified time frame."
        },
        {
            "sample_id": 2635,
            "vt": "SELECT sales orders._salesteamid FROM \"sales orders\" WHERE sales orders.orderdate LIKE '[placeholder-type:string]' GROUP BY sales orders._salesteamid ORDER BY COUNT(sales orders._salesteamid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the sales team IDs from the 'sales orders' table for orders placed on a specific date. The results are grouped by sales team ID and ordered by the count of orders for each team, allowing for the identification of the most active sales teams on that date. The placeholders represent the order date and the limit on the number of results returned."
        },
        {
            "sample_id": 2676,
            "vt": "SELECT DISTINCT subquery_q0.t FROM (SELECT CASE WHEN sales orders.\"discount applied\" = '[placeholder-type:string]' AND sales orders.\"sales channel\" = '[placeholder-type:string]' THEN sales orders._salesteamid ELSE NULL END FROM \"Sales Orders\") WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table identifies unique sales team IDs from the 'Sales Orders' table based on specific conditions related to discount applied and sales channel. The placeholders represent the values for discount and sales channel that the user can specify."
        },
        {
            "sample_id": 2734,
            "vt": "SELECT sales team.\"sales team\", store locations.\"city name\" FROM \"store locations\" INNER JOIN \"Sales Orders\" AS T2 ON T2._StoreID = T1.StoreID INNER JOIN \"Sales Team\" AS T3 ON T3.SalesTeamID = T2._SalesTeamID WHERE sales orders.ordernumber = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of sales team names along with the corresponding city names from the store locations. It combines data from the 'store locations', 'sales orders', and 'sales team' tables using inner joins based on the relationships defined by foreign keys. The query filters results based on a specific order number, represented by a placeholder for string values."
        },
        {
            "sample_id": 2639,
            "vt": "SELECT COUNT(sales orders.ordernumber) FROM \"sales orders\" INNER JOIN \"Store Locations\" AS T2 ON T2.StoreID = T1._StoreID WHERE sales orders.orderdate LIKE '[placeholder-type:string]' GROUP BY store locations.\"city name\" HAVING COUNT(sales orders.ordernumber)",
            "ba": "The virtual table counts the number of sales orders from the 'sales orders' table, joining it with the 'store locations' table to filter by store ID. It groups the results by city name and applies a condition to count only those orders that match a specific order date, represented by a placeholder."
        },
        {
            "sample_id": 2662,
            "vt": "SELECT subquery_q0.t FROM (SELECT DISTINCT CASE WHEN sales orders.deliverydate LIKE '[placeholder-type:string]' AND customers.\"customer names\" = '[placeholder-type:string]' THEN products.\"product name\" END FROM Customers AS T1 INNER JOIN \"Sales Orders\" AS T2 ON T2._CustomerID = T1.CustomerID INNER JOIN Products AS T3 ON T3.ProductID = T2._ProductID) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table describes the distinct product names from the 'Products' table that have been ordered by a specific customer, filtered by the delivery date. The placeholders represent the delivery date and the customer's name."
        },
        {
            "sample_id": 2722,
            "vt": "SELECT subquery_q0.t FROM (SELECT DISTINCT CASE WHEN store locations.\"median income\" < [placeholder-type:numeric] THEN regions.region END FROM Regions AS T1 INNER JOIN \"Store Locations\" AS T2 ON T2.StateCode = T1.StateCode) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table identifies distinct regions based on the median income of store locations. It selects regions where the median income is below a specified threshold, ensuring that only relevant regions are included in the results. The placeholder represents the income threshold for filtering the regions."
        },
        {
            "sample_id": 2644,
            "vt": "SELECT SUM(CASE WHEN sales team.region = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"sales team\"",
            "ba": "The virtual table summarizes the total sales for a specific region by aggregating the sales data from the 'sales team' table. The placeholder in the WHERE clause represents the region for which the sales total is being calculated."
        },
        {
            "sample_id": 2640,
            "vt": "SELECT DISTINCT CASE WHEN COUNT(customers.customerid) > [placeholder-type:numeric] THEN customers.\"customer names\" ELSE NULL END FROM \"sales orders\" INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID WHERE sales orders.orderdate LIKE '[placeholder-type:string]' GROUP BY sales orders._customerid HAVING COUNT(customers.customerid)",
            "ba": "The virtual table provides a list of customer names from the 'customers' table, but only includes those customers who have placed more than a specified number of orders. The query joins the 'sales orders' table with the 'customers' table based on the customer ID, filters the results by a specific order date, and groups the results by customer ID. If a customer has placed more orders than the specified threshold, their name is included in the results; otherwise, it returns NULL for that customer."
        },
        {
            "sample_id": 2593,
            "vt": "SELECT store locations.\"city name\", store locations.\"median income\" FROM \"store locations\" WHERE store locations.state = '[placeholder-type:string]' ORDER BY store locations.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the city names and median incomes of store locations from the 'store locations' table for a specific state. The placeholders in the WHERE clause represent the state name and the limit on the number of results to return."
        },
        {
            "sample_id": 2628,
            "vt": "SELECT products.\"product name\" FROM \"sales orders\" INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID WHERE sales orders.orderdate LIKE '[placeholder-type:string]' ORDER BY REPLACE(sales orders.\"unit price\", ',', '') - REPLACE(sales orders.\"unit cost\", ',', '') LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products from the 'products' table that are associated with sales orders placed on a specific date. The query joins the 'sales orders' table with the 'products' table based on the product ID, and it filters the results by the order date using a placeholder for string values. Additionally, it calculates the net profit for each order by subtracting the unit cost from the unit price, and it limits the results based on a specified numeric value."
        },
        {
            "sample_id": 2577,
            "vt": "SELECT AVG(store locations.\"median income\") FROM \"store locations\" WHERE store locations.type = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average median income from the 'store locations' table for a specific type of store. The placeholder in the WHERE clause represents the type of store being queried."
        },
        {
            "sample_id": 2630,
            "vt": "SELECT subquery_q0.t FROM (SELECT DISTINCT CASE WHEN sales orders.orderdate = '[placeholder-type:string]' THEN sales team.\"sales team\" ELSE NULL END FROM \"Sales Orders\" AS T1 INNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table retrieves distinct sales team names from the 'Sales Orders' table based on a specific order date. It uses a subquery to join the 'Sales Orders' and 'Sales Team' tables, filtering for records where the order date matches the specified placeholder. The result will only include non-null sales team names associated with that order date."
        },
        {
            "sample_id": 2607,
            "vt": "SELECT SUM(CASE WHEN sales orders.\"order quantity\" > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"sales orders\"",
            "ba": "The virtual table calculates the total order quantity from the 'sales orders' table, applying a conditional sum based on whether the order quantity exceeds a specified threshold. The placeholders represent the threshold for order quantity and the values to sum based on that condition."
        },
        {
            "sample_id": 2611,
            "vt": "SELECT subquery_q0.t FROM (SELECT DISTINCT CASE WHEN products.\"product name\" = '[placeholder-type:string]' THEN sales orders.deliverydate ELSE NULL END FROM \"Sales Orders\" AS T1 INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table retrieves distinct delivery dates for sales orders where the product name matches a specified value. It uses a subquery to join the 'Sales Orders' and 'Products' tables based on the product ID, filtering the results to only include delivery dates for the specified product name."
        },
        {
            "sample_id": 2617,
            "vt": "SELECT subquery_q0.t FROM (SELECT DISTINCT CASE WHEN store locations.type = '[placeholder-type:string]' THEN regions.region END FROM Regions AS T1 INNER JOIN \"Store Locations\" AS T2 ON T2.StateCode = T1.StateCode) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table identifies distinct regions based on the type of store from the 'Store Locations' table. It uses a subquery to join the 'Regions' and 'Store Locations' tables on the state code, filtering for a specific store type. The result will show the unique regions where that type of store is located, excluding any null values."
        },
        {
            "sample_id": 2649,
            "vt": "SELECT products.\"product name\" FROM \"sales orders\" INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID WHERE sales orders.orderdate LIKE '[placeholder-type:string]' GROUP BY sales orders._productid ORDER BY COUNT(sales orders._productid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products from the 'sales orders' table, filtered by a specific order date. It joins the 'sales orders' table with the 'products' table to retrieve the product names associated with each order. The results are grouped by product ID to count the occurrences of each product in the orders, and the output is limited to a specified number of products based on their order frequency."
        },
        {
            "sample_id": 2646,
            "vt": "SELECT sales orders.ordernumber FROM \"sales orders\" WHERE REPLACE(sales orders.\"unit cost\", ',', '') = (SELECT REPLACE(sales orders.\"unit cost\", ',', '') FROM \"Sales Orders\" ORDER BY REPLACE(\"Unit Cost\", ',', '') DESC LIMIT 1)",
            "ba": "The virtual table retrieves the order numbers from the 'sales orders' table where the unit cost of the order matches the highest unit cost found in the same table. The placeholder in the query allows for dynamic filtering based on the unit cost."
        },
        {
            "sample_id": 2668,
            "vt": "SELECT SUM(REPLACE(sales orders.\"unit price\", ',', '') - REPLACE(sales orders.\"unit cost\", ',', '')) FROM \"sales orders\" INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID WHERE sales orders.deliverydate LIKE '[placeholder-type:string]' AND products.\"product name\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total net profit from sales orders by subtracting the unit cost from the unit price for each order. It filters the results based on a specific delivery date and product name, allowing users to analyze profitability for a particular product over a given time period."
        },
        {
            "sample_id": 2652,
            "vt": "SELECT SUM(CASE WHEN customers.\"customer names\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM customers INNER JOIN \"Sales Orders\" AS T2 ON T2._CustomerID = T1.CustomerID",
            "ba": "The virtual table calculates the total order quantity for a specific customer from the 'customers' table by summing the order quantities from the 'sales orders' table. It uses a conditional statement to differentiate between the order quantities based on whether the customer's name matches a specified value. The placeholders represent the customer's name and the numeric values for order quantities."
        },
        {
            "sample_id": 2624,
            "vt": "SELECT store locations.storeid, store locations.latitude, store locations.longitude FROM \"store locations\" WHERE store locations.\"city name\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique store IDs along with their latitude and longitude from the 'store locations' table for stores located in a specific city. The placeholder in the WHERE clause represents the name of the city."
        },
        {
            "sample_id": 2601,
            "vt": "SELECT CAST(SUM(CASE WHEN sales team.\"sales team\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(sales orders.ordernumber) FROM \"sales orders\" INNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID",
            "ba": "The virtual table calculates the weighted average of a specific metric from the 'sales orders' table, based on the sales team specified. It sums up the values conditionally based on the sales team name and divides it by the count of orders to get an average, while also allowing for a multiplier to adjust the final result."
        },
        {
            "sample_id": 2626,
            "vt": "SELECT SUM(CASE WHEN store locations.state = '[placeholder-type:string]' AND store locations.type = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"store locations\"",
            "ba": "The virtual table calculates the total quantity of orders from the 'sales orders' table based on specific conditions related to store locations. It sums the order quantities for stores located in a specified state and of a specified type, using placeholders for both the state name and store type. The result will provide insights into the order quantities for different store types within a particular state."
        },
        {
            "sample_id": 2677,
            "vt": "SELECT SUM(CASE WHEN store locations.population < [placeholder-type:numeric] AND store locations.type = '[placeholder-type:string]' AND store locations.\"city name\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"store locations\"",
            "ba": "The virtual table calculates the total order quantity from the 'store locations' table based on specific conditions. It sums the order quantities for stores that have a population less than a specified number, are of a certain type, and are located in a specific city. The placeholders represent the population limit, store type, city name, and the order quantity to be summed."
        },
        {
            "sample_id": 2704,
            "vt": "SELECT sales team.region FROM \"sales orders\" INNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE sales orders.\"sales channel\" = '[placeholder-type:string]' ORDER BY sales orders.\"discount applied\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of regions associated with sales orders filtered by a specific sales channel. It joins the 'sales orders' table with the 'sales team' table to retrieve the relevant region information. The placeholders allow users to specify the sales channel and limit the number of results returned."
        },
        {
            "sample_id": 2657,
            "vt": "SELECT subquery_q0.t FROM (SELECT DISTINCT CASE WHEN sales team.\"sales team\" = '[placeholder-type:string]' THEN sales orders.ordernumber ELSE NULL END FROM \"Sales Orders\" AS T1 INNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table retrieves distinct order numbers from the 'Sales Orders' table for a specific sales team. It uses a subquery to filter the orders based on the sales team name provided as a placeholder. The result will only include order numbers associated with the specified sales team, ensuring that any duplicates are removed."
        },
        {
            "sample_id": 2603,
            "vt": "SELECT SUM(REPLACE(sales orders.\"unit price\", ',', '') - REPLACE(sales orders.\"unit cost\", ',', '')) FROM \"sales orders\" INNER JOIN \"Store Locations\" AS T2 ON T2.StoreID = T1._StoreID ORDER BY store locations.\"median income\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total net profit from sales orders by subtracting the unit cost from the unit price for each order. It joins the 'sales orders' table with the 'store locations' table to access the median income of each store's location. The result is ordered by the median income, and a limit is applied to restrict the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 2651,
            "vt": "SELECT subquery_q0.t FROM (SELECT DISTINCT CASE WHEN store locations.\"city name\" = '[placeholder-type:string]' THEN sales orders.ordernumber END FROM \"Sales Orders\" AS T1 INNER JOIN \"Store Locations\" AS T2 ON T2.StoreID = T1._StoreID) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table retrieves unique order numbers from the 'Sales Orders' table for a specific city by joining it with the 'Store Locations' table. The placeholder in the query represents the city name for which the order numbers are being queried."
        },
        {
            "sample_id": 2672,
            "vt": "SELECT COUNT(sales orders.ordernumber) / [placeholder-type:numeric] FROM \"sales orders\" INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID WHERE (sales orders.orderdate LIKE '[placeholder-type:string]' AND customers.\"customer names\" = '[placeholder-type:string]') OR (sales orders.orderdate LIKE '[placeholder-type:string]' AND customers.\"customer names\" = '[placeholder-type:string]') OR (sales orders.orderdate LIKE '[placeholder-type:string]' AND customers.\"customer names\" = '[placeholder-type:string]')",
            "ba": "The virtual table calculates the average number of sales orders placed by a specific customer on certain dates. It counts the total number of orders from the 'sales orders' table, filtering based on the order date and customer name. The result is divided by a placeholder for numeric values to provide an average."
        },
        {
            "sample_id": 2650,
            "vt": "SELECT SUM(CASE WHEN sales team.\"sales team\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"sales orders\" INNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID",
            "ba": "The virtual table summarizes the total order quantity from the 'sales orders' table, filtered by a specific sales team. It uses a conditional aggregation to calculate the sum based on whether the sales team matches the specified name, allowing for comparison of order quantities for that team against others."
        },
        {
            "sample_id": 2597,
            "vt": "SELECT CAST(SUM(CASE WHEN sales orders.\"sales channel\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(sales orders._customerid) FROM \"sales orders\" INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID WHERE customers.\"customer names\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average sales amount for a specific sales channel from the 'sales orders' table, filtered by a specific customer name from the 'customers' table. It sums the order quantities for the specified sales channel and divides it by the count of orders for that customer, applying a multiplier placeholder to adjust the result."
        },
        {
            "sample_id": 2581,
            "vt": "SELECT DISTINCT sales orders.ordernumber, store locations.\"city name\" FROM \"sales orders\" INNER JOIN \"Store Locations\" AS T2 ON T2.StoreID = T1._StoreID WHERE sales orders.\"sales channel\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique order numbers and corresponding city names from the 'sales orders' table, filtered by a specific sales channel. The query joins the 'sales orders' table with the 'store locations' table to retrieve the city name associated with each order, using a placeholder for the sales channel."
        },
        {
            "sample_id": 2665,
            "vt": "SELECT store locations.storeid FROM \"sales orders\" INNER JOIN \"Store Locations\" AS T2 ON T2.StoreID = T1._StoreID WHERE store locations.\"city name\" = '[placeholder-type:string]' OR store locations.\"city name\" = '[placeholder-type:string]' GROUP BY store locations.storeid ORDER BY COUNT(sales orders.ordernumber) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves unique store IDs from the 'sales orders' table by joining it with the 'store locations' table. It filters the results based on specific city names provided as placeholders, allowing for the selection of stores located in either of the specified cities. The results are grouped by store ID and ordered by the count of orders associated with each store, limiting the output to a specified number of results."
        },
        {
            "sample_id": 2721,
            "vt": "SELECT AVG(store locations.\"household income\") FROM regions INNER JOIN \"Store Locations\" AS T2 ON T2.StateCode = T1.StateCode WHERE regions.region = '[placeholder-type:string]' GROUP BY store locations.state ORDER BY COUNT(store locations.storeid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average household income from the 'store locations' table, filtered by the region specified in the 'regions' table. It joins the 'regions' and 'store locations' tables on the state code, groups the results by state, and orders them based on the count of store IDs, limiting the results to a specified number."
        },
        {
            "sample_id": 2658,
            "vt": "SELECT COUNT(sales orders.ordernumber) FROM products INNER JOIN \"Sales Orders\" AS T2 ON T2._ProductID = T1.ProductID WHERE products.\"product name\" = '[placeholder-type:string]' AND sales orders.orderdate LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of sales orders for a specific product based on its name and a specified order date. It joins the 'products' table with the 'sales orders' table to filter the results accordingly."
        },
        {
            "sample_id": 2692,
            "vt": "SELECT store locations.\"city name\" FROM \"sales orders\" INNER JOIN \"Store Locations\" AS T2 ON T2.StoreID = T1._StoreID WHERE REPLACE(sales orders.\"unit price\", ',', '') = (SELECT REPLACE(sales orders.\"unit price\", ',', '') FROM \"Sales Orders\" AS T1 INNER JOIN \"Store Locations\" AS T2 ON T2.StoreID = T1._StoreID ORDER BY REPLACE(T1.\"Unit Price\", ',', '') DESC LIMIT 1) ORDER BY REPLACE(sales orders.\"unit price\", ',', '') LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the city names from the 'store locations' table based on the highest unit price from the 'sales orders' table. It uses an inner join to connect the 'sales orders' and 'store locations' tables through the store ID. The query filters the results to find city names where the unit price matches the highest unit price found in the sales orders, and limits the number of results returned based on a specified numeric placeholder."
        },
        {
            "sample_id": 2731,
            "vt": "SELECT customers.\"customer names\" FROM (SELECT customers.\"customer names\", REPLACE(sales orders.\"unit price\", ',', '') * sales orders.\"order quantity\" - REPLACE(sales orders.\"unit price\", ',', '') * sales orders.\"discount applied\" FROM Customers AS T1 INNER JOIN \"Sales Orders\" AS T2 ON T2._CustomerID = T1.CustomerID) ORDER BY subquery_q0.t LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of customers from the 'customers' table, along with a calculated value representing the total revenue generated from their orders after applying any discounts. The calculation involves multiplying the unit price of each product by the order quantity and subtracting the discount applied. The results are ordered by a specified limit, allowing users to retrieve a specific number of customer names based on their total revenue."
        },
        {
            "sample_id": 2695,
            "vt": "SELECT products.\"product name\" FROM products INNER JOIN \"Sales Orders\" AS T2 ON T2._ProductID = T1.ProductID INNER JOIN \"Store Locations\" AS T3 ON T3.StoreID = T2._StoreID WHERE store locations.\"city name\" = '[placeholder-type:string]' GROUP BY products.\"product name\" ORDER BY COUNT(products.\"product name\") LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products sold in a specific city, along with the count of how many times each product has been ordered. It joins the 'products' table with the 'sales orders' table to link products to their respective orders, and further joins with the 'store locations' table to filter by a specific city. The results are grouped by product name and ordered by the count of orders, with a limit on the number of results returned."
        },
        {
            "sample_id": 2621,
            "vt": "SELECT SUM(CASE WHEN sales orders.\"order quantity\" > [placeholder-type:numeric] AND customers.\"customer names\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"sales orders\" INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID",
            "ba": "The virtual table calculates the total order quantity from the 'sales orders' table for a specific customer, where the order quantity exceeds a certain threshold. It uses a conditional sum to determine the total based on the specified criteria, joining the 'sales orders' table with the 'customers' table to filter by customer name."
        },
        {
            "sample_id": 2705,
            "vt": "SELECT sales orders.ordernumber, sales orders.orderdate FROM \"sales orders\" INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID WHERE customers.\"customer names\" = '[placeholder-type:string]' ORDER BY sales orders.\"unit price\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the order numbers and order dates of sales orders from the 'sales orders' table, filtered by a specific customer's name. The placeholder in the WHERE clause represents the customer's name, and the query limits the results based on a specified numeric value for the number of records to return."
        },
        {
            "sample_id": 2613,
            "vt": "SELECT subquery_q0.t FROM (SELECT DISTINCT CASE WHEN sales orders.\"discount applied\" = [placeholder-type:numeric] THEN products.\"product name\" ELSE NULL END FROM \"Sales Orders\" AS T1 INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table retrieves distinct product names from the 'products' table based on a condition related to the discount applied in the 'sales orders' table. It uses a subquery to filter products where the discount applied matches a specified numeric value, ensuring that only relevant product names are returned."
        },
        {
            "sample_id": 2667,
            "vt": "SELECT DISTINCT customers.\"customer names\", customers.customerid FROM (SELECT customers.\"customer names\", customers.customerid, SUM(REPLACE(sales orders.\"unit price\", ',', '') - REPLACE(sales orders.\"unit cost\", ',', '')) FROM \"Sales Orders\" AS T1 INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID WHERE T1.\"Sales Channel\" = 'Online' GROUP BY T2.CustomerID) WHERE subquery_q0.t > [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of distinct customer names and their unique identifiers from the 'customers' table. It filters the results to include only those customers who have made online purchases, and it calculates the total profit for each customer by subtracting the unit cost from the unit price for each order. The results are grouped by customer ID, and only those customers whose total profit exceeds a specified numeric threshold are included in the final output."
        },
        {
            "sample_id": 2699,
            "vt": "SELECT AVG(store locations.\"household income\") FROM regions INNER JOIN \"Store Locations\" AS T2 ON T2.StateCode = T1.StateCode WHERE store locations.state = '[placeholder-type:string]' AND store locations.type = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average household income from the 'store locations' table, filtered by a specific state and store type. It joins the 'regions' table to ensure that the state code matches, allowing for accurate aggregation of household income data based on the specified criteria."
        },
        {
            "sample_id": 2620,
            "vt": "SELECT subquery_q0.t FROM (SELECT DISTINCT CASE WHEN sales orders.shipdate = '[placeholder-type:string]' THEN customers.\"customer names\" END FROM Customers AS T1 INNER JOIN \"Sales Orders\" AS T2 ON T2._CustomerID = T1.CustomerID) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table retrieves distinct customer names from the 'customers' table who have orders with a specific shipping date from the 'sales orders' table. The placeholder in the query represents the shipping date that is being filtered."
        },
        {
            "sample_id": 2726,
            "vt": "SELECT products.\"product name\" FROM \"sales orders\" INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID WHERE sales orders.\"order quantity\" > [placeholder-type:numeric] AND sales orders.shipdate LIKE '[placeholder-type:string]' ORDER BY REPLACE(sales orders.\"unit price\", ',', '') - REPLACE(sales orders.\"unit cost\", ',', '') LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products from the 'sales orders' table that have an order quantity greater than a specified number and were shipped on a specific date. The query joins the 'sales orders' table with the 'products' table to retrieve the product names, while also applying filters based on order quantity and ship date. The results are ordered by the net profit calculated from the difference between unit price and unit cost, and limited to a specified number of results."
        },
        {
            "sample_id": 2717,
            "vt": "SELECT CASE WHEN MAX(store locations.\"water area\") THEN store locations.type END FROM \"store locations\"",
            "ba": "The virtual table provides information about the type of store from the 'store locations' table based on the maximum water area available. The placeholder indicates that the query is checking for the store type associated with the largest water area."
        },
        {
            "sample_id": 2618,
            "vt": "SELECT SUM(CASE WHEN customers.\"customer names\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM customers INNER JOIN \"Sales Orders\" AS T2 ON T2._CustomerID = T1.CustomerID",
            "ba": "The virtual table calculates the total order quantity for a specific customer from the 'customers' table by summing the order quantities from the 'sales orders' table. It uses a conditional statement to differentiate between the specified customer and others, allowing for a comparison of order quantities. The placeholders represent the customer's name and the order quantity values."
        },
        {
            "sample_id": 2660,
            "vt": "SELECT CAST(SUM(CASE WHEN store locations.\"city name\" = '[placeholder-type:string]' THEN sales orders.\"order quantity\" ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(sales orders.\"order quantity\") FROM products INNER JOIN \"Sales Orders\" AS T2 ON T2._ProductID = T1.ProductID INNER JOIN \"Store Locations\" AS T3 ON T3.StoreID = T2._StoreID WHERE sales orders.orderdate LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of order quantities for a specific city from the 'Sales Orders' table, based on the total order quantities. It uses a placeholder for the city name and another placeholder for a numeric value to adjust the result. The query joins the 'Products' and 'Store Locations' tables to ensure that the relevant product and store information is included, while filtering the results based on a specified order date."
        },
        {
            "sample_id": 2659,
            "vt": "SELECT CAST(SUM(sales orders.\"order quantity\") AS FLOAT) / [placeholder-type:numeric] FROM products INNER JOIN \"Sales Orders\" AS T2 ON T2._ProductID = T1.ProductID WHERE products.\"product name\" = '[placeholder-type:string]' AND sales orders.orderdate LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average order quantity of a specific product from the 'Sales Orders' table, based on the product name and a specified order date. It uses an inner join between the 'products' and 'sales orders' tables to link product details with their corresponding sales orders. The result is obtained by summing the order quantities and dividing by a placeholder for numeric values, which represents the number of records or another relevant metric."
        },
        {
            "sample_id": 2604,
            "vt": "SELECT COUNT(sales orders.ordernumber) FROM \"sales orders\" INNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE sales team.region = '[placeholder-type:string]' AND sales team.salesteamid BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] GROUP BY sales team.salesteamid HAVING COUNT(sales orders.ordernumber)",
            "ba": "The virtual table counts the number of sales orders from the 'sales orders' table, joining it with the 'Sales Team' table to filter based on the region and sales team ID range. The result is grouped by sales team ID, providing insights into the number of orders handled by each sales team within a specified region and ID range."
        },
        {
            "sample_id": 2596,
            "vt": "SELECT sales team.region, sales team.\"sales team\" FROM \"sales orders\" INNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE sales team.salesteamid = [placeholder-type:numeric] AND sales orders.\"sales channel\" = '[placeholder-type:string]' OR sales orders.\"sales channel\" = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the sales teams and their corresponding regions based on sales orders. It retrieves the region and name of the sales team from the 'sales team' table, joining it with the 'sales orders' table to filter results based on a specific sales team ID and sales channel. The placeholders represent the sales team ID and the sales channel types."
        }
    ],
    "legislator": [
        {
            "sample_id": 4889,
            "vt": "SELECT social-media.instagram FROM current INNER JOIN \"social-media\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current.official_full_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the Instagram handle of a legislator from the 'social-media' table by joining it with the 'current' table based on the legislator's bioguide ID. The query filters the results to find the specific legislator using their official full name."
        },
        {
            "sample_id": 4909,
            "vt": "SELECT historical-terms.type, historical-terms.start FROM historical INNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE historical.birthday_bio = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the type of legislative term and the start date of legislators from the 'historical-terms' table, specifically for those whose birthday matches a specified date. It combines data from the 'historical' table and the 'historical-terms' table using a join on the bioguide ID."
        },
        {
            "sample_id": 4752,
            "vt": "SELECT COUNT(subquery_q0.cid) FROM (SELECT current.bioguide_id FROM current AS T1 INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.gender_bio = 'F' GROUP BY T2.bioguide HAVING COUNT(T2.bioguide) > 4)",
            "ba": "The virtual table counts the number of female legislators who have served more than four terms in the current-terms table. It retrieves the bioguide_id from the current table, joins it with the current-terms table based on the bioguide_id, filters for female legislators, groups the results by bioguide_id, and applies a condition to count only those with more than four terms."
        },
        {
            "sample_id": 4846,
            "vt": "SELECT CASE WHEN historical.ballotpedia_id IS NULL THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM historical WHERE historical.first_name = '[placeholder-type:string]' AND historical.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a mechanism to check the existence of a legislator's Ballotpedia account based on their first and last names. It uses a conditional statement to return a placeholder value if the Ballotpedia ID is null, indicating that the legislator does not have an account on Ballotpedia. The placeholders in the query represent the first name and last name of the legislator being queried."
        },
        {
            "sample_id": 4818,
            "vt": "SELECT current.opensecrets_id FROM current INNER JOIN \"social-media\" AS T2 ON T2.bioguide = T1.bioguide_id WHERE social-media.youtube = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the OpenSecrets ID of legislators from the 'current' table who have a specific YouTube presence. It joins the 'current' table with the 'social-media' table based on the bioguide ID, filtering for those whose YouTube handle matches a specified placeholder."
        },
        {
            "sample_id": 4808,
            "vt": "SELECT COUNT(*) FROM current WHERE NOT current.opensecrets_id IS NULL AND current.opensecrets_id <> '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of current legislators who have a non-null and non-empty OpenSecrets ID, indicating they are registered in OpenSecrets.org."
        },
        {
            "sample_id": 4906,
            "vt": "SELECT social-media.instagram FROM \"social-media\" INNER JOIN current AS T2 ON T2.bioguide_id = T1.bioguide WHERE current.first_name = '[placeholder-type:string]' AND current.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the Instagram handle of legislators from the 'social-media' table by joining it with the 'current' table based on their unique bioguide ID. The query filters the results to find a specific legislator by their first and last name, which are represented as placeholders for string values."
        },
        {
            "sample_id": 4804,
            "vt": "SELECT historical-terms.start, historical-terms.\"end\", historical-terms.party FROM historical INNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE historical.first_name = '[placeholder-type:string]' AND historical.middle_name = '[placeholder-type:string]' AND historical.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the historical terms of legislators, including the start and end dates of their terms and their political party affiliation. It retrieves this data by joining the 'historical' table with the 'historical-terms' table based on the unique bioguide ID of the legislator. The query filters results based on the legislator's first, middle, and last names, which are provided as placeholders."
        },
        {
            "sample_id": 4861,
            "vt": "SELECT historical.first_name, historical.last_name FROM historical INNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE historical-terms.end = '[placeholder-type:string]' AND historical.gender_bio = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of legislators from the 'historical' table who have served terms that ended on a specific date and belong to a specific gender. The query joins the 'historical' table with the 'historical-terms' table using the bioguide ID to filter the results based on the end date of their terms and their gender."
        },
        {
            "sample_id": 4893,
            "vt": "SELECT current-terms.phone FROM \"current-terms\" INNER JOIN current AS T2 ON T2.bioguide_id = T1.bioguide WHERE current.official_full_name = '[placeholder-type:string]' AND current-terms.start = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the phone number of a legislator from the 'current-terms' table by joining it with the 'current' table. The query filters results based on the legislator's official full name and the start date of their current term."
        },
        {
            "sample_id": 4742,
            "vt": "SELECT social-media.facebook FROM \"social-media\" INNER JOIN current AS T2 ON T2.bioguide_id = T1.bioguide WHERE current.official_full_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the Facebook username of a legislator from the 'social-media' table by joining it with the 'current' table based on the legislator's unique bioguide ID. The query filters the results to find the specific legislator using their official full name, which is provided as a placeholder."
        },
        {
            "sample_id": 4911,
            "vt": "SELECT COUNT((SELECT T1.bioguide_id FROM current AS T1 INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.type = 'rep' AND T2.state = 'MI' AND T1.gender_bio = 'F' GROUP BY T1.bioguide_id).bioguide_id) FROM (SELECT current.bioguide_id FROM current AS T1 INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.type = 'rep' AND T2.state = 'MI' AND T1.gender_bio = 'F' GROUP BY T1.bioguide_id) AS t",
            "ba": "The virtual table counts the number of female representatives from the state of Michigan by joining the 'current' and 'current-terms' tables based on the bioguide ID. It filters the results to include only those legislators who are identified as female and are currently serving as representatives in Michigan."
        },
        {
            "sample_id": 4844,
            "vt": "SELECT CAST(SUM(CASE WHEN current-terms.party = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(current-terms.party) FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current.gender_bio = '[placeholder-type:string]' AND STRFTIME('%Y', current.birthday_bio) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average based on the party affiliation of legislators from the 'current' and 'current-terms' tables. It sums a specific value for legislators of a given party, multiplies it by a numeric placeholder, and divides by the count of legislators in that party who meet certain criteria. The criteria include filtering by gender and a range of birth years."
        },
        {
            "sample_id": 4858,
            "vt": "SELECT COUNT(*) FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE STRFTIME('%Y', current-terms.start) = '[placeholder-type:string]' AND current-terms.state = '[placeholder-type:string]' AND current.gender_bio = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of legislators from the 'current' table who have served in a specific state during a specific year and match a specified gender. It joins the 'current' table with the 'current-terms' table based on the bioguide ID, filtering results by the start year of their term, the state they represent, and their gender."
        },
        {
            "sample_id": 4807,
            "vt": "SELECT COUNT(*) FROM current WHERE current.gender_bio = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of legislators from the 'current' table who belong to a specific gender category. The placeholder in the WHERE clause represents the gender of the legislators being queried."
        },
        {
            "sample_id": 4801,
            "vt": "SELECT COUNT(historical.bioguide_id) FROM historical INNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE historical.gender_bio = '[placeholder-type:string]' AND historical-terms.start = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of legislators from the 'historical' table who match a specific gender and have a term that started on a specified date. It joins the 'historical' table with the 'historical-terms' table based on the bioguide ID to filter the results accordingly."
        },
        {
            "sample_id": 4777,
            "vt": "SELECT historical-terms.party FROM \"historical-terms\" INNER JOIN historical AS T2 ON T2.bioguide_id = T1.bioguide WHERE historical.first_name OR historical.middle_name OR historical.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the political party affiliation of legislators from the 'historical-terms' table, joining it with the 'historical' table to filter based on the legislator's name. The placeholder in the WHERE clause represents the full name of the legislator, which can include first, middle, or last names."
        },
        {
            "sample_id": 4744,
            "vt": "SELECT current.official_full_name FROM current INNER JOIN \"social-media\" AS T2 ON T2.bioguide = T1.bioguide_id WHERE social-media.twitter_id = [placeholder-type:numeric]",
            "ba": "The virtual table provides the official full names of legislators from the 'current' table who have a specific Twitter ID associated with their social media presence. The query joins the 'current' table with the 'social-media' table using the bioguide ID to filter for legislators with the specified Twitter ID."
        },
        {
            "sample_id": 4853,
            "vt": "SELECT current.first_name, current.last_name FROM current INNER JOIN \"social-media\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE social-media.instagram IS NULL",
            "ba": "The virtual table describes the first and last names of legislators from the 'current' table who do not have an official Instagram presence. The query joins the 'current' table with the 'social-media' table using the bioguide ID to filter out those without an Instagram account."
        },
        {
            "sample_id": 4820,
            "vt": "SELECT current.first_name FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current-terms.address = '[placeholder-type:string]' GROUP BY current.first_name",
            "ba": "The virtual table retrieves the first names of legislators from the 'current' table who have a specific address in their current terms. It joins the 'current' table with the 'current-terms' table using the bioguide ID to ensure that only legislators with matching records are considered. The results are grouped by the first name to avoid duplicates."
        },
        {
            "sample_id": 4904,
            "vt": "SELECT COUNT(historical-terms.type) FROM \"historical-terms\" WHERE historical-terms.state = '[placeholder-type:string]' AND historical-terms.type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of historical terms served by legislators from a specific state and of a specific type (either senator or representative). The placeholders in the WHERE clause represent the state code and the type of the legislator's term."
        },
        {
            "sample_id": 4774,
            "vt": "SELECT CAST(COUNT(CASE WHEN current.gender_bio = '[placeholder-type:string]' THEN current.bioguide_id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / (SELECT COUNT(CASE WHEN historical.gender_bio = '[placeholder-type:string]' THEN historical.bioguide_id ELSE NULL END) FROM historical) FROM current",
            "ba": "The virtual table calculates the proportion of current legislators of a specific gender compared to historical legislators of the same gender. It counts the number of current legislators matching the specified gender and multiplies it by a numeric placeholder, then divides by the total count of historical legislators of that gender."
        },
        {
            "sample_id": 4761,
            "vt": "SELECT current-terms.party FROM \"current-terms\" INNER JOIN current AS T2 ON T2.bioguide_id = T1.bioguide WHERE current.first_name = '[placeholder-type:string]' AND current.last_name = '[placeholder-type:string]' AND current-terms.start LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the political party affiliation of a legislator from the 'current-terms' table by joining it with the 'current' table. It filters the results based on the legislator's first name, last name, and the start date of their term, using placeholders for these values."
        },
        {
            "sample_id": 4826,
            "vt": "SELECT social-media.facebook_id FROM \"social-media\" WHERE social-media.facebook = '[placeholder-type:string]'",
            "ba": "The virtual table describes the Facebook ID of legislators from the 'social-media' table based on their official Facebook username. The placeholder in the WHERE clause represents the specific Facebook username being queried."
        },
        {
            "sample_id": 4851,
            "vt": "SELECT CAST(SUM(CASE WHEN historical.gender_bio = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN historical.gender_bio = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM historical",
            "ba": "The virtual table calculates the ratio of legislators of a specific gender to the total number of legislators from the 'historical' table. It uses conditional aggregation to sum the counts based on the gender specified by the placeholder, allowing users to analyze the representation of different genders in the historical data."
        },
        {
            "sample_id": 4782,
            "vt": "SELECT current.official_full_name FROM \"social-media\" INNER JOIN current AS T2 ON T1.bioguide = T2.bioguide_id WHERE (social-media.youtube IS NULL OR social-media.youtube = '[placeholder-type:string]') AND (social-media.instagram IS NULL OR social-media.instagram = '[placeholder-type:string]') AND (social-media.twitter IS NULL OR social-media.twitter = '[placeholder-type:string]') AND NOT social-media.facebook IS NULL AND social-media.facebook <> '[placeholder-type:string]'",
            "ba": "The virtual table lists the official full names of legislators from the 'current' table who have a non-null Facebook presence, while their YouTube, Instagram, and Twitter accounts may either be null or match a specified placeholder. This query effectively filters out legislators based on their social media presence, ensuring that only those with a valid Facebook account are included."
        },
        {
            "sample_id": 4833,
            "vt": "SELECT current.official_full_name FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current-terms.party = '[placeholder-type:string]' GROUP BY current.official_full_name",
            "ba": "The virtual table provides a list of official full names of legislators from the 'current' table who are affiliated with a specific political party. It joins the 'current' table with the 'current-terms' table based on the bioguide ID, filtering results by the party affiliation specified in the placeholder."
        },
        {
            "sample_id": 4787,
            "vt": "SELECT historical-terms.state, historical-terms.party FROM historical INNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE historical.first_name OR historical.middle_name OR historical.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the state and political party of legislators from the 'historical' table who have served in the past. It joins the 'historical' table with the 'historical-terms' table based on the bioguide ID, allowing for a comprehensive view of the legislators' affiliations and locations. The placeholder in the WHERE clause is used to filter results based on the legislator's name, which can include first, middle, or last names."
        },
        {
            "sample_id": 4776,
            "vt": "SELECT social-media.facebook FROM current INNER JOIN \"social-media\" AS T2 ON T2.bioguide = T1.bioguide_id WHERE current.official_full_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the Facebook username of a legislator from the 'social-media' table by joining it with the 'current' table based on the legislator's unique bioguide ID. The query filters the results to find the specific legislator using their official full name."
        },
        {
            "sample_id": 4749,
            "vt": "SELECT COUNT(*) FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current.official_full_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of current terms associated with a specific legislator based on their official full name. It joins the 'current' table, which contains legislator details, with the 'current-terms' table, which holds information about their current legislative terms, using the bioguide ID as the linking key."
        },
        {
            "sample_id": 4843,
            "vt": "SELECT SUM(CASE WHEN historical-terms.type = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN historical-terms.type = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM historical INNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE historical.gender_bio = '[placeholder-type:string]' AND STRFTIME('%Y', historical.birthday_bio) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between two sums based on the type of legislative term from the 'historical-terms' table, filtered by the gender and birthday of the legislator from the 'historical' table. The placeholders represent specific values for type, numeric calculations, gender, and a range of years for the birthday."
        },
        {
            "sample_id": 4840,
            "vt": "SELECT current.official_full_name, current.birthday_bio FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current-terms.contact_form = '[placeholder-type:string]'",
            "ba": "The virtual table provides the official full name and birthday of legislators from the 'current' table who have a specific contact form URL associated with their current term in the 'current-terms' table. The placeholder in the WHERE clause represents the contact form URL that is being queried."
        },
        {
            "sample_id": 4780,
            "vt": "SELECT historical.first_name, historical.last_name FROM \"historical-terms\" INNER JOIN historical AS T2 ON T2.bioguide_id = T1.bioguide WHERE historical-terms.party = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of legislators from the 'historical' table who have served in a specific party during their terms. The query joins the 'historical-terms' table with the 'historical' table using the bioguide ID to filter the results based on the specified party."
        },
        {
            "sample_id": 4788,
            "vt": "SELECT COUNT(*) FROM historical WHERE CAST(historical.birthday_bio AS DATE) = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of legislators from the 'historical' table whose birthday matches a specific date. The placeholder in the WHERE clause represents the date being queried."
        },
        {
            "sample_id": 4896,
            "vt": "SELECT COUNT(*) FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current-terms.start = '[placeholder-type:string]' AND current.gender_bio = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of legislators from the 'current' table who have a corresponding entry in the 'current-terms' table, filtered by the start date of their term and their gender. The placeholders represent the specific start date and gender of interest."
        },
        {
            "sample_id": 4894,
            "vt": "SELECT COUNT(*) FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current.official_full_name = '[placeholder-type:string]' AND current-terms.party = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of current terms for a legislator based on their official full name and political party affiliation. It joins the 'current' table, which contains information about legislators, with the 'current-terms' table, which holds details about their current terms, using the bioguide ID as a foreign key. The placeholders represent the legislator's name and party affiliation."
        },
        {
            "sample_id": 4883,
            "vt": "SELECT COUNT(*) FROM current WHERE STRFTIME('%Y', current.birthday_bio) > '[placeholder-type:string]' AND current.google_entity_id_id IS NULL",
            "ba": "The virtual table counts the number of legislators from the 'current' table whose birthday is after a specified year and who do not have a Google entity ID."
        },
        {
            "sample_id": 4877,
            "vt": "SELECT historical.wikipedia_id FROM historical INNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE historical-terms.type = '[placeholder-type:string]' AND historical-terms.party = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the Wikipedia page IDs of legislators from the 'historical' table who have served in a specific type of term (either senator or representative) and belong to a specified political party. The query uses an inner join to connect the 'historical' table with the 'historical-terms' table based on the bioguide ID, ensuring that only relevant records are selected based on the provided placeholders for term type and party affiliation."
        },
        {
            "sample_id": 4856,
            "vt": "SELECT current-terms.address FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current.first_name = '[placeholder-type:string]' AND current.last_name = '[placeholder-type:string]' AND current-terms.start = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the address of a legislator from the 'current-terms' table by joining it with the 'current' table based on the bioguide ID. It filters the results based on the legislator's first name, last name, and the start date of their term."
        },
        {
            "sample_id": 4769,
            "vt": "SELECT historical.first_name, historical.last_name FROM historical INNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE historical-terms.party = '[placeholder-type:string]' AND CAST(historical-terms.start AS DATE) <= [placeholder-type:numeric] AND CAST(historical-terms.end AS DATE) >= [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the first and last names of legislators from the 'historical' table who have served during a specific time frame and belong to a specified political party. The query joins the 'historical' table with the 'historical-terms' table using the bioguide ID to filter results based on party affiliation and the start and end dates of their terms."
        },
        {
            "sample_id": 4900,
            "vt": "SELECT CASE WHEN SUM(CASE WHEN current.official_full_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) > SUM(CASE WHEN current.official_full_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide",
            "ba": "The virtual table calculates a comparison between two legislators based on their official full names. It sums up certain numeric values associated with each legislator and determines which one has a greater total. The result will indicate which legislator has a higher sum, using placeholders for the names and numeric values involved in the calculation."
        },
        {
            "sample_id": 4803,
            "vt": "SELECT current.official_full_name, social-media.twitter_id, social-media.youtube_id FROM \"social-media\" INNER JOIN current AS T2 ON T1.bioguide = T2.bioguide_id WHERE current.first_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides the official full name of legislators along with their Twitter and YouTube IDs from the 'social-media' table. It joins the 'social-media' table with the 'current' table based on the bioguide ID, filtering results to include only those legislators whose first name matches a specified value."
        },
        {
            "sample_id": 4908,
            "vt": "SELECT historical.maplight_id FROM historical INNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE historical-terms.type = '[placeholder-type:string]' AND historical-terms.state = '[placeholder-type:string]' GROUP BY historical.maplight_id",
            "ba": "The virtual table retrieves the maplight ID of legislators from the historical data based on their term type and state. It joins the historical table with the historical-terms table using the bioguide ID to filter results according to the specified term type and state."
        },
        {
            "sample_id": 4786,
            "vt": "SELECT current.official_full_name FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current-terms.party = '[placeholder-type:string]' AND NOT current.nickname_name IS NULL GROUP BY current.official_full_name",
            "ba": "The virtual table provides a list of official full names of legislators from the 'current' table who are affiliated with a specific political party and have a nickname. It joins the 'current' table with the 'current-terms' table based on the bioguide ID, filtering results based on the party affiliation and ensuring that only those with a nickname are included."
        },
        {
            "sample_id": 4882,
            "vt": "SELECT CASE WHEN SUM(CAST(STRFTIME('%Y', current-terms.end) AS INT) - CAST(STRFTIME('%Y', current-terms.start) AS INT)) = [placeholder-type:numeric] THEN current.official_full_name END FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current.religion_bio = '[placeholder-type:string]' AND current-terms.state = '[placeholder-type:string]' AND current-terms.type = '[placeholder-type:string]'",
            "ba": "The virtual table identifies the full names of legislators from the 'current' table whose terms have a specific duration, filtered by their religion, state, and type of term (senator or representative). The placeholders represent the numeric duration of the term, the legislator's religion, the state they represent, and the type of legislative position they hold."
        },
        {
            "sample_id": 4859,
            "vt": "SELECT social-media.twitter_id FROM \"social-media\" INNER JOIN current AS T2 ON T2.bioguide_id = T1.bioguide WHERE current.first_name = '[placeholder-type:string]' AND current.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the Twitter ID of a legislator from the 'social-media' table by joining it with the 'current' table based on the legislator's bioguide ID. It filters the results to find a specific legislator using their first and last names, which are provided as placeholders."
        },
        {
            "sample_id": 4842,
            "vt": "SELECT historical-terms.type, historical-terms.end FROM historical INNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE historical.first_name = '[placeholder-type:string]' AND historical.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the type of legislative term and the end date of that term for a specific legislator. It retrieves this data by joining the 'historical' table with the 'historical-terms' table based on the legislator's unique bioguide ID. The query filters results based on the legislator's first and last names, which are provided as placeholders."
        },
        {
            "sample_id": 4838,
            "vt": "SELECT historical-terms.district FROM historical INNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE historical.last_name = '[placeholder-type:string]' AND historical.first_name = '[placeholder-type:string]' AND historical-terms.type = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the district information of legislators from the historical data based on their names and term type. It joins the 'historical' table with the 'historical-terms' table using the bioguide ID to ensure that the correct term information is associated with the right legislator. The placeholders in the WHERE clause represent the last name, first name, and type of the legislator's term (either 'sen' for senators or 'rep' for representatives)."
        },
        {
            "sample_id": 4832,
            "vt": "SELECT historical.first_name, historical.last_name FROM \"historical-terms\" INNER JOIN historical AS T2 ON T2.bioguide_id = T1.bioguide WHERE historical-terms.district = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of legislators from the 'historical' table who have served in a specific district, as indicated by the 'district' column in the 'historical-terms' table. The query uses an inner join to connect the 'historical-terms' table with the 'historical' table based on the bioguide ID, ensuring that only relevant legislators are selected based on their district."
        },
        {
            "sample_id": 4852,
            "vt": "SELECT CAST(SUM(CASE WHEN NOT historical.wikipedia_id IS NULL THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(historical.bioguide_id) FROM historical",
            "ba": "The virtual table calculates the weighted average of Wikipedia presence among legislators from the 'historical' table. It sums up the total number of legislators who have a Wikipedia ID and multiplies it by a specified weight, then divides by the total count of legislators to get the average."
        },
        {
            "sample_id": 4800,
            "vt": "SELECT historical.bioguide_id, historical.first_name, historical.last_name FROM \"historical-terms\" INNER JOIN historical AS T2 ON T2.bioguide_id = T1.bioguide WHERE historical-terms.party = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the bioguide ID, first name, and last name of legislators from the 'historical' table who have served in a specific political party as indicated in the 'historical-terms' table. The query uses an inner join to connect the two tables based on the bioguide ID, ensuring that only those legislators who have a record in both tables are included in the results. The placeholder in the WHERE clause represents the party name."
        },
        {
            "sample_id": 4860,
            "vt": "SELECT social-media.facebook_id FROM \"current-terms\" INNER JOIN \"social-media\" AS T2 ON T1.bioguide = T2.bioguide WHERE current-terms.party = '[placeholder-type:string]' GROUP BY social-media.facebook_id",
            "ba": "The virtual table retrieves the Facebook IDs of legislators from the 'current-terms' table who belong to a specific political party. It joins the 'current-terms' table with the 'social-media' table based on the bioguide ID, ensuring that only those legislators who are currently serving and belong to the specified party are included in the results."
        },
        {
            "sample_id": 4739,
            "vt": "SELECT COUNT(*) FROM current WHERE (current.fec_id IS NULL OR current.fec_id = '[placeholder-type:string]') AND current.gender_bio = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of legislators from the 'current' table who either do not have a Federal Election Commission ID or have a specific FEC ID, and who also belong to a specified gender category. The placeholders represent the FEC ID and gender of the legislators."
        },
        {
            "sample_id": 4760,
            "vt": "SELECT COUNT(*) FROM current WHERE current.religion_bio = '[placeholder-type:string]' AND current.gender_bio = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of legislators from the 'current' table who belong to a specific religion and gender. The placeholders in the WHERE clause represent the religion and gender of the legislators."
        },
        {
            "sample_id": 4754,
            "vt": "SELECT CAST(COUNT(current-terms.bioguide) AS FLOAT) / COUNT(DISTINCT T1.bioguide_id) FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current.gender_bio = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the ratio of current terms held by legislators of a specific gender to the total number of distinct legislators in the 'current' table. It uses a join between the 'current' and 'current-terms' tables based on the bioguide ID, filtering by the specified gender."
        },
        {
            "sample_id": 4745,
            "vt": "SELECT social-media.youtube FROM current INNER JOIN \"social-media\" AS T2 ON T2.bioguide = T1.bioguide_id WHERE current.gender_bio = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the YouTube channel information of legislators from the 'social-media' table, specifically for those whose gender matches a specified value. It joins the 'current' table to access the legislators' bioguide IDs, ensuring that only the relevant records are selected based on the gender condition."
        },
        {
            "sample_id": 4834,
            "vt": "SELECT current.opensecrets_id, current.thomas_id FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current-terms.type = '[placeholder-type:string]' AND current-terms.state = '[placeholder-type:string]' GROUP BY current.opensecrets_id, current.thomas_id",
            "ba": "The virtual table retrieves the OpenSecrets and Thomas IDs of legislators from the 'current' table, joining it with the 'current-terms' table to filter based on the type of term (senator or representative) and the state they represent. The placeholders in the WHERE clause allow users to specify the type of term and the state code for their query."
        },
        {
            "sample_id": 4872,
            "vt": "SELECT current.official_full_name FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current-terms.party = '[placeholder-type:string]' AND STRFTIME('%Y', current-terms.start) >= '[placeholder-type:string]' AND current-terms.type = '[placeholder-type:string]' AND current-terms.caucus = '[placeholder-type:string]'",
            "ba": "The virtual table describes the official full names of legislators from the 'current' table who are members of a specific political party, have a term that started on or after a specified year, and belong to a certain type of legislative body (either senator or representative). The placeholders in the WHERE clause represent the party name, the start year of the term, the type of the term, and the caucus affiliation."
        },
        {
            "sample_id": 4887,
            "vt": "SELECT current.religion_bio FROM current WHERE current.official_full_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the religion of a legislator from the 'current' table based on their official full name. The placeholder in the WHERE clause represents the legislator's official full name."
        },
        {
            "sample_id": 4738,
            "vt": "SELECT COUNT(current.bioguide_id) FROM current WHERE current.birthday_bio >= '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of legislators from the 'current' table whose birthday is on or after a specified date. The placeholder in the WHERE clause represents the date to filter the legislators' birthdays."
        },
        {
            "sample_id": 4870,
            "vt": "SELECT current-terms.bioguide FROM \"current-terms\" WHERE current-terms.type = '[placeholder-type:string]' AND current-terms.party = '[placeholder-type:string]' AND current-terms.end = '[placeholder-type:string]' AND current-terms.district = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the bioguide ID of legislators from the 'current-terms' table based on specific criteria. The placeholders represent the type of legislator (senator or representative), their political party, the end date of their term, and their district number if applicable."
        },
        {
            "sample_id": 4793,
            "vt": "SELECT current.official_full_name FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current-terms.party = '[placeholder-type:string]' GROUP BY current.official_full_name",
            "ba": "The virtual table describes the official full names of legislators from the 'current' table who belong to a specific political party. The query joins the 'current' table with the 'current-terms' table using the bioguide ID to filter the results based on the party affiliation."
        },
        {
            "sample_id": 4878,
            "vt": "SELECT DISTINCT CASE WHEN SUM(CAST(STRFTIME('%Y', current-terms.end) AS INT) - CAST(STRFTIME('%Y', current-terms.start) AS INT)) = [placeholder-type:numeric] THEN current.official_full_name END FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide GROUP BY current.official_full_name, current-terms.district HAVING COUNT(current.official_full_name) = [placeholder-type:numeric]",
            "ba": "The virtual table identifies legislators based on the duration of their current terms and the number of terms they have served. It selects the official full names of legislators whose total years in office match a specified value, grouping the results by their names and districts. The placeholders allow users to specify the desired duration and count of terms."
        },
        {
            "sample_id": 4886,
            "vt": "SELECT COUNT(current.lis_id) FROM current WHERE current.gender_bio = '[placeholder-type:string]' AND NOT current.lis_id IS NULL",
            "ba": "The virtual table counts the number of legislators from the 'current' table who have a specified gender and have participated in Senate roll call votes. The placeholder in the WHERE clause represents the gender of the legislators being queried."
        },
        {
            "sample_id": 4790,
            "vt": "SELECT current-terms.\"end\", current-terms.party FROM \"current-terms\" WHERE STRFTIME('%Y', current-terms.\"end\") = '[placeholder-type:string]' AND current-terms.party = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the end date of legislative terms and the political party affiliation of legislators from the 'current-terms' table. The placeholders in the WHERE clause allow users to filter results based on a specific year for the term end date and a specific political party."
        },
        {
            "sample_id": 4767,
            "vt": "SELECT social-media.govtrack FROM current INNER JOIN \"social-media\" AS T2 ON T2.bioguide = T1.bioguide_id WHERE current.official_full_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the GovTrack ID of a legislator from the 'social-media' table by joining it with the 'current' table based on the legislator's bioguide ID. The query filters the results to find the specific legislator using their official full name."
        },
        {
            "sample_id": 4784,
            "vt": "SELECT current-terms.contact_form FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current.official_full_name = '[placeholder-type:string]' GROUP BY current-terms.contact_form",
            "ba": "The virtual table retrieves the contact form URL for a legislator from the 'current-terms' table by joining it with the 'current' table based on the legislator's bioguide ID. The query filters results to find the contact form for a specific legislator identified by their official full name, and groups the results to ensure unique contact form URLs are returned."
        },
        {
            "sample_id": 4759,
            "vt": "SELECT COUNT(*) FROM historical WHERE historical.gender_bio = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of legislators from the 'historical' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the legislators being queried."
        },
        {
            "sample_id": 4821,
            "vt": "SELECT social-media.instagram FROM \"social-media\" INNER JOIN current AS T2 ON T1.bioguide = T2.bioguide_id WHERE current.birthday_bio = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the Instagram handle of legislators from the 'social-media' table who were born on a specific date. The query joins the 'social-media' table with the 'current' table using the bioguide ID to ensure that only current legislators are considered. The placeholder in the WHERE clause represents the birthday of the legislator."
        },
        {
            "sample_id": 4828,
            "vt": "SELECT historical-terms.district FROM \"historical-terms\" WHERE historical-terms.party = '[placeholder-type:string]' GROUP BY historical-terms.district",
            "ba": "The virtual table retrieves the districts of legislators from the 'historical-terms' table who belong to a specific political party. The results are grouped by district to provide a unique list of districts associated with that party."
        },
        {
            "sample_id": 4813,
            "vt": "SELECT current.first_name FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current-terms.state_rank = '[placeholder-type:string]' GROUP BY current.first_name",
            "ba": "The virtual table describes the first names of legislators from the 'current' table who hold a specific state rank, by joining with the 'current-terms' table. The placeholder in the WHERE clause represents the state rank of the legislators."
        },
        {
            "sample_id": 4827,
            "vt": "SELECT COUNT(*) FROM current WHERE current.first_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of legislators from the 'current' table whose first name matches a specified value. The placeholder in the WHERE clause represents the first name of the legislator being queried."
        },
        {
            "sample_id": 4765,
            "vt": "SELECT current.last_name FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current-terms.state = '[placeholder-type:string]' GROUP BY current.last_name",
            "ba": "The virtual table describes the last names of legislators from the 'current' table who are currently serving in a specific state. The query joins the 'current' table with the 'current-terms' table based on the bioguide ID, filtering results by the state specified in the placeholder."
        },
        {
            "sample_id": 4891,
            "vt": "SELECT social-media.facebook FROM current INNER JOIN \"social-media\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE NOT current.wikipedia_id IS NULL GROUP BY social-media.facebook",
            "ba": "The virtual table retrieves the Facebook usernames of legislators from the 'social-media' table who have a corresponding entry in the 'current' table and are notable enough to have a Wikipedia page. The query uses an INNER JOIN to connect the two tables based on the bioguide ID, ensuring that only those legislators with a Wikipedia ID are included in the results. The results are grouped by the Facebook usernames to avoid duplicates."
        },
        {
            "sample_id": 4849,
            "vt": "SELECT COUNT(current-terms.district) FROM \"current-terms\" WHERE current-terms.state = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of current legislative districts in a specified state from the 'current-terms' table. The placeholder in the WHERE clause represents the state code for which the count is being requested."
        },
        {
            "sample_id": 4837,
            "vt": "SELECT current-terms.party FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current.official_full_name = '[placeholder-type:string]' GROUP BY current-terms.party",
            "ba": "The virtual table retrieves the political party affiliation of a legislator from the 'current-terms' table by joining it with the 'current' table based on the legislator's unique bioguide ID. The query filters results to a specific legislator identified by their official full name, and groups the results by party to ensure distinct party affiliations are returned."
        },
        {
            "sample_id": 4830,
            "vt": "SELECT historical.google_entity_id_id FROM historical WHERE historical.first_name = '[placeholder-type:string]' AND historical.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the Google entity ID for a legislator from the 'historical' table based on their first and last names. This ID is used to identify the legislator in Google's database, which may provide additional information about their public presence."
        },
        {
            "sample_id": 4817,
            "vt": "SELECT social-media.twitter FROM current INNER JOIN \"social-media\" AS T2 ON T2.bioguide = T1.bioguide_id WHERE current.birthday_bio = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the Twitter handle of legislators from the 'current' table who have a specific birthday. It joins the 'current' table with the 'social-media' table using the bioguide ID to ensure that the correct social media information is associated with each legislator."
        },
        {
            "sample_id": 4871,
            "vt": "SELECT social-media.twitter FROM current INNER JOIN \"social-media\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current.official_full_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the Twitter handle of a legislator from the 'social-media' table by joining it with the 'current' table based on the legislator's bioguide ID. The query filters the results to find the specific legislator using their official full name."
        },
        {
            "sample_id": 4898,
            "vt": "SELECT COUNT(*) FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current.official_full_name = '[placeholder-type:string]' AND current-terms.district = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of current terms for a legislator based on their official full name and district number. It joins the 'current' table, which contains information about legislators, with the 'current-terms' table, which holds details about their current terms, using the bioguide ID as a foreign key."
        },
        {
            "sample_id": 4750,
            "vt": "SELECT current.official_full_name FROM \"current-terms\" INNER JOIN current AS T2 ON T2.bioguide_id = T1.bioguide WHERE NOT current-terms.state_rank IS NULL",
            "ba": "The virtual table retrieves the official full names of legislators from the 'current-terms' table who are currently serving and have a defined state rank. It joins the 'current' table to access additional details about the legislators using their bioguide IDs."
        },
        {
            "sample_id": 4847,
            "vt": "SELECT COUNT(historical.bioguide_id) FROM historical WHERE historical.birthday_bio LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of legislators from the 'historical' table whose birthday matches a specific pattern. The placeholder in the LIKE clause represents the birthday format that is being searched for."
        },
        {
            "sample_id": 4802,
            "vt": "SELECT SUM(CASE WHEN \"current-terms\".start LIKE '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - (SELECT SUM(CASE WHEN current-terms.start LIKE '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"historical-terms\") FROM \"current-terms\"",
            "ba": "The virtual table calculates the difference between the total number of current legislative terms that started on a specific date and the total number of historical terms that started on the same date. It uses placeholders to allow users to specify the date and numeric values for the calculations."
        },
        {
            "sample_id": 4868,
            "vt": "SELECT COUNT(*) FROM \"current-terms\" WHERE current-terms.state = '[placeholder-type:string]' AND current-terms.type = '[placeholder-type:string]' AND current-terms.end LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of current legislators from a specific state and type (either senator or representative) whose term has ended on a specified date. The placeholders represent the state code, the type of legislator, and the end date of their term."
        },
        {
            "sample_id": 4822,
            "vt": "SELECT COUNT(*) FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current.gender_bio = '[placeholder-type:string]' AND (current-terms.class IS NULL OR current-terms.class = '[placeholder-type:string]')",
            "ba": "The virtual table counts the number of current legislators based on their gender and whether they are senators or representatives. It joins the 'current' table with the 'current-terms' table using the bioguide ID to filter the results. The placeholders represent the gender of the legislators and the class of senators, allowing for flexibility in querying specific groups of legislators."
        },
        {
            "sample_id": 4766,
            "vt": "SELECT current.first_name, current.last_name FROM \"current-terms\" INNER JOIN current AS T2 ON T2.bioguide_id = T1.bioguide WHERE current-terms.type = '[placeholder-type:string]' AND current.gender_bio = '[placeholder-type:string]' GROUP BY current.ballotpedia_id",
            "ba": "The virtual table describes the first and last names of legislators from the 'current' table who are currently serving in a specific type of term (either senator or representative) and belong to a specified gender. The query joins the 'current-terms' table to filter based on the type of term and uses placeholders for the type and gender values."
        },
        {
            "sample_id": 4884,
            "vt": "SELECT current.official_full_name FROM current WHERE NOT current.house_history_id IS NULL",
            "ba": "The virtual table provides the official full names of legislators from the 'current' table who have served in the U.S. House, as indicated by the presence of a non-null 'house_history_id'."
        },
        {
            "sample_id": 4778,
            "vt": "SELECT current.official_full_name FROM \"social-media\" INNER JOIN current AS T2 ON T1.bioguide = T2.bioguide_id WHERE NOT social-media.facebook IS NULL AND (social-media.instagram IS NULL OR social-media.instagram = '[placeholder-type:string]') LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of official full names of legislators from the 'current' table who have an active Facebook presence but either do not have an Instagram account or have a specific Instagram account specified by the user. The query limits the results to a specified number."
        },
        {
            "sample_id": 4747,
            "vt": "SELECT SUM(CASE WHEN social-media.instagram IS NULL THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM \"social-media\" INNER JOIN current AS T2 ON T1.bioguide = T2.bioguide_id WHERE current.opensecrets_id IS NULL OR current.opensecrets_id = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total count of legislators who do not have an Instagram account from the 'social-media' table, while joining with the 'current' table to filter based on the OpenSecrets ID. The placeholder in the WHERE clause allows for specifying a particular OpenSecrets ID or checking for null values."
        },
        {
            "sample_id": 4755,
            "vt": "SELECT CAST(SUM(CASE WHEN social-media.instagram IS NULL THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM \"social-media\" INNER JOIN current AS T2 ON T1.bioguide = T2.bioguide_id WHERE current.religion_bio = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of legislators with an Instagram presence based on their religion. It sums up the cases where the Instagram field is null and divides it by the total count of legislators, adjusting the result by a specified multiplier."
        },
        {
            "sample_id": 4762,
            "vt": "SELECT current.official_full_name FROM \"current-terms\" INNER JOIN current AS T2 ON T2.bioguide_id = T1.bioguide WHERE current-terms.state_rank = '[placeholder-type:string]' AND current-terms.type = '[placeholder-type:string]' AND current-terms.start LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the official full names of legislators from the 'current-terms' table who hold a specific state rank and type, filtered by their start date. The placeholders represent the state rank, type of the legislator (senator or representative), and the start date of their term."
        },
        {
            "sample_id": 4841,
            "vt": "SELECT historical-terms.state, historical-terms.type FROM historical INNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE historical.google_entity_id_id = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the state and type of legislative terms for legislators who are recognized as Google entities. It combines data from the 'historical' table and the 'historical-terms' table, linking them through the bioguide ID. The placeholder in the WHERE clause represents the Google entity ID of the legislator being queried."
        },
        {
            "sample_id": 4876,
            "vt": "SELECT COUNT((SELECT T2.district FROM current AS T1 INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.official_full_name = 'John Conyers, Jr.' GROUP BY T2.district).district) FROM (SELECT current-terms.district FROM current AS T1 INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.official_full_name = 'John Conyers, Jr.' GROUP BY T2.district) AS t3",
            "ba": "The virtual table counts the number of unique districts represented by a legislator based on their official full name. It retrieves data from the 'current' and 'current-terms' tables, joining them on the bioguide ID to filter for the specified legislator and group the results by district."
        },
        {
            "sample_id": 4899,
            "vt": "SELECT current.official_full_name FROM current INNER JOIN \"social-media\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE social-media.facebook = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the official full names of legislators from the 'current' table who have a specific Facebook presence. It joins the 'current' table with the 'social-media' table using the bioguide ID to filter for those legislators whose Facebook username matches the provided placeholder."
        },
        {
            "sample_id": 4810,
            "vt": "SELECT COUNT(current-terms.bioguide) FROM \"current-terms\" WHERE current-terms.title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of current terms for legislators with a specific title from the 'current-terms' table. The placeholder in the WHERE clause represents the title of the legislator, such as 'Senator' or 'Representative'."
        },
        {
            "sample_id": 4855,
            "vt": "SELECT historical-terms.district FROM historical INNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE historical.first_name = '[placeholder-type:string]' AND historical.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the district information of legislators from the historical data based on their first and last names. It joins the 'historical' table with the 'historical-terms' table using the bioguide ID to ensure that the correct district is associated with the respective legislator."
        },
        {
            "sample_id": 4885,
            "vt": "SELECT COUNT(*) FROM current WHERE NOT current.icpsr_id IS NULL AND NOT current.maplight_id IS NULL",
            "ba": "The virtual table counts the number of legislators from the 'current' table who have both an ICPSR ID and a MapLight ID. This indicates that these legislators are recognized in both the VoteView.com and MapLight databases, which track legislative voting behavior and campaign finance data respectively."
        },
        {
            "sample_id": 4753,
            "vt": "SELECT COUNT(subquery_q0.cid) FROM (SELECT current.bioguide_id FROM current AS T1 INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.birthday_bio >= '1960-01-01' GROUP BY T2.bioguide HAVING COUNT(T2.bioguide) > 6)",
            "ba": "The virtual table counts the number of legislators who were born on or after a specific date and have served more than six terms in the current legislative body. It retrieves the unique bioguide IDs from the 'current' table, joins it with the 'current-terms' table to filter based on the number of terms served, and groups the results accordingly."
        },
        {
            "sample_id": 4812,
            "vt": "SELECT current.gender_bio FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current-terms.address = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the gender information of legislators from the 'current' table, specifically for those who have a current term associated with a specified address. The query joins the 'current' table with the 'current-terms' table using the bioguide ID to ensure that only legislators with a matching address in their current term are selected."
        },
        {
            "sample_id": 4806,
            "vt": "SELECT COUNT(*) FROM current WHERE current.fec_id IS NULL OR current.fec_id = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of legislators from the 'current' table who either do not have a Federal Election Commission (FEC) ID or have a specific FEC ID provided by the user. The placeholder in the WHERE clause represents the FEC ID that can be specified by the user."
        },
        {
            "sample_id": 4764,
            "vt": "SELECT CASE WHEN NOT social-media.facebook IS NULL THEN [placeholder-type:numeric] END + CASE WHEN NOT social-media.instagram IS NULL THEN [placeholder-type:numeric] END + CASE WHEN NOT social-media.twitter IS NULL THEN [placeholder-type:numeric] END + CASE WHEN NOT social-media.youtube IS NULL THEN [placeholder-type:numeric] END FROM \"social-media\" INNER JOIN current AS T2 ON T1.bioguide = T2.bioguide_id WHERE current.first_name = '[placeholder-type:string]' AND current.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of social media accounts for a legislator by checking their presence on Facebook, Instagram, Twitter, and YouTube. It retrieves this information from the 'social-media' table and joins it with the 'current' table to filter by the legislator's first and last name. The placeholders represent the first and last names of the legislator, while the numeric values indicate the presence of each social media account."
        },
        {
            "sample_id": 4895,
            "vt": "SELECT current.official_full_name FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current-terms.start = '[placeholder-type:string]'",
            "ba": "The virtual table describes the official full names of legislators from the 'current' table who have a term starting on a specific date. The query joins the 'current' table with the 'current-terms' table using the bioguide ID to filter for legislators whose terms began on the specified start date."
        },
        {
            "sample_id": 4791,
            "vt": "SELECT current.official_full_name, current.gender_bio FROM current WHERE current.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the official full name and gender of legislators from the 'current' table who have a specific last name. The placeholder in the WHERE clause represents the last name of the legislator."
        },
        {
            "sample_id": 4824,
            "vt": "SELECT COUNT(*) FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current-terms.title = '[placeholder-type:string]' AND (current.fec_id IS NULL OR current.fec_id = '[placeholder-type:string]')",
            "ba": "The virtual table counts the number of legislators from the 'current' table who hold a specific title and either do not have a Federal Election Commission ID or have a specific FEC ID. It joins the 'current' table with the 'current-terms' table based on the bioguide ID to filter the results accordingly."
        },
        {
            "sample_id": 4741,
            "vt": "SELECT current.official_full_name FROM current WHERE current.official_full_name = '[placeholder-type:string]' OR current.official_full_name = '[placeholder-type:string]' ORDER BY current.birthday_bio LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the official full names of legislators from the 'current' table based on specified names. It allows for filtering by two different official full names and limits the results to a specified number. The placeholders represent the names to search for and the limit on the number of results returned."
        },
        {
            "sample_id": 4783,
            "vt": "SELECT current.official_full_name FROM current INNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE current-terms.party = '[placeholder-type:string]' AND current-terms.state_rank = '[placeholder-type:string]' GROUP BY current.official_full_name",
            "ba": "The virtual table retrieves the official full names of legislators from the 'current' table who are affiliated with a specific political party and hold a specific state rank. The query joins the 'current' table with the 'current-terms' table based on the bioguide ID, ensuring that only those legislators who meet the specified criteria are included in the results."
        }
    ],
    "student_club": [
        {
            "sample_id": 10869,
            "vt": "SELECT DISTINCT event.event_name, event.location FROM event INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE budget.remaining > [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct names and locations of events from the 'event' table that have a remaining budget greater than a specified amount. The query joins the 'event' table with the 'budget' table to filter events based on their budget status."
        },
        {
            "sample_id": 10843,
            "vt": "SELECT CAST(SUM(CASE WHEN major.major_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(member.member_id) FROM member INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE member.position = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of a specific numeric value based on the major of members who hold a certain position. It sums up a conditional value for members linked to a specific major and divides it by the count of members in that position, adjusting the result by a specified multiplier."
        },
        {
            "sample_id": 10870,
            "vt": "SELECT event.event_name, event.event_date FROM event INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE expense.expense_description = '[placeholder-type:string]' AND expense.cost > [placeholder-type:numeric] AND expense.cost < [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of event names and their corresponding dates from the 'event' table. It filters the results based on specific criteria related to expenses associated with each event. The query joins the 'event' table with the 'budget' table to link events to their budgets, and then further joins with the 'expense' table to access details about expenses. The placeholders in the WHERE clause allow users to specify an expense description and a range for the cost of expenses, ensuring that only events with certain types of expenses within a specified cost range are included in the results."
        },
        {
            "sample_id": 10834,
            "vt": "SELECT expense.expense_description FROM member INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE member.t_shirt_size = '[placeholder-type:string]'",
            "ba": "The virtual table describes the expense descriptions incurred by members who have a specific t-shirt size. It retrieves data from the 'member' table and joins it with the 'expense' table based on the member's unique identifier. The placeholder in the WHERE clause represents the t-shirt size of the members."
        },
        {
            "sample_id": 10757,
            "vt": "SELECT budget.spent FROM event INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE event.event_name = '[placeholder-type:string]' AND budget.category = '[placeholder-type:string]' AND SUBSTRING(event.event_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the total amount spent from the 'budget' table for a specific event, identified by its name, and a specific budget category. It filters the results based on the event's name, the budget category, and a substring of the event date, which is specified by numeric placeholders for start and length."
        },
        {
            "sample_id": 10755,
            "vt": "SELECT zip_code.city, zip_code.state FROM member INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE member.position = '[placeholder-type:string]'",
            "ba": "The virtual table describes the cities and states of members based on their zip codes from the 'member' table. It filters the results to include only those members who hold a specific position within the organization. The placeholder in the WHERE clause represents the member's position."
        },
        {
            "sample_id": 10863,
            "vt": "SELECT COUNT(member.member_id) FROM member INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE member.position = '[placeholder-type:string]' AND major.major_name LIKE '[placeholder-type:string]' AND major.college = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of members from the 'member' table who hold a specific position, belong to a specific major, and are enrolled in a specific college. The placeholders in the WHERE clause represent the member's position, the major's name, and the college's name."
        },
        {
            "sample_id": 10741,
            "vt": "SELECT major.college FROM member INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE member.position LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the college names associated with members based on their position within the organization. It joins the 'member' table with the 'major' table using the unique identifier for the major, allowing for a filtered selection of colleges where members hold specific positions."
        },
        {
            "sample_id": 10824,
            "vt": "SELECT member.t_shirt_size FROM member GROUP BY member.t_shirt_size ORDER BY COUNT(member.t_shirt_size) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the t-shirt sizes requested by members, grouped by size and ordered by the count of each size. The placeholder in the LIMIT clause allows for specifying the maximum number of sizes to return."
        },
        {
            "sample_id": 10753,
            "vt": "SELECT income.amount FROM member INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE member.position = '[placeholder-type:string]'",
            "ba": "The virtual table displays the total amount of income received by members of a specific position from the 'member' and 'income' tables. The placeholder in the WHERE clause represents the position of the member."
        },
        {
            "sample_id": 10876,
            "vt": "SELECT SUM(CASE WHEN event.type = '[placeholder-type:string]' THEN expense.cost ELSE [placeholder-type:numeric] END) * [placeholder-type:numeric] / SUM(expense.cost) FROM event INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget",
            "ba": "The virtual table calculates the weighted average cost of expenses for events of a specific type. It sums the costs of expenses associated with events that match the specified type, applies a multiplier, and divides by the total sum of expenses to get the average. The placeholders represent the event type, a numeric value for multiplication, and the numeric result of the calculation."
        },
        {
            "sample_id": 10830,
            "vt": "SELECT SUM(expense.cost) FROM expense WHERE expense.expense_description = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total cost of expenses from the 'expense' table based on a specific expense description. The placeholder in the WHERE clause represents the description of the expense for which the total cost is being calculated."
        },
        {
            "sample_id": 10804,
            "vt": "SELECT member.first_name, member.last_name FROM major INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id WHERE event.event_name = '[placeholder-type:string]' AND major.major_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of members who attended a specific event related to a particular major. It combines data from the 'major', 'member', 'attendance', and 'event' tables, filtering based on the event name and major name provided by the user."
        },
        {
            "sample_id": 10835,
            "vt": "SELECT member.zip FROM member INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE expense.cost < [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the ZIP codes of members who have incurred expenses below a specified cost. It joins the 'member' table with the 'expense' table based on the member's unique identifier, allowing for filtering of members based on their expense amounts."
        },
        {
            "sample_id": 10795,
            "vt": "SELECT COUNT(member.member_id) FROM zip_code INNER JOIN member AS T2 ON T1.zip_code = T2.zip WHERE zip_code.state = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of members from the 'member' table who reside in a specific state, as indicated by the 'zip_code' table. It uses an inner join to connect the two tables based on the zip code, filtering the results to only include members from the specified state."
        },
        {
            "sample_id": 10860,
            "vt": "SELECT major.college FROM member INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE member.link_to_major = '[placeholder-type:string]' AND member.first_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the college name associated with a specific major for a member identified by their first name. It joins the 'member' table with the 'major' table using the major identifier, filtering results based on the member's major and first name."
        },
        {
            "sample_id": 10789,
            "vt": "SELECT major.college FROM member INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id GROUP BY major.major_id ORDER BY COUNT(major.college) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of colleges offering majors, based on the members' declared majors. It groups the results by major to count how many members are associated with each college, and limits the output to a specified number of colleges."
        },
        {
            "sample_id": 10885,
            "vt": "SELECT event.event_name FROM event INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE budget.category = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of events from the 'event' table that are associated with a specific budget category. The query uses an INNER JOIN to connect the 'event' table with the 'budget' table based on the event identifier, filtering results to only include those that match the specified budget category."
        },
        {
            "sample_id": 10874,
            "vt": "SELECT AVG(expense.cost) FROM expense INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE member.position <> '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average cost of expenses incurred by members who do not hold a specific position in the club. It joins the 'expense' table with the 'member' table to filter out members based on their position, using a placeholder for the position value."
        },
        {
            "sample_id": 10827,
            "vt": "SELECT budget.category, SUM(budget.amount) FROM event JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE event.event_name = '[placeholder-type:string]' GROUP BY budget.category ORDER BY SUM(budget.amount)",
            "ba": "The virtual table summarizes the total budgeted amounts for different categories associated with a specific event. It retrieves the event name and groups the results by budget category, allowing users to see how much is allocated to each category for the specified event."
        },
        {
            "sample_id": 10749,
            "vt": "SELECT member.first_name, member.last_name FROM member INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE event.event_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of members who attended a specific event from the 'member' table. It joins the 'attendance' table to link members to events they attended and filters the results based on the event's name using a placeholder for string values."
        },
        {
            "sample_id": 10793,
            "vt": "SELECT COUNT(attendance.link_to_member) FROM event INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE event.event_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of members who attended a specific event from the 'event' table. It joins the 'event' table with the 'attendance' table to link events with their attendees. The placeholder in the WHERE clause represents the name of the event for which the attendance count is being queried."
        },
        {
            "sample_id": 10831,
            "vt": "SELECT SUM(expense.cost) FROM expense WHERE expense.expense_date = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total cost of expenses recorded in the 'expense' table for a specific date. The placeholder in the WHERE clause represents the date for which the total expenses are being calculated."
        },
        {
            "sample_id": 10747,
            "vt": "SELECT expense.expense_description FROM expense ORDER BY expense.cost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the descriptions of expenses recorded in the 'expense' table, ordered by the cost of each expense. The placeholder in the LIMIT clause allows the user to specify how many expense descriptions they want to retrieve."
        },
        {
            "sample_id": 10832,
            "vt": "SELECT member.first_name, member.last_name, SUM(expense.cost) FROM member INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE member.member_id = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total expenses incurred by a specific member from the 'member' table. It retrieves the first and last names of the member along with the total cost of their expenses. The placeholder in the WHERE clause represents the unique identifier of the member whose expenses are being queried."
        },
        {
            "sample_id": 10807,
            "vt": "SELECT member.first_name, member.last_name FROM member INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE income.amount > [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of members from the 'member' table who have received income greater than a specified amount. The query uses an inner join with the 'income' table to filter members based on their income amount, represented by a placeholder for numeric values."
        },
        {
            "sample_id": 10851,
            "vt": "SELECT event.event_name FROM attendance INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id WHERE member.position = '[placeholder-type:string]' AND event.location = '[placeholder-type:string]' AND event.type = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of events that members with a specific position attended, filtered by the event's location and type. The placeholders in the WHERE clause represent the member's position, the event's location, and the type of event."
        },
        {
            "sample_id": 10759,
            "vt": "SELECT SUM(budget.amount) FROM event INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE event.event_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total budgeted amount for a specific event from the 'event' and 'budget' tables. It uses an inner join to link the two tables based on the event identifier, filtering the results by the event name provided as a placeholder."
        },
        {
            "sample_id": 10857,
            "vt": "SELECT DISTINCT event.event_name FROM event WHERE event.type = '[placeholder-type:string]' AND DATE(SUBSTRING(event.event_date, [placeholder-type:numeric], [placeholder-type:numeric])) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND event.status = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct event names from the 'event' table based on specific criteria. It filters events by their type, checks if the event date falls within a specified date range, and ensures that the event status matches a given value."
        },
        {
            "sample_id": 10767,
            "vt": "SELECT COUNT(major.major_name) FROM major WHERE major.college = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of majors offered by a specific college from the 'major' table. The placeholder in the WHERE clause represents the name of the college."
        },
        {
            "sample_id": 10844,
            "vt": "SELECT DISTINCT budget.category FROM event INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE event.location = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct budget categories associated with events held at a specific location. It retrieves data from the 'event' table and joins it with the 'budget' table to filter the results based on the event's location."
        },
        {
            "sample_id": 10771,
            "vt": "SELECT SUM(budget.amount) FROM budget INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE event.event_name = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total budgeted amount for a specific event from the 'budget' table. It joins the 'budget' table with the 'event' table to filter the results based on the event's name, which is represented by a placeholder."
        },
        {
            "sample_id": 10758,
            "vt": "SELECT major.department FROM member INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE member.last_name = '[placeholder-type:string]' OR member.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the department names associated with members whose last names match specified values. It joins the 'member' table with the 'major' table based on the major identifier, allowing for the extraction of department information related to the members."
        },
        {
            "sample_id": 10762,
            "vt": "SELECT SUM(CASE WHEN SUBSTRING(event.event_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' THEN budget.spent ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN SUBSTRING(event.event_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' THEN budget.spent ELSE [placeholder-type:numeric] END) FROM event INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event",
            "ba": "The virtual table calculates the total spent amount from the 'budget' table for events that occurred in a specific month and year, identified by the event date. It uses a conditional sum to differentiate between the events that match the specified date and those that do not, allowing for a comparison of budgeted versus actual spending."
        },
        {
            "sample_id": 10826,
            "vt": "SELECT event.type, SUM(expense.cost) FROM event INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE event.event_name = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total expenses incurred for a specific type of event from the 'event' table. It joins the 'budget' table to link each event with its corresponding budget entries and then joins the 'expense' table to calculate the total cost associated with that budget. The placeholder in the WHERE clause represents the name of the event for which the total expenses are being calculated."
        },
        {
            "sample_id": 10884,
            "vt": "SELECT budget.category, budget.amount FROM event INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE event.event_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a summary of the budget categories and their corresponding amounts for a specific event from the 'event' and 'budget' tables. The placeholder in the WHERE clause represents the name of the event for which the budget details are being queried."
        },
        {
            "sample_id": 10890,
            "vt": "SELECT zip_code.city FROM member INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip WHERE member.first_name = '[placeholder-type:string]' AND member.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the cities associated with members from the 'member' table based on their first and last names. The query joins the 'member' table with the 'zip_code' table to retrieve the city information corresponding to the member's zip code. The placeholders in the WHERE clause represent the first and last names of the member being queried."
        },
        {
            "sample_id": 10774,
            "vt": "SELECT COUNT(member.member_id) FROM member INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE major.major_name = '[placeholder-type:string]' AND member.t_shirt_size = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of members from the 'member' table who are enrolled in a specific major and have a specified t-shirt size. The query joins the 'member' table with the 'major' table to filter members based on their major name and t-shirt size."
        },
        {
            "sample_id": 10871,
            "vt": "SELECT DISTINCT member.first_name, member.last_name, major.major_name FROM member INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major INNER JOIN expense AS T3 ON T1.member_id = T3.link_to_member WHERE expense.cost > [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of distinct first and last names of members along with their major names from the 'member' and 'major' tables. It filters the results to include only those members who have incurred expenses greater than a specified amount."
        },
        {
            "sample_id": 10881,
            "vt": "SELECT major.major_name, major.department FROM member INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE member.first_name = '[placeholder-type:string]' AND member.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the major name and department of a member from the 'member' table based on their first and last names. The placeholders in the WHERE clause represent the member's first and last names."
        },
        {
            "sample_id": 10803,
            "vt": "SELECT member.first_name, member.last_name FROM member INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY attendance.link_to_member HAVING COUNT(attendance.link_to_event) > [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of members who have attended more than a specified number of events. It retrieves data from the 'member' table and joins it with the 'attendance' table to count the number of events each member has attended, filtering the results based on a numeric threshold."
        },
        {
            "sample_id": 10751,
            "vt": "SELECT zip_code.county FROM member INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE member.first_name = '[placeholder-type:string]' AND member.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the county information associated with a member's hometown based on their first and last names. It joins the 'member' table with the 'zip_code' table using the zip code to find the corresponding county."
        },
        {
            "sample_id": 10817,
            "vt": "SELECT COUNT(attendance.link_to_member) FROM event INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE event.event_name = '[placeholder-type:string]' AND SUBSTRING(event.event_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of members who attended a specific event on a specific date. It retrieves data from the 'event' table and joins it with the 'attendance' table to link events with their attendees. The placeholders represent the event name and the date substring parameters."
        },
        {
            "sample_id": 10775,
            "vt": "SELECT zip_code.type FROM member INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE member.first_name = '[placeholder-type:string]' AND member.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the types of ZIP codes associated with members based on their first and last names. It retrieves the 'type' of ZIP code from the 'zip_code' table by joining it with the 'member' table using the member's ZIP code."
        },
        {
            "sample_id": 10847,
            "vt": "SELECT COUNT(major.major_id) FROM major WHERE major.department = '[placeholder-type:string]' AND major.college = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of majors offered in a specific department and college. The placeholders represent the department's name and the college's name."
        },
        {
            "sample_id": 10797,
            "vt": "SELECT member.first_name, member.last_name FROM member INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE major.department = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of members from the 'member' table who are enrolled in a specific major offered by a department. The placeholder in the WHERE clause represents the department's name."
        },
        {
            "sample_id": 10872,
            "vt": "SELECT DISTINCT zip_code.city, zip_code.county FROM income INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN zip_code AS T3 ON T3.zip_code = T2.zip WHERE income.amount > [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of cities and counties associated with members who have received income greater than a specified amount. It combines data from the 'income', 'member', and 'zip_code' tables, linking them through the member's unique identifier and their corresponding ZIP code."
        },
        {
            "sample_id": 10880,
            "vt": "SELECT CAST((SUM(CASE WHEN zip_code.state = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN zip_code.state = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END)) AS FLOAT) * [placeholder-type:numeric] / COUNT(member.member_id) FROM member INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip",
            "ba": "The virtual table calculates a weighted average of a specific numeric value based on the state of the members. It sums up two different cases of numeric values depending on whether the member's zip code corresponds to a specified state or not, and then computes the difference. This difference is then multiplied by a placeholder numeric value and divided by the count of members to yield the final result."
        },
        {
            "sample_id": 10809,
            "vt": "SELECT member.first_name, member.last_name FROM event INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget INNER JOIN member AS T4 ON T3.link_to_member = T4.member_id WHERE event.event_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of members who incurred expenses for a specific event. It retrieves data from the 'event', 'budget', 'expense', and 'member' tables, linking them through their respective identifiers. The placeholder in the WHERE clause represents the name of the event for which the members' expenses are being queried."
        },
        {
            "sample_id": 10864,
            "vt": "SELECT CAST(SUM(CASE WHEN budget.remaining < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(budget.budget_id) FROM budget",
            "ba": "The virtual table calculates a weighted average of the budget remaining amounts from the 'budget' table. It sums up the remaining amounts that are less than a specified threshold and multiplies this sum by a placeholder value. The result is then divided by the count of budget entries to provide an average value. The placeholders represent numeric values that can be modified by the user to generate specific queries."
        },
        {
            "sample_id": 10784,
            "vt": "SELECT COUNT(zip_code.city) FROM zip_code WHERE zip_code.county = '[placeholder-type:string]' AND zip_code.state = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cities from the 'zip_code' table that belong to a specific county and state. The placeholders in the WHERE clause represent the county and state names."
        },
        {
            "sample_id": 10798,
            "vt": "SELECT event.event_name FROM budget INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE event.status = '[placeholder-type:string]' ORDER BY budget.spent / budget.amount LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of events from the 'event' table that are associated with a specific budget status. The query joins the 'budget' table with the 'event' table to filter events based on their status, using a placeholder for the status value. Additionally, it orders the results by the ratio of spent to budgeted amount and limits the number of results returned using a numeric placeholder."
        },
        {
            "sample_id": 10828,
            "vt": "SELECT budget.budget_id FROM budget WHERE budget.category = '[placeholder-type:string]' AND budget.amount = (SELECT MAX(budget.amount) FROM budget)",
            "ba": "The virtual table retrieves the unique identifier for budget entries from the 'budget' table where the category matches a specified value and the amount is the maximum amount found in the budget entries."
        },
        {
            "sample_id": 10761,
            "vt": "SELECT AVG(expense.cost) FROM member INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE member.last_name = '[placeholder-type:string]' AND member.first_name = '[placeholder-type:string]' AND (SUBSTRING(expense.expense_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' OR SUBSTRING(expense.expense_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]')",
            "ba": "The virtual table calculates the average cost of expenses incurred by a specific member identified by their first and last name. It joins the 'member' table with the 'expense' table to access the relevant expense data. The query also filters the expenses based on specific date criteria extracted from the 'expense_date' field, using placeholders for both the member's name and the date components."
        },
        {
            "sample_id": 10737,
            "vt": "SELECT COUNT(event.event_id) FROM event INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE event.event_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of attendees for a specific event from the 'event' table by joining it with the 'attendance' table. The placeholder in the WHERE clause represents the name of the event for which the count is being requested."
        },
        {
            "sample_id": 10738,
            "vt": "SELECT member.phone FROM event INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE event.event_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the phone numbers of members who attended a specific event from the 'event', 'attendance', and 'member' tables. The placeholder in the WHERE clause represents the name of the event."
        },
        {
            "sample_id": 10748,
            "vt": "SELECT COUNT(member.member_id) FROM member INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE major.major_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of members from the 'member' table who are enrolled in a specific major. It joins the 'member' table with the 'major' table using the foreign key relationship to filter members based on the major name provided as a placeholder."
        },
        {
            "sample_id": 10773,
            "vt": "SELECT major.major_name FROM member INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE member.first_name = '[placeholder-type:string]' AND member.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of majors from the 'major' table for members whose first and last names match the specified placeholders. It uses an inner join to connect the 'member' table with the 'major' table based on the unique identifier of the major associated with each member."
        },
        {
            "sample_id": 10743,
            "vt": "SELECT COUNT(event.event_id) FROM event INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE member.first_name = '[placeholder-type:string]' AND member.last_name = '[placeholder-type:string]' AND SUBSTRING(event.event_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of events attended by a specific member identified by their first and last name. It joins the 'event' table with the 'attendance' table to link events to members, and then further joins with the 'member' table to filter based on the member's name. Additionally, it extracts a substring from the event date to match a specific part of the date, which is represented by placeholders for numeric values."
        },
        {
            "sample_id": 10765,
            "vt": "SELECT budget.remaining FROM budget WHERE budget.category = '[placeholder-type:string]' AND budget.amount = (SELECT MAX(budget.amount) FROM budget WHERE category = 'Food')",
            "ba": "The virtual table displays the remaining budget amount for a specific category from the 'budget' table. It filters the results to show only the category specified by the placeholder and ensures that it retrieves the budget entry with the maximum amount allocated for the 'Food' category."
        },
        {
            "sample_id": 10777,
            "vt": "SELECT zip_code.state FROM member INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE member.first_name = '[placeholder-type:string]' AND member.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the state associated with a member's hometown ZIP code from the 'member' and 'zip_code' tables. It uses an inner join to connect the member's ZIP code with the corresponding state information, filtering the results based on the member's first and last name provided as placeholders."
        },
        {
            "sample_id": 10822,
            "vt": "SELECT CAST(SUM(CASE WHEN event.type = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(event.type) FROM event WHERE SUBSTRING(event.event_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average expenditure for a specific type of event that occurred in a given month and year. It sums the costs associated with events of the specified type, multiplies this sum by a placeholder numeric value, and divides it by the count of events of that type that took place in the specified month and year. The placeholders represent the event type, the month and year for filtering, and a numeric multiplier for the calculation."
        },
        {
            "sample_id": 10887,
            "vt": "SELECT DISTINCT budget.category FROM expense INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE expense.expense_description = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of budget categories associated with expenses that match a specific description. It utilizes a join between the 'expense' and 'budget' tables to correlate expenses with their respective budget entries, filtering based on the provided expense description."
        },
        {
            "sample_id": 10812,
            "vt": "SELECT CAST(SUM(CASE WHEN event.event_name = '[placeholder-type:string]' THEN expense.cost ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(expense.cost) FROM event INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget",
            "ba": "The virtual table calculates the weighted average cost of expenses associated with a specific event. It sums the costs of expenses for the event specified by the placeholder in the event_name column, and then multiplies this sum by a numeric placeholder. This total is then divided by the overall sum of all expenses to provide a proportionate value."
        },
        {
            "sample_id": 10858,
            "vt": "SELECT DISTINCT attendance.link_to_event FROM expense INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE expense.cost > [placeholder-type:numeric]",
            "ba": "The virtual table identifies unique events from the 'attendance' table where the associated expenses incurred by members exceed a specified cost. It utilizes joins between the 'expense', 'member', and 'attendance' tables to filter the results based on the expense amount."
        },
        {
            "sample_id": 10888,
            "vt": "SELECT member.first_name, member.last_name, major.college FROM member INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE member.position = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of members along with the college they are associated with from the 'member' and 'major' tables. The query filters members based on their position within the organization, using a placeholder for the position value."
        },
        {
            "sample_id": 10785,
            "vt": "SELECT major.department FROM major WHERE major.college = '[placeholder-type:string]'",
            "ba": "The virtual table describes the departments offering majors from the 'major' table that belong to a specific college. The placeholder in the WHERE clause represents the name of the college."
        },
        {
            "sample_id": 10882,
            "vt": "SELECT member.first_name, member.last_name, expense.cost FROM expense INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE expense.expense_description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of members along with the cost of their expenses from the 'expense' table. It joins the 'member' table to associate each expense with the corresponding member based on their unique identifier. The placeholder in the WHERE clause represents the description of the expense, allowing users to filter results based on specific expense details."
        },
        {
            "sample_id": 10754,
            "vt": "SELECT budget.spent FROM event INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE event.event_name = '[placeholder-type:string]' AND budget.category = '[placeholder-type:string]' AND SUBSTRING(event.event_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the total amount spent from the 'budget' table for a specific event, identified by its name, and a specific budget category. It also filters the results based on a substring of the event date, allowing for a more precise selection of events that occurred during a certain period."
        },
        {
            "sample_id": 10734,
            "vt": "SELECT major.major_name FROM member INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE member.first_name = '[placeholder-type:string]' AND member.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of majors associated with a specific member from the 'member' table. The query uses an INNER JOIN to connect the 'member' table with the 'major' table based on the unique identifier of the major. The placeholders in the WHERE clause represent the first and last names of the member whose major is being queried."
        },
        {
            "sample_id": 10778,
            "vt": "SELECT major.department FROM member INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE member.position = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the department names of members from the 'member' table who hold a specific position within the club. The query uses an inner join to connect the 'member' table with the 'major' table based on the unique identifier of the major, allowing access to the department information associated with each member's major. The placeholder in the WHERE clause represents the position of the member."
        },
        {
            "sample_id": 10810,
            "vt": "SELECT member.first_name, member.last_name, income.source FROM member INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member GROUP BY member.first_name, member.last_name, income.source ORDER BY SUM(income.amount) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of members along with the source of their income. It retrieves data from the 'member' table and joins it with the 'income' table based on the member's unique identifier. The results are grouped by the member's first and last names and the income source, and ordered by the total amount of income received from each source. The placeholder in the LIMIT clause represents the maximum number of records to return."
        },
        {
            "sample_id": 10801,
            "vt": "SELECT COUNT(event.event_id) FROM event WHERE event.type = '[placeholder-type:string]' AND SUBSTRING(event.event_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of events from the 'event' table that match a specific type and occur in a specified month and year. The placeholders represent the event type, the starting position of the substring for extracting the month, the length of the substring, and the formatted date string."
        },
        {
            "sample_id": 10772,
            "vt": "SELECT budget.event_status FROM budget INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE expense.expense_description = '[placeholder-type:string]' AND expense.expense_date = '[placeholder-type:string]'",
            "ba": "The virtual table provides the status of events from the 'budget' table, specifically focusing on the event status related to expenses. It joins the 'budget' table with the 'expense' table to filter results based on a specific expense description and the date the expense was incurred. The placeholders in the WHERE clause represent the specific expense description and date of interest."
        },
        {
            "sample_id": 10750,
            "vt": "SELECT member.last_name FROM member INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE major.major_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the last names of members from the 'member' table who are enrolled in a specific major. The query joins the 'member' table with the 'major' table to filter members based on the major's name, represented by a placeholder."
        },
        {
            "sample_id": 10862,
            "vt": "SELECT DISTINCT member.email FROM member INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE DATE(SUBSTRING(expense.expense_date, [placeholder-type:numeric], [placeholder-type:numeric])) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND expense.cost > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct email addresses of members who have incurred expenses exceeding a specified amount within a defined date range. It joins the 'member' table with the 'expense' table to filter members based on their expenses."
        },
        {
            "sample_id": 10788,
            "vt": "SELECT DISTINCT member.member_id FROM event INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE event.event_name = '[placeholder-type:string]'",
            "ba": "The virtual table identifies unique members who attended a specific event from the 'event' table. It uses inner joins to connect the 'attendance' table, which links events to members, and the 'member' table, which contains member details. The placeholder in the WHERE clause represents the name of the event being queried."
        },
        {
            "sample_id": 10873,
            "vt": "SELECT member.member_id FROM expense INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN budget AS T3 ON T1.link_to_budget = T3.budget_id INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id GROUP BY member.member_id HAVING COUNT(DISTINCT T4.event_id) > [placeholder-type:numeric] ORDER BY SUM(expense.cost) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table identifies members who have incurred expenses for events, grouping them by their unique member ID. It joins the 'expense' table with the 'member' table to link expenses to members, and further joins with the 'budget' and 'event' tables to associate those expenses with specific events. The query filters members who have attended more than a specified number of distinct events, as indicated by a placeholder for numeric values. Additionally, it orders the results by the total cost of expenses incurred by each member and limits the output to a specified number of results, also represented by a numeric placeholder."
        },
        {
            "sample_id": 10736,
            "vt": "SELECT member.first_name, member.last_name FROM member INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE major.department = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of members from the 'member' table who are enrolled in a specific major offered by a department. The placeholder in the WHERE clause represents the department's name."
        },
        {
            "sample_id": 10769,
            "vt": "SELECT zip_code.county FROM member INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE member.first_name = '[placeholder-type:string]' AND member.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the county information associated with a member's hometown based on their first and last names. It joins the 'member' table with the 'zip_code' table using the zip code to find the corresponding county."
        },
        {
            "sample_id": 10792,
            "vt": "SELECT expense.expense_id, expense.expense_description FROM member INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE member.position = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique identifiers and descriptions of expenses incurred by members of a club who hold a specific position. The query retrieves data from the 'expense' table and filters it based on the members' positions from the 'member' table."
        },
        {
            "sample_id": 10802,
            "vt": "SELECT SUM(budget.spent) FROM budget WHERE budget.category = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total amount spent in a specific budget category from the 'budget' table. The placeholder in the WHERE clause represents the category of the budget for which the total spent amount is being queried."
        },
        {
            "sample_id": 10868,
            "vt": "SELECT CAST(SUM(CASE WHEN zip_code.type = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(zip_code.zip_code) FROM zip_code",
            "ba": "The virtual table calculates a weighted average of a numeric value based on the type of ZIP code from the 'zip_code' table. It sums up a specified numeric value for each ZIP code type and multiplies it by a placeholder numeric value, then divides the result by the total count of ZIP codes. The placeholders allow users to specify the ZIP code type and the numeric value for the calculation."
        },
        {
            "sample_id": 10756,
            "vt": "SELECT member.first_name, member.last_name FROM member INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE zip_code.state = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of members from the 'member' table who reside in a specific state. The query joins the 'member' table with the 'zip_code' table to filter members based on their zip code's associated state. The placeholder in the WHERE clause represents the state name."
        },
        {
            "sample_id": 10745,
            "vt": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id HAVING COUNT(T2.link_to_event) > 20 EXCEPT SELECT T1.event_name FROM event AS T1 WHERE T1.type = 'Fundraiser'",
            "ba": "The virtual table lists the names of events from the 'event' table that have more than 20 attendees, excluding those events that are classified as 'Fundraiser'."
        },
        {
            "sample_id": 10829,
            "vt": "SELECT budget.budget_id FROM budget WHERE budget.category = '[placeholder-type:string]' ORDER BY budget.amount LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of budget entries from the 'budget' table that correspond to a specific category. The results are ordered by the budgeted amount, and a limit is applied to control the number of entries returned."
        },
        {
            "sample_id": 10889,
            "vt": "SELECT SUM(budget.spent), event.event_name FROM budget INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE budget.category = '[placeholder-type:string]' GROUP BY event.event_name",
            "ba": "The virtual table summarizes the total amount spent for a specific budget category across different events. It retrieves the event names and the corresponding total spent amounts by joining the 'budget' and 'event' tables based on the event identifiers. The placeholder in the WHERE clause represents the category of the budget being queried."
        },
        {
            "sample_id": 10806,
            "vt": "SELECT income.amount FROM member INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE member.first_name = '[placeholder-type:string]' AND member.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the total amount of income received by members from the 'income' table, filtered by the first and last names of the members from the 'member' table. The placeholders in the WHERE clause represent the first and last names of the member whose income is being queried."
        },
        {
            "sample_id": 10782,
            "vt": "SELECT CAST(SUM(CASE WHEN budget.category = '[placeholder-type:string]' THEN budget.amount ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(budget.amount) FROM budget INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE event.event_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of the budgeted amount for a specific category of an event. It sums the budgeted amounts for the specified category and multiplies it by a numeric placeholder, then divides this by the total budgeted amount for the event. The query filters the results based on the event name provided as a placeholder."
        },
        {
            "sample_id": 10739,
            "vt": "SELECT COUNT(event.event_id) FROM event INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE event.event_name = '[placeholder-type:string]' AND member.t_shirt_size = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of attendees for a specific event based on the event name and the t-shirt size of the members. It joins the 'event', 'attendance', and 'member' tables to filter the results accordingly."
        },
        {
            "sample_id": 10823,
            "vt": "SELECT expense.cost FROM event INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE event.event_name = '[placeholder-type:string]' AND expense.expense_description = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the cost of expenses associated with a specific event and a specific expense description. It joins the 'event' table with the 'budget' table to link the event to its budget entries, and then further joins the 'expense' table to access the costs related to those budget entries. The placeholders in the WHERE clause represent the event name and the expense description that the user wants to filter by."
        },
        {
            "sample_id": 10861,
            "vt": "SELECT member.phone FROM member INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE major.major_name = '[placeholder-type:string]' AND major.college = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the phone numbers of members from the 'member' table who are enrolled in a specific major and college. The placeholders in the WHERE clause represent the major's name and the college's name."
        },
        {
            "sample_id": 10877,
            "vt": "SELECT budget.budget_id FROM expense INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE expense.expense_description = '[placeholder-type:string]' ORDER BY expense.cost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of budget entries from the 'budget' table that are associated with specific expenses from the 'expense' table. It filters the results based on a description of the expense and orders them by the cost of the expense, limiting the number of results returned."
        },
        {
            "sample_id": 10886,
            "vt": "SELECT DISTINCT member.first_name, member.last_name, income.amount FROM event INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T3.member_id = T2.link_to_member INNER JOIN income AS T4 ON T4.link_to_member = T3.member_id WHERE income.date_received = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of distinct first and last names of members along with the amount of income they received, filtered by the date the income was received. It combines data from the 'event', 'attendance', 'member', and 'income' tables to achieve this."
        }
    ],
    "thrombosis_prediction": [
        {
            "sample_id": 10621,
            "vt": "SELECT COUNT(laboratory.id) FROM laboratory WHERE (laboratory.alb <= [placeholder-type:numeric] OR laboratory.alb >= [placeholder-type:numeric]) AND STRFTIME('%Y', laboratory.date) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of patients from the 'laboratory' table whose albumin levels are either below or above specified numeric thresholds for a given year. The placeholders represent the numeric values for the albumin levels and the year of the laboratory tests."
        },
        {
            "sample_id": 10578,
            "vt": "SELECT DISTINCT patient.id, STRFTIME('%Y', CURRENT_TIMESTAMP()) - STRFTIME('%Y', patient.birthday) FROM patient INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE examination.rvvt = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of patient IDs along with their ages, calculated by subtracting the birth year from the current year. It retrieves this information from the 'patient' table and joins it with the 'examination' table to filter patients based on a specific condition related to the 'rvvt' measurement."
        },
        {
            "sample_id": 10676,
            "vt": "SELECT COUNT(patient.id) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.iga BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND STRFTIME('%Y', patient.\"first date\") > '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of patients from the 'patient' table who have undergone laboratory tests, specifically filtering those whose IgA levels fall within a specified numeric range and who have a recorded first date of hospital visit after a certain year."
        },
        {
            "sample_id": 10694,
            "vt": "SELECT patient.id FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE NOT patient.\"first date\" IS NULL AND NOT laboratory.ssa IN ('[placeholder-type:string]', '[placeholder-type:string]') ORDER BY patient.\"first date\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the identification of patients from the 'patient' table who have a recorded first visit date and do not have specific values for the 'ssa' test in the 'laboratory' table. The results are ordered by the first visit date and limited to a specified number of entries."
        },
        {
            "sample_id": 10575,
            "vt": "SELECT patient.diagnosis, laboratory.date FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE patient.id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the diagnosis of a patient along with the date of their laboratory tests. It retrieves this information by joining the 'patient' and 'laboratory' tables based on the patient ID, which serves as a common identifier in both tables. The placeholder in the WHERE clause represents the specific patient ID for whom the data is being queried."
        },
        {
            "sample_id": 10615,
            "vt": "SELECT COUNT(DISTINCT T1.ID) FROM patient INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE examination.\"ana pattern\" <> '[placeholder-type:string]' AND STRFTIME('%Y', patient.birthday) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND patient.sex = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of patients from the 'patient' table who have undergone examinations in the 'examination' table. It filters out patients based on the ANA pattern, the year of birth, and the sex of the patients. The placeholders represent the specific ANA pattern, the range of birth years, and the sex of the patients."
        },
        {
            "sample_id": 10624,
            "vt": "SELECT COUNT(patient.id) FROM patient INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE examination.diagnosis = '[placeholder-type:string]' AND patient.sex = '[placeholder-type:string]' AND STRFTIME('%Y', examination.\"examination date\") BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND patient.admission = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of patients from the 'patient' table who have undergone examinations with a specific diagnosis, filtered by their sex, the year of the examination date, and their admission status."
        },
        {
            "sample_id": 10675,
            "vt": "SELECT patient.diagnosis FROM patient INNER JOIN Laboratory AS labData ON patientData.ID = labData.ID WHERE laboratory.iga BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] ORDER BY laboratory.iga LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the diagnosis of patients from the 'patient' table who have undergone laboratory tests. It joins the 'patient' table with the 'laboratory' table based on the patient ID. The results are filtered to include only those patients whose IgA levels fall within a specified numeric range, and the output is ordered by the IgA levels. The query also limits the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 10659,
            "vt": "SELECT DISTINCT patient.id, patient.sex FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.hgb < [placeholder-type:numeric] AND patient.admission = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of patient IDs and their corresponding sex from the 'patient' table, filtered by specific criteria. It joins the 'patient' table with the 'laboratory' table based on the patient ID. The query includes a condition to select only those patients whose hemoglobin level (hgb) is below a specified numeric threshold and who have a specific admission status, indicated by a placeholder for string values."
        },
        {
            "sample_id": 10701,
            "vt": "SELECT COUNT(CASE WHEN patient.diagnosis LIKE '[placeholder-type:string]' THEN patient.id ELSE [placeholder-type:numeric] END) / COUNT(patient.id) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.\"got\" >= [placeholder-type:numeric]",
            "ba": "The virtual table calculates the proportion of patients diagnosed with a specific condition from the 'patient' table, based on their laboratory test results. It counts the number of patients whose diagnosis matches a specified string and divides it by the total number of patients. The query also filters the results to include only those patients whose AST levels are above a certain numeric threshold."
        },
        {
            "sample_id": 10666,
            "vt": "SELECT patient.id FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', patient.\"first date\") > '[placeholder-type:string]' AND laboratory.pt < [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the identification of patients from the 'patient' table who have undergone laboratory tests. It filters the results based on the first date of the patient's visit to the hospital being after a specified year and the prothrombin time (pt) from the laboratory tests being less than a specified numeric value."
        },
        {
            "sample_id": 10707,
            "vt": "SELECT patient.\"first date\" FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.ldh >= [placeholder-type:numeric] ORDER BY patient.\"first date\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the first date a patient visited the hospital from the 'patient' table, filtering for patients whose lactate dehydrogenase (LDH) levels in the 'laboratory' table are above a specified threshold. The results are ordered by the first date of visit and limited to a certain number of records."
        },
        {
            "sample_id": 10605,
            "vt": "SELECT patient.diagnosis FROM patient INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE patient.id = (SELECT examination.id FROM Examination WHERE \"Examination Date\" = '1997-01-27' AND Diagnosis = 'SLE') AND examination.\"examination date\" = patient.\"first date\"",
            "ba": "The virtual table retrieves the diagnosis of a patient from the 'patient' table by joining it with the 'examination' table. It filters the results to find patients whose examination date matches their first date of hospital visit and who have a specific diagnosis of 'SLE' on a given examination date."
        },
        {
            "sample_id": 10588,
            "vt": "SELECT examination.symptoms, patient.diagnosis FROM patient INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE NOT examination.symptoms IS NULL ORDER BY patient.birthday LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table presents the symptoms observed in patients along with their corresponding diagnoses. It retrieves data from the 'patient' and 'examination' tables, ensuring that only records with non-null symptoms are included. The results are ordered by the patients' birthdays, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 10609,
            "vt": "SELECT DISTINCT laboratory.id FROM laboratory WHERE laboratory.date BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND laboratory.gpt > [placeholder-type:numeric] AND laboratory.alb < [placeholder-type:numeric]",
            "ba": "The virtual table retrieves unique patient identifiers from the 'laboratory' table based on specific criteria. It filters the records to include only those laboratory tests conducted within a specified date range, where the value of the 'gpt' column exceeds a certain numeric threshold and the value of the 'alb' column is below another numeric threshold."
        },
        {
            "sample_id": 10622,
            "vt": "SELECT CAST(SUM(CASE WHEN examination.diagnosis = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(examination.id) FROM examination WHERE examination.symptoms = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of a specific diagnosis from the 'examination' table based on the symptoms observed. It sums up a conditional value based on whether the diagnosis matches a specified string, and then multiplies this sum by a numeric placeholder. The result is divided by the count of examination records to provide an average value, filtered by the symptoms column."
        },
        {
            "sample_id": 10693,
            "vt": "SELECT COUNT(DISTINCT T1.ID) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.ssa IN ('[placeholder-type:string]', '[placeholder-type:string]') AND STRFTIME('%Y', laboratory.date) < '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of patients from the 'patient' table who have undergone laboratory tests. It filters the results based on specific values for the 'ssa' column in the 'laboratory' table and ensures that the laboratory test date is before a specified year."
        },
        {
            "sample_id": 10577,
            "vt": "SELECT DISTINCT patient.id, patient.sex, patient.birthday FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.ldh > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct patient identifiers, their sex, and birthday from the 'patient' table, while joining with the 'laboratory' table to filter patients based on a specific condition related to lactate dehydrogenase (LDH) levels. The placeholder in the WHERE clause represents the threshold for LDH concentration, allowing users to specify a numeric value for filtering."
        },
        {
            "sample_id": 10667,
            "vt": "SELECT COUNT(patient.id) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.date > '[placeholder-type:string]' AND laboratory.aptt >= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of patients from the 'patient' table who have undergone laboratory tests after a specified date and have an activated partial prothrombin time (aPTT) greater than or equal to a specified numeric value. The query joins the 'patient' table with the 'laboratory' table based on the patient ID."
        },
        {
            "sample_id": 10654,
            "vt": "SELECT DISTINCT patient.id, patient.sex, STRFTIME('%Y', CURRENT_TIMESTAMP()) - STRFTIME('%Y', patient.birthday) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.glu >= [placeholder-type:numeric] AND laboratory.\"t-cho\" < [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of patient IDs, their sex, and their age calculated from the birthday. It retrieves data from the 'patient' table and joins it with the 'laboratory' table to filter patients based on specific laboratory test results. The placeholders represent the minimum glucose level and the maximum total cholesterol level for filtering the results."
        },
        {
            "sample_id": 10593,
            "vt": "SELECT COUNT(patient.id) FROM patient INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', examination.\"examination date\") BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND STRFTIME('%Y', examination.\"examination date\") - STRFTIME('%Y', patient.birthday) < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of patients who have undergone examinations within a specified date range and are younger than a certain age. It joins the 'patient' and 'examination' tables on the patient ID, filtering the results based on the examination date and the patient's birthday."
        },
        {
            "sample_id": 10705,
            "vt": "SELECT COUNT(patient.id) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.got < [placeholder-type:numeric] AND patient.sex = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of patients from the 'patient' table who have undergone laboratory tests, specifically filtering for those whose AST levels are below a specified threshold and who belong to a specific sex category."
        },
        {
            "sample_id": 10686,
            "vt": "SELECT COUNT(DISTINCT T1.ID) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.c4 > [placeholder-type:numeric] AND patient.diagnosis = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of patients from the 'patient' table who have undergone laboratory tests. It filters the results based on a specific condition where the value of 'c4' in the 'laboratory' table exceeds a certain numeric threshold, and also matches a specific diagnosis from the 'patient' table."
        },
        {
            "sample_id": 10657,
            "vt": "SELECT DISTINCT patient.diagnosis, patient.id, STRFTIME('%Y', CURRENT_TIMESTAMP()) - STRFTIME('%Y', patient.birthday) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.rbc < [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of patient diagnoses along with their identification and age, calculated from the patient's birthday. It retrieves this information by joining the 'patient' table with the 'laboratory' table based on the patient ID. The results are filtered to include only those patients whose red blood cell count (rbc) is below a specified numeric threshold."
        },
        {
            "sample_id": 10689,
            "vt": "SELECT COUNT(examination.id) FROM examination INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.sm IN ('[placeholder-type:string]', '[placeholder-type:string]') AND examination.thrombosis = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of examinations from the 'examination' table that are associated with patients in the 'laboratory' table, filtered by specific values of the 'sm' column and the degree of thrombosis."
        },
        {
            "sample_id": 10645,
            "vt": "SELECT CASE WHEN SUM(CASE WHEN patient.sex = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) > SUM(CASE WHEN patient.sex = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.cre >= [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the comparison of two groups of patients based on their sex, specifically focusing on a certain laboratory test result (creatinine level). It uses conditional aggregation to determine which group has a higher sum of a specified numeric value, allowing for a comparison between male and female patients. The placeholders represent the sex values and the numeric threshold for the creatinine level."
        },
        {
            "sample_id": 10584,
            "vt": "SELECT COUNT(*) FROM patient WHERE STRFTIME('%Y', patient.description) = '[placeholder-type:string]' AND patient.sex = '[placeholder-type:string]' AND patient.admission = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of patients from the 'patient' table who were recorded in a specific year, filtered by their sex and admission status."
        },
        {
            "sample_id": 10610,
            "vt": "SELECT patient.id FROM patient WHERE STRFTIME('%Y', patient.birthday) = '[placeholder-type:string]' AND patient.sex = '[placeholder-type:string]' AND patient.admission = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the identification of patients from the 'patient' table based on specific criteria. The placeholders in the WHERE clause represent the year of birth, sex, and admission status of the patients."
        },
        {
            "sample_id": 10633,
            "vt": "SELECT DISTINCT patient.id, STRFTIME('%Y', CURRENT_TIMESTAMP()) - STRFTIME('%Y', patient.birthday) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.ldh > [placeholder-type:numeric] AND laboratory.ldh < [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of patient IDs along with their ages, calculated by subtracting the year of birth from the current year. It retrieves data from the 'patient' table and joins it with the 'laboratory' table to filter patients based on their lactate dehydrogenase (LDH) levels, ensuring that only those with LDH values within a specified numeric range are included."
        },
        {
            "sample_id": 10677,
            "vt": "SELECT patient.diagnosis FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE NOT laboratory.igm BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] GROUP BY patient.diagnosis ORDER BY COUNT(patient.diagnosis) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the diagnoses of patients from the 'patient' table, filtering out those whose IgM levels in the 'laboratory' table fall within a specified numeric range. The results are grouped by diagnosis and ordered by the count of occurrences, with a limit on the number of results returned."
        },
        {
            "sample_id": 10649,
            "vt": "SELECT AVG(STRFTIME('%Y', DATE('[placeholder-type:string]')) - STRFTIME('%Y', patient.birthday)) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.\"t-cho\" >= [placeholder-type:numeric] AND patient.sex = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average age of patients from the 'patient' table who have undergone laboratory tests, specifically filtering for those whose total cholesterol ('t-cho') levels are above a certain numeric threshold and who belong to a specified sex. The placeholders represent the date for the examination, the cholesterol level threshold, and the sex of the patients."
        },
        {
            "sample_id": 10580,
            "vt": "SELECT DISTINCT patient.id FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', patient.birthday) = '[placeholder-type:string]' AND laboratory.\"t-cho\" >= [placeholder-type:numeric]",
            "ba": "The virtual table identifies distinct patient IDs from the 'patient' table who have undergone laboratory tests. It filters patients based on their birth year and ensures that their total cholesterol level meets a specified threshold."
        },
        {
            "sample_id": 10672,
            "vt": "SELECT DISTINCT patient.id FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.\"u-pro\" > [placeholder-type:numeric] AND laboratory.\"u-pro\" < [placeholder-type:numeric] AND patient.diagnosis = '[placeholder-type:string]'",
            "ba": "The virtual table identifies unique patient IDs from the 'patient' table who have undergone laboratory tests. It filters the results based on the concentration of proteinuria, ensuring that it falls within a specified numeric range. Additionally, it checks for a specific diagnosis associated with the patient."
        },
        {
            "sample_id": 10597,
            "vt": "SELECT STRFTIME('%Y', laboratory.date) - STRFTIME('%Y', patient.birthday), patient.diagnosis FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY laboratory.hgb LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the age of patients at the time of their laboratory tests along with their diagnosis. It calculates the age by subtracting the year of birth from the year of the laboratory test date. The data is sourced from the 'patient' and 'laboratory' tables, where they are joined on the patient ID. The results are ordered by hemoglobin levels and limited to a specified number of records."
        },
        {
            "sample_id": 10664,
            "vt": "SELECT DISTINCT patient.id FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.plt BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND STRFTIME('%Y', laboratory.date) - STRFTIME('%Y', patient.birthday) < [placeholder-type:numeric] AND STRFTIME('%Y', laboratory.date) = '[placeholder-type:string]'",
            "ba": "The virtual table identifies distinct patient IDs from the 'patient' table who have laboratory test results within a specified platelet range. It joins the 'patient' table with the 'laboratory' table based on patient ID. Additionally, it filters patients based on their age at the time of the laboratory test and restricts results to a specific date."
        },
        {
            "sample_id": 10625,
            "vt": "SELECT COUNT(patient.id) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.wbc < [placeholder-type:numeric] AND patient.sex = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of patients from the 'patient' table who have a white blood cell (WBC) count below a specified threshold and belong to a specific sex. It joins the 'patient' table with the 'laboratory' table based on the patient ID to access the WBC data."
        },
        {
            "sample_id": 10598,
            "vt": "SELECT examination.ana FROM examination WHERE examination.id = [placeholder-type:numeric] AND examination.\"examination date\" = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the anti-nucleus antibody concentration from the 'examination' table for a specific patient identified by their ID and a specific examination date. The placeholders represent the patient's ID and the examination date."
        },
        {
            "sample_id": 10656,
            "vt": "SELECT DISTINCT patient.id, patient.sex, patient.birthday FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.wbc <= [placeholder-type:numeric] OR laboratory.wbc >= [placeholder-type:numeric] GROUP BY patient.sex, patient.id ORDER BY patient.birthday",
            "ba": "The virtual table provides a distinct list of patients along with their sex and birthday from the 'patient' table. It filters the results based on the white blood cell (WBC) count from the 'laboratory' table, allowing users to specify upper and lower limits for WBC values using placeholders. The results are grouped by sex and patient ID, and ordered by the patient's birthday."
        },
        {
            "sample_id": 10638,
            "vt": "SELECT DISTINCT patient.id FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE patient.sex = '[placeholder-type:string]' AND (laboratory.alb <= [placeholder-type:numeric] OR laboratory.alb >= [placeholder-type:numeric]) ORDER BY patient.birthday",
            "ba": "The virtual table identifies distinct patients from the 'patient' table who have undergone laboratory tests. It filters patients based on their sex and checks the albumin levels from the laboratory results, ensuring that only those with albumin levels either below or above specified numeric thresholds are included. The results are ordered by the patients' birthdays."
        },
        {
            "sample_id": 10703,
            "vt": "SELECT patient.birthday FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.got >= [placeholder-type:numeric] ORDER BY patient.birthday LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the birthdays of patients from the 'patient' table who have undergone laboratory tests, specifically filtering for those whose AST (got) levels are above a certain threshold. The results are ordered by the patients' birthdays and limited to a specified number of entries."
        },
        {
            "sample_id": 10592,
            "vt": "SELECT COUNT(DISTINCT T1.ID) FROM patient INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE patient.admission = '[placeholder-type:string]' AND STRFTIME('%Y', examination.\"examination date\") - STRFTIME('%Y', patient.\"first date\") >= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of distinct patients from the 'patient' table who have undergone examinations, filtered by their admission status and the difference in years between their first date of hospital visit and the examination date."
        },
        {
            "sample_id": 10712,
            "vt": "SELECT laboratory.date FROM laboratory WHERE laboratory.alb > [placeholder-type:numeric] AND laboratory.alb < [placeholder-type:numeric] ORDER BY laboratory.alb LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the dates of laboratory tests from the 'laboratory' table where the albumin levels are within a specified range. The placeholders represent the lower and upper limits for albumin values, as well as the maximum number of results to return."
        },
        {
            "sample_id": 10614,
            "vt": "SELECT DISTINCT patient.id FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE patient.admission = '[placeholder-type:string]' AND laboratory.\"t-bil\" < [placeholder-type:numeric] AND laboratory.date LIKE '[placeholder-type:string]'",
            "ba": "The virtual table identifies unique patient IDs from the 'patient' table who have been admitted to the hospital or followed at an outpatient clinic, while also filtering based on their laboratory test results for total bilirubin levels and the date of the tests."
        },
        {
            "sample_id": 10660,
            "vt": "SELECT patient.id, patient.sex FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE patient.diagnosis = '[placeholder-type:string]' AND laboratory.hgb > [placeholder-type:numeric] AND laboratory.hgb < [placeholder-type:numeric] ORDER BY patient.birthday LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the identification and sex of patients from the 'patient' table who have a specific diagnosis, and whose hemoglobin levels from the 'laboratory' table fall within a specified range. The results are ordered by the patients' birthdays and limited to a certain number of records."
        },
        {
            "sample_id": 10655,
            "vt": "SELECT DISTINCT patient.id, laboratory.glu FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', patient.\"first date\") = '[placeholder-type:string]' AND laboratory.glu < [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of patient IDs along with their corresponding blood glucose levels from the laboratory tests. It filters the results based on the year of the patient's first visit to the hospital and ensures that only those patients with a blood glucose level below a specified numeric threshold are included."
        },
        {
            "sample_id": 10604,
            "vt": "SELECT COUNT(*) FROM laboratory WHERE patient.id = (SELECT patient.id FROM Patient WHERE \"First Date\" = '1991-06-13' AND Diagnosis = 'SJS') AND STRFTIME('%Y', laboratory.date) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of laboratory tests conducted for patients who first visited the hospital on a specific date and have a particular diagnosis. The placeholders represent the date of the laboratory tests and the specific date and diagnosis of the patient."
        },
        {
            "sample_id": 10731,
            "vt": "SELECT laboratory.plt FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE patient.diagnosis = '[placeholder-type:string]' AND laboratory.plt BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the platelet count from the laboratory tests for patients with a specific diagnosis, filtering the results based on a range of platelet values."
        },
        {
            "sample_id": 10623,
            "vt": "SELECT CAST(SUM(CASE WHEN patient.sex = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(patient.id) FROM patient WHERE patient.diagnosis = '[placeholder-type:string]' AND STRFTIME('%Y', patient.birthday) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average based on the sex of patients, their diagnosis, and their birth year. It sums a specific numeric value based on the condition of the patient's sex and divides it by the total count of patients with the specified diagnosis and birth year. The placeholders represent the sex, diagnosis, and birth year values."
        },
        {
            "sample_id": 10729,
            "vt": "SELECT DISTINCT patient.id FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (laboratory.rbc <= [placeholder-type:numeric] OR laboratory.rbc >= [placeholder-type:numeric]) AND patient.admission = '[placeholder-type:string]'",
            "ba": "The virtual table identifies unique patient IDs from the 'patient' table who have undergone laboratory tests. It filters the results based on the red blood cell (RBC) count from the 'laboratory' table, allowing for both lower and upper limits specified by placeholders. Additionally, it checks the admission status of the patients, ensuring that only those with a specific admission status are included in the results."
        },
        {
            "sample_id": 10679,
            "vt": "SELECT COUNT(DISTINCT T1.ID) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.cre >= [placeholder-type:numeric] AND STRFTIME('%Y', DATE('[placeholder-type:string]')) - STRFTIME('%Y', patient.birthday) < [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of patients from the 'patient' table who have laboratory test results where the creatinine level is above a specified threshold and who are within a certain age range based on their birth date."
        },
        {
            "sample_id": 10637,
            "vt": "SELECT laboratory.tp - [placeholder-type:numeric] FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE patient.sex = '[placeholder-type:string]' AND laboratory.tp > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the difference between the total protein level from the laboratory tests and a specified numeric value. It retrieves data from the 'patient' table and joins it with the 'laboratory' table based on patient identification. The results are filtered to include only those patients of a specified sex and where the total protein level exceeds a certain numeric threshold."
        },
        {
            "sample_id": 10581,
            "vt": "SELECT DISTINCT patient.id, patient.sex, patient.diagnosis FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.alb < [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of patient identifiers, their sex, and diagnoses from the 'patient' table, filtered by those whose albumin levels in the laboratory tests are below a specified numeric threshold. The query joins the 'patient' table with the 'laboratory' table based on the patient ID to access the relevant laboratory data."
        },
        {
            "sample_id": 10586,
            "vt": "SELECT COUNT(*) FROM patient INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE patient.sex = '[placeholder-type:string]' AND STRFTIME('%Y', examination.\"examination date\") = '[placeholder-type:string]' AND examination.thrombosis = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of patients from the 'patient' table who have undergone examinations in the 'examination' table. It filters the results based on the patient's sex, the year of the examination date, and the degree of thrombosis observed in the examination."
        },
        {
            "sample_id": 10673,
            "vt": "SELECT COUNT(DISTINCT T1.ID) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE laboratory.igg >= [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of patients who have undergone laboratory tests and examinations, specifically filtering for those with an IgG level above a specified threshold. The query joins the 'patient', 'laboratory', and 'examination' tables based on patient identification, ensuring that only relevant records are considered."
        },
        {
            "sample_id": 10585,
            "vt": "SELECT MIN(STRFTIME('%Y', patient.\"first date\") - STRFTIME('%Y', patient.birthday)) FROM patient",
            "ba": "The virtual table calculates the minimum age of patients by subtracting their birth year from the year they first visited the hospital. It uses the 'first date' and 'birthday' columns from the 'patient' table to derive this information."
        },
        {
            "sample_id": 10700,
            "vt": "SELECT COUNT(patient.id) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.igg > [placeholder-type:numeric] AND laboratory.igg < [placeholder-type:numeric] AND patient.admission = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of patients from the 'patient' table who have undergone laboratory tests, specifically filtering for those whose IgG levels fall within a specified range and who have a certain admission status (either admitted to the hospital or followed at an outpatient clinic). The placeholders represent the numeric values for the IgG concentration range and the string value for the admission status."
        },
        {
            "sample_id": 10616,
            "vt": "SELECT patient.sex FROM patient INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T3.ID = T2.ID WHERE examination.diagnosis = '[placeholder-type:string]' AND laboratory.crp = '[placeholder-type:string]' AND laboratory.cre = [placeholder-type:numeric] AND laboratory.ldh = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the sex of patients from the 'patient' table who have undergone examinations and laboratory tests. It filters the results based on specific diagnosis from the 'examination' table and certain laboratory test results from the 'laboratory' table, using placeholders for the diagnosis and laboratory values."
        },
        {
            "sample_id": 10704,
            "vt": "SELECT patient.birthday FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.gpt < [placeholder-type:numeric] ORDER BY laboratory.gpt LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the birthdays of patients from the 'patient' table who have laboratory test results for ALT (GPT) below a specified threshold. The results are ordered by the ALT values and limited to a certain number of entries."
        },
        {
            "sample_id": 10717,
            "vt": "SELECT COUNT(patient.id) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE laboratory.\"t-bil\" >= [placeholder-type:numeric] AND examination.\"ana pattern\" LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of patients from the 'patient' table who have undergone laboratory tests and examinations. It filters the results based on the total bilirubin level from the 'laboratory' table being greater than or equal to a specified numeric value, and the ANA pattern from the 'examination' table matching a specified string pattern."
        },
        {
            "sample_id": 10710,
            "vt": "SELECT patient.diagnosis FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.tp < [placeholder-type:numeric]",
            "ba": "The virtual table describes the diagnoses of patients from the 'patient' table who have laboratory test results indicating total protein levels below a specified threshold. The query joins the 'patient' and 'laboratory' tables on the patient ID to filter the results based on the total protein measurement."
        },
        {
            "sample_id": 10723,
            "vt": "SELECT DISTINCT laboratory.id FROM laboratory INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE examination.thrombosis = [placeholder-type:numeric] AND laboratory.cpk < [placeholder-type:numeric]",
            "ba": "The virtual table identifies unique patient IDs from the 'laboratory' table who have undergone examinations with a specific degree of thrombosis and have a creatinine phosphokinase (CPK) level below a certain threshold. The placeholders represent the degree of thrombosis and the CPK level."
        },
        {
            "sample_id": 10636,
            "vt": "SELECT DISTINCT patient.id, patient.sex, patient.birthday FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.tp < [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct patient identifiers, their sex, and birthday from the 'patient' table, while joining with the 'laboratory' table to filter patients based on a specific condition related to total protein levels. The placeholder in the WHERE clause represents the threshold for total protein concentration."
        },
        {
            "sample_id": 10669,
            "vt": "SELECT COUNT(DISTINCT T1.ID) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.fg <= [placeholder-type:numeric] OR laboratory.fg >= [placeholder-type:numeric] AND laboratory.wbc > [placeholder-type:numeric] AND laboratory.wbc < [placeholder-type:numeric] AND patient.sex = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of patients from the 'patient' table who have undergone laboratory tests. It filters the results based on specific conditions related to laboratory test results for fibrinogen (fg) and white blood cell (wbc) counts, as well as the sex of the patients."
        },
        {
            "sample_id": 10613,
            "vt": "SELECT CAST(SUM(CASE WHEN patient.diagnosis = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(patient.id) FROM patient WHERE STRFTIME('%Y', patient.\"first date\") = '[placeholder-type:string]' AND patient.sex = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of a specific diagnosis from the 'patient' table based on the patient's sex and the year of their first visit. It uses a conditional sum to differentiate between patients with the specified diagnosis and those without, applying a multiplier to the sum. The result is then divided by the total count of patients to obtain the average."
        },
        {
            "sample_id": 10653,
            "vt": "SELECT COUNT(DISTINCT T1.ID) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', patient.birthday) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND patient.sex = '[placeholder-type:string]' AND laboratory.cpk >= [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of patients from the 'patient' table who have undergone laboratory tests. It filters the results based on the patient's birth year range, sex, and a minimum value for the creatinine phosphokinase (CPK) level from the 'laboratory' table."
        },
        {
            "sample_id": 10648,
            "vt": "SELECT patient.id, laboratory.\"t-cho\" FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY laboratory.\"t-cho\", patient.birthday LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table presents the patient IDs along with their total cholesterol levels from the 'laboratory' table. It combines data from the 'patient' and 'laboratory' tables using an inner join based on the patient ID. The results are ordered by total cholesterol levels and the patients' birthdays, with a limit on the number of records returned."
        },
        {
            "sample_id": 10590,
            "vt": "SELECT laboratory.date, STRFTIME('%Y', patient.\"first date\") - STRFTIME('%Y', patient.birthday), patient.birthday FROM laboratory INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE patient.diagnosis = '[placeholder-type:string]' AND NOT patient.birthday IS NULL ORDER BY patient.birthday LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of laboratory test dates, the age of patients at the time of their first hospital visit, and their birthdays. It retrieves data from the 'laboratory' and 'patient' tables, filtering for patients with a specific diagnosis while ensuring that the birthday is not null. The results are ordered by the patient's birthday and limited to a specified number of entries."
        },
        {
            "sample_id": 10646,
            "vt": "SELECT laboratory.\"t-bil\", patient.id, patient.sex, patient.birthday FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY laboratory.\"t-bil\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table presents the total bilirubin levels along with patient identification, sex, and birthday from the 'patient' and 'laboratory' tables. It filters the results by joining these two tables on the patient ID and orders the output by total bilirubin levels, limiting the number of results based on a specified numeric value."
        },
        {
            "sample_id": 10652,
            "vt": "SELECT DISTINCT patient.id FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.cpk < [placeholder-type:numeric] AND patient.admission = '[placeholder-type:string]'",
            "ba": "The virtual table identifies unique patient IDs from the 'patient' table who have undergone laboratory tests. It filters the results based on the creatinine phosphokinase (CPK) levels from the 'laboratory' table, ensuring that only those patients with CPK levels below a specified numeric threshold are included. Additionally, it checks the admission status of the patients, allowing for differentiation between those admitted to the hospital and those followed at an outpatient clinic."
        },
        {
            "sample_id": 10724,
            "vt": "SELECT COUNT(patient.id) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE laboratory.cpk < [placeholder-type:numeric] AND (examination.kct = '[placeholder-type:string]' OR examination.rvvt = '[placeholder-type:string]' OR examination.lac = '[placeholder-type:string]')",
            "ba": "The virtual table counts the number of patients from the 'patient' table who have undergone laboratory tests and examinations. It filters the results based on the creatinine phosphokinase (cpk) level being below a specified numeric threshold, and also checks if any of the coagulation measures (kct, rvvt, lac) match specific string values."
        },
        {
            "sample_id": 10631,
            "vt": "SELECT DISTINCT patient.diagnosis FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.gpt > [placeholder-type:numeric] ORDER BY patient.birthday",
            "ba": "The virtual table presents a distinct list of diagnoses from the 'patient' table for patients whose laboratory test results for ALT (gpt) exceed a specified numeric threshold. The results are ordered by the patients' birthdays."
        },
        {
            "sample_id": 10697,
            "vt": "SELECT COUNT(DISTINCT T1.ID) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.centromea IN ('[placeholder-type:string]', '[placeholder-type:string]') AND laboratory.ssb IN ('[placeholder-type:string]', '[placeholder-type:string]') AND patient.sex = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of patients from the 'patient' table who have undergone laboratory tests. It filters the results based on specific laboratory test results for 'centromea' and 'ssb', as well as the sex of the patient."
        },
        {
            "sample_id": 10650,
            "vt": "SELECT patient.id, patient.diagnosis FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.tg > [placeholder-type:numeric]",
            "ba": "The virtual table describes the identification and diagnosis of patients from the 'patient' table who have laboratory test results indicating triglyceride levels above a specified threshold. The placeholder in the WHERE clause represents the triglyceride value that needs to be exceeded."
        },
        {
            "sample_id": 10587,
            "vt": "SELECT STRFTIME('%Y', MAX(patient.birthday)) - STRFTIME('%Y', MIN(patient.birthday)) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.tg >= [placeholder-type:numeric]",
            "ba": "The virtual table calculates the age range of patients based on their birthday from the 'patient' table, by finding the difference between the maximum and minimum birth years. It filters the results to include only those patients whose triglyceride levels (tg) from the 'laboratory' table are above a specified threshold. The placeholder in the WHERE clause represents the minimum triglyceride level to filter the patients."
        },
        {
            "sample_id": 10663,
            "vt": "SELECT SUM(CASE WHEN laboratory.plt <= [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN laboratory.plt >= [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
            "ba": "The virtual table calculates the difference between the sum of platelet counts that are less than or equal to a specified threshold and the sum of platelet counts that are greater than or equal to that threshold. It retrieves data from the 'laboratory' table, which is joined with the 'patient' table based on patient identification. The placeholders represent numeric values for the thresholds used in the calculations."
        },
        {
            "sample_id": 10643,
            "vt": "SELECT DISTINCT patient.id, patient.sex, patient.birthday FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.un < [placeholder-type:numeric] AND patient.diagnosis = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct patient identifiers, their sex, and birthday from the 'patient' table, while joining with the 'laboratory' table to filter patients based on a specific laboratory test result (urea nitrogen) and a specific diagnosis."
        },
        {
            "sample_id": 10572,
            "vt": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', patient.birthday) > '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM patient WHERE patient.sex = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average age of patients based on their birthday, filtered by sex. It sums up the ages of patients born after a specified year and divides it by the total number of patients of the specified sex. The placeholders represent the year to compare against, the numeric values for age calculations, and the sex of the patients."
        },
        {
            "sample_id": 10721,
            "vt": "SELECT COUNT(examination.id) FROM examination INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.tg < [placeholder-type:numeric] AND NOT examination.symptoms IS NULL",
            "ba": "The virtual table counts the number of examinations from the 'examination' table that have associated laboratory results from the 'laboratory' table, where the triglyceride level is below a specified numeric threshold and there are recorded symptoms for the examinations."
        },
        {
            "sample_id": 10599,
            "vt": "SELECT CASE WHEN laboratory.\"t-cho\" < [placeholder-type:numeric] THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM laboratory WHERE laboratory.id = [placeholder-type:numeric] AND laboratory.date = '[placeholder-type:string]'",
            "ba": "The virtual table provides a conditional output based on the total cholesterol level from the 'laboratory' table. It checks if the total cholesterol ('t-cho') is below a specified numeric threshold. If it is, it returns one string value; otherwise, it returns another string value. The query is filtered by the patient's identification number and the date of the laboratory test."
        },
        {
            "sample_id": 10685,
            "vt": "SELECT DISTINCT patient.id FROM patient INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE (laboratory.hct >= [placeholder-type:numeric] OR laboratory.hct <= [placeholder-type:numeric]) ORDER BY examination.\"acl iga\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct patient identifiers from the 'patient' table, joining it with the 'examination' and 'laboratory' tables to filter patients based on their hematocrit levels. The query includes conditions to check if the hematocrit value is either greater than or equal to a specified minimum or less than or equal to a specified maximum, and it orders the results based on the anti-Cardiolipin antibody (IgA) concentration from the examination data. The results are limited to a specified number of entries."
        },
        {
            "sample_id": 10589,
            "vt": "SELECT CAST(COUNT(patient.id) AS FLOAT) / [placeholder-type:numeric] FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', laboratory.date) = '[placeholder-type:string]' AND patient.sex = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the ratio of patients to a specified number, filtered by the year of laboratory tests and the sex of the patients. It joins the 'patient' and 'laboratory' tables on the patient ID, ensuring that only relevant records are considered for the calculation."
        },
        {
            "sample_id": 10665,
            "vt": "SELECT CAST(SUM(CASE WHEN laboratory.pt >= [placeholder-type:numeric] AND patient.sex = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP()) - STRFTIME('%Y', patient.birthday) > [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average of prothrombin time (PT) for patients based on their sex and age. It sums the PT values for patients who meet the specified criteria and scales this sum by a given factor, then divides by the total count of patients to get the average. The placeholders represent the threshold for PT, the sex of the patients, the scaling factor, and the age limit for filtering patients."
        },
        {
            "sample_id": 10573,
            "vt": "SELECT CAST(SUM(CASE WHEN patient.admission = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM patient WHERE STRFTIME('%Y', patient.birthday) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average based on patient admissions over a specified age range. It sums a conditional value based on whether the patient was admitted or followed at an outpatient clinic, then multiplies this sum by a numeric placeholder and divides by the total count of patients within the specified birth year range."
        },
        {
            "sample_id": 10696,
            "vt": "SELECT COUNT(DISTINCT T1.ID) FROM examination INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.ssb = '[placeholder-type:string]' OR '[placeholder-type:string]' AND NOT examination.symptoms IS NULL",
            "ba": "The virtual table counts the distinct number of patients from the 'examination' table who have undergone laboratory tests and have specific conditions related to the 'ssb' test results. The query filters out patients with null symptoms, ensuring that only those with recorded symptoms are included in the count."
        },
        {
            "sample_id": 10683,
            "vt": "SELECT COUNT(DISTINCT T1.ID) FROM examination INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.rf < [placeholder-type:numeric] AND examination.thrombosis = [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct patient IDs from the 'examination' and 'laboratory' tables. It filters the results based on the rheumatoid factor (rf) value from the laboratory tests being less than a specified numeric threshold and the degree of thrombosis from the examination being equal to a specified numeric value."
        },
        {
            "sample_id": 10678,
            "vt": "SELECT COUNT(patient.id) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (laboratory.crp = '[placeholder-type:string]') AND patient.description IS NULL",
            "ba": "The virtual table counts the number of patients from the 'patient' table who have undergone laboratory tests, specifically filtering for those with a certain C-reactive protein (CRP) result and where the patient's description is not recorded."
        },
        {
            "sample_id": 10674,
            "vt": "SELECT COUNT(patient.id) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE laboratory.igg BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND NOT examination.symptoms IS NULL",
            "ba": "The virtual table counts the number of patients from the 'patient' table who have undergone laboratory tests and examinations. It filters the results based on the concentration of IgG levels in the laboratory tests, ensuring that only those patients with IgG levels within a specified range are included. Additionally, it excludes patients who do not have any recorded symptoms in their examination data."
        },
        {
            "sample_id": 10576,
            "vt": "SELECT patient.sex, patient.birthday, examination.\"examination date\", examination.symptoms FROM patient INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE patient.id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the sex, birthday, examination date, and symptoms of a patient by joining the 'patient' and 'examination' tables based on the patient's identification. The placeholder in the WHERE clause represents the specific patient's ID."
        },
        {
            "sample_id": 10658,
            "vt": "SELECT DISTINCT patient.id, patient.admission FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE patient.sex = '[placeholder-type:string]' AND (laboratory.rbc <= [placeholder-type:numeric] OR laboratory.rbc >= [placeholder-type:numeric]) AND STRFTIME('%Y', CURRENT_TIMESTAMP()) - STRFTIME('%Y', patient.birthday) >= [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of patient IDs and their admission status from the 'patient' table, filtered by specific criteria. It joins the 'patient' table with the 'laboratory' table based on patient ID. The results are filtered to include only patients of a specified sex, with red blood cell counts either below or above certain numeric thresholds, and who meet a minimum age requirement based on their birth year."
        },
        {
            "sample_id": 10708,
            "vt": "SELECT COUNT(patient.id) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.alp >= [placeholder-type:numeric] AND patient.admission = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of patients from the 'patient' table who have undergone laboratory tests, specifically filtering for those whose alkaline phosphatase (ALP) levels are above a specified threshold and who have a certain admission status (either admitted to the hospital or followed at an outpatient clinic). The placeholders represent the ALP value and the admission status respectively."
        },
        {
            "sample_id": 10582,
            "vt": "SELECT CAST(SUM(CASE WHEN patient.sex = '[placeholder-type:string]' AND (laboratory.tp < [placeholder-type:numeric] OR laboratory.tp > [placeholder-type:numeric]) THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE patient.sex = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of a specific laboratory test result (total protein) based on the sex of the patients. It sums the values of total protein for patients of a specified sex who fall outside a given range, applies a weight to this sum, and divides it by the total count of patients of that sex. The placeholders represent the sex of the patients, the numeric thresholds for the total protein test, and the weight to be applied."
        },
        {
            "sample_id": 10682,
            "vt": "SELECT patient.id FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.rf < [placeholder-type:numeric] AND STRFTIME('%Y', DATE('[placeholder-type:string]')) - STRFTIME('%Y', patient.birthday) > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the identification of patients from the 'patient' table who have undergone laboratory tests. It filters the results based on two conditions: the rheumatoid factor (rf) value from the laboratory tests must be less than a specified numeric threshold, and the age of the patient, calculated from their birthday, must be greater than a specified numeric value."
        },
        {
            "sample_id": 10706,
            "vt": "SELECT patient.\"first date\" FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.ldh < [placeholder-type:numeric] ORDER BY laboratory.ldh LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the first date of patient visits from the 'patient' table, specifically for those patients whose lactate dehydrogenase (LDH) levels in the 'laboratory' table are below a specified threshold. The results are ordered by the LDH values and limited to a certain number of entries."
        },
        {
            "sample_id": 10617,
            "vt": "SELECT AVG(laboratory.alb) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.plt > [placeholder-type:numeric] AND patient.diagnosis = '[placeholder-type:string]' AND patient.sex = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average albumin level from the 'laboratory' table for patients who meet specific criteria. It filters patients based on their diagnosis and sex, and only includes those with a platelet count above a certain threshold."
        },
        {
            "sample_id": 10695,
            "vt": "SELECT COUNT(DISTINCT T1.ID) FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.ssb = '[placeholder-type:string]' OR '[placeholder-type:string]' AND patient.diagnosis = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of patients from the 'patient' table who have undergone laboratory tests. It filters the results based on the presence of a specific laboratory test result for 'ssb' and a specific diagnosis from the 'patient' table."
        },
        {
            "sample_id": 10642,
            "vt": "SELECT DISTINCT patient.id, patient.sex, patient.birthday FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.un = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct patient identifiers, their sex, and birthday from the 'patient' table, while joining with the 'laboratory' table to filter patients based on a specific urea nitrogen value. The placeholder in the WHERE clause represents the urea nitrogen measurement."
        },
        {
            "sample_id": 10691,
            "vt": "SELECT patient.id FROM patient INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE laboratory.sc170 IN ('[placeholder-type:string]', '[placeholder-type:string]') AND laboratory.date > [placeholder-type:numeric] - [placeholder-type:numeric] - [placeholder-type:numeric]",
            "ba": "The virtual table identifies patients from the 'patient' table who have undergone laboratory tests. It specifically filters for patients whose laboratory results for the 'anti-scl70' test (sc170) match certain specified values and whose laboratory test date is after a certain date. The placeholders represent the values for the anti-scl70 test and the date for filtering."
        }
    ],
    "food_inspection": [
        {
            "sample_id": 8783,
            "vt": "SELECT COUNT(inspections.business_id) FROM inspections INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE inspections.type = '[placeholder-type:string]' AND businesses.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of inspections for a specific type of inspection related to a particular eatery name from the 'inspections' and 'businesses' tables. The placeholders represent the type of inspection and the name of the eatery."
        },
        {
            "sample_id": 8845,
            "vt": "SELECT DISTINCT violations.violation_type_id, violations.risk_category FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id INNER JOIN inspections AS T3 ON T2.business_id = T3.business_id WHERE inspections.score BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of violation types and their associated risk categories for businesses that have undergone inspections. It filters the results based on inspection scores that fall within a specified numeric range, allowing users to identify which types of violations are present in businesses with certain inspection outcomes."
        },
        {
            "sample_id": 8839,
            "vt": "SELECT DISTINCT businesses.owner_name FROM businesses WHERE businesses.owner_zip = '[placeholder-type:string]'",
            "ba": "The virtual table lists the unique names of owners from the 'businesses' table who are located in a specific zip code. The placeholder in the WHERE clause represents the owner's zip code."
        },
        {
            "sample_id": 8832,
            "vt": "SELECT businesses.name, violations.risk_category, violations.description FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE violations.violation_type_id = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of eateries along with the risk category and description of violations from the 'violations' and 'businesses' tables. The query filters the results based on a specific violation type using a placeholder for string values."
        },
        {
            "sample_id": 8851,
            "vt": "SELECT DISTINCT businesses.owner_name FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE violations.violation_type_id = [placeholder-type:numeric] AND violations.\"date\" = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct names of owners from the 'businesses' table who have a specific type of violation recorded on a particular date. The query joins the 'violations' table with the 'businesses' table to filter the results based on the violation type and date."
        },
        {
            "sample_id": 8852,
            "vt": "SELECT inspections.type FROM inspections INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE businesses.owner_address = '[placeholder-type:string]' AND businesses.owner_city = '[placeholder-type:string]' ORDER BY inspections.score LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the types of inspections conducted on eateries owned by individuals residing at a specific address and city. The results are ordered by the inspection score, which indicates the quality of the establishment, and limited to a specified number of results."
        },
        {
            "sample_id": 8786,
            "vt": "SELECT COUNT(businesses.business_id) FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE businesses.city IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]') AND violations.risk_category = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses in specific cities that have violations of a certain risk category. It joins the 'violations' table with the 'businesses' table to filter the results based on the city and risk category."
        },
        {
            "sample_id": 8834,
            "vt": "SELECT inspections.type FROM inspections INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE businesses.name = '[placeholder-type:string]' ORDER BY inspections.score LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the types of inspections conducted on eateries from the 'inspections' table, specifically for a given eatery name. It joins the 'inspections' table with the 'businesses' table to filter the results based on the eatery's name. The results are ordered by the inspection score, and a limit is applied to control the number of returned records."
        },
        {
            "sample_id": 8779,
            "vt": "SELECT COUNT(violations.business_id) FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE violations.\"date\" = '[placeholder-type:string]' AND businesses.name = '[placeholder-type:string]' AND violations.risk_category = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of violations for a specific eatery on a given date, filtering by the eatery's name and the risk category of the violations. It joins the 'violations' table with the 'businesses' table to access the necessary information about the eatery."
        },
        {
            "sample_id": 8800,
            "vt": "SELECT COUNT(inspections.business_id) FROM violations INNER JOIN inspections AS T2 ON T1.business_id = T2.business_id GROUP BY violations.business_id ORDER BY COUNT(violations.business_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of inspections associated with each business that has violations. It joins the 'violations' and 'inspections' tables on the 'business_id' to correlate violations with their respective inspections. The results are grouped by 'business_id' to aggregate the count of inspections for each business, ordered by the count of violations, and limited to a specified number of results."
        },
        {
            "sample_id": 8838,
            "vt": "SELECT COUNT(businesses.business_id) FROM businesses WHERE businesses.address = '[placeholder-type:string]' AND businesses.city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses from the 'businesses' table that match a specific address and city. The placeholders in the WHERE clause represent the address and city of the eatery."
        },
        {
            "sample_id": 8842,
            "vt": "SELECT DISTINCT businesses.business_id, violations.risk_category FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE businesses.owner_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of unique business IDs along with their associated risk categories from the 'violations' table, specifically for businesses owned by a particular individual. The query joins the 'violations' table with the 'businesses' table to filter results based on the owner's name, which is represented by a placeholder."
        },
        {
            "sample_id": 8840,
            "vt": "SELECT COUNT(businesses.tax_code) FROM businesses WHERE businesses.tax_code = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses from the 'businesses' table that have a specific tax code. The placeholder in the WHERE clause represents the tax code being queried."
        },
        {
            "sample_id": 8782,
            "vt": "SELECT DISTINCT violations.description FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE violations.risk_category = '[placeholder-type:string]' AND businesses.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct descriptions of violations from the 'violations' table for businesses that match a specific risk category and name. The placeholders represent the risk category and the business name."
        },
        {
            "sample_id": 8854,
            "vt": "SELECT DISTINCT businesses.name, violations.risk_category FROM businesses INNER JOIN inspections AS T2 ON T1.business_id = T2.business_id INNER JOIN violations AS T3 ON T1.business_id = T3.business_id WHERE inspections.score > [placeholder-type:numeric] * (SELECT AVG(inspections.score) FROM inspections)",
            "ba": "The virtual table provides a list of unique eatery names along with their associated risk categories based on inspection scores. It filters the results to include only those eateries that have an inspection score greater than the average score of all inspections, indicating a higher standard of compliance."
        },
        {
            "sample_id": 8778,
            "vt": "SELECT inspections.type FROM inspections INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE inspections.\"date\" = '[placeholder-type:string]' AND businesses.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the types of inspections conducted on a specific eatery based on the inspection date and the name of the eatery. It joins the 'inspections' table with the 'businesses' table to correlate inspection records with their respective eateries."
        },
        {
            "sample_id": 8816,
            "vt": "SELECT DISTINCT (SELECT T3.name, T3.years, ROW_NUMBER() OVER (PARTITION BY T3.name ORDER BY T3.years) AS rowNumber FROM (SELECT DISTINCT name, STRFTIME('%Y', \"date\") AS years FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.score = 100) AS T3).name FROM (SELECT (SELECT DISTINCT name, STRFTIME('%Y', \"date\") AS years FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.score = 100).name, (SELECT DISTINCT name, STRFTIME('%Y', \"date\") AS years FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.score = 100).years, ROW_NUMBER() OVER (PARTITION BY (SELECT DISTINCT name, STRFTIME('%Y', \"date\") AS years FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.score = 100).name ORDER BY (SELECT DISTINCT name, STRFTIME('%Y', \"date\") AS years FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.score = 100).years) FROM (SELECT DISTINCT name, STRFTIME('%Y', \"date\") AS years FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.score = 100) AS T3) AS t4 GROUP BY (SELECT T3.name, T3.years, ROW_NUMBER() OVER (PARTITION BY T3.name ORDER BY T3.years) AS rowNumber FROM (SELECT DISTINCT name, STRFTIME('%Y', \"date\") AS years FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.score = 100) AS T3).name, DATE((SELECT T3.name, T3.years, ROW_NUMBER() OVER (PARTITION BY T3.name ORDER BY T3.years) AS rowNumber FROM (SELECT DISTINCT name, STRFTIME('%Y', \"date\") AS years FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.score = 100) AS T3).years || '[placeholder-type:string]', '[placeholder-type:string]' || ((SELECT T3.name, T3.years, ROW_NUMBER() OVER (PARTITION BY T3.name ORDER BY T3.years) AS rowNumber FROM (SELECT DISTINCT name, STRFTIME('%Y', \"date\") AS years FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.score = 100) AS T3).rownumber - [placeholder-type:numeric]) || '[placeholder-type:string]') HAVING COUNT((SELECT T3.name, T3.years, ROW_NUMBER() OVER (PARTITION BY T3.name ORDER BY T3.years) AS rowNumber FROM (SELECT DISTINCT name, STRFTIME('%Y', \"date\") AS years FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.score = 100) AS T3).years) = [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of distinct eatery names that have consistently received a perfect inspection score of 100 over the years. It utilizes a subquery to extract the years of inspections and applies a row numbering system to track the number of years each eatery has maintained this score. The final output is filtered to show only those eateries that have been inspected for a specified number of years, as indicated by the placeholders."
        },
        {
            "sample_id": 8789,
            "vt": "SELECT inspections.business_id FROM inspections GROUP BY inspections.business_id ORDER BY COUNT(inspections.business_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique business IDs from the 'inspections' table, grouping them to count the number of inspections for each business. It orders the results by the count of inspections in descending order and limits the output to a specified number of businesses."
        },
        {
            "sample_id": 8776,
            "vt": "SELECT DISTINCT businesses.name FROM inspections INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE inspections.score = [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique names of eateries from the 'businesses' table that have received a specific inspection score. The query joins the 'inspections' table with the 'businesses' table to filter based on the inspection score, using a placeholder for numeric values."
        },
        {
            "sample_id": 8801,
            "vt": "SELECT COUNT(violations.business_id) FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE businesses.business_certificate = '[placeholder-type:string]' AND violations.\"date\" = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of violations associated with businesses that have a specific business certificate and a specific violation date. It joins the 'violations' table with the 'businesses' table to filter the results based on the business certificate and the date of the violation."
        },
        {
            "sample_id": 8848,
            "vt": "SELECT DISTINCT businesses.owner_name FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE violations.risk_category = '[placeholder-type:string]' AND violations.violation_type_id = [placeholder-type:numeric] AND violations.description = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct owner names of eateries from the 'businesses' table that have specific violations. It filters the results based on the risk category, violation type ID, and a description of the violation."
        },
        {
            "sample_id": 8828,
            "vt": "SELECT DISTINCT violations.violation_type_id, violations.description FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE businesses.name = '[placeholder-type:string]' AND violations.risk_category = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of violation types and their descriptions for eateries based on their name and risk category. It combines data from the 'violations' and 'businesses' tables, filtering results to show only those that match the specified eatery name and risk category."
        },
        {
            "sample_id": 8849,
            "vt": "SELECT DISTINCT businesses.name FROM inspections INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE businesses.owner_city = '[placeholder-type:string]' AND inspections.score = [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct names of eateries from the 'businesses' table that have undergone inspections. It filters the results based on the owner's city and the inspection score, ensuring that only eateries in a specific city with a particular score are included."
        },
        {
            "sample_id": 8795,
            "vt": "SELECT businesses.name FROM inspections INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE inspections.score = (SELECT MIN(inspections.score) FROM inspections WHERE \"date\" = '2016-09-26' AND type = 'Routine - Unscheduled') AND inspections.\"date\" = '[placeholder-type:string]' AND inspections.type = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of eateries from the 'businesses' table that had the lowest inspection score on a specific date for a particular type of inspection. The query uses an inner join to connect the 'inspections' and 'businesses' tables based on the business ID, filtering for the minimum score on the specified date and type."
        },
        {
            "sample_id": 8790,
            "vt": "SELECT violations.business_id FROM violations GROUP BY violations.business_id ORDER BY COUNT(violations.business_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique business IDs from the 'violations' table, grouping them to count the number of violations for each business. The results are ordered by the count of violations in ascending order, and a limit is applied to restrict the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 8814,
            "vt": "SELECT businesses.name FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', violations.\"date\") = '[placeholder-type:string]' AND violations.description = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of eateries from the 'businesses' table that have specific violations recorded in the 'violations' table. The query filters the results based on the year of the violation date and the description of the violation, both represented by placeholders."
        },
        {
            "sample_id": 8781,
            "vt": "SELECT violations.description FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE violations.\"date\" = '[placeholder-type:string]' AND businesses.name = '[placeholder-type:string]' AND violations.risk_category = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the descriptions of violations from the 'violations' table for a specific eatery. It joins the 'violations' table with the 'businesses' table to filter results based on the date of the violation, the name of the eatery, and the risk category of the violation. The placeholders represent the specific date, eatery name, and risk category to be queried."
        },
        {
            "sample_id": 8808,
            "vt": "SELECT COUNT((SELECT owner_name FROM businesses GROUP BY owner_name HAVING COUNT(owner_name) > 5).owner_name) FROM (SELECT businesses.owner_name FROM businesses GROUP BY owner_name HAVING COUNT(owner_name) > 5) AS t1",
            "ba": "The virtual table counts the number of unique owners who own more than five eateries. It first selects the owner names from the 'businesses' table, groups them, and filters those with a count greater than five. Then, it counts how many such unique owner names exist."
        },
        {
            "sample_id": 8787,
            "vt": "SELECT businesses.name FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE violations.risk_category = '[placeholder-type:string]' GROUP BY businesses.name ORDER BY COUNT(businesses.name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of eateries from the 'businesses' table that have violations categorized under a specific risk category. The query joins the 'violations' table with the 'businesses' table to filter eateries based on their risk category and groups the results by eatery name, ordering them by the count of violations. The placeholders represent the risk category and the limit on the number of results returned."
        },
        {
            "sample_id": 8809,
            "vt": "SELECT DISTINCT businesses.name FROM inspections INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', inspections.\"date\") = '[placeholder-type:string]' AND inspections.score = [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct names of eateries from the 'businesses' table that have undergone inspections in a specific year and received a particular inspection score. The placeholders represent the year of the inspection and the score received by the eatery."
        },
        {
            "sample_id": 8822,
            "vt": "SELECT COUNT(DISTINCT business_id) FROM inspections WHERE STRFTIME('%Y', inspections.\"date\") = '[placeholder-type:string]' AND inspections.score = (SELECT MAX(inspections.score) FROM inspections WHERE STRFTIME('%Y', \"date\") = '2013')",
            "ba": "The virtual table counts the number of distinct businesses that have undergone inspections in a specific year, filtering for those that received the highest inspection score in that year. The placeholder in the WHERE clause represents the year for which the count is being requested."
        },
        {
            "sample_id": 8826,
            "vt": "SELECT inspections.\"date\" FROM inspections INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE businesses.city = '[placeholder-type:string]' ORDER BY inspections.score LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the inspection dates of businesses located in a specific city. It joins the 'inspections' table with the 'businesses' table to filter results based on the city of the eatery. The results are ordered by the inspection score, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 8841,
            "vt": "SELECT COUNT(violations.risk_category) FROM violations WHERE STRFTIME('%Y', violations.\"date\") = '[placeholder-type:string]' AND violations.risk_category = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of violations for a specific risk category that occurred in a given year. It filters the violations based on the year extracted from the violation date and the specified risk category."
        },
        {
            "sample_id": 8831,
            "vt": "SELECT violations.\"date\", violations.risk_category, violations.description, businesses.name FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE businesses.owner_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the details of violations associated with eateries, including the date of the violation, risk category, and a description of the violation. It also includes the name of the eatery linked to the owner specified in the query. The placeholder in the WHERE clause represents the owner's name."
        },
        {
            "sample_id": 8821,
            "vt": "SELECT businesses.name, AVG(inspections.score) FROM inspections INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id GROUP BY businesses.name ORDER BY COUNT(businesses.business_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the average inspection scores for eateries, grouped by their names. It joins the 'inspections' table with the 'businesses' table to correlate each eatery with its inspection scores. The results are ordered by the count of inspections for each eatery, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 8827,
            "vt": "SELECT DISTINCT inspections.type, violations.description FROM violations INNER JOIN inspections AS T2 ON T1.business_id = T2.business_id INNER JOIN businesses AS T3 ON T2.business_id = T3.business_id WHERE businesses.name = '[placeholder-type:string]' AND violations.risk_category = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of inspection types and violation descriptions for eateries based on their name and risk category. It combines data from the 'inspections', 'violations', and 'businesses' tables, filtering results to show only those that match the specified eatery name and risk category."
        },
        {
            "sample_id": 8788,
            "vt": "SELECT AVG(inspections.score) FROM inspections INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE businesses.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average inspection score of eateries from the 'inspections' table, joining it with the 'businesses' table to filter by the name of a specific eatery. The placeholder in the WHERE clause represents the name of the eatery for which the average score is being calculated."
        },
        {
            "sample_id": 8818,
            "vt": "SELECT AVG(inspections.score) FROM inspections INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id GROUP BY businesses.owner_name ORDER BY COUNT(businesses.business_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average inspection score of eateries grouped by the owner's name. It joins the 'inspections' table with the 'businesses' table to associate each inspection score with the corresponding eatery. The results are ordered by the count of businesses owned by each owner, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 8815,
            "vt": "SELECT COUNT(DISTINCT T2.business_id) FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id INNER JOIN inspections AS T3 ON T2.business_id = T3.business_id WHERE STRFTIME('%Y', violations.\"date\") = '[placeholder-type:string]' AND businesses.postal_code = '[placeholder-type:string]' AND inspections.score > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of distinct businesses that have violations recorded in the 'violations' table, while also ensuring that these businesses are linked to their details in the 'businesses' table and their inspection scores in the 'inspections' table. The query filters the results based on the year of the violation date, the postal code of the business, and requires that the inspection score exceeds a specified numeric threshold."
        },
        {
            "sample_id": 8780,
            "vt": "SELECT DISTINCT businesses.name FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', violations.\"date\") = '[placeholder-type:string]' AND violations.risk_category = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct names of eateries from the 'businesses' table that have recorded violations of a specific risk category in a given year. The placeholders in the WHERE clause represent the year of the violation and the risk category type."
        },
        {
            "sample_id": 8805,
            "vt": "SELECT COUNT(DISTINCT business_id) FROM inspections WHERE inspections.score < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of unique businesses from the 'inspections' table that have received an inspection score below a specified threshold. The placeholder in the WHERE clause represents the score limit."
        },
        {
            "sample_id": 8812,
            "vt": "SELECT COUNT(violations.business_id) FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE businesses.name = '[placeholder-type:string]' AND violations.risk_category = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of violations associated with a specific eatery based on its name and the risk category of the violations. It joins the 'violations' table with the 'businesses' table to filter the results accordingly."
        },
        {
            "sample_id": 8796,
            "vt": "SELECT businesses.name FROM inspections INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE inspections.type = '[placeholder-type:string]' GROUP BY businesses.name ORDER BY COUNT(inspections.business_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of eateries from the 'businesses' table that have undergone a specific type of inspection. The query joins the 'inspections' table with the 'businesses' table to filter based on the inspection type and groups the results by eatery name. The results are ordered by the count of inspections for each eatery, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 8825,
            "vt": "SELECT violations.business_id, violations.risk_category, violations.description FROM violations WHERE violations.violation_type_id = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about violations associated with businesses, specifically focusing on the business ID, risk category, and description of the violation. The query filters the results based on a specific violation type using a placeholder for the violation type ID."
        },
        {
            "sample_id": 8803,
            "vt": "SELECT CAST(SUM(CASE WHEN violations.risk_category = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(violations.business_id) FROM businesses INNER JOIN violations AS T2 ON T1.business_id = T2.business_id WHERE businesses.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of violations based on their risk category for a specific eatery. It sums the values of violations categorized as high, moderate, or low risk, and divides this sum by the total number of violations associated with the eatery. The placeholders represent the risk category, numeric values for calculations, and the name of the eatery."
        },
        {
            "sample_id": 8844,
            "vt": "SELECT COUNT(DISTINCT T2.business_id) FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE businesses.postal_code = [placeholder-type:numeric] AND violations.risk_category = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct businesses from the 'businesses' table that have violations of a specific risk category in a given postal code. The placeholders represent the postal code as a numeric value and the risk category as a string value."
        },
        {
            "sample_id": 8775,
            "vt": "SELECT COUNT(inspections.\"date\") FROM inspections WHERE STRFTIME('%Y', inspections.\"date\") = '[placeholder-type:string]' AND inspections.type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of inspections conducted on businesses for a specific year and type of inspection. The placeholders represent the year and the type of inspection to filter the results accordingly."
        },
        {
            "sample_id": 8819,
            "vt": "SELECT businesses.name FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', violations.\"date\") = '[placeholder-type:string]' AND violations.risk_category = '[placeholder-type:string]' GROUP BY businesses.name ORDER BY COUNT(businesses.business_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of eateries from the 'businesses' table that have recorded violations of a specific risk category during a specified year. The query joins the 'violations' table with the 'businesses' table to filter and group the results based on the violation date and risk category, while also limiting the number of results returned."
        },
        {
            "sample_id": 8835,
            "vt": "SELECT businesses.owner_name FROM violations INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE violations.risk_category = '[placeholder-type:string]' AND violations.description = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of owners from the 'businesses' table for eateries that have specific violations. It filters the results based on the risk category and the description of the violation, allowing users to identify owners of businesses with particular safety and health concerns."
        }
    ],
    "california_schools": [
        {
            "sample_id": 9454,
            "vt": "SELECT CAST(frpm.\"frpm count (k-12)\" AS FLOAT) / frpm.\"enrollment (k-12)\" FROM frpm INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE schools.soc = [placeholder-type:numeric] ORDER BY frpm.\"frpm count (k-12)\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the ratio of Free or Reduced Price Meal Count (K-12) to Enrollment (K-12) from the 'frpm' table, joining it with the 'schools' table to filter based on the School Ownership Code (SOC). The result is ordered by the Free or Reduced Price Meal Count and limited to a specified number of results."
        },
        {
            "sample_id": 9436,
            "vt": "SELECT schools.ncesschool FROM schools INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY frpm.\"enrollment (ages 5-17)\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the NCES school identification numbers from the 'schools' table, joining it with the 'frpm' table based on the CDSCode. The results are ordered by the enrollment of ages 5-17 in the 'frpm' table, and the number of records returned is limited by a numeric placeholder."
        },
        {
            "sample_id": 9441,
            "vt": "SELECT schools.phone FROM schools INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY satscores.avgscrmath LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the phone numbers of schools from the 'schools' table, joining it with the 'satscores' table based on the common 'cdscode'. The results are ordered by the average math scores from the 'satscores' table, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 9469,
            "vt": "SELECT CAST(COUNT(schools.school) AS FLOAT) / [placeholder-type:numeric] FROM schools WHERE schools.doc = [placeholder-type:numeric] AND schools.county = '[placeholder-type:string]' AND STRFTIME('%Y', schools.opendate) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the ratio of the number of schools in a specific county that are operated by a certain district ownership code and opened in a specified academic year. The placeholders represent the district ownership code, county name, and academic year respectively."
        },
        {
            "sample_id": 9496,
            "vt": "SELECT MIN(frpm.\"low grade\") FROM frpm INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE schools.ncesdist = '[placeholder-type:string]' AND schools.edopscode = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the minimum low grade offered by schools from the 'frpm' table, joining it with the 'schools' table based on the CDSCode. It filters the results based on a specific NCES district code and educational option code, both represented by placeholders for string values."
        },
        {
            "sample_id": 9443,
            "vt": "SELECT COUNT(frpm.cdscode) FROM frpm WHERE frpm.\"county name\" = '[placeholder-type:string]' AND frpm.\"free meal count (k-12)\" > [placeholder-type:numeric] AND frpm.\"frpm count (k-12)\" < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of records in the 'frpm' table where the county name matches a specified value, the free meal count for K-12 exceeds a certain numeric threshold, and the free or reduced price meal count for K-12 is below another numeric threshold."
        },
        {
            "sample_id": 9435,
            "vt": "SELECT schools.phone FROM schools INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY CAST(satscores.numge1500 AS FLOAT) / satscores.numtsttakr LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the phone numbers of schools from the 'schools' table, joining it with the 'satscores' table to filter based on the number of test takers who scored 1500 or more on the SAT. The results are ordered by the ratio of students scoring 1500 or above to the total number of test takers, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 9448,
            "vt": "SELECT frpm.\"school name\", schools.street, schools.city, schools.state, schools.zip FROM frpm INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE schools.county = '[placeholder-type:string]' AND frpm.\"free meal count (ages 5-17)\" > [placeholder-type:numeric] AND frpm.\"school type\" = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of school names along with their street addresses, cities, states, and zip codes from the 'frpm' and 'schools' tables. It filters the results based on the specified county, a minimum count of free meals for ages 5-17, and a specific school type."
        },
        {
            "sample_id": 9456,
            "vt": "SELECT CAST(frpm.\"free meal count (ages 5-17)\" AS FLOAT) / frpm.\"enrollment (ages 5-17)\" FROM schools INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE schools.admfname1 = '[placeholder-type:string]' AND schools.admlname1 = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the ratio of free meal count to enrollment for students aged 5-17 from the 'frpm' table, joined with the 'schools' table. It filters the results based on the first and last names of the school administrator."
        },
        {
            "sample_id": 9471,
            "vt": "SELECT DISTINCT schools.county, schools.school, schools.closeddate FROM schools WHERE schools.county = (SELECT schools.county FROM schools WHERE StatusType = 'Closed' GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1) AND schools.statustype = '[placeholder-type:string]' AND NOT schools.school IS NULL",
            "ba": "The virtual table provides a list of distinct counties, school names, and their closure dates from the 'schools' table. It filters the results to include only those schools located in the county with the highest number of closed schools, while also ensuring that the status type of the schools matches a specified value and that the school name is not null."
        },
        {
            "sample_id": 9492,
            "vt": "SELECT COUNT(schools.school) FROM schools WHERE (schools.statustype = '[placeholder-type:string]' OR schools.statustype = '[placeholder-type:string]') AND schools.soc = [placeholder-type:numeric] AND schools.county = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of schools from the 'schools' table that meet specific criteria. It filters schools based on their status type, which can be either active or closed, and also checks for a specific school ownership code. Additionally, it restricts the results to a particular county."
        },
        {
            "sample_id": 9423,
            "vt": "SELECT frpm.\"free meal count (ages 5-17)\" / frpm.\"enrollment (ages 5-17)\" FROM frpm WHERE frpm.\"educational option type\" = '[placeholder-type:string]' AND NOT frpm.\"free meal count (ages 5-17)\" / frpm.\"enrollment (ages 5-17)\" IS NULL ORDER BY frpm.\"free meal count (ages 5-17)\" / frpm.\"enrollment (ages 5-17)\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the ratio of free meal counts to enrollment for students aged 5-17 from the 'frpm' table, filtered by a specific educational option type. The result is ordered by the calculated ratio and limited to a specified number of results."
        },
        {
            "sample_id": 9510,
            "vt": "SELECT schools.admemail1, schools.school FROM satscores INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY satscores.numge1500 LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of administrator email addresses and school names from the 'schools' table, specifically for schools that have SAT scores data. The query joins the 'satscores' table with the 'schools' table based on the common 'cdscode' (CDSCode) to ensure that only relevant schools with SAT scores are included. The results are ordered by the number of test takers whose total SAT scores are greater than or equal to 1500, and the output is limited to a specified number of records."
        },
        {
            "sample_id": 9490,
            "vt": "SELECT schools.county FROM schools WHERE STRFTIME('%Y', schools.closeddate) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND schools.statustype = '[placeholder-type:string]' AND schools.soc = [placeholder-type:numeric] GROUP BY schools.county ORDER BY COUNT(schools.school) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the counties of schools that have been closed within a specified range of years, filtered by their status type and school ownership code. The results are grouped by county and ordered by the number of schools in each county, with a limit on the number of counties returned."
        },
        {
            "sample_id": 9509,
            "vt": "SELECT schools.admemail1, schools.admemail2 FROM frpm INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE schools.county = '[placeholder-type:string]' AND schools.city = '[placeholder-type:string]' AND schools.doc = [placeholder-type:numeric] AND STRFTIME('%Y', schools.opendate) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND schools.soc = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the email addresses of school administrators from the 'schools' table, specifically for schools located in a specified county and city, with a certain district ownership code. It also filters the results based on the school's opening date and school ownership code."
        },
        {
            "sample_id": 9449,
            "vt": "SELECT schools.school, satscores.avgscrwrite, schools.phone FROM schools LEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds WHERE STRFTIME('%Y', schools.opendate) > '[placeholder-type:string]' OR STRFTIME('%Y', schools.closeddate) < '[placeholder-type:string]'",
            "ba": "The virtual table provides information about schools, including their names, average writing scores from SAT scores, and contact phone numbers. It retrieves data from the 'schools' table and joins it with the 'satscores' table based on the common 'cdscode'. The query filters schools that have opened after a certain year or closed before a certain year, using placeholders for these year values."
        },
        {
            "sample_id": 9426,
            "vt": "SELECT schools.phone FROM frpm INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE frpm.\"charter funding type\" = '[placeholder-type:string]' AND frpm.\"charter school (y/n)\" = [placeholder-type:numeric] AND schools.opendate > '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the phone numbers of schools from the 'schools' table that are associated with specific charter funding types and statuses. It filters the results based on whether the school is a charter school and the date the school opened."
        },
        {
            "sample_id": 9462,
            "vt": "SELECT schools.phone FROM satscores INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE schools.district = '[placeholder-type:string]' AND NOT satscores.avgscrread IS NULL ORDER BY satscores.avgscrread LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the phone numbers of schools from the 'schools' table that are associated with SAT scores from the 'satscores' table. It filters the results based on a specific district and ensures that only schools with available average reading scores are included. The results are ordered by the average reading scores in ascending order, and a limit is applied to the number of records returned."
        },
        {
            "sample_id": 9434,
            "vt": "SELECT MAX(CAST(frpm.\"free meal count (ages 5-17)\" AS FLOAT) / frpm.\"enrollment (ages 5-17)\") FROM frpm INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE CAST(satscores.numge1500 AS FLOAT) / satscores.numtsttakr > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the maximum percentage of eligible free meal counts for students aged 5-17 from the 'frpm' table, based on the enrollment figures for the same age group. It joins the 'frpm' table with the 'satscores' table using the CDSCode to filter schools where the excellence rate, defined as the number of test takers with scores greater than or equal to 1500 divided by the total number of test takers, exceeds a specified numeric threshold."
        },
        {
            "sample_id": 9487,
            "vt": "SELECT CAST(SUM(CASE WHEN schools.fundingtype = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(CASE WHEN schools.fundingtype <> '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM schools WHERE schools.county = '[placeholder-type:string]' AND schools.charter = [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average based on the funding type of schools within a specific county. It sums up values conditionally based on whether the funding type matches a specified placeholder, and divides this by the sum of values for schools with a different funding type. The result is then multiplied by another placeholder value, allowing for dynamic adjustments based on user input."
        },
        {
            "sample_id": 9425,
            "vt": "SELECT schools.mailstreet FROM frpm INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY frpm.\"frpm count (k-12)\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the mailing addresses of schools from the 'schools' table that are associated with the 'frpm' table, which contains data on free or reduced-price meal counts. The results are ordered by the count of free or reduced-price meals for K-12 students, and the number of results returned is limited by a numeric placeholder."
        },
        {
            "sample_id": 9474,
            "vt": "SELECT COUNT(satscores.cds) FROM satscores INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE schools.mailcity = '[placeholder-type:string]' AND (satscores.avgscrread + satscores.avgscrmath + satscores.avgscrwrite) >= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of SAT scores from the 'satscores' table for schools located in a specific city, where the average scores in Reading, Math, and Writing meet or exceed a specified threshold. It joins the 'satscores' table with the 'schools' table based on the CDSCode to filter the results by the city name and the combined average scores."
        },
        {
            "sample_id": 9463,
            "vt": "SELECT schools.school FROM (SELECT schools.school, satscores.avgscrread, RANK() OVER (PARTITION BY schools.county ORDER BY satscores.avgscrread) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F') AS ranked_schools WHERE subquery_ranked_schools.rnk <= [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of schools that offer exclusively virtual instruction, ranked by their average reading scores within each county. The ranking is determined by the average reading scores from the 'satscores' table, and only schools with a rank less than or equal to a specified number will be included in the results."
        },
        {
            "sample_id": 9430,
            "vt": "SELECT satscores.numtsttakr FROM satscores WHERE satscores.cds = (SELECT frpm.cdscode FROM frpm ORDER BY \"FRPM Count (K-12)\" DESC LIMIT 1)",
            "ba": "The virtual table retrieves the number of test takers from the 'satscores' table for the school with the highest Free or Reduced Price Meal Count (K-12) from the 'frpm' table. The inner query selects the CDSCode of the school with the maximum FRPM count, which is then used to filter the outer query."
        },
        {
            "sample_id": 9488,
            "vt": "SELECT COUNT(schools.school) FROM schools WHERE STRFTIME('%Y', schools.opendate) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND schools.county = '[placeholder-type:string]' AND schools.fundingtype = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of schools from the 'schools' table that opened within a specific range of years, located in a specified county, and have a particular funding type. The placeholders represent the start year, end year, county name, and funding type respectively."
        },
        {
            "sample_id": 9504,
            "vt": "SELECT schools.gsoffered FROM schools ORDER BY ABS(schools.longitude) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of grade spans offered by schools from the 'schools' table, sorted by the absolute value of their longitude. The placeholder in the LIMIT clause allows users to specify the maximum number of records to return."
        },
        {
            "sample_id": 9447,
            "vt": "SELECT satscores.sname, frpm.\"charter funding type\" FROM satscores INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE frpm.\"district name\" LIKE '[placeholder-type:string]' GROUP BY satscores.sname, frpm.\"charter funding type\" HAVING CAST(SUM(satscores.avgscrmath) AS FLOAT) / COUNT(satscores.cds) > [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of school names and their corresponding charter funding types from the 'satscores' and 'frpm' tables. It filters the results based on a specific district name and calculates the average math scores for schools in that district, only including those with an average score above a specified numeric threshold."
        },
        {
            "sample_id": 9452,
            "vt": "SELECT schools.city FROM frpm INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode GROUP BY schools.city ORDER BY SUM(frpm.\"enrollment (k-12)\") LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of cities where schools are located, based on the enrollment data from the 'frpm' table. It joins the 'frpm' table with the 'schools' table using the CDSCode to ensure that only relevant records are considered. The results are grouped by city, and the total enrollment for each city is summed to determine the order of the cities. The output is limited to a specified number of cities."
        },
        {
            "sample_id": 9502,
            "vt": "SELECT frpm.\"school type\", frpm.\"school name\", schools.latitude FROM frpm INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY schools.latitude LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the school type, school name, and latitude of schools from the 'frpm' and 'schools' tables. It retrieves this information by joining the two tables on the CDSCode, which is a common identifier. The results are ordered by the latitude of the schools, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 9485,
            "vt": "SELECT schools.admfname1, schools.admlname1, schools.school, schools.city FROM schools WHERE schools.charter = [placeholder-type:numeric] AND schools.charternum = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of administrators, along with the school name and city, from the 'schools' table. It filters the results based on whether the school is a charter school and its corresponding charter number, using placeholders for numeric and string values."
        },
        {
            "sample_id": 9501,
            "vt": "SELECT schools.county, COUNT(schools.virtual) FROM schools WHERE (schools.county = '[placeholder-type:string]' OR schools.county = '[placeholder-type:string]') AND schools.virtual = '[placeholder-type:string]' GROUP BY schools.county ORDER BY COUNT(schools.virtual) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the count of schools based on their virtual instruction type within specified counties. It filters the results to include only those schools located in the given counties and that match a specific virtual instruction type. The results are grouped by county and ordered by the count of virtual schools, with a limit on the number of results returned."
        },
        {
            "sample_id": 9450,
            "vt": "SELECT schools.school, schools.doc FROM frpm INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE schools.fundingtype = '[placeholder-type:string]' AND (frpm.\"enrollment (k-12)\" - frpm.\"enrollment (ages 5-17)\") > (SELECT AVG(frpm.\"enrollment (k-12)\" - frpm.\"enrollment (ages 5-17)\") FROM frpm AS T3 INNER JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode WHERE T4.FundingType = 'Locally funded')",
            "ba": "The virtual table retrieves the names of schools and their district ownership codes from the 'schools' table, filtering for schools with a specific funding type. It also includes a condition that compares the difference between total K-12 enrollment and enrollment for ages 5-17 against the average difference for locally funded schools."
        },
        {
            "sample_id": 9506,
            "vt": "SELECT DISTINCT schools.admfname1, schools.district FROM schools INNER JOIN (SELECT admfname1 FROM schools GROUP BY admfname1 ORDER BY COUNT(admfname1) DESC LIMIT 2) AS T2 ON T1.AdmFName1 = T2.admfname1",
            "ba": "The virtual table provides a list of distinct first names of administrators along with their corresponding school districts from the 'schools' table. It filters the results to include only the top two most common first names of administrators, ensuring that the output is concise and focused on the most frequently occurring names."
        },
        {
            "sample_id": 9476,
            "vt": "SELECT schools.school, schools.mailzip FROM schools WHERE schools.admfname1 = '[placeholder-type:string]' AND schools.admlname1 = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and mailing zip codes of schools from the 'schools' table where the first and last names of the administrators match specified values. The placeholders in the WHERE clause represent the first and last names of the administrators."
        },
        {
            "sample_id": 9446,
            "vt": "SELECT frpm.\"school name\" FROM satscores INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE CAST(frpm.\"free meal count (k-12)\" AS FLOAT) / frpm.\"enrollment (k-12)\" > [placeholder-type:numeric] AND satscores.numge1500 > [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of schools from the 'frpm' table that meet specific criteria regarding free meal counts and SAT scores. It joins the 'satscores' table with the 'frpm' table based on the CDSCode, filtering for schools where the ratio of free meal count to enrollment exceeds a certain numeric threshold and where the number of test takers with scores greater than or equal to 1500 also exceeds another numeric threshold."
        },
        {
            "sample_id": 9445,
            "vt": "SELECT schools.school, schools.street FROM schools INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE frpm.\"enrollment (k-12)\" - frpm.\"enrollment (ages 5-17)\" > [placeholder-type:numeric]",
            "ba": "The virtual table describes the names and street addresses of schools from the 'schools' table that have a difference in enrollment between K-12 and ages 5-17 greater than a specified numeric value. The query joins the 'schools' table with the 'frpm' table using the CDSCode to filter the results based on the enrollment criteria."
        },
        {
            "sample_id": 9508,
            "vt": "SELECT schools.admlname1, schools.district, schools.county, schools.school FROM schools WHERE schools.charternum = '[placeholder-type:string]'",
            "ba": "The virtual table describes the administrator's last name, district, county, and school name from the 'schools' table for a specific charter school identified by its charter number. The placeholder in the WHERE clause represents the charter school number."
        },
        {
            "sample_id": 9491,
            "vt": "SELECT schools.ncesdist FROM schools WHERE schools.soc = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the National Center for Educational Statistics (NCES) district identification number from the 'schools' table for schools that match a specific School Ownership Code (SOC). The placeholder in the WHERE clause represents the SOC value to filter the results accordingly."
        },
        {
            "sample_id": 9422,
            "vt": "SELECT frpm.\"free meal count (k-12)\" / frpm.\"enrollment (k-12)\" FROM frpm WHERE frpm.\"county name\" = '[placeholder-type:string]' ORDER BY (CAST(frpm.\"free meal count (k-12)\" AS FLOAT) / frpm.\"enrollment (k-12)\") LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the ratio of free meal counts to total enrollment for K-12 students in a specific county from the 'frpm' table. The result is ordered by the calculated ratio and limited to a specified number of results."
        },
        {
            "sample_id": 9507,
            "vt": "SELECT frpm.\"free meal count (k-12)\" * [placeholder-type:numeric] / frpm.\"enrollment (k-12)\", frpm.\"district code\" FROM frpm INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE schools.admfname1 = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the ratio of free meal count to enrollment for K-12 students from the 'frpm' table, filtered by the first name of the administrator from the 'schools' table. The result includes the calculated ratio and the district code."
        },
        {
            "sample_id": 9489,
            "vt": "SELECT COUNT(schools.school) FROM schools WHERE STRFTIME('%Y', schools.closeddate) = '[placeholder-type:string]' AND schools.city = '[placeholder-type:string]' AND schools.doctype = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of schools from the 'schools' table that were closed in a specific year, located in a specific city, and have a specific type of district ownership."
        },
        {
            "sample_id": 9478,
            "vt": "SELECT COUNT(schools.cdscode) FROM schools WHERE schools.city = '[placeholder-type:string]' AND schools.mailstate = '[placeholder-type:string]' AND schools.statustype = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of schools from the 'schools' table that are located in a specific city and state, and have a particular status type. The placeholders in the WHERE clause represent the city name, state name, and status type of the schools."
        },
        {
            "sample_id": 9460,
            "vt": "SELECT schools.website FROM satscores INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE satscores.numtsttakr BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND schools.county = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the website addresses of schools from the 'schools' table that are associated with SAT scores from the 'satscores' table. It filters the results based on the number of test takers falling within a specified range and the county name."
        },
        {
            "sample_id": 9464,
            "vt": "SELECT schools.edopsname FROM satscores INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY satscores.avgscrmath LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the educational option names from the 'schools' table, specifically for schools that have corresponding SAT scores in the 'satscores' table. The results are ordered by the average math scores from the SATs, and the number of results returned is limited by a numeric placeholder."
        },
        {
            "sample_id": 9473,
            "vt": "SELECT schools.mailstreet, schools.school FROM satscores INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE NOT satscores.avgscrread IS NULL ORDER BY satscores.avgscrread LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the mailing address and name of schools that have recorded average reading scores. It combines data from the 'satscores' and 'schools' tables, ensuring that only schools with non-null average reading scores are included. The results are ordered by average reading scores, and a limit is applied to the number of records returned."
        },
        {
            "sample_id": 9429,
            "vt": "SELECT schools.phone FROM satscores INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY satscores.numge1500 LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the phone numbers of schools from the 'schools' table that are associated with SAT scores from the 'satscores' table. The results are ordered by the number of test takers whose total SAT scores are greater than or equal to a specified threshold, and the output is limited to a certain number of records as indicated by a placeholder."
        },
        {
            "sample_id": 9437,
            "vt": "SELECT schools.district FROM schools INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE schools.statustype = '[placeholder-type:string]' ORDER BY satscores.avgscrread LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the district names from the 'schools' table for schools that have a specific status type. It joins the 'schools' table with the 'satscores' table based on the CDSCode to ensure that only schools with corresponding SAT scores are included. The results are ordered by the average reading scores from the 'satscores' table, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 9427,
            "vt": "SELECT COUNT(DISTINCT T2.School) FROM satscores INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE schools.virtual = '[placeholder-type:string]' AND satscores.avgscrmath > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of distinct schools from the 'satscores' table that have a specific type of virtual instruction and have an average math score above a certain threshold. It joins the 'satscores' table with the 'schools' table based on the CDSCode to filter the results accordingly."
        },
        {
            "sample_id": 9486,
            "vt": "SELECT COUNT(*) FROM schools WHERE schools.charternum = '[placeholder-type:string]' AND schools.mailcity = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of schools from the 'schools' table that are identified as charter schools based on a specific charter school number and located in a specified city. The placeholders represent the charter school number and the city name."
        },
        {
            "sample_id": 9479,
            "vt": "SELECT schools.phone, schools.ext FROM satscores INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY satscores.avgscrwrite LIMIT [placeholder-type:numeric] OFFSET [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the phone number and extension of schools from the 'schools' table, based on their association with SAT scores from the 'satscores' table. The results are ordered by the average writing scores of the schools, with pagination controlled by placeholders for limiting the number of results and specifying an offset."
        },
        {
            "sample_id": 9472,
            "vt": "SELECT schools.mailstreet, schools.school FROM satscores INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY satscores.avgscrmath LIMIT [placeholder-type:numeric] OFFSET [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of school mailing addresses and their names from the 'schools' table, ordered by the average math scores from the 'satscores' table. The query uses an inner join to connect the two tables based on the CDSCode, ensuring that only schools with corresponding SAT scores are included. The results can be limited and offset using numeric placeholders for pagination."
        },
        {
            "sample_id": 9497,
            "vt": "SELECT schools.eilname, schools.school FROM frpm INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE frpm.\"nslp provision status\" = '[placeholder-type:string]' AND frpm.\"county code\" = [placeholder-type:numeric]",
            "ba": "The virtual table describes the educational institutions' names and their corresponding educational instruction level names from the 'frpm' and 'schools' tables. It filters the results based on the NSLP provision status and county code, allowing users to specify these criteria."
        },
        {
            "sample_id": 9505,
            "vt": "SELECT schools.city, COUNT(schools.cdscode) FROM frpm INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE schools.magnet = [placeholder-type:numeric] AND schools.gsoffered = '[placeholder-type:string]' AND frpm.\"nslp provision status\" = '[placeholder-type:string]' GROUP BY schools.city",
            "ba": "The virtual table summarizes the number of schools located in each city that meet specific criteria, including whether they are magnet schools, the grade span they offer, and their NSLP provision status. The placeholders allow users to specify the magnet status, grade span, and NSLP provision status they are interested in."
        }
    ],
    "olympics": [
        {
            "sample_id": 5027,
            "vt": "SELECT COUNT(games_competitor.person_id) FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE games.games_name = '[placeholder-type:string]' AND games_competitor.age = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of competitors who participated in a specific game based on the game's name and the age of the competitors. It joins the 'games' table with the 'games_competitor' table to filter the results accordingly."
        },
        {
            "sample_id": 4926,
            "vt": "SELECT CAST(COUNT(CASE WHEN noc_region.region_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(person.id) FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id INNER JOIN person_region AS T4 ON T3.id = T4.person_id INNER JOIN noc_region AS T5 ON T4.region_id = T5.id WHERE games.games_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of competitors from a specific region who participated in a particular Olympic game, expressed as a percentage. It counts the number of competitors from the specified region and divides it by the total number of competitors in that game, then multiplies by a specified factor to convert it into a percentage. The placeholders represent the region name and the factor for scaling the result."
        },
        {
            "sample_id": 5042,
            "vt": "SELECT CAST(COUNT(CASE WHEN games_competitor.age < [placeholder-type:numeric] THEN [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(games_competitor.games_id) FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE games.season = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage of competitors who participated in Olympic games at an age younger than a specified threshold. It does this by counting the number of competitors whose age is less than the given value and dividing it by the total number of competitors in the specified season of the games. The result is then multiplied by a specified factor to adjust the final output."
        },
        {
            "sample_id": 5005,
            "vt": "SELECT COUNT(competitor_event.competitor_id) FROM competitor_event INNER JOIN event AS T2 ON T1.event_id = T2.id INNER JOIN medal AS T3 ON T1.medal_id = T3.id WHERE event.event_name LIKE '[placeholder-type:string]' AND medal.medal_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of competitors who participated in a specific event and won a specific medal from the Olympic Games data model. It joins the 'competitor_event' table with the 'event' table to filter by event name and with the 'medal' table to filter by medal name."
        },
        {
            "sample_id": 5019,
            "vt": "SELECT city.city_name FROM games_city INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id WHERE games.games_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of cities that hosted specific Olympic games. It retrieves the city names from the 'city' table by joining it with the 'games_city' table, which links cities to games. The query filters the results based on the name of the game, represented by a placeholder for string values."
        },
        {
            "sample_id": 4995,
            "vt": "SELECT COUNT(games_competitor.person_id) FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE games.games_name = '[placeholder-type:string]' AND games_competitor.age > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of competitors who participated in a specific game, filtered by the game's name and the age of the competitors. It joins the 'games' table with the 'games_competitor' table to access the relevant data."
        },
        {
            "sample_id": 5063,
            "vt": "SELECT AVG(games_competitor.age) FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE games.games_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average age of competitors who participated in a specific game. It joins the 'games' table with the 'games_competitor' table based on the game ID, filtering the results by the name of the game using a placeholder for string values."
        },
        {
            "sample_id": 5035,
            "vt": "SELECT person_region.region_id FROM person_region INNER JOIN person AS T2 ON T1.person_id = T2.id WHERE person.full_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the region identifier associated with a person based on their full name. It joins the 'person_region' table with the 'person' table to filter the results by the specified person's full name, represented by a placeholder."
        },
        {
            "sample_id": 4980,
            "vt": "SELECT CAST(COUNT(CASE WHEN person.gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(games_competitor.person_id) FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE games.games_name = '[placeholder-type:string]' AND games_competitor.age < [placeholder-type:numeric]",
            "ba": "The virtual table calculates the percentage of participants of a specific gender in a particular Olympic game, adjusted by a specified factor. It counts the number of participants of the specified gender and divides it by the total number of competitors in that game, then multiplies the result by a given numeric value. The query filters the results based on the game's name and the age of the competitors."
        },
        {
            "sample_id": 4917,
            "vt": "SELECT person.full_name FROM noc_region INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE noc_region.region_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the full names of persons from the 'person' table who belong to a specific region identified by the NOC code. The query joins the 'noc_region' table with the 'person_region' table to filter persons based on their associated region, and it uses a placeholder for the region's name in the WHERE clause."
        },
        {
            "sample_id": 4975,
            "vt": "SELECT COUNT(person.id) FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id INNER JOIN person_region AS T4 ON T3.id = T4.person_id INNER JOIN noc_region AS T5 ON T4.region_id = T5.id WHERE games.games_name = '[placeholder-type:string]' AND noc_region.region_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of participants from a specific region who competed in a particular Olympic game. It joins multiple tables to gather the necessary information, including the games, competitors, persons, and their respective regions."
        },
        {
            "sample_id": 4998,
            "vt": "SELECT AVG(games_competitor.age) FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person_region AS T3 ON T2.person_id = T3.person_id INNER JOIN noc_region AS T4 ON T3.region_id = T4.id WHERE games.games_name = '[placeholder-type:string]' AND noc_region.region_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average age of competitors who participated in a specific Olympic game held in a specific region. It joins the 'games' table with 'games_competitor' to link games with their competitors, then connects to 'person_region' to associate competitors with their respective regions, and finally links to 'noc_region' to filter by the region's name. The placeholders represent the game name and the region name."
        },
        {
            "sample_id": 4999,
            "vt": "SELECT noc_region.region_name FROM noc_region WHERE noc_region.noc = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of regions from the 'noc_region' table that correspond to a specific NOC code. The placeholder in the WHERE clause represents the NOC code being queried."
        },
        {
            "sample_id": 4990,
            "vt": "SELECT COUNT(person.id) FROM person INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id INNER JOIN competitor_event AS T3 ON T2.id = T3.competitor_id INNER JOIN event AS T4 ON T3.event_id = T4.id WHERE person.full_name = '[placeholder-type:string]' AND event.event_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of times a specific person has participated in a specific event in the Olympics. It joins the 'person' table with the 'games_competitor' table to link each person to their game participations, then further joins with the 'competitor_event' table to connect competitors to events, and finally joins with the 'event' table to filter by event name. The placeholders represent the person's full name and the event name being queried."
        },
        {
            "sample_id": 4982,
            "vt": "SELECT (SELECT games.games_name FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE T1.season = 'Summer' GROUP BY T1.games_year ORDER BY COUNT(T2.person_id) DESC LIMIT 1), (SELECT games.games_name FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE T1.season = 'Summer' GROUP BY T1.games_year ORDER BY COUNT(T2.person_id) LIMIT 1)",
            "ba": "The virtual table identifies the summer Olympic games with the highest and lowest number of competitors. It retrieves the game names by joining the 'games' and 'games_competitor' tables, filtering for the summer season, and grouping by the year of the games. The first subquery selects the game with the most competitors, while the second subquery selects the game with the least competitors."
        },
        {
            "sample_id": 4988,
            "vt": "SELECT games_competitor.age FROM person INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id WHERE person.full_name = '[placeholder-type:string]' ORDER BY games_competitor.age LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the ages of competitors from the 'games_competitor' table who are associated with a specific person identified by their full name in the 'person' table. The results are ordered by age and limited to a specified number of entries."
        },
        {
            "sample_id": 5076,
            "vt": "SELECT AVG(person.height) FROM person INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id WHERE games_competitor.age BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average height of persons who participated in Olympic games, filtered by their age range. The query joins the 'person' table with the 'games_competitor' table to access the height and age of competitors. The placeholders represent the minimum and maximum ages for filtering the results."
        },
        {
            "sample_id": 5016,
            "vt": "SELECT noc_region.region_name FROM person_region INNER JOIN noc_region AS T2 ON T1.region_id = T2.id GROUP BY noc_region.region_name ORDER BY COUNT(person_region.person_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of regions from the 'noc_region' table, which are associated with persons in the 'person_region' table. It groups the results by region name and orders them based on the count of persons linked to each region, limiting the output to a specified number of regions."
        },
        {
            "sample_id": 4942,
            "vt": "SELECT COUNT(games_competitor.person_id) FROM competitor_event INNER JOIN games_competitor AS T2 ON T1.competitor_id = T2.id INNER JOIN event AS T3 ON T1.event_id = T3.id WHERE event.event_name LIKE '[placeholder-type:string]' AND games_competitor.age = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of competitors who participated in a specific event at the Olympics, filtered by the event's name and the age of the competitors."
        },
        {
            "sample_id": 4994,
            "vt": "SELECT city.city_name FROM games_city INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id WHERE games.games_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of cities that hosted specific Olympic games. It retrieves the city names from the 'city' table by joining it with the 'games_city' table, which links cities to games. The query filters the results based on the name of the game, represented by a placeholder for string values."
        },
        {
            "sample_id": 5008,
            "vt": "SELECT games.games_year FROM games_city INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id WHERE city.city_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the years of games held in a specific city from the 'games' table, using the 'games_city' table to link games to their respective cities. The placeholder in the WHERE clause represents the name of the city for which the game years are being queried."
        },
        {
            "sample_id": 5050,
            "vt": "SELECT DISTINCT sport.sport_name FROM sport INNER JOIN event AS T2 ON T1.id = T2.sport_id INNER JOIN competitor_event AS T3 ON T2.id = T3.event_id INNER JOIN games_competitor AS T4 ON T3.competitor_id = T4.id INNER JOIN person AS T5 ON T4.person_id = T5.id WHERE person.full_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct names of sports from the 'sport' table that have been participated in by a specific person. It joins multiple tables to filter the results based on the person's full name, ensuring that only relevant sports are displayed."
        },
        {
            "sample_id": 5026,
            "vt": "SELECT games_competitor.age FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE games.games_name = '[placeholder-type:string]' AND person.full_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the ages of competitors who participated in a specific game, identified by its name, and whose full name matches a given name. It joins the 'games' table with the 'games_competitor' table to link games with their competitors, and further joins the 'person' table to filter by the competitor's full name."
        },
        {
            "sample_id": 4918,
            "vt": "SELECT noc_region.region_name FROM noc_region INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE person.full_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of regions associated with a specific person based on their full name. It joins the 'noc_region' table with the 'person_region' table to link regions to persons, and then further joins with the 'person' table to filter by the person's full name."
        },
        {
            "sample_id": 4945,
            "vt": "SELECT event.event_name FROM competitor_event INNER JOIN event AS T2 ON T1.event_id = T2.id INNER JOIN medal AS T3 ON T1.medal_id = T3.id WHERE medal.medal_name = '[placeholder-type:string]' GROUP BY event.id ORDER BY COUNT(competitor_event.event_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of events from the 'event' table that have competitors who won a specific type of medal. It joins the 'competitor_event' table to link competitors to their respective events and medals, filtering the results based on the specified medal name. The results are grouped by event to count the number of competitors and ordered by this count, limiting the output to a specified number of events."
        },
        {
            "sample_id": 4997,
            "vt": "SELECT COUNT(games_competitor.person_id) FROM competitor_event INNER JOIN games_competitor AS T2 ON T1.competitor_id = T2.id INNER JOIN event AS T3 ON T1.event_id = T3.id WHERE event.event_name LIKE '[placeholder-type:string]' AND games_competitor.age = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of competitors who participated in a specific event at the Olympics, filtered by the event name and the age of the competitors."
        },
        {
            "sample_id": 4973,
            "vt": "SELECT COUNT(games_competitor.person_id) FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE games.games_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of competitors who participated in a specific game from the 'games' table. It joins the 'games' table with the 'games_competitor' table to link each game with its competitors. The placeholder in the WHERE clause represents the name of the game for which the count of competitors is being requested."
        },
        {
            "sample_id": 4928,
            "vt": "SELECT city.city_name FROM games_city INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id WHERE games.games_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of cities that hosted specific Olympic games. It retrieves the city names from the 'city' table by joining it with the 'games_city' table, which links cities to games. The query filters the results based on the name of the game, represented by a placeholder for string values."
        },
        {
            "sample_id": 4986,
            "vt": "SELECT COUNT(person_region.person_id) FROM noc_region INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE noc_region.region_name = '[placeholder-type:string]' AND person.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of persons from a specific region who belong to a specified gender. It joins the 'noc_region' table with the 'person_region' table to link persons to their respective regions, and then further joins with the 'person' table to filter by gender. The placeholders represent the region name and gender of interest."
        },
        {
            "sample_id": 5049,
            "vt": "SELECT person.full_name FROM person INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id ORDER BY games_competitor.age LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the full names of individuals who have participated in Olympic games, retrieved from the 'person' table. It joins with the 'games_competitor' table to associate each person with their participation details, specifically focusing on their age during participation. The results are ordered by age and limited to a specified number of entries."
        },
        {
            "sample_id": 4933,
            "vt": "SELECT sport.sport_name FROM sport INNER JOIN event AS T2 ON T1.id = T2.sport_id GROUP BY sport.sport_name ORDER BY COUNT(event.event_name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of sports from the 'sport' table, which are associated with various events. It uses an inner join to connect the 'sport' table with the 'event' table based on the sport's ID. The results are grouped by sport name to count the number of events for each sport, and the output is ordered by the count of events in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of sports to display."
        },
        {
            "sample_id": 4939,
            "vt": "SELECT CAST(person.weight AS FLOAT) / (person.height * person.height) FROM person INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id WHERE games_competitor.id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the Body Mass Index (BMI) of competitors by dividing their weight (in kg) by the square of their height (in meters). It retrieves the weight and height from the 'person' table and joins it with the 'games_competitor' table to filter for a specific competitor using a placeholder for the competitor's ID."
        },
        {
            "sample_id": 4989,
            "vt": "SELECT COUNT(person_region.person_id) FROM person_region WHERE person_region.region_id = (SELECT person_region.region_id FROM person_region AS T1 INNER JOIN person AS T2 ON T1.person_id = T2.id WHERE T2.full_name = 'Clara Hughes')",
            "ba": "The virtual table counts the number of participants from a specific region in the Olympic games, based on the full name of a person. It retrieves the region ID associated with the person's name and then counts how many individuals belong to that region."
        },
        {
            "sample_id": 5017,
            "vt": "SELECT CAST(COUNT(CASE WHEN person.height > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(person_region.person_id) FROM noc_region INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE noc_region.region_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average height of individuals from a specific region by counting those who exceed a certain height and normalizing it against the total number of individuals in that region. The placeholders represent the height threshold and the region name."
        },
        {
            "sample_id": 4993,
            "vt": "SELECT COUNT(games_city.games_id) FROM games_city INNER JOIN city AS T2 ON T1.city_id = T2.id WHERE city.city_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of games held in a specific city from the 'games_city' table. It joins the 'games_city' table with the 'city' table to filter the results based on the city's name provided as a placeholder."
        },
        {
            "sample_id": 5012,
            "vt": "SELECT COUNT(event.event_name) FROM sport INNER JOIN event AS T2 ON T1.id = T2.sport_id WHERE sport.sport_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of events associated with a specific sport from the 'sport' and 'event' tables. The placeholder in the WHERE clause represents the name of the sport for which the event count is being queried."
        },
        {
            "sample_id": 4963,
            "vt": "SELECT games.games_name FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE person.gender = '[placeholder-type:string]' GROUP BY games.games_name ORDER BY COUNT(games_competitor.person_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of games from the 'games' table that were participated in by competitors of a specific gender. It joins the 'games' table with the 'games_competitor' table to link games with their competitors, and then further joins with the 'person' table to filter based on the gender of the competitors. The results are grouped by game names and ordered by the count of competitors participating in each game, with a limit on the number of results returned."
        },
        {
            "sample_id": 4959,
            "vt": "SELECT person.full_name FROM person INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id INNER JOIN competitor_event AS T3 ON T2.id = T3.competitor_id INNER JOIN medal AS T4 ON T3.medal_id = T4.id WHERE medal.id <> [placeholder-type:numeric] GROUP BY person.full_name ORDER BY COUNT(medal.id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the full names of persons who have participated in Olympic games and have won medals, excluding a specific medal type. The results are grouped by the person's full name and ordered by the count of medals won, with a limit on the number of results returned."
        },
        {
            "sample_id": 5058,
            "vt": "SELECT person.full_name FROM noc_region INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE noc_region.region_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the full names of persons from the 'person' table who belong to a specific region identified by the NOC code. The query joins the 'noc_region' table with the 'person_region' table to filter persons based on their associated region, and it uses a placeholder for the region's name in the WHERE clause."
        },
        {
            "sample_id": 4953,
            "vt": "SELECT COUNT(competitor_event.event_id), CAST(COUNT(CASE WHEN medal.id = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(medal.id) FROM person INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id INNER JOIN competitor_event AS T3 ON T2.id = T3.competitor_id INNER JOIN medal AS T4 ON T3.medal_id = T4.id WHERE person.full_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of competitors who participated in events and the proportion of those who won a specific medal type based on a person's full name. The placeholders represent the medal type and a numeric value for scaling the proportion."
        },
        {
            "sample_id": 5023,
            "vt": "SELECT city.city_name FROM games_city INNER JOIN city AS T2 ON T1.city_id = T2.id GROUP BY city.city_name ORDER BY COUNT(city.city_name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of cities that have hosted Olympic games, aggregating the data to show only unique city names. The results are ordered by the number of times each city has hosted games, and the output is limited to a specified number of cities."
        },
        {
            "sample_id": 5044,
            "vt": "SELECT DISTINCT medal.medal_name FROM medal INNER JOIN competitor_event AS T2 ON T1.id = T2.medal_id WHERE competitor_event.competitor_id = [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct names of medals from the 'medal' table that have been awarded to a specific competitor in the Olympic events. The query joins the 'medal' table with the 'competitor_event' table to filter the results based on the competitor's ID, represented by a placeholder for numeric values."
        },
        {
            "sample_id": 4977,
            "vt": "SELECT noc_region.region_name FROM medal INNER JOIN competitor_event AS T2 ON T1.id = T2.medal_id INNER JOIN games_competitor AS T3 ON T2.competitor_id = T3.id INNER JOIN person_region AS T4 ON T3.person_id = T4.person_id INNER JOIN noc_region AS T5 ON T4.region_id = T5.id WHERE medal.id <> [placeholder-type:numeric] GROUP BY noc_region.region_name ORDER BY COUNT(competitor_event.competitor_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of regions from the 'noc_region' table based on the medals awarded in Olympic events. It filters out a specific medal type using a placeholder and groups the results by region name, counting the number of competitors for each region. The results are then ordered by the count of competitors and limited to a specified number of regions."
        },
        {
            "sample_id": 5033,
            "vt": "SELECT sport.sport_name FROM sport INNER JOIN event AS T2 ON T1.id = T2.sport_id WHERE event.event_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of sports from the 'sport' table that are associated with a specific event. The query uses an inner join to connect the 'sport' table with the 'event' table based on the sport's ID. The placeholder in the WHERE clause allows for filtering events by their name."
        },
        {
            "sample_id": 4930,
            "vt": "SELECT COUNT(event.event_name) FROM sport INNER JOIN event AS T2 ON T1.id = T2.sport_id WHERE sport.sport_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of events associated with a specific sport from the 'sport' and 'event' tables. The placeholder in the WHERE clause represents the name of the sport for which the event count is being queried."
        },
        {
            "sample_id": 4937,
            "vt": "SELECT person.full_name FROM person INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id WHERE games_competitor.id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the full names of individuals who participated in a specific Olympic game. It retrieves data from the 'person' table and joins it with the 'games_competitor' table to filter based on the unique identifier of the competitor. The placeholder in the WHERE clause represents the ID of the competitor."
        },
        {
            "sample_id": 4991,
            "vt": "SELECT COUNT(event.id) FROM event INNER JOIN competitor_event AS T2 ON T1.id = T2.event_id INNER JOIN games_competitor AS T3 ON T2.competitor_id = T3.id INNER JOIN person AS T4 ON T3.person_id = T4.id WHERE person.full_name = '[placeholder-type:string]' AND event.event_name LIKE '[placeholder-type:string]' AND competitor_event.medal_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of events from the 'event' table that a specific person has participated in, based on their full name and the event name. It also filters the results to include only those competitors who have won a specific medal, identified by its ID. The query joins multiple tables to gather the necessary information about events, competitors, and persons."
        },
        {
            "sample_id": 5047,
            "vt": "SELECT city.city_name FROM games_city INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id WHERE games.games_year = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of cities that hosted Olympic games in a specific year. It retrieves the city names from the 'city' table by joining it with the 'games_city' table, which links cities to games, and filters the results based on the year of the games using a placeholder for numeric values."
        },
        {
            "sample_id": 4921,
            "vt": "SELECT city.city_name FROM games_city INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id WHERE games.games_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of cities that hosted specific Olympic games. It retrieves the city names from the 'city' table by joining it with the 'games_city' table, which links cities to games. The query filters the results based on the name of the game, represented by a placeholder for string values."
        },
        {
            "sample_id": 5018,
            "vt": "SELECT AVG(person.weight) FROM noc_region INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE noc_region.region_name = '[placeholder-type:string]' AND person.gender = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average weight of persons from a specific region and gender. It joins the 'noc_region' table with the 'person_region' table to link persons to their respective regions, and then further joins with the 'person' table to access the weight and gender information of each person. The placeholders in the WHERE clause represent the region name and gender of interest."
        },
        {
            "sample_id": 5011,
            "vt": "SELECT COUNT(games_competitor.person_id) FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE games.games_name = '[placeholder-type:string]' AND games_competitor.age > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of competitors who participated in a specific game, filtered by the game's name and the age of the competitors. It joins the 'games' table with the 'games_competitor' table to access the relevant data."
        },
        {
            "sample_id": 5041,
            "vt": "SELECT AVG(games_competitor.age) FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE games.season = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average age of competitors who participated in games held during a specific season. It joins the 'games' table with the 'games_competitor' table to access the age of competitors associated with each game, filtering the results based on the specified season."
        },
        {
            "sample_id": 4966,
            "vt": "SELECT games.games_name FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE person.full_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of games from the 'games' table in which a specific person participated. It joins the 'games' table with the 'games_competitor' table to link games with competitors, and further joins with the 'person' table to filter results based on the full name of the person. The placeholder in the WHERE clause represents the person's full name."
        },
        {
            "sample_id": 5021,
            "vt": "SELECT COUNT(games.id) FROM games_city INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id WHERE city.city_name = '[placeholder-type:string]' AND games.season = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of games held in a specific city during a specific season. It joins the 'games_city' table with the 'city' table to filter by city name and with the 'games' table to filter by season."
        },
        {
            "sample_id": 4967,
            "vt": "SELECT COUNT(competitor_event.competitor_id) FROM competitor_event INNER JOIN event AS T2 ON T1.event_id = T2.id INNER JOIN sport AS T3 ON T2.sport_id = T3.id WHERE event.event_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of competitors who participated in a specific event from the 'competitor_event' table. It joins the 'event' table to get the event details and the 'sport' table to link the event to its corresponding sport. The placeholder in the WHERE clause represents the name of the event for which the count of competitors is being queried."
        },
        {
            "sample_id": 4913,
            "vt": "SELECT games.games_name FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE person.full_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of games from the 'games' table that a specific person has participated in. It joins the 'games' table with the 'games_competitor' table to link games with competitors, and further joins with the 'person' table to filter results based on the full name of the person. The placeholder in the WHERE clause represents the person's full name."
        },
        {
            "sample_id": 5034,
            "vt": "SELECT CAST(COUNT(CASE WHEN games_competitor.age > [placeholder-type:numeric] AND games.season = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(games_competitor.games_id) FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id",
            "ba": "The virtual table calculates the percentage of competitors who participated in a specific season of the games and were older than a certain age. It does this by counting the number of competitors who meet the age condition and dividing it by the total number of competitors for that game, then multiplying by a specified factor."
        },
        {
            "sample_id": 5069,
            "vt": "SELECT games_city.games_id FROM games_city INNER JOIN city AS T2 ON T1.city_id = T2.id WHERE city.city_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of games held in a specific city from the 'games_city' table. It joins the 'games_city' table with the 'city' table to filter the results based on the name of the city provided as a placeholder."
        },
        {
            "sample_id": 4960,
            "vt": "SELECT noc_region.region_name FROM noc_region INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE person.full_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of regions associated with a specific person based on their full name. It retrieves the region name from the 'noc_region' table by joining it with the 'person_region' table to find the corresponding region ID for the person, and then joining with the 'person' table to filter by the person's full name. The placeholder in the WHERE clause represents the full name of the person."
        },
        {
            "sample_id": 4956,
            "vt": "SELECT city.city_name FROM city WHERE city.city_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of cities from the 'city' table that match a specified pattern. The placeholder in the WHERE clause allows for flexible searching of city names based on user input."
        },
        {
            "sample_id": 4947,
            "vt": "SELECT city.city_name FROM games_city INNER JOIN city AS T2 ON T1.city_id = T2.id GROUP BY city.id HAVING COUNT(games_city.games_id) >= [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of cities that have hosted a certain number of Olympic games. It retrieves data from the 'games_city' table, which links games to their respective cities, and joins it with the 'city' table to get the city names. The results are grouped by city ID, and only those cities that have hosted a specified minimum number of games are included in the output."
        },
        {
            "sample_id": 4936,
            "vt": "SELECT person.full_name FROM person INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id GROUP BY games_competitor.person_id ORDER BY COUNT(games_competitor.person_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the full names of individuals who have participated in Olympic games, derived from the 'person' table. It joins with the 'games_competitor' table to associate each person with their participation records. The results are grouped by each person's ID to count their total participations, and the output is ordered by the number of participations in descending order. A placeholder is included to limit the number of results returned, allowing users to specify how many names they want to see."
        },
        {
            "sample_id": 4981,
            "vt": "SELECT CAST(COUNT(CASE WHEN person.gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) / COUNT(CASE WHEN person.gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE games.games_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the gender ratio of competitors in a specific Olympic game. It counts the number of male and female competitors based on their gender and divides the count of one gender by the total count of competitors in that game. The placeholders represent the gender to filter by and the name of the game."
        },
        {
            "sample_id": 4979,
            "vt": "SELECT DISTINCT medal.medal_name FROM medal INNER JOIN competitor_event AS T2 ON T1.id = T2.medal_id INNER JOIN games_competitor AS T3 ON T2.competitor_id = T3.id INNER JOIN person AS T4 ON T3.person_id = T4.id WHERE person.full_name = '[placeholder-type:string]' AND competitor_event.medal_id <> [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct names of medals won by competitors in Olympic events, excluding a specific medal type. It joins multiple tables to connect medals with competitors and their respective personal details, filtering results based on the full name of the person and excluding a specified medal ID."
        },
        {
            "sample_id": 5004,
            "vt": "SELECT city.id FROM city WHERE city.city_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier of a city from the 'city' table based on the specified city name. The placeholder in the WHERE clause represents the name of the city being queried."
        },
        {
            "sample_id": 5009,
            "vt": "SELECT COUNT(games_competitor.person_id) FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE games.games_name = '[placeholder-type:string]' AND games_competitor.age = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of competitors who participated in a specific Olympic game based on the game's name and the age of the competitors. It joins the 'games' table with the 'games_competitor' table to filter the results accordingly."
        },
        {
            "sample_id": 5080,
            "vt": "SELECT CAST(COUNT(CASE WHEN games_competitor.age = [placeholder-type:numeric] THEN [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(games_competitor.person_id) FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE games.games_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage of competitors who were of a specific age during a particular Olympic game. It does this by counting the number of competitors who match the specified age and dividing it by the total number of competitors in that game, then multiplying by a specified factor. The query joins the 'games' table with the 'games_competitor' table to filter results based on the game's name."
        },
        {
            "sample_id": 5051,
            "vt": "SELECT COUNT(person_region.person_id) FROM noc_region INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE noc_region.region_name = '[placeholder-type:string]' AND person.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of persons from a specific region who belong to a specified gender. It joins the 'noc_region' table with the 'person_region' table to link persons to their respective regions, and then further joins with the 'person' table to filter by gender. The placeholders represent the region name and gender of interest."
        },
        {
            "sample_id": 4958,
            "vt": "SELECT medal.medal_name FROM person INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id INNER JOIN competitor_event AS T3 ON T2.id = T3.competitor_id INNER JOIN medal AS T4 ON T3.medal_id = T4.id WHERE person.full_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of medals won by a specific person in the Olympic games. It joins the 'person' table to get the person's details, the 'games_competitor' table to link the person to their game participations, the 'competitor_event' table to find out the events they participated in, and finally the 'medal' table to get the names of the medals associated with those events. The placeholder in the WHERE clause represents the full name of the person whose medals are being queried."
        },
        {
            "sample_id": 5001,
            "vt": "SELECT event.id FROM event WHERE event.event_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier of an event from the 'event' table based on a specified event name. The placeholder in the WHERE clause represents the name of the event being queried."
        },
        {
            "sample_id": 4943,
            "vt": "SELECT event.event_name FROM sport INNER JOIN event AS T2 ON T1.id = T2.sport_id WHERE sport.sport_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of events from the 'event' table that are associated with a specific sport. The query joins the 'sport' table with the 'event' table to filter events based on the specified sport name."
        },
        {
            "sample_id": 4914,
            "vt": "SELECT games.games_name FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE person.full_name = '[placeholder-type:string]' AND games_competitor.age = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of games from the 'games' table that a specific person participated in, based on their full name and age. The query joins the 'games' table with the 'games_competitor' table to link games with competitors, and further joins with the 'person' table to filter by the person's full name and age."
        },
        {
            "sample_id": 4934,
            "vt": "SELECT person.full_name FROM noc_region INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE noc_region.region_name = '[placeholder-type:string]' ORDER BY person.height LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the full names of persons from the 'person' table who belong to a specific region identified by the NOC code. The query joins the 'noc_region' table with the 'person_region' table to filter persons based on their region, and it orders the results by height, limiting the number of results based on a specified numeric value."
        },
        {
            "sample_id": 4950,
            "vt": "SELECT city.city_name FROM games_city INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id ORDER BY games.games_year LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of cities that hosted Olympic games, ordered by the year of the games. The query joins the 'games_city' table with the 'city' and 'games' tables to retrieve the relevant city names based on the games held. The result is limited to a specified number of entries."
        },
        {
            "sample_id": 5037,
            "vt": "SELECT city.city_name FROM games_city INNER JOIN city AS T2 ON T1.city_id = T2.id WHERE games_city.games_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of cities that hosted a specific Olympic game. It retrieves the city names from the 'city' table by joining it with the 'games_city' table, which links games to their respective host cities. The placeholder in the WHERE clause represents the unique identifier of the game."
        },
        {
            "sample_id": 4916,
            "vt": "SELECT COUNT(person_region.person_id) FROM person_region INNER JOIN noc_region AS T2 ON T1.region_id = T2.id WHERE noc_region.region_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of persons from the 'person_region' table who belong to a specific NOC region. It joins the 'person_region' table with the 'noc_region' table to filter based on the region's name, represented by a placeholder."
        },
        {
            "sample_id": 5061,
            "vt": "SELECT games.games_name FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE person.full_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of games from the 'games' table in which a specific person participated. It joins the 'games' table with the 'games_competitor' table to link games with competitors, and further joins with the 'person' table to filter by the full name of the person. The placeholder in the WHERE clause represents the person's full name."
        },
        {
            "sample_id": 4992,
            "vt": "SELECT city.city_name FROM person INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id INNER JOIN games_city AS T3 ON T2.games_id = T3.games_id INNER JOIN city AS T4 ON T3.city_id = T4.id WHERE person.full_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of cities where a specific person participated in Olympic games. It retrieves the city names by joining the 'person', 'games_competitor', 'games_city', and 'city' tables based on their relationships. The placeholder in the WHERE clause represents the full name of the person."
        },
        {
            "sample_id": 5066,
            "vt": "SELECT person.full_name FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE games.games_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the full names of competitors who participated in a specific game from the 'games' table. The query joins the 'games' table with the 'games_competitor' table to link games with their competitors, and then it further joins with the 'person' table to retrieve the full names of those competitors. The placeholder in the WHERE clause represents the name of the game."
        },
        {
            "sample_id": 5062,
            "vt": "SELECT person.full_name FROM noc_region INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE noc_region.region_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the full names of persons from the 'person' table who belong to a specific region identified by the NOC code. The query joins the 'noc_region' table with the 'person_region' table to filter persons based on their associated region, using a placeholder for the region's name."
        },
        {
            "sample_id": 5032,
            "vt": "SELECT CAST(COUNT(CASE WHEN person.gender = '[placeholder-type:string]' AND person.height > [placeholder-type:numeric] THEN [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(games_competitor.person_id) FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE games.games_year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the percentage of competitors of a specific gender who are taller than a certain height in a given Olympic game year. It does this by counting the number of qualifying competitors and dividing it by the total number of competitors in that game year, then multiplying by a specified factor."
        },
        {
            "sample_id": 4940,
            "vt": "SELECT CAST(COUNT(CASE WHEN person.gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(person_region.person_id) FROM noc_region INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE noc_region.region_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage of participants of a specific gender from a particular region in the Olympic Games. It counts the number of participants of the specified gender and divides it by the total number of participants from that region, then multiplies by a specified factor for scaling purposes. The placeholders represent the gender, the scaling factor, and the region's name."
        },
        {
            "sample_id": 4951,
            "vt": "SELECT games.games_name FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id ORDER BY games_competitor.age LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of games from the 'games' table, specifically focusing on those games that have competitors participating in them. The results are ordered by the age of the competitors, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 5013,
            "vt": "SELECT person.full_name FROM noc_region INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE noc_region.region_name = '[placeholder-type:string]' ORDER BY person.weight LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the full names of persons from the 'person' table who belong to a specific region identified by the NOC code. The query joins the 'noc_region' table with the 'person_region' table to filter persons based on their region, and it orders the results by the weight of the persons. The placeholders represent the region's name and the limit on the number of results returned."
        },
        {
            "sample_id": 4972,
            "vt": "SELECT COUNT(games.games_year) FROM games WHERE games.games_year BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of games held within a specified range of years from the 'games' table. The placeholders represent the start and end years for filtering the results."
        },
        {
            "sample_id": 5003,
            "vt": "SELECT person.weight FROM person WHERE person.full_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the weight of a person from the 'person' table based on their full name. The placeholder in the WHERE clause represents the person's full name."
        },
        {
            "sample_id": 5070,
            "vt": "SELECT noc_region.noc, noc_region.region_name FROM noc_region INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id ORDER BY person.weight LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the NOC code and region name from the 'noc_region' table, joining it with the 'person_region' table to link each person to their respective region. It further joins with the 'person' table to access the weight of each person. The results are ordered by the weight of the person, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 5072,
            "vt": "SELECT AVG(person.weight) FROM person INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id INNER JOIN competitor_event AS T3 ON T2.id = T3.competitor_id INNER JOIN medal AS T4 ON T3.medal_id = T4.id WHERE medal.medal_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average weight of persons who have won a specific medal in Olympic events. It joins the 'person' table with the 'games_competitor' table to link persons to their competition records, then further joins with the 'competitor_event' table to access the medals won by these competitors. Finally, it filters the results based on the specified medal name."
        },
        {
            "sample_id": 5079,
            "vt": "SELECT COUNT(CASE WHEN person.weight > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE NULL END) - COUNT(CASE WHEN person.weight < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE NULL END) FROM person INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id WHERE games_competitor.age < [placeholder-type:numeric]",
            "ba": "The virtual table calculates the difference between the number of competitors whose weight is greater than a specified value and those whose weight is less than a specified value. It does this by joining the 'person' table with the 'games_competitor' table to filter competitors based on their age, using placeholders for numeric values to allow for dynamic querying."
        },
        {
            "sample_id": 4935,
            "vt": "SELECT COUNT(person_region.person_id) FROM person_region INNER JOIN noc_region AS T2 ON T1.region_id = T2.id WHERE noc_region.region_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of persons from the 'person_region' table who belong to a specific NOC region. It joins the 'person_region' table with the 'noc_region' table to filter based on the region's name, represented by a placeholder."
        },
        {
            "sample_id": 4968,
            "vt": "SELECT COUNT(DISTINCT T2.event_name) FROM sport INNER JOIN event AS T2 ON T1.id = T2.sport_id WHERE sport.sport_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct event names associated with a specific sport from the 'sport' and 'event' tables. The placeholder in the WHERE clause represents the name of the sport for which the events are being counted."
        },
        {
            "sample_id": 5052,
            "vt": "SELECT COUNT(games_competitor.person_id) FROM games_competitor INNER JOIN games_city AS T2 ON T1.games_id = T2.games_id INNER JOIN city AS T3 ON T2.city_id = T3.id WHERE city.city_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of competitors who participated in Olympic games held in a specific city. It joins the 'games_competitor' table with the 'games_city' table to link games to their respective cities, and then further joins with the 'city' table to filter by the city's name. The placeholder in the WHERE clause represents the name of the city."
        },
        {
            "sample_id": 4984,
            "vt": "SELECT COUNT(person.id) FROM sport INNER JOIN event AS T2 ON T1.id = T2.sport_id INNER JOIN competitor_event AS T3 ON T2.id = T3.event_id INNER JOIN games_competitor AS T4 ON T3.competitor_id = T4.id INNER JOIN person AS T5 ON T4.person_id = T5.id INNER JOIN games AS T6 ON T4.games_id = T6.id WHERE sport.sport_name = '[placeholder-type:string]' AND games.games_name = '[placeholder-type:string]' AND person.weight * [placeholder-type:numeric] / (person.height * person.height) BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of participants in a specific sport during a particular Olympic game, filtered by the sport's name and the game's name. Additionally, it applies a condition based on the Body Mass Index (BMI) of the participants, calculated using their weight and height, to ensure it falls within a specified range."
        },
        {
            "sample_id": 5055,
            "vt": "SELECT COUNT(games_city.games_id) FROM games_city INNER JOIN city AS T2 ON T1.city_id = T2.id WHERE city.city_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of games held in a specific city from the 'games_city' table. It joins the 'games_city' table with the 'city' table to filter the results based on the city's name. The placeholder in the WHERE clause represents the name of the city for which the count of games is requested."
        },
        {
            "sample_id": 5046,
            "vt": "SELECT person.full_name FROM person ORDER BY person.weight LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the full names of individuals from the 'person' table, ordered by their weight. The placeholder in the LIMIT clause allows for specifying the maximum number of names to retrieve."
        },
        {
            "sample_id": 4915,
            "vt": "SELECT games_competitor.age FROM games INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE person.full_name = '[placeholder-type:string]' AND games.games_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the ages of competitors from the 'games_competitor' table who participated in a specific game. It joins the 'games' table to filter by the game's name and the 'person' table to filter by the competitor's full name. The placeholders represent the full name of the person and the name of the game."
        },
        {
            "sample_id": 5053,
            "vt": "SELECT COUNT(event.event_name) FROM sport INNER JOIN event AS T2 ON T1.id = T2.sport_id WHERE sport.sport_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of events associated with a specific sport from the 'sport' and 'event' tables. The placeholder in the WHERE clause represents the name of the sport for which the event count is being queried."
        },
        {
            "sample_id": 4927,
            "vt": "SELECT sport.sport_name FROM sport INNER JOIN event AS T2 ON T1.id = T2.sport_id WHERE event.event_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of sports from the 'sport' table that are associated with a specific event. The query uses an INNER JOIN to connect the 'sport' table with the 'event' table based on the sport's ID. The placeholder in the WHERE clause allows for filtering events by their name."
        },
        {
            "sample_id": 4964,
            "vt": "SELECT COUNT(person_region.person_id) FROM noc_region INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE noc_region.region_name = '[placeholder-type:string]' AND person.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of persons from a specific region and gender who have participated in the Olympics. It joins the 'noc_region' table with the 'person_region' table to filter by region, and then further joins with the 'person' table to filter by gender. The placeholders represent the region name and gender of the persons."
        },
        {
            "sample_id": 4944,
            "vt": "SELECT COUNT(person.id) FROM person INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id INNER JOIN competitor_event AS T3 ON T2.id = T3.competitor_id INNER JOIN medal AS T4 ON T3.medal_id = T4.id WHERE person.full_name = '[placeholder-type:string]' AND medal.medal_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of participants from the 'person' table who have won a specific medal in the Olympics. It joins the 'games_competitor' table to link participants to their respective games, the 'competitor_event' table to associate competitors with events, and the 'medal' table to filter by the type of medal won. The placeholders represent the full name of the person and the name of the medal they won."
        },
        {
            "sample_id": 4922,
            "vt": "SELECT games.games_name FROM games_city INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id WHERE city.city_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of games held in a specific city. It retrieves the game names from the 'games' table by joining it with the 'games_city' table, which links games to their respective cities. The query filters results based on the specified city name."
        }
    ],
    "student_loan": [
        {
            "sample_id": 4500,
            "vt": "SELECT COUNT(enrolled.name) FROM enrolled WHERE enrolled.school = '[placeholder-type:string]' AND enrolled.month = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students enrolled in a specific school during a particular month. The placeholders represent the school name and the month of enrollment."
        },
        {
            "sample_id": 4471,
            "vt": "SELECT no_payment_due.name FROM no_payment_due INNER JOIN enlist AS T2 ON T2.name = T1.name WHERE no_payment_due.bool = '[placeholder-type:string]' AND enlist.organ = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of students who have a specific payment status and are enlisted in a particular organization. It combines data from the 'no_payment_due' table, which indicates whether students have payment dues, and the 'enlist' table, which contains information about the organizations that students are enlisted in. The placeholders in the WHERE clause allow users to specify the payment status and organization, while the LIMIT clause restricts the number of results returned."
        },
        {
            "sample_id": 4491,
            "vt": "SELECT CASE WHEN male.name IS NULL THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END, enrolled.school FROM enrolled LEFT JOIN male AS T2 ON T2.name = T1.name WHERE enrolled.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about a student's enrollment status and gender. It checks if the student is male or female by using a LEFT JOIN on the 'male' table. If the student's name is found in the 'male' table, it indicates that the student is male; otherwise, it indicates that the student is female. The query also retrieves the school the student is enrolled in."
        },
        {
            "sample_id": 4506,
            "vt": "SELECT (SELECT T1.name, COUNT(T1.organ) AS num FROM enlist AS T1 INNER JOIN enrolled AS T2 ON T1.name = T2.name GROUP BY T1.name).name FROM (SELECT enlist.name, COUNT(enlist.organ) FROM enlist AS T1 INNER JOIN enrolled AS T2 ON T1.name = T2.name GROUP BY T1.name) AS t WHERE (SELECT T1.name, COUNT(T1.organ) AS num FROM enlist AS T1 INNER JOIN enrolled AS T2 ON T1.name = T2.name GROUP BY T1.name).num = [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of names of students who have enlisted in organizations and are also enrolled in school, filtered by the number of organizations they have enlisted in. The placeholder in the WHERE clause represents the specific count of organizations that the students must have enlisted in."
        },
        {
            "sample_id": 4457,
            "vt": "SELECT disabled.name FROM disabled INNER JOIN male AS T2 ON T1.name <> T2.name",
            "ba": "The virtual table retrieves the names of disabled students who are not male from the 'disabled' table by performing an inner join with the 'male' table. The join condition ensures that only those disabled students whose names do not match any male student's name are selected."
        },
        {
            "sample_id": 4474,
            "vt": "SELECT COUNT(no_payment_due.name) FROM no_payment_due INNER JOIN unemployed AS T2 ON T2.name = T1.name WHERE no_payment_due.bool = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students who have a specific payment due status and are also unemployed. It combines data from the 'no_payment_due' table, which indicates whether students have payment dues, with the 'unemployed' table to filter for students who are unemployed. The placeholder in the WHERE clause represents the payment due status, which can be either 'neg' for no payment due or 'pos' for having payment due."
        },
        {
            "sample_id": 4472,
            "vt": "SELECT COUNT(enlist.name) FROM enlist WHERE enlist.organ = '[placeholder-type:string]' AND NOT enlist.name IN (SELECT enlist.name FROM male)",
            "ba": "The virtual table counts the number of enlisted students from the 'enlist' table who are part of a specific organization and are not male. The placeholder in the WHERE clause represents the organization's name."
        },
        {
            "sample_id": 4433,
            "vt": "SELECT unemployed.name FROM unemployed INNER JOIN enlist AS T2 ON T1.name = T2.name WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of unemployed students who are also enlisted in a specific organization. It retrieves data from the 'unemployed' table and joins it with the 'enlist' table to filter based on the organization name provided as a placeholder."
        },
        {
            "sample_id": 4537,
            "vt": "SELECT COUNT(longest_absense_from_school.name) FROM longest_absense_from_school WHERE longest_absense_from_school.month > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students who have been absent from school for more than a specified duration. It retrieves data from the 'longest_absense_from_school' table, filtering based on the absence duration using a numeric placeholder."
        },
        {
            "sample_id": 4515,
            "vt": "SELECT AVG(longest_absense_from_school.month) FROM unemployed INNER JOIN longest_absense_from_school AS T2 ON T2.name = T1.name INNER JOIN male AS T3 ON T3.name = T2.name",
            "ba": "The virtual table calculates the average duration of absence from school for male students who are unemployed. It combines data from the 'unemployed' table, the 'longest_absense_from_school' table, and the 'male' table using inner joins to ensure that only those students who meet all criteria are included in the calculation."
        },
        {
            "sample_id": 4393,
            "vt": "SELECT no_payment_due.name FROM no_payment_due INNER JOIN person AS T2 ON T1.\"name\" = T2.\"name\" WHERE NOT person.\"name\" IN (SELECT person.name FROM male) AND no_payment_due.bool = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of students who do not have payment dues from the 'no_payment_due' table. It filters out male students by performing an inner join with the 'person' table and excluding names that are present in the 'male' table. Additionally, it checks the payment status using a placeholder for the boolean value indicating whether the student has payment dues or not."
        },
        {
            "sample_id": 4411,
            "vt": "SELECT COUNT(unemployed.name) FROM unemployed INNER JOIN filed_for_bankrupcy AS T2 ON T1.name = T2.name INNER JOIN no_payment_due AS T3 ON T2.name = T3.name WHERE no_payment_due.bool = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students who are unemployed, have filed for bankruptcy, and have a specific payment due status. It combines data from the 'unemployed', 'filed_for_bankrupcy', and 'no_payment_due' tables using inner joins to ensure that only students meeting all criteria are included in the count. The placeholder in the WHERE clause represents the payment due status, indicating whether the student has payment dues or not."
        },
        {
            "sample_id": 4518,
            "vt": "SELECT CAST(SUM(CASE WHEN longest_absense_from_school.month = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(unemployed.name) FROM unemployed INNER JOIN longest_absense_from_school AS T2 ON T2.name = T1.name",
            "ba": "The virtual table calculates a weighted average of the duration of absence from school for unemployed students. It sums the values based on a condition related to the absence month and divides it by the count of unemployed students, providing insights into the relationship between unemployment and school absence."
        },
        {
            "sample_id": 4397,
            "vt": "SELECT COUNT(no_payment_due.name) FROM no_payment_due INNER JOIN male AS T2 ON T1.name = T2.name WHERE no_payment_due.bool = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of male students from the 'no_payment_due' table based on their payment status. The placeholder in the WHERE clause indicates whether the students have payment dues or not."
        },
        {
            "sample_id": 4509,
            "vt": "SELECT COUNT(disabled.name) FROM disabled INNER JOIN unemployed AS T2 ON T2.name = T1.name",
            "ba": "The virtual table counts the number of disabled students who are also unemployed. It does this by joining the 'disabled' table with the 'unemployed' table on the student's name, ensuring that only those students who appear in both tables are counted."
        },
        {
            "sample_id": 4381,
            "vt": "SELECT enlist.organ, COUNT(disabled.name) FROM disabled INNER JOIN enlist AS T2 ON T1.\"name\" = T2.\"name\" GROUP BY enlist.organ ORDER BY COUNT(disabled.name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of disabled students grouped by the organization they are enlisted in. It combines data from the 'disabled' and 'enlist' tables, where the names of students in both tables match. The result is ordered by the count of disabled students in each organization, and a limit can be applied to restrict the number of results returned."
        },
        {
            "sample_id": 4507,
            "vt": "SELECT CAST(((SUM(CASE WHEN longest_absense_from_school.month = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN longest_absense_from_school.month = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END))) AS FLOAT) * [placeholder-type:numeric] / SUM(CASE WHEN longest_absense_from_school.month = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM longest_absense_from_school",
            "ba": "The virtual table calculates a specific ratio based on the total number of months of absence recorded for students in the 'longest_absense_from_school' table. It uses conditional aggregation to sum the months of absence based on certain criteria, and then applies a mathematical operation to derive a float value representing the ratio of absences. The placeholders represent numeric values that can be modified to specify the conditions for the calculations."
        },
        {
            "sample_id": 4419,
            "vt": "SELECT AVG(longest_absense_from_school.month) FROM longest_absense_from_school",
            "ba": "The virtual table calculates the average duration of absence from school for students listed in the 'longest_absense_from_school' table. The placeholder in the SELECT statement represents the month of absence, which is being averaged."
        },
        {
            "sample_id": 4569,
            "vt": "SELECT COUNT(longest_absense_from_school.name) FROM longest_absense_from_school INNER JOIN disabled AS T2 ON T1.name = T2.name INNER JOIN unemployed AS T3 ON T3.name = T2.name WHERE longest_absense_from_school.month = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of disabled students who have been absent from school for a specified duration. It joins the 'longest_absense_from_school' table with the 'disabled' and 'unemployed' tables to filter the results based on the absence duration provided as a placeholder."
        },
        {
            "sample_id": 4530,
            "vt": "SELECT COUNT(enlist.name) FROM enlist WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students who have enlisted in a specific organization from the 'enlist' table. The placeholder in the WHERE clause represents the name of the organization."
        },
        {
            "sample_id": 4497,
            "vt": "SELECT enlist.name FROM enlist INNER JOIN male AS T2 ON T2.name = T1.name WHERE enlist.organ = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of male students who are enlisted in a specific organization. The query joins the 'enlist' table with the 'male' table to filter for male students and applies a condition to specify the organization they are enlisted in. The placeholders allow for dynamic input of the organization name and the limit on the number of results returned."
        },
        {
            "sample_id": 4451,
            "vt": "SELECT longest_absense_from_school.name FROM male INNER JOIN longest_absense_from_school AS T2 ON T1.name <> T2.name WHERE longest_absense_from_school.month = [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of male students who have been absent from school for a specified duration, excluding those who have the same name as the male students. The query uses an inner join to connect the 'male' and 'longest_absense_from_school' tables, filtering based on the absence duration."
        },
        {
            "sample_id": 4453,
            "vt": "SELECT enlist.organ FROM filed_for_bankrupcy INNER JOIN enlist AS T2 ON T1.name = T2.name",
            "ba": "The virtual table retrieves the organizations that students who have filed for bankruptcy are enlisted in. It does this by joining the 'filed_for_bankrupcy' table with the 'enlist' table on the student names, allowing us to see which organizations these students are associated with."
        },
        {
            "sample_id": 4398,
            "vt": "SELECT longest_absense_from_school.name FROM longest_absense_from_school INNER JOIN enlist AS T2 ON T1.\"name\" = T2.\"name\" WHERE enlist.organ = '[placeholder-type:string]' AND longest_absense_from_school.\"month\" = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of students who have been absent from school for a specified duration and are enlisted in a specific organization. The placeholders represent the organization name and the duration of absence in months."
        },
        {
            "sample_id": 4447,
            "vt": "SELECT AVG(longest_absense_from_school.month) FROM longest_absense_from_school",
            "ba": "The virtual table calculates the average duration of absence from school for students listed in the 'longest_absense_from_school' table. The placeholder in the SELECT statement represents the month of absence, which is averaged across all entries."
        },
        {
            "sample_id": 4445,
            "vt": "SELECT longest_absense_from_school.name FROM longest_absense_from_school WHERE longest_absense_from_school.month = (SELECT MAX(longest_absense_from_school.month) FROM longest_absense_from_school)",
            "ba": "The virtual table identifies the names of students who have the longest absence from school based on the maximum duration of absence recorded in the 'longest_absense_from_school' table. The query uses a subquery to find the maximum month value, which represents the longest absence, and filters the results accordingly."
        },
        {
            "sample_id": 4547,
            "vt": "SELECT longest_absense_from_school.month FROM longest_absense_from_school INNER JOIN enlist AS T2 ON T1.name = T2.name WHERE enlist.organ = '[placeholder-type:string]' ORDER BY longest_absense_from_school.month LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the duration of absence from school for students who are enlisted in a specific organization. It joins the 'longest_absense_from_school' table with the 'enlist' table based on the student's name, filtering the results to only include those who are part of the specified organization. The results are ordered by the duration of absence and limited to a specified number of entries."
        },
        {
            "sample_id": 4380,
            "vt": "SELECT enlist.organ FROM longest_absense_from_school INNER JOIN enlist AS T2 ON T1.\"name\" = T2.\"name\" WHERE longest_absense_from_school.\"month\" = [placeholder-type:numeric]",
            "ba": "The virtual table describes the organizations that students enlisted in, filtered by those who have had a specific duration of absence from school. The placeholder in the WHERE clause represents the number of months of absence."
        },
        {
            "sample_id": 4558,
            "vt": "SELECT COUNT(longest_absense_from_school.name) FROM longest_absense_from_school WHERE longest_absense_from_school.month < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students who have been absent from school for a duration less than a specified number of months. It retrieves data from the 'longest_absense_from_school' table, filtering based on the 'month' column using a numeric placeholder."
        },
        {
            "sample_id": 4470,
            "vt": "SELECT COUNT(unemployed.name) FROM longest_absense_from_school INNER JOIN unemployed AS T2 ON T2.name = T1.name WHERE longest_absense_from_school.month = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of unemployed students who have been absent from school for a specified duration. It joins the 'longest_absense_from_school' table with the 'unemployed' table based on the student's name, filtering the results by the duration of absence using a numeric placeholder."
        },
        {
            "sample_id": 4462,
            "vt": "SELECT COUNT(enrolled.name) FROM enrolled WHERE enrolled.school = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students enrolled in a specific school from the 'enrolled' table. The placeholder in the WHERE clause represents the name of the school."
        },
        {
            "sample_id": 4476,
            "vt": "SELECT COUNT(disabled.name) FROM disabled WHERE NOT disabled.name IN (SELECT disabled.name FROM male)",
            "ba": "The virtual table counts the number of disabled students who are not male. It filters the 'disabled' table to exclude any names that are present in the 'male' table, ensuring that only female disabled students are counted."
        },
        {
            "sample_id": 4552,
            "vt": "SELECT CAST(SUM(CASE WHEN enrolled.school = '[placeholder-type:string]' AND male.name IS NULL THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / COUNT(enrolled.name) FROM enrolled INNER JOIN disabled AS T2 ON T1.name = T2.name INNER JOIN person AS T3 ON T1.name = T3.name LEFT JOIN male AS T4 ON T3.name = T4.name",
            "ba": "The virtual table calculates the ratio of enrolled students who are not male and are disabled, relative to the total number of enrolled students in a specific school. The placeholders represent the school name and numeric values for the calculations."
        },
        {
            "sample_id": 4495,
            "vt": "SELECT COUNT(no_payment_due.name) FROM no_payment_due INNER JOIN unemployed AS T2 ON T2.name = T1.name WHERE no_payment_due.bool = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students who have a specific payment due status and are also unemployed. It retrieves data from the 'no_payment_due' table and joins it with the 'unemployed' table based on the student's name. The placeholder in the WHERE clause represents the payment due status, indicating whether students have payment dues or not."
        },
        {
            "sample_id": 4493,
            "vt": "SELECT COUNT(unemployed.name) FROM unemployed INNER JOIN filed_for_bankrupcy AS T2 ON T2.name = T1.name",
            "ba": "The virtual table counts the number of students who are unemployed and have filed for bankruptcy. It does this by joining the 'unemployed' table with the 'filed_for_bankrupcy' table on the student's name, ensuring that only those students who meet both criteria are included in the count."
        },
        {
            "sample_id": 4475,
            "vt": "SELECT no_payment_due.name FROM no_payment_due INNER JOIN enlist AS T2 ON T2.name = T1.name WHERE enlist.organ = '[placeholder-type:string]' AND no_payment_due.bool = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of students who have a specific payment status and are enlisted in a particular organization. It combines data from the 'no_payment_due' table, which indicates whether students have payment dues, and the 'enlist' table, which contains information about the organizations that students are enlisted in. The placeholders in the WHERE clause represent the organization name and the payment status, allowing users to filter results based on these criteria."
        },
        {
            "sample_id": 4513,
            "vt": "SELECT enrolled.school, enlist.organ FROM enlist INNER JOIN enrolled AS T2 ON T2.name = T1.name WHERE enlist.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the schools and organizations of students who are enlisted in a specific organization. It combines data from the 'enlist' and 'enrolled' tables based on the student's name."
        },
        {
            "sample_id": 4468,
            "vt": "SELECT COUNT(unemployed.name) FROM unemployed INNER JOIN no_payment_due AS T2 ON T1.name = T2.name WHERE no_payment_due.bool = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of unemployed students from the 'unemployed' table who also have a specified payment status from the 'no_payment_due' table. The placeholder in the WHERE clause represents whether the student has payment dues or not."
        },
        {
            "sample_id": 4529,
            "vt": "SELECT [placeholder-type:numeric] * SUM(CASE WHEN longest_absense_from_school.month = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM disabled INNER JOIN longest_absense_from_school AS T2 ON T1.name = T2.name",
            "ba": "The virtual table calculates a weighted sum based on the duration of absence from school for disabled students. It uses a conditional statement to determine the contribution to the sum based on the specified month of absence, with placeholders for numeric values representing the weights and the month."
        },
        {
            "sample_id": 4501,
            "vt": "SELECT COUNT(enlist.name) FROM enlist WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students who are enlisted in a specific organization from the 'enlist' table. The placeholder in the WHERE clause represents the name of the organization."
        },
        {
            "sample_id": 4391,
            "vt": "SELECT disabled.name, enrolled.school FROM enrolled INNER JOIN disabled AS T2 ON T1.\"name\" = T2.\"name\" WHERE enrolled.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of disabled students along with the schools they are enrolled in. It combines data from the 'enrolled' and 'disabled' tables using an inner join on the 'name' column, ensuring that only those students who are both disabled and enrolled are included. The placeholder in the WHERE clause represents the specific student's name being queried."
        },
        {
            "sample_id": 4454,
            "vt": "SELECT COUNT((SELECT COUNT(DISTINCT T1.name) AS a, COUNT(T2.organ) AS num FROM male AS T1 INNER JOIN enlist AS T2 ON T1.name = T2.name GROUP BY T1.name).a) FROM (SELECT COUNT(DISTINCT T1.name), COUNT(enlist.organ) FROM male AS T1 INNER JOIN enlist AS T2 ON T1.name = T2.name GROUP BY T1.name) AS t WHERE (SELECT COUNT(DISTINCT T1.name) AS a, COUNT(T2.organ) AS num FROM male AS T1 INNER JOIN enlist AS T2 ON T1.name = T2.name GROUP BY T1.name).num > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of male students who have enlisted in organizations, filtering out those who have enlisted in more than a specified number of organizations. The placeholder in the WHERE clause represents the minimum number of organizations a male student must be enlisted in to be included in the count."
        },
        {
            "sample_id": 4568,
            "vt": "SELECT COUNT(longest_absense_from_school.name) FROM longest_absense_from_school INNER JOIN filed_for_bankrupcy AS T2 ON T1.name = T2.name INNER JOIN enlist AS T3 ON T3.name = T2.name WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students who have been absent from school and have also filed for bankruptcy, filtered by the organization they enlisted in. The placeholders represent the organization name."
        },
        {
            "sample_id": 4390,
            "vt": "SELECT enlist.organ FROM enlist WHERE enlist.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the organization that a specific student has enlisted in from the 'enlist' table. The placeholder in the WHERE clause represents the student's name."
        },
        {
            "sample_id": 4409,
            "vt": "SELECT COUNT(unemployed.name) FROM unemployed INNER JOIN filed_for_bankrupcy AS T2 ON T1.name = T2.name",
            "ba": "The virtual table counts the number of students who are unemployed and have filed for bankruptcy. It combines data from the 'unemployed' table and the 'filed_for_bankrupcy' table using an inner join on the student names."
        },
        {
            "sample_id": 4564,
            "vt": "SELECT longest_absense_from_school.name FROM longest_absense_from_school INNER JOIN disabled AS T2 ON T1.name = T2.name WHERE longest_absense_from_school.month > [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of disabled students who have been absent from school for a duration greater than a specified number of months. It retrieves data from the 'longest_absense_from_school' table and joins it with the 'disabled' table to filter the results accordingly."
        },
        {
            "sample_id": 4379,
            "vt": "SELECT COUNT(longest_absense_from_school.name) FROM longest_absense_from_school INNER JOIN disabled AS T2 ON T1.\"name\" = T2.\"name\" WHERE longest_absense_from_school.\"month\" = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of disabled students who have been absent from school for a specified duration. It joins the 'longest_absense_from_school' table with the 'disabled' table to filter the results based on the absence duration provided as a placeholder."
        },
        {
            "sample_id": 4534,
            "vt": "SELECT person.name FROM person INNER JOIN filed_for_bankrupcy AS T2 ON T1.name = T2.name LEFT JOIN male AS T3 ON T1.name = T3.name WHERE male.name IS NULL",
            "ba": "The virtual table lists the names of students from the 'person' table who have filed for bankruptcy but are not male. The query uses an inner join to connect the 'person' table with the 'filed_for_bankrupcy' table based on the student's name, ensuring that only those who have filed for bankruptcy are included. Additionally, a left join is performed with the 'male' table to filter out any male students, as indicated by the condition that checks for null values in the 'male.name' column."
        },
        {
            "sample_id": 4434,
            "vt": "SELECT AVG(longest_absense_from_school.month) FROM longest_absense_from_school INNER JOIN disabled AS T2 ON T1.name = T2.name",
            "ba": "The virtual table calculates the average duration of absence from school for disabled students. It retrieves data from the 'longest_absense_from_school' table and joins it with the 'disabled' table to ensure that only disabled students are considered in the average calculation."
        },
        {
            "sample_id": 4431,
            "vt": "SELECT COUNT(enlist.name) FROM enlist WHERE enlist.organ = '[placeholder-type:string]' AND NOT enlist.name IN (SELECT enlist.name FROM male)",
            "ba": "The virtual table counts the number of enlisted students from the 'enlist' table who are part of a specific organization and are not male. The placeholder in the WHERE clause represents the name of the organization."
        },
        {
            "sample_id": 4443,
            "vt": "SELECT COUNT(disabled.name) FROM disabled",
            "ba": "The virtual table counts the number of disabled students from the 'disabled' table. This provides a total number of students who are identified as disabled."
        },
        {
            "sample_id": 4402,
            "vt": "SELECT longest_absense_from_school.month, enlist.organ FROM enlist INNER JOIN longest_absense_from_school AS T2 ON T1.\"name\" = T2.\"name\" WHERE enlist.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the duration of absence from school and the organization that a specific student is enlisted in. It combines data from the 'enlist' and 'longest_absense_from_school' tables based on the student's name."
        },
        {
            "sample_id": 4485,
            "vt": "SELECT enrolled.school, enrolled.month FROM enrolled WHERE enrolled.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the schools and months of enrollment for a specific student from the 'enrolled' table. The placeholder in the WHERE clause represents the student's name."
        },
        {
            "sample_id": 4387,
            "vt": "SELECT enrolled.school FROM enrolled WHERE enrolled.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the schools that a specific student is enrolled in from the 'enrolled' table. The placeholder in the WHERE clause represents the student's name."
        },
        {
            "sample_id": 4535,
            "vt": "SELECT no_payment_due.bool FROM no_payment_due WHERE no_payment_due.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the payment status of a specific student from the 'no_payment_due' table. The placeholder in the WHERE clause represents the student's name."
        },
        {
            "sample_id": 4543,
            "vt": "SELECT male.name FROM male INNER JOIN no_payment_due AS T2 ON T1.name = T2.name WHERE no_payment_due.bool = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of male students who have a specific payment status from the 'no_payment_due' table. The query uses an inner join to combine data from the 'male' and 'no_payment_due' tables based on the student's name, filtering the results based on whether the student has payment dues or not."
        },
        {
            "sample_id": 4502,
            "vt": "SELECT enlist.organ FROM enlist WHERE enlist.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the organization that a specific student has enlisted in from the 'enlist' table. The placeholder in the WHERE clause represents the student's name."
        },
        {
            "sample_id": 4560,
            "vt": "SELECT SUM(CASE WHEN male.name IS NULL THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM enlist INNER JOIN person AS T2 ON T1.name = T2.name LEFT JOIN male AS T3 ON T2.name = T3.name WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of enlisted students from a specific organization, distinguishing between male and female students. It uses a conditional sum to count the number of students based on their gender, where the presence of a name in the 'male' table indicates a male student. The placeholder in the WHERE clause represents the organization name for which the count is being calculated."
        },
        {
            "sample_id": 4417,
            "vt": "SELECT COUNT(person.name) FROM person WHERE NOT person.name IN (SELECT person.name FROM male) AND NOT person.name IN (SELECT person.name FROM enrolled)",
            "ba": "The virtual table counts the number of students from the 'person' table who are not male and are not enrolled in any school. The query uses subqueries to filter out names of male students and those who are enrolled, ensuring that only female students who are unemployed are counted."
        },
        {
            "sample_id": 4388,
            "vt": "SELECT longest_absense_from_school.month FROM longest_absense_from_school WHERE longest_absense_from_school.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the duration of absence from school for a specific student from the 'longest_absense_from_school' table. The placeholder in the WHERE clause represents the student's name."
        },
        {
            "sample_id": 4466,
            "vt": "SELECT COUNT(male.name) FROM male INNER JOIN no_payment_due AS T2 ON T1.name = T2.name WHERE no_payment_due.bool = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of male students from the 'male' table who do not have payment dues, as indicated by the 'no_payment_due' table. The placeholder in the WHERE clause represents the status of payment dues, which can either indicate that the student has or does not have payment dues."
        },
        {
            "sample_id": 4510,
            "vt": "SELECT enlist.name FROM enlist INNER JOIN enrolled AS T2 ON T2.name = T1.name WHERE enrolled.school = '[placeholder-type:string]' AND enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of students who are enlisted in a specific organization and are enrolled in a particular school. The placeholders in the WHERE clause represent the school name and the organization name."
        },
        {
            "sample_id": 4540,
            "vt": "SELECT COUNT(filed_for_bankrupcy.name) FROM filed_for_bankrupcy INNER JOIN enrolled AS T2 ON T1.name = T2.name WHERE enrolled.school = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students who have filed for bankruptcy and are currently enrolled in a specific school. The query uses an INNER JOIN to connect the 'filed_for_bankrupcy' table with the 'enrolled' table based on the student's name. The placeholder in the WHERE clause represents the name of the school."
        },
        {
            "sample_id": 4372,
            "vt": "SELECT enlist.name FROM enlist INNER JOIN male AS T2 ON T1.\"name\" = T2.\"name\" WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of enlisted male students from the 'enlist' table who are part of a specific organization. The placeholder in the WHERE clause represents the organization's name."
        },
        {
            "sample_id": 4396,
            "vt": "SELECT filed_for_bankrupcy.name FROM enlist INNER JOIN filed_for_bankrupcy AS T2 ON T1.\"name\" = T2.\"name\" WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of students who have filed for bankruptcy and are also enlisted in a specific organization. It uses an inner join between the 'enlist' and 'filed_for_bankrupcy' tables based on the student's name, ensuring that only those students who meet both criteria are selected. The placeholder in the WHERE clause represents the organization name."
        },
        {
            "sample_id": 4439,
            "vt": "SELECT COUNT(longest_absense_from_school.name) FROM longest_absense_from_school INNER JOIN disabled AS T2 ON T1.name = T2.name WHERE longest_absense_from_school.month = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of disabled students who have been absent from school for a specified duration. It joins the 'longest_absense_from_school' table with the 'disabled' table to filter the results based on the absence duration provided as a placeholder."
        },
        {
            "sample_id": 4438,
            "vt": "SELECT longest_absense_from_school.name FROM longest_absense_from_school INNER JOIN unemployed AS T2 ON T1.name = T2.name WHERE longest_absense_from_school.month = [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of students who have been absent from school for a specified duration and are also unemployed. It retrieves data from the 'longest_absense_from_school' table and joins it with the 'unemployed' table based on the student's name. The placeholder in the WHERE clause represents the duration of absence in months."
        },
        {
            "sample_id": 4489,
            "vt": "SELECT enlist.name FROM enlist LEFT JOIN male AS T2 ON T2.name = T1.name WHERE male.name IS NULL AND enlist.organ = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of students who are enlisted in a specific organization but are not male. It uses a LEFT JOIN to connect the 'enlist' table with the 'male' table, filtering out any students who are male. The placeholders allow for specifying the organization and limiting the number of results returned."
        },
        {
            "sample_id": 4479,
            "vt": "SELECT CAST(SUM(CASE WHEN male.name IS NULL THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(enlist.name), CAST(SUM(CASE WHEN NOT male.name IS NULL THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(enlist.name) FROM enlist LEFT JOIN male AS T2 ON T2.name = T1.name WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the ratio of male and female students who are enlisted in a specific organization. It uses a LEFT JOIN to combine data from the 'enlist' and 'male' tables, allowing for the identification of male students. The query sums up the counts of male and female students separately, applying a multiplier and dividing by the total count of enlisted students. The placeholder in the WHERE clause represents the organization name."
        },
        {
            "sample_id": 4422,
            "vt": "SELECT enlist.organ FROM enlist WHERE enlist.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the organization that a specific student has enlisted in from the 'enlist' table. The placeholder in the WHERE clause represents the student's name."
        },
        {
            "sample_id": 4368,
            "vt": "SELECT COUNT(longest_absense_from_school.name) FROM longest_absense_from_school WHERE longest_absense_from_school.\"month\" = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students who have been absent from school for a specified duration. It retrieves data from the 'longest_absense_from_school' table, filtering based on the absence duration provided as a numeric placeholder."
        },
        {
            "sample_id": 4542,
            "vt": "SELECT enlist.name FROM enlist INNER JOIN disabled AS T2 ON T1.name = T2.name WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of students who are enlisted in a specific organization and are also identified as disabled. The query uses an INNER JOIN to combine data from the 'enlist' and 'disabled' tables based on the student's name, ensuring that only those students who meet both criteria are selected. The placeholder in the WHERE clause represents the name of the organization."
        },
        {
            "sample_id": 4548,
            "vt": "SELECT COUNT(longest_absense_from_school.name) FROM longest_absense_from_school INNER JOIN enlist AS T2 ON T1.name = T2.name WHERE longest_absense_from_school.month = [placeholder-type:numeric] AND enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students who have been absent for a specified duration and are enlisted in a specific organization. It combines data from the 'longest_absense_from_school' and 'enlist' tables using an inner join on the student's name, filtering by the absence duration and the organization name."
        },
        {
            "sample_id": 4503,
            "vt": "SELECT COUNT(disabled.name) FROM disabled LEFT JOIN male AS T2 ON T2.name = T1.name INNER JOIN enlist AS T3 ON T3.name = T2.name",
            "ba": "The virtual table counts the number of disabled students who are male and have enlisted in an organization. It combines data from the 'disabled', 'male', and 'enlist' tables using LEFT JOIN and INNER JOIN to ensure that only those students who meet all criteria are included in the count."
        },
        {
            "sample_id": 4541,
            "vt": "SELECT COUNT(male.name) FROM male INNER JOIN disabled AS T2 ON T1.name = T2.name",
            "ba": "The virtual table counts the number of male students who are also disabled. It does this by joining the 'male' table with the 'disabled' table on the student's name, ensuring that only those students who are present in both tables are counted."
        },
        {
            "sample_id": 4371,
            "vt": "SELECT COUNT(longest_absense_from_school.name) FROM longest_absense_from_school INNER JOIN male AS T2 ON T1.\"name\" = T2.\"name\" WHERE longest_absense_from_school.\"month\" >= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of male students who have been absent from school for a specified duration or longer. It does this by joining the 'longest_absense_from_school' table with the 'male' table on the student's name, and filtering the results based on the absence duration using a numeric placeholder."
        },
        {
            "sample_id": 4424,
            "vt": "SELECT COUNT(longest_absense_from_school.name) FROM longest_absense_from_school WHERE longest_absense_from_school.month = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students who have been absent from school for a specified duration. It retrieves data from the 'longest_absense_from_school' table, filtering based on the absence duration provided as a numeric placeholder."
        },
        {
            "sample_id": 4455,
            "vt": "SELECT disabled.name FROM disabled INNER JOIN enlist AS T2 ON T1.name = T2.name WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of disabled students who are also enlisted in a specific organization. It uses an inner join between the 'disabled' and 'enlist' tables based on the student's name, filtering the results by the organization name provided as a placeholder."
        },
        {
            "sample_id": 4378,
            "vt": "SELECT longest_absense_from_school.month FROM longest_absense_from_school INNER JOIN enlist AS T2 ON T1.\"name\" = T2.\"name\" WHERE enlist.organ = '[placeholder-type:string]' ORDER BY longest_absense_from_school.\"month\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the duration of absence from school for students who are enlisted in a specific organization. It joins the 'longest_absense_from_school' table with the 'enlist' table based on the student's name, filtering the results to only include those who are part of the specified organization. The results are ordered by the duration of absence and limited to a specified number of entries."
        },
        {
            "sample_id": 4550,
            "vt": "SELECT COUNT(enrolled.name) FROM enrolled INNER JOIN male AS T2 ON T1.name = T2.name WHERE enrolled.school = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of male students enrolled in a specific school from the 'enrolled' table. It uses an inner join with the 'male' table to filter only male students. The placeholder in the WHERE clause represents the name of the school."
        },
        {
            "sample_id": 4482,
            "vt": "SELECT CAST(SUM(CASE WHEN no_payment_due.\"bool\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN no_payment_due.\"bool\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM no_payment_due",
            "ba": "The virtual table calculates the ratio of students with and without payment dues from the 'no_payment_due' table. It uses a conditional aggregation to sum the counts based on the payment status, represented by a placeholder for string values, and divides the total counts to get the ratio."
        },
        {
            "sample_id": 4385,
            "vt": "SELECT enlist.name FROM enlist WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of students who are enlisted in a specific organization from the 'enlist' table. The placeholder in the WHERE clause represents the name of the organization."
        },
        {
            "sample_id": 4557,
            "vt": "SELECT enlist.organ FROM (SELECT enlist.organ, COUNT(enlist.organ) FROM enlist GROUP BY organ) AS t ORDER BY (SELECT organ, COUNT(organ) AS num FROM enlist GROUP BY organ).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of organizations that students have enlisted in, ordered by the number of students in each organization. The query counts the number of students for each organization and limits the results to a specified number of organizations."
        },
        {
            "sample_id": 4463,
            "vt": "SELECT longest_absense_from_school.name FROM longest_absense_from_school ORDER BY longest_absense_from_school.month LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of students from the 'longest_absense_from_school' table, ordered by the duration of their absence. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 4484,
            "vt": "SELECT CAST(COUNT(enlist.name) AS FLOAT) * [placeholder-type:numeric] / COUNT(DISTINCT organ) FROM enlist",
            "ba": "The virtual table calculates the average number of enlisted students per organization from the 'enlist' table. It counts the total number of enlisted students and divides it by the distinct count of organizations they are enlisted in, multiplied by a placeholder for numeric values."
        },
        {
            "sample_id": 4555,
            "vt": "SELECT COUNT(enlist.name) FROM enlist WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students who have enlisted in a specific organization from the 'enlist' table. The placeholder in the WHERE clause represents the name of the organization."
        },
        {
            "sample_id": 4549,
            "vt": "SELECT male.name FROM unemployed INNER JOIN male AS T2 ON T1.name = T2.name INNER JOIN disabled AS T3 ON T3.name = T2.name",
            "ba": "The virtual table identifies male students who are unemployed and also disabled. It retrieves the names of these students by joining the 'unemployed', 'male', and 'disabled' tables based on the common 'name' field."
        },
        {
            "sample_id": 4536,
            "vt": "SELECT COUNT(enlist.name) FROM enlist WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students who have enlisted in a specific organization from the 'enlist' table. The placeholder in the WHERE clause represents the name of the organization."
        },
        {
            "sample_id": 4498,
            "vt": "SELECT CAST(SUM(CASE WHEN male.name IS NULL THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(person.name) FROM person LEFT JOIN male AS T2 ON T2.name = T1.name",
            "ba": "The virtual table calculates the percentage of female students from the total number of students in the 'person' table. It does this by summing up the count of students who are not in the 'male' table (indicating they are female) and dividing it by the total count of students. The result is then multiplied by a placeholder value to allow for further scaling or adjustment of the percentage."
        },
        {
            "sample_id": 4565,
            "vt": "SELECT COUNT(filed_for_bankrupcy.name) FROM filed_for_bankrupcy INNER JOIN enlist AS T2 ON T1.name = T2.name WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students who have filed for bankruptcy and are also enlisted in a specific organization. It uses an inner join between the 'filed_for_bankrupcy' and 'enlist' tables to ensure that only those students who are both enlisted and have filed for bankruptcy are considered. The placeholder in the WHERE clause represents the name of the organization."
        },
        {
            "sample_id": 4522,
            "vt": "SELECT COUNT(no_payment_due.name) FROM no_payment_due INNER JOIN disabled AS T2 ON T1.name = T2.name WHERE no_payment_due.bool = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of disabled students who have a specific payment status from the 'no_payment_due' table. The placeholder in the WHERE clause indicates whether the students have payment dues or not."
        },
        {
            "sample_id": 4483,
            "vt": "SELECT enrolled.name, enrolled.school FROM enrolled WHERE enrolled.month = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names and schools of students who are enrolled in a specific month from the 'enrolled' table. The placeholder in the WHERE clause represents the month of enrollment."
        },
        {
            "sample_id": 4423,
            "vt": "SELECT COUNT(enlist.name) FROM enlist WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students who have enlisted in a specific organization from the 'enlist' table. The placeholder in the WHERE clause represents the name of the organization."
        },
        {
            "sample_id": 4487,
            "vt": "SELECT COUNT(disabled.name) FROM disabled LEFT JOIN longest_absense_from_school AS T2 ON T2.name = T1.name WHERE longest_absense_from_school.month = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of disabled students who have been absent from school for a specified duration. It does this by joining the 'disabled' table with the 'longest_absense_from_school' table on the student's name, and filtering the results based on the absence duration using a numeric placeholder."
        },
        {
            "sample_id": 4376,
            "vt": "SELECT COUNT(disabled.name) FROM disabled WHERE NOT disabled.name IN (SELECT disabled.name FROM male)",
            "ba": "The virtual table counts the number of disabled students who are not male. It retrieves the names of disabled students from the 'disabled' table and filters out those who are listed in the 'male' table, ensuring that only female disabled students are counted."
        },
        {
            "sample_id": 4404,
            "vt": "SELECT CAST(SUM(CASE WHEN enrolled.school = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(enrolled.name) FROM enrolled INNER JOIN enlist AS T2 ON T1.\"name\" = T2.\"name\" WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of a specific numeric value for students enrolled in a particular school, filtered by their enlistment in a specific organization. It sums up the values based on a condition related to the school and divides it by the count of enrolled students, applying a multiplier to the result."
        },
        {
            "sample_id": 4523,
            "vt": "SELECT longest_absense_from_school.name FROM longest_absense_from_school INNER JOIN no_payment_due AS T2 ON T1.name = T2.name WHERE no_payment_due.bool = '[placeholder-type:string]' ORDER BY longest_absense_from_school.month LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of students who have been absent from school for the longest duration, filtered by their payment due status. The query joins the 'longest_absense_from_school' table with the 'no_payment_due' table to ensure that only students with a specific payment status are included. The results are ordered by the duration of absence and limited to a specified number of entries."
        },
        {
            "sample_id": 4464,
            "vt": "SELECT COUNT(enlist.name) FROM enlist WHERE enlist.organ >= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students who have enlisted in organizations that meet a certain numeric criterion. The placeholder in the WHERE clause represents the minimum number of organizations a student must be enlisted in to be included in the count."
        },
        {
            "sample_id": 4545,
            "vt": "SELECT CAST(COUNT(male.name) AS FLOAT) * [placeholder-type:numeric] / COUNT(person.name) FROM person LEFT JOIN male AS T2 ON T1.name = T2.name",
            "ba": "The virtual table calculates the percentage of male students from the total number of students in the 'person' table. It uses a LEFT JOIN to include all students from 'person' and counts the number of males from the 'male' table, multiplying this count by a placeholder numeric value to adjust the result. The final output is a ratio of male students to total students, expressed as a percentage."
        },
        {
            "sample_id": 4427,
            "vt": "SELECT COUNT(no_payment_due.name) FROM no_payment_due WHERE no_payment_due.bool = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students from the 'no_payment_due' table based on their payment status. The placeholder in the WHERE clause represents whether the students have payment dues or not."
        },
        {
            "sample_id": 4508,
            "vt": "SELECT (SELECT T1.school, COUNT(T2.name) AS num FROM enrolled AS T1 LEFT JOIN filed_for_bankrupcy AS T2 ON T2.name = T1.name GROUP BY T1.school).school, subquery_t.num FROM (SELECT enrolled.school, COUNT(filed_for_bankrupcy.name) FROM enrolled AS T1 LEFT JOIN filed_for_bankrupcy AS T2 ON T2.name = T1.name GROUP BY T1.school) AS t ORDER BY (SELECT T1.school, COUNT(T2.name) AS num FROM enrolled AS T1 LEFT JOIN filed_for_bankrupcy AS T2 ON T2.name = T1.name GROUP BY T1.school).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of schools and the number of students who have filed for bankruptcy from each school. It uses a subquery to count the number of students who filed for bankruptcy, grouped by their respective schools. The results are ordered by the count of students filing for bankruptcy, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 4456,
            "vt": "SELECT COUNT(enrolled.name) FROM enrolled INNER JOIN longest_absense_from_school AS T2 ON T1.name = T2.name WHERE enrolled.school = '[placeholder-type:string]' AND longest_absense_from_school.month = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students who are enrolled in a specific school and have a recorded duration of absence from school. It combines data from the 'enrolled' table, which contains student names and their respective schools, with the 'longest_absense_from_school' table, which tracks the duration of absence for each student. The placeholders represent the school name and the duration of absence in months."
        },
        {
            "sample_id": 4528,
            "vt": "SELECT COUNT(no_payment_due.name) FROM no_payment_due INNER JOIN enlist AS T2 ON T1.name = T2.name WHERE no_payment_due.bool = '[placeholder-type:string]' AND enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students who have or do not have payment dues and are enlisted in a specific organization. It combines data from the 'no_payment_due' table and the 'enlist' table based on the student's name, applying filters for the payment status and the organization they are enlisted in."
        },
        {
            "sample_id": 4514,
            "vt": "SELECT COUNT(male.name) - SUM(CASE WHEN male.name IS NULL THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM filed_for_bankrupcy LEFT JOIN male AS T2 ON T2.name = T1.name",
            "ba": "The virtual table calculates the number of male students who have not filed for bankruptcy by counting the total number of male students and subtracting the number of male students who have filed for bankruptcy. The query uses a LEFT JOIN to combine the 'filed_for_bankrupcy' and 'male' tables based on the student names, allowing for the identification of male students who are included in the bankruptcy records."
        },
        {
            "sample_id": 4448,
            "vt": "SELECT COUNT(enlist.name) FROM enlist WHERE enlist.organ IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table counts the number of students who are enlisted in specific organizations from the 'enlist' table. The placeholder in the IN clause represents the names of the organizations."
        },
        {
            "sample_id": 4418,
            "vt": "SELECT filed_for_bankrupcy.name FROM filed_for_bankrupcy INNER JOIN no_payment_due AS T2 ON T1.name = T2.name WHERE no_payment_due.bool = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of students who have filed for bankruptcy from the 'filed_for_bankrupcy' table. It joins this table with the 'no_payment_due' table to filter students based on their payment status. The placeholder in the WHERE clause indicates whether the student has payment dues or not, allowing for dynamic querying based on this condition."
        },
        {
            "sample_id": 4375,
            "vt": "SELECT disabled.name, male.name, filed_for_bankrupcy.name FROM disabled INNER JOIN male AS T2 ON T1.\"name\" = T2.\"name\" INNER JOIN filed_for_bankrupcy AS T3 ON T1.\"name\" = T3.\"name\"",
            "ba": "The virtual table describes the names of students who are disabled, male, and have filed for bankruptcy. It combines data from the 'disabled', 'male', and 'filed_for_bankrupcy' tables using inner joins to ensure that only students who meet all three criteria are included."
        },
        {
            "sample_id": 4458,
            "vt": "SELECT CAST((SELECT COUNT(disabled.name) FROM unemployed) AS FLOAT) / (SELECT COUNT(disabled.name) FROM disabled)",
            "ba": "The virtual table calculates the ratio of unemployed disabled students to the total number of disabled students. It does this by counting the number of names in the 'unemployed' table and dividing it by the count of names in the 'disabled' table, casting the result to a float for precision."
        },
        {
            "sample_id": 4562,
            "vt": "SELECT COUNT(disabled.name) FROM disabled INNER JOIN longest_absense_from_school AS T2 ON T1.name = T2.name WHERE longest_absense_from_school.month = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of disabled students who have been absent from school for a specified duration. It joins the 'disabled' table with the 'longest_absense_from_school' table on the student's name and filters the results based on the absence duration using a numeric placeholder."
        },
        {
            "sample_id": 4469,
            "vt": "SELECT COUNT(male.name) FROM no_payment_due WHERE NOT male.name IN (SELECT male.name FROM male)",
            "ba": "The virtual table counts the number of male students who do not have any payment dues from the 'no_payment_due' table. It filters out those male students who are listed in the 'male' table, ensuring that only those who are not enlisted as male are considered."
        },
        {
            "sample_id": 4526,
            "vt": "SELECT COUNT(longest_absense_from_school.name) FROM longest_absense_from_school INNER JOIN enlist AS T2 ON T1.name = T2.name WHERE enlist.organ = '[placeholder-type:string]' ORDER BY longest_absense_from_school.month LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students who have been absent from school for a specified duration and are enlisted in a particular organization. It joins the 'longest_absense_from_school' table with the 'enlist' table to filter students based on their organization. The placeholders represent the organization name and the limit on the number of results returned."
        },
        {
            "sample_id": 4370,
            "vt": "SELECT COUNT(enlist.name) FROM enlist WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students who have enlisted in a specific organization from the 'enlist' table. The placeholder in the WHERE clause represents the name of the organization."
        },
        {
            "sample_id": 4532,
            "vt": "SELECT COUNT(*) FROM person INNER JOIN enlist AS T2 ON T1.name = T2.name LEFT JOIN male AS T3 ON T1.name = T3.name WHERE enlist.organ = '[placeholder-type:string]' AND male.name IS NULL",
            "ba": "The virtual table counts the number of students from the 'person' table who are not male and are enlisted in a specific organization. The query uses an inner join to connect the 'person' table with the 'enlist' table based on the student's name, and a left join to check for male students. The placeholder in the WHERE clause represents the organization name."
        },
        {
            "sample_id": 4444,
            "vt": "SELECT COUNT(longest_absense_from_school.name) FROM longest_absense_from_school WHERE longest_absense_from_school.month > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students who have been absent from school for more than a specified duration. It retrieves data from the 'longest_absense_from_school' table, filtering based on the absence duration using a numeric placeholder."
        },
        {
            "sample_id": 4539,
            "vt": "SELECT COUNT(no_payment_due.name) FROM no_payment_due INNER JOIN disabled AS T2 ON T1.name = T2.name WHERE no_payment_due.bool = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of disabled students who have a specific payment status from the 'no_payment_due' table. The placeholder in the WHERE clause indicates whether the students have payment dues or not."
        },
        {
            "sample_id": 4556,
            "vt": "SELECT longest_absense_from_school.name FROM longest_absense_from_school WHERE longest_absense_from_school.month = (SELECT MAX(longest_absense_from_school.month) FROM longest_absense_from_school)",
            "ba": "The virtual table identifies the names of students who have the longest absence from school based on the maximum duration of absence recorded in the 'longest_absense_from_school' table. The query uses a subquery to find the maximum absence duration and filters the results accordingly."
        },
        {
            "sample_id": 4403,
            "vt": "SELECT CAST(SUM(CASE WHEN no_payment_due.bool = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(CASE WHEN no_payment_due.bool = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM no_payment_due INNER JOIN enlist AS T2 ON T1.\"name\" = T2.\"name\" WHERE enlist.organ = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the ratio of students with no payment dues to the total number of enlisted students in a specific organization. It uses a conditional sum to differentiate between students with and without payment dues, and applies a scaling factor to the result."
        },
        {
            "sample_id": 4386,
            "vt": "SELECT no_payment_due.bool FROM no_payment_due WHERE no_payment_due.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about whether a specific student has any payment dues. It retrieves the 'bool' column from the 'no_payment_due' table, which indicates the payment status of the student identified by their name."
        },
        {
            "sample_id": 4405,
            "vt": "SELECT longest_absense_from_school.name FROM longest_absense_from_school WHERE longest_absense_from_school.\"month\" = (SELECT MAX(longest_absense_from_school.month) FROM longest_absense_from_school)",
            "ba": "The virtual table identifies the names of students who have the longest absence from school based on the maximum duration of absence recorded in the 'longest_absense_from_school' table. The query uses a subquery to find the maximum month value, which represents the longest absence, and filters the results accordingly."
        },
        {
            "sample_id": 4492,
            "vt": "SELECT disabled.name FROM disabled INNER JOIN unemployed AS T2 ON T2.name = T1.name LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of disabled students who are also unemployed from the 'disabled' and 'unemployed' tables. The query uses an INNER JOIN to combine these two tables based on the student's name, ensuring that only those students who meet both criteria are selected. The LIMIT clause allows for controlling the number of results returned, using a placeholder for numeric values."
        },
        {
            "sample_id": 4559,
            "vt": "SELECT COUNT(no_payment_due.name) FROM no_payment_due INNER JOIN unemployed AS T2 ON T1.name = T2.name WHERE no_payment_due.bool = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students who have a specific payment status and are also unemployed. It retrieves data from the 'no_payment_due' table, which indicates whether students have payment dues, and joins it with the 'unemployed' table to filter for students who are unemployed. The placeholder in the WHERE clause represents the payment status, indicating whether students have dues or not."
        }
    ],
    "world_development_indicators": [
        {
            "sample_id": 2146,
            "vt": "SELECT SUM(CASE WHEN indicators.indicatorname = '[placeholder-type:string]' AND t2.value < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) * [placeholder-type:numeric] / COUNT(country.countrycode) FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE country.incomegroup = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted sum of values from the 'indicators' table based on specific conditions related to the indicator name and value, while also considering the income group of countries from the 'country' table. The result is normalized by the count of countries in the specified income group."
        },
        {
            "sample_id": 2192,
            "vt": "SELECT DISTINCT country.shortname FROM country INNER JOIN footnotes AS T2 ON T1.CountryCode = T2.CountryCode INNER JOIN Series AS T3 ON T2.Seriescode = T3.SeriesCode WHERE country.incomegroup = '[placeholder-type:string]' AND country.region = '[placeholder-type:string]' AND series.topic = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct short names of countries from the 'country' table, filtering based on specific income group, region, and series topic. It joins the 'country' table with the 'footnotes' table to access additional information related to countries and their series codes, and further joins with the 'series' table to filter by topic."
        },
        {
            "sample_id": 2147,
            "vt": "SELECT DISTINCT indicators.indicatorcode FROM indicators WHERE indicators.indicatorname = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of indicator codes from the 'indicators' table based on a specific indicator name. The placeholder in the WHERE clause represents the name of the indicator that the user wants to filter by."
        },
        {
            "sample_id": 2139,
            "vt": "SELECT indicators.countryname FROM indicators WHERE indicators.indicatorname = '[placeholder-type:string]' ORDER BY indicators.value LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of countries from the 'indicators' table based on a specific indicator name. The results are ordered by the value of the indicator, and the number of results returned is limited by a placeholder for numeric values."
        },
        {
            "sample_id": 2103,
            "vt": "SELECT COUNT(footnotes.year) FROM country INNER JOIN FootNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE country.shortname = '[placeholder-type:string]' AND footnotes.seriescode = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of footnotes associated with a specific country and series code from the 'country' and 'footnotes' tables. It filters the results based on the short name of the country and the series code provided as placeholders."
        },
        {
            "sample_id": 2129,
            "vt": "SELECT CAST(SUM(CASE WHEN country.region = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(country.countrycode) FROM country WHERE country.systemoftrade = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of a numeric value for countries belonging to a specific region and using a specific system of trade. The result is derived from summing up values based on the region condition and then normalizing it by the count of countries in that region, multiplied by a specified factor."
        },
        {
            "sample_id": 2095,
            "vt": "SELECT countrynotes.description FROM country INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE country.lendingcategory = '[placeholder-type:string]' AND countrynotes.seriescode = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves descriptions from the 'countrynotes' table, which provides additional information about specific countries based on their lending category and series code. The query joins the 'country' table to filter countries by their lending category and uses placeholders for the lending category and series code to allow for dynamic querying."
        },
        {
            "sample_id": 2241,
            "vt": "SELECT country.region FROM country INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode INNER JOIN Series AS T3 ON T2.Seriescode = T3.SeriesCode WHERE series.indicatorname = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of regions for countries that are associated with a specific indicator name. It combines data from the 'country', 'countrynotes', and 'series' tables to filter the results based on the indicator name provided by the user."
        },
        {
            "sample_id": 2106,
            "vt": "SELECT country.countrycode, country.alpha2code FROM country WHERE country.region = '[placeholder-type:string]' AND country.incomegroup = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of country codes and their corresponding two-digit alpha codes from the 'country' table, filtered by a specific region and income group. The placeholders in the WHERE clause represent the region and income group criteria that can be specified by the user."
        },
        {
            "sample_id": 2205,
            "vt": "SELECT COUNT(country.countrycode) FROM country WHERE country.region = '[placeholder-type:string]' AND country.externaldebtreportingstatus = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of countries from the 'country' table that belong to a specific region and have a specified external debt reporting status. The placeholders in the WHERE clause represent the region and the external debt reporting status of interest."
        },
        {
            "sample_id": 2173,
            "vt": "SELECT country.currencyunit, indicators.indicatorcode FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE country.tablename = '[placeholder-type:string]' AND indicators.year = [placeholder-type:numeric]",
            "ba": "The virtual table describes the currency unit and indicator code for countries from the 'country' and 'indicators' tables. It filters the results based on a specific table name and year, using placeholders for these values."
        },
        {
            "sample_id": 2160,
            "vt": "SELECT DISTINCT country.countrycode, country.currencyunit, country.incomegroup FROM country INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE country.currencyunit = '[placeholder-type:string]' AND country.incomegroup LIKE '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of country codes, currency units, and income groups from the 'country' table. It filters the results based on a specific currency unit and an income group pattern using placeholders for user-defined values."
        },
        {
            "sample_id": 2202,
            "vt": "SELECT country.countrycode FROM country WHERE country.incomegroup = '[placeholder-type:string]' AND country.externaldebtreportingstatus = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique country codes from the 'country' table based on specific income group and external debt reporting status criteria. The placeholders in the WHERE clause represent the income group and the external debt reporting status that the user can specify."
        },
        {
            "sample_id": 2243,
            "vt": "SELECT series.aggregationmethod FROM indicators INNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName INNER JOIN Country AS T3 ON T1.CountryCode = T3.CountryCode WHERE country.shortname = '[placeholder-type:string]' AND indicators.value = [placeholder-type:numeric] AND indicators.year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the aggregation method used for a specific indicator from the 'indicators' table. It joins the 'indicators' table with the 'series' table to match the indicator names and with the 'country' table to filter by the short name of the country. The query also filters results based on a specific value and year for the indicator."
        },
        {
            "sample_id": 2179,
            "vt": "SELECT SUM(indicators.value) FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE country.incomegroup LIKE '[placeholder-type:string]' AND indicators.year = [placeholder-type:numeric] AND indicators.indicatorname = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total value of a specific indicator for countries belonging to a particular income group in a given year. It combines data from the 'country' and 'indicators' tables, filtering by income group, year, and indicator name."
        },
        {
            "sample_id": 2156,
            "vt": "SELECT DISTINCT T1.CountryName FROM indicators AS T1 INNER JOIN country AS T2 ON T1.CountryCode = T2.CountryCode WHERE T2.IncomeGroup = 'Upper middle income' UNION SELECT longname FROM (SELECT longname FROM country WHERE NationalAccountsBaseYear <> '' ORDER BY NationalAccountsBaseYear ASC LIMIT 1)",
            "ba": "The virtual table provides a list of distinct country names from the 'indicators' table for countries classified as 'Upper middle income' in the 'country' table. Additionally, it includes the long name of the country with the earliest non-empty National Accounts Base Year."
        },
        {
            "sample_id": 2228,
            "vt": "SELECT SUM(indicators.value), indicators.year FROM indicators INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode WHERE indicators.indicatorname = '[placeholder-type:string]' AND indicators.year >= [placeholder-type:numeric] AND indicators.year < [placeholder-type:numeric] AND indicators.countrycode = '[placeholder-type:string]' AND country.specialnotes = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total value of a specific indicator for a given country over a defined range of years. It retrieves the sum of the values from the 'indicators' table, filtered by the indicator name, year range, country code, and any special notes associated with the country."
        },
        {
            "sample_id": 2186,
            "vt": "SELECT country.shortname FROM country INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE countrynotes.seriescode = '[placeholder-type:string]'",
            "ba": "The virtual table describes the short names of countries from the 'country' table that have associated notes in the 'CountryNotes' table for a specific series code. The placeholder in the WHERE clause represents the series code for which the country notes are being queried."
        },
        {
            "sample_id": 2170,
            "vt": "SELECT DISTINCT footnotes.description FROM country INNER JOIN FootNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE country.tablename = '[placeholder-type:string]' AND footnotes.year = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct descriptions of footnotes related to countries from the 'country' and 'footnotes' tables. It filters the results based on the specified table name of the country and the year of the footnotes."
        },
        {
            "sample_id": 2220,
            "vt": "SELECT COUNT(LongName) FROM country WHERE LatestPopulationCensus = '2011' UNION ALL SELECT LongName FROM country WHERE LatestPopulationCensus = '2011'",
            "ba": "The virtual table provides a count of countries that had their latest population census conducted in the year 2011, along with the long names of those countries."
        },
        {
            "sample_id": 2122,
            "vt": "SELECT DISTINCT series.source FROM footnotes INNER JOIN Series AS T2 ON T1.Seriescode = T2.SeriesCode INNER JOIN Country AS T3 ON T1.Countrycode = T3.CountryCode WHERE country.region = '[placeholder-type:string]' AND series.indicatorname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct sources of data from the 'series' table based on footnotes related to specific countries and indicators. It filters the results by the region of the country and the name of the indicator, allowing users to identify unique data sources relevant to a particular region and indicator."
        },
        {
            "sample_id": 2121,
            "vt": "SELECT country.tablename, country.sourceofmostrecentincomeandexpendituredata FROM country WHERE country.region = '[placeholder-type:string]' AND country.incomegroup = '[placeholder-type:string]'",
            "ba": "The virtual table describes the table names and the source of the most recent income and expenditure data for countries that belong to a specific region and income group. The placeholders in the WHERE clause represent the region and income group of interest."
        },
        {
            "sample_id": 2197,
            "vt": "SELECT country.longname FROM country WHERE country.incomegroup = '[placeholder-type:string]' AND country.region = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of long names of countries from the 'country' table that belong to a specific income group and region. The placeholders in the WHERE clause represent the income group and region criteria for filtering the results."
        },
        {
            "sample_id": 2127,
            "vt": "SELECT COUNT(country.countrycode) FROM country WHERE country.region = '[placeholder-type:string]' AND country.incomegroup = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of countries from the 'country' table that belong to a specific region and income group. The placeholders in the WHERE clause represent the region and income group criteria."
        },
        {
            "sample_id": 2142,
            "vt": "SELECT indicators.countryname, indicators.indicatorname FROM indicators INNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName WHERE series.topic = '[placeholder-type:string]' ORDER BY indicators.value LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the country names and their corresponding indicator names from the 'indicators' table, filtered by a specific topic from the 'series' table. The placeholders represent the topic of interest and the limit on the number of results to return."
        },
        {
            "sample_id": 2162,
            "vt": "SELECT COUNT(ShortName) FROM Country WHERE ShortName LIKE 'A%' UNION SELECT alpha2code FROM country WHERE shortname LIKE 'A%'",
            "ba": "The virtual table provides a count of countries whose short names start with the letter 'A' and also lists their corresponding two-digit country codes. The first part of the query counts the number of entries in the 'Country' table where the 'ShortName' begins with 'A', while the second part retrieves the 'alpha2code' for those same countries."
        },
        {
            "sample_id": 2213,
            "vt": "SELECT COUNT(DISTINCT T1.CountryCode) FROM Country AS T1 INNER JOIN Footnotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T2.Description = 'Unspecified' OR T2.Description = 'Not specified' UNION SELECT T1.LongName FROM Country AS T1 INNER JOIN Footnotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T2.Description = 'Unspecified' OR T2.Description = 'Not specified' LIMIT 4",
            "ba": "The virtual table provides a count of distinct countries from the 'Country' table that have footnotes with descriptions indicating they are 'Unspecified' or 'Not specified'. Additionally, it retrieves the long names of these countries, limiting the results to four entries."
        },
        {
            "sample_id": 2246,
            "vt": "SELECT CAST(SUM(indicators.value) AS FLOAT) * [placeholder-type:numeric] / COUNT(indicators.year) FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE country.alpha2code = '[placeholder-type:string]' AND indicators.indicatorname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average value of a specific indicator for a country identified by its alpha-2 code. It sums up the values from the 'indicators' table, casts the sum to a float, and then divides it by the count of years for that indicator. The placeholders represent the alpha-2 code of the country and the name of the indicator."
        },
        {
            "sample_id": 2211,
            "vt": "SELECT DISTINCT series.topic FROM countrynotes INNER JOIN Country AS T2 ON T1.Countrycode = T2.CountryCode INNER JOIN Series AS T3 ON T1.Seriescode = T3.SeriesCode WHERE country.shortname = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of topics from the 'series' table that are associated with country notes for a specific country. The query joins the 'countrynotes' table with the 'country' table to filter by the country's short name, and then it joins with the 'series' table to access the relevant topics."
        },
        {
            "sample_id": 2144,
            "vt": "SELECT indicators.indicatorname FROM indicators INNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName WHERE indicators.countryname = '[placeholder-type:string]' AND indicators.year = [placeholder-type:numeric] AND series.periodicity = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of indicators from the 'indicators' table that are associated with a specific country and year, while also ensuring that the periodicity of the series matches a specified value. The placeholders represent the country name, year, and periodicity criteria."
        },
        {
            "sample_id": 2201,
            "vt": "SELECT DISTINCT series.topic FROM series WHERE series.licensetype = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct topics from the 'series' table that are associated with a specific license type. The placeholder in the WHERE clause represents the type of license being queried."
        },
        {
            "sample_id": 2185,
            "vt": "SELECT CAST(MAX(value) AS FLOAT) / MIN(value) FROM indicators WHERE indicatorname = 'Number of infant deaths' AND year = '1971' UNION ALL SELECT countryname FROM (SELECT countryname, MAX(value) FROM indicators WHERE indicatorname = 'Number of infant deaths' AND year = '1971') UNION SELECT countryname FROM (SELECT countryname, MIN(value) FROM indicators WHERE indicatorname = 'Number of infant deaths' AND year = '1971')",
            "ba": "The virtual table calculates the ratio of the maximum to minimum number of infant deaths recorded in the year 1971, and also retrieves the names of countries associated with these maximum and minimum values."
        },
        {
            "sample_id": 2130,
            "vt": "SELECT CAST(SUM(indicators.value) AS FLOAT) / COUNT(country.countrycode) FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE country.region = '[placeholder-type:string]' AND indicators.indicatorname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average value of a specific indicator for countries within a specified region. It does this by summing the values from the 'indicators' table and dividing by the count of countries in that region. The placeholders represent the region and the indicator name to filter the results accordingly."
        },
        {
            "sample_id": 2180,
            "vt": "SELECT indicators.countryname, country.currencyunit FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE indicators.indicatorname = '[placeholder-type:string]' AND indicators.year = [placeholder-type:numeric] AND country.currencyunit <> '[placeholder-type:string]' ORDER BY indicators.value LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of country names along with their corresponding currency units from the 'country' table. It filters the results based on a specific indicator name and year from the 'indicators' table, ensuring that the currency unit is not equal to a specified value. The results are ordered by the indicator value and limited to a specified number of entries."
        },
        {
            "sample_id": 2234,
            "vt": "SELECT country.longname FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE indicators.indicatorname = '[placeholder-type:string]' AND indicators.year = [placeholder-type:numeric] AND indicators.value = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the long names of countries from the 'country' table by joining it with the 'indicators' table. The query filters the results based on a specific indicator name, year, and value, using placeholders for these criteria."
        },
        {
            "sample_id": 2227,
            "vt": "SELECT country.countrycode, country.region FROM indicators INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode WHERE indicators.indicatorname = '[placeholder-type:string]' AND indicators.year >= [placeholder-type:numeric] AND indicators.year < [placeholder-type:numeric] ORDER BY country.region LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of country codes and their corresponding regions from the 'country' table, filtered by specific indicators from the 'indicators' table. The query selects countries based on a given indicator name and a range of years, allowing users to limit the number of results returned."
        },
        {
            "sample_id": 2113,
            "vt": "SELECT seriesnotes.description FROM series INNER JOIN SeriesNotes AS T2 ON T1.SeriesCode = T2.Seriescode WHERE series.seriescode = '[placeholder-type:string]' AND series.topic = '[placeholder-type:string]' AND seriesnotes.year = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves descriptions of series notes from the 'seriesnotes' table, which are linked to specific series in the 'series' table. The query filters the results based on a specific series code, topic, and year, allowing users to obtain detailed information about a particular series note."
        },
        {
            "sample_id": 2099,
            "vt": "SELECT footnotes.description FROM country INNER JOIN FootNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE country.shortname = '[placeholder-type:string]' AND footnotes.seriescode = '[placeholder-type:string]' AND footnotes.year = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves descriptions of footnotes related to specific countries and series for a given year. It joins the 'country' table with the 'footnotes' table based on the country code, filtering results by the short name of the country, the series code, and the year."
        },
        {
            "sample_id": 2229,
            "vt": "SELECT indicators.countryname, SUM(indicators.value), country.incomegroup FROM indicators INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode WHERE indicators.indicatorname = '[placeholder-type:string]' AND indicators.year >= [placeholder-type:numeric] AND indicators.year < [placeholder-type:numeric] GROUP BY indicators.countrycode ORDER BY SUM(indicators.value) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total values of a specific indicator for countries, grouped by country name and income group. It retrieves data from the 'indicators' table and joins it with the 'country' table to include the income group of each country. The query filters results based on a specified indicator name and a range of years, allowing users to limit the number of results returned."
        },
        {
            "sample_id": 2150,
            "vt": "SELECT country.longname FROM country INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE countrynotes.seriescode = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the long names of countries from the 'country' table, joining it with the 'CountryNotes' table to filter based on a specific series code. The placeholder in the WHERE clause represents the series code for which the country names are being queried."
        },
        {
            "sample_id": 2204,
            "vt": "SELECT SUM(CASE WHEN country.governmentaccountingconcept = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END), SUM(CASE WHEN country.governmentaccountingconcept = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM country WHERE country.externaldebtreportingstatus = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total values based on the government accounting concept from the 'country' table, applying conditional aggregation. It filters the results based on the external debt reporting status, allowing users to analyze financial data according to specific accounting practices and reporting statuses."
        },
        {
            "sample_id": 2215,
            "vt": "SELECT CAST(SUM(CASE WHEN indicators.value > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(country.countrycode) FROM indicators INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode WHERE indicators.year = [placeholder-type:numeric] AND country.region = '[placeholder-type:string]' AND indicators.indicatorname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of indicator values for countries in a specific region and year. It sums the values from the 'indicators' table where the value exceeds a certain threshold, applies a multiplier, and divides by the count of countries in that region. The placeholders represent the threshold value, the multiplier, the year, and the region name."
        },
        {
            "sample_id": 2235,
            "vt": "SELECT country.alpha2code FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE indicators.indicatorname = '[placeholder-type:string]' AND indicators.year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the 2-digit country codes from the 'country' table by joining it with the 'indicators' table. It filters the results based on a specific indicator name and year, represented by placeholders for user input."
        },
        {
            "sample_id": 2195,
            "vt": "SELECT DISTINCT country.longname FROM seriesnotes INNER JOIN CountryNotes AS T2 ON T1.SeriesCode = T2.Seriescode INNER JOIN Country AS T3 ON T2.Countrycode = T3.CountryCode WHERE country.region = '[placeholder-type:string]' AND seriesnotes.seriescode = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of long names of countries from the 'country' table that are associated with specific series notes. It filters the results based on the region of the country and the series code, allowing users to identify countries that belong to a particular region and are linked to a specific series."
        },
        {
            "sample_id": 2222,
            "vt": "SELECT MAX(indicators.value), indicators.year FROM indicators INNER JOIN country AS T2 ON T1.CountryCode = T2.CountryCode WHERE country.region = '[placeholder-type:string]' AND indicators.indicatorname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum value of a specific indicator for countries within a specified region, along with the corresponding year. It joins the 'indicators' table with the 'country' table to filter results based on the region and the indicator name provided by the user."
        },
        {
            "sample_id": 2111,
            "vt": "SELECT COUNT(country.countrycode) FROM indicators INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode WHERE country.region = '[placeholder-type:string]' AND indicators.indicatorname = '[placeholder-type:string]' AND indicators.year = [placeholder-type:numeric] AND indicators.value > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of countries from the 'indicators' table that meet specific criteria. It filters countries based on their region, a specific indicator name, a particular year, and ensures that the value of the indicator is greater than a specified numeric threshold."
        },
        {
            "sample_id": 2209,
            "vt": "SELECT indicators.value FROM indicators INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode WHERE country.longname = '[placeholder-type:string]' AND indicators.indicatorname = '[placeholder-type:string]' AND indicators.year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the values of specific indicators for countries based on their long names and a specified year. It joins the 'indicators' table with the 'country' table to filter results according to the country's long name and the indicator's name, while also specifying the year for which the data is requested."
        },
        {
            "sample_id": 2184,
            "vt": "SELECT indicators.countryname FROM indicators WHERE indicators.year = [placeholder-type:numeric] AND indicators.indicatorname = '[placeholder-type:string]' ORDER BY indicators.value LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of countries from the 'indicators' table for a specific year and indicator name. The results are ordered by the value of the indicator, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 2148,
            "vt": "SELECT country.tablename FROM country WHERE country.systemofnationalaccounts = '[placeholder-type:string]'",
            "ba": "The virtual table describes the table names of countries from the 'country' table that utilize a specific system of national accounts. The placeholder in the WHERE clause represents the system of national accounts being queried."
        },
        {
            "sample_id": 2134,
            "vt": "SELECT COUNT(DISTINCT T2.SeriesCode) FROM footnotes INNER JOIN Series AS T2 ON T1.Seriescode = T2.SeriesCode WHERE footnotes.year IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]') AND series.periodicity = '[placeholder-type:string]' AND series.aggregationmethod = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct series codes from the 'footnotes' table that are associated with specific years, while also filtering based on the periodicity and aggregation method of the series."
        },
        {
            "sample_id": 2196,
            "vt": "SELECT country.shortname FROM country WHERE country.currencyunit = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the short names of countries from the 'country' table that use a specific currency unit. The placeholders in the WHERE clause represent the currency unit and the limit on the number of results returned."
        },
        {
            "sample_id": 2090,
            "vt": "SELECT COUNT(country.countrycode) FROM country WHERE country.lendingcategory = '[placeholder-type:string]' AND country.othergroups = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of countries from the 'country' table that belong to a specific lending category and are part of a particular other group. The placeholders in the WHERE clause represent the lending category and the other group respectively."
        },
        {
            "sample_id": 2153,
            "vt": "SELECT DISTINCT indicators.countryname FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE country.incomegroup = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct country names from the 'country' table that belong to a specific income group. The query uses an INNER JOIN to connect the 'country' table with the 'indicators' table based on the country code, ensuring that only countries matching the specified income group are included in the results."
        },
        {
            "sample_id": 2237,
            "vt": "SELECT (SELECT indicators.value FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.Alpha2Code = '1A' AND T2.IndicatorName = 'Adolescent fertility rate (births per 1,000 women ages 15-19)' AND T2.Year = 1961) - (SELECT indicators.value FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.Alpha2Code = '1A' AND T2.IndicatorName = 'Adolescent fertility rate (births per 1,000 women ages 15-19)' AND T2.Year = 1960)",
            "ba": "The virtual table calculates the difference in the 'Adolescent fertility rate (births per 1,000 women ages 15-19)' indicator for a specific country between the years 1961 and 1960. It retrieves the values from the 'Indicators' table by joining it with the 'Country' table based on the country code, filtering for the specified country and indicator name."
        },
        {
            "sample_id": 2158,
            "vt": "SELECT country.tablename, country.currencyunit FROM country INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE countrynotes.seriescode = '[placeholder-type:string]'",
            "ba": "The virtual table describes the table names and currency units of countries from the 'country' table, filtered by a specific series code from the 'CountryNotes' table. The placeholder in the WHERE clause represents the series code used to filter the results."
        },
        {
            "sample_id": 2109,
            "vt": "SELECT series.indicatorname, series.aggregationmethod FROM series WHERE series.topic = '[placeholder-type:string]'",
            "ba": "The virtual table describes the indicator names and their aggregation methods from the 'series' table that are associated with a specific topic. The placeholder in the WHERE clause represents the topic of interest."
        },
        {
            "sample_id": 2232,
            "vt": "SELECT COUNT(country.countrycode) FROM country WHERE country.vitalregistrationcomplete = '[placeholder-type:string]' AND country.region = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of countries from the 'country' table that have completed vital registration and belong to a specific region. The placeholders in the WHERE clause represent the completion status of vital registration and the region of interest."
        },
        {
            "sample_id": 2151,
            "vt": "SELECT countrynotes.seriescode FROM country INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE country.currencyunit = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the series codes from the 'CountryNotes' table for countries that use a specific currency unit. It joins the 'country' table with the 'CountryNotes' table based on the country code, filtering the results to only include countries with the specified currency unit."
        },
        {
            "sample_id": 2226,
            "vt": "SELECT country.lendingcategory FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE indicators.indicatorname = '[placeholder-type:string]' AND indicators.value = [placeholder-type:numeric] AND indicators.year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the lending category of countries from the 'country' table by joining it with the 'indicators' table. The query filters the results based on a specific indicator name, its corresponding value, and the year of the data. The placeholders represent the indicator name as a string, and the value and year as numeric values."
        },
        {
            "sample_id": 2131,
            "vt": "SELECT country.countrycode FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE country.incomegroup = '[placeholder-type:string]' AND indicators.indicatorname = '[placeholder-type:string]' ORDER BY indicators.value LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique country codes from the 'country' table, filtering based on the income group and a specific indicator name from the 'indicators' table. The results are ordered by the value of the indicator and limited to a specified number of entries."
        },
        {
            "sample_id": 2190,
            "vt": "SELECT MAX(indicators.value) FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE country.incomegroup = '[placeholder-type:string]' AND indicators.year = [placeholder-type:numeric] AND indicators.indicatorname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum value of a specific indicator from the 'indicators' table, filtered by the income group of the country and the year of interest. It joins the 'country' table to ensure that the data corresponds to countries within a specified income group."
        },
        {
            "sample_id": 2145,
            "vt": "SELECT indicators.countryname FROM indicators WHERE indicators.value = (SELECT MIN(indicators.value) FROM Indicators AS T1 INNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName WHERE T1.Year >= 1960 AND T1.Year < 1966 AND T2.Topic = 'Health: Population: Structure')",
            "ba": "The virtual table describes the country names from the 'indicators' table that have the minimum value for a specific indicator related to health population structure, within the years 1960 to 1965. The query uses a subquery to find the minimum value of the indicator for the specified years and topic."
        },
        {
            "sample_id": 2152,
            "vt": "SELECT country.tablename FROM country INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE countrynotes.seriescode = '[placeholder-type:string]'",
            "ba": "The virtual table lists the table names of countries from the 'country' table that have associated notes in the 'CountryNotes' table for a specific series code. The placeholder in the WHERE clause represents the series code being queried."
        },
        {
            "sample_id": 2238,
            "vt": "SELECT countrynotes.description FROM country INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE countrynotes.seriescode = '[placeholder-type:string]' AND country.shortname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves descriptions of country notes from the 'countrynotes' table, which are linked to specific countries in the 'country' table. The query filters the results based on a specific series code and the short name of the country."
        },
        {
            "sample_id": 2120,
            "vt": "SELECT indicators.countryname FROM indicators WHERE indicators.year = [placeholder-type:numeric] AND indicators.indicatorname = '[placeholder-type:string]' AND indicators.value >= [placeholder-type:numeric] AND indicators.value <= [placeholder-type:numeric]",
            "ba": "The virtual table describes the country names from the 'indicators' table for a specific year, where the indicator name matches a given string and the values fall within a specified numeric range."
        },
        {
            "sample_id": 2175,
            "vt": "SELECT COUNT(DISTINCT T1.Countrycode) FROM Country AS T1 INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T2.Description = 'Sources: UN Energy Statistics (2014)' UNION SELECT DISTINCT t1.CurrencyUnit FROM country AS t1 INNER JOIN countrynotes AS t2 ON t1.CountryCode = t2.Countrycode WHERE t2.Description = 'Sources: UN Energy Statistics (2014)'",
            "ba": "The virtual table provides a count of distinct countries that have a specific note regarding their energy statistics, as well as a list of unique currency units used by those countries. It combines data from the 'Country' and 'CountryNotes' tables based on a matching country code, filtering for notes that reference the UN Energy Statistics from 2014."
        },
        {
            "sample_id": 2128,
            "vt": "SELECT country.shortname FROM country WHERE country.latesttradedata > [placeholder-type:numeric]",
            "ba": "The virtual table describes the short names of countries from the 'country' table that have more recent trade data than a specified year. The placeholder in the WHERE clause represents the year to compare against."
        },
        {
            "sample_id": 2096,
            "vt": "SELECT COUNT(country.countrycode) FROM country INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE country.lendingcategory = '[placeholder-type:string]' AND countrynotes.seriescode = '[placeholder-type:string]' AND country.incomegroup = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of countries from the 'country' table that meet specific criteria. It filters countries based on their lending category, income group, and a related series code from the 'CountryNotes' table. The placeholders represent the values for these criteria."
        },
        {
            "sample_id": 2093,
            "vt": "SELECT country.shortname, countrynotes.description FROM country INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE country.region = '[placeholder-type:string]' AND countrynotes.seriescode = '[placeholder-type:string]'",
            "ba": "The virtual table describes the short names of countries along with their corresponding notes from the 'CountryNotes' table. It filters the results based on a specific region and a series code, allowing users to retrieve relevant descriptions for countries within a defined geographical area and related to a particular series."
        },
        {
            "sample_id": 2224,
            "vt": "SELECT COUNT(DISTINCT T1.CountryCode) FROM indicators AS T1 INNER JOIN country AS T2 ON T1.CountryCode = T2.CountryCode WHERE T2.Region = 'Middle East & North Africa' AND T2.SystemOfNationalAccounts = 'Country uses the 1968 System of National Accounts methodology.' AND T1.IndicatorName = 'CO2 emissions FROM solid fuel consumption (kt)' UNION SELECT * FROM (SELECT T1.CountryName FROM indicators AS T1 INNER JOIN country AS T2 ON T1.CountryCode = T2.CountryCode WHERE T2.Region = 'Middle East & North Africa' AND T2.SystemOfNationalAccounts = 'Country uses the 1968 System of National Accounts methodology.' AND T1.IndicatorName = 'CO2 emissions FROM solid fuel consumption (kt)' GROUP BY T1.CountryName ORDER BY SUM(T1.value) DESC LIMIT 1)",
            "ba": "The virtual table provides a count of distinct countries in the 'indicators' table that are located in the 'Middle East & North Africa' region and utilize the 1968 System of National Accounts methodology, specifically for the indicator related to CO2 emissions from solid fuel consumption. Additionally, it retrieves the name of the country with the highest total CO2 emissions from solid fuel consumption within the same criteria."
        },
        {
            "sample_id": 2091,
            "vt": "SELECT country.shortname, country.externaldebtreportingstatus FROM country WHERE country.lendingcategory = '[placeholder-type:string]'",
            "ba": "The virtual table describes the short names and external debt reporting status of countries from the 'country' table that belong to a specific lending category. The placeholder in the WHERE clause represents the lending category of interest."
        },
        {
            "sample_id": 2107,
            "vt": "SELECT country.longname, country.alpha2code FROM country WHERE country.latesttradedata = [placeholder-type:numeric] AND country.latestwaterwithdrawaldata = [placeholder-type:numeric]",
            "ba": "The virtual table describes the long names and 2-digit codes of countries from the 'country' table that have specific values for their latest trade data and latest water withdrawal data. The placeholders in the WHERE clause represent the numeric values for these data points."
        },
        {
            "sample_id": 2119,
            "vt": "SELECT COUNT(country.countrycode) FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE indicators.indicatorname = '[placeholder-type:string]' AND country.externaldebtreportingstatus = '[placeholder-type:string]' AND indicators.value > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of countries from the 'country' table that have a specific indicator name, a defined external debt reporting status, and an indicator value greater than a specified numeric threshold. The placeholders in the WHERE clause represent the indicator name, the external debt reporting status, and the numeric value for filtering the results."
        },
        {
            "sample_id": 2181,
            "vt": "SELECT COUNT(country.countrycode) FROM country WHERE country.systemofnationalaccounts = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of countries from the 'country' table that utilize a specific system of national accounts. The placeholder in the WHERE clause represents the system of national accounts being queried."
        },
        {
            "sample_id": 2105,
            "vt": "SELECT DISTINCT country.specialnotes FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE indicators.value = (SELECT indicators.value FROM Indicators WHERE IndicatorName LIKE 'Adolescent fertility rate%' ORDER BY Value DESC LIMIT 1)",
            "ba": "The virtual table retrieves distinct special notes associated with countries from the 'country' table. It filters the results based on a specific condition related to the 'indicators' table, where it looks for the highest value of the 'Adolescent fertility rate' indicator. The use of a subquery allows for identifying the maximum value of this indicator, ensuring that only countries with this highest fertility rate are considered in the final output."
        },
        {
            "sample_id": 2097,
            "vt": "SELECT COUNT(country.countrycode) FROM country INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE country.incomegroup = '[placeholder-type:string]' AND country.currencyunit = '[placeholder-type:string]' AND countrynotes.seriescode = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of countries from the 'country' table that belong to a specific income group and use a particular currency unit. It also filters the results based on a specific series code from the 'CountryNotes' table, which is linked to the 'country' table through the country code."
        },
        {
            "sample_id": 2223,
            "vt": "SELECT DISTINCT countrynotes.seriescode FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode INNER JOIN CountryNotes AS T3 ON T2.CountryCode = T3.Countrycode WHERE indicators.indicatorname = '[placeholder-type:string]' AND country.longname = '[placeholder-type:string]' AND indicators.year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct series codes from the 'countrynotes' table by joining it with the 'country' and 'indicators' tables. It filters the results based on a specific indicator name, the long name of the country, and a particular year."
        },
        {
            "sample_id": 2207,
            "vt": "SELECT MAX(indicators.value) FROM indicators INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode WHERE indicators.year >= [placeholder-type:numeric] AND indicators.year < [placeholder-type:numeric] AND indicators.indicatorname LIKE '[placeholder-type:string]' AND country.longname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum value of a specific indicator from the 'indicators' table for a given country over a specified range of years. The query joins the 'indicators' table with the 'country' table to filter results based on the country's long name and the indicator's name, while also applying year constraints."
        },
        {
            "sample_id": 2118,
            "vt": "SELECT series.topic, series.seriescode, series.licensetype FROM indicators INNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName WHERE indicators.year = [placeholder-type:numeric] AND indicators.countryname = '[placeholder-type:string]' AND indicators.indicatorname = '[placeholder-type:string]' AND indicators.value = [placeholder-type:numeric]",
            "ba": "The virtual table describes the topics, series codes, and license types of indicators from the 'indicators' table that are associated with a specific year, country name, indicator name, and value. The placeholders in the WHERE clause represent the year, country name, indicator name, and value to filter the results accordingly."
        },
        {
            "sample_id": 2116,
            "vt": "SELECT country.shortname FROM indicators INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode WHERE indicators.indicatorname = '[placeholder-type:string]' AND indicators.year = [placeholder-type:numeric] AND indicators.value = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the short names of countries from the 'country' table based on specific criteria from the 'indicators' table. It filters the results by a given indicator name, year, and value, allowing users to find countries that meet these conditions."
        },
        {
            "sample_id": 2141,
            "vt": "SELECT DISTINCT indicators.indicatorname FROM indicators INNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName WHERE indicators.year >= [placeholder-type:numeric] AND indicators.year < [placeholder-type:numeric] AND series.licensetype = '[placeholder-type:string]' AND indicators.value < [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct indicator names from the 'indicators' table, filtering based on specific year ranges, license type, and value conditions. The placeholders allow users to specify the year range, license type, and value threshold for the query."
        },
        {
            "sample_id": 2231,
            "vt": "SELECT country.latesthouseholdsurvey, country.pppsurveyyear FROM country WHERE country.shortname = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the latest household survey and the purchasing power parity survey year for a specific country identified by its short name. The placeholder in the WHERE clause represents the short name of the country."
        },
        {
            "sample_id": 2167,
            "vt": "SELECT country.countrycode FROM country INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE country.incomegroup = '[placeholder-type:string]' AND countrynotes.seriescode = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique country codes from the 'country' table, specifically for countries that belong to a certain income group and have associated notes in the 'CountryNotes' table. The placeholders in the WHERE clause represent the income group and series code that the user can specify."
        },
        {
            "sample_id": 2123,
            "vt": "SELECT series.source FROM countrynotes INNER JOIN Series AS T2 ON T1.Seriescode = T2.SeriesCode INNER JOIN Country AS T3 ON T1.Countrycode = T3.CountryCode INNER JOIN SeriesNotes AS T4 ON T2.SeriesCode = T4.Seriescode WHERE seriesnotes.year LIKE '[placeholder-type:string]' AND series.indicatorname = '[placeholder-type:string]'",
            "ba": "The virtual table provides access to the source of data from the 'series' table, filtered by specific criteria related to country notes and series notes. It joins multiple tables: 'countrynotes', 'series', 'country', and 'seriesnotes' to gather relevant information. The placeholders in the WHERE clause allow users to specify the year and the indicator name they are interested in."
        },
        {
            "sample_id": 2239,
            "vt": "SELECT countrynotes.description FROM country INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode INNER JOIN Series AS T3 ON T2.Seriescode = T3.SeriesCode WHERE country.shortname = '[placeholder-type:string]' AND series.topic = '[placeholder-type:string]'",
            "ba": "The virtual table describes the descriptions of country notes from the 'countrynotes' table, which are linked to specific countries and series. The placeholders in the WHERE clause represent the short name of the country and the topic of the series."
        },
        {
            "sample_id": 2102,
            "vt": "SELECT COUNT(footnotes.seriescode) FROM country INNER JOIN FootNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE country.shortname = '[placeholder-type:string]' AND footnotes.year = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of footnotes associated with a specific country and year from the 'country' and 'footnotes' tables. The placeholders represent the short name of the country and the year for which the footnotes are being counted."
        },
        {
            "sample_id": 2200,
            "vt": "SELECT indicators.countryname FROM indicators WHERE indicators.indicatorname LIKE '[placeholder-type:string]' ORDER BY indicators.value LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of countries from the 'indicators' table where the indicator name matches a specified pattern. The results are ordered by the value of the indicators and limited to a specified number of entries."
        },
        {
            "sample_id": 2245,
            "vt": "SELECT ((SELECT indicators.value FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.Alpha2Code = '1A' AND T2.IndicatorName = 'Adolescent fertility rate (births per 1,000 women ages 15-19)' AND T2.Year = 1961) - (SELECT indicators.value FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.Alpha2Code = '1A' AND T2.IndicatorName = 'Adolescent fertility rate (births per 1,000 women ages 15-19)' AND T2.Year = 1960)) * [placeholder-type:numeric] / (SELECT SUM(indicators.value) FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.Alpha2Code = '1A' AND T2.IndicatorName = 'Adolescent fertility rate (births per 1,000 women ages 15-19)' AND T2.Year = 1960)",
            "ba": "The virtual table calculates the change in the adolescent fertility rate (births per 1,000 women ages 15-19) for a specific country over two consecutive years (1961 and 1960). It takes the difference between the values for these two years, multiplies it by a placeholder for a numeric value, and divides it by the total sum of the indicator's value for the year 1960. The placeholders represent the country code and the numeric multiplier."
        },
        {
            "sample_id": 2183,
            "vt": "SELECT country.shortname, country.longname FROM country WHERE country.latestpopulationcensus >= [placeholder-type:numeric] AND country.latestpopulationcensus < [placeholder-type:numeric] AND country.vitalregistrationcomplete = '[placeholder-type:string]'",
            "ba": "The virtual table describes the short and long names of countries from the 'country' table that have a latest population census within a specified range and where the vital registration is complete. The placeholders represent the numeric values for the census years and the string value for the vital registration status."
        },
        {
            "sample_id": 2140,
            "vt": "SELECT DISTINCT series.indicatorname FROM indicators INNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName WHERE indicators.year = [placeholder-type:numeric] AND indicators.value > [placeholder-type:numeric] AND series.periodicity = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct indicator names from the 'indicators' table, which are associated with specific years and values. It joins the 'indicators' table with the 'series' table to filter based on the periodicity of the series. The placeholders represent the year, a numeric value threshold, and the periodicity type."
        },
        {
            "sample_id": 2233,
            "vt": "SELECT indicators.year FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE country.alpha2code = '[placeholder-type:string]' AND indicators.indicatorname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the years for which specific indicators are available for a country identified by its alpha-2 code. It joins the 'country' table with the 'indicators' table based on the country code, filtering results by the specified alpha-2 code and indicator name."
        },
        {
            "sample_id": 2125,
            "vt": "SELECT DISTINCT country.countrycode, indicators.value FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE country.latesttradedata = [placeholder-type:numeric] AND indicators.indicatorname LIKE '[placeholder-type:string]' AND indicators.year = [placeholder-type:numeric] AND indicators.value > [placeholder-type:numeric] ORDER BY indicators.value",
            "ba": "The virtual table provides a distinct list of country codes along with their corresponding indicator values from the 'country' and 'indicators' tables. It filters the results based on the latest trade data year, a specific indicator name, a particular year, and ensures that the indicator value exceeds a specified threshold. The results are ordered by the indicator value."
        },
        {
            "sample_id": 2203,
            "vt": "SELECT CAST(SUM(CASE WHEN country.externaldebtreportingstatus = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(country.countrycode) FROM country WHERE country.region = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of a specific numeric value from the 'country' table, based on the external debt reporting status of countries within a specified region. The calculation involves summing values conditionally based on the external debt reporting status and then normalizing this sum by the count of countries in that region."
        },
        {
            "sample_id": 2194,
            "vt": "SELECT DISTINCT country.tablename FROM country INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE country.latesttradedata = [placeholder-type:numeric] AND indicators.indicatorcode = '[placeholder-type:string]'",
            "ba": "The virtual table lists the unique table names of countries from the 'country' table that have the latest trade data for a specific indicator. The query joins the 'country' table with the 'Indicators' table based on the country code, filtering for the latest trade data and a specific indicator code."
        }
    ],
    "superstore": [
        {
            "sample_id": 2455,
            "vt": "SELECT DISTINCT people.\"customer name\" FROM east_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" WHERE east_superstore.\"order id\" = '[placeholder-type:string]' AND people.region = '[placeholder-type:string]'",
            "ba": "The virtual table lists the unique names of customers from the 'people' table who have placed an order in the 'east_superstore' table. The query filters results based on a specific order ID and the region of the customers, both represented by placeholders for user input."
        },
        {
            "sample_id": 2450,
            "vt": "SELECT DISTINCT product.\"product name\" FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T2.\"Product ID\" WHERE people.\"customer name\" = '[placeholder-type:string]' AND central_superstore.region = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct product names from the 'product' table that are associated with customers from the 'people' table based on their name and region. It joins the 'people' table with the 'central_superstore' table to link customer IDs, and then joins with the 'product' table to retrieve product names. The placeholders represent the specific customer name and region for filtering the results."
        },
        {
            "sample_id": 2373,
            "vt": "SELECT SUM(central_superstore.sales) FROM central_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE product.\"product name\" = '[placeholder-type:string]' AND product.region = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total sales from the 'central_superstore' table for a specific product and region. It joins the 'central_superstore' table with the 'product' table to filter sales based on the product name and region specified by the user."
        },
        {
            "sample_id": 2391,
            "vt": "SELECT DISTINCT product.\"product name\" FROM east_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE product.region = '[placeholder-type:string]' AND east_superstore.profit > (SELECT AVG(east_superstore.profit) * [placeholder-type:numeric] FROM east_superstore)",
            "ba": "The virtual table lists distinct product names from the 'east_superstore' table that are associated with a specific region. It filters the results to include only those products whose profit exceeds a certain threshold, which is determined by multiplying the average profit of all products in the 'east_superstore' by a specified numeric value."
        },
        {
            "sample_id": 2368,
            "vt": "SELECT product.\"product name\" FROM east_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE east_superstore.\"ship mode\" = '[placeholder-type:string]' AND product.region = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products from the 'east_superstore' table that are shipped using a specific shipping mode and belong to a certain region. The placeholders in the WHERE clause represent the shipping mode and the region of the products."
        },
        {
            "sample_id": 2407,
            "vt": "SELECT product.\"product name\" FROM west_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE west_superstore.\"ship mode\" = '[placeholder-type:string]' AND west_superstore.\"ship date\" LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of products from the 'west_superstore' table that were shipped using a specific shipping mode and on a specific shipping date. The placeholders in the WHERE clause represent the shipping mode and the shipping date."
        },
        {
            "sample_id": 2392,
            "vt": "SELECT DISTINCT people.\"customer name\" FROM east_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" WHERE east_superstore.region = '[placeholder-type:string]' AND east_superstore.sales / ([placeholder-type:numeric] - east_superstore.discount) * east_superstore.quantity - east_superstore.profit > [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct names of customers from the 'people' table who have made purchases in the 'east_superstore'. It filters the results based on the specified region and ensures that the total cost of products sold exceeds a certain threshold, calculated using sales, discount, quantity, and profit."
        },
        {
            "sample_id": 2452,
            "vt": "SELECT SUM(central_superstore.profit) FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T2.\"Product ID\" WHERE people.city = '[placeholder-type:string]' AND people.state = '[placeholder-type:string]' AND central_superstore.region = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total profit generated from sales in the 'central_superstore' by customers located in a specific city and state, filtered by the region of the store. It combines data from the 'people', 'central_superstore', and 'product' tables to achieve this."
        },
        {
            "sample_id": 2460,
            "vt": "SELECT CAST(SUM(CASE WHEN central_superstore.discount = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" WHERE central_superstore.region = '[placeholder-type:string]' AND people.state = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of sales from the 'central_superstore' table based on a specific discount condition. It joins the 'people' table to filter results by customer state and region. The placeholders represent the discount value, a numeric multiplier, the region, and the state."
        },
        {
            "sample_id": 2413,
            "vt": "SELECT SUM(east_superstore.sales) FROM east_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE STRFTIME('%Y', east_superstore.\"order date\") = '[placeholder-type:string]' AND product.category = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total sales from the 'east_superstore' table for a specific year and product category. It joins the 'east_superstore' table with the 'product' table to filter sales based on the product category. The placeholders represent the year and the product category to be specified by the user."
        },
        {
            "sample_id": 2421,
            "vt": "SELECT SUM(east_superstore.sales) - SUM(west_superstore.sales) FROM east_superstore INNER JOIN west_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\"",
            "ba": "The virtual table calculates the difference in total sales between the East and West superstores by summing the sales from both regions and subtracting the total sales of the West superstore from that of the East superstore. It uses an inner join to match records based on customer IDs, ensuring that only sales from customers present in both regions are considered."
        },
        {
            "sample_id": 2434,
            "vt": "SELECT SUM(west_superstore.quantity) FROM west_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE product.\"product name\" = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total quantity of a specific product sold from the 'west_superstore' table. It joins the 'west_superstore' table with the 'product' table to filter the results based on the product name provided by the user."
        },
        {
            "sample_id": 2428,
            "vt": "SELECT DISTINCT STRFTIME('%J', central_superstore.\"ship date\") - STRFTIME('%J', central_superstore.\"order date\") FROM central_superstore WHERE central_superstore.\"order id\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the shipment time for a specific order in the 'central_superstore' table by finding the difference in days between the 'ship date' and 'order date'. The placeholder in the WHERE clause represents the unique identifier for the order."
        },
        {
            "sample_id": 2361,
            "vt": "SELECT product.\"product name\" FROM east_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" ORDER BY (east_superstore.sales / ([placeholder-type:numeric] - east_superstore.discount)) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of products from the 'product' table that are sold in the 'east_superstore'. It retrieves product names by joining the 'east_superstore' and 'product' tables based on the product ID. The results are ordered by the calculated original price of the products, which is derived from sales and discount values, and limits the output to a specified number of entries."
        },
        {
            "sample_id": 2353,
            "vt": "SELECT DISTINCT people.\"customer name\" FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T2.\"Product ID\" WHERE product.\"product name\" = '[placeholder-type:string]'",
            "ba": "The virtual table lists the unique names of customers from the 'people' table who have made purchases of a specific product. It joins the 'people' table with the 'central_superstore' table to link customer information with their orders, and further joins with the 'product' table to filter based on the product name."
        },
        {
            "sample_id": 2400,
            "vt": "SELECT SUM((east_superstore.sales / ([placeholder-type:numeric] - east_superstore.discount)) * east_superstore.quantity - east_superstore.profit) FROM east_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T1.\"Product ID\" = T3.\"Product ID\" AND T1.Region = T3.Region WHERE east_superstore.region = '[placeholder-type:string]' AND people.\"customer name\" = '[placeholder-type:string]' AND STRFTIME('%Y', east_superstore.\"order date\") = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total cost of products sold in the 'east_superstore' by summing up the adjusted sales for each product. The calculation considers the sales amount adjusted for discounts, multiplied by the quantity sold, and subtracts the profit. The query filters results based on the specified region, customer name, and order date, ensuring that only relevant records are included in the total cost calculation."
        },
        {
            "sample_id": 2381,
            "vt": "SELECT SUM(west_superstore.sales) FROM west_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE product.\"product name\" = '[placeholder-type:string]' AND west_superstore.region = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total sales from the 'west_superstore' table for a specific product and region. It joins the 'west_superstore' table with the 'product' table to filter the results based on the product name and the region specified by the user."
        },
        {
            "sample_id": 2349,
            "vt": "SELECT DISTINCT central_superstore.\"order id\" FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" WHERE people.\"customer name\" = '[placeholder-type:string]' GROUP BY central_superstore.\"product id\" HAVING COUNT(central_superstore.\"product id\") > [placeholder-type:numeric]",
            "ba": "The virtual table lists unique order IDs from the 'central_superstore' table for customers whose names match a specified name. It joins the 'people' table to filter customers based on their name and groups the results by product ID, ensuring that only those orders with a count of products greater than a specified number are included."
        },
        {
            "sample_id": 2395,
            "vt": "SELECT SUM(west_superstore.profit) + SUM(east_superstore.profit) + SUM(central_superstore.profit) + SUM(south_superstore.profit) FROM west_superstore INNER JOIN east_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN central_superstore AS T3 ON T3.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN south_superstore AS T4 ON T4.\"Customer ID\" = T3.\"Customer ID\" INNER JOIN product AS T5 ON T5.\"Product ID\" = T4.\"Product ID\" WHERE product.\"product name\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total profit generated from products sold across multiple superstore locations (west, east, central, and south) for a specific product. It aggregates the profits from each superstore by joining them on the customer ID and filtering by the product name."
        },
        {
            "sample_id": 2363,
            "vt": "SELECT SUM(central_superstore.quantity) FROM central_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE product.\"product name\" = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total quantity of a specific product sold from the 'central_superstore' table. It joins the 'central_superstore' table with the 'product' table to filter the results based on the product name provided by the user."
        },
        {
            "sample_id": 2398,
            "vt": "SELECT subquery_q0.east, (SELECT COUNT(\"Order ID\") FROM west_superstore WHERE \"Order Date\" LIKE '2015%') FROM (SELECT COUNT(east_superstore.\"order id\"), (SELECT COUNT(east_superstore.\"order id\") FROM west_superstore WHERE \"Order Date\" LIKE '2015%') FROM east_superstore WHERE \"Order Date\" LIKE '2015%')",
            "ba": "The virtual table summarizes the count of orders from the 'east_superstore' and compares it with the count of orders from the 'west_superstore' for the year 2015. It uses subqueries to calculate the total number of orders in both stores for that specific year."
        },
        {
            "sample_id": 2355,
            "vt": "SELECT SUM(central_superstore.quantity) FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T2.\"Product ID\" WHERE people.\"customer name\" = '[placeholder-type:string]' AND product.\"product name\" = '[placeholder-type:string]' AND central_superstore.\"order date\" = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total quantity of products ordered by a specific customer on a specific order date from the 'central_superstore'. It joins the 'people' table to filter by customer name and the 'product' table to filter by product name, ensuring that only relevant records are included in the calculation."
        },
        {
            "sample_id": 2422,
            "vt": "SELECT DISTINCT product.\"product name\" FROM central_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE product.region = '[placeholder-type:string]' AND central_superstore.profit < [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct product names from the 'product' table that are associated with orders in the 'central_superstore' table. It filters the results based on a specific region and ensures that only products with a profit less than a specified numeric value are included."
        },
        {
            "sample_id": 2401,
            "vt": "SELECT DISTINCT people.\"customer name\", people.city, people.country FROM west_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T1.\"Product ID\" WHERE product.\"product name\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct customer names, cities, and countries from the 'people' table who have purchased a specific product from the 'west_superstore'. The query joins the 'west_superstore' with the 'people' and 'product' tables to filter results based on the product name."
        },
        {
            "sample_id": 2402,
            "vt": "SELECT DISTINCT central_superstore.\"ship date\", product.\"product name\" FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T2.\"Product ID\" WHERE people.\"customer name\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct shipment dates and product names from the 'central_superstore' table, filtered by a specific customer's name from the 'people' table. The placeholders in the WHERE clause represent the customer's name."
        },
        {
            "sample_id": 2423,
            "vt": "SELECT DISTINCT product.\"product name\", west_superstore.\"ship mode\" FROM west_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE product.region = '[placeholder-type:string]' ORDER BY west_superstore.\"ship date\" - west_superstore.\"order date\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of distinct product names and their corresponding shipping modes from the 'west_superstore' table. It filters the results based on the specified region from the 'product' table and orders the results by the shipment time, which is calculated as the difference between the ship date and order date. The results are limited to a specified number of entries."
        },
        {
            "sample_id": 2394,
            "vt": "SELECT DISTINCT people.\"customer name\" FROM central_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T1.\"Product ID\" WHERE product.\"product name\" = '[placeholder-type:string]' AND product.region = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct names of customers from the 'people' table who have made purchases of a specific product in a specified region. The placeholders in the WHERE clause represent the product's name and the region where the product is sold."
        },
        {
            "sample_id": 2456,
            "vt": "SELECT product.\"product name\" FROM south_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE product.region = '[placeholder-type:string]' ORDER BY south_superstore.sales LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products sold in the 'south_superstore' that belong to a specific region. The query joins the 'south_superstore' table with the 'product' table to filter products based on their region and orders the results by sales, limiting the number of results returned."
        },
        {
            "sample_id": 2424,
            "vt": "SELECT COUNT(DISTINCT T1.\"Order ID\") FROM central_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE product.\"product name\" = '[placeholder-type:string]' AND product.region = '[placeholder-type:string]' AND central_superstore.\"ship mode\" = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct order IDs from the 'central_superstore' table, joining it with the 'product' table to filter based on specific product name, region, and shipping mode. The placeholders represent the product name, region, and shipping mode that can be specified by the user."
        },
        {
            "sample_id": 2372,
            "vt": "SELECT product.\"product name\" FROM south_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE south_superstore.\"ship date\" = '[placeholder-type:string]' AND product.region = '[placeholder-type:string]' AND south_superstore.\"order date\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of products sold from the 'south_superstore' table, filtered by specific shipment and order dates, as well as the region of the product. The placeholders in the WHERE clause represent the ship date, order date, and product region."
        },
        {
            "sample_id": 2384,
            "vt": "SELECT people.city, people.state FROM west_superstore INNER JOIN east_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN central_superstore AS T3 ON T3.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN south_superstore AS T4 ON T4.\"Customer ID\" = T3.\"Customer ID\" INNER JOIN people AS T5 ON T5.\"Customer ID\" = T4.\"Customer ID\" ORDER BY east_superstore.sales LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the city and state of customers from the 'people' table by joining multiple superstore tables (west, east, central, and south) based on the customer ID. The results are ordered by sales from the east superstore and limited to a specified number of records."
        },
        {
            "sample_id": 2388,
            "vt": "SELECT DISTINCT people.\"customer name\" FROM south_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T1.\"Product ID\" WHERE south_superstore.region = '[placeholder-type:string]' AND product.\"product name\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct names of customers from the 'people' table who have made purchases in the 'south_superstore' based on a specific region and product name. The placeholders in the WHERE clause represent the region and product name that can be specified by the user."
        },
        {
            "sample_id": 2415,
            "vt": "SELECT CAST(SUM(CASE WHEN product.category = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(product.category) FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T2.\"Product ID\"",
            "ba": "The virtual table calculates a weighted average of sales for a specific product category from the 'central_superstore' table, while joining with the 'people' and 'product' tables to filter by customer and product details. The placeholders represent the product category, sales values, and a numeric factor for the calculation."
        },
        {
            "sample_id": 2427,
            "vt": "SELECT people.segment FROM east_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T1.\"Product ID\" WHERE east_superstore.region = '[placeholder-type:string]' ORDER BY (east_superstore.sales / ([placeholder-type:numeric] - east_superstore.discount)) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the segments of customers from the 'people' table who have made purchases in the 'east_superstore' based on a specific region. The query joins the 'east_superstore' with the 'people' and 'product' tables to filter and retrieve customer segments, while also ordering the results based on sales adjusted for discount, with a limit on the number of results returned."
        },
        {
            "sample_id": 2348,
            "vt": "SELECT COUNT(DISTINCT T2.\"Order ID\") FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" WHERE people.\"customer name\" = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct orders made by a specific customer from the 'central_superstore' table. It joins the 'people' table to filter the results based on the customer's name, ensuring that only orders associated with that customer are counted."
        },
        {
            "sample_id": 2383,
            "vt": "SELECT product.\"product name\" FROM central_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE central_superstore.\"order date\" = '[placeholder-type:string]' AND central_superstore.\"ship date\" = '[placeholder-type:string]' AND product.region = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of products from the 'product' table that were ordered from the 'central_superstore' on a specific order date and shipped on a specific ship date, filtered by the region of the product. The placeholders in the WHERE clause represent the order date, ship date, and region respectively."
        },
        {
            "sample_id": 2445,
            "vt": "SELECT DISTINCT product.\"product name\" FROM east_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE east_superstore.\"order id\" = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct product names from the 'product' table that are associated with a specific order in the 'east_superstore' table. The placeholder in the WHERE clause represents the unique identifier for the order."
        },
        {
            "sample_id": 2352,
            "vt": "SELECT SUM(central_superstore.quantity) FROM central_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE product.\"product name\" = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total quantity of a specific product sold from the 'central_superstore' table. It joins the 'central_superstore' table with the 'product' table to filter the results based on the product name provided by the user. The placeholder in the WHERE clause represents the name of the product being queried."
        },
        {
            "sample_id": 2378,
            "vt": "SELECT CAST(SUM(CASE WHEN product.category = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(west_superstore.quantity) FROM west_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE product.region = '[placeholder-type:string]' AND west_superstore.\"ship mode\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted sum of sales for a specific product category from the 'west_superstore' table, adjusting for the quantity sold. It joins the 'west_superstore' table with the 'product' table to filter by region and shipping mode. The placeholders represent the product category, region, and shipping mode, allowing users to specify their desired values."
        },
        {
            "sample_id": 2357,
            "vt": "SELECT DISTINCT central_superstore.sales / ([placeholder-type:numeric] - central_superstore.discount) FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T2.\"Product ID\" WHERE people.\"customer name\" = '[placeholder-type:string]' AND product.\"product name\" = '[placeholder-type:string]' AND central_superstore.\"order date\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the original price of products sold in the central superstore by joining the 'people', 'central_superstore', and 'product' tables. It filters the results based on a specific customer's name, a specific product's name, and the order date. The original price is derived from the sales amount divided by (1 minus the discount)."
        },
        {
            "sample_id": 2397,
            "vt": "SELECT DISTINCT product.\"product name\" FROM west_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T1.\"Product ID\" WHERE people.city = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct product names from the 'west_superstore' table, which contains order details, by joining it with the 'people' table to filter based on the city of customers. It also joins with the 'product' table to access product information. The placeholder in the WHERE clause represents the specific city of the customers."
        },
        {
            "sample_id": 2457,
            "vt": "SELECT east_superstore.sales, east_superstore.profit, product.\"sub-category\" FROM east_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE east_superstore.\"order id\" = '[placeholder-type:string]' AND product.region = '[placeholder-type:string]'",
            "ba": "The virtual table describes the sales and profit of products from the 'east_superstore' table, along with their sub-category from the 'product' table. The placeholders in the WHERE clause represent the specific order ID and the region of the products."
        },
        {
            "sample_id": 2385,
            "vt": "SELECT people.\"customer name\" FROM east_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" WHERE east_superstore.region = '[placeholder-type:string]' ORDER BY east_superstore.profit LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of customers from the 'people' table who have made purchases in the 'east_superstore' based on a specific region. The query joins the 'east_superstore' and 'people' tables on the customer ID to filter and retrieve customer names, with a limit on the number of results based on profit."
        },
        {
            "sample_id": 2405,
            "vt": "SELECT product.category FROM south_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" ORDER BY south_superstore.profit LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the categories of products sold in the 'south_superstore' by joining it with the 'product' table. The results are ordered by the profit generated from these products, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 2347,
            "vt": "SELECT COUNT(DISTINCT T2.\"Order ID\") FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" WHERE people.\"customer name\" = '[placeholder-type:string]' AND central_superstore.\"ship mode\" = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct order IDs from the 'central_superstore' table for customers in the 'people' table. It filters the results based on a specific customer name and the shipping mode used for the orders."
        },
        {
            "sample_id": 2453,
            "vt": "SELECT DISTINCT people.\"customer name\" FROM east_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" WHERE east_superstore.\"ship date\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct names of customers from the 'people' table who have placed orders in the 'east_superstore' on a specific shipment date. The placeholder in the WHERE clause represents the shipment date for which we want to retrieve customer names."
        },
        {
            "sample_id": 2390,
            "vt": "SELECT people.\"customer name\" FROM west_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" WHERE west_superstore.region = '[placeholder-type:string]' ORDER BY west_superstore.discount LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of customers from the 'people' table who have made purchases in the 'west_superstore' based on a specific region. The query filters the results by the region of the customers and orders them by the discount applied to their purchases, limiting the number of results returned."
        },
        {
            "sample_id": 2345,
            "vt": "SELECT DISTINCT product.\"product name\" FROM central_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE central_superstore.\"order id\" = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct product names from the 'product' table that are associated with a specific order in the 'central_superstore' table. The query uses an inner join to connect the two tables based on the product ID, ensuring that only products related to the specified order ID are retrieved."
        },
        {
            "sample_id": 2403,
            "vt": "SELECT COUNT(south_superstore.\"order id\") FROM south_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE south_superstore.\"ship mode\" = '[placeholder-type:string]' AND product.category = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of orders from the 'south_superstore' table that match a specific shipping mode and product category. It joins the 'south_superstore' table with the 'product' table to filter the results based on the product category."
        },
        {
            "sample_id": 2375,
            "vt": "SELECT SUM(east_superstore.quantity), product.\"product name\" FROM east_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE east_superstore.\"ship date\" = '[placeholder-type:string]' AND product.region = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total quantity of products sold from the 'east_superstore' table, grouped by product name. It filters the results based on a specific shipment date and the region of the products. The placeholders represent the shipment date and the region, allowing users to specify these values when generating their queries."
        },
        {
            "sample_id": 2448,
            "vt": "SELECT DISTINCT people.\"customer name\" FROM west_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" WHERE west_superstore.\"order date\" = '[placeholder-type:string]' AND west_superstore.discount = [placeholder-type:numeric] AND west_superstore.region = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct names of customers from the 'people' table who have placed orders in the 'west_superstore' table. The query filters the results based on a specific order date, discount value, and region, using placeholders for these criteria."
        },
        {
            "sample_id": 2454,
            "vt": "SELECT product.\"product name\" FROM central_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE product.region = '[placeholder-type:string]' AND STRFTIME('%Y', central_superstore.\"order date\") = '[placeholder-type:string]' ORDER BY central_superstore.profit LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products from the 'central_superstore' table that are associated with a specific region and year. The query joins the 'central_superstore' and 'product' tables based on the product ID, filtering results by the specified region and year of the order date. The results are ordered by profit, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 2431,
            "vt": "SELECT DISTINCT product.\"product name\" FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T2.\"Product ID\" WHERE people.\"customer name\" = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct product names from the 'product' table that have been purchased by a specific customer. It joins the 'people' table to identify the customer based on their name and the 'central_superstore' table to link the customer to their orders, ensuring that only products associated with that customer are included."
        },
        {
            "sample_id": 2436,
            "vt": "SELECT central_superstore.sales / ([placeholder-type:numeric] - central_superstore.discount) FROM central_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE product.\"product name\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the original price of products sold in the 'central_superstore' by dividing the sales amount by the difference between 1 and the discount rate. It joins the 'central_superstore' table with the 'product' table to filter results based on a specific product name. The placeholders represent the discount rate and the product name, allowing users to specify these values when generating their queries."
        },
        {
            "sample_id": 2369,
            "vt": "SELECT DISTINCT product.\"product name\" FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T2.\"Product ID\" WHERE people.\"customer name\" = '[placeholder-type:string]' AND product.region = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct product names from the 'product' table that are associated with customers from the 'people' table who have a specific name and belong to a specified region. The query joins the 'people' table with the 'central_superstore' table based on customer IDs, and then joins the resulting table with the 'product' table based on product IDs. The placeholders in the WHERE clause represent the customer's name and the product's region."
        },
        {
            "sample_id": 2354,
            "vt": "SELECT COUNT(DISTINCT T1.\"Customer Name\") FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T2.\"Product ID\" WHERE product.\"product name\" = '[placeholder-type:string]' AND people.segment = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct names of customers from the 'people' table who have made purchases in the 'central_superstore' table for a specific product and belong to a certain customer segment. The placeholders represent the product name and the customer segment."
        },
        {
            "sample_id": 2425,
            "vt": "SELECT people.\"customer name\" FROM east_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" WHERE people.segment = '[placeholder-type:string]' AND people.state = '[placeholder-type:string]' AND people.region = '[placeholder-type:string]' AND STRFTIME('%Y', east_superstore.\"order date\") = '[placeholder-type:string]' GROUP BY people.\"customer name\" ORDER BY COUNT(people.\"customer name\") LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of customers from the 'people' table who have placed orders in the 'east_superstore' table. It filters customers based on their segment, state, and region, and also restricts the results to a specific year of order date. The results are grouped by customer name and ordered by the count of orders, with a limit on the number of results returned."
        },
        {
            "sample_id": 2364,
            "vt": "SELECT central_superstore.\"order id\" FROM central_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE product.\"product name\" = '[placeholder-type:string]' GROUP BY central_superstore.\"order id\" ORDER BY SUM((central_superstore.sales / ([placeholder-type:numeric] - central_superstore.discount)) * central_superstore.quantity - central_superstore.profit) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the order IDs from the 'central_superstore' table, joining it with the 'product' table to filter based on a specific product name. It groups the results by order ID and orders them based on the total cost of products sold, calculated using sales, discount, quantity, and profit. The placeholders allow for dynamic input of the product name and a limit on the number of results returned."
        },
        {
            "sample_id": 2433,
            "vt": "SELECT DISTINCT central_superstore.profit FROM central_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE product.\"product name\" = '[placeholder-type:string]'",
            "ba": "The virtual table displays the distinct profits from the 'central_superstore' table for products that match a specific product name. The query joins the 'central_superstore' table with the 'product' table to filter results based on the product name provided by the user."
        },
        {
            "sample_id": 2362,
            "vt": "SELECT product.\"product name\" FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T2.\"Product ID\" WHERE people.\"customer name\" = '[placeholder-type:string]' ORDER BY central_superstore.\"order date\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products purchased by a specific customer from the 'central_superstore' table. It joins the 'people' table to filter by the customer's name and the 'product' table to retrieve the product names. The results are ordered by the order date, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 2440,
            "vt": "SELECT east_superstore.\"order id\" FROM east_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" WHERE people.city = '[placeholder-type:string]' AND people.state = '[placeholder-type:string]' ORDER BY east_superstore.profit LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the order IDs from the 'east_superstore' table for customers located in a specific city and state. It joins the 'east_superstore' table with the 'people' table to filter the results based on the customer's city and state. The results are ordered by profit, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 2408,
            "vt": "SELECT DISTINCT product.category FROM east_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T1.\"Product ID\" LEFT JOIN central_superstore AS T4 ON T3.\"Product ID\" = T4.\"Product ID\" WHERE people.\"customer name\" = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct product categories from the 'east_superstore' table, joining with the 'people' table to filter by a specific customer's name. It also includes a left join with the 'central_superstore' to potentially gather additional product information, although it primarily focuses on the east region's sales data."
        },
        {
            "sample_id": 2371,
            "vt": "SELECT SUM(central_superstore.profit) FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" WHERE people.\"customer name\" = '[placeholder-type:string]' AND people.region = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total profit generated from orders placed by a specific customer in a specific region. It combines data from the 'people' table, which contains customer information, and the 'central_superstore' table, which records order details. The query filters results based on the customer's name and their region, allowing for a focused analysis of profits associated with that customer."
        },
        {
            "sample_id": 2443,
            "vt": "SELECT COUNT(DISTINCT T2.\"Order ID\") FROM people INNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" WHERE people.state = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct order IDs from the 'central_superstore' table for customers located in a specific state. It joins the 'people' table to filter customers based on their state, ensuring that only unique orders from that state are considered."
        },
        {
            "sample_id": 2439,
            "vt": "SELECT COUNT(product.category) FROM east_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE east_superstore.\"ship mode\" = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of products in a specific category from the 'east_superstore' table, filtered by the shipping mode. It joins the 'east_superstore' table with the 'product' table to access the product categories associated with each order."
        },
        {
            "sample_id": 2365,
            "vt": "SELECT DISTINCT product.\"product name\" FROM west_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T1.\"Product ID\" WHERE people.\"customer name\" = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct product names from the 'west_superstore' table, which contains order details, by joining it with the 'people' table to filter based on a specific customer's name. The join is also made with the 'product' table to access product details."
        },
        {
            "sample_id": 2432,
            "vt": "SELECT people.\"customer name\" FROM south_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T1.\"Product ID\" WHERE product.\"product name\" = '[placeholder-type:string]' GROUP BY people.\"customer name\" ORDER BY COUNT(people.\"customer name\") LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of customers from the 'people' table who have purchased a specific product from the 'south_superstore'. It joins the 'south_superstore' with the 'people' and 'product' tables to filter based on the product name and groups the results by customer name, ordering them by the count of purchases. The placeholders represent the product name and the limit on the number of results returned."
        },
        {
            "sample_id": 2449,
            "vt": "SELECT DISTINCT central_superstore.\"order id\" FROM central_superstore INNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\" WHERE product.\"product name\" = '[placeholder-type:string]' AND central_superstore.\"order date\" = '[placeholder-type:string]'",
            "ba": "The virtual table lists unique order IDs from the 'central_superstore' table for orders that include a specific product name and were placed on a specific order date. The placeholders represent the product name and the order date, allowing users to filter results based on their input."
        },
        {
            "sample_id": 2437,
            "vt": "SELECT DISTINCT product.\"product name\" FROM east_superstore INNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" INNER JOIN product AS T3 ON T3.\"Product ID\" = T1.\"Product ID\" WHERE people.\"customer name\" = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct product names from the 'east_superstore' table, which contains order details. It joins with the 'people' table to filter based on customer information and the 'product' table to retrieve product names. The placeholder in the WHERE clause represents the specific customer's name."
        }
    ],
    "mental_health_survey": [
        {
            "sample_id": 4620,
            "vt": "SELECT answer.answertext FROM answer WHERE answer.questionid = [placeholder-type:numeric] AND answer.surveyid = [placeholder-type:numeric] GROUP BY answer.answertext ORDER BY COUNT(answer.answertext) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves specific answer texts from the 'answer' table based on a given question ID and survey ID. It groups the results by the answer text and orders them by the count of occurrences, limiting the results to a specified number."
        },
        {
            "sample_id": 4596,
            "vt": "SELECT MAX(answer.userid) - MIN(answer.userid) + [placeholder-type:numeric] FROM answer WHERE answer.questionid = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the difference between the maximum and minimum user IDs who provided answers to a specific question, adding a placeholder for a numeric value to the result. This allows for understanding the range of user participation for that question."
        },
        {
            "sample_id": 4574,
            "vt": "SELECT COUNT(answer.userid) FROM answer INNER JOIN (SELECT T2.questionid FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T1.SurveyID = 2019 AND T2.questionid = 6 AND T1.AnswerText LIKE 'Yes') AS T2 ON T1.QuestionID = T2.questionid WHERE answer.surveyid = [placeholder-type:numeric] AND question.questionid = [placeholder-type:numeric] AND answer.answertext LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users who answered 'Yes' to a specific question in a given survey year. It joins the 'answer' table with a subquery that filters for a specific question ID and survey year, ensuring that only relevant answers are counted."
        },
        {
            "sample_id": 4586,
            "vt": "SELECT COUNT(DISTINCT T1.UserID) FROM answer INNER JOIN Survey AS T2 ON T1.SurveyID = T2.SurveyID WHERE survey.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of users who provided answers to surveys with a specific description. It joins the 'answer' table with the 'survey' table based on the survey ID, ensuring that only users who participated in surveys matching the given description are counted."
        },
        {
            "sample_id": 4595,
            "vt": "SELECT question.questionid FROM question WHERE question.questiontext LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of questions from the 'question' table that match a specific text pattern. The placeholder in the LIKE clause allows for flexible searching of question text."
        },
        {
            "sample_id": 4577,
            "vt": "SELECT COUNT(answer.userid) FROM answer INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE question.questionid = [placeholder-type:numeric] AND answer.answertext LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of unique users who provided a specific answer to a particular question in the survey. It joins the 'answer' table with the 'question' table to filter results based on the question ID and the answer text, using placeholders for dynamic input."
        },
        {
            "sample_id": 4575,
            "vt": "SELECT answer.surveyid FROM answer INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE answer.surveyid BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND question.questionid = [placeholder-type:numeric] AND answer.answertext LIKE '[placeholder-type:string]' GROUP BY answer.surveyid ORDER BY COUNT(answer.userid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves survey IDs from the 'answer' table by joining it with the 'question' table based on question IDs. It filters the results to include only those surveys that fall within a specified range of years, match a specific question ID, and have answers that contain a certain text pattern. The results are grouped by survey ID and ordered by the count of unique users who provided answers, with a limit on the number of results returned."
        },
        {
            "sample_id": 4582,
            "vt": "SELECT COUNT(answer.questionid) FROM answer WHERE answer.surveyid LIKE [placeholder-type:numeric] GROUP BY answer.questionid ORDER BY COUNT(answer.questionid) > [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of answers for each question in a specific survey, grouping the results by question ID. It filters the results based on the survey year and only includes questions that have a count greater than a specified threshold. The results are limited to a certain number of entries."
        },
        {
            "sample_id": 4615,
            "vt": "SELECT CAST(COUNT(answer.surveyid) AS FLOAT) / [placeholder-type:numeric] FROM answer WHERE answer.surveyid BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of answers provided in surveys over a specified range of survey years. The placeholder in the SELECT statement represents the total number of users, while the placeholders in the WHERE clause define the range of survey years to consider."
        },
        {
            "sample_id": 4576,
            "vt": "SELECT COUNT(*) FROM (SELECT answer.userid FROM question INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID INNER JOIN Survey AS T3 ON T2.SurveyID = T3.SurveyID WHERE survey.description = '[placeholder-type:string]' AND question.questionid = [placeholder-type:numeric] AND answer.answertext = '[placeholder-type:string]' UNION SELECT answer.userid FROM question INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID INNER JOIN Survey AS T3 ON T2.SurveyID = T3.SurveyID WHERE question.questionid = [placeholder-type:numeric] AND answer.answertext = '[placeholder-type:string]' AND survey.description = '[placeholder-type:string]')",
            "ba": "The virtual table counts the number of unique users who provided specific answers to a particular question in a survey, based on the survey's description and the question's ID. It combines results from two queries using a UNION to ensure that all relevant user IDs are considered, regardless of whether they answered the question in the context of the survey description or just by the question ID."
        },
        {
            "sample_id": 4590,
            "vt": "SELECT question.questiontext FROM answer INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid INNER JOIN Survey AS T3 ON T1.SurveyID = T3.SurveyID WHERE survey.description LIKE '[placeholder-type:string]' GROUP BY question.questiontext",
            "ba": "The virtual table retrieves the text of questions from the 'question' table that are associated with surveys matching a specific description. It uses inner joins to connect the 'answer' table with the 'question' and 'survey' tables based on their respective IDs, ensuring that only questions related to the specified survey description are selected. The results are grouped by the question text to avoid duplicates."
        },
        {
            "sample_id": 4608,
            "vt": "SELECT COUNT(DISTINCT T1.UserID) FROM answer INNER JOIN Survey AS T2 ON T1.SurveyID = T2.SurveyID WHERE survey.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of users who provided answers to surveys with a specific description. It joins the 'answer' table with the 'survey' table based on the survey ID, ensuring that only users who participated in surveys matching the given description are counted."
        },
        {
            "sample_id": 4572,
            "vt": "SELECT answer.surveyid, COUNT(answer.userid) FROM answer WHERE answer.questionid = [placeholder-type:numeric] AND answer.surveyid BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] GROUP BY answer.surveyid",
            "ba": "The virtual table summarizes the count of unique users who provided answers to a specific question across a range of survey years. The placeholders represent the question ID and the range of survey years."
        },
        {
            "sample_id": 4583,
            "vt": "SELECT answer.answertext FROM question INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID WHERE question.questiontext = '[placeholder-type:string]' AND answer.surveyid = [placeholder-type:numeric] ORDER BY answer.answertext LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves specific answer texts from the 'answer' table based on a given question text and survey year. It joins the 'question' table to filter answers related to a specific question, and it allows for ordering and limiting the results based on user-defined criteria."
        },
        {
            "sample_id": 4614,
            "vt": "SELECT COUNT(DISTINCT T1.UserID) FROM answer INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE answer.questionid = [placeholder-type:numeric] AND answer.surveyid = [placeholder-type:numeric] AND answer.answertext <= [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of users who provided answers to a specific question in a particular survey, filtering based on the answer text value."
        },
        {
            "sample_id": 4591,
            "vt": "SELECT COUNT(answer.userid) FROM question INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID WHERE answer.surveyid = [placeholder-type:numeric] AND question.questiontext LIKE '[placeholder-type:string]' AND answer.answertext = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of unique users who provided answers to a specific question in a given survey. It joins the 'question' and 'answer' tables based on the question ID, filtering results by the survey year and specific question text, as well as the answer text."
        },
        {
            "sample_id": 4599,
            "vt": "SELECT COUNT(answer.questionid) FROM answer INNER JOIN Survey AS T2 ON T1.SurveyID = T2.SurveyID WHERE survey.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of answers provided for questions in surveys that match a specific description. It joins the 'answer' table with the 'survey' table based on the survey ID, filtering results to include only those surveys that have a particular description."
        },
        {
            "sample_id": 4597,
            "vt": "SELECT COUNT(answer.questionid) FROM answer WHERE answer.userid = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of answers provided by a specific user from the 'answer' table. The placeholder in the WHERE clause represents the unique identifier of the user whose answers are being counted."
        },
        {
            "sample_id": 4610,
            "vt": "SELECT answer.answertext FROM answer INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE question.questionid = [placeholder-type:numeric] AND answer.answertext = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves specific answers from the 'answer' table based on a given question ID and answer text. It joins the 'answer' table with the 'question' table to ensure that the answers correspond to the correct questions."
        },
        {
            "sample_id": 4573,
            "vt": "SELECT answer.userid FROM answer INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE answer.surveyid = [placeholder-type:numeric] AND question.questionid = [placeholder-type:numeric] AND answer.answertext BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the user IDs from the 'answer' table based on specific survey and question criteria. It joins the 'answer' table with the 'question' table to ensure that the answers correspond to the correct questions. The query filters results by a specific survey year and question ID, and also restricts the answer text to a specified range."
        },
        {
            "sample_id": 4617,
            "vt": "SELECT COUNT(answer.answertext) FROM answer INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE answer.questionid = [placeholder-type:numeric] AND answer.surveyid = [placeholder-type:numeric] AND answer.answertext = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of specific answers provided by users for a given question in a particular survey. It joins the 'answer' table with the 'question' table to ensure that the answers correspond to the correct questions, filtering by both the question ID and survey ID, as well as the specific answer text."
        },
        {
            "sample_id": 4593,
            "vt": "SELECT CAST(SUM(answer.answertext) AS FLOAT) / COUNT(answer.userid) FROM question INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID WHERE answer.surveyid = [placeholder-type:numeric] AND question.questiontext LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average of the answer texts for a specific question from a particular survey. It joins the 'question' and 'answer' tables based on the question ID, filtering results by the survey year and the question text."
        },
        {
            "sample_id": 4571,
            "vt": "SELECT COUNT(answer.questionid) FROM answer WHERE answer.questionid = [placeholder-type:numeric] AND answer.answertext LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of answers provided for a specific question identified by its question ID. It filters the answers based on a specific answer text pattern using a placeholder for string values."
        },
        {
            "sample_id": 4601,
            "vt": "SELECT answer.answertext FROM answer INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE question.questiontext = '[placeholder-type:string]' AND answer.userid = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the specific answer text from the 'answer' table by joining it with the 'question' table. It filters the results based on a specific question text and a user ID."
        },
        {
            "sample_id": 4607,
            "vt": "SELECT COUNT(answer.userid) FROM answer INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE question.questiontext LIKE '[placeholder-type:string]' AND answer.answertext = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of unique users who provided a specific answer to a question that matches a given text description. It combines data from the 'answer' and 'question' tables using a join on the question ID, filtering results based on the question text and the answer text provided by the user."
        },
        {
            "sample_id": 4605,
            "vt": "SELECT COUNT(answer.userid) FROM answer INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE question.questiontext LIKE '[placeholder-type:string]' AND answer.answertext = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of unique users who provided a specific answer to a question that matches a given text description. It combines data from the 'answer' and 'question' tables using a join on the question ID, filtering results based on the question text and the answer text provided by the user."
        },
        {
            "sample_id": 4578,
            "vt": "SELECT MAX(answer.answertext), MIN(answer.answertext), (SELECT answer.userid FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T2.questionid = 1 ORDER BY T1.AnswerText LIMIT 1) FROM answer INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE question.questionid = [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the maximum and minimum answer texts for a specific question, along with the user ID of the first answer given for that question. It combines data from the 'answer' and 'question' tables, filtering by a specific question ID."
        },
        {
            "sample_id": 4594,
            "vt": "SELECT CAST((SELECT COUNT(answer.userid) FROM Question AS T1 INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID WHERE T2.SurveyID = 2019 AND T1.questiontext LIKE 'Do you currently have a mental health disorder?' AND T2.AnswerText = 'Yes') - (SELECT COUNT(answer.userid) FROM Question AS T1 INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID WHERE T2.SurveyID = 2016 AND T1.questiontext LIKE 'Do you currently have a mental health disorder?' AND T2.AnswerText = 'Yes') AS FLOAT) * [placeholder-type:numeric] / (SELECT COUNT(answer.userid) FROM Question AS T1 INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID WHERE T2.SurveyID = 2016 AND T1.questiontext LIKE 'Do you currently have a mental health disorder?' AND T2.AnswerText = 'Yes')",
            "ba": "The virtual table calculates the change in the number of users who reported having a mental health disorder between two survey years, 2016 and 2019. It does this by counting the number of users who answered 'Yes' to the specific question in both years and then computes the difference. The result is then scaled by a placeholder numeric value, allowing for further manipulation or analysis of the change in responses."
        },
        {
            "sample_id": 4609,
            "vt": "SELECT COUNT(answer.userid) FROM answer INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE question.questiontext LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of unique users who provided answers to a specific question in the survey. It joins the 'answer' table with the 'question' table to filter based on the question text, using a placeholder for the specific question text."
        },
        {
            "sample_id": 4616,
            "vt": "SELECT COUNT(answer.userid) FROM answer INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE answer.questionid = [placeholder-type:numeric] AND answer.surveyid = [placeholder-type:numeric] AND answer.answertext = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of unique users who provided a specific answer to a particular question in a given survey. It joins the 'answer' table with the 'question' table to ensure that the answers correspond to the correct questions, filtering by the question ID, survey ID, and answer text using placeholders for numeric values."
        }
    ],
    "formula_1": [
        {
            "sample_id": 10374,
            "vt": "SELECT DISTINCT constructors.name FROM results INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId WHERE results.rank = [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of unique constructor names from the 'results' table, filtered by the rank of the race results. The query joins the 'results' table with the 'constructors' table to retrieve the constructor names associated with specific race results that meet the rank criteria."
        },
        {
            "sample_id": 10396,
            "vt": "SELECT races.year FROM results INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE NOT results.fastestlaptime IS NULL",
            "ba": "The virtual table retrieves the years of races from the 'results' table where there is a recorded fastest lap time. It joins the 'results' table with the 'races' table to ensure that only relevant race years are selected, specifically filtering for results that have a non-null fastest lap time."
        },
        {
            "sample_id": 10440,
            "vt": "SELECT AVG(pitstops.milliseconds) FROM pitstops INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE drivers.forename = '[placeholder-type:string]' AND drivers.surname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average duration of pit stops for a specific driver identified by their first and last name. It retrieves data from the 'pitstops' table and joins it with the 'drivers' table to filter the results based on the driver's forename and surname."
        },
        {
            "sample_id": 10368,
            "vt": "SELECT circuits.lat, circuits.lng FROM circuits WHERE circuits.country = '[placeholder-type:string]'",
            "ba": "The virtual table provides the latitude and longitude of circuits from the 'circuits' table that are located in a specific country. The placeholder in the WHERE clause represents the name of the country."
        },
        {
            "sample_id": 10411,
            "vt": "SELECT results.time FROM results INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE races.name = '[placeholder-type:string]' AND races.year = [placeholder-type:numeric] AND results.time LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the race times from the 'results' table for races that match a specific name and year. It uses an inner join to connect the 'results' table with the 'races' table based on the race ID. The placeholders allow users to specify the race name, year, and a pattern for the time."
        },
        {
            "sample_id": 10412,
            "vt": "SELECT constructors.constructorref, constructors.url FROM results INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN constructors AS T3 ON T1.constructorId = T3.constructorId WHERE races.name = '[placeholder-type:string]' AND races.year = [placeholder-type:numeric] AND results.time LIKE '[placeholder-type:string]'",
            "ba": "The virtual table provides a view of constructor references and their associated URLs from the 'results' table, filtered by specific race names and years, as well as a condition on the race results time."
        },
        {
            "sample_id": 10316,
            "vt": "SELECT laptimes.milliseconds, drivers.forename, drivers.surname, races.name FROM drivers INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId ORDER BY laptimes.milliseconds LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table presents the lap times of drivers in milliseconds, along with their first and last names, and the name of the race they participated in. The data is sourced from the 'drivers', 'laptimes', and 'races' tables, where drivers are linked to their lap times and the corresponding race details. The results are ordered by lap time in ascending order, and a limit is applied to restrict the number of records returned based on a specified numeric value."
        },
        {
            "sample_id": 10389,
            "vt": "SELECT COUNT(*) FROM (SELECT drivers.nationality FROM drivers AS T1 ORDER BY JULIANDAY(T1.dob) DESC LIMIT 3) AS t3 WHERE (SELECT T1.nationality FROM drivers AS T1 ORDER BY JULIANDAY(T1.dob) DESC LIMIT 3).nationality = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of drivers from a specific nationality who are among the three most recently born drivers in the 'drivers' table. It first selects the nationalities of the three youngest drivers, and then filters this selection to count how many of them belong to the specified nationality."
        },
        {
            "sample_id": 10342,
            "vt": "SELECT DISTINCT races.year FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE circuits.name = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct years of races held at a specific circuit, identified by its name. It retrieves this information by joining the 'circuits' table with the 'races' table based on the circuit ID, ensuring that only the years corresponding to the specified circuit name are included."
        },
        {
            "sample_id": 10324,
            "vt": "SELECT races.name FROM races INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE drivers.forename = '[placeholder-type:string]' AND drivers.surname = '[placeholder-type:string]' AND driverstandings.position < [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of races from the 'races' table where a specific driver, identified by their first and last name, has achieved a position that is less than a specified numeric value in the driver standings. The query involves joining the 'races' table with the 'driverStandings' and 'drivers' tables to filter results based on the driver's name and their standing position."
        },
        {
            "sample_id": 10272,
            "vt": "SELECT DISTINCT races.name FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE circuits.country = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct names of races that take place at circuits located in a specific country. It retrieves data from the 'circuits' table and joins it with the 'races' table based on the circuit ID, filtering the results by the country specified."
        },
        {
            "sample_id": 10313,
            "vt": "SELECT drivers.forename, drivers.surname FROM races INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE races.name = '[placeholder-type:string]' AND races.year = [placeholder-type:numeric] ORDER BY driverstandings.position",
            "ba": "The virtual table describes the first names and last names of drivers from the 'drivers' table who participated in a specific race, identified by its name and year. The query joins the 'races' table with the 'driverStandings' table to filter the results based on the race name and year, and orders the results by the driver's position in the standings."
        },
        {
            "sample_id": 10301,
            "vt": "SELECT drivers.nationality FROM drivers INNER JOIN results AS T2 ON T2.driverId = T1.driverId ORDER BY results.fastestlapspeed LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the nationalities of drivers from the 'drivers' table who have participated in races, along with their fastest lap speeds from the 'results' table. The results are ordered by the fastest lap speed, and a limit is applied to restrict the number of records returned based on a specified numeric value."
        },
        {
            "sample_id": 10377,
            "vt": "WITH time_in_seconds AS (SELECT T2.year, T2.raceId, T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTRING(T1.time, 1, 1) AS FLOAT) * 3600) + (CAST(SUBSTRING(T1.time, 3, 2) AS FLOAT) * 60) + CAST(SUBSTRING(T1.time, 6, 2) AS FLOAT) + CAST(SUBSTRING(T1.time, 9) AS FLOAT) / 1000 ELSE 0 END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE NOT T1.time IS NULL), champion_time AS (SELECT year, raceId, time_seconds FROM time_in_seconds WHERE positionOrder = 1) SELECT races.year, AVG(None.time_seconds) FROM champion_time WHERE races.year < [placeholder-type:numeric] GROUP BY races.year HAVING NOT AVG(None.time_seconds) IS NULL",
            "ba": "The virtual table calculates the average winning time in seconds for races held in years prior to a specified year. It first creates a temporary table that converts the race results' time from a string format into seconds for the winning positions. Then, it filters this data to only include the winning times and computes the average for each year, excluding any years where the average is null."
        },
        {
            "sample_id": 10296,
            "vt": "SELECT drivers.forename, drivers.surname FROM races INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE races.year = [placeholder-type:numeric] AND races.name = '[placeholder-type:string]' AND results.position = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of drivers who participated in a specific race during a particular year. The placeholders represent the year, race name, and finishing position of the drivers."
        },
        {
            "sample_id": 10318,
            "vt": "SELECT CAST(COUNT(CASE WHEN driverstandings.position <> [placeholder-type:numeric] THEN driverstandings.position END) AS FLOAT) * [placeholder-type:numeric] / COUNT(driverstandings.driverstandingsid) FROM races INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE drivers.surname = '[placeholder-type:string]' AND races.year >= [placeholder-type:numeric]",
            "ba": "The virtual table calculates the weighted position of a driver based on their standings in races over a specified year. It counts the number of races where the driver's position is not equal to a specified value, multiplies this count by a given weight, and divides it by the total number of driver standings entries. The query filters results based on the driver's surname and the year of the races."
        },
        {
            "sample_id": 10269,
            "vt": "SELECT drivers.surname FROM qualifying INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE qualifying.raceid = [placeholder-type:numeric] ORDER BY qualifying.q2 LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the surnames of drivers who participated in a specific race, identified by its race ID. It retrieves this information from the 'qualifying' table, which contains qualifying results, and joins it with the 'drivers' table to get the driver's surname. The results are ordered based on the qualifying times in Q2 and limited to a specified number of entries."
        },
        {
            "sample_id": 10439,
            "vt": "SELECT circuits.lat, circuits.lng FROM laptimes INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId WHERE laptimes.time = '[placeholder-type:string]'",
            "ba": "The virtual table provides the latitude and longitude of circuits based on lap times recorded in races. It joins the 'laptimes' table with the 'races' table to associate each lap time with its corresponding race, and then further joins with the 'circuits' table to retrieve the geographical coordinates of the circuit where the race took place. The placeholder in the WHERE clause represents a specific lap time that is being queried."
        },
        {
            "sample_id": 10347,
            "vt": "SELECT circuits.url FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE races.year = [placeholder-type:numeric] AND races.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides the URL of circuits from the 'circuits' table that are associated with races held in a specific year and with a specific race name. The placeholders allow users to specify the year and the race name they are interested in."
        },
        {
            "sample_id": 10352,
            "vt": "SELECT races.name FROM races WHERE races.raceid IN (SELECT races.raceid FROM results WHERE rank = 1 AND driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton'))",
            "ba": "The virtual table lists the names of races from the 'races' table where the race ID corresponds to races that Lewis Hamilton has won, as indicated by his rank being 1 in the 'results' table."
        },
        {
            "sample_id": 10302,
            "vt": "SELECT (SUM(CASE WHEN results.raceid = [placeholder-type:numeric] THEN results.fastestlapspeed ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN results.raceid = [placeholder-type:numeric] THEN results.fastestlapspeed ELSE [placeholder-type:numeric] END)) * [placeholder-type:numeric] / SUM(CASE WHEN results.raceid = [placeholder-type:numeric] THEN results.fastestlapspeed ELSE [placeholder-type:numeric] END) FROM drivers INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE drivers.forename = '[placeholder-type:string]' AND drivers.surname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a specific metric related to the fastest lap speeds of drivers in a race. It sums the fastest lap speeds for a given race and applies a formula to derive a value based on the difference of these sums, multiplied by a placeholder numeric value, and normalized by the total fastest lap speed for that race. The query filters results based on the driver's first and last names."
        },
        {
            "sample_id": 10328,
            "vt": "SELECT races.name, driverstandings.points FROM races INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE drivers.forename = '[placeholder-type:string]' AND drivers.surname = '[placeholder-type:string]' ORDER BY races.year LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of race names along with the points scored by a specific driver in those races. It retrieves data from the 'races' table and joins it with the 'driverstandings' and 'drivers' tables to filter results based on the driver's first and last names. The results are ordered by the year of the races and limited to a specified number of entries."
        },
        {
            "sample_id": 10392,
            "vt": "SELECT drivers.driverid FROM pitstops INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE drivers.nationality = '[placeholder-type:string]' AND STRFTIME('%Y', drivers.dob) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' ORDER BY pitstops.time LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique identifiers of drivers from the 'drivers' table who have made pit stops. It filters the drivers based on their nationality and their date of birth, ensuring that only those born within a specific range of years are included. The results are ordered by the time of the pit stops, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 10338,
            "vt": "SELECT drivers.surname FROM drivers WHERE drivers.nationality = '[placeholder-type:string]'",
            "ba": "The virtual table describes the surnames of drivers from the 'drivers' table who belong to a specific nationality. The placeholder in the WHERE clause represents the driver's nationality."
        },
        {
            "sample_id": 10432,
            "vt": "SELECT laptimes.time FROM laptimes INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE drivers.forename = '[placeholder-type:string]' AND drivers.surname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the lap times of drivers from the 'laptimes' table based on their first and last names. It uses an inner join to connect the 'laptimes' table with the 'drivers' table, allowing for filtering by the driver's forename and surname."
        },
        {
            "sample_id": 10420,
            "vt": "SELECT SUM(CASE WHEN driverstandings.points = [placeholder-type:numeric] THEN driverstandings.wins ELSE [placeholder-type:numeric] END) FROM driverstandings",
            "ba": "The virtual table calculates the total number of wins for drivers based on their points in the 'driverstandings' table. If a driver's points match a specified value, their wins are included in the sum; otherwise, a placeholder for numeric values is used."
        },
        {
            "sample_id": 10367,
            "vt": "SELECT COUNT(circuits.circuitid) FROM circuits WHERE circuits.location = '[placeholder-type:string]' AND circuits.country = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of circuits from the 'circuits' table that are located in a specific location and country. The placeholders in the WHERE clause represent the location and country names."
        },
        {
            "sample_id": 10418,
            "vt": "SELECT CAST(SUM(CASE WHEN races.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / [placeholder-type:numeric] FROM races WHERE races.date BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average of a specific numeric value from the 'races' table, based on a condition that checks if the race year falls within a specified range. It also filters the results based on a date range, ensuring that only races within the given dates are considered in the calculation."
        },
        {
            "sample_id": 10435,
            "vt": "WITH fastest_lap_times AS (SELECT T1.raceId, T1.fastestLapTime FROM results AS T1 WHERE NOT T1.FastestLapTime IS NULL) SELECT MIN(fastest_lap_times.fastestlaptime) FROM fastest_lap_times INNER JOIN races AS T2 ON fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId WHERE races.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the minimum fastest lap time from the results of races held at a specific circuit. It first creates a temporary table of fastest lap times from the results, filtering out any null values. Then, it joins this temporary table with the races and circuits tables to ensure that the lap times correspond to the correct race and circuit. The final output is the minimum fastest lap time for races that match the specified circuit name."
        },
        {
            "sample_id": 10315,
            "vt": "SELECT drivers.forename, drivers.surname, driverstandings.points FROM races INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE races.name = '[placeholder-type:string]' AND races.year = [placeholder-type:numeric] ORDER BY driverstandings.points LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of drivers along with their first and last names and the points they have earned in a specific race. It retrieves data from the 'drivers' table and the 'driverstandings' table, linking them through the 'races' table to filter results based on the race name and year."
        },
        {
            "sample_id": 10303,
            "vt": "SELECT CAST(COUNT(CASE WHEN NOT results.time IS NULL THEN results.driverid END) AS FLOAT) * [placeholder-type:numeric] / COUNT(results.driverid) FROM races INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE races.date = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage of drivers who completed a race based on the race date. It counts the number of drivers with recorded times and divides it by the total number of drivers for that race, multiplying the result by a specified numeric placeholder."
        },
        {
            "sample_id": 10362,
            "vt": "SELECT COUNT(*) FROM (SELECT results.driverid FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Chinese Grand Prix' AND T2.year = 2008 AND NOT T1.time IS NULL GROUP BY T1.driverId HAVING COUNT(T2.raceId) > 0)",
            "ba": "The virtual table counts the number of unique drivers who participated in the 'Chinese Grand Prix' in the year 2008, ensuring that only those with recorded race times are included."
        },
        {
            "sample_id": 10273,
            "vt": "SELECT DISTINCT constructorstandings.position FROM constructorstandings INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE constructors.name = '[placeholder-type:string]'",
            "ba": "The virtual table displays the distinct positions of constructors from the 'constructorstandings' table, filtered by the constructor's name. The query joins the 'constructorstandings' table with the 'constructors' table to access the constructor's name, using a placeholder for the specific name to be queried."
        },
        {
            "sample_id": 10275,
            "vt": "SELECT DISTINCT races.name FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE circuits.country = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct names of races that take place at circuits located in a specific country. The query joins the 'circuits' table with the 'races' table based on the circuit ID, filtering the results to only include circuits from the specified country."
        },
        {
            "sample_id": 10329,
            "vt": "SELECT DISTINCT races.name, circuits.country FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE races.year = [placeholder-type:numeric] ORDER BY races.date",
            "ba": "The virtual table provides a distinct list of race names along with their corresponding circuit countries from the 'races' and 'circuits' tables. It filters the results based on a specific racing year, represented by a placeholder for numeric values, and orders the results by the race date."
        },
        {
            "sample_id": 10428,
            "vt": "SELECT laptimes.time FROM laptimes ORDER BY (CASE WHEN INSTR(laptimes.time, ':') <> INSTR(SUBSTRING(laptimes.time, INSTR(laptimes.time, ':') + [placeholder-type:numeric]), ':') + INSTR(laptimes.time, ':') THEN CAST(SUBSTRING(laptimes.time, [placeholder-type:numeric], INSTR(laptimes.time, ':') - [placeholder-type:numeric]) AS FLOAT) * [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) + (CAST(SUBSTRING(laptimes.time, INSTR(laptimes.time, ':') - [placeholder-type:numeric] * (INSTR(laptimes.time, ':') = INSTR(SUBSTRING(laptimes.time, INSTR(laptimes.time, ':') + [placeholder-type:numeric]), ':') + INSTR(laptimes.time, ':')), INSTR(laptimes.time, ':') - [placeholder-type:numeric]) AS FLOAT) * [placeholder-type:numeric]) + (CAST(SUBSTRING(laptimes.time, INSTR(laptimes.time, ':') + [placeholder-type:numeric], INSTR(laptimes.time, '.') - INSTR(laptimes.time, ':') - [placeholder-type:numeric]) AS FLOAT)) + (CAST(SUBSTRING(laptimes.time, INSTR(laptimes.time, '.') + [placeholder-type:numeric]) AS FLOAT) / [placeholder-type:numeric]) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves lap times from the 'laptimes' table, ordering them based on a complex calculation that converts the time format into a numeric value for sorting. The placeholders represent various numeric values used in the calculation, allowing users to specify their own parameters for the ordering and limiting of results."
        },
        {
            "sample_id": 10285,
            "vt": "SELECT seasons.url FROM races INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE races.raceid = [placeholder-type:numeric]",
            "ba": "The virtual table provides the URL of the season associated with a specific race. It retrieves this information by joining the 'races' table with the 'seasons' table based on the year of the race, using a placeholder for the race ID."
        },
        {
            "sample_id": 10386,
            "vt": "SELECT drivers.code FROM drivers WHERE drivers.nationality = '[placeholder-type:string]'",
            "ba": "The virtual table describes the codes of drivers from the 'drivers' table who belong to a specific nationality. The placeholder in the WHERE clause represents the driver's nationality."
        },
        {
            "sample_id": 10283,
            "vt": "SELECT drivers.number FROM qualifying INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE qualifying.raceid = [placeholder-type:numeric] AND qualifying.q3 LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the racing numbers of drivers who qualified in the third qualifying session (Q3) for a specific race. It joins the 'qualifying' table with the 'drivers' table to match driver IDs and filter results based on the race ID and the qualifying time in Q3."
        },
        {
            "sample_id": 10410,
            "vt": "SELECT drivers.forename, drivers.surname FROM pitstops INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE drivers.nationality = '[placeholder-type:string]' AND STRFTIME('%Y', drivers.dob) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' GROUP BY drivers.forename, drivers.surname ORDER BY AVG(pitstops.duration) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first names and surnames of drivers from the 'drivers' table who have made pit stops. It filters the results based on the driver's nationality and their date of birth, ensuring that only drivers born within a specific range of years are included. The results are grouped by the driver's name and ordered by the average duration of their pit stops, with a limit on the number of results returned."
        },
        {
            "sample_id": 10371,
            "vt": "SELECT constructors.name FROM constructorstandings INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId ORDER BY constructorstandings.points LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of constructors from the 'constructors' table based on their standings in the 'constructorstandings' table. The results are ordered by the points scored in descending order, and a limit is applied to restrict the number of constructors returned."
        },
        {
            "sample_id": 10293,
            "vt": "SELECT DISTINCT drivers.nationality FROM qualifying INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE qualifying.raceid = [placeholder-type:numeric] AND qualifying.q2 LIKE '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of distinct nationalities of drivers who participated in a specific qualifying session of a race. It retrieves this information by joining the 'qualifying' table with the 'drivers' table based on the driver ID. The query filters the results for a particular race identified by a numeric placeholder and checks if the qualifying time in Q2 matches a specified string pattern."
        },
        {
            "sample_id": 10369,
            "vt": "SELECT COUNT(drivers.driverid) FROM drivers WHERE drivers.nationality = '[placeholder-type:string]' AND STRFTIME('%Y', drivers.dob) > '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of drivers from the 'drivers' table who have a specific nationality and were born after a certain year. The placeholders in the WHERE clause represent the nationality of the drivers and the year of birth."
        },
        {
            "sample_id": 10289,
            "vt": "SELECT drivers.nationality FROM drivers INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE results.raceid = [placeholder-type:numeric] AND NOT results.fastestlaptime IS NULL ORDER BY results.fastestlapspeed LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the nationalities of drivers who participated in a specific race, filtering for those who achieved a fastest lap time. The results are ordered by the speed of their fastest lap, and the number of results returned is limited by a placeholder value."
        },
        {
            "sample_id": 10344,
            "vt": "SELECT races.date, races.time FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE races.year = [placeholder-type:numeric] AND races.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides the race date and time for races held at a specific circuit in a given year. It joins the 'circuits' table with the 'races' table based on the circuit ID, filtering results by the specified year and race name."
        },
        {
            "sample_id": 10307,
            "vt": "SELECT races.name, races.date FROM races WHERE races.year = [placeholder-type:numeric] ORDER BY races.round LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the names and dates of races from the 'races' table that occurred in a specific year. The placeholders in the WHERE clause represent the year of the races and the limit on the number of results to return."
        },
        {
            "sample_id": 10312,
            "vt": "SELECT COUNT(races.circuitid) FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE circuits.name = '[placeholder-type:string]' AND races.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of races associated with a specific circuit and race name from the 'circuits' and 'races' tables. The placeholders represent the circuit name and race name that the user can specify to filter the results accordingly."
        },
        {
            "sample_id": 10391,
            "vt": "SELECT COUNT(drivers.driverid) FROM drivers WHERE drivers.nationality = '[placeholder-type:string]' AND STRFTIME('%Y', drivers.dob) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of drivers from the 'drivers' table who have a specific nationality and were born in a specific year. The placeholders represent the nationality and the year of birth."
        },
        {
            "sample_id": 10334,
            "vt": "SELECT circuits.circuitref FROM circuits WHERE circuits.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the circuit reference names from the 'circuits' table for a specific circuit name. The placeholder in the WHERE clause represents the name of the circuit being queried."
        },
        {
            "sample_id": 10309,
            "vt": "SELECT races.name FROM races WHERE races.year = [placeholder-type:numeric] AND NOT races.name IN (SELECT races.name FROM races WHERE year = 2000)",
            "ba": "The virtual table lists the names of races from the 'races' table that occurred in a specific year, excluding those that took place in the year 2000. The placeholder in the WHERE clause represents the year of interest."
        },
        {
            "sample_id": 10424,
            "vt": "SELECT drivers.forename, drivers.surname, drivers.nationality, races.name FROM drivers INNER JOIN driverStandings AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId ORDER BY JULIANDAY(drivers.dob) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of drivers along with their first names, surnames, nationalities, and the names of the races they participated in. It combines data from the 'drivers' table and the 'races' table through the 'driverStandings' table, which links drivers to their respective race results. The results are ordered by the date of birth of the drivers, and a limit is applied to restrict the number of records returned."
        },
        {
            "sample_id": 10438,
            "vt": "WITH fastest_lap_times AS (SELECT T1.raceId, T1.driverId, T1.FastestLapTime, (CAST(SUBSTRING(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS FLOAT) * 60) + (CAST(SUBSTRING(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS FLOAT)) + (CAST(SUBSTRING(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS FLOAT) / 1000) AS time_in_seconds FROM results AS T1 WHERE NOT T1.FastestLapTime IS NULL), lap_record_race AS (SELECT T1.raceId, T1.driverId FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId INNER JOIN (SELECT MIN(fastest_lap_times.time_in_seconds) AS min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 ON fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix') AS T4 ON (CAST(SUBSTRING(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS FLOAT) * 60) + (CAST(SUBSTRING(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS FLOAT)) + (CAST(SUBSTRING(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS FLOAT) / 1000) = T4.min_time_in_seconds WHERE T2.name = 'Austrian Grand Prix') SELECT (SELECT MIN(fastest_lap_times.time_in_seconds) AS min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 ON fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix').duration FROM lap_record_race INNER JOIN pitStops AS T4 ON lap_record_race.raceId = T4.raceId AND lap_record_race.driverId = T4.driverId",
            "ba": "The virtual table retrieves the duration of pit stops for drivers who achieved the fastest lap time during the 'Austrian Grand Prix'. It first calculates the fastest lap times in seconds for each driver in the race, then identifies the drivers who recorded the minimum fastest lap time for that specific race. Finally, it joins this information with the pit stop data to extract the duration of their pit stops."
        },
        {
            "sample_id": 10401,
            "vt": "SELECT results.raceid FROM results GROUP BY results.raceid ORDER BY COUNT(NOT results.time IS NULL) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists unique race identifiers from the 'results' table, grouping them to count the number of non-null time entries for each race. The results are ordered by the count of these entries, and a limit is applied to restrict the number of race identifiers returned based on a specified numeric value."
        },
        {
            "sample_id": 10271,
            "vt": "SELECT DISTINCT circuits.url FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE circuits.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of URLs for circuits from the 'circuits' table that are associated with races. It filters the results based on the circuit name specified by the user."
        },
        {
            "sample_id": 10433,
            "vt": "WITH lap_times_in_seconds AS (SELECT driverId, (CASE WHEN SUBSTRING(time, 1, INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTRING(time, 1, INSTR(time, ':') - 1) AS FLOAT) * 60 ELSE 0 END + CASE WHEN SUBSTRING(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTRING(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS FLOAT) ELSE 0 END + CASE WHEN SUBSTRING(time, INSTR(time, '.') + 1) <> '' THEN CAST(SUBSTRING(time, INSTR(time, '.') + 1) AS FLOAT) / 1000 ELSE 0 END) AS time_in_seconds FROM lapTimes) SELECT drivers.forename, drivers.surname, (SELECT driverId, MIN(time_in_seconds) AS min_time_in_seconds FROM lap_times_in_seconds GROUP BY driverId).driverid FROM (SELECT drivers.driverid, MIN(None.time_in_seconds) FROM lap_times_in_seconds GROUP BY driverId) AS t1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId ORDER BY (SELECT driverId, MIN(time_in_seconds) AS min_time_in_seconds FROM lap_times_in_seconds GROUP BY driverId).min_time_in_seconds LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the fastest lap times of drivers from the 'drivers' table by calculating the lap times in seconds from the 'lapTimes' table. It selects the first name and surname of the drivers along with their minimum lap time, ordering the results by the fastest lap time. The placeholder in the LIMIT clause allows for specifying the number of top results to return."
        },
        {
            "sample_id": 10323,
            "vt": "SELECT DISTINCT races.name, circuits.name, circuits.location FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE races.year = [placeholder-type:numeric] AND STRFTIME('%m', races.date) = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of race names, circuit names, and their locations from the 'races' and 'circuits' tables. It filters the results based on a specific year and the month of the race date."
        },
        {
            "sample_id": 10405,
            "vt": "SELECT constructors.url FROM constructors INNER JOIN constructorStandings AS T2 ON T1.constructorId = T2.constructorId WHERE constructors.nationality = '[placeholder-type:string]' ORDER BY constructorstandings.points LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the URLs of constructors from the 'constructors' table who belong to a specific nationality. It joins the 'constructors' table with the 'constructorStandings' table to filter based on the constructor's nationality and orders the results by points, limiting the output to a specified number of entries."
        },
        {
            "sample_id": 10358,
            "vt": "SELECT results.fastestlap FROM results INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE races.name = '[placeholder-type:string]' AND races.year = [placeholder-type:numeric] AND drivers.forename = '[placeholder-type:string]' AND drivers.surname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the fastest lap times from the 'results' table for specific races. It joins the 'results' table with the 'races' table to filter by race name and year, and also joins with the 'drivers' table to filter by the driver's first and last names. The placeholders represent the race name, year, driver's first name, and driver's last name."
        },
        {
            "sample_id": 10288,
            "vt": "SELECT DISTINCT drivers.forename, drivers.surname, drivers.url FROM laptimes INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE laptimes.raceid = [placeholder-type:numeric] AND laptimes.time LIKE '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of distinct drivers' first names, surnames, and URLs from the 'drivers' table who participated in a specific race identified by its race ID. The query filters the lap times based on a specific time pattern using a placeholder for string values."
        },
        {
            "sample_id": 10394,
            "vt": "SELECT drivers.driverid, drivers.code FROM results INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE STRFTIME('%Y', drivers.dob) = '[placeholder-type:string]' AND NOT results.fastestlaptime IS NULL",
            "ba": "The virtual table provides a list of driver IDs and their corresponding codes from the 'results' table, filtered by the year of birth of the drivers. It ensures that only those drivers who have a recorded fastest lap time are included in the results."
        },
        {
            "sample_id": 10310,
            "vt": "SELECT circuits.country, circuits.location FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE races.name = '[placeholder-type:string]' ORDER BY races.year LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of countries and locations of circuits from the 'circuits' table that are associated with races having a specific name. The query joins the 'circuits' and 'races' tables based on the circuit ID, filtering results by the race name and ordering them by year, with a limit on the number of results returned."
        },
        {
            "sample_id": 10427,
            "vt": "SELECT pitstops.duration FROM pitstops ORDER BY pitstops.duration LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the duration of pit stops from the 'pitstops' table, ordered by the duration in ascending order. The placeholder in the LIMIT clause allows the user to specify how many records they want to retrieve."
        },
        {
            "sample_id": 10270,
            "vt": "SELECT races.year FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE circuits.location = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the years of races held at circuits located in a specific location. It joins the 'circuits' table with the 'races' table based on the circuit ID, allowing for filtering by the circuit's location."
        },
        {
            "sample_id": 10322,
            "vt": "SELECT circuits.name, circuits.location, races.name FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE circuits.country = '[placeholder-type:string]' AND races.year = [placeholder-type:numeric]",
            "ba": "The virtual table provides information about the names and locations of circuits along with the names of races held at those circuits. It filters the results based on the specified country of the circuit and the year of the race."
        },
        {
            "sample_id": 10304,
            "vt": "SELECT races.year FROM races WHERE races.name = '[placeholder-type:string]' ORDER BY races.year LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the years of races from the 'races' table based on a specific race name. The placeholder in the WHERE clause represents the race name, and the LIMIT clause allows for specifying the maximum number of years to return."
        },
        {
            "sample_id": 10297,
            "vt": "SELECT seasons.url FROM races INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE races.raceid = [placeholder-type:numeric]",
            "ba": "The virtual table provides the URL of the season associated with a specific race. It retrieves this information by joining the 'races' table with the 'seasons' table based on the year of the race, using a placeholder for the race ID."
        },
        {
            "sample_id": 10379,
            "vt": "SELECT COUNT(results.driverid) FROM results INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE drivers.nationality = '[placeholder-type:string]' AND results.time IS NULL",
            "ba": "The virtual table counts the number of drivers from the 'results' table who have not finished their race (indicated by a NULL time) and belong to a specific nationality. It joins the 'results' table with the 'drivers' table to filter based on the driver's nationality."
        },
        {
            "sample_id": 10306,
            "vt": "SELECT races.name FROM races WHERE STRFTIME('%Y', races.date) = (SELECT STRFTIME('%Y', races.date) FROM races ORDER BY date ASC LIMIT 1) AND STRFTIME('%m', races.date) = (SELECT STRFTIME('%m', races.date) FROM races ORDER BY date ASC LIMIT 1)",
            "ba": "The virtual table retrieves the names of races that occurred in the earliest month of the earliest year recorded in the 'races' table. It uses subqueries to find the earliest date and extracts the year and month from that date to filter the results accordingly."
        },
        {
            "sample_id": 10402,
            "vt": "SELECT drivers.driverref, drivers.nationality, drivers.dob FROM qualifying INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE qualifying.raceid = [placeholder-type:numeric] AND NOT qualifying.q2 IS NULL",
            "ba": "The virtual table provides information about drivers who participated in a specific race, including their reference, nationality, and date of birth. It filters the results to include only those drivers who have qualifying times recorded in Q2, ensuring that only relevant data is displayed."
        },
        {
            "sample_id": 10365,
            "vt": "SELECT CAST(SUM(CASE WHEN NOT results.time IS NULL THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(results.resultid) FROM results INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE races.name = '[placeholder-type:string]' AND races.year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average time of race results for a specific race name and year from the 'results' table. It sums the times of the results that are not null, multiplies by a placeholder value, and divides by the count of result IDs to get the average. The query joins the 'results' table with the 'races' table to filter by race name and year."
        },
        {
            "sample_id": 10325,
            "vt": "SELECT SUM(driverstandings.wins) FROM drivers INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId INNER JOIN circuits AS T4 ON T4.circuitId = T3.circuitId WHERE drivers.forename = '[placeholder-type:string]' AND drivers.surname = '[placeholder-type:string]' AND circuits.name = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total number of wins for a specific driver based on their first and last names, as well as the circuit name where the races took place. It aggregates the wins from the driver standings by joining the drivers table with the driver standings, races, and circuits tables."
        },
        {
            "sample_id": 10274,
            "vt": "SELECT COUNT(races.raceid) FROM circuits INNER JOIN races AS T3 ON T3.circuitID = T1.circuitId WHERE NOT circuits.country IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]') AND races.year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of races held at circuits located outside of specified countries for a given year. It joins the 'circuits' and 'races' tables to filter the results based on the circuit's country and the race year."
        },
        {
            "sample_id": 10298,
            "vt": "SELECT COUNT(results.driverid) FROM races INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE races.date = '[placeholder-type:string]' AND results.time IS NULL",
            "ba": "The virtual table counts the number of drivers who participated in races on a specific date where their race results do not have a recorded time. It joins the 'races' table with the 'results' table to filter based on the race date and checks for null values in the time column of the results."
        },
        {
            "sample_id": 10287,
            "vt": "SELECT drivers.forename, drivers.surname FROM drivers INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE results.raceid = [placeholder-type:numeric] AND NOT results.time IS NULL AND NOT drivers.dob IS NULL ORDER BY drivers.dob LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of drivers' first and last names from the 'drivers' table who participated in a specific race, identified by its race ID. It filters out any results where the time is not recorded and ensures that the date of birth of the drivers is available. The results are ordered by the drivers' date of birth, and a limit is applied to restrict the number of returned records."
        },
        {
            "sample_id": 10321,
            "vt": "SELECT DISTINCT circuits.name FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE STRFTIME('%Y', races.date) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' GROUP BY circuits.name HAVING COUNT(races.raceid) = [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique names of circuits from the 'circuits' table that have hosted a specific number of races within a given date range. The placeholders represent the start and end years for filtering the races, as well as the required count of races for each circuit."
        },
        {
            "sample_id": 10399,
            "vt": "SELECT SUM(CASE WHEN NOT results.time IS NULL THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM results WHERE results.statusid = [placeholder-type:numeric] AND results.raceid < [placeholder-type:numeric] AND results.raceid > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total time of race results from the 'results' table, where the results are filtered based on a specific status and race ID range. The placeholders represent the status ID and the range of race IDs to consider."
        },
        {
            "sample_id": 10441,
            "vt": "SELECT CAST(SUM(laptimes.milliseconds) AS FLOAT) / COUNT(laptimes.lap) FROM laptimes INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId WHERE circuits.country = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average lap time in milliseconds for all laps completed in races held at a specific circuit location. It joins the 'laptimes' table with the 'races' table to associate lap times with their respective races, and further joins with the 'circuits' table to filter the results based on the country of the circuit. The placeholder in the WHERE clause represents the country name."
        },
        {
            "sample_id": 10345,
            "vt": "SELECT COUNT(races.circuitid) FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE circuits.country = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of races held at circuits located in a specific country. It joins the 'circuits' table with the 'races' table based on the circuit ID, filtering the results to only include circuits from the specified country."
        },
        {
            "sample_id": 10320,
            "vt": "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP()) - STRFTIME('%Y', drivers.dob), drivers.forename, drivers.surname FROM drivers WHERE drivers.nationality = '[placeholder-type:string]' ORDER BY drivers.dob LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the age, first name, and surname of drivers from the 'drivers' table who belong to a specific nationality. The age is calculated by subtracting the year of birth from the current year, and the results are ordered by date of birth. Placeholders are used for the nationality and the limit on the number of results returned."
        },
        {
            "sample_id": 10343,
            "vt": "SELECT DISTINCT circuits.url FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE circuits.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves unique URLs of circuits from the 'circuits' table that are associated with races. It filters the results based on the circuit name provided by the user."
        },
        {
            "sample_id": 10337,
            "vt": "SELECT drivers.nationality FROM drivers WHERE NOT drivers.dob IS NULL ORDER BY drivers.dob LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the nationalities of drivers from the 'drivers' table who have a recorded date of birth. The results are ordered by the date of birth in ascending order, and the number of results returned is limited by a placeholder for numeric values."
        },
        {
            "sample_id": 10305,
            "vt": "SELECT races.name FROM races WHERE races.year = [placeholder-type:numeric] ORDER BY races.name",
            "ba": "The virtual table lists the names of races from the 'races' table that occurred in a specific year. The placeholder in the WHERE clause represents the year of the races."
        },
        {
            "sample_id": 10314,
            "vt": "SELECT drivers.forename, drivers.surname, driverstandings.points FROM races INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId ORDER BY driverstandings.points LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table presents the first names and surnames of drivers along with their points from the driver standings. It combines data from the 'races', 'driverstandings', and 'drivers' tables, filtering and ordering the results based on the points scored by each driver. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 10349,
            "vt": "SELECT drivers.forename, drivers.surname FROM drivers INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE NOT results.fastestlaptime IS NULL ORDER BY results.fastestlapspeed LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first names and last names of drivers from the 'drivers' table who have achieved a fastest lap time in their respective races. The query joins the 'drivers' table with the 'results' table to filter out drivers based on their fastest lap times, and it orders the results by the speed of those fastest laps. The placeholder in the LIMIT clause represents the maximum number of records to return."
        },
        {
            "sample_id": 10382,
            "vt": "SELECT AVG(results.fastestlapspeed) FROM results INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE races.year = [placeholder-type:numeric] AND races.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and with a specific race name. The placeholders represent the year and the race name respectively."
        },
        {
            "sample_id": 10381,
            "vt": "SELECT results.fastestlap FROM results INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE races.year = [placeholder-type:numeric] AND results.time LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the fastest lap times from the 'results' table for races that occurred in a specific year. It joins the 'results' table with the 'races' table to filter the results based on the year of the race. The placeholder in the WHERE clause represents the year, while the placeholder for the time allows for a specific time format to be specified."
        },
        {
            "sample_id": 10311,
            "vt": "SELECT races.date FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE circuits.name = '[placeholder-type:string]' AND races.name = '[placeholder-type:string]' ORDER BY races.year LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the race dates from the 'races' table, which are associated with a specific circuit and race name. It uses an inner join to connect the 'circuits' and 'races' tables based on the circuit ID. The placeholders allow users to specify the circuit name and race name, as well as limit the number of results returned."
        },
        {
            "sample_id": 10284,
            "vt": "SELECT COUNT(drivers.driverid) FROM races INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE races.year = [placeholder-type:numeric] AND races.name = '[placeholder-type:string]' AND results.time IS NULL",
            "ba": "The virtual table counts the number of drivers who participated in races for a specific year and race name, where the results for those races have not been recorded (i.e., time is NULL)."
        },
        {
            "sample_id": 10387,
            "vt": "SELECT races.raceid FROM races WHERE races.year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identification numbers of races from the 'races' table that occurred in a specific year. The placeholder in the WHERE clause represents the year of interest."
        },
        {
            "sample_id": 10295,
            "vt": "SELECT results.time FROM drivers INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE results.raceid = [placeholder-type:numeric] AND drivers.forename = '[placeholder-type:string]' AND drivers.surname = '[placeholder-type:string]'",
            "ba": "The virtual table provides the race times of drivers from the 'results' table by joining it with the 'drivers' table. It filters the results based on a specific race identified by its race ID and the driver's first and last names, which are represented by placeholders for user input."
        },
        {
            "sample_id": 10319,
            "vt": "SELECT drivers.forename, drivers.surname, drivers.nationality, MAX(driverstandings.points) FROM drivers INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId WHERE driverstandings.wins >= [placeholder-type:numeric] GROUP BY drivers.forename, drivers.surname, drivers.nationality ORDER BY COUNT(driverstandings.wins) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of drivers along with their first names, surnames, and nationalities, who have achieved a certain number of wins in races. It calculates the maximum points scored by each driver from the driver standings and groups the results by the driver's name and nationality. The results are ordered by the count of wins and limited to a specified number of entries."
        },
        {
            "sample_id": 10340,
            "vt": "SELECT drivers.driverref FROM drivers WHERE drivers.forename = '[placeholder-type:string]' AND drivers.surname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the driver reference from the 'drivers' table based on the driver's first name and surname. The placeholders represent the specific first name and surname of the driver being queried."
        },
        {
            "sample_id": 10327,
            "vt": "SELECT AVG(driverstandings.points) FROM drivers INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE drivers.forename = '[placeholder-type:string]' AND drivers.surname = '[placeholder-type:string]' AND races.year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average points scored by a specific driver in races during a particular year. It joins the 'drivers' table with the 'driverstandings' table to access the points data, and it also joins with the 'races' table to filter results based on the specified year. The placeholders represent the driver's first name, last name, and the race year."
        },
        {
            "sample_id": 10398,
            "vt": "SELECT laptimes.driverid FROM laptimes WHERE laptimes.lap = [placeholder-type:numeric] ORDER BY laptimes.time LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the driver IDs from the 'laptimes' table for a specific lap number, ordered by the time taken for that lap. The placeholders represent the lap number and the limit on the number of results to return."
        },
        {
            "sample_id": 10308,
            "vt": "SELECT races.year FROM races GROUP BY races.year ORDER BY COUNT(races.round) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the years of races from the 'races' table, grouping them by year and ordering them based on the count of rounds for each year. The placeholder in the LIMIT clause allows the user to specify how many years they want to retrieve."
        },
        {
            "sample_id": 10277,
            "vt": "SELECT DISTINCT circuits.url FROM circuits INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE circuits.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves unique URLs of circuits from the 'circuits' table that are associated with races. It filters the results based on the circuit name provided by the user."
        },
        {
            "sample_id": 10282,
            "vt": "SELECT DISTINCT drivers.nationality FROM qualifying INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE qualifying.raceid = [placeholder-type:numeric] AND qualifying.q2 LIKE '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of nationalities of drivers who participated in a specific qualifying session of a race. It retrieves this information by joining the 'qualifying' table with the 'drivers' table based on the driver ID. The query filters the results for a particular race identified by a numeric placeholder and checks if the qualifying time in Q2 matches a specified string pattern."
        },
        {
            "sample_id": 10353,
            "vt": "SELECT results.fastestlapspeed FROM races INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE races.name = '[placeholder-type:string]' AND races.year = [placeholder-type:numeric] AND NOT results.fastestlapspeed IS NULL ORDER BY results.fastestlapspeed LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the fastest lap speeds from the results of races that match a specific name and year. It filters out any results where the fastest lap speed is null, ensuring only valid data is returned. The results are ordered by the fastest lap speed in ascending order, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 10326,
            "vt": "SELECT races.name, races.year FROM races INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE drivers.forename = '[placeholder-type:string]' AND drivers.surname = '[placeholder-type:string]' ORDER BY laptimes.milliseconds LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of race names and their corresponding years from the 'races' table. It filters the results based on the first name and surname of drivers, ensuring that only races participated in by a specific driver are included. The results are ordered by the lap times in milliseconds, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 10430,
            "vt": "SELECT pitstops.lap FROM pitstops INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceId = T3.raceId WHERE drivers.forename = '[placeholder-type:string]' AND drivers.surname = '[placeholder-type:string]' AND races.year = [placeholder-type:numeric] AND races.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the laps during which a specific driver made pit stops in a particular race. It retrieves the lap numbers from the 'pitstops' table, joining it with the 'drivers' and 'races' tables to filter results based on the driver's first name, last name, race year, and race name."
        },
        {
            "sample_id": 10355,
            "vt": "SELECT results.positionorder FROM races INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE drivers.forename = '[placeholder-type:string]' AND drivers.surname = '[placeholder-type:string]' AND races.name = '[placeholder-type:string]' AND races.year = [placeholder-type:numeric]",
            "ba": "The virtual table provides the position order of a specific driver in a particular race. It retrieves this information by joining the 'races' table with the 'results' table to link race results to their corresponding races, and then further joins with the 'drivers' table to filter results based on the driver's first name and surname. Additionally, it filters the races by their name and year, using placeholders for the driver's name, race name, and year."
        },
        {
            "sample_id": 10291,
            "vt": "SELECT constructors.url FROM constructorresults INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE constructorresults.raceid = [placeholder-type:numeric] ORDER BY constructorresults.points LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the URLs of constructors from the 'constructorresults' table for a specific race, identified by its race ID. It joins the 'constructorresults' table with the 'constructors' table to access the constructor's details, filtering results based on the race ID and ordering them by points earned in that race. The placeholders allow users to specify the race ID and limit the number of results returned."
        },
        {
            "sample_id": 10286,
            "vt": "SELECT COUNT(results.driverid) FROM races INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE races.date = '[placeholder-type:string]' AND NOT results.time IS NULL",
            "ba": "The virtual table counts the number of drivers who participated in races on a specific date, ensuring that only those results with recorded times are included. It joins the 'races' table with the 'results' table to filter the data based on the race date and checks for non-null race times."
        },
        {
            "sample_id": 10333,
            "vt": "SELECT circuits.name FROM circuits WHERE circuits.name IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]') ORDER BY circuits.lat LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of circuits from the 'circuits' table that match specific names provided in the query. The results are filtered to include only those circuits whose names are in a specified list, and the output is ordered by the latitude of the circuits. Additionally, there is a limit on the number of results returned based on a numeric placeholder."
        }
    ],
    "codebase_comments": [
        {
            "sample_id": 613,
            "vt": "SELECT COUNT(solution.repoid) FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.watchers = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of solutions associated with repositories that have a specific number of watchers. It joins the 'repo' table with the 'solution' table based on the repository ID, filtering the results to only include those repositories that match the specified number of watchers."
        },
        {
            "sample_id": 674,
            "vt": "SELECT DISTINCT SUBSTRING(SUBSTRING(method.name, INSTR(method.name, '.') + [placeholder-type:numeric]), [placeholder-type:numeric], INSTR(SUBSTRING(method.name, INSTR(method.name, '.') + [placeholder-type:numeric]), '.') - [placeholder-type:numeric]) FROM method WHERE method.nametokenized = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct substrings from the 'name' column of the 'method' table, specifically extracting parts of the method name that follow a certain pattern. The placeholders represent numeric values for substring extraction and a string value for filtering based on tokenized names."
        },
        {
            "sample_id": 589,
            "vt": "SELECT method.name FROM method WHERE method.summary = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of methods from the 'method' table that have a specific summary. The placeholder in the WHERE clause represents the summary of the method being queried."
        },
        {
            "sample_id": 625,
            "vt": "SELECT CAST(SUM(CASE WHEN solution.id = [placeholder-type:numeric] THEN repo.watchers ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN solution.id = [placeholder-type:numeric] THEN repo.watchers ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(CASE WHEN solution.id = [placeholder-type:numeric] THEN repo.watchers ELSE [placeholder-type:numeric] END) FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId",
            "ba": "The virtual table calculates a weighted difference in the number of watchers for a specific solution from the 'repo' table, based on the solution's ID. It uses placeholders for numeric values to allow users to specify the solution ID and other numeric parameters dynamically."
        },
        {
            "sample_id": 662,
            "vt": "SELECT COUNT(DISTINCT T1.Id) FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.stars > CAST(repo.forks AS FLOAT) / [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of repositories from the 'repo' table that have more stars than half of their forks. It does this by joining the 'repo' table with the 'solution' table based on the repository ID, and applies a condition to filter repositories based on their star and fork counts."
        },
        {
            "sample_id": 608,
            "vt": "SELECT COUNT(solution.repoid) FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.stars = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of solutions associated with repositories that have a specific number of stars. It joins the 'repo' table with the 'solution' table based on the repository ID, filtering the results to only include those repositories that match the specified star count."
        },
        {
            "sample_id": 639,
            "vt": "SELECT repo.url FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE solution.processedtime = (SELECT MAX(repo.processedtime) FROM Solution)",
            "ba": "The virtual table retrieves the URLs of repositories from the 'repo' table that are associated with solutions having the maximum processed time. It uses an inner join to connect the 'repo' and 'solution' tables based on their respective IDs, ensuring that only the relevant repository URLs are selected for the most recently processed solution."
        },
        {
            "sample_id": 567,
            "vt": "SELECT SUBSTRING(SUBSTRING(method.name, INSTR(method.name, '.') + [placeholder-type:numeric]), [placeholder-type:numeric], INSTR(SUBSTRING(method.name, INSTR(method.name, '.') + [placeholder-type:numeric]), '.') - [placeholder-type:numeric]) FROM method WHERE method.nametokenized = '[placeholder-type:string]'",
            "ba": "The virtual table extracts a specific part of the method's name from the 'method' table based on a tokenized name. It uses string manipulation functions to isolate a substring of the method name, starting from the first occurrence of a dot and continuing for a specified length. The placeholders represent the numeric values for substring positions and the tokenized name for filtering."
        },
        {
            "sample_id": 682,
            "vt": "SELECT repo.url FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE solution.path = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the URLs of repositories from the 'repo' table that are associated with a specific solution path. It uses an inner join to connect the 'repo' table with the 'solution' table based on the repository ID, ensuring that only the relevant repository URLs for the given solution path are selected."
        },
        {
            "sample_id": 630,
            "vt": "SELECT SUM(solution.processedtime) FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.forks = (SELECT MAX(repo.forks) FROM Repo)",
            "ba": "The virtual table calculates the total processed time of solutions from the repository that has the maximum number of forks. It joins the 'repo' table with the 'solution' table to aggregate the processed time for solutions associated with the repository having the highest fork count."
        },
        {
            "sample_id": 688,
            "vt": "SELECT CAST(SUM(solution.processedtime) AS FLOAT) / COUNT(solution.processedtime) FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.stars = [placeholder-type:numeric] AND repo.forks = [placeholder-type:numeric] AND repo.watchers = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average processed time of solutions from repositories that have a specific number of stars, forks, and watchers. It joins the 'repo' table with the 'solution' table based on the repository ID, and filters the results based on the specified numeric values for stars, forks, and watchers."
        },
        {
            "sample_id": 633,
            "vt": "SELECT DISTINCT method.id FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE solution.repoid = [placeholder-type:numeric] AND method.lang = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct method IDs from the 'method' table that are associated with a specific solution in the 'solution' table. It filters the results based on the repository ID and the programming language of the method."
        },
        {
            "sample_id": 595,
            "vt": "SELECT COUNT(solution.repoid) FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.processedtime = (SELECT MAX(repo.processedtime) FROM Repo) AND solution.wascompiled = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of solutions associated with the most recently processed repository, filtering based on whether the solutions require compilation or not. The placeholder in the WHERE clause represents a numeric value indicating the compilation requirement of the solutions."
        },
        {
            "sample_id": 612,
            "vt": "SELECT solution.path FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the paths of solutions from the 'solution' table that are associated with a specific method name. The query uses an INNER JOIN to connect the 'solution' table with the 'method' table based on the solution ID, filtering results to only include those methods that match the specified name."
        },
        {
            "sample_id": 614,
            "vt": "SELECT repo.url FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId GROUP BY solution.repoid ORDER BY COUNT(solution.repoid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the URLs of repositories from the 'repo' table, joining it with the 'solution' table to associate each repository with its solutions. The results are grouped by the repository ID and ordered by the count of solutions associated with each repository, limiting the output to a specified number of results."
        },
        {
            "sample_id": 650,
            "vt": "SELECT CAST(SUM(CASE WHEN repo.stars > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(repo.stars) FROM repo",
            "ba": "The virtual table calculates a weighted average of the stars received by repositories from the 'repo' table. It uses a conditional sum to differentiate between repositories with stars greater than a specified threshold and those that do not, applying a multiplier to the result. The final output is normalized by the count of stars, allowing users to understand the average star rating based on their criteria."
        },
        {
            "sample_id": 626,
            "vt": "SELECT CAST(SUM(CASE WHEN solution.id = [placeholder-type:numeric] THEN repo.stars ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN solution.id = [placeholder-type:numeric] THEN repo.stars ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(CASE WHEN solution.id = [placeholder-type:numeric] THEN repo.stars ELSE [placeholder-type:numeric] END) FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId",
            "ba": "The virtual table calculates a weighted difference in stars for repositories associated with a specific solution. It sums the stars of repositories linked to a given solution ID and applies a formula to compute a float value based on the total stars and a specified multiplier. The placeholders represent the solution ID and numeric values for calculations."
        },
        {
            "sample_id": 680,
            "vt": "SELECT COUNT(method.commentisxml) FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId INNER JOIN Method AS T3 ON T2.Id = T3.SolutionId WHERE repo.url = '[placeholder-type:string]' AND method.commentisxml = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of methods from the 'method' table that have comments in XML format or not, based on a specific repository URL from the 'repo' table. It joins the 'repo', 'solution', and 'method' tables to filter the results accordingly."
        },
        {
            "sample_id": 599,
            "vt": "SELECT COUNT(solution.repoid) FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE solution.processedtime < [placeholder-type:numeric] AND repo.stars > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of solutions associated with repositories that have been processed within a specified time and have received a certain number of stars. The placeholders represent the maximum processed time for the solutions and the minimum number of stars for the repositories."
        },
        {
            "sample_id": 634,
            "vt": "SELECT DISTINCT solution.path FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.url = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct paths of solutions from the 'solution' table that are associated with a specific repository identified by its URL in the 'repo' table. The placeholder in the WHERE clause represents the repository's URL."
        },
        {
            "sample_id": 620,
            "vt": "SELECT DISTINCT solution.processedtime FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.nametokenized = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct processed times of solutions from the 'solution' table that are associated with methods having a specific tokenized name. The query uses an inner join to connect the 'solution' table with the 'method' table based on the solution ID, ensuring that only relevant solutions are considered. The placeholder in the WHERE clause represents the tokenized name of the method being queried."
        },
        {
            "sample_id": 587,
            "vt": "SELECT SUBSTRING(SUBSTRING(method.name, INSTR(method.name, '.') + [placeholder-type:numeric]), [placeholder-type:numeric], INSTR(SUBSTRING(method.name, INSTR(method.name, '.') + [placeholder-type:numeric]), '.') - [placeholder-type:numeric]) FROM method WHERE method.nametokenized = '[placeholder-type:string]'",
            "ba": "The virtual table extracts a specific part of the method name from the 'method' table based on a tokenized name. It uses string manipulation functions to isolate a substring of the method name, starting from the first occurrence of a dot and continuing for a specified length. The placeholders represent the numeric values for substring positions and the tokenized name for filtering."
        },
        {
            "sample_id": 663,
            "vt": "SELECT SUBSTRING(SUBSTRING(method.name, INSTR(method.name, '.') + [placeholder-type:numeric]), [placeholder-type:numeric], INSTR(SUBSTRING(method.name, INSTR(method.name, '.') + [placeholder-type:numeric]), '.') - [placeholder-type:numeric]) FROM method WHERE method.id = [placeholder-type:numeric]",
            "ba": "The virtual table extracts a specific part of the method's name from the 'method' table based on its unique identifier. It uses string manipulation functions to isolate a substring that follows a certain pattern, indicated by numeric placeholders for flexibility in specifying the starting position and length of the substring."
        },
        {
            "sample_id": 652,
            "vt": "SELECT repo.id FROM repo WHERE repo.stars = [placeholder-type:numeric] AND repo.forks = (SELECT MAX(repo.forks) FROM Repo WHERE Stars = 21)",
            "ba": "The virtual table retrieves the unique identifiers of repositories from the 'repo' table that have a specific number of stars and the maximum number of forks among those repositories with the same star count. The placeholder in the WHERE clause represents the number of stars to filter the repositories."
        },
        {
            "sample_id": 643,
            "vt": "SELECT solution.path FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the paths of solutions from the 'solution' table that are associated with a specific method name. The query uses an INNER JOIN to connect the 'solution' table with the 'method' table based on the solution ID, filtering results to only include those methods that match the specified name."
        },
        {
            "sample_id": 676,
            "vt": "SELECT COUNT(DISTINCT T2.Path) FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.url = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct paths of solutions associated with a specific repository URL from the 'repo' table. It joins the 'repo' table with the 'solution' table based on the repository ID, filtering for a particular repository URL using a placeholder."
        },
        {
            "sample_id": 638,
            "vt": "SELECT solution.id FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.processedtime = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of solutions from the 'solution' table that are associated with repositories in the 'repo' table, filtered by the processed time of the repository. The placeholder in the WHERE clause represents the specific processed time value to filter the results."
        },
        {
            "sample_id": 648,
            "vt": "SELECT CAST(SUM(CASE WHEN solution.wascompiled = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(method.solutionid) FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.commentisxml = [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average based on the compilation requirement of solutions associated with methods that have XML comments. It sums up the values based on whether the solution needs to be compiled or not, and then divides this sum by the count of solutions linked to the methods, applying a scaling factor."
        },
        {
            "sample_id": 580,
            "vt": "SELECT CAST(SUM(solution.processedtime) AS FLOAT) / COUNT(solution.repoid) FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.url = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average processed time of solutions associated with a specific repository URL. It does this by summing the processed time of all solutions linked to the repository and dividing it by the count of those solutions. The placeholder in the WHERE clause represents the repository's URL."
        },
        {
            "sample_id": 681,
            "vt": "SELECT DISTINCT solution.path FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.sampledat = [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct paths of solutions from the 'solution' table that are associated with methods sampled at a specific time. The query joins the 'solution' table with the 'method' table using the solution ID to filter results based on the sampling date, and it limits the number of results returned."
        },
        {
            "sample_id": 685,
            "vt": "SELECT repo.url FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId INNER JOIN Method AS T3 ON T2.Id = T3.SolutionId WHERE method.summary = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the URLs of repositories from the 'repo' table that are associated with solutions in the 'solution' table, which in turn are linked to methods in the 'method' table. The query filters the results based on a specific summary of the method, represented by a placeholder for string values."
        },
        {
            "sample_id": 616,
            "vt": "SELECT solution.path FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.lang = '[placeholder-type:string]' GROUP BY solution.path ORDER BY COUNT(solution.path) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the paths of solutions from the 'solution' table that are associated with methods in a specific programming language. It joins the 'solution' table with the 'method' table based on the solution ID, filters the results by the specified language, groups the results by solution path, and orders them by the count of occurrences, limiting the output to a specified number of results."
        },
        {
            "sample_id": 655,
            "vt": "SELECT solution.id FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.forks = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of solutions from the 'solution' table that are associated with repositories having a specific number of forks. The query uses an INNER JOIN to connect the 'repo' and 'solution' tables based on the repository ID, filtering the results based on the number of forks in the 'repo' table."
        },
        {
            "sample_id": 576,
            "vt": "SELECT DISTINCT method.nametokenized FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE solution.path = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct tokenized names of methods from the 'method' table that are associated with a specific solution path in the 'solution' table. The placeholder in the WHERE clause represents the path of the solution being queried."
        },
        {
            "sample_id": 658,
            "vt": "SELECT solution.path FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.fullcomment = '[placeholder-type:string]'",
            "ba": "The virtual table describes the paths of solutions from the 'solution' table that are associated with methods having a specific full comment. The query uses an INNER JOIN to connect the 'solution' table with the 'method' table based on the solution ID, filtering results based on the full comment of the method."
        },
        {
            "sample_id": 673,
            "vt": "SELECT CASE WHEN method.commentisxml = [placeholder-type:numeric] THEN '[placeholder-type:string]' WHEN method.commentisxml = [placeholder-type:numeric] THEN '[placeholder-type:string]' END FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.id = [placeholder-type:numeric] AND solution.path = '[placeholder-type:string]'",
            "ba": "The virtual table provides a conditional selection of comments based on whether the comment format is XML or not from the 'method' table, while also joining with the 'solution' table to filter results based on a specific method ID and solution path. The placeholders represent the numeric values for the comment format and method ID, as well as string values for the comments and solution path."
        },
        {
            "sample_id": 586,
            "vt": "SELECT method.lang FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE solution.path = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the programming language used in methods associated with a specific solution path from the 'solution' and 'method' tables. It uses an INNER JOIN to connect the two tables based on the solution ID, ensuring that only relevant methods for the given solution path are selected."
        },
        {
            "sample_id": 597,
            "vt": "SELECT repo.url FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE solution.id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the URLs of repositories from the 'repo' table that are associated with a specific solution identified by its ID. The query uses an INNER JOIN to connect the 'repo' table with the 'solution' table based on the repository ID, ensuring that only the relevant repository URLs for the specified solution are returned."
        },
        {
            "sample_id": 571,
            "vt": "SELECT repo.url, repo.stars FROM repo WHERE repo.stars = (SELECT MAX(repo.stars) FROM Repo)",
            "ba": "The virtual table provides the URL and star count of the repository with the highest number of stars from the 'repo' table. The subquery identifies the maximum star count among all repositories, and the main query retrieves the corresponding URL and star count for that repository."
        },
        {
            "sample_id": 660,
            "vt": "SELECT CAST(SUM(CASE WHEN solution.wascompiled = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(method.lang) FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.lang = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average based on the compilation requirement of solutions associated with methods in a specific programming language. It sums up the values based on whether the solution needs to be compiled or not, and then divides this sum by the count of methods in that language. The placeholders represent the conditions and values that can be modified to generate specific queries."
        },
        {
            "sample_id": 598,
            "vt": "SELECT solution.path FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.url = '[placeholder-type:string]'",
            "ba": "The virtual table describes the paths of solutions from the 'solution' table that are associated with a specific repository in the 'repo' table. The placeholder in the WHERE clause represents the URL of the repository."
        },
        {
            "sample_id": 679,
            "vt": "SELECT DISTINCT solution.path FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.nametokenized = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct paths of solutions from the 'solution' table that are associated with methods having a specific tokenized name. The query uses an inner join to connect the 'solution' table with the 'method' table based on the solution ID, ensuring that only relevant solutions are selected based on the provided tokenized name."
        },
        {
            "sample_id": 670,
            "vt": "SELECT COUNT(method.solutionid) FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.nametokenized LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of solutions associated with methods that have a specific tokenized name. It joins the 'solution' table with the 'method' table based on the solution ID, filtering for methods whose tokenized name matches a given pattern."
        },
        {
            "sample_id": 629,
            "vt": "SELECT COUNT(solution.repoid) FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.url = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of solutions associated with a specific repository identified by its URL. It joins the 'repo' table with the 'solution' table to link each solution to its corresponding repository, filtering the results based on the provided repository URL."
        },
        {
            "sample_id": 621,
            "vt": "SELECT DISTINCT solution.repoid FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct repository IDs from the 'solution' table that are associated with methods having a specific name. It uses an inner join to connect the 'solution' table with the 'method' table based on the solution ID, ensuring that only relevant solutions linked to the specified method name are considered."
        },
        {
            "sample_id": 566,
            "vt": "SELECT COUNT(method.lang) FROM method WHERE method.lang = '[placeholder-type:string]' AND method.commentisxml = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of methods from the 'method' table that are written in a specific programming language and have comments in a specified format (either XML or not). The placeholders represent the language code and the XML format status."
        },
        {
            "sample_id": 672,
            "vt": "SELECT COUNT(method.solutionid) FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE solution.repoid = [placeholder-type:numeric] AND method.fullcomment IS NULL AND method.summary IS NULL",
            "ba": "The virtual table counts the number of methods associated with a specific solution in the 'solution' table, where the solution is identified by its repository ID. It filters the methods to include only those that do not have a full comment or summary."
        },
        {
            "sample_id": 606,
            "vt": "SELECT method.nametokenized FROM method WHERE method.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the tokenized name of a method from the 'method' table based on a specific method name. The placeholder in the WHERE clause represents the name of the method being queried."
        },
        {
            "sample_id": 656,
            "vt": "SELECT method.nametokenized FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.lang = '[placeholder-type:string]' AND solution.wascompiled = [placeholder-type:numeric]",
            "ba": "The virtual table describes the tokenized names of methods from the 'method' table that are associated with solutions in the 'solution' table. It filters the results based on the specified programming language and whether the solution requires compilation, using placeholders for these criteria."
        },
        {
            "sample_id": 678,
            "vt": "SELECT repo.url FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE solution.wascompiled = [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the URLs of repositories from the 'repo' table that are associated with solutions from the 'solution' table. It filters the results based on whether the solution requires compilation, using a placeholder for numeric values to indicate this requirement. Additionally, it limits the number of results returned, allowing for a controlled output of repository URLs."
        },
        {
            "sample_id": 585,
            "vt": "SELECT method.sampledat FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE solution.path = '[placeholder-type:string]' AND method.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the sampling time of methods from the 'method' table that are associated with a specific solution in the 'solution' table. It uses an INNER JOIN to connect the two tables based on the solution ID, and filters the results based on the path of the solution and the name of the method, both represented by placeholders."
        },
        {
            "sample_id": 689,
            "vt": "SELECT COUNT(DISTINCT T3.Lang) FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId INNER JOIN Method AS T3 ON T2.Id = T3.SolutionId WHERE repo.url = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct programming languages used in methods associated with a specific repository. It joins the 'repo', 'solution', and 'method' tables to filter the results based on the repository's URL, which is provided as a placeholder."
        },
        {
            "sample_id": 647,
            "vt": "SELECT COUNT(method.solutionid), CASE WHEN solution.wascompiled = [placeholder-type:numeric] THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.solutionid = [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of methods associated with a specific solution, indicating whether the solution requires compilation or not. The placeholders represent the solution ID and the compilation status."
        },
        {
            "sample_id": 684,
            "vt": "SELECT DISTINCT method.nametokenized FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE solution.path = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of tokenized names of methods from the 'method' table that are associated with a specific solution path in the 'solution' table. The placeholder in the WHERE clause represents the path of the solution being queried."
        },
        {
            "sample_id": 636,
            "vt": "SELECT solution.repoid FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.nametokenized = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the repository ID associated with solutions that are linked to methods with a specific tokenized name. It joins the 'solution' table with the 'method' table based on the solution ID, filtering for methods that match the provided tokenized name."
        },
        {
            "sample_id": 568,
            "vt": "SELECT DISTINCT method.sampledat, method.solutionid FROM method WHERE method.sampledat = (SELECT MAX(method.sampledat) FROM Method)",
            "ba": "The virtual table provides a distinct list of sample dates and solution IDs from the 'method' table, specifically focusing on the most recent sample date available. The placeholder in the WHERE clause is used to filter the results based on the latest sample date."
        },
        {
            "sample_id": 628,
            "vt": "SELECT DISTINCT method.name FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE solution.processedtime = [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct method names from the 'method' table that are associated with solutions in the 'solution' table, filtered by the processed time of the solution. The placeholder in the WHERE clause represents the specific processed time value to filter the results."
        },
        {
            "sample_id": 645,
            "vt": "SELECT solution.id FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.watchers = (SELECT MAX(repo.watchers) FROM Repo)",
            "ba": "The virtual table retrieves the unique identifiers of solutions from the 'solution' table that are associated with the repository having the maximum number of watchers. It uses an inner join between the 'repo' and 'solution' tables to link solutions to their respective repositories, filtering for the repository with the highest watcher count."
        },
        {
            "sample_id": 591,
            "vt": "SELECT DISTINCT solution.path FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.stars = (SELECT MAX(repo.stars) FROM Repo)",
            "ba": "The virtual table retrieves distinct paths of solutions from the 'solution' table that are associated with the repository having the maximum number of stars in the 'repo' table. The query uses an inner join to connect the 'repo' and 'solution' tables based on the repository ID, ensuring that only solutions from the most popular repository are selected."
        },
        {
            "sample_id": 575,
            "vt": "SELECT DISTINCT repo.id, solution.wascompiled FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.processedtime = (SELECT MAX(repo.processedtime) FROM Repo)",
            "ba": "The virtual table provides a distinct list of repository IDs along with their compilation status from the 'repo' and 'solution' tables. It filters the results to include only those repositories that have the maximum processed time, indicating the most recently processed repositories."
        },
        {
            "sample_id": 646,
            "vt": "SELECT repo.stars FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE solution.id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the number of stars for a specific repository associated with a solution. It joins the 'repo' table with the 'solution' table to link the repository information with the solution's details, using a placeholder for the solution's ID."
        },
        {
            "sample_id": 667,
            "vt": "SELECT solution.path FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the paths of solutions from the 'solution' table that are associated with a specific method identified by its ID. The query uses an INNER JOIN to connect the 'solution' table with the 'method' table based on the solution ID, filtering results to only include those methods that match the provided method ID placeholder."
        },
        {
            "sample_id": 619,
            "vt": "SELECT solution.path FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the paths of solutions from the 'solution' table that are associated with a specific method name. The query uses an INNER JOIN to connect the 'solution' table with the 'method' table based on the solution ID, filtering results to only include those methods that match the specified name."
        },
        {
            "sample_id": 609,
            "vt": "SELECT solution.path FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the paths of solutions from the 'solution' table that are associated with a specific method name. The query uses an INNER JOIN to connect the 'solution' table with the 'method' table based on the solution ID, filtering results to only include those methods that match the specified name."
        },
        {
            "sample_id": 627,
            "vt": "SELECT CAST(SUM(CASE WHEN solution.id = [placeholder-type:numeric] THEN repo.forks ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN solution.id = [placeholder-type:numeric] THEN repo.forks ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(CASE WHEN solution.id = [placeholder-type:numeric] THEN repo.forks ELSE [placeholder-type:numeric] END) FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId",
            "ba": "The virtual table calculates a weighted difference based on the number of forks from repositories associated with a specific solution. It uses conditional aggregation to sum the forks for a given solution ID and applies a mathematical operation to derive a result, which is then scaled by a placeholder value."
        },
        {
            "sample_id": 584,
            "vt": "SELECT DISTINCT solution.processedtime, method.lang FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.nametokenized = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct processed time and language of methods from the 'solution' and 'method' tables. It filters the results based on a specific tokenized name of the method, represented by a placeholder."
        },
        {
            "sample_id": 596,
            "vt": "SELECT DISTINCT solution.processedtime FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE solution.path = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct processed times of solutions from the 'solution' table that are associated with a specific repository in the 'repo' table. The placeholder in the WHERE clause represents the path of the solution being queried."
        },
        {
            "sample_id": 601,
            "vt": "SELECT CAST(SUM(solution.processedtime) AS FLOAT) / COUNT(solution.repoid) FROM repo INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE repo.url = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average processed time of solutions associated with a specific repository URL. It does this by summing the processed time of all solutions linked to the repository and dividing it by the count of those solutions. The placeholder in the WHERE clause represents the repository's URL."
        },
        {
            "sample_id": 569,
            "vt": "SELECT repo.forks, repo.url FROM repo WHERE repo.forks = (SELECT MAX(repo.forks) FROM Repo)",
            "ba": "The virtual table displays the URL and the number of forks of the repository that has received the maximum number of forks from the 'repo' table. The subquery identifies the maximum number of forks across all repositories, and the main query retrieves the corresponding repository's URL and fork count."
        },
        {
            "sample_id": 610,
            "vt": "SELECT solution.processedtime FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.nametokenized = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the processed time of solutions from the 'solution' table that are associated with methods having a specific tokenized name. The query uses an INNER JOIN to connect the 'solution' table with the 'method' table based on the solution ID, ensuring that only relevant solutions are considered. The placeholder in the WHERE clause represents the tokenized name of the method being queried."
        },
        {
            "sample_id": 637,
            "vt": "SELECT COUNT(method.solutionid) FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE solution.path = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of methods associated with a specific solution path from the 'solution' table. It joins the 'solution' table with the 'method' table based on the solution ID, filtering for a specific solution path using a placeholder for string values."
        },
        {
            "sample_id": 654,
            "vt": "SELECT solution.path FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.nametokenized = '[placeholder-type:string]'",
            "ba": "The virtual table describes the paths of solutions from the 'solution' table that are associated with methods having a specific tokenized name. The query uses an INNER JOIN to connect the 'solution' table with the 'method' table based on the solution ID, filtering results based on the tokenized name of the method."
        },
        {
            "sample_id": 631,
            "vt": "SELECT DISTINCT solution.path FROM solution INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE method.lang = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct paths of solutions from the 'solution' table that are associated with methods in a specific programming language. The placeholder in the WHERE clause represents the language code of the method."
        }
    ],
    "shooting": [
        {
            "sample_id": 2479,
            "vt": "SELECT COUNT(officers.case_number) FROM officers INNER JOIN incidents AS T2 ON T2.case_number = T1.case_number WHERE officers.race = '[placeholder-type:string]' AND incidents.date BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of officers involved in incidents based on their race and the date range of those incidents. It joins the 'officers' table with the 'incidents' table using the case number to ensure that only relevant records are considered. The placeholders represent the race of the officers and the start and end dates for filtering the incidents."
        },
        {
            "sample_id": 2477,
            "vt": "SELECT COUNT(incidents.case_number) FROM incidents INNER JOIN officers AS T2 ON T1.case_number = T2.case_number WHERE incidents.subject_weapon = '[placeholder-type:string]' AND officers.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of incidents from the 'incidents' table that match specific criteria related to the weapon used and the gender of the officers involved. It joins the 'incidents' table with the 'officers' table based on the case number, allowing for filtering based on the subject weapon and officer gender."
        },
        {
            "sample_id": 2465,
            "vt": "SELECT SUM(CASE WHEN STRFTIME('%Y', incidents.date) = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN STRFTIME('%Y', incidents.date) = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM incidents WHERE incidents.subject_weapon = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference in the sum of a numeric value based on the year extracted from the 'date' column in the 'incidents' table, filtered by a specific 'subject_weapon'. The placeholders represent the year and the numeric values to be summed."
        },
        {
            "sample_id": 2485,
            "vt": "SELECT CAST(SUM(incidents.subject_statuses = '[placeholder-type:string]') AS FLOAT) * [placeholder-type:numeric] / COUNT(incidents.case_number) FROM incidents WHERE incidents.subject_weapon = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of incidents with a specific subject status and weapon type from the 'incidents' table. It sums the occurrences of a specified subject status, multiplies it by a numeric placeholder, and divides by the total count of case numbers to derive a ratio."
        },
        {
            "sample_id": 2478,
            "vt": "SELECT COUNT(incidents.case_number) FROM incidents INNER JOIN subjects AS T2 ON T1.case_number = T2.case_number WHERE subjects.gender = '[placeholder-type:string]' AND incidents.subject_statuses = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of incidents from the 'incidents' table that are associated with subjects of a specific gender and have a particular status. It uses an inner join to connect the 'incidents' table with the 'subjects' table based on the case number, ensuring that only relevant records are considered. The placeholders in the WHERE clause represent the gender of the subjects and the status of the incidents."
        },
        {
            "sample_id": 2463,
            "vt": "SELECT STRFTIME('%Y', incidents.date) FROM incidents WHERE incidents.subject_weapon = '[placeholder-type:string]' GROUP BY STRFTIME('%Y', incidents.date) ORDER BY COUNT(incidents.case_number) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the years from the 'incidents' table based on the date of incidents where a specific subject weapon was used. It groups the results by year and orders them by the count of case numbers, limiting the output to a specified number of results."
        },
        {
            "sample_id": 2469,
            "vt": "SELECT incidents.case_number, incidents.location, incidents.subject_statuses FROM incidents INNER JOIN subjects AS T2 ON T1.case_number = T2.case_number WHERE subjects.gender = '[placeholder-type:string]'",
            "ba": "The virtual table describes incidents along with their locations and the statuses of the victims from the 'incidents' table, filtered by the gender of the subjects involved in those incidents. The placeholder in the WHERE clause represents the gender of the subjects."
        },
        {
            "sample_id": 2473,
            "vt": "SELECT CAST(SUM(incidents.subject_weapon = '[placeholder-type:string]') AS FLOAT) * [placeholder-type:numeric] / COUNT(incidents.case_number) FROM incidents INNER JOIN subjects AS T2 ON T1.case_number = T2.case_number WHERE subjects.gender = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of incidents involving a specific weapon type, adjusted by a numeric factor, for a specified gender of subjects. It aggregates data from the 'incidents' table and joins it with the 'subjects' table based on the case number, applying filters for weapon type and subject gender."
        },
        {
            "sample_id": 2474,
            "vt": "SELECT CAST(SUM(incidents.subject_weapon = '[placeholder-type:string]') AS FLOAT) * [placeholder-type:numeric] / SUM(incidents.subject_weapon = '[placeholder-type:string]') FROM incidents INNER JOIN subjects AS T2 ON T1.case_number = T2.case_number WHERE incidents.subject_statuses = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of a specific subject weapon used in incidents, based on the statuses of the victims. It sums the occurrences of the specified weapon and divides it by the total occurrences of that weapon, then multiplies by a numeric placeholder to adjust the result. The query joins the 'incidents' table with the 'subjects' table on the case number to filter results based on the victim's statuses."
        },
        {
            "sample_id": 2475,
            "vt": "SELECT incidents.case_number FROM incidents WHERE STRFTIME('%Y', incidents.date) > '[placeholder-type:string]' AND incidents.subject_statuses = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves case numbers from the 'incidents' table based on specific criteria. It filters the results to include only those incidents that occurred after a certain year and have a specific status for the victims."
        },
        {
            "sample_id": 2482,
            "vt": "SELECT incidents.subject_weapon FROM incidents WHERE incidents.subject_statuses = '[placeholder-type:string]' GROUP BY incidents.subject_weapon ORDER BY COUNT(incidents.case_number) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the subject weapons used in incidents where the statuses of the victims match a specified condition. The results are grouped by the type of weapon and ordered by the count of case numbers, allowing for a limit on the number of results returned."
        },
        {
            "sample_id": 2476,
            "vt": "SELECT CAST(SUM(officers.race = '[placeholder-type:string]') AS FLOAT) * [placeholder-type:numeric] / COUNT(officers.case_number) FROM officers WHERE officers.gender = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of officers of a specific race among all officers of a specified gender from the 'officers' table. It sums the occurrences of officers matching the specified race, multiplies this sum by a numeric placeholder, and divides it by the total count of officers for the specified gender."
        },
        {
            "sample_id": 2481,
            "vt": "SELECT COUNT(incidents.location) FROM incidents WHERE incidents.subject_weapon = '[placeholder-type:string]' AND incidents.subject_statuses = '[placeholder-type:string]' AND incidents.date BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of incidents from the 'incidents' table based on specific criteria. It filters incidents by the weapon used and the status of the subjects involved, as well as a date range for when the incidents occurred. The placeholders represent the weapon type, subject statuses, and the start and end dates for the query."
        },
        {
            "sample_id": 2468,
            "vt": "SELECT incidents.case_number, incidents.subject_statuses, incidents.subject_weapon FROM incidents INNER JOIN subjects AS T2 ON T1.case_number = T2.case_number WHERE subjects.gender = '[placeholder-type:string]'",
            "ba": "The virtual table describes the case numbers, statuses of the victims, and the weapons involved in incidents from the 'incidents' table. It joins with the 'subjects' table to filter the results based on the gender of the subjects involved in those incidents. The placeholder in the WHERE clause represents the gender of the subjects."
        }
    ],
    "airline": [
        {
            "sample_id": 5845,
            "vt": "SELECT COUNT(air carriers.code) FROM airlines INNER JOIN \"Air Carriers\" AS T2 ON T1.OP_CARRIER_AIRLINE_ID = T2.Code WHERE airlines.fl_date = '[placeholder-type:string]' AND air carriers.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of flights operated by specific air carriers on a given flight date. It joins the 'airlines' table with the 'air carriers' table to filter results based on the flight date and the description of the air carrier."
        },
        {
            "sample_id": 5903,
            "vt": "SELECT airlines.tail_num FROM \"air carriers\" INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE airlines.arr_time <= [placeholder-type:numeric] AND air carriers.description = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the tail numbers of aircraft from the 'airlines' table that are operated by a specific air carrier, as indicated by the description of the air carrier. It filters the results to include only those flights that have an arrival time less than or equal to a specified time."
        },
        {
            "sample_id": 5898,
            "vt": "SELECT air carriers.description FROM \"air carriers\" INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE airlines.dep_delay = [placeholder-type:numeric] GROUP BY air carriers.description",
            "ba": "The virtual table provides a list of descriptions of air carriers from the 'air carriers' table, filtered by the departure delay of flights in the 'airlines' table. The query joins the two tables on the carrier airline ID and groups the results by the air carrier descriptions."
        },
        {
            "sample_id": 5877,
            "vt": "SELECT COUNT(*) FROM airlines WHERE airlines.dest = '[placeholder-type:string]' AND airlines.origin = '[placeholder-type:string]' AND airlines.dep_delay = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of flights from the 'airlines' table that have a specific destination and origin airport, as well as a specified departure delay. The placeholders represent the destination airport code, origin airport code, and the departure delay in minutes."
        },
        {
            "sample_id": 5861,
            "vt": "SELECT airlines.fl_date FROM airports INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN WHERE airlines.fl_date LIKE '[placeholder-type:string]' AND airports.description = '[placeholder-type:string]' AND airlines.origin = '[placeholder-type:string]' AND airlines.cancelled = [placeholder-type:numeric] AND airlines.cancellation_code = '[placeholder-type:string]' GROUP BY airlines.fl_date ORDER BY COUNT(airlines.fl_date) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves flight dates from the 'airlines' table, filtering based on specific criteria related to the origin airport and cancellation status. It joins the 'airports' table to get the airport descriptions and applies conditions to ensure that only flights matching the specified date pattern, airport description, origin, cancellation status, and cancellation code are included. The results are grouped by flight date and ordered by the count of occurrences, with a limit on the number of results returned."
        },
        {
            "sample_id": 5884,
            "vt": "SELECT COUNT(*) FROM airports WHERE airports.code LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of airports from the 'airports' table that match a specific IATA code pattern. The placeholder in the WHERE clause allows for flexible input of the airport code to filter the results accordingly."
        },
        {
            "sample_id": 5868,
            "vt": "SELECT airlines.op_carrier_airline_id FROM \"air carriers\" INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE air carriers.description = '[placeholder-type:string]' AND airlines.origin = '[placeholder-type:string]' AND airlines.dest = '[placeholder-type:string]' GROUP BY airlines.op_carrier_airline_id ORDER BY COUNT(airlines.op_carrier_airline_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the operator carrier airline IDs from the 'air carriers' table, joining it with the 'airlines' table. It filters the results based on the description of the air carrier and the origin and destination airports, both of which are represented by placeholders for string values. The results are grouped by the operator carrier airline ID and ordered by the count of occurrences, with a limit on the number of results specified by a numeric placeholder."
        },
        {
            "sample_id": 5890,
            "vt": "SELECT airlines.origin FROM airlines ORDER BY airlines.actual_elapsed_time LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the origin airports from the 'airlines' table, ordering the results by the actual elapsed time of flights. The placeholder in the LIMIT clause allows for specifying the maximum number of records to return."
        },
        {
            "sample_id": 5823,
            "vt": "SELECT airlines.fl_date FROM airlines WHERE airlines.cancellation_code = '[placeholder-type:string]' GROUP BY airlines.fl_date",
            "ba": "The virtual table retrieves the flight dates from the 'airlines' table where the cancellation code matches a specified value. The results are grouped by flight date to summarize the data effectively."
        },
        {
            "sample_id": 5822,
            "vt": "SELECT airlines.dest FROM airlines WHERE airlines.fl_date = '[placeholder-type:string]' AND airlines.cancelled = [placeholder-type:numeric] GROUP BY airlines.dest",
            "ba": "The virtual table provides a list of destination airports from the 'airlines' table for flights on a specific date that have a certain cancellation status. The placeholders allow users to specify the flight date and whether the flight was cancelled or not."
        },
        {
            "sample_id": 5829,
            "vt": "SELECT COUNT(*) FROM airports INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN INNER JOIN \"Air Carriers\" AS T3 ON T2.OP_CARRIER_AIRLINE_ID = T3.Code WHERE airlines.fl_date = '[placeholder-type:string]' AND air carriers.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of airports that have flights originating from them on a specific flight date and are operated by a specific air carrier. It joins the 'airports' table with the 'airlines' table to match the origin airport codes and then further joins with the 'air carriers' table to filter by the air carrier's description."
        },
        {
            "sample_id": 5891,
            "vt": "SELECT airlines.fl_date, airlines.tail_num FROM airlines INNER JOIN \"Air Carriers\" AS T2 ON T1.OP_CARRIER_AIRLINE_ID = T2.Code WHERE air carriers.description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the flight date and tail number of flights from the 'airlines' table that are operated by a specific air carrier. The query joins the 'airlines' table with the 'air carriers' table to filter results based on the description of the air carrier, using a placeholder for the carrier's description."
        },
        {
            "sample_id": 5872,
            "vt": "SELECT airports.code, airports.description FROM airports LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of airport codes and their corresponding descriptions from the 'airports' table, limited to a specified number of entries. The placeholder in the LIMIT clause allows the user to define how many records they want to retrieve."
        },
        {
            "sample_id": 5879,
            "vt": "SELECT air carriers.description FROM \"air carriers\" INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID ORDER BY airlines.cancelled LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of descriptions of air carriers from the 'air carriers' table. It retrieves this information by joining the 'air carriers' table with the 'airlines' table based on the operator carrier airline ID. The results are ordered by the cancellation status of flights, and a limit is applied to the number of records returned."
        },
        {
            "sample_id": 5843,
            "vt": "SELECT COUNT(*) FROM airlines INNER JOIN \"Air Carriers\" AS T2 ON T1.OP_CARRIER_AIRLINE_ID = T2.Code WHERE airlines.cancellation_code = '[placeholder-type:string]' AND air carriers.description = '[placeholder-type:string]' AND airlines.cancelled = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of flights from the 'airlines' table that have been cancelled, based on specific criteria related to the cancellation code and the description of the air carrier. It joins the 'airlines' table with the 'air carriers' table to filter results according to the specified cancellation code and air carrier description."
        },
        {
            "sample_id": 5858,
            "vt": "SELECT airlines.origin_airport_id FROM airlines ORDER BY airlines.late_aircraft_delay LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the origin airport IDs from the 'airlines' table, ordering the results by the late aircraft delay. The placeholder in the LIMIT clause allows for specifying the maximum number of records to return."
        },
        {
            "sample_id": 5867,
            "vt": "SELECT air carriers.description FROM airports INNER JOIN Airlines AS T2 ON T1.Code = T2.DEST INNER JOIN \"Air Carriers\" AS T3 ON T2.OP_CARRIER_AIRLINE_ID = T3.Code WHERE airports.description = '[placeholder-type:string]' AND airlines.dest = '[placeholder-type:string]' GROUP BY air carriers.description ORDER BY COUNT(air carriers.description) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the descriptions of air carriers that operate flights to a specific destination airport, filtered by the airport's description. The query joins the 'airports' and 'airlines' tables to find relevant flights and then joins the 'air carriers' table to get the descriptions of those carriers. The results are grouped by the carrier descriptions and ordered by the count of flights to ensure the most frequently operating carriers are listed, with a limit on the number of results returned."
        },
        {
            "sample_id": 5826,
            "vt": "SELECT airports.description FROM airports INNER JOIN Airlines AS T2 ON T1.Code = T2.DEST WHERE airlines.fl_date = '[placeholder-type:string]' ORDER BY airlines.dep_delay LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the descriptions of airports from the 'airports' table, specifically for those airports that are destinations for flights on a specified date. The query joins the 'airports' table with the 'airlines' table to filter the results based on the flight date and orders them by the departure delay. The placeholders allow users to specify the flight date and limit the number of results returned."
        },
        {
            "sample_id": 5830,
            "vt": "SELECT airlines.op_carrier_fl_num FROM airports INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN INNER JOIN \"Air Carriers\" AS T3 ON T2.OP_CARRIER_AIRLINE_ID = T3.Code WHERE air carriers.description = '[placeholder-type:string]' AND airports.description = '[placeholder-type:string]' AND airlines.fl_date = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the operator carrier flight numbers from the 'Airlines' table, filtering based on the descriptions of the air carriers and airports, as well as the flight date. It uses inner joins to connect the 'Airlines' table with the 'Air Carriers' and 'Airports' tables based on their respective codes."
        },
        {
            "sample_id": 5892,
            "vt": "SELECT air carriers.description, air carriers.code FROM \"air carriers\" INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID ORDER BY airlines.arr_time LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the details of air carriers, specifically their descriptions and codes, by joining the 'air carriers' table with the 'airlines' table based on the operator carrier airline ID. The results are ordered by the arrival time of the flights and limited to a specified number of records."
        },
        {
            "sample_id": 5856,
            "vt": "SELECT airlines.weather_delay FROM airlines WHERE airlines.origin_airport_id = [placeholder-type:numeric] ORDER BY airlines.weather_delay LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the weather delay times for flights originating from a specific airport, identified by its airport ID. The results are ordered by the weather delay in ascending order, and the number of results returned is limited by a specified numeric placeholder."
        },
        {
            "sample_id": 5820,
            "vt": "SELECT COUNT(*) FROM airlines WHERE airlines.fl_date = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of flights from the 'airlines' table that are scheduled on a specific flight date. The placeholder in the WHERE clause represents the flight date being queried."
        },
        {
            "sample_id": 5869,
            "vt": "SELECT airlines.dest FROM \"air carriers\" INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE air carriers.description = '[placeholder-type:string]' GROUP BY airlines.dest ORDER BY COUNT(airlines.dest) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the destination airports served by specific air carriers from the 'air carriers' table. It joins the 'airlines' table to filter results based on the description of the air carrier, grouping by destination airport and ordering the results by the count of flights to each destination. The placeholders represent the air carrier's description and the limit on the number of results returned."
        },
        {
            "sample_id": 5827,
            "vt": "SELECT SUM(CASE WHEN airlines.arr_delay < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM airports INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN WHERE airports.description = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of flights arriving on time or late from a specific origin airport, based on the arrival delay. It sums up the number of flights that either have an arrival delay less than a specified threshold or not, depending on the condition provided. The query joins the 'airports' table with the 'airlines' table to filter results based on the airport's description."
        },
        {
            "sample_id": 5849,
            "vt": "SELECT COUNT(airports.code) FROM airports INNER JOIN Airlines AS T2 ON T1.Code = T2.DEST WHERE airlines.fl_date = '[placeholder-type:string]' AND airports.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of airports from the 'airports' table that are linked to flights in the 'airlines' table for a specific flight date and airport description. The placeholders represent the flight date and the airport description that the user can specify."
        },
        {
            "sample_id": 5900,
            "vt": "SELECT airlines.dest FROM \"air carriers\" INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE air carriers.description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the destination airports of flights operated by specific air carriers. It retrieves the destination airport codes from the 'airlines' table, joining it with the 'air carriers' table to filter based on the description of the air carrier. The placeholder in the WHERE clause represents the description of the air carrier."
        },
        {
            "sample_id": 5906,
            "vt": "SELECT air carriers.description FROM \"air carriers\" INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE airlines.fl_date = '[placeholder-type:string]' GROUP BY air carriers.description",
            "ba": "The virtual table describes the descriptions of air carriers from the 'air carriers' table that are associated with flights on a specific date. The query joins the 'air carriers' table with the 'airlines' table using the operator carrier airline ID, and filters the results based on the flight date provided by the placeholder."
        },
        {
            "sample_id": 5821,
            "vt": "SELECT COUNT(*) FROM airlines WHERE airlines.fl_date = '[placeholder-type:string]' AND airlines.origin = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of flights from the 'airlines' table for a specific flight date and origin airport. The placeholders represent the flight date and the origin airport code."
        },
        {
            "sample_id": 5907,
            "vt": "SELECT air carriers.description FROM airlines INNER JOIN \"Air Carriers\" AS T2 ON T2.Code = T1.OP_CARRIER_AIRLINE_ID WHERE airlines.tail_num = '[placeholder-type:string]' AND airlines.origin = '[placeholder-type:string]' GROUP BY air carriers.description",
            "ba": "The virtual table describes the descriptions of air carriers from the 'air carriers' table that are associated with flights originating from a specific airport and operated by a specific tail number. The placeholders in the WHERE clause represent the tail number of the aircraft and the origin airport code."
        },
        {
            "sample_id": 5844,
            "vt": "SELECT SUM(CASE WHEN airlines.actual_elapsed_time < airlines.crs_elapsed_time THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM airlines INNER JOIN \"Air Carriers\" AS T2 ON T1.OP_CARRIER_AIRLINE_ID = T2.Code WHERE airlines.fl_date = '[placeholder-type:string]' AND air carriers.description = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of flights that were faster than scheduled from the 'airlines' table, while also filtering based on the flight date and the description of the air carrier. The placeholders represent the specific flight date and air carrier description to be used in the query."
        },
        {
            "sample_id": 5893,
            "vt": "SELECT COUNT(*) FROM \"air carriers\" INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE air carriers.description LIKE '[placeholder-type:string]' AND airlines.arr_delay_new = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of flights operated by specific air carriers that match a given description and have a specified arrival delay. It joins the 'air carriers' table with the 'airlines' table based on the carrier code, filtering results based on the carrier's description and the arrival delay using placeholders."
        },
        {
            "sample_id": 5825,
            "vt": "SELECT COUNT(airports.code) FROM airports INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN WHERE airlines.fl_date = '[placeholder-type:string]' AND airports.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of airports from the 'airports' table that are linked to flights originating from those airports in the 'airlines' table. The query filters results based on a specific flight date and a description of the airport."
        },
        {
            "sample_id": 5848,
            "vt": "SELECT air carriers.description FROM airlines INNER JOIN \"Air Carriers\" AS T2 ON T1.OP_CARRIER_AIRLINE_ID = T2.Code WHERE airlines.fl_date = '[placeholder-type:string]' AND airlines.origin = '[placeholder-type:string]' AND airlines.dest = '[placeholder-type:string]' AND airlines.crs_dep_time = '[placeholder-type:string]' GROUP BY air carriers.description",
            "ba": "The virtual table describes the descriptions of air carriers from the 'air carriers' table that operate flights on a specific date, originating from a specific airport to a specific destination, and scheduled to depart at a specific time. The placeholders in the WHERE clause represent the flight date, origin airport, destination airport, and scheduled departure time."
        },
        {
            "sample_id": 5828,
            "vt": "SELECT airlines.dep_time FROM airports INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN WHERE airlines.fl_date = '[placeholder-type:string]' AND airports.description = '[placeholder-type:string]' AND NOT airlines.dep_time IS NULL ORDER BY airlines.dep_time LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the departure times of flights from the 'airlines' table, filtered by flight date and airport description. It joins the 'airports' table to match the origin airport code with the corresponding airport description. The results are ordered by departure time and limited to a specified number of entries."
        },
        {
            "sample_id": 5874,
            "vt": "SELECT airlines.crs_dep_time, airlines.dep_time FROM airlines WHERE airlines.origin = '[placeholder-type:string]' AND airlines.dest = '[placeholder-type:string]' AND airlines.tail_num = '[placeholder-type:string]' AND airlines.fl_date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the scheduled departure time and actual departure time of flights from the 'airlines' table based on specific criteria. The placeholders in the WHERE clause represent the origin airport, destination airport, plane's tail number, and flight date."
        },
        {
            "sample_id": 5876,
            "vt": "SELECT airlines.dest FROM airlines WHERE airlines.origin = '[placeholder-type:string]' GROUP BY airlines.dest",
            "ba": "The virtual table describes the destination airports from the 'airlines' table based on a specified origin airport. The placeholder in the WHERE clause represents the origin airport's code, and the results are grouped by destination to provide a list of unique destinations."
        },
        {
            "sample_id": 5905,
            "vt": "SELECT COUNT(*) FROM \"air carriers\" INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE air carriers.description LIKE '[placeholder-type:string]' AND airlines.dep_delay > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of flights operated by air carriers that match a specific description and have a departure delay greater than a specified numeric value. It joins the 'air carriers' table with the 'airlines' table based on the carrier code, filtering results based on the carrier description and the departure delay."
        },
        {
            "sample_id": 5832,
            "vt": "SELECT airlines.op_carrier_fl_num FROM airlines INNER JOIN Airports AS T2 ON T2.Code = T1.ORIGIN INNER JOIN \"Air Carriers\" AS T3 ON T1.OP_CARRIER_AIRLINE_ID = T3.Code WHERE air carriers.description = '[placeholder-type:string]' ORDER BY airlines.dep_time LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the operator carrier flight numbers from the 'airlines' table for flights operated by air carriers with a specific description. It joins the 'airlines' table with the 'airports' table to get the origin airport details and with the 'air carriers' table to filter by the carrier's description. The results are ordered by departure time and limited to a specified number of records."
        },
        {
            "sample_id": 5883,
            "vt": "SELECT COUNT(*) FROM airlines WHERE airlines.origin = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of flights originating from a specific airport in the 'airlines' table. The placeholder in the WHERE clause represents the airport code of origin."
        },
        {
            "sample_id": 5870,
            "vt": "SELECT airlines.op_carrier_airline_id FROM airlines INNER JOIN Airports AS T2 ON T1.ORIGIN = T2.Code WHERE NOT airlines.actual_elapsed_time IS NULL AND NOT airlines.crs_elapsed_time IS NULL ORDER BY airlines.actual_elapsed_time - airlines.crs_elapsed_time LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the operator carrier airline IDs from the 'airlines' table, joining it with the 'airports' table to filter based on the origin airport. It ensures that both actual and scheduled elapsed times are not null, indicating that the flight data is complete. The results are ordered by the difference between actual and scheduled elapsed times, allowing for an analysis of flights that were either faster or slower than expected. The query limits the number of results returned based on a specified numeric placeholder."
        },
        {
            "sample_id": 5838,
            "vt": "SELECT COUNT(air carriers.code) FROM \"air carriers\"",
            "ba": "The virtual table counts the number of air carriers from the 'air carriers' table."
        },
        {
            "sample_id": 5847,
            "vt": "SELECT airports.description FROM airports INNER JOIN Airlines AS T2 ON T1.Code = T2.DEST WHERE airlines.fl_date = '[placeholder-type:string]' ORDER BY airlines.dest LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the descriptions of airports from the 'airports' table that are linked to flights in the 'airlines' table for a specific flight date. The placeholders represent the flight date and the limit on the number of results returned."
        },
        {
            "sample_id": 5885,
            "vt": "SELECT airlines.dest FROM airlines WHERE airlines.op_carrier_fl_num = [placeholder-type:numeric]",
            "ba": "The virtual table describes the destination airports of flights from the 'airlines' table based on a specific operator carrier flight number. The placeholder in the WHERE clause represents the flight number for which the destination is being queried."
        },
        {
            "sample_id": 5854,
            "vt": "SELECT COUNT(*) FROM airlines WHERE airlines.fl_date = '[placeholder-type:string]' AND airlines.dep_delay <= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of flights from the 'airlines' table that are scheduled on a specific flight date and have a departure delay that is less than or equal to a specified value. The placeholders represent the flight date and the maximum allowable departure delay in minutes."
        },
        {
            "sample_id": 5850,
            "vt": "SELECT COUNT(airlines.fl_date) FROM airlines WHERE airlines.fl_date LIKE '[placeholder-type:string]' AND airlines.origin = (SELECT airlines.origin FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN WHERE T1.Description = 'San Diego, CA: San Diego International') AND airlines.dest = (SELECT airlines.dest FROM Airports AS T3 INNER JOIN Airlines AS T4 ON T3.Code = T4.DEST WHERE T3.Description = 'Los Angeles, CA: Los Angeles International')",
            "ba": "The virtual table counts the number of flights from a specific origin airport to a specific destination airport on a given flight date. The origin airport is filtered by its description, which corresponds to 'San Diego, CA: San Diego International', and the destination airport is filtered by its description, which corresponds to 'Los Angeles, CA: Los Angeles International'. The flight date is specified using a placeholder for string values."
        },
        {
            "sample_id": 5902,
            "vt": "SELECT COUNT(*) FROM \"air carriers\" INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE air carriers.description LIKE '[placeholder-type:string]' AND airlines.fl_date = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of flights operated by air carriers that match a specific description and flight date. It joins the 'air carriers' table with the 'airlines' table based on the carrier code, filtering results based on the carrier's description and the flight date provided as placeholders."
        },
        {
            "sample_id": 5862,
            "vt": "SELECT airlines.tail_num FROM airports INNER JOIN Airlines AS T2 ON T1.Code = T2.DEST WHERE airlines.fl_date LIKE '[placeholder-type:string]' AND airports.description = '[placeholder-type:string]' AND airlines.dest = '[placeholder-type:string]' AND airlines.arr_delay <= [placeholder-type:numeric] GROUP BY airlines.tail_num",
            "ba": "The virtual table retrieves the tail numbers of aircraft from the 'airlines' table that have flights on a specific date, arriving at a specified airport, and with a maximum allowable arrival delay. The query joins the 'airports' table to filter based on the airport's description and uses placeholders for the flight date, airport description, destination airport code, and arrival delay."
        },
        {
            "sample_id": 5882,
            "vt": "SELECT airports.description FROM airports WHERE airports.code = '[placeholder-type:string]'",
            "ba": "The virtual table describes the descriptions of airports from the 'airports' table based on a specific airport code. The placeholder in the WHERE clause represents the IATA code of the airport."
        },
        {
            "sample_id": 5896,
            "vt": "SELECT airlines.actual_elapsed_time FROM \"air carriers\" INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE air carriers.description = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the actual elapsed time of flights operated by specific air carriers from the 'airlines' table, filtered by the description of the air carrier from the 'air carriers' table. The placeholder in the WHERE clause represents the description of the air carrier."
        },
        {
            "sample_id": 5859,
            "vt": "SELECT COUNT(airlines.fl_date) FROM airlines WHERE airlines.origin = (SELECT airlines.origin FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN WHERE T1.Description = 'Chicago, IL: Chicago O''Hare International') AND airlines.dest = (SELECT airlines.dest FROM Airports AS T3 INNER JOIN Airlines AS T4 ON T3.Code = T4.DEST WHERE T3.Description = 'Atlanta, GA: Hartsfield-Jackson Atlanta International')",
            "ba": "The virtual table counts the number of flights from a specific origin airport to a specific destination airport. The origin airport is identified by its description 'Chicago, IL: Chicago O'Hare International', and the destination airport is identified by its description 'Atlanta, GA: Hartsfield-Jackson Atlanta International'."
        },
        {
            "sample_id": 5895,
            "vt": "SELECT air carriers.description FROM \"air carriers\" INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE airlines.cancelled = [placeholder-type:numeric] GROUP BY air carriers.description",
            "ba": "The virtual table describes the descriptions of air carriers from the 'air carriers' table that are associated with flights in the 'airlines' table which have a specific cancellation status. The placeholder in the WHERE clause represents the cancellation status of the flights."
        },
        {
            "sample_id": 5871,
            "vt": "SELECT airlines.tail_num, SUM(CAST(airlines.late_aircraft_delay AS FLOAT) / [placeholder-type:numeric]) FROM airlines INNER JOIN \"Air Carriers\" AS T2 ON T2.Code = T1.OP_CARRIER_AIRLINE_ID WHERE airlines.fl_date LIKE '[placeholder-type:string]' AND air carriers.description = '[placeholder-type:string]' ORDER BY None.delay LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the tail numbers of aircraft along with the total late aircraft delay, calculated as a fraction of a specified numeric value, for flights operated by a specific airline on a given flight date. The data is retrieved by joining the 'airlines' table with the 'air carriers' table based on the operator carrier airline ID. The results are filtered by the flight date and the description of the air carrier, and are ordered without any specific delay criteria, limited to a specified number of results."
        },
        {
            "sample_id": 5846,
            "vt": "SELECT air carriers.description FROM airlines INNER JOIN \"Air Carriers\" AS T2 ON T1.OP_CARRIER_AIRLINE_ID = T2.Code WHERE airlines.tail_num = '[placeholder-type:string]' GROUP BY air carriers.description",
            "ba": "The virtual table describes the descriptions of air carriers associated with a specific flight's tail number from the 'airlines' table. It uses an inner join to connect the 'airlines' table with the 'air carriers' table based on the operator carrier airline ID, ensuring that only relevant air carrier descriptions are retrieved. The placeholder in the WHERE clause represents the tail number of the flight."
        },
        {
            "sample_id": 5901,
            "vt": "SELECT COUNT(*) FROM \"air carriers\" INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE air carriers.description = '[placeholder-type:string]' AND airlines.cancelled = [placeholder-type:numeric] AND airlines.fl_date BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of flights operated by a specific air carrier that have been cancelled, within a specified date range. It joins the 'air carriers' table with the 'airlines' table based on the carrier's code and filters the results based on the carrier's description and cancellation status."
        },
        {
            "sample_id": 5824,
            "vt": "SELECT airports.description FROM airports INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN WHERE airlines.fl_date = '[placeholder-type:string]' AND airlines.dep_delay > [placeholder-type:numeric] GROUP BY airports.description",
            "ba": "The virtual table describes the airport descriptions for flights originating from specific airports on a given flight date, where the departure delay exceeds a specified threshold. The placeholders represent the flight date and the minimum departure delay in minutes."
        }
    ],
    "shipping": [
        {
            "sample_id": 5610,
            "vt": "SELECT COUNT(*) FROM customer INNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id INNER JOIN city AS T3 ON T3.city_id = T2.city_id WHERE city.city_name = '[placeholder-type:string]' AND customer.cust_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of customers who have made shipments to a specific city. It joins the 'customer' table with the 'shipment' table to link customers with their respective shipments, and further joins the 'city' table to filter the results based on the city name. The placeholders represent the city name and customer name for which the count is being requested."
        },
        {
            "sample_id": 5635,
            "vt": "SELECT driver.first_name, driver.last_name FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE shipment.ship_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of drivers associated with a specific shipment from the 'shipment' table. It uses an inner join to connect the 'shipment' table with the 'driver' table based on the driver ID, allowing for the retrieval of driver names for a given shipment ID."
        },
        {
            "sample_id": 5632,
            "vt": "SELECT shipment.weight FROM truck INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id WHERE truck.make = '[placeholder-type:string]'",
            "ba": "The virtual table describes the weight of shipments associated with trucks of a specific make. It retrieves data from the 'shipment' table and joins it with the 'truck' table based on the truck's unique identifier. The placeholder in the WHERE clause represents the make of the truck."
        },
        {
            "sample_id": 5643,
            "vt": "SELECT truck.make, truck.model_year FROM truck INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id WHERE shipment.ship_id = '[placeholder-type:string]'",
            "ba": "The virtual table displays the make and model year of trucks from the 'truck' table that are associated with a specific shipment. The query uses an inner join to connect the 'truck' table with the 'shipment' table based on the truck's unique identifier. The placeholder in the WHERE clause represents the unique identifier of the shipment."
        },
        {
            "sample_id": 5661,
            "vt": "SELECT CAST(SUM(CASE WHEN driver.first_name = '[placeholder-type:string]' AND driver.last_name = '[placeholder-type:string]' THEN shipment.ship_id ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE STRFTIME('%Y', shipment.ship_date) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of shipment IDs for a specific driver based on their first and last names, filtered by the year of the shipment date. It uses a conditional sum to count only the shipments associated with the specified driver, and then multiplies this sum by a numeric placeholder before dividing by the total count of shipments to derive the average."
        },
        {
            "sample_id": 5601,
            "vt": "SELECT city.area FROM shipment INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE shipment.ship_id = '[placeholder-type:string]'",
            "ba": "The virtual table provides the area of the city associated with a specific shipment from the 'shipment' table. It uses an inner join to connect the 'shipment' table with the 'city' table based on the city_id, allowing us to retrieve the area of the city where the shipment is destined. The placeholder in the WHERE clause represents the unique identifier of the shipment."
        },
        {
            "sample_id": 5645,
            "vt": "SELECT COUNT(*) FROM customer WHERE customer.cust_type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customer' table who belong to a specific customer type. The placeholder in the WHERE clause represents the type of customer, which can be either a manufacturer or a wholesaler."
        },
        {
            "sample_id": 5578,
            "vt": "SELECT COUNT(shipment.ship_id) FROM customer INNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id WHERE customer.cust_name = '[placeholder-type:string]' AND STRFTIME('%Y', shipment.ship_date) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of shipments associated with a specific customer name and shipment year. It joins the 'customer' table with the 'shipment' table based on the customer ID, filtering results by the customer's name and the year of the shipment date."
        },
        {
            "sample_id": 5616,
            "vt": "SELECT COUNT(*) FROM driver INNER JOIN shipment AS T2 ON T1.driver_id = T2.driver_id INNER JOIN city AS T3 ON T3.city_id = T2.city_id WHERE driver.first_name = '[placeholder-type:string]' AND driver.last_name = '[placeholder-type:string]' AND city.city_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of shipments associated with a specific driver and city. It joins the 'driver' table with the 'shipment' table to link drivers to their respective shipments, and then further joins the 'city' table to filter by the destination city of those shipments. The placeholders represent the driver's first name, last name, and the city's name."
        },
        {
            "sample_id": 5646,
            "vt": "SELECT COUNT(*) FROM customer WHERE customer.cust_type = '[placeholder-type:string]' AND customer.state = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customer' table based on their type and state. The placeholders in the WHERE clause represent the specific customer type and state to filter the results accordingly."
        },
        {
            "sample_id": 5608,
            "vt": "SELECT driver.first_name, driver.last_name FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id ORDER BY shipment.ship_date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of drivers from the 'driver' table who are associated with shipments. The query joins the 'shipment' table with the 'driver' table based on the driver ID, allowing us to retrieve the names of drivers for a specified number of recent shipments, as indicated by the placeholder in the LIMIT clause."
        },
        {
            "sample_id": 5618,
            "vt": "SELECT CAST(SUM(CASE WHEN customer.cust_type = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM customer WHERE customer.state = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of a specific customer type's annual revenue from the 'customer' table, filtered by the state. It uses a conditional sum to differentiate between customer types and applies a multiplier to the result, then divides by the total count of customers in that state."
        },
        {
            "sample_id": 5638,
            "vt": "SELECT driver.first_name, driver.last_name FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE shipment.ship_date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of drivers from the 'driver' table who are associated with shipments received on a specific date. The query uses an inner join to connect the 'shipment' and 'driver' tables based on the driver ID, filtering results by the shipment date using a placeholder for string values."
        },
        {
            "sample_id": 5603,
            "vt": "SELECT driver.first_name, driver.last_name FROM truck INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id INNER JOIN driver AS T3 ON T3.driver_id = T2.driver_id WHERE truck.truck_id = '[placeholder-type:string]' AND shipment.ship_date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of drivers associated with a specific truck and shipment date. It combines data from the 'truck', 'shipment', and 'driver' tables, filtering based on the truck's unique identifier and the shipment date."
        },
        {
            "sample_id": 5626,
            "vt": "SELECT COUNT(*) FROM shipment INNER JOIN city AS T2 ON T1.city_id = T2.city_id INNER JOIN driver AS T3 ON T3.driver_id = T1.driver_id WHERE driver.first_name = '[placeholder-type:string]' AND driver.last_name = '[placeholder-type:string]' AND city.city_name = '[placeholder-type:string]' AND STRFTIME('%Y', shipment.ship_date) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of shipments made by a specific driver to a specific city during a specified year. It joins the 'shipment' table with the 'city' and 'driver' tables to filter the results based on the driver's first and last name, the city's name, and the year of the shipment date."
        },
        {
            "sample_id": 5630,
            "vt": "SELECT COUNT(*) FROM (SELECT city.city_id FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE T2.state = 'New Jersey' GROUP BY T2.city_id HAVING SUM(T1.weight) > 20000)",
            "ba": "The virtual table counts the number of unique cities in New Jersey that have received shipments weighing more than 20,000 pounds. It does this by joining the 'shipment' table with the 'city' table based on the city ID, filtering for cities in New Jersey, and grouping the results by city ID to apply the weight condition."
        },
        {
            "sample_id": 5586,
            "vt": "SELECT COUNT(*) FROM shipment INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE STRFTIME('%Y', shipment.ship_date) = '[placeholder-type:string]' AND city.state = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of shipments from the 'shipment' table, filtered by the year of the shipment date and the state of the destination city. It joins the 'shipment' table with the 'city' table to access the state information for the filtering criteria."
        },
        {
            "sample_id": 5647,
            "vt": "SELECT COUNT(*) FROM city WHERE city.state = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cities from the 'city' table that are located in a specific state. The placeholder in the WHERE clause represents the name of the state."
        },
        {
            "sample_id": 5664,
            "vt": "SELECT shipment.ship_id FROM shipment INNER JOIN city AS T2 ON T1.city_id = T2.city_id ORDER BY city.area LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of shipments from the 'shipment' table, while also joining with the 'city' table to access city-related information. The results are ordered by the area of the city, and a limit is applied to restrict the number of records returned based on a specified numeric value."
        },
        {
            "sample_id": 5615,
            "vt": "SELECT COUNT(*) FROM shipment INNER JOIN city AS T2 ON T1.city_id = T2.city_id INNER JOIN customer AS T3 ON T3.cust_id = T1.cust_id WHERE city.city_name = '[placeholder-type:string]' AND STRFTIME('%Y', shipment.ship_date) = '[placeholder-type:string]' AND customer.state = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of shipments from the 'shipment' table, joining with the 'city' and 'customer' tables to filter based on the city name, shipment year, and customer state. The placeholders represent the specific city name, year of shipment, and state of the customer."
        },
        {
            "sample_id": 5679,
            "vt": "SELECT shipment.weight FROM shipment INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id WHERE customer.annual_revenue = [placeholder-type:numeric]",
            "ba": "The virtual table displays the weight of shipments from the 'shipment' table, filtered by the annual revenue of customers from the 'customer' table. The placeholder in the WHERE clause represents the annual revenue amount for which the user wants to find corresponding shipment weights."
        },
        {
            "sample_id": 5588,
            "vt": "SELECT SUM(CASE WHEN city.city_name = '[placeholder-type:string]' THEN shipment.weight ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN city.city_name = '[placeholder-type:string]' THEN shipment.weight ELSE [placeholder-type:numeric] END) FROM shipment INNER JOIN city AS T2 ON T1.city_id = T2.city_id",
            "ba": "The virtual table calculates the difference in total shipment weights for a specific city by summing the weights of shipments associated with that city and subtracting the weights of shipments not associated with that city. The placeholders represent the city name and a numeric value for comparison."
        },
        {
            "sample_id": 5617,
            "vt": "SELECT COUNT(*) FROM shipment INNER JOIN city AS T2 ON T1.city_id = T2.city_id ORDER BY city.area / city.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of shipments grouped by city, utilizing an inner join between the 'shipment' and 'city' tables. It calculates the population density for each city by dividing the area of the city by its population. The results are ordered based on this calculated density, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 5612,
            "vt": "SELECT driver.first_name, driver.last_name FROM driver INNER JOIN shipment AS T2 ON T1.driver_id = T2.driver_id INNER JOIN city AS T3 ON T3.city_id = T2.city_id GROUP BY driver.first_name, driver.last_name, city.population HAVING city.population = MAX(city.population) ORDER BY COUNT(*) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of drivers who have made shipments to cities with the highest population. It joins the 'driver' table with the 'shipment' table to link drivers to their respective shipments, and then further joins with the 'city' table to access city population data. The results are grouped by the driver's name and filtered to only include those associated with the city that has the maximum population. The final output is limited by a numeric placeholder, allowing users to specify how many driver names they want to retrieve."
        },
        {
            "sample_id": 5666,
            "vt": "SELECT COUNT(*) FROM shipment INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE city.city_name = '[placeholder-type:string]' AND city.state = '[placeholder-type:string]' AND shipment.weight BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of shipments from the 'shipment' table that are associated with a specific city and state. It filters the results based on the city name and state, as well as the weight of the shipments, which must fall within a specified range."
        },
        {
            "sample_id": 5629,
            "vt": "SELECT CAST(SUM(CASE WHEN customer.cust_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id INNER JOIN customer AS T3 ON T3.cust_id = T1.cust_id WHERE driver.first_name = '[placeholder-type:string]' AND driver.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of a specific numeric value from the 'shipment' table based on the customer's name and the driver's full name. It uses a conditional sum to include only the shipments related to a specified customer, and then divides this sum by the total count of shipments to derive the average. The query joins the 'shipment' table with the 'driver' and 'customer' tables to access the necessary information for filtering and calculations."
        },
        {
            "sample_id": 5621,
            "vt": "SELECT shipment.weight, customer.cust_name FROM shipment INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id INNER JOIN city AS T3 ON T3.city_id = T1.city_id WHERE city.city_name = '[placeholder-type:string]' ORDER BY shipment.weight LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the weights of shipments along with the names of customers associated with those shipments. It retrieves data from the 'shipment' table and joins it with the 'customer' table to get the customer names. Additionally, it joins with the 'city' table to filter the results based on a specific city name. The results are ordered by shipment weight and limited to a specified number of entries."
        },
        {
            "sample_id": 5675,
            "vt": "SELECT COUNT(*) FROM shipment INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id WHERE customer.state = '[placeholder-type:string]'",
            "ba": "The virtual table counts the total number of shipments from the 'shipment' table, joining it with the 'customer' table to filter based on the state of the customer. The placeholder in the WHERE clause represents the state of the customer."
        },
        {
            "sample_id": 5611,
            "vt": "SELECT COUNT(shipment.ship_id) FROM truck INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id WHERE truck.make = '[placeholder-type:string]' ORDER BY shipment.weight LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of shipments associated with trucks of a specific make. It joins the 'truck' table with the 'shipment' table based on the truck's unique identifier. The query filters the results to include only those trucks that match the specified make and orders the shipments by their weight. The result is limited to a specified number of entries."
        },
        {
            "sample_id": 5582,
            "vt": "SELECT shipment.ship_id FROM customer INNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id WHERE customer.cust_type = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of shipments from the 'shipment' table that are associated with customers of a specific type from the 'customer' table. The placeholder in the WHERE clause represents the type of customer, which can be either a manufacturer or a wholesaler."
        },
        {
            "sample_id": 5671,
            "vt": "SELECT driver.address FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE shipment.ship_id = '[placeholder-type:string]'",
            "ba": "The virtual table provides the address of the driver associated with a specific shipment from the 'shipment' table. It uses an inner join to connect the 'shipment' table with the 'driver' table based on the driver ID, ensuring that only the relevant driver's address for the specified shipment ID is retrieved."
        },
        {
            "sample_id": 5633,
            "vt": "SELECT truck.model_year FROM truck INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id WHERE shipment.ship_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the model year of a truck from the 'truck' table based on a specific shipment identified by its unique shipment ID. The query uses an inner join to connect the 'truck' table with the 'shipment' table, ensuring that only the truck associated with the specified shipment is selected."
        },
        {
            "sample_id": 5609,
            "vt": "SELECT COUNT(shipment.ship_id) FROM customer INNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id WHERE customer.cust_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of shipments associated with a specific customer from the 'customer' table. It uses an inner join to connect the 'customer' table with the 'shipment' table based on the customer ID. The placeholder in the WHERE clause represents the name of the customer for whom the shipment count is being queried."
        },
        {
            "sample_id": 5599,
            "vt": "SELECT MIN(shipment.ship_date) FROM shipment INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id WHERE customer.state = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the earliest shipment date from the 'shipment' table for customers located in a specific state. It joins the 'shipment' table with the 'customer' table to filter the results based on the state of the customer, using a placeholder for the state name."
        },
        {
            "sample_id": 5681,
            "vt": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', shipment.ship_date) = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM shipment INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id WHERE customer.state = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average weight of shipments for a specific year and state. It sums the weights of shipments that match the specified year and divides by the total number of shipments for that year, adjusting the result by a placeholder numeric value. The query joins the shipment table with the customer table to filter results based on the customer's state."
        },
        {
            "sample_id": 5669,
            "vt": "SELECT COUNT(*) FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE driver.first_name = '[placeholder-type:string]' AND driver.last_name = '[placeholder-type:string]' AND STRFTIME('%Y', shipment.ship_date) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of shipments associated with a specific driver based on their first and last names, as well as the year of the shipment date. It joins the 'shipment' table with the 'driver' table to filter the results accordingly."
        },
        {
            "sample_id": 5602,
            "vt": "SELECT shipment.weight FROM shipment INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id WHERE customer.cust_name = '[placeholder-type:string]' AND shipment.ship_date = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the weight of shipments from the 'shipment' table, joining it with the 'customer' table to filter results based on a specific customer's name and the date the shipment was received."
        },
        {
            "sample_id": 5597,
            "vt": "SELECT driver.first_name, driver.last_name FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE shipment.ship_date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of drivers from the 'driver' table who are associated with shipments received on a specific date. The query uses an inner join to connect the 'shipment' and 'driver' tables based on the driver ID, filtering results by the shipment date using a placeholder for string values."
        },
        {
            "sample_id": 5627,
            "vt": "SELECT CAST(COUNT(*) AS FLOAT) / ([placeholder-type:numeric] * COUNT(driver.driver_id)) FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id",
            "ba": "The virtual table calculates the population density of shipments per driver by dividing the total number of shipments by the product of a specified numeric value and the count of drivers. It uses an inner join between the shipment and driver tables to associate each shipment with its corresponding driver."
        },
        {
            "sample_id": 5655,
            "vt": "SELECT shipment.ship_id FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE driver.first_name = '[placeholder-type:string]' AND driver.last_name = '[placeholder-type:string]' ORDER BY shipment.weight LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the shipment IDs from the 'shipment' table for shipments handled by a specific driver, identified by their first and last names. The results are ordered by the weight of the shipments, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 5628,
            "vt": "SELECT CAST(SUM(CASE WHEN shipment.weight >= [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM shipment INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id WHERE customer.cust_name = '[placeholder-type:string]' AND STRFTIME('%Y', shipment.ship_date) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of shipment weights for a specific customer over a specified year. It sums the weights of shipments that meet a certain condition and divides by the count of shipments, adjusting the result based on a placeholder value. The query joins the shipment table with the customer table to filter results based on the customer's name and the year of shipment."
        },
        {
            "sample_id": 5598,
            "vt": "SELECT city.population FROM shipment INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE shipment.ship_id = '[placeholder-type:string]'",
            "ba": "The virtual table provides the population of the city associated with a specific shipment. It retrieves data from the 'shipment' table and joins it with the 'city' table to access the population information based on the shipment's unique identifier."
        },
        {
            "sample_id": 5663,
            "vt": "SELECT COUNT(*) FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE shipment.driver_id = [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of shipments associated with a specific driver from the 'shipment' table. It joins the 'shipment' table with the 'driver' table to access driver information, filtering the results based on a specific driver's ID."
        },
        {
            "sample_id": 5648,
            "vt": "SELECT city.city_name FROM city WHERE city.state = '[placeholder-type:string]' AND city.population = (SELECT MAX(city.population) FROM city WHERE state = 'California')",
            "ba": "The virtual table retrieves the name of the city from the 'city' table that is located in a specific state and has the highest population among cities in California. The placeholder in the WHERE clause represents the state name."
        },
        {
            "sample_id": 5596,
            "vt": "SELECT driver.first_name, driver.last_name FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE shipment.ship_id = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of drivers associated with a specific shipment from the 'shipment' table. It uses an inner join to connect the 'shipment' table with the 'driver' table based on the driver ID, allowing us to retrieve the driver's full name for a given shipment ID."
        },
        {
            "sample_id": 5651,
            "vt": "SELECT COUNT(*) FROM customer INNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id WHERE STRFTIME('%Y', shipment.ship_date) = '[placeholder-type:string]' AND customer.state = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers who have made shipments in a specific year and from a specific state. It joins the 'customer' table with the 'shipment' table based on the customer ID, filtering the results by the shipment date and the customer's state."
        },
        {
            "sample_id": 5642,
            "vt": "SELECT driver.phone FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id GROUP BY driver.driver_id HAVING SUM(shipment.weight) > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the phone numbers of drivers from the 'driver' table who have transported shipments exceeding a specified total weight. It uses an inner join between the 'shipment' and 'driver' tables, grouping the results by driver ID and filtering those groups based on the total weight of shipments they have handled."
        },
        {
            "sample_id": 5592,
            "vt": "SELECT truck.make FROM truck INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id WHERE shipment.ship_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the make of the truck used for a specific shipment from the 'truck' table. It joins the 'truck' table with the 'shipment' table to link the truck information with the corresponding shipment details. The placeholder in the WHERE clause represents the unique identifier of the shipment."
        },
        {
            "sample_id": 5580,
            "vt": "SELECT COUNT(*) FROM customer INNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id INNER JOIN driver AS T3 ON T3.driver_id = T2.driver_id WHERE customer.cust_name = '[placeholder-type:string]' AND driver.first_name = '[placeholder-type:string]' AND driver.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of shipments associated with a specific customer and driver. It joins the 'customer' table with the 'shipment' table to link customers to their shipments, and then joins the 'driver' table to associate drivers with those shipments. The placeholders in the WHERE clause represent the customer's name and the driver's first and last names, allowing for dynamic querying based on user input."
        },
        {
            "sample_id": 5639,
            "vt": "SELECT AVG(customer.annual_revenue) FROM customer INNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id WHERE shipment.weight < [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average annual revenue of customers from the 'customer' table who have shipments weighing less than a specified amount. It joins the 'customer' table with the 'shipment' table to filter the customers based on their shipment weights."
        },
        {
            "sample_id": 5657,
            "vt": "SELECT CASE WHEN truck.make = '[placeholder-type:string]' THEN '[placeholder-type:string]' WHEN truck.make = '[placeholder-type:string]' THEN '[placeholder-type:string]' WHEN truck.make = '[placeholder-type:string]' THEN '[placeholder-type:string]' END FROM shipment INNER JOIN truck AS T2 ON T1.truck_id = T2.truck_id WHERE CAST(shipment.ship_date AS DATE) = [placeholder-type:numeric] GROUP BY truck.make ORDER BY COUNT(shipment.ship_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the number of shipments made by different truck makes on a specific date. It uses a CASE statement to categorize the truck makes into specific groups. The query joins the 'shipment' table with the 'truck' table to access the truck details, filters the results based on the shipment date, and groups the results by truck make. The output is ordered by the count of shipments for each make, and it limits the results to a specified number."
        },
        {
            "sample_id": 5683,
            "vt": "SELECT driver.first_name, driver.last_name FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE shipment.weight * [placeholder-type:numeric] > (SELECT [placeholder-type:numeric] * AVG(shipment.weight) FROM shipment)",
            "ba": "The virtual table describes the first and last names of drivers from the 'driver' table who are associated with shipments that exceed a certain weight threshold. The query uses an inner join to connect the 'shipment' and 'driver' tables based on the driver ID, and it filters the results based on a condition that compares the weight of the shipment multiplied by a placeholder value against the average weight of all shipments multiplied by another placeholder value."
        },
        {
            "sample_id": 5662,
            "vt": "SELECT CAST(SUM(CASE WHEN driver.first_name = '[placeholder-type:string]' AND driver.last_name = '[placeholder-type:string]' THEN shipment.weight ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(shipment.weight) FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE STRFTIME('%Y', shipment.ship_date) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of the shipment weights for a specific driver over a given year. It sums the weights of shipments handled by the driver identified by their first and last names, and then normalizes this sum by the total weight of all shipments in that year. The placeholders represent the driver's name, a numeric value for scaling, and the year for filtering the shipments."
        },
        {
            "sample_id": 5587,
            "vt": "SELECT MAX(shipment.weight) FROM shipment INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE city.city_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum weight of shipments from the 'shipment' table, filtered by the city name from the 'city' table. The placeholder in the WHERE clause represents the specific city name for which the maximum shipment weight is being queried."
        },
        {
            "sample_id": 5591,
            "vt": "SELECT CAST(SUM(CASE WHEN city.city_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM shipment INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE city.state = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average weight of shipments for a specific city and state. It sums the weights of shipments where the city name matches a specified value and divides it by the total number of shipments in that state. The placeholders represent the city name, weight values, and state name."
        },
        {
            "sample_id": 5668,
            "vt": "SELECT driver.address FROM shipment INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id INNER JOIN driver AS T3 ON T3.driver_id = T1.driver_id WHERE customer.address = '[placeholder-type:string]' AND customer.city = '[placeholder-type:string]' AND customer.state = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the addresses of drivers from the 'shipment' table, which is linked to the 'customer' table to filter based on the customer's address, city, and state. The placeholders in the WHERE clause represent the specific address, city, and state of the customer."
        },
        {
            "sample_id": 5600,
            "vt": "SELECT shipment.weight FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE driver.first_name = '[placeholder-type:string]' AND driver.last_name = '[placeholder-type:string]' AND shipment.ship_date = '[placeholder-type:string]'",
            "ba": "The virtual table provides the weight of shipments that were transported by a specific driver on a particular date. It joins the 'shipment' table with the 'driver' table to filter the results based on the driver's first and last name, as well as the shipment date."
        },
        {
            "sample_id": 5607,
            "vt": "SELECT customer.cust_name FROM shipment INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id ORDER BY shipment.weight LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of customers from the 'customer' table who have shipments recorded in the 'shipment' table. The results are ordered by the weight of the shipments, and a limit is applied to restrict the number of customer names returned."
        },
        {
            "sample_id": 5614,
            "vt": "SELECT customer.annual_revenue FROM shipment INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id GROUP BY shipment.cust_id ORDER BY COUNT(shipment.cust_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the annual revenue of customers from the 'customer' table who have made shipments. It uses an inner join to connect the 'shipment' table with the 'customer' table based on the customer ID. The results are grouped by customer ID to aggregate the data, and they are ordered by the count of shipments per customer. The limit placeholder allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 5660,
            "vt": "SELECT DISTINCT city.city_name FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id INNER JOIN city AS T3 ON T1.city_id = T3.city_id WHERE driver.first_name = '[placeholder-type:string]' AND driver.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the unique names of cities from the 'shipment' table where the shipments were handled by a specific driver identified by their first and last names. It involves joining the 'shipment' table with the 'driver' and 'city' tables to filter the results based on the driver's name."
        },
        {
            "sample_id": 5665,
            "vt": "SELECT driver.first_name, driver.last_name FROM shipment INNER JOIN city AS T2 ON T1.city_id = T2.city_id INNER JOIN driver AS T3 ON T3.driver_id = T1.driver_id ORDER BY city.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of drivers from the 'driver' table who are associated with shipments to various cities. The query joins the 'shipment' table with the 'city' table to access city information, and it also joins with the 'driver' table to retrieve driver names. The results are ordered by the population of the cities, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 5606,
            "vt": "SELECT shipment.weight FROM shipment INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE driver.first_name = '[placeholder-type:string]' AND driver.last_name = '[placeholder-type:string]' ORDER BY shipment.ship_date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the weight of shipments from the 'shipment' table, specifically for shipments handled by a driver identified by their first and last name. It joins the 'shipment' table with the 'driver' table to filter the results based on the driver's name. The results are ordered by the shipment date, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 5674,
            "vt": "SELECT city.city_name FROM shipment INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE shipment.ship_date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of cities from the 'shipment' table based on the shipment date. It uses an inner join to connect the 'shipment' table with the 'city' table, allowing for the retrieval of city names associated with specific shipments that occurred on a given date. The placeholder in the WHERE clause represents the shipment date."
        }
    ],
    "music_tracker": [
        {
            "sample_id": 2067,
            "vt": "SELECT AVG(torrents.totalsnatched) FROM torrents WHERE torrents.artist LIKE '[placeholder-type:string]' AND torrents.releasetype LIKE '[placeholder-type:string]' AND torrents.groupyear BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of times releases have been downloaded from the 'torrents' table, filtered by a specific artist, release type, and a range of release years. The placeholders represent the artist's name, the type of release, and the start and end years for filtering."
        },
        {
            "sample_id": 2047,
            "vt": "SELECT tags.tag FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE torrents.releasetype = '[placeholder-type:string]' ORDER BY torrents.totalsnatched LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves tags associated with releases from the 'torrents' table, filtering by a specific release type and ordering the results by the number of times the release has been downloaded. The placeholders allow users to specify the desired release type and limit the number of results returned."
        },
        {
            "sample_id": 2064,
            "vt": "SELECT torrents.artist, torrents.groupname FROM torrents WHERE torrents.groupyear = [placeholder-type:numeric] AND torrents.releasetype LIKE '[placeholder-type:string]' ORDER BY torrents.totalsnatched LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the artist and release title of torrents from the 'torrents' table for a specific release year and type. The placeholders in the WHERE clause represent the year and type of release, while the LIMIT clause restricts the number of results based on a specified numeric value."
        },
        {
            "sample_id": 2068,
            "vt": "SELECT torrents.groupname, torrents.groupyear, tags.tag FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE torrents.releasetype = '[placeholder-type:string]' ORDER BY torrents.totalsnatched LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the release titles, release years, and associated tags of torrents from the 'torrents' table, filtered by a specific release type. The results are ordered by the number of times the release has been downloaded, with a limit on the number of results returned."
        },
        {
            "sample_id": 2057,
            "vt": "SELECT COUNT(tags.tag) FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE torrents.groupname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of tags associated with a specific release title from the 'torrents' table. It uses an inner join with the 'tags' table to match the release identifier, ensuring that only tags related to the specified release title are counted. The placeholder in the WHERE clause represents the release title being queried."
        },
        {
            "sample_id": 2081,
            "vt": "SELECT COUNT(torrents.releasetype) FROM torrents WHERE torrents.releasetype LIKE '[placeholder-type:string]' AND torrents.groupyear = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of releases from the 'torrents' table based on a specific release type and year. The placeholders represent the release type as a string and the release year as a numeric value."
        },
        {
            "sample_id": 2084,
            "vt": "SELECT tags.tag FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE torrents.groupyear BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND torrents.artist LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves tags associated with releases from the 'torrents' table that were released within a specific year range and by a particular artist. The placeholders in the WHERE clause represent the year range and the artist's name."
        },
        {
            "sample_id": 2051,
            "vt": "SELECT tags.tag FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE torrents.releasetype = '[placeholder-type:string]' ORDER BY torrents.totalsnatched LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves tags associated with releases from the 'torrents' table, filtering by a specific release type and ordering the results by the number of times the release has been downloaded. The placeholders represent the release type and the limit on the number of results returned."
        },
        {
            "sample_id": 2050,
            "vt": "SELECT torrents.groupname FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE tags.tag LIKE '[placeholder-type:string]' AND torrents.releasetype = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the release titles from the 'torrents' table that are associated with specific tags and release types. The placeholders in the WHERE clause represent the tag and release type criteria that can be specified by the user."
        },
        {
            "sample_id": 2055,
            "vt": "SELECT torrents.groupname FROM torrents WHERE torrents.totalsnatched > [placeholder-type:numeric]",
            "ba": "The virtual table describes the release titles from the 'torrents' table that have been downloaded more than a specified number of times. The placeholder in the WHERE clause represents the minimum number of downloads required to filter the results."
        },
        {
            "sample_id": 2046,
            "vt": "SELECT torrents.totalsnatched FROM torrents WHERE torrents.artist LIKE '[placeholder-type:string]' AND torrents.groupyear = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the total number of times a specific release by a particular artist has been downloaded from the 'torrents' table. The placeholders allow for filtering by the artist's name and the release year."
        },
        {
            "sample_id": 2077,
            "vt": "SELECT tags.tag FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE torrents.id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves tags associated with a specific release from the 'torrents' table by joining it with the 'tags' table based on their unique identifiers. The placeholder in the WHERE clause represents the unique identifier of the release."
        },
        {
            "sample_id": 2053,
            "vt": "SELECT COUNT(tags.id) FROM tags WHERE tags.tag LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of tags associated with releases in the 'tags' table that match a specific tag pattern. The placeholder in the WHERE clause represents the tag to be searched for."
        },
        {
            "sample_id": 2072,
            "vt": "SELECT torrents.artist FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE tags.tag = '[placeholder-type:string]' AND torrents.groupyear BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the artist names from the 'torrents' table by joining it with the 'tags' table based on their unique identifiers. It filters the results to include only those releases that have a specific tag and were released within a specified range of years."
        },
        {
            "sample_id": 2083,
            "vt": "SELECT COUNT(torrents.id) FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE tags.tag = '[placeholder-type:string]' AND torrents.groupyear = [placeholder-type:numeric] AND torrents.releasetype LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of unique releases from the 'torrents' table that match specific criteria based on tags, release year, and release type. The placeholders represent the tag name, the release year, and the type of release respectively."
        },
        {
            "sample_id": 2088,
            "vt": "SELECT torrents.artist FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE torrents.releasetype = '[placeholder-type:string]' AND tags.tag LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the artists of releases from the 'torrents' table that match a specific release type and a specific tag. The placeholders in the WHERE clause represent the release type and the tag to filter the results accordingly."
        },
        {
            "sample_id": 2060,
            "vt": "SELECT COUNT(torrents.groupname) FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE tags.tag = '[placeholder-type:string]' AND torrents.artist = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of releases from the 'torrents' table that match a specific tag and artist. It joins the 'torrents' table with the 'tags' table on the release identifier to filter the results based on the provided tag and artist name."
        },
        {
            "sample_id": 2063,
            "vt": "SELECT torrents.groupname FROM torrents ORDER BY torrents.totalsnatched LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the release titles from the 'torrents' table, ordered by the number of times each release has been downloaded. The placeholder in the LIMIT clause allows the user to specify how many results they want to retrieve."
        },
        {
            "sample_id": 2079,
            "vt": "SELECT COUNT(torrents.artist) FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE tags.tag = '[placeholder-type:string]' AND torrents.groupyear BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND torrents.releasetype LIKE '[placeholder-type:string]' OR torrents.releasetype LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of artists from the 'torrents' table that match specific criteria based on tags, release year, and release type. The placeholders represent the tag name, a range of years for the release, and types of releases that can be specified."
        },
        {
            "sample_id": 2048,
            "vt": "SELECT tags.tag FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE torrents.releasetype = '[placeholder-type:string]' ORDER BY torrents.totalsnatched LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves tags associated with releases from the 'torrents' table, filtered by a specific release type. The results are ordered by the number of times the release has been downloaded, and the number of results returned is limited by a numeric placeholder."
        },
        {
            "sample_id": 2058,
            "vt": "SELECT torrents.groupname FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE tags.tag = '[placeholder-type:string]'",
            "ba": "The virtual table describes the release titles from the 'torrents' table that are associated with a specific tag. The query uses an INNER JOIN to connect the 'torrents' table with the 'tags' table based on their unique identifiers. The placeholder in the WHERE clause represents the tag that is being filtered."
        },
        {
            "sample_id": 2069,
            "vt": "SELECT torrents.artist FROM torrents WHERE torrents.groupyear = [placeholder-type:numeric] AND torrents.releasetype LIKE '[placeholder-type:string]' GROUP BY torrents.artist HAVING COUNT(torrents.releasetype) > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of artists from the 'torrents' table who have released a specific type of release in a given year. The query groups the results by artist and filters to include only those artists who have more than a specified number of releases of that type. The placeholders represent the year, the type of release, and the minimum count of releases required."
        },
        {
            "sample_id": 2056,
            "vt": "SELECT tags.tag FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE torrents.groupname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves tags associated with a specific release title from the 'torrents' table by joining it with the 'tags' table based on their unique identifiers. The placeholder in the WHERE clause represents the release title for which the tags are being queried."
        },
        {
            "sample_id": 2085,
            "vt": "SELECT torrents.groupname, tags.tag FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE torrents.groupyear = [placeholder-type:numeric] AND torrents.artist LIKE '[placeholder-type:string]' AND torrents.releasetype LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the release titles and associated tags from the 'torrents' and 'tags' tables. It filters the results based on the release year, artist name, and release type, allowing users to find specific releases that match their criteria."
        },
        {
            "sample_id": 2071,
            "vt": "SELECT torrents.groupname FROM torrents WHERE torrents.totalsnatched >= [placeholder-type:numeric] AND torrents.releasetype LIKE '[placeholder-type:string]' AND torrents.id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the release titles from the 'torrents' table based on specific criteria. It filters the results to include only those releases that have been downloaded a certain number of times, match a specific release type, and fall within a specified range of unique identifiers."
        },
        {
            "sample_id": 2059,
            "vt": "SELECT torrents.groupname FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE tags.tag = '[placeholder-type:string]' ORDER BY torrents.totalsnatched LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the release titles from the 'torrents' table that are associated with a specific tag from the 'tags' table. It uses an inner join to connect the two tables based on their unique identifiers, ensuring that only releases with the specified tag are selected. The results are ordered by the number of times each release has been downloaded, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 2086,
            "vt": "SELECT torrents.groupname FROM torrents INNER JOIN tags AS T2 ON T1.id = T2.id WHERE torrents.groupyear = [placeholder-type:numeric] AND tags.tag LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the release titles from the 'torrents' table that match a specific release year and a tag associated with the release. The placeholders in the WHERE clause represent the release year and the tag name."
        }
    ],
    "college_completion": [
        {
            "sample_id": 3718,
            "vt": "SELECT DISTINCT institution_details.chronname FROM institution_details INNER JOIN state_sector_grads AS T2 ON T2.state = T1.state WHERE state_sector_grads.state_abbr = '[placeholder-type:string]' AND institution_details.level = '[placeholder-type:string]' AND institution_details.student_count = (SELECT MAX(institution_details.student_count) FROM institution_details AS T1 INNER JOIN state_sector_grads AS T2 ON T2.state = T1.state WHERE T2.state_abbr = 'NJ' AND T1.level = '4-year')",
            "ba": "The virtual table lists the names of institutions from the 'institution_details' table that are located in a specific state and offer a certain level of education. It filters the results based on the state abbreviation and the level of the institution, while also ensuring that only the institution with the highest student count for 4-year institutions in New Jersey is selected."
        },
        {
            "sample_id": 3757,
            "vt": "SELECT institution_details.chronname, state_sector_details.state_appr_value FROM institution_details INNER JOIN state_sector_details AS T2 ON T2.state = T1.state ORDER BY institution_details.awards_per_value - state_sector_details.awards_per_natl_value LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of institution names along with their corresponding state appropriations for higher education. It combines data from the 'institution_details' table and the 'state_sector_details' table based on the state they are located in. The results are ordered by the difference between the awards per value of the institution and the national average awards per value, allowing users to see which institutions have a higher or lower performance relative to the national average. The query limits the results to a specified number of entries."
        },
        {
            "sample_id": 3683,
            "vt": "SELECT institution_details.chronname, institution_details.site FROM institution_details INNER JOIN state_sector_grads AS T2 ON T1.state = T2.state WHERE state_sector_grads.year = [placeholder-type:numeric] AND state_sector_grads.grad_cohort = [placeholder-type:numeric]",
            "ba": "The virtual table provides the names and website addresses of educational institutions from the 'institution_details' table that are located in a specific state. It filters the results based on the year of data release and the degree-seeking cohort type from the 'state_sector_grads' table."
        },
        {
            "sample_id": 3743,
            "vt": "SELECT CAST(SUM(CASE WHEN state_sector_grads.level = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(state_sector_grads.level) FROM state_sector_details INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid WHERE state_sector_grads.state = '[placeholder-type:string]' AND state_sector_grads.year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average of graduation rates for institutions at a specific level (either 2-year or 4-year) in a given state for a specified year. It sums the graduation rates from the 'state_sector_grads' table, applying a condition to filter by the institution level, and then divides by the count of institutions at that level to get the average. The placeholders represent the institution level, state name, and year for which the data is being queried."
        },
        {
            "sample_id": 3697,
            "vt": "SELECT COUNT(*) FROM institution_details WHERE institution_details.control = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of institutions from the 'institution_details' table that fall under a specific control type, such as Public, Private not-for-profit, or Private for-profit. The placeholder in the WHERE clause represents the control type of the institution."
        },
        {
            "sample_id": 3688,
            "vt": "SELECT institution_details.chronname FROM institution_details INNER JOIN state_sector_grads AS T2 ON T1.state = T2.state WHERE state_sector_grads.year = [placeholder-type:numeric] AND institution_details.control = '[placeholder-type:string]' ORDER BY state_sector_grads.grad_cohort LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of institutions from the 'institution_details' table that are located in a specific state and are of a certain control type (public, private non-profit, or private for-profit). It filters the results based on the year of graduation data from the 'state_sector_grads' table and orders the results by the number of students in the graduation cohort."
        },
        {
            "sample_id": 3684,
            "vt": "SELECT COUNT(state_sector_grads.grad_cohort) FROM institution_details INNER JOIN state_sector_grads AS T2 ON T1.state = T2.state WHERE state_sector_grads.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND institution_details.chronname = '[placeholder-type:string]' AND state_sector_grads.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of degree-seeking students in a specific state for a given institution over a range of years, filtered by gender."
        },
        {
            "sample_id": 3745,
            "vt": "SELECT institution_details.site FROM institution_details INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE institution_grads.race = '[placeholder-type:string]' AND institution_grads.cohort = '[placeholder-type:string]' AND institution_grads.year = [placeholder-type:numeric] ORDER BY institution_grads.grad_cohort LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the website addresses of educational institutions from the 'institution_details' table. It filters the results based on the race and cohort type of students from the 'institution_grads' table, as well as the year of data release. The results are ordered by the graduation cohort and limited to a specified number of entries."
        },
        {
            "sample_id": 3737,
            "vt": "SELECT SUM(state_sector_grads.grad_cohort) FROM state_sector_details INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid WHERE state_sector_grads.state LIKE '[placeholder-type:string]' AND state_sector_details.awards_per_natl_value = [placeholder-type:numeric] AND state_sector_grads.year = [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total number of first-time, full-time, degree-seeking students in a specific state for a given year, filtered by the state's name and the national average completions per 100 FTE undergraduate students."
        },
        {
            "sample_id": 3695,
            "vt": "SELECT CAST(SUM(CASE WHEN institution_grads.gender = '[placeholder-type:string]' THEN institution_grads.grad_cohort ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN institution_grads.gender = '[placeholder-type:string]' THEN institution_grads.grad_cohort ELSE [placeholder-type:numeric] END) FROM institution_details INNER JOIN institution_grads AS T2 ON T1.unitid = T2.unitid WHERE institution_details.chronname = '[placeholder-type:string]' AND institution_grads.year = [placeholder-type:numeric] AND institution_grads.race = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the graduation rate of students based on gender from the 'institution_grads' table, while filtering for a specific institution name, year, and race. It uses a conditional aggregation to sum the number of graduates in the specified gender cohort and divides it by the total number of students in that cohort. The placeholders represent the gender, institution name, year, and race criteria for the query."
        },
        {
            "sample_id": 3727,
            "vt": "SELECT SUM(state_sector_grads.grad_cohort) FROM state_sector_details INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid WHERE state_sector_details.state = '[placeholder-type:string]' AND state_sector_grads.year = [placeholder-type:numeric] AND state_sector_details.level = '[placeholder-type:string]' AND state_sector_details.control = '[placeholder-type:string]' AND state_sector_grads.race = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total number of first-time, full-time, degree-seeking students in a specified state, year, level of institution, control type, and race/ethnicity from the 'state_sector_grads' table. It joins with the 'state_sector_details' table to filter based on the state and other criteria."
        },
        {
            "sample_id": 3729,
            "vt": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.state = (SELECT T1.state FROM institution_details AS T1 INNER JOIN state_sector_details AS T2 ON T2.state = T1.state WHERE T1.chronname = 'Madison Area Technical College') AND T1.level = '4-year' AND T1.control = 'Public' THEN T1.chronname ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(DISTINCT CASE WHEN T2.state = 'Alabama' THEN T1.chronname ELSE NULL END) FROM institution_details INNER JOIN state_sector_details AS T2 ON T2.state = T1.state",
            "ba": "The virtual table calculates the proportion of public 4-year institutions named 'Madison Area Technical College' in a specific state compared to the total number of institutions in Alabama. It uses a nested query to identify the state of 'Madison Area Technical College' and counts distinct institutions based on the specified criteria."
        },
        {
            "sample_id": 3716,
            "vt": "SELECT COUNT(state_sector_details.stateid) FROM state_sector_details WHERE state_sector_details.state = '[placeholder-type:string]' AND state_sector_details.level = '[placeholder-type:string]' AND state_sector_details.control = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of institutions in a specific state that match the given level and control type. The placeholders represent the state name, the level of institution (either 4-year or 2-year), and the control type (Public, Private not-for-profit, or Private for-profit)."
        },
        {
            "sample_id": 3701,
            "vt": "SELECT institution_grads.grad_cohort FROM institution_details INNER JOIN institution_grads AS T2 ON T1.unitid = T2.unitid WHERE institution_details.chronname = '[placeholder-type:string]' AND institution_grads.year = [placeholder-type:numeric]",
            "ba": "The virtual table provides the number of first-time, full-time, degree-seeking students in a specific cohort from the 'institution_grads' table, filtered by the institution's name and the year of data release. The placeholders allow users to specify the institution's name and the year they are interested in."
        },
        {
            "sample_id": 3723,
            "vt": "SELECT institution_details.chronname, institution_details.unitid FROM institution_details INNER JOIN state_sector_grads AS T2 ON T2.state = T1.state WHERE state_sector_grads.state_abbr = '[placeholder-type:string]' AND institution_details.level = '[placeholder-type:string]' AND institution_details.control = '[placeholder-type:string]' GROUP BY institution_details.chronname ORDER BY SUM(institution_details.grad_150_value) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of institution names and their unique Education Unit ID numbers from the 'institution_details' table. It filters the results based on the state abbreviation, level of institution, and control type (public, private non-profit, or private for-profit). The results are grouped by institution name and ordered by the total number of students who graduated within 150 percent of the expected time, with a limit on the number of results returned."
        },
        {
            "sample_id": 3748,
            "vt": "SELECT AVG(institution_grads.grad_cohort) FROM institution_details INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE institution_details.chronname = '[placeholder-type:string]' AND institution_grads.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND institution_grads.race = '[placeholder-type:string]' AND institution_grads.cohort = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of first-time, full-time, degree-seeking students in a specified cohort from the 'institution_grads' table, filtered by the institution's name, graduation year range, race, and cohort type. It joins the 'institution_details' table to access the institution's name using the unique Education Unit ID."
        },
        {
            "sample_id": 3751,
            "vt": "SELECT institution_details.state FROM institution_details INNER JOIN state_sector_details AS T2 ON T2.state = T1.state WHERE institution_details.chronname IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]') GROUP BY institution_details.state ORDER BY SUM(state_sector_details.state_appr_value) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the states of institutions from the 'institution_details' table that match specific institution names. It joins with the 'state_sector_details' table to aggregate state appropriations for higher education. The results are grouped by state and ordered by the total state appropriations, with a limit on the number of states returned."
        },
        {
            "sample_id": 3735,
            "vt": "SELECT COUNT(state_sector_grads.race) FROM state_sector_details INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid WHERE state_sector_details.schools_count = [placeholder-type:numeric] AND state_sector_grads.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND state_sector_grads.race = '[placeholder-type:string]' AND state_sector_details.state = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students of a specific race from the 'state_sector_grads' table, filtered by the number of schools in a state, the year range, and the state name. It joins with the 'state_sector_details' table to access the schools count and state information."
        },
        {
            "sample_id": 3720,
            "vt": "SELECT COUNT(DISTINCT T1.chronname) FROM institution_details INNER JOIN state_sector_grads AS T2 ON T2.state = T1.state WHERE state_sector_grads.state_abbr = '[placeholder-type:string]' AND institution_details.level = '[placeholder-type:string]' AND institution_details.control = '[placeholder-type:string]' AND institution_details.awards_per_value > institution_details.awards_per_state_value",
            "ba": "The virtual table counts the distinct institution names from the 'institution_details' table that meet specific criteria. It filters institutions based on their state abbreviation, level, and control type, while also ensuring that their completion rate exceeds the average for their state and sector."
        },
        {
            "sample_id": 3739,
            "vt": "SELECT DISTINCT state_sector_details.state FROM state_sector_details INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid WHERE state_sector_grads.gender = '[placeholder-type:string]' AND state_sector_grads.race = '[placeholder-type:string]' AND state_sector_details.control = '[placeholder-type:string]' AND state_sector_grads.year = [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of states from the 'state_sector_details' table, filtered by specific criteria related to student demographics and institutional control. The placeholders represent the gender, race, and control type of the institutions, as well as the year of data release."
        },
        {
            "sample_id": 3756,
            "vt": "SELECT AVG(institution_grads.grad_150) FROM institution_details INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE institution_details.chronname = '[placeholder-type:string]' AND institution_grads.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND institution_grads.gender = '[placeholder-type:string]' AND institution_grads.race = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average graduation rate within 150% of the expected time for a specific institution, filtered by the institution's name, the range of years for which data is available, and the demographic characteristics of the students, including gender and race."
        },
        {
            "sample_id": 3702,
            "vt": "SELECT CASE WHEN SUM(CASE WHEN institution_grads.gender = '[placeholder-type:string]' THEN institution_grads.grad_150 ELSE [placeholder-type:numeric] END) > SUM(CASE WHEN institution_grads.gender = '[placeholder-type:string]' THEN institution_grads.grad_150 ELSE [placeholder-type:numeric] END) THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM institution_details INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE institution_details.chronname = '[placeholder-type:string]' AND institution_grads.year = [placeholder-type:numeric] AND institution_grads.race = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the graduation rates of institutions based on gender and race for a specific institution name and year. It uses conditional aggregation to compare the number of students graduating within 150% of the expected time for a specified gender against the total number of graduates for that gender. The placeholders represent the gender, institution name, year, and race criteria for filtering the results."
        },
        {
            "sample_id": 3714,
            "vt": "SELECT subquery_q0.t FROM (SELECT DISTINCT CASE WHEN institution_details.chronname = '[placeholder-type:string]' THEN institution_details.city ELSE NULL END FROM institution_details) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table provides a list of unique cities where institutions are located, filtered by a specific institution name. The placeholder in the SELECT statement represents the institution's name that the user wants to query."
        },
        {
            "sample_id": 3721,
            "vt": "SELECT COUNT(DISTINCT T1.chronname) FROM institution_details INNER JOIN state_sector_grads AS T2 ON T2.state = T1.state WHERE state_sector_grads.state_abbr = '[placeholder-type:string]' AND state_sector_grads.level = '[placeholder-type:string]' AND institution_details.control = '[placeholder-type:string]' AND institution_details.awards_per_value < institution_details.awards_per_natl_value",
            "ba": "The virtual table counts the distinct institution names from the 'institution_details' table that are located in a specific state, have a certain level of education, are of a particular control type, and have an awards per value that is less than the national average awards per value."
        },
        {
            "sample_id": 3691,
            "vt": "SELECT COUNT(*) FROM institution_details INNER JOIN institution_grads AS T2 ON T1.unitid = T2.unitid WHERE institution_grads.gender = '[placeholder-type:string]' AND institution_grads.race = '[placeholder-type:string]' AND institution_details.chronname = '[placeholder-type:string]' AND institution_grads.cohort = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of graduates from a specific institution based on gender, race, and cohort type. It joins the 'institution_details' table with the 'institution_grads' table using the unique Education Unit ID. The placeholders represent the gender, race, institution name, and cohort type for which the count is being queried."
        },
        {
            "sample_id": 3734,
            "vt": "SELECT DISTINCT institution_details.basic, institution_grads.race FROM institution_details INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE institution_grads.year = [placeholder-type:numeric] AND institution_grads.gender = '[placeholder-type:string]' AND t2.race = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of the Carnegie Foundation classifications and the race/ethnicity of students from the 'institution_details' and 'institution_grads' tables. It filters the results based on a specific year, gender, and race of students."
        },
        {
            "sample_id": 3754,
            "vt": "SELECT institution_details.chronname FROM institution_details INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE institution_grads.gender = '[placeholder-type:string]' AND institution_grads.cohort = '[placeholder-type:string]' ORDER BY institution_grads.grad_cohort LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of institutions from the 'institution_details' table that have graduates filtered by gender and cohort type from the 'institution_grads' table. The placeholders in the WHERE clause represent the specific gender and cohort type, while the LIMIT placeholder specifies the maximum number of results to return."
        },
        {
            "sample_id": 3706,
            "vt": "SELECT SUM(CASE WHEN institution_grads.year = [placeholder-type:numeric] THEN institution_grads.grad_cohort ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN institution_grads.year = [placeholder-type:numeric] THEN institution_grads.grad_cohort ELSE [placeholder-type:numeric] END) FROM institution_details INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE institution_details.chronname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference in the number of degree-seeking students who graduated within a specified year from a specific institution. It uses a conditional sum to account for the graduation cohort of that year and compares it to another specified year, allowing users to analyze graduation trends over time for a particular institution."
        },
        {
            "sample_id": 3726,
            "vt": "SELECT COUNT(institution_details.chronname) FROM institution_details INNER JOIN state_sector_details AS T2 ON T2.state = T1.state WHERE state_sector_details.level = '[placeholder-type:string]' AND state_sector_details.control = '[placeholder-type:string]' AND institution_details.chronname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of institutions from the 'institution_details' table that match specific criteria based on their state, level, control type, and institution name. The placeholders represent the level of the institution, the control type (public or private), and the institution's name."
        },
        {
            "sample_id": 3732,
            "vt": "SELECT DISTINCT institution_details.control, institution_details.level FROM institution_details INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE institution_grads.race = '[placeholder-type:string]' AND institution_details.student_count = (SELECT MAX(institution_details.student_count) FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T2.race = 'X')",
            "ba": "The virtual table provides a distinct list of institution control types and levels from the 'institution_details' table, filtered by the race of students in the 'institution_grads' table. It specifically identifies institutions that have the highest number of undergraduate students for a given race category, using a subquery to determine the maximum student count for all students."
        },
        {
            "sample_id": 3749,
            "vt": "SELECT institution_details.chronname FROM institution_details INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE institution_details.chronname IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]') AND institution_grads.race = '[placeholder-type:string]' GROUP BY institution_details.chronname ORDER BY SUM(institution_grads.grad_cohort) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of institutions from the 'institution_details' table that have graduates of a specific race. It filters the institutions based on a list of names and groups the results by institution name, ordering them by the total number of graduates in the specified cohort. The placeholders represent the institution names and race criteria, as well as a limit on the number of results returned."
        },
        {
            "sample_id": 3733,
            "vt": "SELECT DISTINCT state_sector_grads.race FROM state_sector_details INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid WHERE state_sector_details.schools_count <= [placeholder-type:numeric] AND state_sector_details.control = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of races represented in the 'state_sector_grads' table, filtered by the number of schools and the control type of the institution from the 'state_sector_details' table. The placeholders allow users to specify the maximum number of schools and the type of control (Public, Private not-for-profit, or Private for-profit) they are interested in."
        },
        {
            "sample_id": 3747,
            "vt": "SELECT institution_details.chronname FROM institution_details INNER JOIN state_sector_details AS T2 ON T2.state = T1.state INNER JOIN institution_grads AS T3 ON T3.unitid = T1.unitid WHERE institution_details.student_count = (SELECT MIN(institution_details.student_count) FROM institution_details AS T1 INNER JOIN state_sector_details AS T2 ON T2.state = T1.state INNER JOIN institution_grads AS T3 ON T3.unitid = T1.unitid WHERE T3.year = 2010) AND institution_grads.year = [placeholder-type:numeric] GROUP BY institution_details.state ORDER BY SUM(state_sector_details.state_appr_value) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of institutions from the 'institution_details' table that have the minimum student count for the year 2010, while also considering their state and graduation data. It joins the 'institution_details', 'state_sector_details', and 'institution_grads' tables to filter institutions based on their student count and the specified year. The results are grouped by state and ordered by the total state appropriations value, with a limit on the number of results returned."
        },
        {
            "sample_id": 3741,
            "vt": "SELECT COUNT(state_sector_grads.race) FROM state_sector_details INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid WHERE state_sector_grads.gender = '[placeholder-type:string]' AND state_sector_details.schools_count BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND state_sector_grads.year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students from the 'state_sector_grads' table based on their race, filtered by gender, the number of schools in a state, and the year of data release. It joins the 'state_sector_details' table to access the schools count for the specified state."
        },
        {
            "sample_id": 3742,
            "vt": "SELECT DISTINCT institution_grads.race FROM institution_details INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE institution_details.student_count > (SELECT AVG(institution_details.student_count) * [placeholder-type:numeric] FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T1.state = 'Alabama') AND institution_details.state = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct race categories of students from the 'institution_grads' table, joining it with the 'institution_details' table. It filters institutions based on a condition that their student count exceeds a certain multiple of the average student count for institutions in Alabama, while also ensuring that the institutions are located in a specified state."
        },
        {
            "sample_id": 3752,
            "vt": "SELECT COUNT(t1.unitid), t1.chronname FROM institution_details INNER JOIN state_sector_details AS T2 ON t1.state = t2.state WHERE t1.ft_pct > [placeholder-type:numeric] ORDER BY t2.schools_count LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of educational institutions along with their names from the 'institution_details' table, filtered by the percentage of full-time undergraduates. It joins with the 'state_sector_details' table to include only those institutions located in states that meet the specified criteria. The results are ordered by the number of schools in each state and limited to a specified number of entries."
        },
        {
            "sample_id": 3736,
            "vt": "SELECT DISTINCT institution_details.chronname FROM institution_details INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE institution_grads.grad_cohort BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND institution_grads.race = '[placeholder-type:string]'",
            "ba": "The virtual table lists the unique names of institutions from the 'institution_details' table that have graduation cohorts within a specified range and for a specific race/ethnicity. The placeholders represent the numeric range for the graduation cohort and the string value for the race/ethnicity."
        },
        {
            "sample_id": 3728,
            "vt": "SELECT COUNT(state_sector_grads.grad_cohort) FROM state_sector_details INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid WHERE state_sector_grads.level = '[placeholder-type:string]' AND state_sector_grads.control = '[placeholder-type:string]' AND state_sector_grads.gender = '[placeholder-type:string]' AND state_sector_grads.race = '[placeholder-type:string]' AND state_sector_grads.cohort = '[placeholder-type:string]' AND state_sector_details.schools_count = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of degree-seeking students in a specific cohort from the 'state_sector_grads' table, filtered by institution level, control type, gender, race, and cohort type. It also ensures that the count is only for states with a specified number of schools from the 'state_sector_details' table."
        },
        {
            "sample_id": 3694,
            "vt": "SELECT CAST(SUM(CASE WHEN institution_grads.race = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(institution_grads.grad_cohort) FROM institution_details INNER JOIN institution_grads AS T2 ON T1.unitid = T2.unitid WHERE institution_grads.year = [placeholder-type:numeric] AND institution_details.state = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the graduation rate for a specific race of students from institutions in a specified state for a given year. It sums the number of graduates of that race and divides it by the total number of degree-seeking students in the cohort, providing a percentage that reflects the graduation success of that demographic within the state."
        },
        {
            "sample_id": 3696,
            "vt": "SELECT institution_details.chronname FROM institution_details WHERE institution_details.chronname IN ('[placeholder-type:string]', '[placeholder-type:string]') ORDER BY institution_details.grad_100_value LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of institutions from the 'institution_details' table that match specific names provided in the placeholders. The results are ordered by the graduation rate within 100 percent of the expected time, and the number of results returned is limited by a numeric placeholder."
        },
        {
            "sample_id": 3746,
            "vt": "SELECT institution_grads.year FROM institution_details INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE institution_details.chronname = '[placeholder-type:string]' GROUP BY institution_grads.year ORDER BY SUM(institution_grads.grad_cohort) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the years of graduation data for a specific institution identified by its name. It joins the 'institution_details' table with the 'institution_grads' table to access graduation information, grouping the results by year and ordering them based on the total number of students in the graduation cohort. The placeholders allow users to specify the institution's name and limit the number of years returned."
        },
        {
            "sample_id": 3717,
            "vt": "SELECT subquery_q0.t FROM (SELECT DISTINCT CASE WHEN state_sector_details.state = '[placeholder-type:string]' THEN state_sector_details.state_post ELSE NULL END FROM state_sector_details) WHERE NOT subquery_q0.t IS NULL",
            "ba": "The virtual table retrieves distinct state postal codes from the 'state_sector_details' table based on a specified state. The placeholder in the WHERE clause represents the state name for which the postal codes are being queried."
        },
        {
            "sample_id": 3755,
            "vt": "SELECT institution_details.chronname FROM institution_details INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE institution_details.chronname IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]') AND institution_grads.year = [placeholder-type:numeric] AND institution_grads.race = '[placeholder-type:string]' AND institution_grads.cohort = '[placeholder-type:string]' ORDER BY institution_grads.grad_cohort LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of institutions from the 'institution_details' table that match specific criteria. It filters institutions based on their names, the year of graduation data, the race of students, and the type of degree-seeking cohort. The results are ordered by the number of students in the graduation cohort and limited to a specified number of entries."
        },
        {
            "sample_id": 3750,
            "vt": "SELECT institution_details.chronname FROM institution_details INNER JOIN state_sector_details AS T2 WHERE state_sector_details.level = '[placeholder-type:string]' AND state_sector_details.control = '[placeholder-type:string]' AND state_sector_details.state = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of institutions from the 'institution_details' table that match specific criteria related to their level, control type, and state. The placeholders in the WHERE clause represent the level of institution, control type, and state name."
        },
        {
            "sample_id": 3708,
            "vt": "SELECT COUNT(institution_details.chronname) FROM institution_details INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE institution_details.state = '[placeholder-type:string]' AND institution_details.control = '[placeholder-type:string]' AND institution_grads.year = [placeholder-type:numeric] AND institution_grads.grad_100 > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of institutions from the 'institution_details' table that meet specific criteria based on their state, control type, graduation year, and graduation rate. The placeholders allow users to specify the state name, control type (such as public or private), the year of graduation data, and a minimum graduation rate for filtering the results."
        }
    ],
    "human_resources": [
        {
            "sample_id": 8940,
            "vt": "SELECT employee.ssn FROM employee INNER JOIN location AS T2 ON T1.locationID = T2.locationID WHERE location.state = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the social security numbers of employees from the 'employee' table who work in a specific state. It joins the 'employee' table with the 'location' table based on the location ID to filter employees by their work location's state."
        },
        {
            "sample_id": 8947,
            "vt": "SELECT position.educationrequired FROM employee INNER JOIN position AS T2 ON T1.positionID = T2.positionID WHERE employee.firstname = '[placeholder-type:string]' AND employee.lastname = '[placeholder-type:string]' AND employee.gender = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the education requirements for a specific employee based on their first name, last name, and gender. It joins the 'employee' table with the 'position' table to access the education requirement associated with the employee's position."
        },
        {
            "sample_id": 8937,
            "vt": "SELECT employee.firstname, employee.lastname FROM employee INNER JOIN position AS T2 ON T1.positionID = T2.positionID WHERE position.positiontitle = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of employees from the 'employee' table who hold a specific position title. The query joins the 'employee' table with the 'position' table based on the position ID, filtering results to only include those employees whose position title matches the specified placeholder."
        },
        {
            "sample_id": 8974,
            "vt": "SELECT employee.firstname, employee.lastname, employee.ssn FROM employee INNER JOIN position AS T2 ON T1.positionID = T2.positionID WHERE employee.performance = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first name, last name, and social security number of employees from the 'employee' table who have a specific performance rating. The query joins the 'employee' table with the 'position' table to access position-related information, but only the employee details are selected. The placeholder in the WHERE clause represents the performance rating of the employees."
        },
        {
            "sample_id": 8960,
            "vt": "SELECT position.minsalary FROM position ORDER BY position.educationrequired LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the minimum salary for various positions from the 'position' table, ordered by the level of education required for each position. The placeholder in the LIMIT clause allows the user to specify how many records they want to return."
        },
        {
            "sample_id": 8926,
            "vt": "SELECT COUNT(*) FROM employee WHERE employee.performance = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees from the 'employee' table who have a specific performance rating. The placeholder in the WHERE clause represents the performance rating, which can be Good, Average, or Poor."
        },
        {
            "sample_id": 8975,
            "vt": "SELECT employee.hiredate, position.positiontitle, employee.salary FROM employee INNER JOIN position AS T2 ON T1.positionID = T2.positionID WHERE employee.firstname = '[placeholder-type:string]' AND employee.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the hire date, position title, and salary of an employee from the 'employee' table, joined with the 'position' table to get the position title. The placeholders in the WHERE clause represent the first and last names of the employee being queried."
        },
        {
            "sample_id": 8936,
            "vt": "SELECT COUNT(*) FROM employee INNER JOIN location AS T2 ON T1.locationID = T2.locationID INNER JOIN position AS T3 ON T3.positionID = T1.positionID WHERE position.positiontitle = '[placeholder-type:string]' AND location.state = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees based on their position title and location state. It joins the 'employee' table with the 'location' and 'position' tables to filter the results accordingly."
        },
        {
            "sample_id": 8945,
            "vt": "SELECT location.locationcity FROM employee INNER JOIN location AS T2 ON T1.locationID = T2.locationID WHERE employee.firstname = '[placeholder-type:string]' AND employee.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the cities of locations where employees work, based on their first and last names. The query joins the 'employee' table with the 'location' table to retrieve the city information. The placeholders in the WHERE clause represent the employee's first and last names."
        },
        {
            "sample_id": 8968,
            "vt": "SELECT location.state FROM employee INNER JOIN location AS T2 ON T1.locationID = T2.locationID INNER JOIN position AS T3 ON T3.positionID = T1.positionID WHERE position.positiontitle = '[placeholder-type:string]' AND employee.performance = '[placeholder-type:string]' GROUP BY location.state ORDER BY COUNT(location.state) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the states from the 'location' table where employees have a specific position title and performance rating. It joins the 'employee' table with the 'location' and 'position' tables to filter the results based on the specified criteria. The results are grouped by state and ordered by the count of employees in each state, with a limit on the number of states returned."
        },
        {
            "sample_id": 8946,
            "vt": "SELECT location.state FROM employee INNER JOIN location AS T2 ON T1.locationID = T2.locationID WHERE employee.firstname = '[placeholder-type:string]' AND employee.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the state of the location associated with an employee based on their first and last name. It joins the 'employee' table with the 'location' table using the location ID to access the relevant state information."
        },
        {
            "sample_id": 8952,
            "vt": "SELECT position.positiontitle FROM employee INNER JOIN position AS T2 ON T1.positionID = T2.positionID WHERE employee.firstname = '[placeholder-type:string]' AND employee.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the position title of an employee based on their first and last name from the 'employee' and 'position' tables. It uses an INNER JOIN to connect the two tables through the position ID, ensuring that only the relevant position title for the specified employee is returned."
        },
        {
            "sample_id": 8928,
            "vt": "SELECT position.educationrequired FROM position WHERE position.positiontitle = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the education requirements for a specific position title from the 'position' table. The placeholder in the WHERE clause represents the title of the position being queried."
        },
        {
            "sample_id": 8966,
            "vt": "SELECT COUNT(*) FROM employee INNER JOIN location AS T2 ON T1.locationID = T2.locationID INNER JOIN position AS T3 ON T3.positionID = T1.positionID WHERE position.positiontitle = '[placeholder-type:string]' AND employee.performance = '[placeholder-type:string]' AND location.state = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees based on their performance and position title in a specific state. It joins the 'employee', 'location', and 'position' tables to filter the results according to the specified criteria."
        },
        {
            "sample_id": 8976,
            "vt": "SELECT position.maxsalary, position.minsalary, position.positiontitle FROM employee INNER JOIN position AS T2 ON T1.positionID = T2.positionID WHERE employee.firstname = '[placeholder-type:string]' AND employee.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the maximum and minimum salary along with the position title for a specific employee identified by their first and last name. It combines data from the 'employee' and 'position' tables using an inner join based on the position ID."
        },
        {
            "sample_id": 8970,
            "vt": "SELECT location.locationcity FROM location WHERE location.state IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table retrieves the cities of locations from the 'location' table that are situated in specific states. The placeholders in the WHERE clause represent the state abbreviations that the user can specify."
        },
        {
            "sample_id": 8978,
            "vt": "SELECT employee.firstname, employee.lastname, employee.hiredate, employee.performance FROM employee INNER JOIN location AS T2 ON T1.locationID = T2.locationID WHERE location.state = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first name, last name, hire date, and performance of employees from the 'employee' table who work in a specific state. The query joins the 'employee' table with the 'location' table to filter employees based on their location's state, using a placeholder for the state abbreviation."
        },
        {
            "sample_id": 8935,
            "vt": "SELECT CAST(REPLACE(SUBSTRING(employee.salary, [placeholder-type:numeric]), ',', '') AS FLOAT) - CAST(REPLACE(SUBSTRING(position.minsalary, [placeholder-type:numeric]), ',', '') AS FLOAT) FROM employee INNER JOIN position AS T2 ON T1.positionID = T2.positionID WHERE employee.lastname = '[placeholder-type:string]' AND employee.firstname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between an employee's salary and the minimum salary for their position. It retrieves the employee's salary from the 'employee' table and the minimum salary from the 'position' table, ensuring that both values are treated as numeric by removing any commas. The query filters results based on the employee's first and last names, which are provided as placeholders."
        },
        {
            "sample_id": 8972,
            "vt": "SELECT position.positiontitle FROM position WHERE position.educationrequired = '[placeholder-type:string]'",
            "ba": "The virtual table describes the position titles from the 'position' table that require a specific level of education. The placeholder in the WHERE clause represents the education requirement."
        },
        {
            "sample_id": 8943,
            "vt": "SELECT [placeholder-type:numeric] * (AVG(CAST(REPLACE(SUBSTRING(employee.salary, [placeholder-type:numeric]), ',', '') AS FLOAT)) - CAST(REPLACE(SUBSTRING(position.minsalary, [placeholder-type:numeric]), ',', '') AS FLOAT)) / CAST(REPLACE(SUBSTRING(position.minsalary, [placeholder-type:numeric]), ',', '') AS FLOAT) FROM employee INNER JOIN position AS T2 ON T1.positionID = T2.positionID WHERE position.positiontitle = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage difference between the average salary of employees in a specific position and the minimum salary for that position. It retrieves data from the 'employee' and 'position' tables, joining them on the position ID. The placeholders represent the specific position title and numeric values for calculations."
        },
        {
            "sample_id": 8934,
            "vt": "SELECT COUNT(*) FROM employee INNER JOIN position AS T2 ON T1.positionID = T2.positionID WHERE position.positiontitle = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees from the 'employee' table who hold a specific position title. It joins the 'employee' table with the 'position' table based on the position ID, filtering the results to include only those employees whose position title matches the specified placeholder."
        },
        {
            "sample_id": 8954,
            "vt": "SELECT position.maxsalary FROM employee INNER JOIN position AS T2 ON T1.positionID = T2.positionID WHERE employee.firstname = '[placeholder-type:string]' AND employee.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum salary for a specific employee based on their first and last name by joining the 'employee' and 'position' tables."
        },
        {
            "sample_id": 8932,
            "vt": "SELECT location.officephone FROM employee INNER JOIN location AS T2 ON T1.locationID = T2.locationID WHERE employee.lastname = '[placeholder-type:string]' AND employee.firstname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the office phone number of a specific employee based on their first and last name. It joins the 'employee' table with the 'location' table using the location ID to access the office phone number associated with that employee's location."
        },
        {
            "sample_id": 8981,
            "vt": "SELECT employee.firstname, employee.lastname, location.state, location.locationcity FROM employee INNER JOIN location AS T2 ON T1.locationID = T2.locationID WHERE employee.ssn = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of employees along with their state and city of location from the 'employee' and 'location' tables. The placeholder in the WHERE clause represents the employee's social security number (SSN)."
        },
        {
            "sample_id": 8933,
            "vt": "SELECT COUNT(*) FROM employee INNER JOIN location AS T2 ON T1.locationID = T2.locationID WHERE location.address = '[placeholder-type:string]' AND employee.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees from the 'employee' table who are located at a specific address and match a specified gender. It joins the 'employee' table with the 'location' table based on the location ID to filter the results accordingly."
        },
        {
            "sample_id": 8929,
            "vt": "SELECT position.positiontitle FROM position WHERE position.positiontitle = '[placeholder-type:string]' OR position.positiontitle = '[placeholder-type:string]' ORDER BY position.minsalary LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of positions from the 'position' table that match either of the specified titles. The results are ordered by the minimum salary for each position, and the number of results returned is limited by a numeric placeholder."
        },
        {
            "sample_id": 8982,
            "vt": "SELECT employee.firstname, employee.lastname, position.positiontitle, location.locationcity, location.officephone FROM employee INNER JOIN location AS T2 ON T1.locationID = T2.locationID INNER JOIN position AS T3 ON T3.positionID = T1.positionID WHERE location.state = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of employees, their position titles, the city of their location, and the office phone number from the 'employee', 'position', and 'location' tables. The query filters results based on a specific state using a placeholder for the state abbreviation."
        },
        {
            "sample_id": 8959,
            "vt": "SELECT employee.salary FROM employee ORDER BY employee.hiredate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the salaries of employees from the 'employee' table, ordered by their hire date. The placeholder in the LIMIT clause allows for specifying the number of records to return."
        },
        {
            "sample_id": 8942,
            "vt": "SELECT AVG(CAST(REPLACE(SUBSTRING(employee.salary, [placeholder-type:numeric]), ',', '') AS FLOAT)) FROM employee INNER JOIN position AS T2 ON T1.positionID = T2.positionID WHERE position.positiontitle = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average salary of employees from the 'employee' table who hold a specific position title. It joins the 'employee' table with the 'position' table based on the position ID to filter employees by their job title. The salary is processed to remove any commas and convert it to a numeric format for accurate averaging. The placeholder in the WHERE clause represents the position title being queried."
        },
        {
            "sample_id": 8980,
            "vt": "SELECT position.educationrequired, employee.firstname, employee.lastname, employee.salary FROM employee INNER JOIN position AS T2 ON T1.positionID = T2.positionID WHERE employee.performance = '[placeholder-type:string]' AND position.positiontitle = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about employees' education requirements, names, and salaries based on their performance and position title. It combines data from the 'employee' and 'position' tables using an inner join on the position ID, ensuring that only employees with a specific performance rating and position title are included."
        },
        {
            "sample_id": 8983,
            "vt": "SELECT SUM(CAST(REPLACE(SUBSTRING(employee.salary, [placeholder-type:numeric]), ',', '') AS FLOAT)) / [placeholder-type:numeric], employee.firstname, employee.lastname, position.positiontitle, location.locationcity FROM employee INNER JOIN position AS T2 ON T1.positionID = T2.positionID INNER JOIN location AS T3 ON T1.locationID = T3.locationID WHERE CAST(REPLACE(SUBSTRING(employee.salary, [placeholder-type:numeric]), ',', '') AS FLOAT) = (SELECT MAX(CAST(REPLACE(SUBSTRING(employee.salary, [placeholder-type:numeric]), ',', '') AS FLOAT)) FROM employee AS T1 INNER JOIN position AS T2 ON T1.positionID = T2.positionID INNER JOIN location AS T3 ON T1.locationID = T3.locationID)",
            "ba": "The virtual table calculates the average salary of employees who have the highest salary, displaying their first name, last name, position title, and location city. It joins the 'employee', 'position', and 'location' tables to gather all necessary information, while using placeholders for numeric values to allow for dynamic input."
        },
        {
            "sample_id": 8949,
            "vt": "SELECT employee.firstname, employee.lastname FROM employee INNER JOIN location AS T2 ON T1.locationID = T2.locationID WHERE location.locationcity = '[placeholder-type:string]' ORDER BY employee.salary LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of employees from the 'employee' table who work in a specific city. It joins the 'employee' table with the 'location' table to filter employees based on the city they are located in. The placeholders represent the city name and the limit on the number of results returned."
        },
        {
            "sample_id": 8951,
            "vt": "SELECT COUNT(*) FROM employee INNER JOIN location AS T2 ON T1.locationID = T2.locationID INNER JOIN position AS T3 ON T3.positionID = T1.positionID WHERE position.positiontitle = '[placeholder-type:string]' AND location.locationcity = '[placeholder-type:string]' AND employee.performance = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees based on their performance, position title, and location city. It joins the 'employee' table with the 'location' and 'position' tables to filter the results according to the specified criteria."
        },
        {
            "sample_id": 8964,
            "vt": "SELECT position.positiontitle FROM employee INNER JOIN position AS T2 ON T1.positionID = T2.positionID WHERE employee.performance = '[placeholder-type:string]' GROUP BY position.positiontitle ORDER BY COUNT(position.positiontitle) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of positions held by employees filtered by their performance ratings. It retrieves the position titles from the 'position' table, joining it with the 'employee' table based on the position ID. The results are grouped by position title and ordered by the count of employees in each position, allowing for a limit on the number of results returned."
        },
        {
            "sample_id": 8967,
            "vt": "SELECT AVG(CAST(REPLACE(SUBSTRING(employee.salary, [placeholder-type:numeric]), ',', '') AS FLOAT)) FROM employee INNER JOIN position AS T2 ON T1.positionID = T2.positionID WHERE employee.performance = '[placeholder-type:string]' AND position.positiontitle = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average salary of employees based on their performance rating and position title. It joins the 'employee' table with the 'position' table to filter results according to the specified performance and position title. The salary is processed to remove any commas and convert it to a numeric format for accurate averaging."
        }
    ],
    "menu": [
        {
            "sample_id": 5571,
            "vt": "SELECT menupage.page_number FROM menupage INNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id INNER JOIN Dish AS T3 ON T2.dish_id = T3.id WHERE dish.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the page numbers of menu pages that contain a specific dish by joining the 'menupage', 'menuitem', and 'dish' tables. The placeholder in the WHERE clause represents the name of the dish being queried."
        },
        {
            "sample_id": 5558,
            "vt": "SELECT menu.id FROM menu WHERE menu.sponsor IS NULL",
            "ba": "The virtual table lists the unique identifiers of menus from the 'menu' table that do not have a sponsor associated with them. This indicates that these menus are DIY by the restaurant, as the sponsor field is null."
        },
        {
            "sample_id": 5547,
            "vt": "SELECT dish.name FROM dish INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE SUBSTRING(menuitem.created_at, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND SUBSTRING(menuitem.created_at, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND dish.highest_price IS NULL",
            "ba": "The virtual table lists the names of dishes from the 'dish' table that have not been assigned a highest price. It filters the results based on specific conditions related to the creation date of the menu items, using placeholders for numeric values to specify the date range and a string placeholder for the exact date."
        },
        {
            "sample_id": 5516,
            "vt": "SELECT menuitem.price FROM menu INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id INNER JOIN MenuItem AS T3 ON T2.id = T3.menu_page_id WHERE menupage.image_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the prices of menu items from the 'menuitem' table, which are associated with specific menu pages that belong to a particular menu. The query joins the 'menu', 'menupage', and 'menuitem' tables to filter the results based on the image ID of the menu page."
        },
        {
            "sample_id": 5519,
            "vt": "SELECT dish.name FROM menuitem INNER JOIN Dish AS T2 ON T2.id = T1.dish_id WHERE menuitem.menu_page_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of dishes from the 'dish' table that are included in a specific menu item. The query uses an INNER JOIN to connect the 'menuitem' table with the 'dish' table based on the dish's unique identifier. The placeholder in the WHERE clause represents the specific menu page ID for which the dish names are being queried."
        },
        {
            "sample_id": 5490,
            "vt": "SELECT COUNT(*) FROM menu WHERE menu.location = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of menus from the 'menu' table that are located at a specific location. The placeholder in the WHERE clause represents the location of interest."
        },
        {
            "sample_id": 5513,
            "vt": "SELECT CASE WHEN menupage.uuid = '[placeholder-type:string]' THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM menu INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id WHERE menu.name = '[placeholder-type:string]' AND menupage.uuid = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves a specific value based on the condition of the UUID from the 'menupage' table. It checks if the UUID matches a given placeholder and returns one of two string values accordingly. The query joins the 'menu' table with the 'menupage' table to filter results based on the menu name and the UUID."
        },
        {
            "sample_id": 5550,
            "vt": "SELECT COUNT(*) FROM menu INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id WHERE menu.sponsor = '[placeholder-type:string]' GROUP BY menupage.menu_id HAVING COUNT(menupage.page_number) <= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of menu pages associated with menus that have a specific sponsor. It filters the results based on the sponsor's name and groups the results by menu ID, ensuring that only those menus with a number of pages less than or equal to a specified limit are included."
        },
        {
            "sample_id": 5570,
            "vt": "SELECT dish.name FROM menupage INNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id INNER JOIN Dish AS T3 ON T2.dish_id = T3.id WHERE menupage.menu_id = [placeholder-type:numeric] AND menupage.page_number = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of dishes from the 'dish' table that are included in a specific menu page. The query joins the 'menupage' and 'menuitem' tables to filter the results based on a specific menu ID and page number, using placeholders for these numeric values."
        },
        {
            "sample_id": 5556,
            "vt": "SELECT menu.sponsor FROM menupage INNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id INNER JOIN Dish AS T3 ON T2.dish_id = T3.id INNER JOIN Menu AS T4 ON T4.id = T1.menu_id WHERE dish.name = '[placeholder-type:string]' AND dish.id = [placeholder-type:numeric] ORDER BY menuitem.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the sponsor information from the 'menu' table based on specific dish criteria. It joins multiple tables: 'menupage', 'menuitem', and 'dish' to filter results by the dish's name and id. The results are ordered by the price of the menu items, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 5524,
            "vt": "SELECT dish.name FROM dish ORDER BY dish.highest_price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of dishes from the 'dish' table, ordered by their highest price. The placeholder allows the user to specify a limit on the number of dish names returned."
        },
        {
            "sample_id": 5494,
            "vt": "SELECT dish.name FROM menuitem INNER JOIN Dish AS T2 ON T2.id = T1.dish_id WHERE menuitem.menu_page_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of dishes from the 'dish' table that are included in a specific menu item. The query uses an inner join to connect the 'menuitem' and 'dish' tables based on the dish's unique identifier. The placeholder in the WHERE clause represents the specific menu page ID for which the dish names are being queried."
        },
        {
            "sample_id": 5503,
            "vt": "SELECT CAST(SUM(CASE WHEN menuitem.xpos BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND menuitem.ypos BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(menuitem.id) FROM dish INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE dish.name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of a specific numeric value from the 'menuitem' table based on the x and y positions of the items on the menu pages. It filters the results to include only those dishes that match a specified name, and it uses placeholders for the positional ranges and the numeric value to be averaged."
        },
        {
            "sample_id": 5476,
            "vt": "SELECT SUM(CASE WHEN dish.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM dish INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE dish.highest_price IS NULL",
            "ba": "The virtual table calculates the total number of occurrences of a specific dish from the 'dish' table, where the dish's name matches a given placeholder. It joins the 'dish' table with the 'MenuItem' table to access the relevant dish information. The query also filters for dishes that do not have a specified highest price, indicating they may be more affordable or have a different pricing structure."
        },
        {
            "sample_id": 5553,
            "vt": "SELECT menuitem.xpos, menuitem.ypos FROM dish INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE dish.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the x and y positions of a dish on a menu page from the 'menuitem' table, which is linked to the 'dish' table. The placeholder in the WHERE clause represents the name of the dish being queried."
        },
        {
            "sample_id": 5518,
            "vt": "SELECT dish.name FROM menuitem INNER JOIN Dish AS T2 ON T2.id = T1.dish_id WHERE SUBSTRING(menuitem.created_at, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of dishes from the 'dish' table that are associated with menu items created during a specific year. The query joins the 'menuitem' table with the 'dish' table based on the dish ID, and filters the results based on the creation date of the menu items, using placeholders for the year and substring parameters."
        },
        {
            "sample_id": 5562,
            "vt": "SELECT COUNT(*) FROM menu WHERE menu.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of menus from the 'menu' table that match a specific name. The placeholder in the WHERE clause represents the name of the menu being queried."
        },
        {
            "sample_id": 5495,
            "vt": "SELECT dish.name, menuitem.dish_id FROM menuitem INNER JOIN Dish AS T2 ON T2.id = T1.dish_id WHERE dish.first_appeared = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names and IDs of dishes from the 'dish' table that first appeared in a specific year. The placeholder in the WHERE clause represents the year when the dish was first introduced."
        },
        {
            "sample_id": 5506,
            "vt": "SELECT menu.location FROM menu WHERE menu.id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the location of a specific menu from the 'menu' table based on its unique identifier. The placeholder in the WHERE clause represents the menu's ID."
        },
        {
            "sample_id": 5521,
            "vt": "SELECT dish.name FROM dish INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE menuitem.xpos < [placeholder-type:numeric] AND menuitem.ypos < [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of dishes from the 'dish' table that are positioned within specific coordinates on a menu page. The placeholders represent the maximum x and y positions for filtering the dishes."
        },
        {
            "sample_id": 5496,
            "vt": "SELECT dish.name, menuitem.price FROM dish INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE menuitem.created_at LIKE '[placeholder-type:string]' ORDER BY menuitem.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of dishes along with their prices from the 'dish' table and 'menuitem' table. It filters the results based on the creation date of the menu items using a placeholder for string values, and it orders the results by price while limiting the number of results returned using a placeholder for numeric values."
        },
        {
            "sample_id": 5576,
            "vt": "SELECT menupage.full_height * menupage.full_width FROM menu INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id WHERE menu.name = '[placeholder-type:string]' AND menupage.page_number = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the area of menu pages (full height multiplied by full width) from the 'menupage' table, which is linked to the 'menu' table. It filters the results based on a specific menu name and a specific page number."
        },
        {
            "sample_id": 5530,
            "vt": "SELECT dish.name FROM dish INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE dish.last_appeared - dish.first_appeared > [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of dishes from the 'dish' table that have a significant historical duration, indicated by the difference between the last and first appearance years being greater than a specified numeric value. The query joins the 'dish' table with the 'MenuItem' table to ensure that only dishes that are part of menu items are considered."
        },
        {
            "sample_id": 5471,
            "vt": "SELECT CASE WHEN SUM(CASE WHEN dish.name = '[placeholder-type:string]' THEN dish.last_appeared - dish.first_appeared ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN dish.name = '[placeholder-type:string]' THEN dish.last_appeared - dish.first_appeared ELSE [placeholder-type:numeric] END) > [placeholder-type:numeric] THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM dish WHERE dish.name IN ('[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table calculates the difference between the last and first appearance years of specific dishes, checking if the history of these dishes is long or classical. It uses placeholders for dish names and numeric values to determine if the difference exceeds a certain threshold, returning a specific string based on the result."
        },
        {
            "sample_id": 5505,
            "vt": "SELECT menu.event FROM menu WHERE menu.sponsor = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the events associated with menus that have a specific sponsor from the 'menu' table. The placeholder in the WHERE clause represents the sponsor's identifier."
        },
        {
            "sample_id": 5515,
            "vt": "SELECT menu.page_count FROM menu INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id WHERE menupage.id = [placeholder-type:numeric]",
            "ba": "The virtual table provides the total number of pages in a specific menu by joining the 'menu' and 'menupage' tables. The placeholder in the WHERE clause represents the unique identifier of the menu page being queried."
        },
        {
            "sample_id": 5554,
            "vt": "SELECT dish.name FROM menuitem INNER JOIN Dish AS T2 ON T2.id = T1.dish_id WHERE menuitem.xpos > [placeholder-type:numeric] AND menuitem.ypos > [placeholder-type:numeric] AND menuitem.menu_page_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of dishes from the 'dish' table that are located at specific positions on a menu page. The query filters the results based on the x and y positions of the dishes, as well as the specific menu page they belong to."
        },
        {
            "sample_id": 5522,
            "vt": "SELECT SUM(CASE WHEN menupage.uuid = '[placeholder-type:string]' THEN menu.dish_count ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN menupage.uuid = '[placeholder-type:string]' THEN menu.dish_count ELSE [placeholder-type:numeric] END) FROM menu INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id",
            "ba": "The virtual table calculates the difference in the total number of dishes from a specific menu identified by its UUID. It sums the dish counts from the 'menu' table for the specified UUID and subtracts the same sum, effectively resulting in zero unless modified. The placeholders represent the UUID of the menu and numeric values for calculations."
        },
        {
            "sample_id": 5537,
            "vt": "SELECT menu.event FROM menu INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id WHERE menupage.full_width = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the event associated with a menu from the 'menu' table, specifically for menus that have a certain full width. The query uses an INNER JOIN to connect the 'menu' table with the 'menupage' table based on their IDs, ensuring that only relevant records are considered based on the specified full width of the menu page."
        },
        {
            "sample_id": 5498,
            "vt": "SELECT menupage.page_number, menu.name FROM menupage INNER JOIN Menu AS T2 ON T2.id = T1.menu_id ORDER BY menu.page_count LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the page numbers of menu pages along with the names of the menus they belong to. The query retrieves this information by joining the 'menupage' table with the 'menu' table based on their respective IDs. The results are ordered by the number of pages in each menu and limited to a specified number of entries."
        },
        {
            "sample_id": 5523,
            "vt": "SELECT SUM(menuitem.price) FROM menupage INNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id WHERE menupage.menu_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total price of all menu items from a specific menu by summing the prices of the items listed on the corresponding menu pages."
        },
        {
            "sample_id": 5479,
            "vt": "SELECT SUM(CASE WHEN menu.currency = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM menuitem INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id INNER JOIN Dish AS T4 ON T1.dish_id = T4.id WHERE dish.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total price of menu items from the 'menuitem' table, based on a specific currency. It joins the 'menuitem' table with the 'menupage', 'menu', and 'dish' tables to filter the results by the name of the dish. The placeholder in the WHERE clause represents the dish's name, while the placeholders in the SUM function represent the currency and price values."
        },
        {
            "sample_id": 5507,
            "vt": "SELECT menu.physical_description FROM menu WHERE menu.sponsor = '[placeholder-type:string]'",
            "ba": "The virtual table describes the physical description of menus from the 'menu' table that are sponsored by a specific sponsor. The placeholder in the WHERE clause represents the sponsor's identifier."
        },
        {
            "sample_id": 5536,
            "vt": "SELECT menupage.image_id, menupage.full_height, menupage.full_width FROM menupage INNER JOIN Menu AS T2 ON T2.id = T1.menu_id WHERE menu.event = '[placeholder-type:string]'",
            "ba": "The virtual table displays the image ID, full height, and full width of menu pages from the 'menupage' table that are associated with a specific event in the 'menu' table. The placeholder in the WHERE clause represents the event for which the menu was created."
        },
        {
            "sample_id": 5545,
            "vt": "SELECT SUM(CASE WHEN menu.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM menu INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id",
            "ba": "The virtual table calculates the total sum of a specific numeric value based on a condition related to the menu name from the 'menu' table. It joins the 'menu' table with the 'menupage' table to access the relevant data, allowing for aggregation based on the specified menu name. The placeholders represent the menu name and the numeric values to be summed, enabling users to customize the query for their specific needs."
        },
        {
            "sample_id": 5502,
            "vt": "SELECT menu.name, menu.event FROM menuitem INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id INNER JOIN Dish AS T4 ON T1.dish_id = T4.id WHERE dish.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and events of menus that include a specific dish from the 'dish' table. The placeholders in the WHERE clause represent the name of the dish being queried."
        },
        {
            "sample_id": 5483,
            "vt": "SELECT SUM(CASE WHEN menu.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM menuitem INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id",
            "ba": "The virtual table calculates the total sum of a specific numeric value from the 'menuitem' table based on a condition related to the 'menu' table. It uses a CASE statement to check if the name of the menu matches a specified placeholder value, and sums the corresponding numeric values accordingly. The query involves joining the 'menuitem' table with the 'menupage' and 'menu' tables to access the necessary data for this calculation."
        },
        {
            "sample_id": 5541,
            "vt": "SELECT COUNT(*) FROM dish WHERE dish.times_appeared > dish.menus_appeared",
            "ba": "The virtual table counts the number of dishes from the 'dish' table that have appeared in menus more than the number of menus they are included in. This indicates that these dishes are featured multiple times across different menus."
        },
        {
            "sample_id": 5481,
            "vt": "SELECT dish.name FROM menuitem INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id INNER JOIN Dish AS T4 ON T1.dish_id = T4.id WHERE menu.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of dishes from the 'dish' table that are included in a specific menu. The query joins multiple tables: 'menuitem' to get the menu items, 'menupage' to link the menu items to their respective pages, and 'menu' to filter by a specific menu name. The placeholder in the WHERE clause represents the name of the menu being queried."
        },
        {
            "sample_id": 5478,
            "vt": "SELECT menupage.menu_id FROM menupage INNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id INNER JOIN Dish AS T3 ON T2.dish_id = T3.id WHERE dish.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the menu ID from the 'menupage' table, which is linked to the 'menuitem' table and the 'dish' table. It filters the results based on the name of a specific dish provided as a placeholder."
        },
        {
            "sample_id": 5533,
            "vt": "SELECT menuitem.price FROM menuitem INNER JOIN MenuPage AS T2 ON T2.id = T1.menu_page_id WHERE menupage.menu_id = [placeholder-type:numeric] AND menupage.page_number = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the prices of menu items from the 'menuitem' table, specifically for a given menu and page number. The placeholders represent the unique identifiers for the menu and the specific page within that menu."
        },
        {
            "sample_id": 5534,
            "vt": "SELECT SUM(CASE WHEN menuitem.created_at BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM dish INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id",
            "ba": "The virtual table calculates the total number of menu items created within a specified date range from the 'dish' table, which contains information about various dishes. It uses a conditional sum to differentiate between items created within the date range and those created outside of it. The join with the 'MenuItem' table allows access to the creation dates of the menu items associated with each dish."
        },
        {
            "sample_id": 5482,
            "vt": "SELECT dish.name FROM menuitem INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id INNER JOIN Dish AS T4 ON T1.dish_id = T4.id WHERE menu.name = '[placeholder-type:string]' ORDER BY menuitem.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of dishes from the 'dish' table that are included in a specific menu. It joins the 'menuitem', 'menupage', and 'menu' tables to filter the results based on the menu name provided. The results are ordered by the price of the menu items, and a limit can be set on the number of results returned."
        },
        {
            "sample_id": 5575,
            "vt": "SELECT menuitem.price FROM dish INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE dish.name = '[placeholder-type:string]' ORDER BY menuitem.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the prices of a specific dish from the 'dish' table by joining it with the 'menuitem' table. The query filters the results based on the dish's name and orders the prices in ascending order, limiting the number of results returned."
        },
        {
            "sample_id": 5517,
            "vt": "SELECT menupage.page_number FROM menu INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id INNER JOIN MenuItem AS T3 ON T2.id = T3.menu_page_id WHERE menuitem.xpos > [placeholder-type:numeric] AND menuitem.ypos < [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the page numbers of menu pages from the 'menu' table, which are associated with specific menu items. It uses inner joins to connect the 'menu', 'menupage', and 'menuitem' tables based on their respective IDs. The query filters the results based on the x and y positions of the menu items, ensuring that only those with an x position greater than a specified value and a y position less than another specified value are included."
        },
        {
            "sample_id": 5489,
            "vt": "SELECT COUNT(*) FROM menuitem WHERE menuitem.menu_page_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the total number of menu items associated with a specific menu page identified by its ID. The placeholder in the WHERE clause represents the unique identifier for the menu page."
        },
        {
            "sample_id": 5470,
            "vt": "SELECT COUNT(*) FROM dish WHERE dish.first_appeared < [placeholder-type:numeric] OR dish.first_appeared > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of dishes from the 'dish' table that first appeared before or after a specified range of years. The placeholders represent the year values to filter the dishes based on their first appearance."
        },
        {
            "sample_id": 5520,
            "vt": "SELECT menuitem.price FROM dish INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE menuitem.id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] ORDER BY menuitem.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the prices of menu items associated with specific dishes from the 'dish' and 'menuitem' tables. It filters the results based on a range of menu item IDs and orders the prices in ascending order, limiting the number of results returned."
        },
        {
            "sample_id": 5504,
            "vt": "SELECT menu.sponsor FROM menu WHERE menu.id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the sponsor information from the 'menu' table for a specific menu identified by its unique ID. The placeholder in the WHERE clause represents the menu's ID."
        },
        {
            "sample_id": 5572,
            "vt": "SELECT menupage.id FROM menupage INNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id INNER JOIN Dish AS T3 ON T2.dish_id = T3.id WHERE dish.name = '[placeholder-type:string]' ORDER BY menupage.full_width LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of menu pages that feature a specific dish, identified by its name. It joins the 'menupage', 'menuitem', and 'dish' tables to filter the results based on the dish's name and orders the results by the full width of the menu page, limiting the number of results returned."
        },
        {
            "sample_id": 5491,
            "vt": "SELECT COUNT(*) FROM dish WHERE dish.times_appeared > dish.menus_appeared",
            "ba": "The virtual table counts the number of dishes from the 'dish' table that have appeared in menus more than the number of menus they are included in. This indicates which dishes are featured multiple times across different menus."
        },
        {
            "sample_id": 5528,
            "vt": "SELECT COUNT(*) FROM menuitem INNER JOIN Dish AS T2 ON T1.dish_id = T2.id WHERE menuitem.xpos > [placeholder-type:numeric] AND menuitem.ypos < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of menu items from the 'menuitem' table that are associated with dishes in the 'dish' table. It filters the results based on the x and y positions of the menu items, ensuring that only those with an x position greater than a specified value and a y position less than a specified value are included in the count."
        },
        {
            "sample_id": 5474,
            "vt": "SELECT dish.name FROM dish INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE menuitem.menu_page_id = [placeholder-type:numeric] AND menuitem.xpos < [placeholder-type:numeric] AND menuitem.ypos < [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of dishes from the 'dish' table that are associated with a specific menu item. It filters the results based on the menu page ID and the x and y positions of the dish on that menu page, ensuring that only dishes located within specified coordinates are included."
        },
        {
            "sample_id": 5488,
            "vt": "SELECT COUNT(*) FROM menuitem WHERE menuitem.created_at LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of menu items created on a specific date from the 'menuitem' table. The placeholder in the WHERE clause represents the date when the menu items were created."
        },
        {
            "sample_id": 5510,
            "vt": "SELECT menu.id FROM menupage INNER JOIN Menu AS T2 ON T2.id = T1.menu_id WHERE menu.sponsor = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of menus from the 'menu' table that are sponsored, by joining it with the 'menupage' table based on the menu ID. The placeholder in the WHERE clause represents the sponsor's identifier."
        },
        {
            "sample_id": 5555,
            "vt": "SELECT dish.name FROM menu INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id INNER JOIN MenuItem AS T3 ON T2.id = T3.menu_page_id INNER JOIN Dish AS T4 ON T3.dish_id = T4.id WHERE menu.sponsor = '[placeholder-type:string]' AND menu.event = '[placeholder-type:string]' AND menu.place = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of dishes from the 'dish' table that are associated with specific menus. It retrieves data by joining the 'menu', 'menupage', and 'menuitem' tables to filter dishes based on the sponsor, event, and place of the menu. The placeholders in the WHERE clause represent the specific values for sponsor, event, and place."
        },
        {
            "sample_id": 5527,
            "vt": "SELECT menu.name FROM menu GROUP BY menu.name ORDER BY menu.dish_count LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of menus from the 'menu' table, grouping them to ensure each name appears only once. The results are ordered by the count of dishes associated with each menu, and the output is limited to a specified number of menu names."
        },
        {
            "sample_id": 5577,
            "vt": "SELECT CAST(COUNT(menuitem.dish_id) AS FLOAT) / COUNT(menu.page_count) FROM menuitem INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id WHERE menupage.menu_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of dishes per page for a specific menu by dividing the total count of menu items by the total count of pages in that menu. The placeholder in the WHERE clause represents the unique identifier of the menu being queried."
        },
        {
            "sample_id": 5539,
            "vt": "SELECT menuitem.xpos, menuitem.ypos, dish.last_appeared - dish.first_appeared FROM dish INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE dish.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides the x and y positions of a dish on a menu page, along with the duration of its appearance in years, calculated by subtracting the year it first appeared from the year it last appeared. The query filters results based on the name of the dish, which is specified by a placeholder."
        },
        {
            "sample_id": 5486,
            "vt": "SELECT AVG(menupage.page_number) FROM menupage INNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id INNER JOIN Dish AS T3 ON T2.dish_id = T3.id WHERE dish.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average page number of menu pages that contain a specific dish. It joins the 'menupage' table with the 'menuitem' table to link menu items to their respective pages, and then further joins with the 'dish' table to filter by the name of the dish specified by the user."
        },
        {
            "sample_id": 5548,
            "vt": "SELECT menu.name FROM menu INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id GROUP BY menupage.menu_id ORDER BY COUNT(menupage.page_number) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of menus from the 'menu' table, which are joined with the 'menupage' table to count the number of pages associated with each menu. The results are grouped by the menu ID and ordered by the count of pages, limiting the output to a specified number of results."
        },
        {
            "sample_id": 5480,
            "vt": "SELECT SUM(CASE WHEN dish.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM menuitem INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id INNER JOIN Dish AS T4 ON T1.dish_id = T4.id WHERE menu.call_number IS NULL",
            "ba": "The virtual table calculates the total number of times a specific dish appears in the menu items, using a conditional sum based on the dish's name. It joins multiple tables: 'menuitem' to get the menu items, 'menupage' to link to the corresponding menu pages, 'menu' to filter menus that are DIY (without a sponsor), and 'dish' to identify the specific dish by its name. The placeholders represent the dish name and numeric values for the sum calculation."
        },
        {
            "sample_id": 5511,
            "vt": "SELECT menupage.image_id FROM menupage INNER JOIN Menu AS T2 ON T2.id = T1.menu_id WHERE menu.location = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the image IDs of menu pages from the 'menupage' table that are associated with a specific menu location. The query uses an INNER JOIN to connect the 'menupage' table with the 'menu' table based on the menu ID, filtering results by the specified location."
        },
        {
            "sample_id": 5567,
            "vt": "SELECT menupage.page_number FROM menupage INNER JOIN Menu AS T2 ON T2.id = T1.menu_id WHERE menu.name = '[placeholder-type:string]' ORDER BY menupage.full_height LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the page numbers of menu pages from the 'menupage' table that are associated with a specific menu name. The query joins the 'menupage' table with the 'menu' table to filter the results based on the menu name provided by the user. The results are ordered by the full height of the menu pages, and a limit is applied to restrict the number of results returned."
        }
    ],
    "shakespeare": [
        {
            "sample_id": 3055,
            "vt": "SELECT chapters.description FROM works RIGHT JOIN chapters AS T2 ON T1.id = T2.work_id WHERE works.title = '[placeholder-type:string]' ORDER BY chapters.scene LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the descriptions of chapters from the 'chapters' table that are associated with a specific work title from the 'works' table. The query uses a RIGHT JOIN to ensure that all chapters are included even if there is no matching work title, and it orders the results by scene while limiting the number of results based on a numeric placeholder."
        },
        {
            "sample_id": 2987,
            "vt": "SELECT COUNT(works.id) FROM works WHERE works.genretype = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of works from the 'works' table that belong to a specific genre type. The placeholder in the WHERE clause represents the genre type being queried."
        },
        {
            "sample_id": 2969,
            "vt": "SELECT MIN(works.date) FROM works WHERE works.genretype = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the earliest date of works from the 'works' table that belong to a specific genre type. The placeholder in the WHERE clause represents the genre type of the work."
        },
        {
            "sample_id": 3062,
            "vt": "SELECT CAST(SUM(CASE WHEN characters.charname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(works.id) FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id WHERE works.genretype = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average based on the number of characters in a specific genre of works. It sums up a conditional value based on whether the character's name matches a specified placeholder, and then multiplies this sum by another placeholder value. Finally, it divides this result by the count of works in the specified genre."
        },
        {
            "sample_id": 3042,
            "vt": "SELECT characters.charname FROM characters INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE paragraphs.chapter_id = [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of characters from the 'characters' table that are mentioned in a specific chapter identified by its ID. The query joins the 'characters' table with the 'paragraphs' table to find the relevant character names associated with the specified chapter. The placeholders allow for dynamic input of the chapter ID and a limit on the number of results returned."
        },
        {
            "sample_id": 3043,
            "vt": "SELECT COUNT(chapters.act) FROM chapters LEFT JOIN works AS T2 ON T1.work_id = T2.id WHERE works.genretype = '[placeholder-type:string]' AND works.title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of acts in the 'chapters' table that are associated with works of a specific genre and title. The placeholders in the WHERE clause represent the genre type and title of the work."
        },
        {
            "sample_id": 3011,
            "vt": "SELECT SUM(CASE WHEN characters.charname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END), SUM(CASE WHEN characters.charname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END), CAST(SUM(CASE WHEN characters.charname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) + SUM(CASE WHEN characters.charname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(works.id) FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id",
            "ba": "The virtual table calculates the total and average values based on character names from the 'characters' table, while also aggregating data from related 'works', 'chapters', and 'paragraphs' tables. It uses conditional summation to differentiate between characters and applies a mathematical operation to derive a final result, which is then averaged over the count of works."
        },
        {
            "sample_id": 2983,
            "vt": "SELECT CAST(SUM(CASE WHEN works.genretype = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(chapters.scene) FROM chapters INNER JOIN works AS T2 ON T1.work_id = T2.id WHERE works.date = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average based on the number of scenes in chapters associated with a specific genre type of works. It sums up a conditional value based on the genre type and divides it by the count of scenes in the chapters, applying a multiplier. The query filters the results based on the date of the works."
        },
        {
            "sample_id": 3017,
            "vt": "SELECT COUNT(chapters.id) FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE works.title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of chapters associated with a specific work from the 'works' table. It joins the 'works' table with the 'chapters' table using the work_id to filter the chapters that belong to the specified work title. The placeholder in the WHERE clause represents the title of the work for which the chapter count is being requested."
        },
        {
            "sample_id": 3013,
            "vt": "SELECT COUNT(paragraphs.paragraphnum) FROM paragraphs WHERE paragraphs.chapter_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of paragraphs in a specific chapter from the 'paragraphs' table. The placeholder in the WHERE clause represents the unique identifier of the chapter."
        },
        {
            "sample_id": 3028,
            "vt": "SELECT COUNT(characters.id) FROM characters WHERE characters.abbrev = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of characters from the 'characters' table that have a specific abbreviation. The placeholder in the WHERE clause represents the abbreviation of the character."
        },
        {
            "sample_id": 2962,
            "vt": "SELECT paragraphs.id FROM paragraphs INNER JOIN characters AS T2 ON T1.character_id = T2.id WHERE characters.description = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of paragraphs from the 'paragraphs' table that are associated with characters whose descriptions match a specified value. The query uses an inner join to connect the 'paragraphs' and 'characters' tables based on the character's ID, allowing for filtering based on the character's description."
        },
        {
            "sample_id": 2974,
            "vt": "SELECT DISTINCT chapters.act FROM chapters INNER JOIN works AS T2 ON T1.id = T1.work_id WHERE works.longtitle = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct acts from the 'chapters' table that are associated with a specific work identified by its long title. The query joins the 'chapters' table with the 'works' table to filter the results based on the long title of the work."
        },
        {
            "sample_id": 2981,
            "vt": "SELECT (SELECT T1.LongTitle, COUNT(T2.Scene) AS num FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T1.GenreType = 'Tragedy' GROUP BY T1.LongTitle, T2.Scene).longtitle FROM (SELECT works.longtitle, COUNT(chapters.scene) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T1.GenreType = 'Tragedy' GROUP BY T1.LongTitle, T2.Scene) AS t ORDER BY (SELECT T1.LongTitle, COUNT(T2.Scene) AS num FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T1.GenreType = 'Tragedy' GROUP BY T1.LongTitle, T2.Scene).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of long titles of works categorized under the genre 'Tragedy', along with the count of scenes associated with each work. It filters the works based on their genre type and groups the results by the long title and scene count. The results are ordered by the number of scenes in descending order, and a limit is applied to restrict the number of returned records."
        },
        {
            "sample_id": 2986,
            "vt": "SELECT works.title FROM works WHERE works.date = (SELECT MIN(works.date) FROM works)",
            "ba": "The virtual table retrieves the title of the earliest work from the 'works' table based on the date of publication. The inner query identifies the minimum date from the 'works' table, and the outer query selects the title corresponding to that date."
        },
        {
            "sample_id": 3023,
            "vt": "SELECT DISTINCT works.longtitle FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id WHERE characters.description = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct long titles of works from the 'works' table, which are associated with chapters and paragraphs that mention characters with a specific description. The query joins the 'works', 'chapters', 'paragraphs', and 'characters' tables to filter the results based on the character's description."
        },
        {
            "sample_id": 3033,
            "vt": "SELECT characters.charname FROM characters WHERE characters.description = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of characters from the 'characters' table that match a specific description. The placeholder in the WHERE clause represents the character's description."
        },
        {
            "sample_id": 3027,
            "vt": "SELECT CAST(SUM(CASE WHEN works.title = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(paragraphs.id) FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id",
            "ba": "The virtual table calculates a weighted average of a specific numeric value based on the title of a work from the 'works' table. It sums up a conditional value based on whether the title matches a specified placeholder, and then multiplies this sum by another placeholder value. Finally, it divides this result by the count of paragraphs associated with the chapters of the work."
        },
        {
            "sample_id": 2957,
            "vt": "SELECT DISTINCT works.title FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id WHERE characters.charname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct titles of works from the 'works' table that are associated with chapters containing paragraphs mentioning a specific character's name. The query joins multiple tables: 'works', 'chapters', 'paragraphs', and 'characters' to filter the results based on the character's name provided as a placeholder."
        },
        {
            "sample_id": 3061,
            "vt": "SELECT chapters.id FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE works.date > (SELECT AVG(works.date) FROM works) * [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of chapters from the 'chapters' table that are associated with works created after the average date of all works. It uses an inner join to connect the 'works' and 'chapters' tables based on the work's ID, and applies a condition to filter the results based on the average date of works, using a numeric placeholder for further specification."
        },
        {
            "sample_id": 3034,
            "vt": "SELECT characters.charname FROM characters INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE paragraphs.paragraphnum = [placeholder-type:numeric] AND paragraphs.chapter_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of characters from the 'characters' table that are mentioned in specific paragraphs of a chapter. The query uses an inner join to connect the 'characters' table with the 'paragraphs' table based on the character's ID. It filters the results to include only those paragraphs that match a specified paragraph number and are associated with a specific chapter ID."
        },
        {
            "sample_id": 3008,
            "vt": "SELECT chapters.description FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE chapters.act = [placeholder-type:numeric] AND chapters.scene = [placeholder-type:numeric] AND works.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the textual descriptions of chapters from the 'chapters' table that are part of a specific work. It filters the chapters based on the act and scene numbers, as well as the title of the work, using placeholders for numeric and string values."
        },
        {
            "sample_id": 3051,
            "vt": "SELECT characters.description FROM characters INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE paragraphs.plaintext = '[placeholder-type:string]' AND paragraphs.paragraphnum BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the descriptions of characters from the 'characters' table based on specific conditions related to paragraphs. It joins the 'characters' table with the 'paragraphs' table to filter character descriptions that are mentioned in paragraphs with a specific plaintext content and within a specified range of paragraph numbers."
        },
        {
            "sample_id": 3040,
            "vt": "SELECT DISTINCT characters.charname FROM characters INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE paragraphs.paragraphnum = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct character names from the 'characters' table that are mentioned in paragraphs of a specific chapter. The query joins the 'characters' table with the 'paragraphs' table based on the character's ID, and filters the results to include only those paragraphs that match a specified paragraph number."
        },
        {
            "sample_id": 3058,
            "vt": "SELECT chapters.id, chapters.description FROM chapters INNER JOIN paragraphs AS T2 ON T1.id = T2.chapter_id WHERE paragraphs.plaintext = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique identifiers and textual descriptions of chapters from the 'chapters' table that are associated with paragraphs containing specific content. The placeholder in the WHERE clause represents the main content of the paragraphs."
        },
        {
            "sample_id": 3041,
            "vt": "SELECT paragraphs.paragraphnum FROM characters INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE characters.charname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the paragraph numbers from the 'paragraphs' table that are associated with a specific character from the 'characters' table. The placeholder in the WHERE clause represents the name of the character being queried."
        },
        {
            "sample_id": 2965,
            "vt": "SELECT (SELECT T1.Title, COUNT(T3.character_id) AS num FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id GROUP BY T3.character_id, T1.Title).title FROM (SELECT works.title, COUNT(paragraphs.character_id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id GROUP BY T3.character_id, T1.Title) AS t ORDER BY (SELECT T1.Title, COUNT(T3.character_id) AS num FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id GROUP BY T3.character_id, T1.Title).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of titles of works along with the count of characters mentioned in their respective paragraphs. It aggregates data from multiple tables: 'works', 'chapters', 'paragraphs', and 'characters'. The query counts the number of unique characters associated with each work's title and orders the results based on the character count, limiting the output to a specified number of results."
        },
        {
            "sample_id": 3052,
            "vt": "SELECT works.longtitle FROM works RIGHT JOIN chapters AS T2 ON T1.id = T2.work_id WHERE chapters.description = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the full title of works from the 'works' table that are associated with chapters containing a specific description. The query uses a RIGHT JOIN to ensure that all chapters are included, even if they do not have a corresponding work, and filters the results based on the chapter's description using a placeholder for string values."
        },
        {
            "sample_id": 3006,
            "vt": "SELECT DISTINCT works.title, works.genretype FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE chapters.act = [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of titles and genre types from the 'works' table, specifically for works that contain chapters belonging to a specified act. The placeholder in the WHERE clause represents the act number."
        },
        {
            "sample_id": 3032,
            "vt": "SELECT works.id FROM works WHERE works.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier of works from the 'works' table that match a specified title pattern. The placeholder in the WHERE clause allows for flexible input of the title to search for."
        },
        {
            "sample_id": 3048,
            "vt": "SELECT paragraphs.character_id FROM paragraphs WHERE paragraphs.plaintext = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the character ID from the 'paragraphs' table based on a specific paragraph's main content. The placeholder in the WHERE clause represents the text content of the paragraph."
        },
        {
            "sample_id": 3026,
            "vt": "SELECT CAST(SUM(chapters.scene) AS FLOAT) / COUNT(chapters.act) FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE works.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of scenes per act for a specific work by joining the 'works' and 'chapters' tables. It sums the total number of scenes in the chapters and divides it by the count of acts, filtering the results based on the title of the work provided as a placeholder."
        },
        {
            "sample_id": 3009,
            "vt": "SELECT works.date, works.id FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE chapters.scene = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the date and unique identifier of works from the 'works' table that are associated with chapters containing a specific scene. The query uses an inner join to connect the 'works' table with the 'chapters' table based on the work's ID, filtering the results to only include chapters that match a specified scene number."
        },
        {
            "sample_id": 3019,
            "vt": "SELECT DISTINCT characters.charname, chapters.description FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id WHERE works.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct character names and chapter descriptions from the 'works' table, joined with the 'chapters', 'paragraphs', and 'characters' tables. The placeholder in the WHERE clause represents the title of the work being queried."
        },
        {
            "sample_id": 3022,
            "vt": "SELECT chapters.scene, chapters.description FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE works.longtitle = '[placeholder-type:string]' AND chapters.act = [placeholder-type:numeric]",
            "ba": "The virtual table describes the scenes and their descriptions from the 'chapters' table that are associated with a specific work identified by its long title. It uses an inner join to connect the 'works' and 'chapters' tables based on the work's ID, and filters the results based on the specified long title and act number."
        },
        {
            "sample_id": 3029,
            "vt": "SELECT works.title FROM works WHERE works.genretype = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of works from the 'works' table that match a specific genre type. The placeholder in the WHERE clause represents the genre type, and the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 3045,
            "vt": "SELECT CAST(SUM(CASE WHEN chapters.act = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(chapters.act) FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE works.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average based on the number of acts in chapters associated with a specific work. It sums up a conditional value based on the act type and divides it by the count of acts, providing a float result. The query joins the 'works' table with the 'chapters' table to filter results based on the title of the work."
        },
        {
            "sample_id": 2982,
            "vt": "SELECT SUM(paragraphs.paragraphnum) FROM chapters INNER JOIN paragraphs AS T2 ON T1.id = T2.chapter_id WHERE chapters.description = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of paragraphs from the 'paragraphs' table that are associated with chapters from the 'chapters' table, filtered by a specific chapter description. The placeholder in the WHERE clause represents the chapter's description."
        },
        {
            "sample_id": 2956,
            "vt": "SELECT SUM(CASE WHEN chapters.act = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN chapters.act = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE works.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between two sums based on conditions applied to the 'act' column in the 'chapters' table. It joins the 'works' table to filter results based on the title of the work. The placeholders represent numeric values for the conditions and a string value for the title of the work."
        },
        {
            "sample_id": 3012,
            "vt": "SELECT paragraphs.paragraphnum FROM paragraphs WHERE paragraphs.plaintext = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the paragraph numbers from the 'paragraphs' table where the main content matches a specific text. The placeholder in the WHERE clause represents the content of the paragraph being searched for."
        },
        {
            "sample_id": 3060,
            "vt": "SELECT DISTINCT works.title FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id WHERE works.date < [placeholder-type:numeric] AND works.genretype = '[placeholder-type:string]' AND characters.charname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct titles of works from the 'works' table that are associated with specific chapters, paragraphs, and characters. It filters the results based on the date of the work being less than a specified numeric value, the genre type being equal to a specified string, and the character name matching a specified string."
        },
        {
            "sample_id": 2989,
            "vt": "SELECT COUNT(works.id) FROM works WHERE works.genretype = '[placeholder-type:string]' AND works.date BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of works from the 'works' table that belong to a specific genre and were created within a specified date range. The placeholders represent the genre type and the start and end dates for filtering the results."
        },
        {
            "sample_id": 3050,
            "vt": "SELECT works.title, characters.charname FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id ORDER BY works.date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of works along with the names of characters associated with those works. It combines data from the 'works', 'chapters', 'paragraphs', and 'characters' tables, linking them through their respective IDs. The results are ordered by the date of the works and limited to a specified number of entries."
        },
        {
            "sample_id": 2953,
            "vt": "SELECT COUNT(works.id) FROM works WHERE works.date < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of works from the 'works' table that were created before a specific date. The placeholder in the WHERE clause represents the cutoff date for filtering the works."
        },
        {
            "sample_id": 3049,
            "vt": "SELECT paragraphs.paragraphnum, paragraphs.id FROM characters INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE characters.charname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the paragraph numbers and IDs from the 'paragraphs' table that are associated with a specific character from the 'characters' table. The placeholder in the WHERE clause represents the character's name."
        },
        {
            "sample_id": 2985,
            "vt": "SELECT COUNT(characters.id) FROM characters WHERE characters.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of characters from the 'characters' table that match a specific description. The placeholder in the WHERE clause represents the character's description being queried."
        },
        {
            "sample_id": 2990,
            "vt": "SELECT characters.charname FROM characters WHERE characters.description = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of characters from the 'characters' table that match a specific description. The placeholder in the WHERE clause represents the character's description being queried."
        },
        {
            "sample_id": 3014,
            "vt": "SELECT works.title FROM works WHERE works.genretype = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of works from the 'works' table that belong to a specific genre type. The query includes a placeholder for the genre type and limits the number of results returned."
        },
        {
            "sample_id": 3030,
            "vt": "SELECT SUM(CASE WHEN works.genretype = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN works.genretype = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM works WHERE works.date > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the difference between the sums of two conditions based on the genre type of works from the 'works' table. It filters the results to include only those works that were created after a specified date, using placeholders for both the genre type and the date."
        },
        {
            "sample_id": 3047,
            "vt": "SELECT COUNT(works.id) FROM works WHERE works.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of works in the 'works' table that match a specific title pattern. The placeholder in the WHERE clause allows for flexible title searching."
        },
        {
            "sample_id": 3005,
            "vt": "SELECT chapters.description FROM paragraphs INNER JOIN chapters AS T2 ON T1.chapter_id = T2.id INNER JOIN characters AS T3 ON T1.character_id = T3.id WHERE characters.abbrev = '[placeholder-type:string]' ORDER BY paragraphs.chapter_id LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the descriptions of chapters from the 'chapters' table that are associated with specific characters mentioned in the 'paragraphs' table. The query uses inner joins to connect the 'paragraphs', 'chapters', and 'characters' tables based on their respective IDs. It filters the results based on the abbreviation of the character, which is provided as a placeholder, and limits the number of results returned based on a numeric placeholder."
        },
        {
            "sample_id": 2997,
            "vt": "SELECT paragraphs.paragraphnum FROM paragraphs INNER JOIN chapters AS T2 ON T1.chapter_id = T2.id WHERE chapters.act = [placeholder-type:numeric] ORDER BY chapters.scene LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the paragraph numbers from the 'paragraphs' table that are associated with chapters of a specific act. It joins the 'paragraphs' table with the 'chapters' table to filter the results based on the act number, and it orders the results by scene while limiting the number of returned paragraphs."
        },
        {
            "sample_id": 3039,
            "vt": "SELECT chapters.description FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE chapters.id = [placeholder-type:numeric] AND works.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the description of a specific chapter from the 'chapters' table, which is linked to the 'works' table. The query filters the results based on the chapter's unique identifier and the title of the work."
        },
        {
            "sample_id": 2968,
            "vt": "SELECT COUNT(works.id) FROM works WHERE works.genretype = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of works from the 'works' table that belong to a specific genre type. The placeholder in the WHERE clause represents the genre type being queried."
        },
        {
            "sample_id": 3059,
            "vt": "SELECT DISTINCT chapters.scene FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id WHERE works.title = '[placeholder-type:string]' AND characters.charname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct scenes from the 'chapters' table that are associated with a specific work and character. It joins the 'works', 'chapters', 'paragraphs', and 'characters' tables to filter the results based on the title of the work and the name of the character."
        },
        {
            "sample_id": 2954,
            "vt": "SELECT COUNT(works.id) FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE chapters.act = [placeholder-type:numeric] AND works.title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of works from the 'works' table that have chapters corresponding to a specific act and title. The placeholders represent the act number and the title of the work."
        },
        {
            "sample_id": 3025,
            "vt": "SELECT characters.charname, paragraphs.paragraphnum, paragraphs.plaintext FROM characters INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE characters.description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the character names, paragraph numbers, and main content of paragraphs from the 'characters' and 'paragraphs' tables. It filters the results based on a specific character description provided by the user."
        },
        {
            "sample_id": 3035,
            "vt": "SELECT DISTINCT chapters.description FROM characters INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id INNER JOIN chapters AS T3 ON T2.chapter_id = T3.id WHERE characters.charname = '[placeholder-type:string]' AND chapters.id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct descriptions of chapters from the 'chapters' table based on specific character names and chapter IDs. The query joins the 'characters' table with the 'paragraphs' table to link characters to their respective paragraphs, and then further joins with the 'chapters' table to access chapter descriptions. The placeholders represent the character's name and the chapter's unique identifier."
        },
        {
            "sample_id": 3057,
            "vt": "SELECT paragraphs.character_id, chapters.work_id FROM chapters INNER JOIN paragraphs AS T2 ON T1.id = T2.chapter_id WHERE paragraphs.plaintext = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the character IDs and work IDs from the 'chapters' and 'paragraphs' tables. It uses an inner join to connect the two tables based on the chapter ID, ensuring that only paragraphs related to specific chapters are included. The query filters the results based on the plaintext content of the paragraphs, represented by a placeholder for string values."
        },
        {
            "sample_id": 3036,
            "vt": "SELECT COUNT(chapters.scene) FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE works.longtitle = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of scenes in chapters associated with a specific work. It joins the 'works' table with the 'chapters' table using the work's ID, filtering by the long title of the work provided as a placeholder."
        },
        {
            "sample_id": 2970,
            "vt": "SELECT DISTINCT characters.abbrev FROM characters WHERE characters.charname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct abbreviations of characters from the 'characters' table based on a specified character name. The placeholder in the WHERE clause represents the character's name."
        },
        {
            "sample_id": 3046,
            "vt": "SELECT COUNT(works.id) FROM works WHERE works.genretype = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of works from the 'works' table that belong to a specific genre type. The placeholder in the WHERE clause represents the genre type being queried."
        },
        {
            "sample_id": 2998,
            "vt": "SELECT (SELECT T3.CharName, COUNT(T3.id) AS num FROM paragraphs AS T1 INNER JOIN chapters AS T2 ON T1.chapter_id = T2.id INNER JOIN characters AS T3 ON T1.character_id = T3.id WHERE T2.Description = 'The sea-coast.' AND T3.CharName <> '(stage directions)' AND T1.chapter_id = 18709 GROUP BY T3.id, T3.CharName).charname FROM (SELECT characters.charname, COUNT(characters.id) FROM paragraphs AS T1 INNER JOIN chapters AS T2 ON T1.chapter_id = T2.id INNER JOIN characters AS T3 ON T1.character_id = T3.id WHERE T2.Description = 'The sea-coast.' AND T3.CharName <> '(stage directions)' AND T1.chapter_id = 18709 GROUP BY T3.id, T3.CharName) AS t WHERE (SELECT T3.CharName, COUNT(T3.id) AS num FROM paragraphs AS T1 INNER JOIN chapters AS T2 ON T1.chapter_id = T2.id INNER JOIN characters AS T3 ON T1.character_id = T3.id WHERE T2.Description = 'The sea-coast.' AND T3.CharName <> '(stage directions)' AND T1.chapter_id = 18709 GROUP BY T3.id, T3.CharName).num = [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of character names from the 'characters' table who are mentioned in paragraphs of a specific chapter, identified by its ID. It filters out stage directions and counts the occurrences of each character's mentions in the chapter with a specific description. The placeholder in the query allows for specifying the number of times a character is mentioned, enabling users to find characters based on their frequency of appearance in that chapter."
        },
        {
            "sample_id": 3000,
            "vt": "SELECT paragraphs.character_id FROM paragraphs INNER JOIN chapters AS T2 ON T1.chapter_id = T2.id WHERE paragraphs.plaintext = '[placeholder-type:string]' AND chapters.description = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the character IDs from the 'paragraphs' table that are associated with specific chapters based on the content of the paragraphs and the description of the chapters. The placeholders in the WHERE clause represent the specific paragraph content and chapter description that the user wants to filter by."
        },
        {
            "sample_id": 3053,
            "vt": "SELECT characters.charname FROM characters INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE paragraphs.plaintext = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of characters from the 'characters' table that are mentioned in paragraphs containing specific text. It uses an inner join to connect the 'characters' table with the 'paragraphs' table based on the character's ID, ensuring that only those characters associated with the specified paragraph content are selected."
        },
        {
            "sample_id": 2999,
            "vt": "SELECT COUNT(paragraphs.chapter_id) FROM works INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id WHERE works.title = '[placeholder-type:string]' AND paragraphs.paragraphnum < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of paragraphs associated with chapters from a specific work, filtering by the title of the work and the paragraph number."
        }
    ],
    "retails": [
        {
            "sample_id": 6727,
            "vt": "SELECT COUNT(partsupp.ps_suppkey) FROM partsupp WHERE partsupp.ps_availqty < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of suppliers from the 'partsupp' table whose available quantity is below a specified threshold. The placeholder in the WHERE clause represents the quantity limit for filtering suppliers."
        },
        {
            "sample_id": 6688,
            "vt": "SELECT CAST(SUM(CASE WHEN nation.n_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(customer.c_custkey) FROM customer INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey",
            "ba": "The virtual table calculates a weighted average based on the total sum of a conditional case when the nation name matches a specified value. It uses the customer table to count the number of customers and joins it with the nation table to filter by nation. The result is then multiplied by a placeholder numeric value and divided by the count of customers to derive the final weighted average."
        },
        {
            "sample_id": 6702,
            "vt": "SELECT CAST(SUM(CASE WHEN region.r_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(nation.n_name) FROM nation INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey",
            "ba": "The virtual table calculates a weighted average based on the sum of a conditional expression from the 'nation' table, filtered by a specific region name. It joins the 'nation' table with the 'region' table to access the region's details. The result is then multiplied by a numeric placeholder and divided by the count of nation names to derive the final value."
        },
        {
            "sample_id": 6805,
            "vt": "SELECT customer.c_name FROM customer WHERE customer.c_acctbal < [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of customers from the 'customer' table who have an account balance less than a specified amount. The placeholders in the WHERE clause represent the account balance limit and the number of results to return."
        },
        {
            "sample_id": 6797,
            "vt": "SELECT SUM(lineitem.l_extendedprice * ([placeholder-type:numeric] - lineitem.l_discount) - partsupp.ps_supplycost * lineitem.l_quantity) / COUNT(partsupp.ps_partkey) FROM partsupp INNER JOIN lineitem AS T2 ON T1.ps_suppkey = T2.l_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey WHERE part.p_type = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average profit from line items based on the supply cost and extended price, filtered by part type. It joins the 'partsupp', 'lineitem', and 'part' tables to gather necessary data for the calculation."
        },
        {
            "sample_id": 6716,
            "vt": "SELECT (SELECT T1.c_mktsegment, COUNT(T1.c_custkey) AS num FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T2.n_name = 'UNITED STATES' GROUP BY T1.c_mktsegment).c_mktsegment FROM (SELECT customer.c_mktsegment, COUNT(customer.c_custkey) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T2.n_name = 'UNITED STATES' GROUP BY T1.c_mktsegment) AS t ORDER BY (SELECT T1.c_mktsegment, COUNT(T1.c_custkey) AS num FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T2.n_name = 'UNITED STATES' GROUP BY T1.c_mktsegment).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the number of customers in different market segments from the 'customer' table, specifically for those customers located in the 'UNITED STATES'. It counts the unique customer keys grouped by market segment and orders the results based on the count of customers in each segment. The placeholder in the LIMIT clause allows for specifying the maximum number of segments to return."
        },
        {
            "sample_id": 6841,
            "vt": "SELECT lineitem.l_linenumber FROM lineitem WHERE STRFTIME('%Y', lineitem.l_shipdate) < [placeholder-type:numeric] AND lineitem.l_shipmode = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique line numbers from the 'lineitem' table for items that were shipped before a specified year and with a specific shipping mode. The placeholders represent the year and the shipping mode respectively."
        },
        {
            "sample_id": 6750,
            "vt": "SELECT nation.n_name FROM nation INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey WHERE region.r_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of nations from the 'nation' table that are associated with a specific region. The query uses an INNER JOIN to connect the 'nation' table with the 'region' table based on the region key, and it filters the results based on the specified region name using a placeholder."
        },
        {
            "sample_id": 6904,
            "vt": "SELECT COUNT(customer.c_name) FROM orders INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE customer.c_mktsegment = '[placeholder-type:string]' AND orders.o_totalprice > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of customers from the 'customer' table who have placed orders with a total price exceeding a specified amount, filtered by their market segment. The placeholders represent the market segment and the total price threshold."
        },
        {
            "sample_id": 6713,
            "vt": "SELECT COUNT(customer.c_custkey) FROM customer INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE customer.c_acctbal < [placeholder-type:numeric] AND customer.c_mktsegment = '[placeholder-type:string]' AND nation.n_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customer' table who belong to a specific market segment, have an account balance below a certain threshold, and are associated with a specific nation. The placeholders in the WHERE clause represent the account balance, market segment, and nation name respectively."
        },
        {
            "sample_id": 6808,
            "vt": "SELECT partsupp.ps_supplycost FROM part INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey WHERE part.p_type = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the supply cost of parts from the 'partsupp' table, which is joined with the 'part' table based on the part key. The query filters the results to include only those parts that match a specific type, represented by a placeholder for string values."
        },
        {
            "sample_id": 6829,
            "vt": "SELECT (SELECT T1.s_acctbal, COUNT(T2.ps_suppkey) AS num FROM supplier AS T1 INNER JOIN partsupp AS T2 ON T1.s_suppkey = T2.ps_suppkey GROUP BY T1.s_suppkey).s_acctbal FROM (SELECT supplier.s_acctbal, COUNT(partsupp.ps_suppkey) FROM supplier AS T1 INNER JOIN partsupp AS T2 ON T1.s_suppkey = T2.ps_suppkey GROUP BY T1.s_suppkey) AS t ORDER BY (SELECT T1.s_acctbal, COUNT(T2.ps_suppkey) AS num FROM supplier AS T1 INNER JOIN partsupp AS T2 ON T1.s_suppkey = T2.ps_suppkey GROUP BY T1.s_suppkey).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the account balances of suppliers along with the count of parts they supply. It retrieves the account balance from the 'supplier' table and counts the number of corresponding entries in the 'partsupp' table for each supplier. The results are ordered by the number of parts supplied, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 6719,
            "vt": "SELECT COUNT(nation.n_nationkey) FROM nation INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey WHERE region.r_comment = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of nations from the 'nation' table that are associated with a specific region, as indicated by a comment in the 'region' table. The placeholder in the WHERE clause represents the comment description of the region."
        },
        {
            "sample_id": 6862,
            "vt": "SELECT part.p_name FROM part WHERE part.p_retailprice = (SELECT MAX(part.p_retailprice) FROM part)",
            "ba": "The virtual table describes the name of the part from the 'part' table that has the highest retail price. The subquery is used to find the maximum retail price among all parts, and the placeholder represents this maximum value."
        },
        {
            "sample_id": 6781,
            "vt": "SELECT lineitem.l_orderkey FROM lineitem ORDER BY lineitem.l_extendedprice * ([placeholder-type:numeric] - lineitem.l_discount) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the order keys from the 'lineitem' table, sorted by the calculated price after applying a discount to the extended price. The placeholders allow for dynamic input of discount values and limits on the number of results returned."
        },
        {
            "sample_id": 6819,
            "vt": "SELECT customer.c_name FROM customer WHERE customer.c_acctbal = (SELECT MIN(customer.c_acctbal) FROM customer)",
            "ba": "The virtual table describes the name of the customer from the 'customer' table who has the lowest account balance. The placeholder in the WHERE clause represents the condition to find the minimum account balance among all customers."
        },
        {
            "sample_id": 6782,
            "vt": "SELECT COUNT(lineitem.l_linenumber) FROM lineitem WHERE lineitem.l_quantity > [placeholder-type:numeric] AND lineitem.l_returnflag = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of line items from the 'lineitem' table that meet specific criteria. It filters the line items based on the quantity being greater than a specified numeric value and checks for a specific return flag using a placeholder for string values."
        },
        {
            "sample_id": 6722,
            "vt": "SELECT SUM(lineitem.l_extendedprice) / [placeholder-type:numeric] FROM orders INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey ORDER BY orders.o_totalprice LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average extended price of line items from the 'lineitem' table, grouped by orders from the 'orders' table. It uses a join to connect the two tables based on the order key, allowing for aggregation of line item prices associated with each order. The result is ordered by the total price of the orders, and the output is limited to a specified number of results."
        },
        {
            "sample_id": 6800,
            "vt": "SELECT lineitem.l_linenumber FROM lineitem WHERE lineitem.l_discount = [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique line numbers from the 'lineitem' table where the discount applied to the line item matches a specified value. The query also limits the number of results returned based on a specified count."
        },
        {
            "sample_id": 6766,
            "vt": "SELECT supplier.s_suppkey, supplier.s_acctbal FROM supplier ORDER BY supplier.s_acctbal LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of suppliers along with their account balances from the 'supplier' table. The results are ordered by the account balance, allowing users to see which suppliers have the highest or lowest balances. The placeholder in the LIMIT clause indicates that users can specify the number of suppliers they wish to retrieve."
        },
        {
            "sample_id": 6710,
            "vt": "SELECT lineitem.l_shipdate FROM orders INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey ORDER BY orders.o_totalprice LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the shipping dates of line items associated with orders, sorted by the total price of the orders. The query joins the 'orders' table with the 'lineitem' table based on the order key, ensuring that only relevant line items for each order are considered. The result is limited to a specified number of entries, allowing for focused analysis of shipping dates for the highest total price orders."
        },
        {
            "sample_id": 6784,
            "vt": "SELECT COUNT(orders.o_orderkey) FROM orders WHERE orders.o_orderpriority = '[placeholder-type:string]' GROUP BY orders.o_orderdate ORDER BY orders.o_orderdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of orders from the 'orders' table based on a specific order priority. It groups the results by the order date and orders them chronologically, limiting the output to a specified number of results."
        },
        {
            "sample_id": 6849,
            "vt": "SELECT customer.c_name FROM orders INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE orders.o_totalprice > [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of customers from the 'customer' table who have placed orders with a total price exceeding a specified amount. The query uses an INNER JOIN to connect the 'orders' table with the 'customer' table based on the customer key, ensuring that only relevant customer names are retrieved for orders that meet the price condition."
        },
        {
            "sample_id": 6902,
            "vt": "SELECT customer.c_name FROM orders INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey INNER JOIN customer AS T3 ON T1.o_custkey = T3.c_custkey ORDER BY (JULIANDAY(lineitem.l_receiptdate) - JULIANDAY(lineitem.l_commitdate)) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of customers who have placed orders, sorted by the speed of delivery, which is calculated as the difference between the receipt date and the commit date of the line items. The query limits the results to a specified number of entries."
        },
        {
            "sample_id": 6712,
            "vt": "SELECT COUNT(orders.o_orderkey) FROM lineitem INNER JOIN orders AS T2 ON T2.o_orderkey = T1.l_orderkey WHERE JULIANDAY(lineitem.l_shipdate) - JULIANDAY(orders.o_orderdate) = [placeholder-type:numeric] AND orders.o_orderpriority = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of orders from the 'orders' table that are associated with line items from the 'lineitem' table. It filters the results based on the shipping date of the line items and the order date of the orders, ensuring that the difference between these two dates matches a specified numeric value. Additionally, it includes a condition to filter orders based on their priority using a placeholder for string values."
        },
        {
            "sample_id": 6745,
            "vt": "SELECT customer.c_phone FROM customer ORDER BY customer.c_acctbal LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the phone numbers of customers from the 'customer' table, ordered by their account balance. The placeholder in the LIMIT clause allows the user to specify how many phone numbers to return."
        },
        {
            "sample_id": 6821,
            "vt": "SELECT COUNT(lineitem.l_linenumber) FROM lineitem WHERE lineitem.l_shipinstruct = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of line items from the 'lineitem' table that have a specific shipping instruction. The placeholder in the WHERE clause represents the shipping instruction to filter the results."
        },
        {
            "sample_id": 6824,
            "vt": "SELECT nation.n_name FROM region INNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey WHERE region.r_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of nations from the 'nation' table that belong to a specific region. The query uses an INNER JOIN to connect the 'region' and 'nation' tables based on their region key, filtering the results by the specified region name."
        },
        {
            "sample_id": 6840,
            "vt": "SELECT lineitem.l_linenumber FROM lineitem WHERE STRFTIME('%Y', lineitem.l_shipdate) < [placeholder-type:numeric] AND lineitem.l_shipmode = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique line numbers from the 'lineitem' table for items that were shipped before a specified year and with a specific shipping mode. The placeholders represent the year and the shipping mode respectively."
        },
        {
            "sample_id": 6828,
            "vt": "SELECT DISTINCT lineitem.l_shipmode FROM orders INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE orders.o_orderdate = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct shipping modes used for orders placed on a specific order date. It combines data from the 'orders' and 'lineitem' tables, linking them through the order key. The placeholder in the WHERE clause represents the specific order date being queried."
        },
        {
            "sample_id": 6760,
            "vt": "SELECT CAST(SUM(CASE WHEN nation.n_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(customer.c_custkey) FROM customer INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE customer.c_acctbal < [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average of a specific numeric value based on the customer account balance and their nation. It sums up a conditional value based on the nation name and multiplies it by a placeholder numeric value, then divides by the count of customers. The query filters customers whose account balance is below a specified threshold."
        },
        {
            "sample_id": 6818,
            "vt": "SELECT COUNT(supplier.s_suppkey) FROM supplier INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE supplier.s_acctbal < [placeholder-type:numeric] AND nation.n_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of suppliers from the 'supplier' table who have an account balance below a specified threshold and belong to a specific nation. The placeholders represent the account balance limit and the name of the nation."
        },
        {
            "sample_id": 6814,
            "vt": "SELECT COUNT(customer.c_custkey) FROM customer INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE customer.c_mktsegment = '[placeholder-type:string]' AND nation.n_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customer' table who belong to a specific market segment and are associated with a particular nation. The placeholders in the WHERE clause represent the market segment and the nation name."
        },
        {
            "sample_id": 6726,
            "vt": "SELECT CAST(SUM(CASE WHEN customer.c_acctbal < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(customer.c_custkey) FROM customer",
            "ba": "The virtual table calculates a weighted average of account balances from the 'customer' table. It sums the account balances of customers who are in debt (where the account balance is less than a specified threshold) and applies a multiplier to this sum. The result is then divided by the total number of customers to obtain the average. The placeholders represent the threshold for debt, the multiplier for the sum, and the numeric values for the account balances."
        },
        {
            "sample_id": 6872,
            "vt": "SELECT SUM(partsupp.ps_availqty) FROM partsupp INNER JOIN part AS T2 ON T1.ps_partkey = T2.p_partkey WHERE part.p_name = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total available quantity of parts from the 'partsupp' table, filtered by the name of the part from the 'part' table. The placeholder in the WHERE clause represents the specific name of the part being queried."
        },
        {
            "sample_id": 6735,
            "vt": "SELECT COUNT(orders.o_orderkey), SUM(lineitem.l_extendedprice * ([placeholder-type:numeric] - lineitem.l_discount) * ([placeholder-type:numeric] + lineitem.l_tax)) FROM customer INNER JOIN orders AS T2 ON T1.c_custkey = T2.o_custkey INNER JOIN lineitem AS T3 ON T2.o_orderkey = T3.l_orderkey WHERE customer.c_name = '[placeholder-type:string]' GROUP BY lineitem.l_linenumber",
            "ba": "The virtual table summarizes the total number of orders and the total revenue generated from line items for a specific customer. It joins the 'customer', 'orders', and 'lineitem' tables to correlate customer information with their respective orders and line items. The placeholders represent the customer's name for filtering and numeric values for calculations related to discounts and taxes."
        },
        {
            "sample_id": 6740,
            "vt": "SELECT part.p_name FROM partsupp INNER JOIN part AS T2 ON T1.ps_partkey = T2.p_partkey INNER JOIN lineitem AS T3 ON T1.ps_partkey = T3.l_partkey WHERE lineitem.l_discount = [placeholder-type:numeric] AND lineitem.l_shipdate = '[placeholder-type:string]' AND lineitem.l_shipmode = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of parts from the 'part' table that are associated with specific line items in the 'lineitem' table. It filters the results based on a specified discount, ship date, and ship mode. The placeholders represent the discount percentage, the date of shipping, and the mode of shipping respectively."
        },
        {
            "sample_id": 6759,
            "vt": "SELECT nation.n_name FROM customer INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey INNER JOIN (SELECT AVG(c_acctbal) * 0.8 AS avg_acctbal FROM customer) AS T3 WHERE customer.c_acctbal > (SELECT AVG(c_acctbal) * 0.8 AS avg_acctbal FROM customer).avg_acctbal",
            "ba": "The virtual table lists the names of nations from the 'nation' table where customers have an account balance greater than 80% of the average account balance of all customers. This is achieved by joining the 'customer' table with the 'nation' table based on the nation key, and filtering based on the calculated average account balance."
        },
        {
            "sample_id": 6767,
            "vt": "SELECT COUNT(customer.c_custkey) FROM orders INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE customer.c_acctbal > [placeholder-type:numeric] AND orders.o_orderpriority = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customer' table who have placed orders, filtered by their account balance and order priority. The placeholders represent the minimum account balance and the specific order priority to filter the results accordingly."
        },
        {
            "sample_id": 6896,
            "vt": "SELECT customer.c_mktsegment FROM customer WHERE customer.c_acctbal = (SELECT MIN(customer.c_acctbal) FROM customer)",
            "ba": "The virtual table describes the marketing segment of the customer with the lowest account balance from the 'customer' table. The placeholder in the WHERE clause represents the condition to find the minimum account balance among all customers."
        },
        {
            "sample_id": 6832,
            "vt": "SELECT customer.c_phone FROM orders INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE orders.o_totalprice > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the phone numbers of customers from the 'customer' table who have placed orders with a total price exceeding a specified amount. The query involves an inner join between the 'orders' and 'customer' tables, linking them through the customer key, and applies a condition to filter orders based on their total price."
        },
        {
            "sample_id": 6885,
            "vt": "SELECT COUNT(lineitem.l_linenumber) FROM lineitem INNER JOIN supplier AS T2 ON T1.l_suppkey = T2.s_suppkey WHERE lineitem.l_orderkey = [placeholder-type:numeric] AND supplier.s_acctbal < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of line items from the 'lineitem' table that are associated with a specific order and belong to suppliers with an account balance below a certain threshold. The placeholders represent the order key and the account balance limit."
        },
        {
            "sample_id": 6838,
            "vt": "SELECT orders.o_totalprice FROM orders WHERE orders.o_orderkey = [placeholder-type:numeric]",
            "ba": "The virtual table provides the total price of an order from the 'orders' table based on a specific order key. The placeholder in the WHERE clause represents the unique identifier for the order."
        },
        {
            "sample_id": 6763,
            "vt": "SELECT orders.o_orderkey FROM orders WHERE orders.o_totalprice BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique order keys from the 'orders' table for orders that have a total price falling within a specified range. The placeholders represent the minimum and maximum total price values for filtering the results."
        },
        {
            "sample_id": 6894,
            "vt": "SELECT lineitem.l_extendedprice * ([placeholder-type:numeric] - lineitem.l_discount) - partsupp.ps_supplycost * lineitem.l_quantity FROM lineitem INNER JOIN partsupp AS T2 ON T1.l_suppkey = T2.ps_suppkey WHERE lineitem.l_orderkey = [placeholder-type:numeric] AND lineitem.l_partkey = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the profit for line items by subtracting the supply cost from the discounted extended price. It retrieves data from the 'lineitem' and 'partsupp' tables, joining them on the supplier key. The placeholders represent specific order and part keys to filter the results accordingly."
        },
        {
            "sample_id": 6909,
            "vt": "SELECT nation.n_name FROM supplier INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey ORDER BY supplier.s_suppkey LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of nations from the 'nation' table that are associated with suppliers in the 'supplier' table. The query joins the 'supplier' and 'nation' tables on the nation key, ensuring that only nations linked to suppliers are included. The results are ordered by the supplier's unique identifier and limited to a specified number of entries."
        },
        {
            "sample_id": 6804,
            "vt": "SELECT COUNT(orders.o_orderkey) FROM orders WHERE STRFTIME('%Y', orders.o_orderdate) = '[placeholder-type:string]' AND orders.o_totalprice < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of orders from the 'orders' table that were placed in a specific year and have a total price below a certain threshold. The placeholders represent the year and the maximum total price for filtering the results."
        },
        {
            "sample_id": 6830,
            "vt": "SELECT nation.n_name FROM supplier INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE supplier.s_acctbal = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of nations from the 'nation' table that are associated with suppliers from the 'supplier' table who have a specific account balance. The placeholder in the WHERE clause represents the account balance of the supplier."
        },
        {
            "sample_id": 6901,
            "vt": "SELECT COUNT(orders.o_orderkey) FROM orders WHERE STRFTIME('%Y', orders.o_orderdate) = '[placeholder-type:string]' AND orders.o_clerk = '[placeholder-type:string]' AND orders.o_orderpriority = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of orders from the 'orders' table based on specific criteria. It filters the orders by the year of the order date, the clerk handling the order, and the priority of the order. The placeholders represent the year, clerk's name, and order priority respectively."
        },
        {
            "sample_id": 6691,
            "vt": "SELECT region.r_name FROM nation INNER JOIN supplier AS T2 ON T1.n_nationkey = T2.s_nationkey INNER JOIN region AS T3 ON T1.n_regionkey = T3.r_regionkey WHERE supplier.s_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of regions associated with suppliers from the 'supplier' table based on a specific supplier's name. The query involves joining the 'nation' table to link nations to their respective suppliers and then joining the 'region' table to get the region names. The placeholder in the WHERE clause represents the name of the supplier being queried."
        },
        {
            "sample_id": 6701,
            "vt": "SELECT (SELECT T2.n_name, SUM(T1.s_acctbal) AS num FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T1.s_acctbal < 0 GROUP BY T2.n_name).n_name FROM (SELECT nation.n_name, SUM(supplier.s_acctbal) FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T1.s_acctbal < 0 GROUP BY T2.n_name) AS t ORDER BY (SELECT T2.n_name, SUM(T1.s_acctbal) AS num FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T1.s_acctbal < 0 GROUP BY T2.n_name).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total account balances of suppliers who are in debt, grouped by their respective nations. It retrieves the names of the nations and the sum of account balances for suppliers with negative account balances, ordering the results by the total debt amount in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 6734,
            "vt": "SELECT SUM(orders.o_totalprice) FROM orders INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE customer.c_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total price of orders from the 'orders' table for a specific customer. It joins the 'orders' table with the 'customer' table based on the customer key, filtering the results to include only those orders made by a customer with a specified name."
        },
        {
            "sample_id": 6807,
            "vt": "SELECT SUM(CASE WHEN lineitem.l_returnflag = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN lineitem.l_returnflag = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM lineitem WHERE lineitem.l_extendedprice < [placeholder-type:numeric]",
            "ba": "The virtual table calculates the difference between the total amounts of line items based on their return status, filtered by the extended price of the line items. It uses placeholders for the return flag values and the extended price threshold."
        },
        {
            "sample_id": 6756,
            "vt": "SELECT customer.c_name, customer.c_mktsegment FROM orders INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE orders.o_totalprice = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names and market segments of customers from the 'customer' table who have placed orders with a specific total price. The query uses an INNER JOIN to connect the 'orders' table with the 'customer' table based on the customer key, filtering results by the total price of the orders."
        },
        {
            "sample_id": 6833,
            "vt": "SELECT orders.o_clerk FROM orders INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE lineitem.l_shipmode = '[placeholder-type:string]'",
            "ba": "The virtual table describes the clerks who processed orders from the 'orders' table, filtered by the shipping mode of the line items. The placeholder in the WHERE clause represents the specific shipping mode being queried."
        },
        {
            "sample_id": 6876,
            "vt": "SELECT COUNT(supplier.s_name) FROM part INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN supplier AS T3 ON T2.ps_suppkey = T3.s_suppkey WHERE supplier.s_acctbal < [placeholder-type:numeric] AND part.p_type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of suppliers who provide a specific type of part and have an account balance below a certain threshold. It joins the 'part', 'partsupp', and 'supplier' tables to filter the results based on the part type and supplier account balance."
        },
        {
            "sample_id": 6869,
            "vt": "SELECT supplier.s_name FROM partsupp INNER JOIN supplier AS T2 ON T1.ps_suppkey = T2.s_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey WHERE part.p_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of suppliers from the 'supplier' table who supply a specific part. It joins the 'partsupp' table to link suppliers with parts, and filters the results based on the name of the part using a placeholder."
        },
        {
            "sample_id": 6886,
            "vt": "SELECT COUNT(lineitem.l_partkey) FROM lineitem INNER JOIN supplier AS T2 ON T1.l_suppkey = T2.s_suppkey WHERE lineitem.l_returnflag = '[placeholder-type:string]' AND supplier.s_acctbal < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of line items from the 'lineitem' table that are associated with suppliers from the 'supplier' table. It filters the results based on a specific return flag for line items and ensures that only suppliers with an account balance below a certain threshold are included in the count."
        },
        {
            "sample_id": 6723,
            "vt": "SELECT (SELECT T2.c_name, SUM(T1.o_totalprice) / COUNT(T1.o_orderkey) AS res, COUNT(T1.o_orderkey) AS num FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey GROUP BY T1.o_custkey).c_name, (SELECT T2.c_name, SUM(T1.o_totalprice) / COUNT(T1.o_orderkey) AS res, COUNT(T1.o_orderkey) AS num FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey GROUP BY T1.o_custkey).res FROM (SELECT customer.c_name, SUM(orders.o_totalprice) / COUNT(orders.o_orderkey), COUNT(orders.o_orderkey) FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey GROUP BY T1.o_custkey) AS t ORDER BY (SELECT T2.c_name, SUM(T1.o_totalprice) / COUNT(T1.o_orderkey) AS res, COUNT(T1.o_orderkey) AS num FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey GROUP BY T1.o_custkey).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the average total price of orders placed by each customer from the 'orders' and 'customer' tables. It calculates the average total price per customer and counts the number of orders for each customer. The results are ordered by the number of orders, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 6875,
            "vt": "SELECT COUNT(supplier.s_name) FROM part INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN supplier AS T3 ON T2.ps_suppkey = T3.s_suppkey INNER JOIN nation AS T4 ON T3.s_nationkey = T4.n_nationkey WHERE part.p_name = '[placeholder-type:string]' AND nation.n_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of suppliers for a specific part name and nation name by joining the 'part', 'partsupp', 'supplier', and 'nation' tables. The placeholders represent the part name and nation name that the user wants to filter by."
        },
        {
            "sample_id": 6870,
            "vt": "SELECT MIN(partsupp.ps_supplycost) FROM partsupp INNER JOIN part AS T2 ON T1.ps_partkey = T2.p_partkey WHERE part.p_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the minimum supply cost of a specific part from the 'partsupp' table by joining it with the 'part' table. The placeholder in the WHERE clause represents the name of the part for which the minimum supply cost is being queried."
        },
        {
            "sample_id": 6793,
            "vt": "SELECT COUNT(orders.o_clerk) FROM orders INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE customer.c_address = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of orders placed by customers from the 'orders' table, joining it with the 'customer' table to filter based on the customer's address. The placeholder in the WHERE clause represents the specific address of the customer."
        },
        {
            "sample_id": 6835,
            "vt": "SELECT supplier.s_address FROM partsupp INNER JOIN supplier AS T2 ON T1.ps_suppkey = T2.s_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey ORDER BY part.p_size LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the addresses of suppliers from the 'supplier' table, based on their supply relationships defined in the 'partsupp' table. It joins the 'partsupp' table with the 'supplier' table using the supplier key, and also joins with the 'part' table to access part details. The results are ordered by the size of the parts, and a limit is applied to restrict the number of returned addresses."
        },
        {
            "sample_id": 6802,
            "vt": "SELECT CASE WHEN SUM(CASE WHEN lineitem.l_shipmode = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN lineitem.l_shipmode = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM lineitem WHERE lineitem.l_shipinstruct = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a conditional sum based on the shipping mode of line items from the 'lineitem' table. It uses placeholders to specify the shipping modes and numeric values for the calculations. The result is determined by comparing two sums, which are filtered by the shipping instructions also specified by a placeholder."
        },
        {
            "sample_id": 6730,
            "vt": "SELECT COUNT(orders.o_orderkey) FROM orders INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE lineitem.l_shipmode = '[placeholder-type:string]' AND orders.o_orderpriority = '[placeholder-type:string]' AND SUBSTRING(lineitem.l_shipdate, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of orders from the 'orders' table that are associated with line items in the 'lineitem' table. It filters the results based on the shipping mode and order priority, as well as a substring condition applied to the shipping date."
        },
        {
            "sample_id": 6707,
            "vt": "SELECT COUNT(lineitem.l_linenumber) FROM lineitem WHERE lineitem.l_returnflag = '[placeholder-type:string]' AND lineitem.l_shipmode = '[placeholder-type:string]' AND STRFTIME('%Y', lineitem.l_shipdate) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of line items from the 'lineitem' table that meet specific criteria. It filters the results based on whether the line item has been returned, the shipping mode used, and the year of the shipping date. The placeholders represent the return flag, shipping mode, and year respectively."
        },
        {
            "sample_id": 6672,
            "vt": "SELECT lineitem.l_orderkey FROM lineitem WHERE lineitem.l_orderkey IN ([placeholder-type:numeric], [placeholder-type:numeric]) ORDER BY lineitem.l_shipdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the order keys from the 'lineitem' table for specific orders, identified by their order keys. The results are sorted by the shipping date, and a limit is applied to the number of records returned."
        },
        {
            "sample_id": 6697,
            "vt": "SELECT lineitem.l_extendedprice * ([placeholder-type:numeric] - lineitem.l_discount) * ([placeholder-type:numeric] + lineitem.l_tax) FROM orders INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE orders.o_clerk = '[placeholder-type:string]' AND lineitem.l_shipmode = '[placeholder-type:string]' AND orders.o_orderstatus = '[placeholder-type:string]' AND orders.o_orderdate = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total charge for line items associated with orders placed by a specific clerk, filtered by shipping mode, order status, and order date. It uses the extended price, discount, and tax from the lineitem table to compute the final charge."
        },
        {
            "sample_id": 6695,
            "vt": "SELECT lineitem.l_extendedprice * ([placeholder-type:numeric] - lineitem.l_discount) FROM lineitem INNER JOIN orders AS T2 ON T2.o_orderkey = T1.l_orderkey WHERE lineitem.l_suppkey = [placeholder-type:numeric] AND orders.o_totalprice = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the discounted extended price of line items from the 'lineitem' table, where it joins with the 'orders' table to filter based on specific order keys. The placeholders represent the supplier key and the total price of the order, allowing users to specify these values for their queries."
        },
        {
            "sample_id": 6854,
            "vt": "SELECT customer.c_name FROM orders INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey INNER JOIN customer AS T3 ON T1.o_custkey = T3.c_custkey WHERE lineitem.l_discount = [placeholder-type:numeric] AND STRFTIME('%Y', orders.o_orderdate) BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of customers who have placed orders with a specific discount applied to the line items. It filters the results based on the discount percentage and the order date range specified by placeholders."
        },
        {
            "sample_id": 6715,
            "vt": "SELECT COUNT(orders.o_orderkey) FROM orders INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE lineitem.l_shipmode = '[placeholder-type:string]' AND orders.o_orderpriority = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of orders from the 'orders' table that have associated line items in the 'lineitem' table. It filters the results based on the shipping mode and order priority, both of which are represented by placeholders for string values."
        },
        {
            "sample_id": 6776,
            "vt": "SELECT AVG(lineitem.l_discount) FROM part INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN lineitem AS T3 ON T2.ps_suppkey = T3.l_suppkey WHERE part.p_mfgr = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average discount applied to line items for parts manufactured by a specific manufacturer. It joins the 'part' table with the 'partsupp' table to link parts with their suppliers, and then further joins with the 'lineitem' table to access discount information. The placeholder in the WHERE clause represents the manufacturer's name."
        },
        {
            "sample_id": 6844,
            "vt": "SELECT COUNT(customer.c_name) FROM customer INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE customer.c_mktsegment = '[placeholder-type:string]' AND nation.n_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customer' table who belong to a specific market segment and are located in a specific nation. The placeholders in the WHERE clause represent the market segment and the nation name."
        },
        {
            "sample_id": 6698,
            "vt": "SELECT JULIANDAY(lineitem.l_receiptdate) - JULIANDAY(lineitem.l_commitdate) FROM orders INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE orders.o_custkey = '[placeholder-type:string]' AND orders.o_orderdate = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the shipping or delivery time for orders by subtracting the commit date from the receipt date of line items. It retrieves this information by joining the 'orders' table with the 'lineitem' table based on the order key. The placeholders in the WHERE clause represent the customer key and the order date, allowing users to specify which customer's order and date they are interested in."
        },
        {
            "sample_id": 6747,
            "vt": "SELECT COUNT(orders.o_orderkey) FROM orders INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey INNER JOIN nation AS T3 ON T2.c_nationkey = T3.n_nationkey WHERE nation.n_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of orders from the 'orders' table that are associated with customers from a specific nation. It joins the 'orders' table with the 'customer' table to link orders to customers, and then further joins with the 'nation' table to filter based on the nation's name. The placeholder in the WHERE clause represents the name of the nation for which the order count is being queried."
        },
        {
            "sample_id": 6865,
            "vt": "SELECT MIN(part.p_size) FROM part WHERE part.p_container = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the minimum size of parts from the 'part' table that are contained in a specific type of container. The placeholder in the WHERE clause represents the type of container being queried."
        },
        {
            "sample_id": 6693,
            "vt": "SELECT region.r_name FROM nation INNER JOIN customer AS T2 ON T1.n_nationkey = T2.c_nationkey INNER JOIN region AS T3 ON T1.n_regionkey = T3.r_regionkey WHERE customer.c_custkey = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of regions associated with a specific customer identified by their unique customer key. It retrieves this information by joining the 'nation' table with the 'customer' table based on the nation key, and then further joins with the 'region' table based on the region key. The placeholder in the WHERE clause represents the unique identifier for the customer."
        },
        {
            "sample_id": 6675,
            "vt": "SELECT COUNT(orders.o_orderkey) FROM orders INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE customer.c_mktsegment = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of orders from the 'orders' table that are associated with customers in a specific market segment. It joins the 'orders' table with the 'customer' table based on the customer key, filtering the results to include only those customers belonging to a specified market segment."
        },
        {
            "sample_id": 6892,
            "vt": "SELECT AVG(partsupp.ps_supplycost) FROM partsupp INNER JOIN supplier AS T2 ON T1.ps_suppkey = T2.s_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey WHERE part.p_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average supply cost of parts from the 'partsupp' table, joining with the 'supplier' and 'part' tables to filter by a specific part name. The placeholder in the WHERE clause represents the name of the part for which the average supply cost is being calculated."
        },
        {
            "sample_id": 6705,
            "vt": "SELECT COUNT(lineitem.l_orderkey) FROM lineitem WHERE STRFTIME('%Y', lineitem.l_shipdate) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of line items from the 'lineitem' table that were shipped in a specific year. The placeholder in the WHERE clause represents the year of interest."
        },
        {
            "sample_id": 6893,
            "vt": "SELECT CAST((MAX(partsupp.ps_supplycost) - MIN(partsupp.ps_supplycost)) AS FLOAT) * [placeholder-type:numeric] / MIN(partsupp.ps_supplycost) FROM partsupp INNER JOIN supplier AS T2 ON T1.ps_suppkey = T2.s_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey WHERE part.p_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage difference in supply costs for a specific part by finding the maximum and minimum supply costs from the 'partsupp' table, then normalizing this difference by the minimum supply cost and multiplying it by a numeric placeholder. The query joins the 'partsupp' table with the 'supplier' and 'part' tables to filter results based on the part's name."
        },
        {
            "sample_id": 6867,
            "vt": "SELECT supplier.s_name FROM supplier ORDER BY supplier.s_acctbal LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of suppliers from the 'supplier' table, ordered by their account balance. The placeholder in the LIMIT clause allows for specifying the maximum number of supplier names to retrieve."
        },
        {
            "sample_id": 6696,
            "vt": "SELECT lineitem.l_suppkey FROM orders INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE orders.o_totalprice = [placeholder-type:numeric] AND lineitem.l_returnflag = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the supplier key from the 'lineitem' table for orders that match a specific total price and return flag. It uses an inner join between the 'orders' and 'lineitem' tables based on the order key, ensuring that only relevant line items associated with the specified orders are considered."
        },
        {
            "sample_id": 6770,
            "vt": "SELECT CAST(SUM(CASE WHEN customer.c_mktsegment = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(customer.c_name) FROM customer INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE nation.n_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of a specific metric for customers belonging to a certain market segment and nation. It sums up a conditional value based on the market segment and divides it by the count of customer names, applying a multiplier to the result. The placeholders represent the market segment, the numeric values for the calculation, and the nation name."
        },
        {
            "sample_id": 6746,
            "vt": "SELECT orders.o_orderpriority FROM orders WHERE orders.o_totalprice = (SELECT MAX(orders.o_totalprice) FROM orders)",
            "ba": "The virtual table retrieves the order priority of the order with the highest total price from the 'orders' table. The placeholder in the subquery represents the maximum total price of all orders, allowing users to identify the priority of the most expensive order."
        },
        {
            "sample_id": 6877,
            "vt": "SELECT supplier.s_name FROM part INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN supplier AS T3 ON T2.ps_suppkey = T3.s_suppkey WHERE part.p_brand = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of suppliers from the 'supplier' table who supply parts of a specific brand. The query involves joining the 'part' and 'partsupp' tables to link parts with their suppliers, and it filters the results based on the specified brand using a placeholder for string values."
        },
        {
            "sample_id": 6732,
            "vt": "SELECT COUNT(customer.c_custkey) FROM customer INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE customer.c_acctbal < [placeholder-type:numeric] AND nation.n_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customer' table who have an account balance less than a specified amount and belong to a specific nation. The query joins the 'customer' table with the 'nation' table based on the nation key, applying filters for account balance and nation name."
        },
        {
            "sample_id": 6686,
            "vt": "SELECT orders.o_orderkey FROM nation INNER JOIN customer AS T2 ON T1.n_nationkey = T2.c_nationkey INNER JOIN orders AS T3 ON T2.c_custkey = T3.o_custkey WHERE nation.n_name = '[placeholder-type:string]' ORDER BY orders.o_orderdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the order keys from the 'orders' table for customers belonging to a specific nation. It joins the 'nation' table with the 'customer' table based on the nation key, and then joins the resulting table with the 'orders' table using the customer key. The query filters results based on the specified nation name and orders them by the order date, limiting the number of results to a specified numeric value."
        },
        {
            "sample_id": 6826,
            "vt": "SELECT customer.c_phone FROM customer INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE nation.n_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the phone numbers of customers from the 'customer' table who belong to a specific nation. The query joins the 'customer' table with the 'nation' table based on the nation key, filtering results to include only those customers from a specified nation."
        },
        {
            "sample_id": 6855,
            "vt": "SELECT CAST(SUM(CASE WHEN region.r_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(nation.n_name) FROM region INNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey",
            "ba": "The virtual table calculates a weighted average based on the sum of a conditional expression involving the region's name and a numeric placeholder, divided by the count of nation names. It joins the 'region' table with the 'nation' table using the region key to filter and aggregate data accordingly."
        },
        {
            "sample_id": 6884,
            "vt": "SELECT supplier.s_phone FROM lineitem INNER JOIN supplier AS T2 ON T1.l_suppkey = T2.s_suppkey WHERE lineitem.l_orderkey = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the phone numbers of suppliers associated with a specific line item order from the 'lineitem' and 'supplier' tables. The join condition links the line item to its corresponding supplier using the supplier key, while the placeholder in the WHERE clause specifies the order key for filtering the results."
        },
        {
            "sample_id": 6761,
            "vt": "SELECT customer.c_name, customer.c_phone FROM customer WHERE customer.c_acctbal > [placeholder-type:numeric]",
            "ba": "The virtual table describes the names and phone numbers of customers from the 'customer' table who have an account balance greater than a specified amount. The placeholder in the WHERE clause represents the minimum account balance to filter the results."
        },
        {
            "sample_id": 6888,
            "vt": "SELECT lineitem.l_quantity FROM lineitem INNER JOIN part AS T2 ON T1.l_partkey = T2.p_partkey WHERE lineitem.l_orderkey = [placeholder-type:numeric] AND part.p_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the quantity of line items from the 'lineitem' table that are associated with a specific order and part name. The placeholders in the WHERE clause represent the order key and the part name respectively."
        },
        {
            "sample_id": 6741,
            "vt": "SELECT part.p_name FROM partsupp INNER JOIN part AS T2 ON T1.ps_partkey = T2.p_partkey INNER JOIN supplier AS T3 ON T1.ps_suppkey = T3.s_suppkey WHERE partsupp.ps_supplycost > [placeholder-type:numeric] AND supplier.s_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of parts from the 'part' table that are supplied by suppliers from the 'supplier' table. It filters the results based on a minimum supply cost and a specific supplier's name."
        },
        {
            "sample_id": 6720,
            "vt": "SELECT COUNT(partsupp.ps_partkey) FROM partsupp INNER JOIN lineitem AS T2 ON T1.ps_suppkey = T2.l_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey WHERE part.p_mfgr = '[placeholder-type:string]' AND part.p_retailprice < [placeholder-type:numeric] AND lineitem.l_shipmode = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of parts supplied by suppliers that meet specific criteria. It joins the 'partsupp', 'lineitem', and 'part' tables to filter based on the manufacturer name, retail price, and shipping mode."
        },
        {
            "sample_id": 6912,
            "vt": "SELECT SUM(lineitem.l_extendedprice * ([placeholder-type:numeric] - lineitem.l_discount) * ([placeholder-type:numeric] + lineitem.l_tax)) FROM orders INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE orders.o_custkey = [placeholder-type:numeric] AND orders.o_orderdate = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total revenue generated from line items associated with a specific order placed by a customer on a particular date. It sums up the extended price of each line item, adjusted for discount and tax, by joining the 'orders' and 'lineitem' tables based on the order key. The placeholders represent the customer key and the order date for filtering the results."
        },
        {
            "sample_id": 6796,
            "vt": "SELECT COUNT(lineitem.l_partkey) FROM orders INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE orders.o_orderdate = '[placeholder-type:string]' AND lineitem.l_shipdate = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of line items associated with orders that were placed on a specific order date and shipped on a specific ship date. It combines data from the 'orders' and 'lineitem' tables using the order key to link them together."
        },
        {
            "sample_id": 6783,
            "vt": "SELECT lineitem.l_extendedprice * ([placeholder-type:numeric] - lineitem.l_discount) * ([placeholder-type:numeric] + lineitem.l_tax) FROM lineitem WHERE lineitem.l_shipmode = '[placeholder-type:string]' AND lineitem.l_shipinstruct = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total charge for line items from the 'lineitem' table based on the extended price, discount, and tax. It filters the results by specific shipping mode and shipping instructions, allowing users to analyze charges for particular shipping conditions."
        },
        {
            "sample_id": 6883,
            "vt": "SELECT COUNT(region.r_regionkey) FROM region INNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey INNER JOIN supplier AS T3 ON T2.n_nationkey = T3.s_nationkey WHERE region.r_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of regions from the 'region' table that are associated with suppliers from the 'supplier' table through the 'nation' table. The placeholder in the WHERE clause represents the name of the region being queried."
        },
        {
            "sample_id": 6866,
            "vt": "SELECT COUNT(supplier.s_suppkey) FROM supplier WHERE supplier.s_acctbal < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of suppliers from the 'supplier' table whose account balance is less than a specified amount. The placeholder in the WHERE clause represents the account balance threshold."
        },
        {
            "sample_id": 6676,
            "vt": "SELECT MAX(orders.o_totalprice) FROM orders INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE customer.c_mktsegment = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum total price of orders from the 'orders' table, filtered by the marketing segment of customers from the 'customer' table. The placeholder in the WHERE clause represents the specific marketing segment being queried."
        },
        {
            "sample_id": 6769,
            "vt": "SELECT partsupp.ps_partkey FROM supplier INNER JOIN partsupp AS T2 ON T1.s_suppkey = T2.ps_suppkey WHERE supplier.s_name = '[placeholder-type:string]' ORDER BY partsupp.ps_supplycost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the part keys from the 'partsupp' table associated with a specific supplier. It joins the 'supplier' table with the 'partsupp' table on the supplier key, filtering results based on the supplier's name. The results are ordered by supply cost and limited to a specified number of entries."
        },
        {
            "sample_id": 6771,
            "vt": "SELECT (SELECT T3.p_name, T2.l_extendedprice * (1 - T2.l_discount) - T1.ps_supplycost * T2.l_quantity AS num FROM partsupp AS T1 INNER JOIN lineitem AS T2 ON T1.ps_suppkey = T2.l_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey).p_name FROM (SELECT part.p_name, lineitem.l_extendedprice * ([placeholder-type:numeric] - lineitem.l_discount) - partsupp.ps_supplycost * lineitem.l_quantity FROM partsupp AS T1 INNER JOIN lineitem AS T2 ON T1.ps_suppkey = T2.l_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey) AS t ORDER BY (SELECT T3.p_name, T2.l_extendedprice * (1 - T2.l_discount) - T1.ps_supplycost * T2.l_quantity AS num FROM partsupp AS T1 INNER JOIN lineitem AS T2 ON T1.ps_suppkey = T2.l_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the profit for each part by subtracting the supply cost from the discounted extended price of line items associated with that part. It retrieves the part names and orders the results based on the calculated profit, limiting the output to a specified number of results."
        },
        {
            "sample_id": 6853,
            "vt": "SELECT COUNT(region.r_name) FROM region INNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey WHERE nation.n_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of regions associated with a specific nation from the 'region' and 'nation' tables. The placeholder in the WHERE clause represents the name of the nation for which the region count is being queried."
        },
        {
            "sample_id": 6718,
            "vt": "SELECT part.p_name FROM partsupp INNER JOIN part AS T2 ON T1.ps_partkey = T2.p_partkey WHERE partsupp.ps_supplycost = [placeholder-type:numeric] AND part.p_mfgr = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of parts from the 'part' table that are supplied at a specific supply cost and manufactured by a specific manufacturer. The placeholders in the WHERE clause represent the supply cost and manufacturer's name."
        },
        {
            "sample_id": 6683,
            "vt": "SELECT COUNT(customer.c_custkey) FROM customer INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE nation.n_name = '[placeholder-type:string]' AND customer.c_acctbal > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of customers from the 'customer' table who belong to a specific nation and have a positive account balance. The placeholders represent the nation's name and the minimum account balance required."
        },
        {
            "sample_id": 6858,
            "vt": "SELECT part.p_comment FROM part WHERE part.p_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the comments associated with a specific part from the 'part' table. The placeholder in the WHERE clause represents the name of the part for which the comment is being queried."
        },
        {
            "sample_id": 6908,
            "vt": "SELECT part.p_name FROM part INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey WHERE partsupp.ps_supplycost > [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of parts from the 'part' table that have a supply cost greater than a specified amount. The query uses an inner join with the 'partsupp' table to filter parts based on their supply cost, represented by a numeric placeholder."
        },
        {
            "sample_id": 6724,
            "vt": "SELECT COUNT(lineitem.l_linenumber) FROM lineitem WHERE lineitem.l_shipdate = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of line items from the 'lineitem' table that were shipped on a specific date. The placeholder in the WHERE clause represents the shipping date for which the count is to be calculated."
        },
        {
            "sample_id": 6777,
            "vt": "SELECT COUNT(lineitem.l_partkey) FROM orders INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE lineitem.l_shipmode = '[placeholder-type:string]' AND orders.o_orderpriority = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of line items associated with orders that meet specific shipping mode and order priority criteria. It combines data from the 'orders' and 'lineitem' tables using the order key as a linking field. The placeholders represent the shipping mode and order priority that can be specified by the user."
        },
        {
            "sample_id": 6809,
            "vt": "SELECT part.p_name FROM part INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey WHERE partsupp.ps_availqty > [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of parts from the 'part' table that are available in sufficient quantity as indicated by the 'partsupp' table. The placeholders represent the minimum available quantity and the limit on the number of results returned."
        },
        {
            "sample_id": 6860,
            "vt": "SELECT COUNT(part.p_partkey) FROM part WHERE part.p_type = '[placeholder-type:string]' AND part.p_mfgr = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of parts from the 'part' table that match a specific type and manufacturer. The placeholders in the WHERE clause represent the part type and manufacturer name."
        },
        {
            "sample_id": 6737,
            "vt": "SELECT CAST(SUM(CASE WHEN nation.n_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(supplier.s_suppkey) FROM supplier INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE supplier.s_acctbal < [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average of a specific metric for suppliers from a particular nation, where the supplier's account balance is below a specified threshold. It uses a conditional sum based on the nation name and divides it by the count of suppliers to derive the average. The placeholders represent the nation name, a numeric value for the conditional sum, and the threshold for account balance."
        },
        {
            "sample_id": 6834,
            "vt": "SELECT nation.n_name FROM supplier INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey ORDER BY supplier.s_acctbal LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of nations from the 'nation' table that are associated with suppliers in the 'supplier' table. The query performs an inner join between the 'supplier' and 'nation' tables based on the nation key, ensuring that only suppliers with a corresponding nation are included. The results are ordered by the account balance of the suppliers, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 6863,
            "vt": "SELECT (SELECT p_name, p_size FROM part WHERE p_name IN ('pink powder drab lawn cyan', 'cornflower sky burlywood green beige')).p_name FROM (SELECT part.p_name, part.p_size FROM part WHERE p_name IN ('pink powder drab lawn cyan', 'cornflower sky burlywood green beige')) AS t ORDER BY part.p_size LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names and sizes of specific parts from the 'part' table, filtered by a list of part names. The results are ordered by the size of the parts, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 6882,
            "vt": "SELECT COUNT(nation.n_nationkey) FROM nation INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey INNER JOIN supplier AS T3 ON T1.n_nationkey = T3.s_nationkey WHERE region.r_name = '[placeholder-type:string]' AND supplier.s_acctbal < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of nations from the 'nation' table that are associated with a specific region and have suppliers with an account balance below a certain threshold. The placeholders represent the region's name and the account balance limit."
        },
        {
            "sample_id": 6731,
            "vt": "SELECT COUNT(customer.c_custkey) FROM customer INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE nation.n_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customer' table who belong to a specific nation. It joins the 'customer' table with the 'nation' table based on the nation key, filtering the results by the name of the nation provided as a placeholder."
        },
        {
            "sample_id": 6903,
            "vt": "SELECT SUM(orders.o_totalprice) FROM customer INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey INNER JOIN orders AS T3 ON T1.c_custkey = T3.o_custkey WHERE nation.n_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total price of orders made by customers from a specific nation. It joins the 'customer' table with the 'nation' table to filter customers based on their nation, and then it sums up the total prices from the 'orders' table for those customers. The placeholder in the WHERE clause represents the name of the nation."
        },
        {
            "sample_id": 6792,
            "vt": "SELECT part.p_name FROM part INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey WHERE partsupp.ps_availqty < [placeholder-type:numeric] ORDER BY partsupp.ps_supplycost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of parts from the 'part' table that are associated with suppliers whose available quantity is below a specified threshold. The results are ordered by the supply cost, and the number of results returned is limited by a placeholder for numeric values."
        },
        {
            "sample_id": 6843,
            "vt": "SELECT customer.c_name FROM customer WHERE customer.c_acctbal < [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of customers from the 'customer' table who have an account balance below a specified threshold. The placeholder in the WHERE clause represents the account balance limit."
        },
        {
            "sample_id": 6728,
            "vt": "SELECT CAST(SUM(CASE WHEN part.p_mfgr = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(part.p_partkey) FROM part",
            "ba": "The virtual table calculates the weighted average of a specific manufacturer's part prices from the 'part' table. It sums the prices of parts manufactured by a specified manufacturer, applies a multiplier, and divides by the count of parts to get the average. The placeholders represent the manufacturer's name and a numeric multiplier for the calculation."
        },
        {
            "sample_id": 6755,
            "vt": "SELECT COUNT(partsupp.ps_suppkey) FROM partsupp INNER JOIN lineitem AS T2 ON T1.ps_suppkey = T2.l_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey WHERE part.p_retailprice > [placeholder-type:numeric] AND lineitem.l_shipmode = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of suppliers from the 'partsupp' table who supply parts with a retail price greater than a specified amount and are associated with line items that have a specific shipping mode."
        },
        {
            "sample_id": 6752,
            "vt": "SELECT COUNT(supplier.s_suppkey) FROM supplier INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE nation.n_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of suppliers from the 'supplier' table who belong to a specific nation. It joins the 'supplier' table with the 'nation' table based on the nation key, and filters the results to include only those suppliers from the specified nation name."
        },
        {
            "sample_id": 6847,
            "vt": "SELECT orders.o_orderkey, lineitem.l_shipdate FROM orders INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey ORDER BY orders.o_totalprice LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of order keys along with their corresponding ship dates from the 'orders' and 'lineitem' tables. It joins these two tables based on the order key, ensuring that only line items associated with each order are included. The results are ordered by the total price of the orders, and a limit is applied to restrict the number of records returned."
        },
        {
            "sample_id": 6811,
            "vt": "SELECT nation.n_name FROM supplier INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE supplier.s_suppkey = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of nations from the 'nation' table that are associated with a specific supplier from the 'supplier' table. The placeholder in the WHERE clause represents the unique identifier of the supplier."
        },
        {
            "sample_id": 6753,
            "vt": "SELECT COUNT(nation.n_name) FROM nation INNER JOIN customer AS T2 ON T1.n_nationkey = T2.c_nationkey INNER JOIN region AS T3 ON T1.n_regionkey = T3.r_regionkey WHERE customer.c_acctbal < [placeholder-type:numeric] AND region.r_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of nations from the 'nation' table that are associated with customers having a negative account balance in the 'customer' table, filtered by a specific region name from the 'region' table. The placeholders represent the account balance threshold and the region name."
        },
        {
            "sample_id": 6787,
            "vt": "SELECT COUNT(nation.n_nationkey) FROM nation INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey INNER JOIN supplier AS T3 ON T1.n_nationkey = T3.s_nationkey WHERE region.r_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of nations from the 'nation' table that are associated with a specific region. It joins the 'nation' table with the 'region' table to filter by the region's name, and also joins with the 'supplier' table to ensure that the nations counted have suppliers linked to them. The placeholder in the WHERE clause represents the name of the region being queried."
        },
        {
            "sample_id": 6744,
            "vt": "SELECT COUNT(customer.c_custkey) FROM customer WHERE customer.c_mktsegment = '[placeholder-type:string]' AND customer.c_nationkey = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of customers from the 'customer' table who belong to a specific market segment and are from a particular nation. The placeholders represent the market segment as a string and the nation key as a numeric value."
        },
        {
            "sample_id": 6751,
            "vt": "SELECT nation.n_name FROM nation INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey WHERE region.r_comment = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of nations from the 'nation' table that are associated with a specific region. The query uses an INNER JOIN to connect the 'nation' table with the 'region' table based on the region key. The placeholder in the WHERE clause represents a comment related to the region."
        },
        {
            "sample_id": 6827,
            "vt": "SELECT SUM(orders.o_totalprice) FROM orders INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE customer.c_phone = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total price of all orders made by customers with a specific phone number. It joins the 'orders' table with the 'customer' table based on the customer key, allowing for the aggregation of order totals filtered by the customer's phone number."
        },
        {
            "sample_id": 6873,
            "vt": "SELECT supplier.s_phone FROM part INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN supplier AS T3 ON T2.ps_suppkey = T3.s_suppkey WHERE part.p_name = '[placeholder-type:string]' ORDER BY partsupp.ps_availqty LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the phone numbers of suppliers for a specific part name from the 'part' table. It joins the 'part' table with the 'partsupp' table to access supply information and then joins with the 'supplier' table to get the supplier's phone details. The query filters results based on the part name and orders them by the available quantity of the part supply, limiting the number of results returned."
        },
        {
            "sample_id": 6788,
            "vt": "SELECT (SELECT T2.c_mktsegment, COUNT(T1.o_orderkey) AS num FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE T1.o_orderdate LIKE '1994-04-%' GROUP BY T1.o_custkey).c_mktsegment FROM (SELECT customer.c_mktsegment, COUNT(orders.o_orderkey) FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE T1.o_orderdate LIKE '1994-04-%' GROUP BY T1.o_custkey) AS t ORDER BY (SELECT T2.c_mktsegment, COUNT(T1.o_orderkey) AS num FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE T1.o_orderdate LIKE '1994-04-%' GROUP BY T1.o_custkey).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the number of orders placed by customers in a specific market segment during April 1994. It retrieves the market segment from the 'customer' table and counts the number of orders from the 'orders' table, grouping the results by customer. The results are ordered by the count of orders, and a limit is applied to restrict the number of returned rows."
        },
        {
            "sample_id": 6775,
            "vt": "SELECT (CAST(SUM(CASE WHEN lineitem.l_shipmode = '[placeholder-type:string]' THEN part.p_retailprice ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN lineitem.l_shipmode = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END)) - (CAST(SUM(CASE WHEN lineitem.l_shipmode = '[placeholder-type:string]' THEN part.p_retailprice ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN lineitem.l_shipmode = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END)) FROM part INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN lineitem AS T3 ON T2.ps_suppkey = T3.l_suppkey",
            "ba": "The virtual table calculates a specific ratio related to the retail price of parts based on the shipping mode of line items. It sums the retail prices of parts for a given shipping mode and divides it by the total quantity of line items for that shipping mode. The result is then adjusted by subtracting the same ratio calculated for a different condition, allowing for a comparative analysis of the retail prices based on shipping modes."
        },
        {
            "sample_id": 6898,
            "vt": "SELECT COUNT(customer.c_custkey) FROM customer WHERE customer.c_mktsegment = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customer' table who belong to a specific market segment. The placeholder in the WHERE clause represents the market segment of interest."
        },
        {
            "sample_id": 6874,
            "vt": "SELECT supplier.s_phone FROM part INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN supplier AS T3 ON T2.ps_suppkey = T3.s_suppkey WHERE part.p_name = '[placeholder-type:string]' ORDER BY part.p_size LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the phone numbers of suppliers for a specific part name from the 'part' table. It joins the 'part' table with the 'partsupp' table to link parts with their suppliers, and then joins with the 'supplier' table to access supplier details. The query filters results based on the part name and orders them by the size of the part, limiting the number of results returned."
        },
        {
            "sample_id": 6839,
            "vt": "SELECT COUNT(lineitem.l_orderkey) FROM lineitem WHERE lineitem.l_discount = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of line items from the 'lineitem' table that have a specific discount value. The placeholder in the WHERE clause represents the discount percentage being queried."
        },
        {
            "sample_id": 6817,
            "vt": "SELECT JULIANDAY(lineitem.l_receiptdate) - JULIANDAY(lineitem.l_commitdate), orders.o_clerk FROM orders INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE orders.o_orderkey = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the delivery time in days for a specific order by subtracting the commit date from the receipt date, and it also retrieves the clerk associated with that order. The query joins the 'orders' table with the 'lineitem' table based on the order key, allowing access to both the order details and the corresponding line item information."
        },
        {
            "sample_id": 6845,
            "vt": "SELECT customer.c_phone FROM orders INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE orders.o_orderpriority = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the phone numbers of customers from the 'customer' table who have placed orders with a specific order priority. The query uses an INNER JOIN to connect the 'orders' table with the 'customer' table based on the customer key, ensuring that only customers associated with the specified order priority are selected."
        },
        {
            "sample_id": 6868,
            "vt": "SELECT supplier.s_phone FROM supplier INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE nation.n_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the phone numbers of suppliers from the 'supplier' table who belong to a specific nation. The query joins the 'supplier' table with the 'nation' table based on the nation key, and filters the results based on the specified nation name."
        },
        {
            "sample_id": 6879,
            "vt": "SELECT COUNT(part.p_partkey) FROM part INNER JOIN lineitem AS T2 ON T1.p_partkey = T2.l_partkey WHERE part.p_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of parts from the 'part' table that are associated with line items in the 'lineitem' table, filtered by a specific part name. The placeholder in the WHERE clause represents the name of the part being queried."
        },
        {
            "sample_id": 6754,
            "vt": "SELECT customer.c_phone FROM orders INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey ORDER BY orders.o_totalprice LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the phone numbers of customers who have placed orders, sorted by the total price of those orders. The query uses an inner join between the 'orders' and 'customer' tables to link each order to its corresponding customer based on the customer key. The results are limited to a specified number of entries, indicated by a numeric placeholder."
        },
        {
            "sample_id": 6733,
            "vt": "SELECT nation.n_name, nation.n_nationkey FROM nation INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey WHERE region.r_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and unique identifiers of nations from the 'nation' table that are associated with a specific region. The placeholder in the WHERE clause represents the name of the region."
        },
        {
            "sample_id": 6709,
            "vt": "SELECT lineitem.l_orderkey FROM lineitem ORDER BY lineitem.l_extendedprice LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the order keys from the 'lineitem' table, sorted by the extended price of each line item. The result is limited to a specified number of entries, allowing users to focus on the highest priced line items."
        },
        {
            "sample_id": 6772,
            "vt": "SELECT nation.n_name FROM customer INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey GROUP BY nation.n_name HAVING COUNT(customer.c_name) > (SELECT COUNT(customer.c_name) / COUNT(DISTINCT nation.n_name) FROM customer INNER JOIN nation ON customer.c_nationkey = nation.n_nationkey) ORDER BY COUNT(customer.c_name)",
            "ba": "The virtual table lists the names of nations from the 'nation' table that have a higher number of customers than the average number of customers per nation. It achieves this by joining the 'customer' and 'nation' tables on the nation key, grouping the results by nation name, and applying a condition to filter those nations with a customer count exceeding the average. The results are then ordered by the count of customers in ascending order."
        },
        {
            "sample_id": 6692,
            "vt": "SELECT nation.n_name FROM customer INNER JOIN nation AS T2 ON T1.c_name = 'Customer#000000055'",
            "ba": "The virtual table describes the name of the nation associated with a specific customer from the 'customer' table. It uses an inner join with the 'nation' table to link the customer to their corresponding nation based on the customer's name. The placeholder in the WHERE clause represents the specific customer's name."
        },
        {
            "sample_id": 6729,
            "vt": "SELECT part.p_name FROM part WHERE part.p_type = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of parts from the 'part' table that belong to a specific type of part. The placeholder in the WHERE clause represents the type of part, and the LIMIT clause restricts the number of results returned based on a numeric value."
        },
        {
            "sample_id": 6725,
            "vt": "SELECT orders.o_orderdate FROM orders WHERE orders.o_totalprice = (SELECT MAX(orders.o_totalprice) FROM orders)",
            "ba": "The virtual table retrieves the order date from the 'orders' table for the order with the highest total price. The query uses a subquery to find the maximum total price among all orders, ensuring that only the date of the most expensive order is selected."
        }
    ],
    "professional_basketball": [
        {
            "sample_id": 2804,
            "vt": "SELECT DISTINCT coaches.coachid, teams.tmid, coaches.year FROM coaches INNER JOIN teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE coaches.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND teams.lost > teams.won",
            "ba": "The virtual table retrieves distinct coach IDs, team IDs, and the year from the 'coaches' and 'teams' tables. It filters the results to include only those coaches who have coached teams that lost more games than they won during a specified range of years."
        },
        {
            "sample_id": 2897,
            "vt": "SELECT DISTINCT coaches.year, teams.name, coaches.coachid FROM coaches INNER JOIN teams AS T2 ON T1.tmID = T2.tmID WHERE CAST(coaches.won AS FLOAT) / CAST((coaches.won + coaches.lost) AS FLOAT) > [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of years, team names, and coach IDs from the 'coaches' and 'teams' tables. It filters the results to include only those coaches whose winning percentage exceeds a specified threshold. The winning percentage is calculated by dividing the number of games won by the total number of games played (won + lost)."
        },
        {
            "sample_id": 2833,
            "vt": "SELECT AVG(players.height) FROM players INNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID WHERE awards_players.award = '[placeholder-type:string]' AND players.birthcity = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average height of players from the 'players' table who have received a specific award and were born in a specified city. The placeholders in the WHERE clause represent the award name and the birth city of the players."
        },
        {
            "sample_id": 2928,
            "vt": "SELECT COUNT(player_allstar.playerid) FROM player_allstar INNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID WHERE player_allstar.first_name = '[placeholder-type:string]' AND player_allstar.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of All-Star appearances for a specific player identified by their first and last name. It joins the 'player_allstar' table with the 'awards_players' table to ensure that the player exists in both datasets, using placeholders for the player's first and last names."
        },
        {
            "sample_id": 2882,
            "vt": "SELECT COUNT(DISTINCT T1.playerID) FROM players INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID INNER JOIN teams AS T3 ON T3.tmID = T2.tmID WHERE CAST(teams.lost AS FLOAT) * [placeholder-type:numeric] / (teams.lost + teams.won) < [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of players who have participated in teams that have a specific win-loss ratio. It joins the 'players' table with the 'players_teams' table to link players to their respective teams, and then further joins with the 'teams' table to access the win and loss records of those teams. The condition filters teams based on their performance, specifically looking for teams where the ratio of losses to total games played is less than a specified threshold."
        },
        {
            "sample_id": 2893,
            "vt": "SELECT players.college FROM players WHERE awards_players.playerid = (SELECT awards_players.playerid FROM awards_players WHERE year = 1970 GROUP BY playerID ORDER BY COUNT(award) DESC LIMIT 1)",
            "ba": "The virtual table retrieves the college of the player who received the most awards in the year 1970 from the 'awards_players' table. It uses a subquery to identify the player ID of the award-winning player by counting the number of awards they received, grouping by player ID, and ordering the results to find the top player."
        },
        {
            "sample_id": 2860,
            "vt": "SELECT MIN(CAST(players.weight AS FLOAT) / (players.height * players.height)), MAX(CAST(players.weight AS FLOAT) / (players.height * players.height)) FROM players",
            "ba": "The virtual table calculates the minimum and maximum Body Mass Index (BMI) of players by using their weight and height from the 'players' table. The BMI is computed by dividing the weight (converted to float) by the square of the height. This provides insights into the weight status of players based on their height."
        },
        {
            "sample_id": 2838,
            "vt": "SELECT COUNT(DISTINCT T4.name) FROM (SELECT teams.name, SUM(players_teams.points) FROM teams AS T1 INNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year INNER JOIN awards_players AS T3 ON T2.playerID = T3.playerID WHERE T3.award = 'Most Valuable Player' GROUP BY T1.name HAVING SUM(T2.points) >= 3800) AS t4",
            "ba": "The virtual table counts the distinct names of teams that have players who received the 'Most Valuable Player' award and whose total points scored by those players in a season is 3800 or more. It involves joining the 'teams', 'players_teams', and 'awards_players' tables to filter and aggregate the relevant data."
        },
        {
            "sample_id": 2854,
            "vt": "SELECT DISTINCT teams.name FROM teams INNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE teams.rank = [placeholder-type:numeric] AND teams.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] ORDER BY players_teams.points LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct names of teams from the 'teams' table that meet specific criteria. It filters teams based on their rank and the year range, ensuring that only teams within the specified rank and year are included. Additionally, it joins with the 'players_teams' table to consider the performance of players in those teams, specifically focusing on the points scored. The results are ordered by the points scored by players and limited to a specified number of entries."
        },
        {
            "sample_id": 2806,
            "vt": "SELECT DISTINCT teams.name, coaches.year, coaches.coachid FROM coaches INNER JOIN teams AS T2 ON T1.tmID = T2.tmID WHERE CAST(teams.won AS FLOAT) * [placeholder-type:numeric] / teams.games > [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of distinct team names, the years in which their coaches were active, and the unique identifiers for those coaches. It filters the results based on a condition that compares the ratio of wins to total games played by the teams, allowing users to specify a minimum threshold for this ratio using numeric placeholders."
        },
        {
            "sample_id": 2803,
            "vt": "SELECT coaches.coachid, teams.name, teams.won FROM coaches INNER JOIN teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE coaches.year = [placeholder-type:numeric] AND teams.won > [placeholder-type:numeric]",
            "ba": "The virtual table provides information about coaches and their respective teams, specifically focusing on the coach's ID, the team's name, and the total number of games won by the team. The query filters results based on a specific year for the coaches and only includes teams that have won more than a specified number of games."
        },
        {
            "sample_id": 2822,
            "vt": "SELECT coaches.coachid FROM coaches ORDER BY coaches.post_wins LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique identifiers of coaches from the 'coaches' table, sorted by the number of post-season wins. The placeholder in the LIMIT clause allows the user to specify how many coach IDs they want to retrieve."
        },
        {
            "sample_id": 2835,
            "vt": "SELECT teams.name FROM teams WHERE CAST(teams.won AS FLOAT) * [placeholder-type:numeric] / (teams.won + teams.lost) < [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of teams from the 'teams' table that have a winning percentage lower than a specified threshold. The winning percentage is calculated by dividing the number of wins by the total number of games played (wins plus losses), and the placeholder represents the threshold for comparison."
        },
        {
            "sample_id": 2808,
            "vt": "SELECT DISTINCT teams.divid FROM awards_coaches INNER JOIN coaches AS T2 ON T1.coachID = T2.coachID INNER JOIN teams AS T3 ON T2.tmID = T3.tmID WHERE awards_coaches.year = [placeholder-type:numeric] AND awards_coaches.award = '[placeholder-type:string]' AND teams.year = [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of division IDs from the 'teams' table for coaches who received a specific award in a given year. It joins the 'awards_coaches' table with the 'coaches' table to link coaches to their respective teams, and filters the results based on the award year and the award name."
        },
        {
            "sample_id": 2847,
            "vt": "SELECT MAX(players.weight) FROM players INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE players.birthcountry = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum weight of players from the 'players' table who have participated in the All-Star games, filtered by their country of birth. The placeholder in the WHERE clause represents the specific country of birth being queried."
        },
        {
            "sample_id": 2861,
            "vt": "SELECT teams.name FROM teams ORDER BY CAST(teams.homewon AS FLOAT) / (teams.homewon + teams.homelost) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of teams from the 'teams' table, ordered by their home win percentage. The home win percentage is calculated by dividing the number of home wins by the total number of home games played (home wins plus home losses). The result is limited to a specified number of teams using a numeric placeholder."
        },
        {
            "sample_id": 2944,
            "vt": "SELECT teams.tmid FROM teams INNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year INNER JOIN players AS T3 ON T2.playerID = T3.playerID WHERE players.pos = '[placeholder-type:string]' AND players_teams.lgid = '[placeholder-type:string]' ORDER BY players.birthdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the team IDs from the 'teams' table that have players in a specific position and league. It joins the 'teams' table with the 'players_teams' table to filter by year and then further joins with the 'players' table to filter by player position. The results are ordered by the players' birthdates and limited to a specified number of entries."
        },
        {
            "sample_id": 2930,
            "vt": "SELECT COUNT(awards_coaches.id) FROM awards_coaches INNER JOIN teams AS T2 ON T1.year = T2.year WHERE awards_coaches.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND awards_coaches.award = '[placeholder-type:string]' AND teams.tmid = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of awards received by coaches from the 'awards_coaches' table, filtered by a specific year range and award type, and linked to the 'teams' table to ensure the awards correspond to a particular team."
        },
        {
            "sample_id": 2926,
            "vt": "SELECT series_post.w FROM teams INNER JOIN series_post AS T2 ON T1.tmID = T2.tmIDLoser AND T1.year = T2.year WHERE series_post.year = [placeholder-type:numeric] ORDER BY teams.o_fgm LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the number of wins for teams that lost in a specific series during a given year. It joins the 'teams' table with the 'series_post' table to filter the results based on the team ID and year, ensuring that only relevant data is selected. The results are ordered by the number of offensive field goals made by the teams, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 2877,
            "vt": "SELECT COUNT(DISTINCT playerID) FROM awards_players WHERE awards_players.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND awards_players.award = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of players who received a specific award within a given range of years from the 'awards_players' table. The placeholders represent the year range and the award name."
        },
        {
            "sample_id": 2866,
            "vt": "SELECT AVG(CAST(players.weight AS FLOAT) / (players.height * players.height)) FROM players INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID",
            "ba": "The virtual table calculates the average body mass index (BMI) of players by joining the 'players' table with the 'player_allstar' table. It uses the weight and height of each player to compute the BMI, where weight is divided by the square of height. The result provides insights into the average physical condition of players who have participated in all-star games."
        },
        {
            "sample_id": 2848,
            "vt": "SELECT SUM(player_allstar.points) FROM players INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE player_allstar.season_id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND players.deathdate = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total points scored by players in All-Star games over a specified range of seasons, while also filtering out players who are deceased. The query joins the 'players' table with the 'player_allstar' table to access player details and their All-Star game performance."
        },
        {
            "sample_id": 2871,
            "vt": "SELECT teams.name FROM teams INNER JOIN coaches AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year INNER JOIN awards_coaches AS T3 ON T2.coachID = T3.coachID AND T2.year = T3.year WHERE awards_coaches.year = [placeholder-type:numeric] AND awards_coaches.award = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of teams that had coaches who received a specific award in a particular year. The query joins the 'teams', 'coaches', and 'awards_coaches' tables to filter the results based on the award year and the award name, using placeholders for the year and award name."
        },
        {
            "sample_id": 2892,
            "vt": "SELECT DISTINCT players.firstname, players.middlename, players.lastname FROM series_post INNER JOIN players_teams AS T2 ON T1.tmIDWinner = T2.tmID INNER JOIN players AS T3 ON T3.playerID = T2.playerID WHERE series_post.year = [placeholder-type:numeric] AND series_post.round = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of distinct first, middle, and last names of players who were part of the winning teams in a specific series round during a given year. The placeholders allow users to specify the year and the round of the series they are interested in."
        },
        {
            "sample_id": 2927,
            "vt": "SELECT AVG(players_teams.turnovers) FROM players INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE players_teams.year = [placeholder-type:numeric] GROUP BY players.playerid, players_teams.assists ORDER BY players_teams.assists LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of turnovers made by players in a specific year. It joins the 'players' table with the 'players_teams' table to access player information and their performance metrics. The results are grouped by each player's ID and their assists, allowing for an analysis of turnovers in relation to assists. The output is ordered by the number of assists, and a limit can be set on the number of results returned."
        },
        {
            "sample_id": 2909,
            "vt": "SELECT COUNT(awards_players.award) FROM awards_players INNER JOIN players AS T2 ON T1.playerID = T2.playerID WHERE awards_players.year = [placeholder-type:numeric] AND players.hscity = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of awards received by players in a specific year, filtered by the city of their high school. It joins the 'awards_players' table with the 'players' table to access player information based on their unique ID."
        },
        {
            "sample_id": 2824,
            "vt": "SELECT COUNT(DISTINCT T1.playerID) FROM players INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE players_teams.lgid = '[placeholder-type:string]' AND (players.pos = '[placeholder-type:string]' OR players.pos = '[placeholder-type:string]')",
            "ba": "The virtual table counts the distinct number of players from the 'players' table who are associated with a specific league and play in one of two specified positions. The placeholders in the WHERE clause represent the league identifier and the two possible player positions."
        },
        {
            "sample_id": 2914,
            "vt": "SELECT DISTINCT players_teams.playerid FROM player_allstar INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE players_teams.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND player_allstar.three_made / player_allstar.three_attempted > [placeholder-type:numeric]",
            "ba": "The virtual table identifies unique players who have participated in All-Star games and also played for teams during a specified range of years. It filters players based on their performance in three-point shooting, specifically those who have made a certain percentage of their three-point attempts. The placeholders represent the year range and the minimum shooting percentage required."
        },
        {
            "sample_id": 2801,
            "vt": "SELECT coaches.coachid, coaches.won, coaches.lost FROM coaches WHERE coaches.year = [placeholder-type:numeric] AND coaches.tmid = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about coaches, specifically their unique ID, the number of games they won, and the number of games they lost. The data is filtered based on a specific year and team, represented by placeholders for numeric and string values respectively."
        },
        {
            "sample_id": 2797,
            "vt": "SELECT teams.name FROM teams WHERE CAST(teams.lost AS FLOAT) * [placeholder-type:numeric] / teams.games > [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of teams from the 'teams' table that have a loss ratio exceeding a specified threshold. The loss ratio is calculated by dividing the number of losses by the total number of games played, and this ratio is then compared to a placeholder for a numeric value."
        },
        {
            "sample_id": 2862,
            "vt": "SELECT draft.draftyear - STRFTIME('%Y', players.birthdate) FROM draft INNER JOIN players AS T2 ON T1.playerID = T2.playerID WHERE draft.firstname = '[placeholder-type:string]' AND draft.lastname = '[placeholder-type:string]' AND draft.draftround = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the age of players at the time of their draft by subtracting their birth year from the draft year. It retrieves this information from the 'draft' table and joins it with the 'players' table to access the player's birthdate. The query filters results based on the player's first name, last name, and the round in which they were drafted, using placeholders for these values."
        },
        {
            "sample_id": 2916,
            "vt": "SELECT COUNT(DISTINCT T2.coachID) FROM coaches INNER JOIN awards_coaches AS T2 ON T1.coachID = T2.coachID WHERE coaches.tmid = '[placeholder-type:string]' AND awards_coaches.award = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of coaches who have received a specific award while coaching a particular team. It joins the 'coaches' table with the 'awards_coaches' table based on the coach's ID, filtering results by the team ID and the award name provided as placeholders."
        },
        {
            "sample_id": 2906,
            "vt": "SELECT COUNT(DISTINCT T2.year) FROM players INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE players_teams.tmid = '[placeholder-type:string]' AND players_teams.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND players.playerid = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct years a player has participated in games for a specific team within a given range of years. It joins the 'players' table with the 'players_teams' table to filter the records based on the player's ID and the team's ID, while also ensuring that the years fall within the specified range."
        },
        {
            "sample_id": 2823,
            "vt": "SELECT coaches.coachid FROM coaches WHERE coaches.lgid = '[placeholder-type:string]' AND coaches.post_wins <> [placeholder-type:numeric] AND coaches.post_losses <> [placeholder-type:numeric] AND coaches.coachid IN (SELECT coaches.coachid FROM coaches WHERE lgID = 'NBA' GROUP BY coachID HAVING COUNT(tmID) > 2) ORDER BY coaches.post_losses LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the IDs of coaches from the 'coaches' table who belong to a specific league and have non-zero post-season wins and losses. Additionally, it filters for coaches who have coached more than two teams in the NBA, ensuring that only experienced coaches are considered. The results are ordered by the number of post-season losses, and a limit is applied to the number of records returned."
        },
        {
            "sample_id": 2829,
            "vt": "SELECT players.birthdate FROM players INNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID WHERE awards_players.award = '[placeholder-type:string]' GROUP BY players.playerid, players.birthdate ORDER BY COUNT(awards_players.award) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the birthdates of players from the 'players' table who have received a specific award. It joins the 'awards_players' table to filter players based on the award they have won. The results are grouped by player ID and birthdate, and ordered by the count of awards received, limiting the output to a specified number of records."
        },
        {
            "sample_id": 2929,
            "vt": "SELECT (CAST(SUM(CASE WHEN teams.year = [placeholder-type:numeric] THEN teams.won ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN teams.year = [placeholder-type:numeric] THEN teams.won + teams.lost ELSE [placeholder-type:numeric] END)) - (CAST(SUM(CASE WHEN teams.year = [placeholder-type:numeric] THEN teams.won ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN teams.year = [placeholder-type:numeric] THEN teams.won + teams.lost ELSE [placeholder-type:numeric] END)) FROM teams INNER JOIN draft AS T2 ON T1.tmID = T2.tmID WHERE draft.draftround = [placeholder-type:numeric] AND draft.draftyear = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the performance ratio of teams based on their wins and losses for a specific year and draft round. It uses the 'teams' table to sum the wins and losses, and the 'draft' table to filter by draft round and year. The placeholders represent the year and draft round for which the performance ratio is being calculated."
        },
        {
            "sample_id": 2812,
            "vt": "SELECT players.birthdate FROM players INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE player_allstar.season_id = [placeholder-type:numeric] ORDER BY player_allstar.assists LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the birthdates of players who participated in the All-Star games during a specific season. It joins the 'players' table with the 'player_allstar' table to filter players based on their participation in a given season, represented by a numeric placeholder. The results are ordered by the number of assists recorded in the All-Star games, and the output is limited to a specified number of records."
        },
        {
            "sample_id": 2936,
            "vt": "SELECT teams.tmid FROM players_teams INNER JOIN teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE players_teams.postgp = [placeholder-type:numeric] ORDER BY teams.won LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the team IDs from the 'teams' table for players who have participated in a specified number of post-season games. The query joins the 'players_teams' table with the 'teams' table based on matching team IDs and years, filtering for players with a specific post-season game attendance. The results are ordered by the total wins of the teams, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 2817,
            "vt": "SELECT SUM(player_allstar.minutes) FROM players INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE players.birthcity = '[placeholder-type:string]' AND players.namenick LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total minutes played by players in all-star games, filtered by their birth city and nickname. It joins the 'players' table with the 'player_allstar' table to aggregate the minutes for players who meet the specified criteria."
        },
        {
            "sample_id": 2858,
            "vt": "SELECT COUNT(DISTINCT playerID) FROM draft WHERE draft.firstname = '[placeholder-type:string]' AND draft.draftyear = [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of players from the 'draft' table based on their first name and the year of the draft. The placeholders represent the player's first name and the specific draft year."
        },
        {
            "sample_id": 2931,
            "vt": "SELECT CAST(SUM(CASE WHEN NOT players_teams.steals IS NULL AND teams.tmid = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(teams.tmid) FROM teams INNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year",
            "ba": "The virtual table calculates the average number of steals made by players from a specific team during a given year. It sums the steals for players associated with that team and divides it by the total number of games played by the team in that year, adjusting the result by a specified multiplier."
        },
        {
            "sample_id": 2874,
            "vt": "SELECT COUNT(DISTINCT T2.playerID) FROM awards_players INNER JOIN players AS T2 ON T1.playerID = T2.playerID WHERE awards_players.award = '[placeholder-type:string]' AND players.birthcountry = '[placeholder-type:string]' AND awards_players.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of players who have received a specific award in a given range of years and are from a specified country. It combines data from the 'awards_players' table, which contains information about awards received by players, and the 'players' table, which includes details about the players' birth countries."
        },
        {
            "sample_id": 2899,
            "vt": "SELECT COUNT(players_teams.playerid) FROM players_teams WHERE CAST(players_teams.orebounds AS FLOAT) * [placeholder-type:numeric] / players_teams.drebounds <= [placeholder-type:numeric] AND players_teams.year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of players from the 'players_teams' table who have a specific ratio of offensive rebounds to defensive rebounds for a given year. The placeholders represent numeric values that can be modified to filter the results based on the desired criteria."
        },
        {
            "sample_id": 2807,
            "vt": "SELECT COUNT(DISTINCT T1.playerID) FROM players INNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID WHERE players.birthstate = '[placeholder-type:string]' AND awards_players.award = '[placeholder-type:string]' AND awards_players.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of distinct players who have received a specific award in a given year range, filtered by their birth state. It combines data from the 'players' table and the 'awards_players' table to achieve this."
        },
        {
            "sample_id": 2890,
            "vt": "SELECT DISTINCT teams.name, series_post.year FROM teams JOIN series_post AS T2 ON T1.tmID = T2.tmIDWinner WHERE series_post.round = '[placeholder-type:string]' AND series_post.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of distinct team names and the years they won in a specific playoff round. It joins the 'teams' table with the 'series_post' table to filter for teams that won in a specified round during a range of years. The placeholders allow users to specify the playoff round and the year range they are interested in."
        },
        {
            "sample_id": 2820,
            "vt": "SELECT players_teams.lgid FROM players INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID GROUP BY players_teams.lgid, players.weight HAVING players.weight = MAX(players.weight) - MAX(players.weight) * [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the league IDs of players who are part of teams, specifically focusing on players with a weight that is a certain percentage less than the maximum weight recorded for players in the database. The query uses an inner join to connect the 'players' and 'players_teams' tables, grouping the results by league ID and player weight, and applying a condition to filter based on the calculated weight."
        },
        {
            "sample_id": 2814,
            "vt": "SELECT COUNT(DISTINCT T1.playerID) FROM players INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE player_allstar.conference = '[placeholder-type:string]' AND player_allstar.minutes <= [placeholder-type:numeric] AND players.college = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of players who have participated in the All-Star games from a specific conference, played a limited number of minutes, and graduated from a specified college. The placeholders represent the conference name, maximum minutes played, and college name respectively."
        },
        {
            "sample_id": 2886,
            "vt": "SELECT DISTINCT coaches.tmid FROM coaches INNER JOIN awards_coaches AS T2 ON T1.coachID = T2.coachID WHERE awards_coaches.year = [placeholder-type:numeric] AND awards_coaches.award = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct team IDs from the 'coaches' table that have received a specific award in a given year. The query joins the 'coaches' table with the 'awards_coaches' table to filter the results based on the year and the award name provided by the user."
        },
        {
            "sample_id": 2853,
            "vt": "SELECT players.lastname, players.firstname FROM players_teams INNER JOIN players AS T5 ON T4.playerID = T5.playerID WHERE players_teams.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND players_teams.tmid IN (SELECT DISTINCT teams.tmid FROM teams AS T1 INNER JOIN teams AS T2 INNER JOIN teams AS T3 ON T1.tmID = T2.tmID AND T2.tmID = T3.tmID AND T3.year - T2.year = 1 AND T2.year - T1.year = 1 WHERE T1.rank = 1 AND T1.year BETWEEN 1937 AND 1940)",
            "ba": "The virtual table describes the last and first names of players who were part of teams that ranked first in consecutive years between 1937 and 1940. The query filters players based on their participation in those teams during a specified range of years, using placeholders for the numeric year values."
        },
        {
            "sample_id": 2901,
            "vt": "SELECT draft.playerid FROM draft INNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID WHERE awards_players.award = '[placeholder-type:string]' AND draft.draftyear = [placeholder-type:numeric] AND draft.draftround = [placeholder-type:numeric]",
            "ba": "The virtual table identifies players who were drafted in a specific year and round, and who have received a particular award. It combines data from the 'draft' table and the 'awards_players' table, filtering based on the award name, draft year, and draft round."
        },
        {
            "sample_id": 2818,
            "vt": "SELECT teams.tmid FROM awards_coaches INNER JOIN coaches AS T2 ON T1.coachID = T2.coachID INNER JOIN teams AS T3 ON T3.tmID = T2.tmID WHERE awards_coaches.year = [placeholder-type:numeric] AND awards_coaches.award = '[placeholder-type:string]' GROUP BY teams.tmid ORDER BY SUM(teams.homelost) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the team IDs of coaches who received a specific award in a given year. It joins the 'awards_coaches' table with the 'coaches' table to link coaches to their respective teams, and then filters based on the award year and award name. The results are grouped by team ID and ordered by the total number of home losses, with a limit on the number of results returned."
        },
        {
            "sample_id": 2935,
            "vt": "SELECT teams.tmid FROM players_teams INNER JOIN teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE players_teams.year = [placeholder-type:numeric] AND players_teams.postgp = [placeholder-type:numeric] ORDER BY players_teams.points LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the team IDs of teams that players participated in during a specific year, filtered by the number of postseason games played by those players. The results are ordered by the points scored by the players, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 2912,
            "vt": "SELECT players.college FROM players INNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID WHERE awards_players.year = [placeholder-type:numeric] AND awards_players.award = '[placeholder-type:string]'",
            "ba": "The virtual table lists the colleges of players who received a specific award in a particular year. It combines data from the 'players' table and the 'awards_players' table, filtering based on the year and award name provided by the user."
        },
        {
            "sample_id": 2813,
            "vt": "SELECT DISTINCT players.firstname, players.middlename, players.lastname FROM players INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE players.birthcity = '[placeholder-type:string]' AND player_allstar.season_id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND player_allstar.minutes = [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct first, middle, and last names of players from the 'players' table who were born in a specific city, participated in All-Star games during a specified range of seasons, and played a certain number of minutes in those games. The placeholders represent the birth city, the range of season IDs, and the minutes played."
        },
        {
            "sample_id": 2857,
            "vt": "SELECT players.firstname, players.lastname FROM players WHERE players.race = '[placeholder-type:string]' AND players.height > [placeholder-type:numeric] ORDER BY players.height LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of players from the 'players' table who belong to a specific race and have a height greater than a specified value. The placeholders in the WHERE clause represent the race and height criteria, while the LIMIT clause restricts the number of results returned."
        },
        {
            "sample_id": 2918,
            "vt": "SELECT players.firstname, players.middlename, players.lastname FROM players INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE players.college = '[placeholder-type:string]' AND player_allstar.o_rebounds > player_allstar.d_rebounds",
            "ba": "The virtual table describes the first, middle, and last names of players from the 'players' table who attended a specific college and have more offensive rebounds than defensive rebounds in the 'player_allstar' table. The placeholder in the WHERE clause represents the college's name."
        },
        {
            "sample_id": 2920,
            "vt": "SELECT teams.name FROM teams INNER JOIN series_post AS T2 ON T1.tmID = T2.tmIDLoser AND T1.year = T2.year WHERE teams.rank < [placeholder-type:numeric] AND series_post.lgidloser > [placeholder-type:numeric] AND series_post.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of teams that have lost in a specific series of the playoffs. It filters teams based on their rank, the league they belong to, and the years of interest. The placeholders represent the maximum rank a team can have, the league ID of the losing team, and the range of years for which the data is relevant."
        },
        {
            "sample_id": 2941,
            "vt": "SELECT players.highschool FROM player_allstar INNER JOIN players AS T2 ON T1.playerID = T2.playerID ORDER BY player_allstar.rebounds LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the high school names of players who have participated in the All-Star games. It joins the 'player_allstar' table with the 'players' table to access player details, specifically focusing on their high school information. The results are ordered by the total rebounds recorded by the players in the All-Star games, and a limit is applied to restrict the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 2947,
            "vt": "SELECT players.firstname, players.middlename, players.lastname FROM players INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE players_teams.gp = [placeholder-type:numeric] AND players_teams.year = [placeholder-type:numeric] ORDER BY players_teams.turnovers LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first, middle, and last names of players from the 'players' table who have participated in a specific number of games during a given year. The results are ordered by the number of turnovers made by the players, and the output is limited to a specified number of records."
        },
        {
            "sample_id": 2923,
            "vt": "SELECT players_teams.playerid FROM players_teams WHERE players_teams.year = [placeholder-type:numeric] ORDER BY players_teams.gp LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique player IDs from the 'players_teams' table for a specific year. The results are ordered by the number of game presentations (gp) to prioritize players with more attendance, and the output is limited to a specified number of records."
        },
        {
            "sample_id": 2837,
            "vt": "SELECT coaches.coachid FROM coaches WHERE coaches.lgid = '[placeholder-type:string]' GROUP BY coaches.coachid HAVING MAX(coaches.year) - MIN(coaches.year) > [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique coach IDs from the 'coaches' table who have coached in a specific league. It filters the results to include only those coaches whose coaching tenure spans more than a specified number of years. The placeholders represent the league identifier and the minimum number of years of coaching experience required."
        },
        {
            "sample_id": 2878,
            "vt": "SELECT DISTINCT teams.name FROM teams WHERE teams.tmid IN (SELECT teams.tmid FROM players_teams AS T1 INNER JOIN players AS T2 ON T1.playerID = T2.playerID WHERE NOT T2.birthState IS NULL GROUP BY T1.tmID, T2.birthState HAVING COUNT(*) > 5)",
            "ba": "The virtual table lists the distinct names of teams from the 'teams' table that have more than five players whose birth state is recorded. It uses a subquery to identify the teams based on the player data, specifically filtering for players with a non-null birth state and grouping them by team and birth state."
        },
        {
            "sample_id": 2921,
            "vt": "SELECT players_teams.tmid FROM players_teams WHERE players_teams.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] ORDER BY CAST(players_teams.points AS FLOAT) / players_teams.minutes LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the team IDs from the 'players_teams' table for a specified range of years. The results are ordered by the points scored per minute played by the players on each team, allowing for an analysis of team performance over time. The placeholders represent the year range and the limit on the number of results returned."
        },
        {
            "sample_id": 2843,
            "vt": "SELECT COUNT(DISTINCT coachID) FROM awards_coaches WHERE awards_coaches.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND awards_coaches.award = '[placeholder-type:string]' AND awards_coaches.coachid IN (SELECT awards_coaches.coachid FROM awards_coaches WHERE year BETWEEN 1962 AND 2011 AND award = 'NBA Coach of the Year')",
            "ba": "The virtual table counts the distinct number of coaches who received a specific award within a given range of years. It filters the results to include only those coaches who have also been recognized as 'NBA Coach of the Year' between the years 1962 and 2011."
        },
        {
            "sample_id": 2867,
            "vt": "SELECT teams.name FROM teams INNER JOIN (SELECT * FROM teams WHERE lgID = 'ABA' AND year = 1972) AS T2 ON T1.tmID = T2.tmID WHERE teams.lgid = '[placeholder-type:string]' AND teams.year = [placeholder-type:numeric] ORDER BY (CAST(teams.won AS FLOAT) / (teams.won + teams.lost) - (CAST((SELECT * FROM teams WHERE lgID = 'ABA' AND year = 1972).won AS FLOAT) / ((SELECT * FROM teams WHERE lgID = 'ABA' AND year = 1972).won + (SELECT * FROM teams WHERE lgID = 'ABA' AND year = 1972).lost))) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of teams from the 'teams' table that belong to a specified league and year. It filters teams based on their league ID and year, and it compares their winning percentages to those of teams from the ABA league in 1972. The results are ordered by the difference in winning percentages, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 2815,
            "vt": "SELECT COUNT(DISTINCT playerID) FROM player_allstar WHERE CAST(player_allstar.d_rebounds AS FLOAT) * [placeholder-type:numeric] / player_allstar.rebounds > [placeholder-type:numeric] AND player_allstar.season_id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of players from the 'player_allstar' table who have a specific ratio of defensive rebounds to total rebounds exceeding a certain threshold during a specified range of seasons. The placeholders represent numeric values for the ratio multiplier and the season range."
        },
        {
            "sample_id": 2827,
            "vt": "SELECT DISTINCT players.college FROM players INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE player_allstar.conference = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct colleges from which players have graduated, specifically for those players who have participated in All-Star games. The query filters the results based on the conference to which these players belong, using a placeholder for the conference name."
        },
        {
            "sample_id": 2810,
            "vt": "SELECT players.namenick FROM player_allstar INNER JOIN players AS T2 ON T1.playerID = T2.playerID WHERE player_allstar.blocks = [placeholder-type:numeric] AND player_allstar.conference = '[placeholder-type:string]' AND player_allstar.season_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the nicknames of players who participated in the All-Star games, filtered by the number of blocks they made, their conference affiliation, and the specific season they played in. The placeholders represent the numeric values for blocks and season ID, as well as the string value for the conference."
        },
        {
            "sample_id": 2883,
            "vt": "SELECT players.firstname, players.middlename, players.lastname FROM players WHERE players.birthcountry <> '[placeholder-type:string]'",
            "ba": "The virtual table describes the first, middle, and last names of players from the 'players' table who were not born in a specified country. The placeholder in the WHERE clause represents the country name that is being excluded from the results."
        },
        {
            "sample_id": 2828,
            "vt": "SELECT COUNT(DISTINCT T1.playerID) FROM players INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE players.birthcity = '[placeholder-type:string]' AND players_teams.lgid = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct players from the 'players' table who were born in a specific city and have played for teams in a specified league. It joins the 'players' table with the 'players_teams' table to filter players based on their birth city and the league they participated in."
        },
        {
            "sample_id": 2934,
            "vt": "SELECT teams.tmid FROM players_teams INNER JOIN teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE players_teams.postgp = [placeholder-type:numeric] AND players_teams.year = [placeholder-type:numeric] ORDER BY CAST(teams.won AS FLOAT) / (teams.won + teams.lost) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the team IDs of teams that players have participated in during a specific year and post-season games. The query filters teams based on the number of post-season game presentations and the year, and it orders the results by the winning percentage of the teams, limiting the output to a specified number of results."
        },
        {
            "sample_id": 2863,
            "vt": "SELECT players.firstname, players.lastname FROM players INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID INNER JOIN teams AS T3 ON T3.tmID = T2.tmID WHERE teams.name = '[placeholder-type:string]' AND players_teams.year > [placeholder-type:numeric] ORDER BY players.height LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of players from the 'players' table who are associated with a specific team and have played in a year greater than a specified year. The results are ordered by the players' height, and the number of results returned is limited by a placeholder for numeric values."
        },
        {
            "sample_id": 2915,
            "vt": "SELECT DISTINCT awards_coaches.coachid FROM coaches INNER JOIN awards_coaches AS T2 ON T1.coachID = T2.coachID WHERE coaches.tmid = '[placeholder-type:string]' AND coaches.lgid = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves a distinct list of coach IDs from the 'coaches' table who have received awards, filtered by a specific team and league."
        },
        {
            "sample_id": 2894,
            "vt": "SELECT players.firstname, players.middlename, players.lastname FROM players INNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID WHERE awards_players.award = '[placeholder-type:string]' ORDER BY players.birthdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first, middle, and last names of players from the 'players' table who have received a specific award. The query joins the 'players' table with the 'awards_players' table to filter players based on the award they have received. The placeholder in the WHERE clause represents the name of the award, and the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 2851,
            "vt": "SELECT players_teams.tmid FROM players_teams INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID GROUP BY players_teams.tmid HAVING COUNT(DISTINCT T1.playerID) >= [placeholder-type:numeric]",
            "ba": "The virtual table lists the team IDs from the 'players_teams' table where a certain number of distinct players have participated in All-Star games. It uses an inner join with the 'player_allstar' table to filter teams based on the count of unique players who have played in All-Star games, ensuring that only teams with a specified minimum number of All-Star players are included."
        },
        {
            "sample_id": 2950,
            "vt": "SELECT players.birthdate FROM players WHERE players.playerid = (SELECT players.playerid FROM players_teams WHERE year = 2001 GROUP BY playerID ORDER BY SUM(rebounds + dRebounds) DESC LIMIT 1)",
            "ba": "The virtual table retrieves the birthdate of the player who had the highest total rebounds (offensive and defensive) in the year 2001 from the 'players' table. It first identifies the player with the maximum sum of rebounds from the 'players_teams' table for that year."
        },
        {
            "sample_id": 2868,
            "vt": "SELECT players.firstname FROM players INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE players_teams.lgid = '[placeholder-type:string]' GROUP BY players.playerid, players.firstname ORDER BY COUNT(players_teams.pf) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the first names of players from the 'players' table who are associated with a specific league, as indicated by the league ID. It joins the 'players' table with the 'players_teams' table to filter players based on their league participation. The results are grouped by player ID and first name, and ordered by the count of personal fouls, limiting the output to a specified number of players."
        },
        {
            "sample_id": 2839,
            "vt": "SELECT players.firstname, players.middlename, players.lastname FROM players INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE players_teams.tmid = '[placeholder-type:string]' ORDER BY players.height LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first, middle, and last names of players from the 'players' table who are associated with a specific team. The query joins the 'players' table with the 'players_teams' table to filter players based on their team ID. The results are ordered by the players' height and limited to a specified number of entries."
        },
        {
            "sample_id": 2900,
            "vt": "SELECT COUNT(DISTINCT playerID) FROM player_allstar WHERE player_allstar.season_id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND player_allstar.steals <= [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of players who participated in the All-Star games within a specified range of seasons, while also filtering for those who had a certain number of steals or fewer during those seasons. The placeholders represent the range of seasons and the maximum number of steals allowed."
        },
        {
            "sample_id": 2872,
            "vt": "SELECT players.firstname, players.lastname FROM players INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE players_teams.year = [placeholder-type:numeric] ORDER BY CAST(players_teams.fgmade AS FLOAT) / players_teams.fgattempted LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of players from the 'players' table who participated in a specific year, along with their performance metrics in terms of field goals made and attempted. The query joins the 'players' table with the 'players_teams' table to filter players based on the specified year and orders them by their shooting efficiency, represented by the ratio of field goals made to field goals attempted. The placeholders allow users to specify the year and limit the number of results returned."
        },
        {
            "sample_id": 2907,
            "vt": "SELECT CAST(SUM(CASE WHEN awards_coaches.award = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM awards_coaches WHERE awards_coaches.year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average value of a specific award received by coaches in a given year. It sums the values associated with the specified award and divides it by the total count of awards received in that year, adjusting the result by a specified multiplier."
        },
        {
            "sample_id": 2811,
            "vt": "SELECT teams.year FROM series_post INNER JOIN teams AS T2 ON T1.tmIDWinner = T2.tmID WHERE series_post.round = '[placeholder-type:string]' AND series_post.tmidloser = '[placeholder-type:string]' ORDER BY teams.rank LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the years in which specific teams won their playoff series, based on the round of the series and the team that lost. It joins the 'series_post' table with the 'teams' table to get the relevant team information, filtering by the round and the losing team, and orders the results by the team's rank, limiting the number of results returned."
        },
        {
            "sample_id": 2875,
            "vt": "SELECT DISTINCT players.firstname, players.lastname FROM players INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE players.college = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct first and last names of players from the 'players' table who have attended a specific college. The placeholder in the WHERE clause represents the name of the college."
        },
        {
            "sample_id": 2805,
            "vt": "SELECT teams.name, coaches.year, teams.o_pts FROM coaches INNER JOIN teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE coaches.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND coaches.coachid = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the names of teams, the years in which their coaches were active, and the offensive points scored by those teams. It combines data from the 'coaches' and 'teams' tables based on matching team IDs and years. The query filters results to include only those years that fall within a specified range and for a specific coach identified by their ID."
        },
        {
            "sample_id": 2809,
            "vt": "SELECT DISTINCT awards_coaches.coachid FROM coaches INNER JOIN awards_coaches AS T2 ON T1.coachID = T2.coachID INNER JOIN teams AS T3 ON T3.tmID = T1.tmID WHERE awards_coaches.award = '[placeholder-type:string]' AND awards_coaches.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND coaches.year = [placeholder-type:numeric] AND teams.name = '[placeholder-type:string]'",
            "ba": "The virtual table identifies distinct coach IDs from the 'coaches' table who have received a specific award within a certain year range. It joins the 'awards_coaches' table to filter by award name and year, and also joins the 'teams' table to ensure the results are for a specific team name in a given coaching year."
        },
        {
            "sample_id": 2850,
            "vt": "SELECT COUNT(awards_players.playerid) FROM awards_players WHERE awards_players.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND awards_players.award = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of players who received a specific award within a given range of years from the 'awards_players' table. The placeholders represent the year range and the award name."
        },
        {
            "sample_id": 2905,
            "vt": "SELECT awards_players.playerid FROM awards_players WHERE awards_players.year > [placeholder-type:numeric] AND awards_players.award = '[placeholder-type:string]' AND awards_players.lgid = '[placeholder-type:string]'",
            "ba": "The virtual table lists the unique player IDs from the 'awards_players' table for players who have received a specific award in a year greater than a specified year and belong to a particular league. The placeholders represent the year, award name, and league name respectively."
        },
        {
            "sample_id": 2802,
            "vt": "SELECT coaches.coachid, coaches.tmid FROM coaches WHERE coaches.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] ORDER BY coaches.stint LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique identifiers and team abbreviations of coaches from the 'coaches' table who coached during a specified range of years. The placeholders represent the start and end years for filtering, as well as a limit on the number of results returned."
        },
        {
            "sample_id": 2881,
            "vt": "SELECT COUNT(DISTINCT T1.playerID) FROM players INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID INNER JOIN teams AS T3 ON T3.tmID = T2.tmID WHERE teams.year = [placeholder-type:numeric] AND teams.rank = [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of players who participated in a specific year and rank of a team. It joins the 'players' table with the 'players_teams' table to link players to their respective teams, and then further joins with the 'teams' table to filter based on the specified year and rank."
        },
        {
            "sample_id": 2887,
            "vt": "SELECT DISTINCT players.firstname, players.lastname, players.height, players.weight FROM players INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE player_allstar.ft_attempted > [placeholder-type:numeric] AND player_allstar.ft_attempted = player_allstar.ft_made",
            "ba": "The virtual table provides a list of distinct players' first names, last names, heights, and weights from the 'players' table who have participated in the All-Star games. It filters the results to include only those players who have attempted more than a specified number of free throws and have made all of their attempted free throws during the All-Star season."
        },
        {
            "sample_id": 2891,
            "vt": "SELECT DISTINCT coaches.coachid, teams.name FROM coaches JOIN series_post AS T2 ON T1.tmID = T2.tmIDWinner JOIN teams AS T3 ON T3.tmID = T1.tmID WHERE series_post.round = '[placeholder-type:string]' AND series_post.year = [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of unique coach IDs along with the names of teams that won in a specific round of the playoffs during a given year. The placeholders allow users to specify the round and year of interest."
        },
        {
            "sample_id": 2825,
            "vt": "SELECT DISTINCT players.firstname FROM players INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE (players.pos = '[placeholder-type:string]' OR players.pos = '[placeholder-type:string]') AND players_teams.lgid = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct first names of players from the 'players' table who play in specified positions and belong to a specific league. The query joins the 'players' table with the 'players_teams' table to filter players based on their positions and league affiliation."
        },
        {
            "sample_id": 2880,
            "vt": "SELECT players.birthstate FROM players INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID GROUP BY players.birthstate ORDER BY COUNT(DISTINCT T1.playerID) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of birth states of players who have participated in All-Star games, grouped by their birth state. The result is ordered by the count of distinct players from each state, allowing for the identification of states with the most All-Star players. The placeholder in the LIMIT clause allows for specifying the maximum number of states to return."
        },
        {
            "sample_id": 2831,
            "vt": "SELECT players.height FROM players INNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID WHERE awards_players.award = '[placeholder-type:string]' ORDER BY players.height LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the heights of players who have received a specific award. It joins the 'players' table with the 'awards_players' table to filter players based on the award they have won. The results are ordered by height and limited to a specified number of entries."
        }
    ],
    "european_football_1": [
        {
            "sample_id": 2747,
            "vt": "SELECT COUNT(DISTINCT CASE WHEN T1.FTHG >= 4 THEN HomeTeam ELSE NULL END) + COUNT(DISTINCT CASE WHEN T1.FTAG >= 4 THEN AwayTeam ELSE NULL END) FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE divisions.country = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of distinct home and away teams that scored 4 or more goals in matches, filtered by the country of the division. It uses a join between the 'matchs' and 'divisions' tables to associate matches with their respective divisions based on the division ID."
        },
        {
            "sample_id": 2761,
            "vt": "SELECT matchs.awayteam FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE divisions.country = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the away teams from the 'matchs' table that are associated with divisions in a specific country. The query joins the 'matchs' table with the 'divisions' table to filter the results based on the country of the division. The placeholders represent the country name and the limit on the number of results returned."
        },
        {
            "sample_id": 2743,
            "vt": "SELECT CAST(SUM(CASE WHEN matchs.div = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(matchs.div) FROM matchs WHERE matchs.date = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average goals scored by a specific division on a particular match date. It uses a conditional sum to differentiate between home and away goals based on the division ID, and then divides the total by the count of matches to get the average. The placeholders represent the division ID, numeric values for goals, and the match date."
        },
        {
            "sample_id": 2746,
            "vt": "SELECT matchs.hometeam, matchs.awayteam FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE divisions.name = '[placeholder-type:string]' AND matchs.div = '[placeholder-type:string]'",
            "ba": "The virtual table describes the home and away teams from the 'matchs' table that are associated with a specific division name and division id. The placeholders in the WHERE clause represent the division's name and id."
        },
        {
            "sample_id": 2774,
            "vt": "SELECT divisions.division, divisions.name FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE matchs.season = [placeholder-type:numeric] AND matchs.fthg = [placeholder-type:numeric] AND matchs.ftag = [placeholder-type:numeric]",
            "ba": "The virtual table describes the divisions and their names from the 'divisions' table that are associated with matches in a specific season where the final-time home-team goals, final-time away-team goals are specified. The placeholders in the WHERE clause represent the season and the goals scored by the home and away teams."
        },
        {
            "sample_id": 2783,
            "vt": "SELECT COUNT(matchs.div) FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE matchs.season = [placeholder-type:numeric] AND divisions.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of matches from the 'matchs' table that belong to a specific division and season. It joins the 'matchs' table with the 'divisions' table to filter matches based on the division's name and the specified season."
        },
        {
            "sample_id": 2753,
            "vt": "SELECT matchs.hometeam FROM matchs WHERE matchs.div = '[placeholder-type:string]' AND matchs.season = [placeholder-type:numeric] ORDER BY matchs.fthg LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the home teams from the 'matchs' table that belong to a specific division and season. The placeholders in the WHERE clause represent the division's ID and the season year, while the LIMIT clause allows for controlling the number of results returned."
        },
        {
            "sample_id": 2749,
            "vt": "SELECT matchs.hometeam FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE divisions.country = '[placeholder-type:string]' AND matchs.fthg = [placeholder-type:numeric]",
            "ba": "The virtual table describes the home teams from the 'matchs' table that are associated with divisions in a specific country. The query filters the results based on the country of the division and the final-time home-team goals scored in a match, using placeholders for both the country name and the numeric value of goals."
        },
        {
            "sample_id": 2782,
            "vt": "SELECT CAST(COUNT(CASE WHEN divisions.name = '[placeholder-type:string]' THEN matchs.div ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(matchs.div) FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE matchs.fthg = [placeholder-type:numeric] AND matchs.ftag = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the percentage of matches played by a specific division where the home team scored a certain number of goals and the away team scored a certain number of goals. It uses a conditional count to determine how many matches belong to the specified division and multiplies this count by a numeric placeholder to adjust the result. The final count is divided by the total number of matches to get the desired percentage."
        },
        {
            "sample_id": 2780,
            "vt": "SELECT COUNT(DISTINCT T1.HomeTeam) FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE divisions.name = '[placeholder-type:string]' AND matchs.season = [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct home teams from the 'matchs' table that are associated with a specific division and season. The placeholders represent the division's name and the season year."
        },
        {
            "sample_id": 2763,
            "vt": "SELECT COUNT(matchs.hometeam) FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE divisions.name = '[placeholder-type:string]' AND matchs.hometeam = '[placeholder-type:string]' AND matchs.ftr = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of matches played by a specific home team in a specific division, filtered by the division's name and the match result."
        },
        {
            "sample_id": 2739,
            "vt": "SELECT COUNT(*) FROM matchs WHERE matchs.season = [placeholder-type:numeric] AND matchs.awayteam = '[placeholder-type:string]' AND matchs.ftr = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of matches from the 'matchs' table for a specific season, where a specified away team played and the final result of the match is known."
        },
        {
            "sample_id": 2786,
            "vt": "SELECT matchs.hometeam FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE divisions.name = '[placeholder-type:string]' AND matchs.ftr = '[placeholder-type:string]' GROUP BY matchs.hometeam ORDER BY COUNT(matchs.ftr) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of home teams from the 'matchs' table that belong to a specific division and have a certain final-time result. The query joins the 'matchs' table with the 'divisions' table to filter matches based on the division name and the match result. The results are grouped by home team names and ordered by the count of match results, with a limit on the number of results returned."
        },
        {
            "sample_id": 2769,
            "vt": "SELECT MIN(matchs.date) FROM matchs WHERE matchs.fthg + matchs.ftag > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the earliest match date from the 'matchs' table where the total goals scored by both teams (home and away) exceed a specified number. The placeholder in the WHERE clause represents the minimum total goals required for the matches."
        },
        {
            "sample_id": 2766,
            "vt": "SELECT divisions.name FROM divisions WHERE divisions.country = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of divisions from the 'divisions' table that are located in a specific country. The placeholder in the WHERE clause represents the name of the country."
        },
        {
            "sample_id": 2784,
            "vt": "SELECT matchs.hometeam FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE matchs.date = '[placeholder-type:string]' AND divisions.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the home teams from the 'matchs' table for matches that occurred on a specific date and belong to a specific division. The placeholders in the WHERE clause represent the match date and the division name."
        },
        {
            "sample_id": 2772,
            "vt": "SELECT COUNT(matchs.ftr) FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE divisions.name = '[placeholder-type:string]' AND matchs.date = '[placeholder-type:string]' AND matchs.ftr = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of matches from the 'matchs' table that meet specific criteria. It joins the 'matchs' table with the 'divisions' table to filter matches based on the division name and match date. The placeholders represent the division name, match date, and final-time result of the match."
        },
        {
            "sample_id": 2771,
            "vt": "SELECT COUNT(matchs.ftr) FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE divisions.name = '[placeholder-type:string]' AND matchs.date = '[placeholder-type:string]' AND matchs.ftr = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of matches from the 'matchs' table that meet specific criteria related to the division name, match date, and final-time result. The placeholders represent the division's name, the match date, and the final-time result of the match."
        },
        {
            "sample_id": 2744,
            "vt": "SELECT CAST(SUM(CASE WHEN matchs.hometeam = '[placeholder-type:string]' OR matchs.awayteam = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(matchs.ftr) FROM matchs WHERE matchs.ftr = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average goals scored by a specific home or away team in matches from the 'matchs' table, filtered by the match result. The placeholders represent the team names, the multiplier for scaling the average, and the final-time result condition."
        },
        {
            "sample_id": 2750,
            "vt": "SELECT matchs.hometeam, CAST(COUNT(CASE WHEN matchs.ftr = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(matchs.hometeam) FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE divisions.name = '[placeholder-type:string]' AND divisions.country = '[placeholder-type:string]' AND matchs.season = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the percentage of home victories, away victories, and draws for home teams in a specific division and country during a particular season. It joins the 'matchs' table with the 'divisions' table to filter matches based on the division name, country, and season. The placeholders represent the type of result (home victory, away victory, or draw), a numeric value for scaling the result, and the specific division name, country, and season year."
        },
        {
            "sample_id": 2751,
            "vt": "SELECT (SELECT COUNT(matchs.div) FROM matchs AS T1 INNER JOIN divisions AS T2 ON T2.division = T1.Div WHERE T2.country = 'England' AND T1.season = 2012), CASE WHEN [placeholder-type:numeric] THEN (SELECT 100.0 * COUNT(T1.Div) / (SELECT COUNT(T1.Div) FROM matchs AS T1 INNER JOIN divisions AS T2 ON T2.division = T1.Div WHERE T2.country = 'England' AND T1.season = 2012) AS result FROM matchs AS T1 INNER JOIN divisions AS T2 ON T2.division = T1.Div WHERE T2.country = 'England' AND T1.season = 2012 GROUP BY T2.division).result END FROM (SELECT [placeholder-type:numeric] * COUNT(matchs.div) / (SELECT COUNT(matchs.div) FROM matchs AS T1 INNER JOIN divisions AS T2 ON T2.division = T1.Div WHERE T2.country = 'England' AND T1.season = 2012) FROM matchs AS T1 INNER JOIN divisions AS T2 ON T2.division = T1.Div WHERE T2.country = 'England' AND T1.season = 2012 GROUP BY T2.division) AS t",
            "ba": "The virtual table calculates the total number of matches played in a specific country (England) during a particular season (2012) and computes the percentage of matches won by a specified team based on the final-time results. It uses subqueries to count the matches and determine the winning percentage, with placeholders for numeric values to allow for dynamic input."
        },
        {
            "sample_id": 2760,
            "vt": "SELECT matchs.awayteam FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE divisions.name = '[placeholder-type:string]' ORDER BY matchs.ftag LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of away teams from the 'matchs' table that are associated with a specific division. It joins the 'matchs' table with the 'divisions' table to filter matches based on the division's name. The results are ordered by the final-time away team goals and limited to a specified number of entries."
        },
        {
            "sample_id": 2790,
            "vt": "SELECT COUNT(CASE WHEN divisions.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) - COUNT(CASE WHEN divisions.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE matchs.season = [placeholder-type:numeric] AND matchs.ftr = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference in the count of matches for a specific division and season based on the final-time results. It uses placeholders to filter by division name, season, and final-time result type (home victory, away victory, or draw)."
        },
        {
            "sample_id": 2789,
            "vt": "SELECT COUNT(matchs.div) FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE divisions.name = '[placeholder-type:string]' AND matchs.ftr = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of matches from the 'matchs' table that belong to a specific division and have a specific final-time result. It joins the 'matchs' table with the 'divisions' table to filter based on the division's name and the match result."
        },
        {
            "sample_id": 2779,
            "vt": "SELECT DISTINCT divisions.country FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE matchs.hometeam = '[placeholder-type:string]' OR matchs.awayteam = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves a list of unique countries from the 'divisions' table based on matches played in the 'matchs' table. It filters the matches where either the home team or the away team matches a specified team name."
        },
        {
            "sample_id": 2765,
            "vt": "SELECT COUNT(divisions.division) FROM divisions WHERE divisions.country = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of divisions from the 'divisions' table that are located in a specific country. The placeholder in the WHERE clause represents the name of the country."
        },
        {
            "sample_id": 2757,
            "vt": "SELECT divisions.name FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE matchs.date = '[placeholder-type:string]' AND matchs.hometeam = '[placeholder-type:string]' AND matchs.awayteam = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of divisions from the 'divisions' table that are associated with matches in the 'matchs' table. It filters the results based on a specific match date and the names of the home and away teams. The placeholders in the WHERE clause represent the match date, home team name, and away team name."
        },
        {
            "sample_id": 2756,
            "vt": "SELECT matchs.hometeam FROM matchs WHERE matchs.div = '[placeholder-type:string]' AND matchs.date = '[placeholder-type:string]' AND matchs.ftr = '[placeholder-type:string]'",
            "ba": "The virtual table describes the home teams from the 'matchs' table for a specific division and date, filtered by the final-time result of the match. The placeholders represent the division id, match date, and the final-time result of the match."
        },
        {
            "sample_id": 2740,
            "vt": "SELECT CAST(COUNT(CASE WHEN divisions.country = '[placeholder-type:string]' THEN divisions.division ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(divisions.division) FROM divisions",
            "ba": "The virtual table calculates the percentage of divisions in a specific country relative to the total number of divisions, multiplied by a specified numeric value. The placeholder in the WHERE clause represents the country name, and the numeric placeholder allows for scaling the result by a given factor."
        },
        {
            "sample_id": 2770,
            "vt": "SELECT CASE WHEN matchs.ftr = '[placeholder-type:string]' THEN matchs.hometeam ELSE matchs.awayteam END FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE divisions.name = '[placeholder-type:string]' ORDER BY matchs.ftag + matchs.fthg LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table identifies the winning team from matches based on the final-time results. It selects either the home team or the away team depending on whether the match result indicates a home victory, away victory, or draw. The results are filtered by the division name and ordered by the total goals scored in the match, with a limit on the number of results returned."
        },
        {
            "sample_id": 2768,
            "vt": "SELECT matchs.fthg, matchs.ftag FROM matchs WHERE matchs.date = '[placeholder-type:string]' AND matchs.hometeam = '[placeholder-type:string]' AND matchs.awayteam = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the final-time goals scored by the home and away teams from the 'matchs' table for a specific match date and specific teams."
        },
        {
            "sample_id": 2791,
            "vt": "SELECT DISTINCT matchs.hometeam FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE matchs.season = [placeholder-type:numeric] AND matchs.ftr = '[placeholder-type:string]' AND divisions.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct home teams from the 'matchs' table that played in a specific season and achieved a certain final-time result, filtered by the division name from the 'divisions' table. The placeholders represent the season number, the final-time result, and the division name."
        },
        {
            "sample_id": 2785,
            "vt": "SELECT CASE WHEN matchs.ftr = '[placeholder-type:string]' THEN matchs.hometeam WHEN matchs.ftr = '[placeholder-type:string]' THEN matchs.awayteam END FROM matchs INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE matchs.date = '[placeholder-type:string]' AND divisions.name = '[placeholder-type:string]'",
            "ba": "The virtual table identifies the winning team of a match based on the final-time results from the 'matchs' table. It uses a CASE statement to determine whether the home team or away team won, depending on the final-time result (ftr). The query also joins the 'matchs' table with the 'divisions' table to filter results based on the match date and the division name."
        },
        {
            "sample_id": 2754,
            "vt": "SELECT CAST(COUNT(CASE WHEN matchs.ftr = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(matchs.ftr) - CAST(COUNT(CASE WHEN matchs.ftr = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(matchs.ftr) FROM matchs WHERE matchs.season = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the percentage of matches that resulted in a specific outcome (home victory, away victory, or draw) for a given season. It uses a conditional count to determine how many matches ended with the specified result and divides it by the total number of matches in that season. The placeholders represent the type of match result and the season year."
        }
    ],
    "debit_card_specializing": [
        {
            "sample_id": 10902,
            "vt": "SELECT SUBSTRING(yearmonth.date, [placeholder-type:numeric], [placeholder-type:numeric]) FROM customers INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTRING(yearmonth.date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND customers.segment = '[placeholder-type:string]' GROUP BY SUBSTRING(yearmonth.date, [placeholder-type:numeric], [placeholder-type:numeric]) ORDER BY SUM(yearmonth.consumption) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves specific segments of dates from the 'yearmonth' table, filtered by customer segment and a specific date substring. It joins the 'customers' table to access customer segments and groups the results by the extracted date substring, ordering them by the total consumption for each date segment, with a limit on the number of results returned."
        },
        {
            "sample_id": 10927,
            "vt": "SELECT COUNT(*) FROM yearmonth INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.currency = '[placeholder-type:string]' AND yearmonth.consumption > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of records from the 'yearmonth' table that are associated with customers from the 'customers' table, filtered by a specific currency and a minimum consumption value. The placeholders represent the currency type and the threshold for consumption."
        },
        {
            "sample_id": 10914,
            "vt": "SELECT CAST(SUM(customers.currency = '[placeholder-type:string]') AS FLOAT) * [placeholder-type:numeric] / COUNT(customers.customerid) FROM customers WHERE customers.segment = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average currency value for customers in a specific segment. It sums the currency values for customers matching the specified segment and divides it by the count of customers in that segment, applying a multiplier to the result."
        },
        {
            "sample_id": 10917,
            "vt": "SELECT customers.customerid FROM customers INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE yearmonth.date = '[placeholder-type:string]' GROUP BY customers.customerid ORDER BY SUM(yearmonth.consumption) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique customer IDs from the 'customers' table who have transactions recorded in the 'yearmonth' table for a specific date. It groups the results by customer ID and orders them based on the total consumption, limiting the output to a specified number of customers."
        },
        {
            "sample_id": 10895,
            "vt": "SELECT AVG(yearmonth.consumption) / [placeholder-type:numeric] FROM customers INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTRING(yearmonth.date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND customers.segment = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average consumption of customers from the 'yearmonth' table, divided by a specified numeric value. It joins the 'customers' table to filter results based on customer segments and a specific date substring. The placeholders represent the numeric divisor, the date substring parameters, and the customer segment."
        },
        {
            "sample_id": 10921,
            "vt": "SELECT SUM(yearmonth.consumption) / [placeholder-type:numeric] FROM customers INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.currency = '[placeholder-type:string]' GROUP BY customers.customerid ORDER BY None.monthlyconsumption LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average monthly consumption of customers from the 'customers' and 'yearmonth' tables. It sums the consumption values from the 'yearmonth' table, divides by a specified number to get the average, and filters the results based on the currency of the customers. The results are grouped by customer ID and can be limited to a specified number of records."
        },
        {
            "sample_id": 10928,
            "vt": "SELECT DISTINCT products.description FROM transactions_1k INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE gasstations.country = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct product descriptions from the 'products' table that have been sold at gas stations located in a specific country. The query joins the 'transactions_1k' table with the 'gasstations' and 'products' tables to filter the results based on the country of the gas stations."
        },
        {
            "sample_id": 10906,
            "vt": "SELECT SUM(CASE WHEN gasstations.country = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN gasstations.country = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM gasstations WHERE gasstations.segment = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference in total amounts based on the country of gas stations and their segment. It uses conditional aggregation to sum amounts for specified countries and segments, allowing for a comparison between two different conditions."
        },
        {
            "sample_id": 10931,
            "vt": "SELECT COUNT(transactions_1k.transactionid) FROM transactions_1k INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE gasstations.country = '[placeholder-type:string]' AND STRFTIME('%Y', transactions_1k.date) >= '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of transactions from the 'transactions_1k' table that occurred at gas stations located in a specific country and after a certain year. The placeholders represent the country and the year for filtering the results."
        },
        {
            "sample_id": 10944,
            "vt": "SELECT customers.currency FROM yearmonth INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE yearmonth.date = '[placeholder-type:string]' AND yearmonth.consumption = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the currency used by customers from the 'customers' table based on their consumption data in the 'yearmonth' table. The query filters results for a specific date and a specific consumption amount, using placeholders for these values."
        },
        {
            "sample_id": 10898,
            "vt": "SELECT SUM(CASE WHEN customers.currency = '[placeholder-type:string]' THEN yearmonth.consumption ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN customers.currency = '[placeholder-type:string]' THEN yearmonth.consumption ELSE [placeholder-type:numeric] END) FROM customers INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTRING(yearmonth.date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference in total consumption for customers based on their currency type over a specified date range. It uses a conditional sum to account for the consumption values associated with a specific currency, while also allowing for a placeholder for numeric values to handle cases where the currency does not match. The query joins the 'customers' table with the 'yearmonth' table to filter the results based on customer IDs and a substring of the date."
        },
        {
            "sample_id": 10938,
            "vt": "SELECT COUNT(transactions_1k.transactionid) FROM transactions_1k INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE transactions_1k.date = '[placeholder-type:string]' AND transactions_1k.time < '[placeholder-type:string]' AND customers.currency = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of transactions from the 'transactions_1k' table for a specific date and time, while also filtering based on the customer's currency from the 'customers' table. The placeholders represent the date, time, and currency values that can be specified by the user."
        },
        {
            "sample_id": 10919,
            "vt": "SELECT customers.customerid FROM customers INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE yearmonth.date = '[placeholder-type:string]' AND customers.segment = '[placeholder-type:string]' GROUP BY customers.customerid ORDER BY SUM(yearmonth.consumption) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique customer IDs from the 'customers' table who belong to a specific segment and have consumption data for a given date. The results are grouped by customer ID and ordered by the total consumption, with a limit on the number of results returned."
        },
        {
            "sample_id": 10949,
            "vt": "SELECT transactions_1k.gasstationid FROM transactions_1k GROUP BY transactions_1k.gasstationid ORDER BY SUM(transactions_1k.price) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique gas station IDs from the 'transactions_1k' table, grouping the results by gas station ID. It orders the results based on the total price of transactions at each gas station, allowing for a limit on the number of results returned."
        },
        {
            "sample_id": 10932,
            "vt": "SELECT AVG(transactions_1k.price) FROM transactions_1k INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE gasstations.country = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average price of transactions from the 'transactions_1k' table for gas stations located in a specific country. It joins the 'transactions_1k' table with the 'gasstations' table based on the gas station ID, and filters the results based on the specified country using a placeholder for string values."
        },
        {
            "sample_id": 10899,
            "vt": "SELECT SUBSTRING(yearmonth.date, [placeholder-type:numeric], [placeholder-type:numeric]) FROM customers INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.currency = '[placeholder-type:string]' GROUP BY SUBSTRING(yearmonth.date, [placeholder-type:numeric], [placeholder-type:numeric]) ORDER BY SUM(yearmonth.consumption) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a substring of the date from the 'yearmonth' table, grouped by this substring, for customers who have a specific currency. It joins the 'customers' table with the 'yearmonth' table based on the customer ID, and orders the results by the total consumption, limiting the output to a specified number of records."
        },
        {
            "sample_id": 10947,
            "vt": "SELECT CAST(SUM(CASE WHEN customers.currency = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(transactions_1k.customerid) FROM transactions_1k INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE transactions_1k.date = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average transaction amount for customers based on their currency type for a specific date. It sums the transaction amounts for customers whose currency matches the specified placeholder and divides it by the count of transactions for that date. The result is then multiplied by a numeric placeholder, allowing for further adjustments or scaling of the average amount."
        },
        {
            "sample_id": 10923,
            "vt": "SELECT DISTINCT gasstations.country FROM transactions_1k INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE yearmonth.date = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct countries of gas stations from the 'gasstations' table based on transactions recorded in the 'transactions_1k' table. It joins the 'transactions_1k' table with the 'gasstations' table using the gas station ID and also joins with the 'yearmonth' table using the customer ID. The query filters results for a specific date provided as a placeholder."
        },
        {
            "sample_id": 10954,
            "vt": "SELECT gasstations.country FROM transactions_1k INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE transactions_1k.productid = [placeholder-type:numeric] ORDER BY transactions_1k.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the country of gas stations from the 'gasstations' table based on transactions recorded in the 'transactions_1k' table. It filters the results to include only those transactions that involve a specific product, indicated by a placeholder for the product ID. Additionally, the results are ordered by the price of the transactions, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 10912,
            "vt": "SELECT CAST(SUM(CASE WHEN yearmonth.consumption > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(customers.customerid) FROM customers INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.segment = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of consumption for customers in a specific segment. It sums the consumption values from the 'yearmonth' table based on a condition, applies a multiplier, and divides by the count of customers in that segment."
        },
        {
            "sample_id": 10933,
            "vt": "SELECT AVG(transactions_1k.price) FROM transactions_1k INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE customers.currency = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average price of transactions from the 'transactions_1k' table, joining with the 'gasstations' and 'customers' tables to filter results based on the currency of the customers. The placeholder in the WHERE clause represents the specific currency being queried."
        },
        {
            "sample_id": 10950,
            "vt": "SELECT CAST(SUM(CASE WHEN gasstations.country = '[placeholder-type:string]' AND gasstations.segment = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(CASE WHEN gasstations.country = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM gasstations",
            "ba": "The virtual table calculates a weighted average based on the sum of certain values from the 'gasstations' table, filtered by specific country and segment criteria. The placeholders represent the country, segment, and numeric values for calculations."
        },
        {
            "sample_id": 10908,
            "vt": "SELECT SUM(customers.currency = '[placeholder-type:string]') - SUM(customers.currency = '[placeholder-type:string]') FROM customers WHERE customers.segment = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between the total counts of customers in two different currency types, filtered by a specific client segment. The placeholders represent the currency types and the segment of customers."
        },
        {
            "sample_id": 10893,
            "vt": "SELECT CAST(SUM(CASE WHEN customers.currency = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN customers.currency = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM customers",
            "ba": "The virtual table calculates the average amount spent by customers in a specific currency from the 'customers' table. It uses conditional aggregation to sum the amounts based on the specified currency, allowing for a comparison of spending across different currencies."
        },
        {
            "sample_id": 10911,
            "vt": "SELECT SUM(yearmonth.consumption) FROM customers INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE yearmonth.date = '[placeholder-type:string]' AND customers.segment = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total consumption of customers from the 'yearmonth' table, filtered by a specific date and customer segment. The placeholders in the WHERE clause represent the date and segment criteria."
        },
        {
            "sample_id": 10909,
            "vt": "SELECT customers.customerid FROM customers INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.segment = '[placeholder-type:string]' AND yearmonth.date = '[placeholder-type:string]' AND customers.currency = '[placeholder-type:string]' GROUP BY customers.customerid ORDER BY SUM(yearmonth.consumption) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a list of customer IDs from the 'customers' table who belong to a specific client segment, have made transactions in a specified date, and use a particular currency. The results are grouped by customer ID and ordered by the total consumption from the 'yearmonth' table, with a limit on the number of results returned."
        },
        {
            "sample_id": 10918,
            "vt": "SELECT customers.segment FROM customers INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE yearmonth.date = '[placeholder-type:string]' GROUP BY customers.customerid ORDER BY SUM(yearmonth.consumption) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the segments of customers from the 'customers' table who have transactions recorded in the 'yearmonth' table for a specific date. It groups the results by customer ID and orders them based on the total consumption, limiting the output to a specified number of results."
        },
        {
            "sample_id": 10955,
            "vt": "SELECT yearmonth.consumption FROM transactions_1k INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE transactions_1k.price / transactions_1k.amount > [placeholder-type:numeric] AND transactions_1k.productid = [placeholder-type:numeric] AND yearmonth.date = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the consumption data from the 'yearmonth' table for customers based on specific transaction criteria. It filters transactions where the price per unit exceeds a certain threshold and matches a specific product ID, while also ensuring the date corresponds to a given value."
        },
        {
            "sample_id": 10925,
            "vt": "SELECT DISTINCT transactions_1k.productid, products.description FROM transactions_1k INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE customers.currency = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of product IDs and their descriptions from the 'products' table, based on transactions made by customers who are identified in the 'transactions_1k' table. It filters the results to include only those customers whose currency matches a specified value."
        },
        {
            "sample_id": 10900,
            "vt": "SELECT customers.segment FROM customers INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY customers.segment ORDER BY SUM(yearmonth.consumption) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the segments of customers from the 'customers' table, joining it with the 'yearmonth' table to aggregate consumption data. It groups the results by customer segment and orders them based on the total consumption, limiting the output to a specified number of segments."
        },
        {
            "sample_id": 10926,
            "vt": "SELECT AVG(transactions_1k.amount) FROM transactions_1k WHERE transactions_1k.date LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average amount of transactions from the 'transactions_1k' table for a specific date. The placeholder in the WHERE clause represents the date for which the average transaction amount is being calculated."
        },
        {
            "sample_id": 10915,
            "vt": "SELECT CAST(SUM(CASE WHEN yearmonth.consumption > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(yearmonth.customerid) FROM yearmonth WHERE yearmonth.date = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average consumption of customers from the 'yearmonth' table for a specific date. It sums up the consumption values based on a condition and multiplies it by a placeholder value, then divides by the count of customers for that date. The placeholders represent numeric values for consumption thresholds and multipliers, while the date is represented as a string."
        },
        {
            "sample_id": 10901,
            "vt": "SELECT SUBSTRING(yearmonth.date, [placeholder-type:numeric], [placeholder-type:numeric]) FROM customers INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.currency = '[placeholder-type:string]' GROUP BY SUBSTRING(yearmonth.date, [placeholder-type:numeric], [placeholder-type:numeric]) ORDER BY SUM(yearmonth.consumption) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a substring of the date from the 'yearmonth' table, grouped by this substring, for customers who have a specific currency. It joins the 'customers' table with the 'yearmonth' table based on the customer ID, and orders the results by the total consumption, limiting the output to a specified number of results."
        },
        {
            "sample_id": 10951,
            "vt": "SELECT SUM(transactions_1k.price), SUM(CASE WHEN yearmonth.date = '[placeholder-type:string]' THEN transactions_1k.price ELSE [placeholder-type:numeric] END) FROM transactions_1k INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE transactions_1k.customerid = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total price of transactions from the 'transactions_1k' table, while also calculating a conditional sum based on a specific date from the 'yearmonth' table. It joins the 'gasstations' table to include gas station details and filters the results for a specific customer using a placeholder for the customer ID."
        },
        {
            "sample_id": 10934,
            "vt": "SELECT transactions_1k.customerid FROM transactions_1k WHERE transactions_1k.date = '[placeholder-type:string]' GROUP BY transactions_1k.customerid ORDER BY SUM(transactions_1k.price) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a list of unique customer IDs from the 'transactions_1k' table for a specific date. It groups the results by customer ID and orders them based on the total price of transactions, limiting the output to a specified number of customers."
        },
        {
            "sample_id": 10916,
            "vt": "SELECT CAST(SUM(CASE WHEN gasstations.segment = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(gasstations.gasstationid) FROM gasstations WHERE gasstations.country = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of a specific segment's gas station performance based on the total amount and price of transactions. It sums the amounts for gas stations that belong to a specified segment and divides it by the count of gas stations in a specified country, adjusting the result by a given multiplier."
        },
        {
            "sample_id": 10936,
            "vt": "SELECT DISTINCT customers.currency FROM transactions_1k INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE transactions_1k.date = '[placeholder-type:string]' AND transactions_1k.time = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct currency types used by customers in transactions that occurred at gas stations on a specific date and time. It combines data from the 'transactions_1k', 'gasstations', and 'customers' tables, filtering based on the transaction date and time."
        },
        {
            "sample_id": 10942,
            "vt": "SELECT transactions_1k.customerid, yearmonth.date, yearmonth.consumption FROM transactions_1k INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE transactions_1k.date = '[placeholder-type:string]' AND transactions_1k.price = [placeholder-type:numeric] AND yearmonth.date = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves customer transaction details along with their consumption data. It joins the 'transactions_1k' table with the 'yearmonth' table based on the customer ID. The query filters results based on a specific transaction date and price, as well as a specific consumption date."
        }
    ],
    "car_retails": [
        {
            "sample_id": 1587,
            "vt": "SELECT COUNT(payments.customernumber) FROM (SELECT payments.customernumber FROM payments WHERE STRFTIME('%Y', paymentDate) >= '2003' AND STRFTIME('%Y', paymentDate) <= '2004' GROUP BY customernumber HAVING COUNT(customernumber) > 3) AS t",
            "ba": "The virtual table counts the number of unique customers who made more than three payments in the years 2003 and 2004. It first filters the payments based on the payment date, grouping them by customer number, and then applies a condition to count only those customers who have more than three payments during that period."
        },
        {
            "sample_id": 1582,
            "vt": "SELECT employees.email FROM customers INNER JOIN employees AS T2 ON T1.salesRepEmployeeNumber = T2.employeeNumber WHERE employees.jobtitle = '[placeholder-type:string]' AND customers.country = '[placeholder-type:string]' GROUP BY customers.customername, employees.email ORDER BY SUM(customers.creditlimit) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the email addresses of employees who are sales representatives for customers in a specific country. It joins the 'customers' table with the 'employees' table based on the sales representative's employee number. The results are filtered by the job title of the employees and the country of the customers. The results are grouped by customer name and employee email, and ordered by the total credit limit of the customers, with a limit on the number of results returned."
        },
        {
            "sample_id": 1648,
            "vt": "SELECT customers.customername FROM products INNER JOIN orderdetails AS t2 ON t1.productCode = t2.productCode INNER JOIN orders AS t3 ON t2.orderNumber = t3.orderNumber INNER JOIN customers AS t4 ON t3.customerNumber = t4.customerNumber WHERE products.productname = '[placeholder-type:string]' ORDER BY orderdetails.priceeach LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of customers who have ordered a specific product. It joins the 'products' table with 'orderdetails' to link products to their respective orders, then connects to the 'orders' table to find the associated customers. The query filters results based on the product name and limits the number of results based on a specified numeric value."
        },
        {
            "sample_id": 1665,
            "vt": "SELECT SUM(orderdetails.ordernumber) FROM orderdetails INNER JOIN products AS t2 ON t1.productCode = t2.productCode WHERE products.productname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of orders from the 'orderdetails' table for a specific product based on its name. It joins the 'orderdetails' table with the 'products' table to filter the results by the product name provided in the placeholder."
        },
        {
            "sample_id": 1589,
            "vt": "SELECT products.productname FROM products INNER JOIN orderdetails AS T2 ON T1.productCode = T2.productCode INNER JOIN orders AS T3 ON T2.orderNumber = T3.orderNumber INNER JOIN customers AS T4 ON T3.customerNumber = T4.customerNumber WHERE products.productline = '[placeholder-type:string]' AND products.productscale = '[placeholder-type:string]' AND customers.country = '[placeholder-type:string]' GROUP BY products.productname ORDER BY SUM(orderdetails.quantityordered) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of products from the 'products' table that belong to a specific product line and scale, filtered by customers from a specified country. The query joins multiple tables: 'products', 'orderdetails', 'orders', and 'customers' to gather the necessary information. It groups the results by product name and orders them based on the total quantity ordered, with a limit on the number of results returned."
        },
        {
            "sample_id": 1666,
            "vt": "SELECT products.productname FROM orderdetails INNER JOIN products AS t2 ON t1.productCode = t2.productCode GROUP BY products.productname ORDER BY SUM(orderdetails.quantityordered) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the product names from the 'products' table that are associated with order details. It aggregates the total quantity ordered for each product and sorts them in descending order, allowing users to see the most ordered products. The placeholder in the LIMIT clause specifies the maximum number of product names to return."
        },
        {
            "sample_id": 1565,
            "vt": "SELECT DISTINCT customers.customername FROM payments INNER JOIN customers AS T2 ON T1.customerNumber = T2.customerNumber WHERE payments.amount > [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique names of customers who have made payments exceeding a specified amount. It retrieves data from the 'payments' table and joins it with the 'customers' table to ensure that only those customers who have made payments above the given threshold are included."
        },
        {
            "sample_id": 1586,
            "vt": "SELECT COUNT(customers.customernumber) FROM customers WHERE customers.creditlimit = [placeholder-type:numeric] AND customers.country = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table who have a specific credit limit and are located in a specified country. The placeholders represent the credit limit as a numeric value and the country as a string value."
        },
        {
            "sample_id": 1646,
            "vt": "SELECT employees.firstname, employees.lastname FROM offices INNER JOIN employees AS t2 ON t1.officeCode = t2.officeCode WHERE employees.jobtitle = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of employees from the 'employees' table who work in a specific office and hold a specific job title. The query joins the 'offices' table to filter employees based on their office code, and it uses a placeholder for the job title to allow users to specify which job title they are interested in."
        },
        {
            "sample_id": 1651,
            "vt": "SELECT SUM(payments.amount) FROM payments WHERE payments.customernumber = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total payment amount made by a specific customer from the 'payments' table. The placeholder in the WHERE clause represents the unique customer number associated with the payments."
        },
        {
            "sample_id": 1618,
            "vt": "SELECT productlines.textdescription FROM productlines INNER JOIN products AS t2 ON t1.productLine = t2.productLine WHERE products.productcode = '[placeholder-type:string]'",
            "ba": "The virtual table describes the text description of product lines from the 'productlines' table that are associated with a specific product code from the 'products' table. The placeholder in the WHERE clause represents the unique product code."
        },
        {
            "sample_id": 1558,
            "vt": "SELECT COUNT(DISTINCT T1.orderNumber) FROM orderdetails INNER JOIN orders AS T2 ON T1.orderNumber = T2.orderNumber WHERE orderdetails.quantityordered < [placeholder-type:numeric] AND STRFTIME('%Y', orders.orderdate) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct order numbers from the 'orderdetails' table that meet specific criteria. It joins the 'orderdetails' table with the 'orders' table to access the order date. The query filters the results to include only those orders where the quantity ordered is less than a specified numeric value and the order date falls within a specified year, represented by a string placeholder."
        },
        {
            "sample_id": 1598,
            "vt": "SELECT AVG(payments.amount) FROM payments WHERE payments.paymentdate BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average payment amount from the 'payments' table for a specified date range. The placeholders represent the start and end dates for filtering the payments made within that period."
        },
        {
            "sample_id": 1573,
            "vt": "SELECT employees.email FROM employees INNER JOIN offices AS T2 ON T1.officeCode = T2.officeCode WHERE employees.reportsto = [placeholder-type:numeric] AND offices.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the email addresses of employees from the 'employees' table who report to a specific manager and work in a specified city. The query joins the 'employees' table with the 'offices' table to filter based on the office location."
        },
        {
            "sample_id": 1551,
            "vt": "SELECT DISTINCT customers.country, customers.addressline1, customers.addressline2 FROM payments INNER JOIN customers AS T2 ON T1.customerNumber = T2.customerNumber ORDER BY payments.amount LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of countries along with their corresponding address lines from the 'customers' table, filtered by payment records. It joins the 'payments' table with the 'customers' table based on the customer number, ensuring that only customers who have made payments are included. The results are ordered by the payment amount, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 1544,
            "vt": "SELECT customers.country, COUNT(customers.customernumber) FROM customers GROUP BY customers.country",
            "ba": "The virtual table summarizes the number of customers from each country by counting the unique customer numbers in the 'customers' table, grouped by the country field."
        },
        {
            "sample_id": 1624,
            "vt": "SELECT employees.email FROM employees WHERE employees.jobtitle = '[placeholder-type:string]'",
            "ba": "The virtual table describes the email addresses of employees from the 'employees' table who hold a specific job title. The placeholder in the WHERE clause represents the job title of the employees."
        },
        {
            "sample_id": 1649,
            "vt": "SELECT SUM(CASE WHEN customers.customername = '[placeholder-type:string]' THEN payments.amount ELSE [placeholder-type:numeric] END) * [placeholder-type:numeric] / SUM(payments.amount) FROM customers INNER JOIN payments AS t2 ON t1.customerNumber = t2.customerNumber WHERE STRFTIME('%Y', payments.paymentdate) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted sum of payments made by a specific customer over a given year. It sums the payment amounts for the specified customer and multiplies it by a placeholder numeric value, then divides this by the total sum of all payments made in that year. The query joins the 'customers' and 'payments' tables to correlate customer data with their payment records, filtering results based on the payment date's year."
        },
        {
            "sample_id": 1635,
            "vt": "SELECT products.productname FROM orderdetails INNER JOIN orders AS t2 ON t1.orderNumber = t2.orderNumber INNER JOIN customers AS t3 ON t2.customerNumber = t3.customerNumber INNER JOIN products AS t4 ON t1.productCode = t4.productCode WHERE customers.customername = '[placeholder-type:string]' ORDER BY orderdetails.priceeach * orderdetails.quantityordered LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the product names from the 'products' table that are associated with orders made by a specific customer. It joins multiple tables: 'orderdetails' to get the details of each order, 'orders' to link orders to customers, and 'customers' to filter by a specific customer's name. The results are ordered by the total price of each order (calculated as the product of quantity ordered and price each), and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 1628,
            "vt": "SELECT COUNT(customers.customernumber) FROM customers INNER JOIN employees AS t2 ON t1.salesRepEmployeeNumber = t2.employeeNumber WHERE employees.firstname = '[placeholder-type:string]' AND employees.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of customers associated with a specific sales representative from the 'employees' table. It uses an inner join to link the 'customers' table with the 'employees' table based on the sales representative's employee number. The placeholders in the WHERE clause represent the first and last names of the sales representative."
        },
        {
            "sample_id": 1569,
            "vt": "SELECT COUNT(customers.country) FROM orders INNER JOIN customers AS T2 ON T1.customerNumber = T2.customerNumber WHERE orders.status = '[placeholder-type:string]' AND customers.country = '[placeholder-type:string]' GROUP BY customers.customernumber HAVING COUNT(orders.status) = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of customers from a specific country who have placed a certain number of orders with a specified status. It joins the 'orders' table with the 'customers' table based on the customer number, filters the results by order status and customer country, and groups the results by customer number to ensure that only those customers who meet the order count criteria are included."
        },
        {
            "sample_id": 1647,
            "vt": "SELECT employees.firstname, employees.lastname, employees.reportsto FROM offices INNER JOIN employees AS t2 ON t1.officeCode = t2.officeCode WHERE offices.country = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of employees along with their reporting structure from the 'employees' table, filtered by the country of the office they belong to. The placeholder in the WHERE clause represents the country name."
        },
        {
            "sample_id": 1555,
            "vt": "SELECT customers.customername, customers.contactfirstname, customers.contactlastname, SUM(payments.amount) FROM employees INNER JOIN customers AS T2 ON T2.salesRepEmployeeNumber = T1.employeeNumber INNER JOIN payments AS T3 ON T2.customerNumber = T3.customerNumber INNER JOIN offices AS T4 ON T1.officeCode = T4.officeCode WHERE offices.city = '[placeholder-type:string]' AND employees.reportsto = [placeholder-type:numeric] GROUP BY customers.customername, customers.contactfirstname, customers.contactlastname ORDER BY payments.amount LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes customer information along with the total payment amounts made by each customer. It retrieves the customer's name, contact first name, and contact last name from the 'customers' table, and calculates the total payment amount from the 'payments' table. The data is filtered based on the office's city and the reporting structure of employees, ensuring that only relevant customers associated with a specific employee and office location are included. The results are grouped by customer details and ordered by the total payment amount, with a limit on the number of results returned."
        },
        {
            "sample_id": 1644,
            "vt": "SELECT employees.firstname, employees.lastname FROM orders INNER JOIN customers AS t2 ON t1.customerNumber = t2.customerNumber INNER JOIN employees AS t3 ON t2.salesRepEmployeeNumber = t3.employeeNumber WHERE orders.status = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of employees who are associated with orders that have a specific status. It combines data from the 'orders', 'customers', and 'employees' tables, filtering based on the order status provided by the user."
        },
        {
            "sample_id": 1634,
            "vt": "SELECT products.productname FROM orderdetails INNER JOIN orders AS t2 ON t1.orderNumber = t2.orderNumber INNER JOIN customers AS t3 ON t2.customerNumber = t3.customerNumber INNER JOIN products AS t4 ON t1.productCode = t4.productCode WHERE customers.customername = '[placeholder-type:string]' AND orders.orderdate = '[placeholder-type:string]'",
            "ba": "The virtual table describes the product names from the 'products' table that are associated with specific orders made by a customer. It retrieves this information by joining the 'orderdetails', 'orders', 'customers', and 'products' tables. The placeholders in the WHERE clause represent the customer's name and the order date, allowing users to filter results based on these criteria."
        },
        {
            "sample_id": 1545,
            "vt": "SELECT DISTINCT products.productvendor, products.msrp - products.buyprice FROM products INNER JOIN orderdetails AS T2 ON T1.productCode = T2.productCode GROUP BY products.productvendor, products.msrp, products.buyprice ORDER BY COUNT(orderdetails.quantityordered) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the profit margins for each product vendor by calculating the difference between the Manufacturer Suggested Retail Price (MSRP) and the buy price from vendors. It aggregates the data from the 'products' table and joins it with the 'orderdetails' table to count the number of orders for each product vendor. The results are grouped by product vendor and ordered by the count of ordered quantities, with a limit on the number of results returned."
        },
        {
            "sample_id": 1547,
            "vt": "SELECT orderdetails.priceeach * orderdetails.quantityordered FROM customers INNER JOIN orders AS T2 ON T1.customerNumber = T2.customerNumber INNER JOIN orderdetails AS T3 ON T2.orderNumber = T3.orderNumber WHERE customers.customername = '[placeholder-type:string]' AND orders.status = '[placeholder-type:string]' AND STRFTIME('%Y', orders.shippeddate) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total price of ordered products for a specific customer based on their name, the status of the orders, and the year in which the orders were shipped. It combines data from the 'customers', 'orders', and 'orderdetails' tables to achieve this."
        },
        {
            "sample_id": 1613,
            "vt": "SELECT SUM(orderdetails.quantityordered) FROM orderdetails INNER JOIN (SELECT t1.productCode FROM products AS t1 ORDER BY t1.MSRP - t1.buyPrice DESC LIMIT 1) AS t3 ON t2.productCode = t3.productCode",
            "ba": "The virtual table calculates the total quantity ordered for the product that has the highest expected profit, which is determined by the difference between the Manufacturer Suggested Retail Price (MSRP) and the buy price from vendors."
        },
        {
            "sample_id": 1612,
            "vt": "SELECT orders.orderdate FROM orderdetails INNER JOIN orders AS T2 ON T1.orderNumber = T2.orderNumber WHERE STRFTIME('%Y-%m-%d', orders.orderdate) = '[placeholder-type:string]' OR STRFTIME('%Y-%m-%d', orders.orderdate) = '[placeholder-type:string]' ORDER BY orderdetails.quantityordered * orderdetails.priceeach LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the order dates from the 'orders' table based on specific date conditions. It joins the 'orderdetails' table to access details about the orders, specifically filtering for orders that match either of the two specified dates. The results are ordered by the total price of the ordered items, calculated as the product of quantity ordered and price for each item, and limited to a specified number of results."
        },
        {
            "sample_id": 1564,
            "vt": "SELECT COUNT(employees.officecode) FROM employees WHERE employees.jobtitle = '[placeholder-type:string]' AND employees.officecode = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of employees in a specific office who hold a particular job title. The placeholders represent the job title and the office code, allowing users to specify their criteria for the count."
        },
        {
            "sample_id": 1626,
            "vt": "SELECT employees.email FROM customers INNER JOIN employees AS t2 ON t1.salesRepEmployeeNumber = t2.employeeNumber WHERE customers.customername = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the email addresses of employees who are sales representatives for a specific customer. It joins the 'customers' table with the 'employees' table based on the sales representative's employee number, filtering the results by the customer's name."
        },
        {
            "sample_id": 1606,
            "vt": "SELECT SUM(products.msrp - products.buyprice) FROM productlines INNER JOIN products AS T2 ON T1.productLine = T2.productLine WHERE products.productvendor = '[placeholder-type:string]' AND productlines.textdescription LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total expected profits from products based on their MSRP and buy price. It joins the 'productlines' table with the 'products' table to filter products by vendor and a specific text description of the product line."
        },
        {
            "sample_id": 1553,
            "vt": "SELECT products.productname FROM products INNER JOIN orderdetails AS T2 ON T1.productCode = T2.productCode WHERE products.productscale = '[placeholder-type:string]' AND products.productline = '[placeholder-type:string]' GROUP BY products.productname ORDER BY SUM(orderdetails.quantityordered) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of products from the 'products' table that belong to a specific product scale and product line. It joins the 'products' table with the 'orderdetails' table to aggregate the total quantity ordered for each product. The results are grouped by product name and ordered by the total quantity ordered, with a limit on the number of results returned."
        },
        {
            "sample_id": 1566,
            "vt": "SELECT SUM(payments.amount) FROM payments INNER JOIN customers AS T2 ON T1.customerNumber = T2.customerNumber WHERE customers.country = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total payment amounts made by customers from a specific country. It combines data from the 'payments' and 'customers' tables, filtering the results based on the country of the customers."
        },
        {
            "sample_id": 1574,
            "vt": "SELECT employees.email, employees.employeenumber FROM employees INNER JOIN offices AS T2 ON T1.officeCode = T2.officeCode WHERE offices.state = '[placeholder-type:string]' AND offices.country = '[placeholder-type:string]'",
            "ba": "The virtual table describes the email addresses and employee numbers of employees from the 'employees' table who work in offices located in a specific state and country. The placeholders in the WHERE clause represent the state and country of the office."
        },
        {
            "sample_id": 1636,
            "vt": "SELECT orders.shippeddate FROM orders INNER JOIN customers AS t2 ON t1.customerNumber = t2.customerNumber WHERE customers.customername = '[placeholder-type:string]' AND orders.orderdate = '[placeholder-type:string]'",
            "ba": "The virtual table provides the shipped dates of orders from the 'orders' table that are associated with a specific customer name from the 'customers' table. The placeholders in the WHERE clause represent the customer's name and the order date."
        },
        {
            "sample_id": 1550,
            "vt": "SELECT CAST(SUM(payments.amount) AS FLOAT) / [placeholder-type:numeric], MAX(payments.amount), MIN(payments.amount) FROM payments INNER JOIN customers AS T2 ON T1.customerNumber = T2.customerNumber WHERE payments.paymentdate BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average, maximum, and minimum payment amounts from the 'payments' table, filtered by a specific date range. It joins the 'payments' table with the 'customers' table to ensure that the payments are associated with valid customers. The placeholders represent the numeric divisor for calculating the average and the date range for filtering the payments."
        },
        {
            "sample_id": 1596,
            "vt": "SELECT customers.addressline1, customers.addressline2, customers.phone FROM orderdetails INNER JOIN orders AS T2 ON T1.orderNumber = T2.orderNumber INNER JOIN customers AS T3 ON T2.customerNumber = T3.customerNumber INNER JOIN employees AS T4 ON T3.salesRepEmployeeNumber = T4.employeeNumber INNER JOIN offices AS T5 ON T4.officeCode = T5.officeCode WHERE STRFTIME('%Y', orders.orderdate) = '[placeholder-type:string]' AND employees.jobtitle = '[placeholder-type:string]' ORDER BY orderdetails.quantityordered LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a view of customer addresses and phone numbers associated with specific orders. It combines data from multiple tables: 'orderdetails', 'orders', 'customers', 'employees', and 'offices'. The query filters results based on the year of the order date and the job title of the sales representative, allowing users to focus on specific criteria. The results are ordered by the quantity of items ordered, with a limit on the number of records returned."
        },
        {
            "sample_id": 1579,
            "vt": "SELECT payments.customernumber FROM payments ORDER BY payments.amount LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the customer numbers from the 'payments' table, sorted by the payment amount in ascending order, and limits the results to a specified number of entries."
        },
        {
            "sample_id": 1621,
            "vt": "SELECT products.productname FROM orderdetails INNER JOIN orders AS t2 ON t1.orderNumber = t2.orderNumber INNER JOIN products AS t3 ON t1.productCode = t3.productCode WHERE orders.customernumber = '[placeholder-type:string]' ORDER BY orders.orderdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of products from the 'products' table that are associated with orders made by a specific customer. It joins the 'orderdetails' table with the 'orders' table to link orders to their details, and then further joins with the 'products' table to retrieve product names. The results are filtered by the customer's unique identifier and ordered by the order date, with a limit on the number of results returned."
        },
        {
            "sample_id": 1595,
            "vt": "SELECT SUM(orderdetails.priceeach - products.buyprice) FROM products INNER JOIN orderdetails AS T2 ON T1.productCode = T2.productCode INNER JOIN orders AS T3 ON T2.orderNumber = T3.orderNumber INNER JOIN customers AS T4 ON T3.customerNumber = T4.customerNumber WHERE orders.orderdate > '[placeholder-type:string]' AND orders.orderdate < '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total profit from products sold within a specific date range. It does this by summing the difference between the selling price of each product (from order details) and the buying price (from products). The query joins multiple tables: 'products' to get product details, 'orderdetails' to find out how many of each product was sold, 'orders' to filter by order date, and 'customers' to link orders to customers. The placeholders represent the start and end dates for filtering the orders."
        },
        {
            "sample_id": 1669,
            "vt": "SELECT SUM(orderdetails.priceeach * orderdetails.quantityordered) FROM customers INNER JOIN orders AS t2 ON t1.customerNumber = t2.customerNumber INNER JOIN orderdetails AS t3 ON t2.orderNumber = t3.orderNumber INNER JOIN products AS t4 ON t3.productCode = t4.productCode WHERE products.productline = '[placeholder-type:string]' AND customers.customername = '[placeholder-type:string]' AND orders.status = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total sales amount for a specific product line sold to a specific customer, filtered by the order status. It combines data from multiple tables: 'customers', 'orders', 'orderdetails', and 'products'. The placeholders represent the product line, customer name, and order status that can be specified by the user."
        },
        {
            "sample_id": 1645,
            "vt": "SELECT CAST(COUNT(CASE WHEN offices.city = '[placeholder-type:string]' THEN employees.employeenumber ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(employees.employeenumber) FROM offices INNER JOIN employees AS t2 ON t1.officeCode = t2.officeCode",
            "ba": "The virtual table calculates the proportion of employees in a specific city compared to the total number of employees, adjusted by a numeric factor. It does this by counting the number of employees whose office is located in the specified city and dividing it by the total count of employees, then multiplying by a placeholder for a numeric value."
        },
        {
            "sample_id": 1609,
            "vt": "SELECT COUNT(orderdetails.productcode) FROM orderdetails WHERE orderdetails.ordernumber = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of the number of products associated with a specific order from the 'orderdetails' table. The placeholder in the WHERE clause represents the unique order number for which the product count is being requested."
        },
        {
            "sample_id": 1654,
            "vt": "SELECT customers.contactfirstname, customers.contactlastname FROM employees INNER JOIN customers AS t2 ON t1.employeeNumber = t2.salesRepEmployeeNumber WHERE employees.employeenumber = '[placeholder-type:string]' ORDER BY customers.creditlimit LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of customers who are represented by a specific employee. It retrieves this information by joining the 'employees' table with the 'customers' table based on the sales representative's employee number. The results are ordered by the customers' credit limit and limited to a specified number of entries."
        },
        {
            "sample_id": 1559,
            "vt": "SELECT SUM(orderdetails.quantityordered * orderdetails.priceeach) FROM orderdetails INNER JOIN orders AS T2 ON T1.orderNumber = T2.orderNumber WHERE orders.status = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total revenue generated from orders based on their status by summing the product of quantity ordered and price for each product in the order details. It joins the 'orderdetails' table with the 'orders' table to filter the results according to the specified order status."
        },
        {
            "sample_id": 1562,
            "vt": "SELECT COUNT(orderdetails.productcode) FROM orderdetails INNER JOIN products AS T2 ON T1.productCode = T2.productCode WHERE products.msrp - products.buyprice > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of product codes from the 'orderdetails' table that are associated with products having a profit margin greater than a specified value. The profit margin is calculated as the difference between the Manufacturer Suggested Retail Price (msrp) and the buy price from vendors (buyprice)."
        },
        {
            "sample_id": 1567,
            "vt": "SELECT SUM(payments.amount) FROM payments WHERE STRFTIME('%Y', payments.paymentdate) = '[placeholder-type:string]' AND customers.customernumber IN (SELECT customers.customernumber FROM customers WHERE creditLimit = 0)",
            "ba": "The virtual table calculates the total amount of payments made by customers who have a credit limit of zero for a specific year. It filters the payments based on the payment date's year and checks the customers' credit limit."
        },
        {
            "sample_id": 1657,
            "vt": "SELECT SUM(orderdetails.quantityordered) FROM orders INNER JOIN orderdetails AS t2 ON t1.orderNumber = t2.orderNumber INNER JOIN products AS t3 ON t2.productCode = t3.productCode WHERE products.productline = '[placeholder-type:string]' AND STRFTIME('%Y', orders.orderdate) = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total quantity of products ordered from a specific product line during a specified year. It combines data from the 'orders', 'orderdetails', and 'products' tables, filtering results based on the product line and the year of the order date."
        },
        {
            "sample_id": 1576,
            "vt": "SELECT employees.email, offices.country FROM customers INNER JOIN employees AS T2 ON T1.salesRepEmployeeNumber = T2.employeeNumber INNER JOIN offices AS T3 ON T2.officeCode = T3.officeCode WHERE offices.country = '[placeholder-type:string]' AND customers.creditlimit < [placeholder-type:numeric] AND employees.jobtitle = '[placeholder-type:string]'",
            "ba": "The virtual table provides a view of the email addresses of employees and the countries of their respective offices. It filters the results based on the country of the office, the credit limit of customers, and the job title of employees. The placeholders allow users to specify the desired country, credit limit, and job title for their query."
        },
        {
            "sample_id": 1607,
            "vt": "SELECT customers.customernumber FROM customers INNER JOIN payments AS T2 ON T1.customerNumber = T2.customerNumber WHERE customers.city = '[placeholder-type:string]' GROUP BY customers.customernumber ORDER BY SUM(payments.amount) / COUNT(payments.paymentdate) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a list of unique customer numbers from the 'customers' table, filtering by a specific city. It joins the 'payments' table to calculate the average payment amount for each customer based on their payment history. The results are grouped by customer number and ordered by the average payment amount, with a limit on the number of results returned."
        },
        {
            "sample_id": 1638,
            "vt": "SELECT products.productname, products.msrp - products.buyprice FROM products WHERE products.productline = '[placeholder-type:string]' ORDER BY products.msrp - products.buyprice LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the product names along with their expected profits, calculated as the difference between the Manufacturer Suggested Retail Price (MSRP) and the buy price from vendors. It filters the results based on a specific product line and orders them by the expected profit, limiting the number of results returned."
        },
        {
            "sample_id": 1570,
            "vt": "SELECT SUM(orderdetails.quantityordered * orderdetails.priceeach) / COUNT(orders.ordernumber) FROM customers INNER JOIN orders AS T2 ON T1.customerNumber = T2.customerNumber INNER JOIN orderdetails AS T3 ON T2.orderNumber = T3.orderNumber WHERE orders.status = '[placeholder-type:string]' AND customers.country = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average total order value for customers based on their country and the status of their orders. It sums the total price of ordered items by multiplying the quantity ordered by the price for each item, and then divides this sum by the count of orders to find the average. The query involves joining the 'customers', 'orders', and 'orderdetails' tables to gather the necessary data, applying filters for order status and customer country."
        },
        {
            "sample_id": 1662,
            "vt": "SELECT employees.firstname, employees.lastname, SUM(orderdetails.quantityordered) FROM products INNER JOIN orderdetails AS t2 ON t1.productCode = t2.productCode INNER JOIN orders AS t3 ON t2.orderNumber = t3.orderNumber INNER JOIN customers AS t4 ON t3.customerNumber = t4.customerNumber INNER JOIN employees AS t5 ON t4.salesRepEmployeeNumber = t5.employeeNumber WHERE products.productname = '[placeholder-type:string]' GROUP BY employees.lastname, employees.firstname",
            "ba": "The virtual table summarizes the total quantity of a specific product ordered by each employee's first and last name. It combines data from multiple tables including 'products', 'orderdetails', 'orders', 'customers', and 'employees'. The placeholder in the WHERE clause represents the name of the product being queried."
        },
        {
            "sample_id": 1577,
            "vt": "SELECT DISTINCT employees.email FROM customers INNER JOIN employees AS T2 ON T1.salesRepEmployeeNumber = T2.employeeNumber WHERE employees.jobtitle = '[placeholder-type:string]' AND customers.country = '[placeholder-type:string]' ORDER BY customers.creditlimit LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct email addresses of employees who are sales representatives for customers in a specific country. The query filters employees based on their job title and customers based on their country, ensuring that only relevant records are selected. The results are ordered by the customers' credit limit, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 1608,
            "vt": "SELECT SUM(orderdetails.quantityordered), SUM(orderdetails.quantityordered * orderdetails.priceeach) / SUM(orderdetails.quantityordered) FROM products INNER JOIN orderdetails AS T2 ON T1.productCode = T2.productCode WHERE products.productname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total quantity ordered and the average price for a specific product from the 'products' and 'orderdetails' tables. The placeholder in the WHERE clause represents the name of the product being queried."
        },
        {
            "sample_id": 1637,
            "vt": "SELECT COUNT(orders.customernumber) FROM orderdetails INNER JOIN orders AS T2 ON T1.orderNumber = T2.orderNumber WHERE orderdetails.productcode IN (SELECT products.productcode FROM products WHERE productName = '1957 Chevy Pickup')",
            "ba": "The virtual table counts the number of unique customers who have placed orders for a specific product, identified by its name. It does this by joining the 'orderdetails' table with the 'orders' table to link order details to the corresponding orders. A subquery is used to filter the product codes based on the product name provided, ensuring that only orders for the specified product are counted."
        },
        {
            "sample_id": 1640,
            "vt": "SELECT COUNT(CASE WHEN JULIANDAY(t1.shippeddate) - JULIANDAY(t1.requireddate) > [placeholder-type:numeric] THEN orders.customernumber ELSE NULL END) FROM orders INNER JOIN orderdetails AS T2 ON T1.orderNumber = T2.orderNumber WHERE orders.status = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers who have orders that were shipped later than the required date by a specified number of days. It joins the 'orders' table with the 'orderdetails' table to access the necessary order information and applies a filter based on the order status."
        },
        {
            "sample_id": 1601,
            "vt": "SELECT payments.paymentdate FROM employees INNER JOIN customers AS T2 ON T1.employeeNumber = T2.salesRepEmployeeNumber INNER JOIN payments AS T3 ON T2.customerNumber = T3.customerNumber WHERE employees.firstname = '[placeholder-type:string]' AND employees.lastname = '[placeholder-type:string]' AND employees.jobtitle = '[placeholder-type:string]' ORDER BY customers.creditlimit LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the payment dates associated with customers handled by a specific employee. It joins the 'employees' table with the 'customers' table based on the sales representative's employee number, and then further joins with the 'payments' table to get the relevant payment information. The query filters results based on the first name, last name, and job title of the employee, and orders the results by the customer's credit limit, limiting the number of results returned."
        },
        {
            "sample_id": 1594,
            "vt": "SELECT products.productname, orderdetails.quantityordered * orderdetails.priceeach FROM orderdetails INNER JOIN products AS T2 ON T1.productCode = T2.productCode INNER JOIN orders AS T3 ON T1.orderNumber = T3.orderNumber INNER JOIN customers AS T4 ON T3.customerNumber = T4.customerNumber WHERE customers.city = '[placeholder-type:string]' AND customers.salesrepemployeenumber IN (SELECT employees.employeenumber FROM employees WHERE jobTitle = 'Sales Rep') ORDER BY orderdetails.quantityordered LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the product names and total prices of ordered products from the 'orderdetails' table, filtered by customers located in a specific city and whose sales representatives hold the job title 'Sales Rep'. The placeholders represent the city name and the limit on the number of results returned."
        },
        {
            "sample_id": 1667,
            "vt": "SELECT customers.customername FROM customers INNER JOIN orders AS t2 ON t1.customerNumber = t2.customerNumber WHERE orders.status = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of customers from the 'customers' table who have placed orders with a specific status. The query joins the 'customers' table with the 'orders' table based on the customer number, allowing us to filter the results based on the order status."
        },
        {
            "sample_id": 1643,
            "vt": "SELECT employees.firstname, employees.lastname FROM offices INNER JOIN employees AS T2 ON T1.officeCode = T2.officeCode WHERE employees.employeenumber = (SELECT MAX(employees.employeenumber) FROM employees)",
            "ba": "The virtual table describes the first and last names of the employee who has the highest employee number from the 'employees' table, along with their associated office information from the 'offices' table. The query uses an inner join to connect the 'offices' and 'employees' tables based on the office code, ensuring that only the relevant employee's details are retrieved."
        },
        {
            "sample_id": 1639,
            "vt": "SELECT customers.customername FROM orders INNER JOIN customers AS t2 ON t1.customerNumber = t2.customerNumber WHERE orders.status = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of customers who have placed orders with a specific status. It retrieves data from the 'customers' table and joins it with the 'orders' table based on the customer number. The placeholder in the WHERE clause represents the order status being queried."
        },
        {
            "sample_id": 1588,
            "vt": "SELECT SUM(orderdetails.priceeach - products.buyprice) / COUNT(*) FROM orderdetails INNER JOIN products AS T2 ON T1.productCode = T2.productCode WHERE products.productname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average profit margin for a specific product by subtracting the buy price from the selling price for each order detail and then averaging these values."
        },
        {
            "sample_id": 1623,
            "vt": "SELECT employees.firstname, employees.lastname FROM employees INNER JOIN employees AS t2 ON t2.employeeNumber = t1.reportsTo WHERE employees.firstname = '[placeholder-type:string]' AND employees.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of employees who report to a specific manager within the 'employees' table. The placeholders in the WHERE clause represent the first and last names of the employee being queried."
        },
        {
            "sample_id": 1571,
            "vt": "SELECT employees.firstname, employees.lastname FROM employees INNER JOIN offices AS T2 ON T1.officeCode = T2.officeCode WHERE offices.city = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of employees from the 'employees' table who work in a specific city. The query joins the 'employees' table with the 'offices' table to filter employees based on the city they are located in, using a placeholder for the city name."
        },
        {
            "sample_id": 1614,
            "vt": "SELECT payments.amount FROM payments INNER JOIN customers AS t2 ON t1.customerNumber = t2.customerNumber WHERE customers.customername = '[placeholder-type:string]' AND payments.paymentdate = '[placeholder-type:string]'",
            "ba": "The virtual table displays the payment amounts from the 'payments' table for a specific customer based on their name and the date of the payment. The query joins the 'payments' table with the 'customers' table to filter results according to the customer's name and the payment date."
        },
        {
            "sample_id": 1603,
            "vt": "SELECT customers.addressline1, customers.addressline2 FROM customers INNER JOIN orders AS T2 ON T1.customerNumber = T2.customerNumber WHERE orders.shippeddate = '[placeholder-type:string]' AND orders.status = '[placeholder-type:string]'",
            "ba": "The virtual table provides the address details of customers who have placed orders that were shipped on a specific date and have a particular status. The placeholders in the WHERE clause represent the shipped date and the order status."
        },
        {
            "sample_id": 1580,
            "vt": "SELECT employees.email, employees.employeenumber FROM employees INNER JOIN offices AS T2 ON T1.officeCode = T2.officeCode WHERE offices.country = '[placeholder-type:string]' AND offices.state = '[placeholder-type:string]' GROUP BY employees.email, employees.officecode",
            "ba": "The virtual table retrieves the email addresses and unique employee numbers of employees who work in offices located in a specific country and state. The query joins the 'employees' table with the 'offices' table based on the office code, filtering results based on the specified country and state."
        },
        {
            "sample_id": 1561,
            "vt": "SELECT COUNT(orderdetails.productcode) FROM orderdetails INNER JOIN products AS T2 ON T1.productCode = T2.productCode WHERE products.productline = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of products sold from the 'orderdetails' table, specifically filtering by the product line from the 'products' table. The placeholder in the WHERE clause represents the specific product line being queried."
        },
        {
            "sample_id": 1591,
            "vt": "SELECT MAX(orderdetails.quantityordered * orderdetails.priceeach) - AVG(orderdetails.priceeach) FROM orderdetails WHERE products.productcode IN (SELECT products.productcode FROM products WHERE productLine = 'Planes')",
            "ba": "The virtual table calculates the difference between the maximum total price of ordered products in the 'orderdetails' table and the average price of those products. The total price is determined by multiplying the quantity ordered by the price for each product. The query specifically focuses on products that belong to the 'Planes' product line."
        },
        {
            "sample_id": 1620,
            "vt": "SELECT COUNT(customers.customernumber) FROM customers INNER JOIN employees AS t2 ON t1.salesRepEmployeeNumber = t2.employeeNumber WHERE customers.country = '[placeholder-type:string]' AND employees.firstname = '[placeholder-type:string]' AND employees.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table who are associated with a specific sales representative from the 'employees' table. The query filters customers based on their country and the first and last names of the sales representative."
        },
        {
            "sample_id": 1615,
            "vt": "SELECT customers.contactfirstname, customers.contactlastname FROM payments INNER JOIN customers AS t2 ON t1.customerNumber = t2.customerNumber WHERE payments.checknumber = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of contacts from the 'customers' table who have made a payment identified by a specific check number. The placeholder in the WHERE clause represents the check number used to filter the results."
        },
        {
            "sample_id": 1581,
            "vt": "SELECT employees.firstname, employees.lastname FROM employees INNER JOIN offices AS T2 ON T1.officeCode = T2.officeCode WHERE offices.city = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of employees from the 'employees' table who work in a specific city. The query joins the 'employees' table with the 'offices' table to filter employees based on the city they are located in, using a placeholder for the city name."
        },
        {
            "sample_id": 1602,
            "vt": "SELECT employees.reportsto FROM employees INNER JOIN customers AS T2 ON T1.employeeNumber = T2.salesRepEmployeeNumber WHERE customers.country = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the reporting structure of employees who are sales representatives for customers located in a specific country. It joins the 'employees' table with the 'customers' table to filter based on the country of the customers."
        }
    ],
    "music_platform_2": [
        {
            "sample_id": 7920,
            "vt": "SELECT podcasts.itunes_id, podcasts.itunes_url FROM podcasts WHERE podcasts.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the iTunes ID and iTunes URL of a podcast from the 'podcasts' table based on a specific podcast title. The placeholder in the WHERE clause represents the title of the podcast being queried."
        },
        {
            "sample_id": 7960,
            "vt": "SELECT DISTINCT reviews.title FROM categories INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE categories.category = '[placeholder-type:string]' AND reviews.rating > [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct titles of podcast reviews from the 'reviews' table that belong to a specific category and have a rating greater than a specified value. The query joins the 'categories' table with the 'reviews' table based on the podcast_id, filtering results based on the category and rating criteria."
        },
        {
            "sample_id": 7977,
            "vt": "SELECT AVG(reviews.rating) FROM podcasts INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE podcasts.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rating of a specific podcast from the 'podcasts' table by joining it with the 'reviews' table. The placeholder in the WHERE clause represents the title of the podcast for which the average rating is being calculated."
        },
        {
            "sample_id": 7962,
            "vt": "SELECT categories.category, podcasts.itunes_url FROM categories INNER JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id WHERE podcasts.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the categories and iTunes URLs of podcasts from the 'categories' and 'podcasts' tables. It retrieves the category of a podcast along with its iTunes URL based on a specific podcast title provided as a placeholder."
        },
        {
            "sample_id": 7941,
            "vt": "SELECT AVG(reviews.rating) FROM categories INNER JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id INNER JOIN reviews AS T3 ON T3.podcast_id = T2.podcast_id WHERE podcasts.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rating of podcast reviews from the 'reviews' table, filtered by the title of the podcast from the 'podcasts' table. It joins the 'categories' table to associate each podcast with its respective category, ensuring that only relevant podcasts are considered in the average rating calculation. The placeholder in the WHERE clause represents the title of the podcast for which the average rating is being queried."
        },
        {
            "sample_id": 7970,
            "vt": "SELECT categories.category FROM categories INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE reviews.rating = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the categories of podcasts from the 'categories' table that have received a specific rating in their reviews. It uses an inner join to connect the 'categories' table with the 'reviews' table based on the podcast_id, ensuring that only categories associated with reviews of a certain rating are selected."
        },
        {
            "sample_id": 7982,
            "vt": "SELECT COUNT(reviews.content) FROM podcasts INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE podcasts.title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of reviews for a specific podcast title from the 'podcasts' table. It joins the 'podcasts' table with the 'reviews' table based on the podcast ID, filtering the results to only include reviews for the specified podcast title."
        },
        {
            "sample_id": 7983,
            "vt": "SELECT COUNT(reviews.created_at) FROM podcasts INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE podcasts.title = '[placeholder-type:string]' AND reviews.created_at LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of reviews created for a specific podcast title within a specified time frame. It joins the 'podcasts' table with the 'reviews' table based on the podcast ID, filtering results by the podcast title and the creation date of the reviews."
        },
        {
            "sample_id": 7967,
            "vt": "SELECT podcasts.title FROM categories INNER JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id WHERE categories.category = '[placeholder-type:string]' ORDER BY LENGTH(podcasts.title) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of podcasts from the 'podcasts' table that belong to a specific category. The query uses an inner join between the 'categories' and 'podcasts' tables to match podcasts with their respective categories. The placeholder in the WHERE clause represents the category name, and the results are ordered by the length of the podcast titles, limiting the output to a specified number of titles."
        },
        {
            "sample_id": 7973,
            "vt": "SELECT categories.category FROM categories INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id GROUP BY categories.category ORDER BY COUNT(reviews.podcast_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the categories of podcasts based on the number of reviews they have received. It joins the 'categories' table with the 'reviews' table to count how many reviews each category has, grouping the results by category and ordering them by the count of reviews. The placeholder in the LIMIT clause allows for specifying the maximum number of categories to return."
        },
        {
            "sample_id": 7938,
            "vt": "SELECT reviews.content FROM reviews WHERE podcasts.podcast_id = (SELECT podcasts.podcast_id FROM podcasts WHERE title = 'StormCast: The Official Warhammer Age of Sigmar Podcast')",
            "ba": "The virtual table retrieves the content of reviews for a specific podcast titled 'StormCast: The Official Warhammer Age of Sigmar Podcast'. It does this by first identifying the podcast's unique ID from the 'podcasts' table based on the title, and then using that ID to filter the relevant reviews from the 'reviews' table."
        },
        {
            "sample_id": 7930,
            "vt": "SELECT podcasts.podcast_id, reviews.created_at, reviews.title, reviews.rating FROM podcasts INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id ORDER BY reviews.created_at LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique podcast identifiers, the creation date and time of the reviews, the titles of the reviews, and their ratings from the 'podcasts' and 'reviews' tables. It joins these two tables based on the podcast ID, ensuring that only reviews corresponding to existing podcasts are included. The results are ordered by the review creation date, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 7934,
            "vt": "SELECT AVG(reviews.rating) FROM podcasts INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id GROUP BY podcasts.podcast_id ORDER BY COUNT(reviews.content) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average rating of podcasts from the 'podcasts' table by joining it with the 'reviews' table. It groups the results by each podcast's unique identifier and orders them based on the count of reviews associated with each podcast. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 7943,
            "vt": "SELECT SUM(runs.reviews_added) FROM runs WHERE runs.run_at LIKE '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total number of reviews added during podcast review runs that occurred at a specific date and time. The placeholder in the WHERE clause allows users to specify the desired date and time for filtering the results."
        },
        {
            "sample_id": 7936,
            "vt": "SELECT podcasts.podcast_id, podcasts.itunes_url FROM podcasts WHERE podcasts.podcast_id = (SELECT podcasts.podcast_id FROM reviews WHERE title = 'Long time listener, calling it quits')",
            "ba": "The virtual table retrieves the unique podcast ID and its iTunes URL from the 'podcasts' table for a specific podcast review title. The query uses a subquery to find the podcast ID associated with the review that has the title 'Long time listener, calling it quits'."
        },
        {
            "sample_id": 7950,
            "vt": "SELECT reviews.author_id FROM podcasts INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE podcasts.itunes_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the author IDs of reviews for a specific podcast identified by its iTunes ID. It joins the 'podcasts' table with the 'reviews' table based on the podcast ID, allowing us to filter the results based on the unique iTunes identifier."
        },
        {
            "sample_id": 7981,
            "vt": "SELECT DISTINCT podcasts.title FROM categories INNER JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id WHERE categories.category = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct titles of podcasts from the 'podcasts' table that belong to a specific category. The query uses an inner join between the 'categories' and 'podcasts' tables to filter podcasts based on their associated category, represented by a placeholder for string values."
        },
        {
            "sample_id": 7959,
            "vt": "SELECT DISTINCT reviews.title FROM categories INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE categories.category = '[placeholder-type:string]' AND reviews.created_at LIKE '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct titles of podcast reviews from the 'reviews' table that belong to a specific category and were created at a specific time. The placeholders in the WHERE clause represent the category of the podcast and the creation date and time of the review."
        },
        {
            "sample_id": 7927,
            "vt": "SELECT DISTINCT podcasts.title FROM categories INNER JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id INNER JOIN reviews AS T3 ON T3.podcast_id = T2.podcast_id WHERE reviews.rating = [placeholder-type:numeric] AND categories.category = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct titles of podcasts from the 'podcasts' table that belong to a specific category and have received a certain rating. The query uses inner joins to connect the 'categories', 'podcasts', and 'reviews' tables based on their podcast IDs. The placeholders represent the rating and category of interest."
        },
        {
            "sample_id": 7969,
            "vt": "SELECT categories.category FROM categories WHERE podcasts.podcast_id IN (SELECT podcasts.podcast_id FROM podcasts WHERE title = 'Moist Boys')",
            "ba": "The virtual table retrieves the categories associated with a specific podcast title from the 'categories' table. It filters the results based on the podcast_id, which is obtained from the 'podcasts' table where the title matches a specified value."
        },
        {
            "sample_id": 7968,
            "vt": "SELECT categories.category FROM categories WHERE podcasts.podcast_id IN (SELECT podcasts.podcast_id FROM podcasts WHERE title LIKE '%jessica%')",
            "ba": "The virtual table retrieves the categories of podcasts from the 'categories' table that have titles containing the name 'jessica'. The inner query selects the podcast IDs from the 'podcasts' table where the title matches the specified pattern, and the outer query filters the categories based on these podcast IDs."
        },
        {
            "sample_id": 7918,
            "vt": "SELECT COUNT(categories.podcast_id) FROM categories WHERE categories.category = (SELECT categories.category FROM categories GROUP BY category ORDER BY COUNT(podcast_id) DESC LIMIT 1)",
            "ba": "The virtual table counts the number of podcasts in the most popular category from the 'categories' table. It identifies the category with the highest number of associated podcasts and returns the count of podcasts that belong to that category."
        },
        {
            "sample_id": 7932,
            "vt": "SELECT DISTINCT podcasts.title, reviews.title, reviews.content FROM podcasts INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE reviews.rating = [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct titles and content of podcast reviews from the 'podcasts' and 'reviews' tables. It retrieves the titles of the podcasts and their corresponding reviews, filtering the results based on a specific rating value."
        },
        {
            "sample_id": 7965,
            "vt": "SELECT reviews.title FROM reviews ORDER BY LENGTH(reviews.content) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of podcast reviews from the 'reviews' table, ordered by the length of their content. The query limits the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 7975,
            "vt": "SELECT reviews.content FROM podcasts INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE podcasts.title = '[placeholder-type:string]' ORDER BY reviews.created_at LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the content of podcast reviews from the 'reviews' table, which are associated with a specific podcast title from the 'podcasts' table. The query uses an INNER JOIN to link the two tables based on the podcast ID, ensuring that only reviews related to the specified podcast title are selected. The results are ordered by the creation date of the reviews, and a limit is applied to control the number of reviews returned."
        },
        {
            "sample_id": 7923,
            "vt": "SELECT podcasts.title, podcasts.itunes_url FROM categories INNER JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id WHERE categories.category = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles and iTunes URLs of podcasts that belong to a specific category. The query joins the 'categories' table with the 'podcasts' table to filter podcasts based on their category, represented by a placeholder."
        },
        {
            "sample_id": 7954,
            "vt": "SELECT reviews.created_at FROM reviews WHERE podcasts.podcast_id = (SELECT podcasts.podcast_id FROM podcasts WHERE title = 'Don''t Lie To Your Life Coach')",
            "ba": "The virtual table retrieves the creation date and time of reviews for a specific podcast titled 'Don't Lie To Your Life Coach'. The query filters the reviews based on the podcast's unique identifier, which is obtained by selecting the podcast_id from the podcasts table where the title matches the specified podcast title."
        },
        {
            "sample_id": 7933,
            "vt": "SELECT DISTINCT podcasts.title, reviews.rating FROM podcasts INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE reviews.created_at LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct titles of podcasts along with their associated ratings from the 'podcasts' and 'reviews' tables. The query filters the results based on the creation date of the reviews, using a placeholder for the date format."
        },
        {
            "sample_id": 7940,
            "vt": "SELECT COUNT(reviews.rating) FROM podcasts INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE podcasts.title = '[placeholder-type:string]' AND reviews.rating <= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of reviews for a specific podcast title from the 'podcasts' table, filtering those reviews based on a maximum rating. The placeholders represent the podcast title and the rating threshold."
        },
        {
            "sample_id": 7939,
            "vt": "SELECT podcasts.title, reviews.content FROM reviews WHERE podcasts.podcast_id = (SELECT podcasts.podcast_id FROM podcasts WHERE title = 'More Stupider: A 90-Day Fiance Podcast') AND reviews.rating = [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of podcasts along with their corresponding review content from the 'reviews' table, filtered by a specific podcast title and a rating. The placeholder in the WHERE clause represents the rating of the review, while the subquery fetches the unique podcast ID based on the specified title."
        },
        {
            "sample_id": 7958,
            "vt": "SELECT AVG(reviews.rating) FROM categories INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE categories.category = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rating of podcast reviews from the 'reviews' table, filtered by a specific category from the 'categories' table. The placeholder in the WHERE clause represents the category of the podcast."
        },
        {
            "sample_id": 7928,
            "vt": "SELECT DISTINCT podcasts.title, reviews.content, reviews.rating FROM podcasts INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE reviews.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct titles of podcasts along with their corresponding review content and ratings. It retrieves data from the 'podcasts' table and joins it with the 'reviews' table based on the podcast ID. The placeholder in the WHERE clause represents the title of the review being queried."
        },
        {
            "sample_id": 7919,
            "vt": "SELECT COUNT((SELECT podcast_id FROM categories GROUP BY podcast_id HAVING COUNT(category) >= 4).podcast_id) FROM (SELECT categories.podcast_id FROM categories GROUP BY podcast_id HAVING COUNT(category) >= 4) AS t1",
            "ba": "The virtual table counts the number of podcasts that belong to four or more categories from the 'categories' table. It first identifies the unique podcast IDs that have at least four associated categories and then counts how many such unique podcast IDs exist."
        },
        {
            "sample_id": 7929,
            "vt": "SELECT reviews.author_id, reviews.rating, reviews.created_at FROM podcasts INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE podcasts.title = '[placeholder-type:string]' GROUP BY reviews.author_id, reviews.rating, reviews.created_at",
            "ba": "The virtual table retrieves the author ID, rating, and creation date of podcast reviews from the 'reviews' table, while joining with the 'podcasts' table to filter results based on a specific podcast title. The placeholder in the WHERE clause represents the title of the podcast being queried."
        },
        {
            "sample_id": 7957,
            "vt": "SELECT DISTINCT reviews.title FROM categories INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE categories.category = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct titles of podcast reviews from the 'reviews' table that belong to a specific category. The query joins the 'categories' table with the 'reviews' table based on the podcast_id, filtering the results to include only those reviews that match the specified category."
        },
        {
            "sample_id": 7942,
            "vt": "SELECT (SELECT categories.category FROM categories WHERE category = 'arts-books' OR category = 'arts-design' GROUP BY category ORDER BY COUNT(podcast_id) DESC LIMIT 1), (SELECT SUM(CASE WHEN categories.category = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN categories.category = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM categories)",
            "ba": "The virtual table provides insights into the most popular podcast category based on the number of podcasts in each category. It also calculates the difference in the sum of reviews added for a specific category compared to another category, allowing for a comparative analysis of podcast performance across different categories."
        },
        {
            "sample_id": 7937,
            "vt": "SELECT podcasts.title FROM categories INNER JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id WHERE categories.category = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of podcasts from the 'podcasts' table that belong to a specific category. The query uses an INNER JOIN to connect the 'categories' table with the 'podcasts' table based on the podcast_id, filtering the results by a specified category using a placeholder for string values."
        },
        {
            "sample_id": 7921,
            "vt": "SELECT podcasts.itunes_url FROM podcasts WHERE podcasts.title LIKE '[placeholder-type:string]' GROUP BY podcasts.itunes_url",
            "ba": "The virtual table retrieves the iTunes URLs of podcasts from the 'podcasts' table that match a specified title pattern. The placeholder in the WHERE clause allows for flexible input of the title, enabling users to search for podcasts with similar names."
        },
        {
            "sample_id": 7947,
            "vt": "SELECT CAST((SUM(CASE WHEN runs.run_at LIKE '[placeholder-type:string]' THEN runs.reviews_added ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN runs.run_at LIKE '[placeholder-type:string]' THEN runs.reviews_added ELSE [placeholder-type:numeric] END)) AS FLOAT) * [placeholder-type:numeric] / SUM(runs.reviews_added) OR '[placeholder-type:string]' FROM runs",
            "ba": "The virtual table calculates a specific metric based on the number of reviews added during podcast review runs. It filters the runs based on a specified date and time, and computes a weighted average of reviews added, using placeholders for both the date and numeric values. The result is intended to provide insights into the performance of podcast reviews over time."
        },
        {
            "sample_id": 7980,
            "vt": "SELECT categories.category FROM categories WHERE podcasts.podcast_id IN (SELECT podcasts.podcast_id FROM podcasts WHERE title = 'Scaling Global')",
            "ba": "The virtual table retrieves the categories associated with a specific podcast title from the 'categories' table. It filters the results based on the podcast's unique identifier, which is obtained from the 'podcasts' table by matching the title of the podcast."
        },
        {
            "sample_id": 7931,
            "vt": "SELECT reviews.title, reviews.rating, reviews.content FROM podcasts INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE reviews.author_id = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles, ratings, and content of podcast reviews from the 'reviews' table, filtered by a specific author's ID. It joins the 'podcasts' table to associate each review with its corresponding podcast using the podcast ID."
        }
    ],
    "university": [
        {
            "sample_id": 8098,
            "vt": "SELECT university_year.pct_international_students FROM university INNER JOIN university_year AS T2 ON T1.id = T2.university_id WHERE university.university_name = '[placeholder-type:string]' AND university_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the percentage of international students from the 'university_year' table for a specific university and year. It joins the 'university' table to filter by the university's name and uses placeholders for the university name and year."
        },
        {
            "sample_id": 8119,
            "vt": "SELECT COUNT(*) FROM ranking_system INNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id WHERE ranking_system.system_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of ranking criteria associated with a specific ranking system from the 'ranking_system' and 'ranking_criteria' tables. The placeholder in the WHERE clause represents the name of the ranking system being queried."
        },
        {
            "sample_id": 8033,
            "vt": "SELECT university.university_name FROM university_ranking_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university_ranking_year.year = [placeholder-type:numeric] ORDER BY university_ranking_year.score LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of universities that have been ranked in a specific year, ordered by their ranking scores. The placeholders in the WHERE clause represent the ranking year and the limit on the number of universities to display."
        },
        {
            "sample_id": 8102,
            "vt": "SELECT university_ranking_year.score FROM ranking_criteria INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id INNER JOIN university AS T3 ON T3.id = T2.university_id WHERE university.university_name = '[placeholder-type:string]' AND university_ranking_year.year = [placeholder-type:numeric] AND ranking_criteria.criteria_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the ranking score of a specific university for a given year based on a particular ranking criterion. It joins the 'ranking_criteria' table with the 'university_ranking_year' table to access the scores, and further joins with the 'university' table to filter by the university's name. The placeholders represent the university's name, the year of ranking, and the name of the ranking criterion."
        },
        {
            "sample_id": 8036,
            "vt": "SELECT university_year.pct_international_students FROM university_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university_year.year = [placeholder-type:numeric] AND university.university_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides the percentage of international students from the 'university_year' table for a specific university in a given year. The placeholders represent the year and the university's name."
        },
        {
            "sample_id": 8047,
            "vt": "SELECT COUNT(*) FROM university_year WHERE university_year.year = [placeholder-type:numeric] AND university_year.num_students > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of universities from the 'university_year' table that have a specific number of students for a given year. The placeholders represent the year and the minimum number of students required for the count."
        },
        {
            "sample_id": 8004,
            "vt": "SELECT DISTINCT country.country_name FROM university INNER JOIN university_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE university_year.pct_international_students > [placeholder-type:numeric] AND university_year.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct country names from the 'country' table based on universities that have a certain percentage of international students. It joins the 'university' table with the 'university_year' table to filter universities by the percentage of international students and the range of years specified. The placeholders represent the minimum percentage of international students and the range of years for which the data is being queried."
        },
        {
            "sample_id": 8061,
            "vt": "SELECT university.university_name FROM ranking_criteria INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id INNER JOIN university AS T3 ON T3.id = T2.university_id WHERE ranking_criteria.criteria_name = '[placeholder-type:string]' AND university_ranking_year.year = [placeholder-type:numeric] ORDER BY university_ranking_year.score LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of universities that meet specific ranking criteria for a given year. It retrieves data from the 'ranking_criteria', 'university_ranking_year', and 'university' tables, filtering based on the criteria name and the ranking year. The results are ordered by the ranking score, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 8050,
            "vt": "SELECT ranking_criteria.id FROM ranking_criteria WHERE ranking_criteria.criteria_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier of ranking criteria from the 'ranking_criteria' table based on a specified criteria name. The placeholder in the WHERE clause represents the name of the ranking criteria being queried."
        },
        {
            "sample_id": 8024,
            "vt": "SELECT ranking_criteria.criteria_name FROM ranking_system INNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id WHERE ranking_system.system_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of ranking criteria from the 'ranking_criteria' table that are associated with a specific ranking system. The query uses an INNER JOIN to connect the 'ranking_system' and 'ranking_criteria' tables based on their IDs, filtering the results by the name of the ranking system provided as a placeholder."
        },
        {
            "sample_id": 8005,
            "vt": "SELECT COUNT(*), SUM(CASE WHEN country.country_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM university INNER JOIN university_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE university_year.year = [placeholder-type:numeric] AND university_year.num_students * university_year.pct_female_students / [placeholder-type:numeric] > [placeholder-type:numeric]",
            "ba": "The virtual table counts the total number of universities and sums a conditional value based on the country name. It joins the 'university' table with 'university_year' to access student data and with 'country' to filter by country. The query also includes conditions to filter by a specific year and calculates a ratio of female students to total students, using placeholders for dynamic input."
        },
        {
            "sample_id": 8014,
            "vt": "SELECT university_year.student_staff_ratio FROM university_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university.university_name = '[placeholder-type:string]' AND university_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the student-to-staff ratio for a specific university in a given year. It joins the 'university_year' table with the 'university' table to filter results based on the university's name and the specified year. The placeholders represent the university's name and the year for which the data is being queried."
        },
        {
            "sample_id": 8094,
            "vt": "SELECT COUNT(*) FROM university INNER JOIN country AS T2 ON T1.country_id = T2.id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of universities located in a specific country by joining the 'university' table with the 'country' table. The placeholder in the WHERE clause represents the name of the country for which the count of universities is being requested."
        },
        {
            "sample_id": 8023,
            "vt": "SELECT SUM(university_year.num_students) FROM university_year INNER JOIN university_ranking_year AS T2 ON T1.university_id = T2.university_id WHERE university_ranking_year.score = [placeholder-type:numeric] AND university_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total number of students from the 'university_year' table for universities that have a specific ranking score in a given year. It joins the 'university_year' table with the 'university_ranking_year' table to filter the results based on the ranking score and the year, using placeholders for numeric values."
        },
        {
            "sample_id": 8095,
            "vt": "SELECT university.university_name FROM university_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university_year.year = [placeholder-type:numeric] ORDER BY university_year.num_students LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of universities from the 'university' table that have a specific number of students in a given year. The query joins the 'university_year' table with the 'university' table to filter results based on the year and limit the number of universities returned."
        },
        {
            "sample_id": 7987,
            "vt": "SELECT COUNT(*) FROM university_year WHERE university_year.num_students > [placeholder-type:numeric] AND university_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of universities from the 'university_year' table that have a total number of students greater than a specified number for a given year. The placeholders represent the minimum number of students and the specific year for which the count is being calculated."
        },
        {
            "sample_id": 8093,
            "vt": "SELECT country.country_name FROM university INNER JOIN country AS T2 ON T1.country_id = T2.id WHERE university.university_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of countries associated with a specific university from the 'university' table. It uses an inner join to connect the 'university' table with the 'country' table based on the country identifier. The placeholder in the WHERE clause represents the name of the university being queried."
        },
        {
            "sample_id": 8078,
            "vt": "SELECT university.university_name FROM ranking_criteria INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id INNER JOIN university AS T3 ON T3.id = T2.university_id WHERE ranking_criteria.criteria_name = '[placeholder-type:string]' AND university_ranking_year.year = [placeholder-type:numeric] ORDER BY university_ranking_year.score LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of universities that meet specific ranking criteria for a given year. It retrieves data from the 'ranking_criteria', 'university_ranking_year', and 'university' tables, filtering based on the criteria name and the ranking year. The results are ordered by the ranking score, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 8135,
            "vt": "SELECT SUM(university_year.num_students) - SUM(CAST(university_year.num_students * university_year.pct_international_students AS FLOAT) / [placeholder-type:numeric]) FROM university_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university_year.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND university.university_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of domestic students in a specific university over a range of years. It does this by summing the total number of students and subtracting the number of international students, which is derived from the percentage of international students. The query filters results based on the university's name and the specified year range."
        },
        {
            "sample_id": 8128,
            "vt": "SELECT DISTINCT university.university_name FROM university_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university_year.num_students BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct names of universities from the 'university_year' table that have a total number of students within a specified range. The query uses an INNER JOIN to connect the 'university_year' table with the 'university' table to ensure that only valid university names are retrieved based on the student count criteria."
        },
        {
            "sample_id": 8136,
            "vt": "SELECT university.university_name FROM university_ranking_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university_ranking_year.year = [placeholder-type:numeric] AND university_ranking_year.score * [placeholder-type:numeric] < (SELECT AVG(university_ranking_year.score) * [placeholder-type:numeric] FROM university_ranking_year WHERE year = 2015)",
            "ba": "The virtual table describes the names of universities that have a ranking score below a certain threshold, which is calculated as a fraction of the average score of all universities for the year 2015. The query joins the 'university_ranking_year' table with the 'university' table to retrieve the university names, applying filters based on the specified year and score criteria."
        },
        {
            "sample_id": 8101,
            "vt": "SELECT CAST(university_year.num_students * university_year.pct_female_students AS FLOAT) / [placeholder-type:numeric] FROM university_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university_year.year = [placeholder-type:numeric] AND university.university_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the number of female students in a specific university for a given year. It does this by multiplying the total number of students by the percentage of female students, and then dividing by a specified numeric value. The query joins the 'university_year' table with the 'university' table to filter results based on the university's name and the year of interest."
        },
        {
            "sample_id": 8035,
            "vt": "SELECT university.university_name FROM university INNER JOIN university_ranking_year AS T2 ON T1.id = T2.university_id INNER JOIN ranking_criteria AS T3 ON T3.id = T2.ranking_criteria_id WHERE ranking_criteria.criteria_name = '[placeholder-type:string]' ORDER BY university_ranking_year.score LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of universities that are ranked based on specific criteria. It retrieves the university names from the 'university' table, joining it with the 'university_ranking_year' table to access the ranking scores. Additionally, it joins with the 'ranking_criteria' table to filter the results based on a specified criteria name. The results are ordered by the ranking score and limited to a specified number of entries."
        },
        {
            "sample_id": 8123,
            "vt": "SELECT COUNT(*) FROM university INNER JOIN country AS T2 ON T1.country_id = T2.id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of universities located in a specific country by joining the 'university' table with the 'country' table. The placeholder in the WHERE clause represents the name of the country for which the count of universities is being requested."
        },
        {
            "sample_id": 8016,
            "vt": "SELECT SUM(university_year.num_students) FROM university INNER JOIN university_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total number of students from universities located in a specific country. It combines data from the 'university', 'university_year', and 'country' tables, filtering by the country's name."
        },
        {
            "sample_id": 8000,
            "vt": "SELECT country.country_name FROM university INNER JOIN country AS T2 ON T1.country_id = T2.id WHERE university.university_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of countries associated with a specific university from the 'university' table. The query uses an INNER JOIN to connect the 'university' table with the 'country' table based on the country identifier. The placeholder in the WHERE clause represents the name of the university for which we want to find the corresponding country."
        },
        {
            "sample_id": 8104,
            "vt": "SELECT university.university_name FROM university_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university_year.year = [placeholder-type:numeric] ORDER BY university_year.num_students LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of universities from the 'university' table that have been filtered based on a specific year and ordered by the number of students. The placeholders in the WHERE clause represent the year of interest and the limit on the number of universities to return."
        },
        {
            "sample_id": 8009,
            "vt": "SELECT AVG(university_year.pct_female_students) FROM university_year",
            "ba": "The virtual table calculates the average percentage of female students from the 'university_year' table across all universities."
        },
        {
            "sample_id": 8015,
            "vt": "SELECT country.country_name FROM university INNER JOIN country AS T2 ON T1.country_id = T2.id WHERE university.id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of countries associated with a specific university from the 'university' table. The query uses an INNER JOIN to connect the 'university' table with the 'country' table based on the country identifier. The placeholder in the WHERE clause represents the unique identifier of the university."
        },
        {
            "sample_id": 8058,
            "vt": "SELECT CAST(university_year.num_students * university_year.pct_female_students AS FLOAT) / [placeholder-type:numeric] FROM university INNER JOIN university_year AS T2 ON T1.id = T2.university_id WHERE university.university_name = '[placeholder-type:string]' AND university_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the number of female students in a specific university for a given year by multiplying the total number of students by the percentage of female students. The result is then divided by a placeholder for numeric values, which could represent a scaling factor or another divisor. The query filters the results based on the university's name and the year of interest."
        },
        {
            "sample_id": 8129,
            "vt": "SELECT university_ranking_year.year FROM university_ranking_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university.university_name = '[placeholder-type:string]' ORDER BY university_ranking_year.score LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the ranking years of a specific university from the 'university_ranking_year' table. It joins with the 'university' table to filter results based on the university's name. The results are ordered by the ranking score, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 8051,
            "vt": "SELECT COUNT(*) FROM university_year WHERE university_year.pct_international_students > [placeholder-type:numeric] AND university_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of universities from the 'university_year' table that have a percentage of international students greater than a specified value for a given year. The placeholders represent the threshold for the percentage of international students and the specific year being queried."
        },
        {
            "sample_id": 8073,
            "vt": "SELECT university_year.num_students FROM university_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university.university_name = '[placeholder-type:string]' AND university_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table describes the total number of students enrolled in a specific university for a given year. It retrieves data from the 'university_year' table and joins it with the 'university' table to filter results based on the university's name and the specified year. The placeholders represent the university's name and the year of interest."
        },
        {
            "sample_id": 8065,
            "vt": "SELECT AVG(university_ranking_year.score) FROM ranking_criteria INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id WHERE ranking_criteria.criteria_name = '[placeholder-type:string]' AND university_ranking_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average ranking score of universities based on specific ranking criteria for a given year. It joins the 'ranking_criteria' table with the 'university_ranking_year' table to filter the results by the criteria name and the year, using placeholders for these values."
        },
        {
            "sample_id": 8071,
            "vt": "SELECT university_year.university_id FROM university_year WHERE university_year.year = [placeholder-type:numeric] ORDER BY university_year.pct_female_students LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of universities from the 'university_year' table for a specific year. The results are ordered by the percentage of female students, and the number of results returned is limited by a specified placeholder value."
        },
        {
            "sample_id": 8011,
            "vt": "SELECT university.id FROM university WHERE university.university_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier of a university from the 'university' table based on the specified university name. The placeholder in the WHERE clause represents the name of the university being queried."
        },
        {
            "sample_id": 8103,
            "vt": "SELECT CAST(university_year.num_students * university_year.pct_international_students AS FLOAT) / [placeholder-type:numeric] FROM university_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university_year.year = [placeholder-type:numeric] AND university.university_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the number of international students in a specific university for a given year. It does this by multiplying the total number of students by the percentage of international students, and then dividing by a specified numeric value. The query joins the 'university_year' table with the 'university' table to filter results based on the university's name and the year of interest."
        },
        {
            "sample_id": 8111,
            "vt": "SELECT ranking_criteria.criteria_name FROM ranking_criteria WHERE ranking_criteria.id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of ranking criteria from the 'ranking_criteria' table based on a specific ranking criteria ID. The placeholder in the WHERE clause represents the unique identifier for the ranking criteria."
        },
        {
            "sample_id": 8006,
            "vt": "SELECT DISTINCT university.university_name FROM university_year INNER JOIN university AS T2 ON T1.university_id = T2.id ORDER BY (CAST(university_year.num_students * university_year.pct_international_students AS FLOAT) / [placeholder-type:numeric]) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct university names from the 'university_year' table, which contains data about universities and their student demographics. It joins with the 'university' table to ensure that the university names are correctly associated with their respective IDs. The results are ordered based on a calculated value that represents the ratio of international students to a specified number, allowing for a dynamic limit on the number of results returned."
        },
        {
            "sample_id": 8018,
            "vt": "SELECT university.university_name FROM university INNER JOIN country AS T2 ON T1.country_id = T2.id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of universities located in a specific country. It retrieves the 'university_name' from the 'university' table and joins it with the 'country' table to filter based on the country's name. The placeholder in the WHERE clause represents the name of the country."
        },
        {
            "sample_id": 8110,
            "vt": "SELECT university_year.university_id FROM university_year ORDER BY university_year.pct_international_students LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of universities from the 'university_year' table, ordered by the percentage of international students. The result is limited to a specified number of entries."
        },
        {
            "sample_id": 8070,
            "vt": "SELECT COUNT(*) FROM university_year WHERE university_year.year = [placeholder-type:numeric] AND university_year.pct_international_students > [placeholder-type:numeric] AND university_year.num_students > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of universities from the 'university_year' table that meet specific criteria for a given year. The placeholders represent the year, the minimum percentage of international students, and the minimum number of students required for the universities to be included in the count."
        },
        {
            "sample_id": 8121,
            "vt": "SELECT CAST(university_year.num_students * university_year.pct_female_students AS FLOAT) / [placeholder-type:numeric] FROM university_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university_year.year = [placeholder-type:numeric] AND university.university_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the number of female students in a specific university for a given year by multiplying the total number of students by the percentage of female students. The result is then divided by a specified numeric value. The placeholders represent the year and the university's name."
        },
        {
            "sample_id": 8066,
            "vt": "SELECT university.university_name, country.country_name FROM university INNER JOIN university_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE university_year.year = [placeholder-type:numeric] ORDER BY university_year.num_students LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of universities along with their corresponding countries from the 'university' and 'country' tables. It filters the results based on a specific year from the 'university_year' table and orders the results by the number of students, limiting the output to a specified number of entries."
        },
        {
            "sample_id": 8017,
            "vt": "SELECT university_ranking_year.ranking_criteria_id FROM university_ranking_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university.university_name = '[placeholder-type:string]' AND university_ranking_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the ranking criteria ID for a specific university in a given year. It joins the 'university_ranking_year' table with the 'university' table to filter results based on the university's name and the ranking year."
        },
        {
            "sample_id": 7994,
            "vt": "SELECT university.university_name FROM university_year INNER JOIN university AS T2 ON T1.university_id = T2.id ORDER BY university_year.pct_international_students LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of universities from the 'university' table, filtered by their international student percentage. It uses an inner join with the 'university_year' table to access the percentage of international students and orders the results accordingly. The placeholder in the LIMIT clause allows for specifying the maximum number of universities to return."
        },
        {
            "sample_id": 8099,
            "vt": "SELECT ranking_criteria.criteria_name FROM ranking_criteria INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id INNER JOIN university AS T3 ON T3.id = T2.university_id WHERE university.university_name = '[placeholder-type:string]' AND university_ranking_year.year = [placeholder-type:numeric] ORDER BY university_ranking_year.score LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of ranking criteria from the 'ranking_criteria' table based on specific conditions related to universities and their ranking scores. It joins the 'ranking_criteria' table with the 'university_ranking_year' table to filter by a specific university's name and the year of ranking. The results are ordered by the ranking score, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 8020,
            "vt": "SELECT AVG(university_ranking_year.score) FROM university INNER JOIN university_ranking_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average ranking score of universities located in a specific country. It joins the 'university' table with the 'university_ranking_year' table to access the ranking scores, and it also joins with the 'country' table to filter universities based on the country name provided as a placeholder."
        },
        {
            "sample_id": 8028,
            "vt": "SELECT SUM(CAST(university_year.num_students * university_year.pct_female_students AS FLOAT) / [placeholder-type:numeric]) FROM university_year WHERE university_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total number of female students across universities for a specific year by summing the product of the number of students and the percentage of female students. The placeholder in the SELECT statement represents a divisor for the calculation, while the WHERE clause filters the results for a specified year."
        },
        {
            "sample_id": 8049,
            "vt": "SELECT ranking_system.id FROM ranking_system WHERE ranking_system.system_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier for a ranking system from the 'ranking_system' table based on a specified system name. The placeholder in the WHERE clause represents the name of the ranking system being queried."
        },
        {
            "sample_id": 8117,
            "vt": "SELECT DISTINCT ranking_criteria.criteria_name FROM university INNER JOIN university_ranking_year AS T2 ON T1.id = T2.university_id INNER JOIN ranking_criteria AS T3 ON T3.id = T2.ranking_criteria_id WHERE university.university_name = '[placeholder-type:string]' AND university_ranking_year.score = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct ranking criteria names from the 'ranking_criteria' table based on a specific university's name and its corresponding ranking score. It involves joining the 'university' table with the 'university_ranking_year' table to link universities with their ranking scores, and then further joining with the 'ranking_criteria' table to get the criteria names associated with those scores."
        },
        {
            "sample_id": 7997,
            "vt": "SELECT COUNT(*) FROM university INNER JOIN country AS T2 ON T1.country_id = T2.id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of universities located in a specific country by joining the 'university' table with the 'country' table. The placeholder in the WHERE clause represents the name of the country for which the count of universities is being requested."
        },
        {
            "sample_id": 8012,
            "vt": "SELECT university_ranking_year.university_id FROM university_ranking_year WHERE university_ranking_year.score = [placeholder-type:numeric] AND university_ranking_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of universities from the 'university_ranking_year' table based on a specific ranking score and year. The placeholders represent the score and year for which the universities' rankings are being queried."
        },
        {
            "sample_id": 7991,
            "vt": "SELECT COUNT(ranking_criteria.id) FROM ranking_criteria WHERE ranking_criteria.ranking_system_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of ranking criteria associated with a specific ranking system from the 'ranking_criteria' table. The placeholder in the WHERE clause represents the unique identifier for the ranking system."
        },
        {
            "sample_id": 8091,
            "vt": "SELECT university_year.num_students FROM university_year WHERE university_year.university_id = [placeholder-type:numeric] AND university_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table provides the total number of students enrolled in a specific university for a given year. The placeholders represent the university's unique identifier and the year of interest."
        },
        {
            "sample_id": 8092,
            "vt": "SELECT country.country_name FROM country WHERE country.id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of countries from the 'country' table based on a specific country identifier. The placeholder in the WHERE clause represents the unique id of the country."
        },
        {
            "sample_id": 8132,
            "vt": "SELECT country.country_name, CAST(university_year.num_students * university_year.pct_female_students AS FLOAT) / [placeholder-type:numeric] FROM university INNER JOIN university_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE university_year.year = [placeholder-type:numeric] AND university.id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the number of female students in a specific university for a given year, expressed as a percentage of the total number of students. It retrieves the country name and computes the female student count by multiplying the total number of students by the percentage of female students, then dividing by a placeholder for numeric values. The query joins the 'university', 'university_year', and 'country' tables to filter results based on the specified year and university ID."
        },
        {
            "sample_id": 8002,
            "vt": "SELECT ranking_criteria.criteria_name FROM ranking_system INNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id WHERE ranking_system.system_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of ranking criteria from the 'ranking_criteria' table that are associated with a specific ranking system. The query uses an INNER JOIN to connect the 'ranking_system' and 'ranking_criteria' tables based on their IDs, filtering the results by the name of the ranking system provided as a placeholder."
        },
        {
            "sample_id": 8086,
            "vt": "SELECT CAST(SUM(CASE WHEN country.country_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM ranking_criteria INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id INNER JOIN university AS T3 ON T3.id = T2.university_id INNER JOIN country AS T4 ON T4.id = T3.country_id WHERE ranking_criteria.criteria_name = '[placeholder-type:string]' AND university_ranking_year.year = [placeholder-type:numeric] AND university_ranking_year.score > [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average score for universities based on specific ranking criteria and country. It sums the scores of universities from a particular country that meet the specified criteria and year, applying a weight to the sum. The placeholders represent the country name, ranking criteria name, year, and a score threshold."
        },
        {
            "sample_id": 8084,
            "vt": "SELECT COUNT(*) FROM university INNER JOIN university_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE country.country_name = '[placeholder-type:string]' AND university_year.student_staff_ratio > [placeholder-type:numeric] AND university_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of universities from the 'university' table that meet specific criteria. It joins the 'university_year' table to access student and staff ratio data, and the 'country' table to filter by country name. The placeholders represent the country name, a minimum student-staff ratio, and a specific year."
        },
        {
            "sample_id": 8118,
            "vt": "SELECT university.university_name, university.id FROM university INNER JOIN country AS T2 ON T1.country_id = T2.id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and IDs of universities located in a specific country. It retrieves data from the 'university' table and joins it with the 'country' table to filter universities based on the country's name provided as a placeholder."
        },
        {
            "sample_id": 8019,
            "vt": "SELECT ranking_criteria.criteria_name FROM ranking_criteria INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id WHERE university_ranking_year.university_id = [placeholder-type:numeric] AND university_ranking_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of ranking criteria from the 'ranking_criteria' table for a specific university and year. The query uses an inner join to connect the 'ranking_criteria' table with the 'university_ranking_year' table, filtering results based on the university's ID and the ranking year, both represented by placeholders for numeric values."
        },
        {
            "sample_id": 8130,
            "vt": "SELECT AVG(university_ranking_year.score) FROM university_ranking_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university.university_name = '[placeholder-type:string]' AND university_ranking_year.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average ranking score of a specific university over a range of years. It joins the 'university_ranking_year' table with the 'university' table to filter by the university's name and restricts the results to a specified year range using placeholders for both the university name and the year values."
        },
        {
            "sample_id": 8083,
            "vt": "SELECT university.university_name FROM ranking_criteria INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id INNER JOIN university AS T3 ON T3.id = T2.university_id INNER JOIN country AS T4 ON T4.id = T3.country_id WHERE country.country_name = '[placeholder-type:string]' AND university_ranking_year.year = [placeholder-type:numeric] AND university_ranking_year.score < [placeholder-type:numeric] AND ranking_criteria.criteria_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of universities from the 'university' table that meet specific ranking criteria. It filters universities based on the country name, the ranking year, and the ranking score, while also ensuring that the criteria name matches a specified value."
        },
        {
            "sample_id": 8126,
            "vt": "SELECT CAST((university_year.num_students - (university_year.num_students * university_year.pct_female_students)) AS FLOAT) / [placeholder-type:numeric] FROM university_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university.university_name = '[placeholder-type:string]' AND university_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the number of male students in a specific university for a given year by taking the total number of students and subtracting the number of female students. The result is then divided by a placeholder for a numeric value, which could represent a specific divisor for further calculations. The query filters the results based on the university's name and the year of interest."
        },
        {
            "sample_id": 8059,
            "vt": "SELECT university.university_name FROM university INNER JOIN university_ranking_year AS T2 ON T1.id = T2.university_id GROUP BY university.university_name ORDER BY SUM(university_ranking_year.score) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of universities from the 'university' table, which are joined with their corresponding ranking scores from the 'university_ranking_year' table. The results are grouped by university name and ordered by the total score in descending order, with a limit on the number of universities returned based on a specified numeric value."
        },
        {
            "sample_id": 8039,
            "vt": "SELECT ranking_system.system_name FROM ranking_system INNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id WHERE ranking_criteria.criteria_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of ranking systems from the 'ranking_system' table that are associated with a specific ranking criteria. The placeholder in the WHERE clause represents the name of the criteria being queried."
        },
        {
            "sample_id": 8043,
            "vt": "SELECT COUNT(ranking_criteria.criteria_name) FROM ranking_system INNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id WHERE ranking_system.system_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of ranking criteria associated with a specific ranking system from the 'ranking_system' and 'ranking_criteria' tables. The placeholder in the WHERE clause represents the name of the ranking system."
        },
        {
            "sample_id": 8134,
            "vt": "SELECT SUM(CAST(university_year.pct_female_students * university_year.num_students AS FLOAT) / [placeholder-type:numeric]) * [placeholder-type:numeric] / SUM(university_year.num_students) FROM university INNER JOIN university_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE country.country_name = '[placeholder-type:string]' AND university_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the weighted average percentage of female students in universities located in a specific country for a given year. It does this by summing the product of the percentage of female students and the total number of students for each university, then normalizing this by the total number of students across all universities in that country for the specified year. The placeholders represent the country name and the year for which the calculation is performed."
        },
        {
            "sample_id": 8076,
            "vt": "SELECT COUNT(*) FROM university INNER JOIN university_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE country.country_name = '[placeholder-type:string]' AND university_year.year = [placeholder-type:numeric] AND university_year.num_students > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of universities located in a specific country that have a certain number of students in a given year. It joins the 'university' table with the 'university_year' table to access student data and the 'country' table to filter by country name. The placeholders represent the country name, the year, and the minimum number of students required."
        },
        {
            "sample_id": 8025,
            "vt": "SELECT DISTINCT country.country_name FROM university INNER JOIN university_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE university_year.year = [placeholder-type:numeric] AND university_year.num_students * [placeholder-type:numeric] > (SELECT AVG(university_year.num_students) FROM university_year) * [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct country names from the 'country' table based on universities that meet specific criteria. It joins the 'university' table with 'university_year' to filter universities by a given year and a calculated condition involving the number of students. The condition checks if the number of students in a university, multiplied by a placeholder value, exceeds the average number of students across all universities, also multiplied by another placeholder value."
        },
        {
            "sample_id": 8133,
            "vt": "SELECT COUNT(*) FROM ranking_criteria INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id WHERE university_ranking_year.score = [placeholder-type:numeric] AND ranking_criteria.criteria_name = '[placeholder-type:string]' AND university_ranking_year.score = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of ranking criteria that meet specific conditions related to university rankings. It joins the 'ranking_criteria' table with the 'university_ranking_year' table to filter based on the ranking score and criteria name. The placeholders represent the score and criteria name that can be specified by the user."
        },
        {
            "sample_id": 7998,
            "vt": "SELECT university.university_name FROM ranking_criteria INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id INNER JOIN university AS T3 ON T3.id = T2.university_id INNER JOIN country AS T4 ON T4.id = T3.country_id WHERE ranking_criteria.criteria_name = '[placeholder-type:string]' AND university_ranking_year.year = [placeholder-type:numeric] AND ranking_criteria.id = [placeholder-type:numeric] AND country.country_name = '[placeholder-type:string]' ORDER BY university_ranking_year.score LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of universities based on specific ranking criteria and their scores for a given year. It filters the results by the criteria name, the year of ranking, the criteria ID, and the country name, allowing users to retrieve a list of universities that meet these conditions, ordered by their ranking scores."
        },
        {
            "sample_id": 8131,
            "vt": "SELECT university.university_name FROM university_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university_year.year = [placeholder-type:numeric] ORDER BY university_year.num_students LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of universities from the 'university' table that are associated with a specific year from the 'university_year' table. The query filters the results based on the specified year and limits the number of results returned. The placeholders represent the year and the limit on the number of universities to display."
        },
        {
            "sample_id": 8046,
            "vt": "SELECT SUM(university_year.num_students) - SUM(CAST(university_year.num_students * university_year.pct_international_students AS FLOAT) / [placeholder-type:numeric]) FROM university_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university.university_name = '[placeholder-type:string]' AND university_year.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total number of domestic students in a specific university over a range of years. It does this by summing the total number of students and subtracting the number of international students, which is derived from the percentage of international students. The query filters results based on the university's name and the specified year range."
        },
        {
            "sample_id": 8120,
            "vt": "SELECT university.university_name, university_ranking_year.score FROM university_ranking_year INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE university.id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of universities along with their corresponding ranking scores from the 'university_ranking_year' table. The query joins the 'university' table to retrieve the university names based on a specific university ID, which is represented by a placeholder for numeric values."
        },
        {
            "sample_id": 8041,
            "vt": "SELECT COUNT(*) FROM university INNER JOIN country AS T2 ON T1.country_id = T2.id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of universities located in a specific country by joining the 'university' table with the 'country' table. The placeholder in the WHERE clause represents the name of the country for which the count of universities is being requested."
        },
        {
            "sample_id": 8008,
            "vt": "SELECT university_year.year FROM university_year ORDER BY university_year.num_students LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the years from the 'university_year' table, ordered by the total number of students in ascending order, with a limit on the number of results returned."
        },
        {
            "sample_id": 8029,
            "vt": "SELECT MAX(university_year.student_staff_ratio) FROM university_year ORDER BY university_year.student_staff_ratio LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the maximum student-to-staff ratio from the 'university_year' table, which contains data about universities, including their student and staff numbers. The result is ordered by the student-to-staff ratio, and a placeholder is used to limit the number of results returned."
        },
        {
            "sample_id": 8068,
            "vt": "SELECT university_year.university_id FROM university_year WHERE university_year.year = [placeholder-type:numeric] ORDER BY university_year.num_students LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of universities from the 'university_year' table for a specified year. The results are ordered by the total number of students enrolled in each university, and the output is limited to a specified number of universities."
        },
        {
            "sample_id": 8114,
            "vt": "SELECT AVG(university_ranking_year.score) FROM university_ranking_year WHERE university_ranking_year.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND university_ranking_year.university_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average ranking score of a specific university over a range of years. The placeholders represent the start and end years for the ranking period, as well as the unique identifier for the university."
        },
        {
            "sample_id": 8108,
            "vt": "SELECT university_ranking_year.score FROM university_ranking_year WHERE university_ranking_year.year = [placeholder-type:numeric] AND university_ranking_year.university_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the ranking scores of universities for a specific year. The placeholders in the WHERE clause represent the year of ranking and the unique identifier of the university."
        },
        {
            "sample_id": 8080,
            "vt": "SELECT COUNT(*) FROM ranking_criteria INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id INNER JOIN university AS T3 ON T3.id = T2.university_id WHERE ranking_criteria.criteria_name = '[placeholder-type:string]' AND university_ranking_year.year = [placeholder-type:numeric] AND university_ranking_year.score > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of ranking criteria that meet specific conditions related to university rankings. It joins the 'ranking_criteria' table with the 'university_ranking_year' table to filter based on the criteria name, the year of ranking, and a minimum score threshold. The placeholders represent the criteria name, the ranking year, and the score threshold respectively."
        },
        {
            "sample_id": 7988,
            "vt": "SELECT ranking_criteria.ranking_system_id FROM ranking_criteria WHERE ranking_criteria.criteria_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the ranking system ID associated with a specific ranking criterion from the 'ranking_criteria' table. The placeholder in the WHERE clause represents the name of the ranking criterion being queried."
        },
        {
            "sample_id": 8067,
            "vt": "SELECT university_year.num_students FROM university_year WHERE university_year.year = [placeholder-type:numeric] AND university_year.university_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the total number of students enrolled in a specific university for a given year. The placeholders in the WHERE clause represent the year and the university's unique identifier."
        },
        {
            "sample_id": 8022,
            "vt": "SELECT CAST(university_year.num_students * university_year.pct_international_students AS FLOAT) / [placeholder-type:numeric], university_ranking_year.score FROM university_year INNER JOIN university_ranking_year AS T2 ON T1.university_id = T2.university_id WHERE university_ranking_year.year = [placeholder-type:numeric] AND university_year.university_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the ratio of international students to total students for a specific university in a given year, alongside the university's ranking score for that year. The placeholders represent the year and university ID for which the data is being queried."
        },
        {
            "sample_id": 8109,
            "vt": "SELECT country.id FROM country WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier of a country from the 'country' table based on the specified country name. The placeholder in the WHERE clause represents the name of the country being queried."
        },
        {
            "sample_id": 8107,
            "vt": "SELECT AVG(university_year.num_students) FROM university_year WHERE university_year.year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of students from the 'university_year' table for a specific year. The placeholder in the WHERE clause represents the year for which the average is being calculated."
        },
        {
            "sample_id": 8013,
            "vt": "SELECT ranking_system.system_name FROM ranking_system INNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id WHERE ranking_criteria.criteria_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of ranking systems from the 'ranking_system' table that are associated with a specific ranking criteria. The query uses an INNER JOIN to connect the 'ranking_system' table with the 'ranking_criteria' table based on their IDs, and filters the results based on the criteria name provided as a placeholder."
        },
        {
            "sample_id": 8116,
            "vt": "SELECT university_ranking_year.score FROM university_year INNER JOIN university_ranking_year AS T2 ON T1.university_id = T2.university_id WHERE university_year.year = [placeholder-type:numeric] ORDER BY university_year.num_students LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the ranking scores of universities for a specific year, based on the number of students enrolled. It joins the 'university_year' table with the 'university_ranking_year' table to access the scores while filtering by the specified year and ordering the results by the number of students. The placeholders represent the year and the limit for the number of results returned."
        }
    ],
    "toxicology": [
        {
            "sample_id": 9644,
            "vt": "SELECT COUNT(CASE WHEN T.label = '[placeholder-type:string]' THEN T.molecule_id ELSE NULL END) - COUNT(CASE WHEN T.label = '[placeholder-type:string]' THEN T.molecule_id ELSE NULL END) FROM molecule",
            "ba": "The virtual table calculates the difference in the count of molecules based on their carcinogenic label from the 'molecule' table. It uses placeholders to specify the labels for filtering the molecules, allowing users to input specific carcinogenic statuses to compare counts."
        },
        {
            "sample_id": 9645,
            "vt": "SELECT connected.atom_id FROM connected WHERE connected.bond_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier of the first atom involved in a specific bond from the 'connected' table. The placeholder in the WHERE clause represents the bond's unique identifier."
        },
        {
            "sample_id": 9696,
            "vt": "SELECT DISTINCT atom.element FROM atom WHERE atom.molecule_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct elements from the 'atom' table for a specific molecule identified by its molecule_id. The placeholder in the WHERE clause represents the unique identifier of the molecule."
        },
        {
            "sample_id": 9651,
            "vt": "SELECT DISTINCT bond.bond_type FROM bond WHERE bond.molecule_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the distinct types of bonds associated with a specific molecule from the 'bond' table. The placeholder in the WHERE clause represents the unique identifier of the molecule."
        },
        {
            "sample_id": 9625,
            "vt": "SELECT COUNT(DISTINCT T.atom_id) FROM atom WHERE atom.element <> '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct atoms from the 'atom' table that are not of a specified element type. The placeholder in the WHERE clause represents the element that should be excluded from the count."
        },
        {
            "sample_id": 9624,
            "vt": "SELECT COUNT(bond.bond_id) FROM bond WHERE bond.bond_type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of bonds from the 'bond' table that match a specific bond type. The placeholder in the WHERE clause represents the type of bond being queried."
        },
        {
            "sample_id": 9749,
            "vt": "SELECT T.molecule_id FROM (SELECT molecule.molecule_id, COUNT(atom.atom_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING COUNT(T2.atom_id) > 5) AS t",
            "ba": "The virtual table identifies molecules that are not carcinogenic and contain more than five atoms. It does this by joining the 'molecule' table with the 'atom' table, filtering for molecules labeled as non-carcinogenic, and counting the number of atoms associated with each molecule. The result is a list of molecule IDs that meet these criteria."
        },
        {
            "sample_id": 9643,
            "vt": "SELECT SUBSTRING(bond.bond_id, [placeholder-type:numeric], [placeholder-type:numeric]), bond.molecule_id || SUBSTRING(bond.bond_id, [placeholder-type:numeric], [placeholder-type:numeric]) FROM bond WHERE bond.molecule_id = '[placeholder-type:string]' AND bond.bond_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves specific information about bonds from the 'bond' table, including a substring of the bond ID and a concatenated string of the molecule ID with the bond ID. The query filters results based on a specific molecule ID and bond ID, both represented by placeholders."
        },
        {
            "sample_id": 9665,
            "vt": "SELECT connected.bond_id FROM atom INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE connected.bond_id IN (SELECT connected.bond_id FROM connected AS T3 INNER JOIN atom AS T4 ON T3.atom_id = T4.atom_id WHERE T4.element = 'p') AND atom.element = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the bond IDs of atoms that are connected to a specific type of element, while also filtering for bonds that are connected to atoms of phosphorus. The query uses inner joins to link the 'atom' and 'connected' tables, ensuring that only relevant connections are considered based on the specified element."
        },
        {
            "sample_id": 9728,
            "vt": "SELECT DISTINCT bond.molecule_id, atom.element FROM bond INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE bond.bond_type = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct molecule IDs and their corresponding elements from the 'bond' and 'atom' tables, filtered by a specific bond type. The placeholder in the WHERE clause represents the type of bond being queried."
        },
        {
            "sample_id": 9661,
            "vt": "SELECT COUNT(connected.bond_id) FROM connected WHERE SUBSTRING(connected.atom_id, -[placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of bonds between atoms in the 'connected' table where the last part of the 'atom_id' matches a specified string value. The placeholder in the SUBSTRING function represents the number of characters to consider from the end of the 'atom_id', and the other placeholder represents the specific string to match against."
        },
        {
            "sample_id": 9697,
            "vt": "SELECT DISTINCT bond.molecule_id FROM bond WHERE bond.bond_type = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct molecule identifiers from the 'bond' table based on a specified bond type. The placeholder in the WHERE clause represents the type of bond being queried, such as single, double, or triple bonds."
        },
        {
            "sample_id": 9623,
            "vt": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(DISTINCT T1.atom_id) FROM atom INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE bond.bond_type = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of carbon atoms in a specific type of bond within a molecule. It counts the distinct carbon atoms and divides that by the total distinct atoms in the molecule, then multiplies by a numeric placeholder to adjust the result. The query joins the 'atom' and 'bond' tables based on the molecule identifier and filters the results based on the specified bond type."
        },
        {
            "sample_id": 9742,
            "vt": "SELECT bond.bond_type FROM bond INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE connected.atom_id = '[placeholder-type:string]' AND connected.atom_id2 = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the type of bond between two specific atoms from the 'bond' table. It uses an inner join with the 'connected' table to link the bond information to the corresponding atoms. The placeholders represent the unique identifiers of the two atoms being queried."
        },
        {
            "sample_id": 9693,
            "vt": "SELECT connected.bond_id, connected.atom_id2, atom.element FROM atom INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE connected.bond_id = '[placeholder-type:string]' AND (atom.element = '[placeholder-type:string]' OR atom.element = '[placeholder-type:string]')",
            "ba": "The virtual table describes the bond information between atoms in a molecule, specifically retrieving the bond ID, the second atom's ID, and the element type of the first atom. The query filters results based on a specific bond ID and allows for filtering by one or two specific element types."
        },
        {
            "sample_id": 9751,
            "vt": "SELECT T.molecule_id FROM (SELECT molecule.molecule_id, COUNT(atom.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' GROUP BY T2.molecule_id ORDER BY COUNT(T1.atom_id) DESC LIMIT 1) AS t",
            "ba": "The virtual table retrieves the molecule_id of the molecule that has the highest number of atoms and is classified as carcinogenic. It does this by joining the atom and molecule tables, filtering for molecules labeled as carcinogenic, counting the atoms for each molecule, and ordering the results to find the one with the most atoms."
        },
        {
            "sample_id": 9730,
            "vt": "SELECT COUNT(connected.bond_id) FROM connected INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE atom.element = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of bonds between atoms of a specific element in the 'connected' table. It joins the 'connected' table with the 'atom' table to filter based on the element type, using a placeholder for the element's name."
        },
        {
            "sample_id": 9755,
            "vt": "SELECT COUNT(atom.atom_id) FROM atom WHERE atom.molecule_id = '[placeholder-type:string]' AND atom.element = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of atoms from the 'atom' table that belong to a specific molecule and are of a specific element type. The placeholders represent the molecule's identifier and the element's name."
        },
        {
            "sample_id": 9756,
            "vt": "SELECT atom.element FROM atom INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE atom.atom_id = '[placeholder-type:string]' AND molecule.label = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the elements of a specific atom from the 'atom' table, while ensuring that the atom belongs to a molecule with a specific carcinogenic label from the 'molecule' table. The placeholders represent the atom's unique identifier and the carcinogenic label of the molecule."
        },
        {
            "sample_id": 9710,
            "vt": "SELECT molecule.label FROM atom INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE atom.atom_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the carcinogenic label of a molecule associated with a specific atom from the 'atom' and 'molecule' tables. The placeholder in the WHERE clause represents the unique identifier of the atom."
        },
        {
            "sample_id": 9747,
            "vt": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE atom.element = '[placeholder-type:string]' AND molecule.label = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct molecules from the 'molecule' table that are associated with a specific element from the 'atom' table and have a certain carcinogenic label. The placeholders represent the element type and the carcinogenic status of the molecules."
        },
        {
            "sample_id": 9633,
            "vt": "SELECT DISTINCT atom.atom_id FROM atom INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE molecule.label = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique identifiers of atoms from the 'atom' table that are part of molecules classified by their carcinogenic properties. The query joins the 'atom' table with the 'molecule' table to filter based on the carcinogenic label, and it also connects to the 'connected' table to ensure the relationship between atoms is considered. The placeholder in the WHERE clause represents the carcinogenic label of the molecule."
        },
        {
            "sample_id": 9660,
            "vt": "SELECT COUNT(DISTINCT T.molecule_id) FROM bond WHERE bond.bond_type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct molecules from the 'bond' table that have a specific type of bond. The placeholder in the WHERE clause represents the type of bond being queried."
        },
        {
            "sample_id": 9760,
            "vt": "SELECT atom.atom_id FROM atom INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE molecule.molecule_id = '[placeholder-type:string]' AND bond.bond_type = '[placeholder-type:string]' AND atom.element = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of atoms from the 'atom' table that are part of a specific molecule and have a specific bond type, while also filtering based on the element type of the atom. The query uses inner joins to connect the 'atom', 'molecule', and 'bond' tables based on their relationships defined by foreign keys."
        },
        {
            "sample_id": 9622,
            "vt": "SELECT DISTINCT molecule.molecule_id FROM bond INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE bond.bond_type = '[placeholder-type:string]' AND molecule.label = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct molecule IDs from the 'molecule' table based on specific bond types and carcinogenic labels. It joins the 'bond' table with the 'molecule' table to filter results according to the bond type and the carcinogenic status of the molecules."
        },
        {
            "sample_id": 9694,
            "vt": "SELECT DISTINCT molecule.molecule_id FROM atom INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE bond.bond_type = '[placeholder-type:string]' AND atom.element = '[placeholder-type:string]' AND molecule.label = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct molecule IDs from the 'molecule' table based on specific criteria related to atoms and bonds. It filters the results by the type of bond, the element of the atom, and whether the molecule is carcinogenic or not, using placeholders for these values."
        },
        {
            "sample_id": 9705,
            "vt": "SELECT molecule.label FROM atom INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE atom.element = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the carcinogenic label of molecules from the 'molecule' table based on the element type of atoms from the 'atom' table. The placeholder in the WHERE clause represents the specific element being queried."
        },
        {
            "sample_id": 9682,
            "vt": "SELECT COUNT(atom.atom_id) FROM atom INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE bond.bond_type = '[placeholder-type:string]' AND atom.element IN ('[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table counts the number of atoms from the 'atom' table that are part of a specific molecule and have a certain bond type. It joins the 'atom' table with the 'molecule' table to ensure that the atoms belong to the specified molecule, and it also joins with the 'bond' table to filter based on the bond type. Additionally, it checks if the element of the atom is one of the specified elements using placeholders for both bond type and element values."
        },
        {
            "sample_id": 9707,
            "vt": "SELECT atom.element FROM atom INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE bond.bond_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the elements of atoms that are connected through a specific bond in the molecular structure. It joins the 'atom' table with the 'connected' table to find the relevant connections and then further joins with the 'bond' table to filter by a specific bond identifier. The placeholder in the WHERE clause represents the bond's unique identifier."
        },
        {
            "sample_id": 9648,
            "vt": "SELECT ROUND(CAST(COUNT(CASE WHEN bond.bond_type = '[placeholder-type:string]' THEN bond.bond_id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(bond.bond_id), [placeholder-type:numeric]) FROM bond WHERE bond.molecule_id = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of a specific type of bond in a given molecule. It counts the number of bonds of a specified type and divides it by the total number of bonds in that molecule, then multiplies by a numeric factor and rounds the result to a specified number of decimal places."
        },
        {
            "sample_id": 9675,
            "vt": "SELECT DISTINCT atom.element FROM bond INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE bond.bond_type = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct elements of atoms that are connected by a specific type of bond. It joins the 'bond' table with the 'connected' table to find the relevant connections and then further joins with the 'atom' table to get the elements of those atoms. The placeholder in the WHERE clause represents the type of bond being queried."
        },
        {
            "sample_id": 9720,
            "vt": "SELECT CAST(COUNT(CASE WHEN atom.element = '[placeholder-type:string]' AND molecule.label = '[placeholder-type:string]' THEN molecule.molecule_id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(molecule.molecule_id) FROM atom INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id",
            "ba": "The virtual table calculates the proportion of molecules containing a specific element that are classified as carcinogenic or not, based on the provided placeholders. It counts the total number of molecules and the number of those that match the specified element and carcinogenic label, then computes the ratio multiplied by a numeric placeholder."
        },
        {
            "sample_id": 9632,
            "vt": "SELECT connected.atom_id, connected.atom_id2 FROM bond INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE bond.bond_type = '[placeholder-type:string]'",
            "ba": "The virtual table describes the connections between atoms in a molecule based on the type of bond they share. It retrieves the identifiers of two connected atoms from the 'connected' table, using an inner join with the 'bond' table to filter for a specific bond type. The placeholder in the WHERE clause represents the type of bond, such as single, double, or triple bond."
        },
        {
            "sample_id": 9713,
            "vt": "SELECT COUNT(molecule.molecule_id) FROM molecule WHERE molecule.label = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of molecules from the 'molecule' table that are classified as either carcinogenic or non-carcinogenic based on the label. The placeholder in the WHERE clause represents the carcinogenic status of the molecules being queried."
        },
        {
            "sample_id": 9698,
            "vt": "SELECT connected.atom_id, connected.atom_id2 FROM bond INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE bond.bond_type = '[placeholder-type:string]'",
            "ba": "The virtual table describes the connections between atoms in a molecule based on the type of bond they share. It retrieves the identifiers of two connected atoms from the 'connected' table, using an inner join with the 'bond' table to filter for a specific bond type. The placeholder in the WHERE clause represents the type of bond, such as single, double, or triple bond."
        },
        {
            "sample_id": 9711,
            "vt": "SELECT molecule.label FROM molecule WHERE molecule.molecule_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the carcinogenic label of a specific molecule from the 'molecule' table based on its unique identifier. The placeholder in the WHERE clause represents the molecule's ID."
        },
        {
            "sample_id": 9677,
            "vt": "SELECT ROUND(CAST(COUNT(CASE WHEN molecule.label = '[placeholder-type:string]' THEN bond.bond_id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(bond.bond_id), [placeholder-type:numeric]) FROM bond INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE bond.bond_type = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of bonds in a specific type of molecule that are associated with a certain label indicating whether the molecule is carcinogenic or not. It does this by counting the number of bonds that belong to molecules with the specified label and dividing it by the total number of bonds of a specified type, then multiplying by a numeric placeholder for scaling. The result is rounded to a specified number of decimal places."
        },
        {
            "sample_id": 9678,
            "vt": "SELECT COUNT(atom.atom_id) FROM atom WHERE atom.element = '[placeholder-type:string]' OR atom.element = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of atoms from the 'atom' table that are of specific elements. The placeholders in the WHERE clause represent the names of the elements being queried."
        },
        {
            "sample_id": 9717,
            "vt": "SELECT COUNT(atom.atom_id) FROM atom INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE molecule.label = '[placeholder-type:string]' AND atom.element = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of atoms from the 'atom' table that belong to molecules with a specific carcinogenic label and are of a specific element type. The placeholders in the WHERE clause represent the carcinogenic label and the element type."
        },
        {
            "sample_id": 9630,
            "vt": "SELECT T.label FROM (SELECT molecule.label, COUNT(molecule.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'h' GROUP BY T2.label ORDER BY COUNT(T2.molecule_id) DESC LIMIT 1) AS t",
            "ba": "The virtual table retrieves the label of the molecule that contains the highest number of hydrogen atoms. It does this by joining the 'atom' and 'molecule' tables based on their molecule IDs, filtering for atoms that are hydrogen, and then counting the occurrences of each molecule. The result is ordered in descending order to get the molecule with the most hydrogen atoms, limited to one result."
        },
        {
            "sample_id": 9719,
            "vt": "SELECT atom.atom_id FROM atom INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE atom.element = '[placeholder-type:string]' AND molecule.label = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of atoms from the 'atom' table that belong to a specific molecule, filtered by the element type and the carcinogenic label of the molecule."
        },
        {
            "sample_id": 9714,
            "vt": "SELECT atom.atom_id FROM atom WHERE atom.molecule_id BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND atom.element = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of atoms from the 'atom' table that belong to a specific range of molecules and are of a specified element type. The placeholders in the WHERE clause represent the range of molecule IDs and the element type."
        },
        {
            "sample_id": 9680,
            "vt": "SELECT DISTINCT bond.bond_type FROM atom INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE atom.element = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct bond types from the 'bond' table based on the elements of atoms connected to those bonds. It joins the 'atom' table with the 'connected' table to find connections between atoms and then joins with the 'bond' table to get the bond types. The placeholder in the WHERE clause represents the specific element of the atom being queried."
        },
        {
            "sample_id": 9738,
            "vt": "SELECT DISTINCT atom.molecule_id FROM atom INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE atom.element = '[placeholder-type:string]' AND molecule.label = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct molecule identifiers from the 'atom' table, filtering based on the element type of the atom and the carcinogenic label of the molecule. The query uses an inner join to connect the 'atom' and 'molecule' tables based on their shared 'molecule_id'."
        },
        {
            "sample_id": 9685,
            "vt": "SELECT CAST(COUNT(CASE WHEN (SELECT T1.atom_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-').element = '[placeholder-type:string]' THEN (SELECT T1.atom_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-').atom_id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT((SELECT T1.atom_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-').atom_id) FROM (SELECT atom.atom_id, atom.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-') AS t",
            "ba": "The virtual table calculates the proportion of a specific type of atom in molecules that have only single bonds. It counts the number of atoms of a specified element and divides it by the total number of atoms in those molecules, then multiplies the result by a numeric placeholder to scale the value. The placeholders represent the element type and a numeric factor for scaling."
        },
        {
            "sample_id": 9669,
            "vt": "SELECT DISTINCT atom.element FROM atom WHERE NOT atom.element IN (SELECT DISTINCT atom.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id)",
            "ba": "The virtual table lists distinct elements from the 'atom' table that are not connected to any other atoms through bonds. The subquery identifies elements that are part of connected atoms, and the main query filters out these elements from the distinct list of all elements in the 'atom' table."
        },
        {
            "sample_id": 9745,
            "vt": "SELECT molecule.label FROM molecule WHERE molecule.molecule_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the carcinogenic label of a specific molecule from the 'molecule' table based on its unique identifier. The placeholder in the WHERE clause represents the molecule's ID."
        },
        {
            "sample_id": 9731,
            "vt": "SELECT atom.atom_id, COUNT(DISTINCT T2.bond_type), atom.molecule_id FROM atom INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE atom.molecule_id = '[placeholder-type:string]' GROUP BY atom.atom_id, bond.bond_type",
            "ba": "The virtual table provides a count of distinct bond types associated with each atom in a specific molecule. It retrieves the unique atom IDs and their corresponding molecule ID from the 'atom' table, while joining with the 'bond' table to access bond types. The placeholder in the WHERE clause represents the specific molecule's ID for which the data is being queried."
        },
        {
            "sample_id": 9620,
            "vt": "SELECT AVG(subquery_subquery.single_bond_count) FROM (SELECT molecule.molecule_id, COUNT(bond.bond_type) FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T3.label = '+' GROUP BY T3.molecule_id) AS subquery",
            "ba": "The virtual table calculates the average number of single bonds for carcinogenic molecules. It does this by first identifying the relevant molecules that are labeled as carcinogenic. Then, it counts the number of single bonds associated with each of these molecules. Finally, it computes the average of these counts."
        },
        {
            "sample_id": 9708,
            "vt": "SELECT CAST(COUNT(CASE WHEN bond.bond_type = '[placeholder-type:string]' THEN bond.bond_id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(bond.bond_id) FROM bond",
            "ba": "The virtual table calculates the proportion of a specific type of bond in relation to the total number of bonds present in the 'bond' table. The placeholder in the COUNT function represents the bond type being queried, while the second placeholder is a numeric value that scales the result of the calculation."
        },
        {
            "sample_id": 9670,
            "vt": "SELECT connected.atom_id, connected.atom_id2 FROM atom INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE bond.bond_type = '[placeholder-type:string]' AND bond.molecule_id = '[placeholder-type:string]'",
            "ba": "The virtual table describes the connections between atoms in a molecule based on specific bond types. It retrieves the identifiers of two connected atoms from the 'connected' table, while joining with the 'atom' and 'bond' tables to filter by a specific bond type and molecule identifier. The placeholders represent the bond type and molecule ID that can be specified by the user."
        },
        {
            "sample_id": 9748,
            "vt": "SELECT DISTINCT atom.molecule_id FROM atom INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE atom.element = '[placeholder-type:string]' AND bond.bond_type = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct molecule identifiers from the 'atom' table by joining it with the 'bond' table. It filters the results based on a specific element type and bond type, allowing users to identify unique molecules that contain a certain element and have a specific type of bond."
        },
        {
            "sample_id": 9636,
            "vt": "SELECT DISTINCT molecule.label FROM atom INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE atom.element <> '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct labels indicating whether molecules are carcinogenic or not from the 'molecule' table, based on the elements present in the 'atom' table. The placeholder in the WHERE clause represents an element that should not be included in the results."
        },
        {
            "sample_id": 9637,
            "vt": "SELECT COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END), COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) FROM atom INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE bond.bond_type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct atoms of specific elements (iodine and sulfur) that are connected through bonds of a specified type. It joins the 'atom', 'connected', and 'bond' tables to filter the results based on the bond type provided by the user."
        },
        {
            "sample_id": 9684,
            "vt": "SELECT DISTINCT bond.molecule_id FROM bond INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE molecule.label = '[placeholder-type:string]' AND bond.bond_type = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct molecule identifiers from the 'bond' table, which are associated with specific bond types and their carcinogenic labels. The query joins the 'bond' table with the 'molecule' table to filter results based on the carcinogenic label and bond type specified by placeholders."
        },
        {
            "sample_id": 9635,
            "vt": "SELECT bond.bond_type FROM bond INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE connected.atom_id = '[placeholder-type:string]' AND connected.atom_id2 = '[placeholder-type:string]' OR connected.atom_id2 = '[placeholder-type:string]' AND connected.atom_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the type of bond between two specified atoms from the 'bond' table. It uses an inner join with the 'connected' table to find the relevant bond based on the atom IDs provided. The placeholders represent the IDs of the two atoms being queried, allowing users to specify which atoms they are interested in."
        },
        {
            "sample_id": 9757,
            "vt": "SELECT COUNT(DISTINCT T1.molecule_id) FROM atom INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE bond.bond_type = '[placeholder-type:string]' AND atom.element = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct molecules from the 'atom' table that are connected by bonds of a specific type and contain atoms of a specific element. The placeholders in the WHERE clause represent the bond type and the element of the atoms."
        },
        {
            "sample_id": 9752,
            "vt": "SELECT CAST(SUM(CASE WHEN molecule.label = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(DISTINCT T1.molecule_id) FROM molecule INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T1.molecule_id = T3.molecule_id WHERE bond.bond_type = '[placeholder-type:string]' AND atom.element = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average based on the labels of molecules, specifically focusing on whether they are carcinogenic or not. It sums up values conditionally based on the label of the molecule and divides by the count of distinct molecules, while also filtering for specific bond types and elements of atoms."
        },
        {
            "sample_id": 9650,
            "vt": "SELECT ROUND(CAST(COUNT(CASE WHEN atom.element = '[placeholder-type:string]' THEN atom.atom_id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(atom.atom_id), [placeholder-type:numeric]) FROM atom WHERE atom.molecule_id = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of a specific type of atom in a given molecule. It counts the number of atoms of a specified element and divides it by the total number of atoms in that molecule, then multiplies by a specified numeric value and rounds the result to a specified number of decimal places."
        },
        {
            "sample_id": 9617,
            "vt": "SELECT (SELECT bond_type, COUNT(bond_id) FROM bond GROUP BY bond_type ORDER BY COUNT(bond_id) DESC LIMIT 1).bond_type FROM (SELECT bond.bond_type, COUNT(bond.bond_id) FROM bond GROUP BY bond_type ORDER BY COUNT(bond_id) DESC LIMIT 1) AS t",
            "ba": "The virtual table identifies the most common type of bond among the bonds present in the 'bond' table. It does this by counting the occurrences of each bond type and selecting the one with the highest count. The placeholder in the query represents the bond type that is most frequently found."
        },
        {
            "sample_id": 9734,
            "vt": "SELECT DISTINCT molecule.label FROM atom INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE bond.bond_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct labels indicating whether molecules are carcinogenic or not from the 'molecule' table. It joins the 'atom' table to identify the relevant molecules and the 'bond' table to filter based on a specific bond identified by a placeholder. The placeholder represents the bond's unique identifier."
        },
        {
            "sample_id": 9621,
            "vt": "SELECT COUNT(DISTINCT T2.molecule_id) FROM atom INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE atom.element = '[placeholder-type:string]' AND molecule.label = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct molecules from the 'atom' and 'molecule' tables based on specific criteria. It filters atoms by their element type and checks if the corresponding molecule is carcinogenic or not."
        },
        {
            "sample_id": 9744,
            "vt": "SELECT atom.element FROM atom WHERE atom.atom_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the element type of a specific atom from the 'atom' table based on its unique identifier. The placeholder in the WHERE clause represents the unique id of the atom being queried."
        },
        {
            "sample_id": 9646,
            "vt": "SELECT connected.bond_id FROM connected WHERE connected.atom_id2 = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the bond ID from the 'connected' table for a specific atom identified by its ID. The placeholder in the WHERE clause represents the ID of the second atom involved in the connection."
        },
        {
            "sample_id": 9754,
            "vt": "SELECT COUNT(DISTINCT T.molecule_id) FROM bond WHERE bond.molecule_id BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND bond.bond_type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct molecules from the 'bond' table that fall within a specified range of molecule IDs and have a specific bond type. The placeholders represent the range of molecule IDs and the bond type to filter the results accordingly."
        },
        {
            "sample_id": 9642,
            "vt": "SELECT DISTINCT atom.element FROM atom WHERE atom.molecule_id = '[placeholder-type:string]' ORDER BY atom.element LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct elements from the 'atom' table for a specific molecule identified by its molecule_id. The results are ordered by the element type and limited to a specified number of entries."
        },
        {
            "sample_id": 9699,
            "vt": "SELECT atom.element FROM atom INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE connected.bond_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the elements of atoms that are connected by a specific bond in the molecular structure. It uses an inner join between the 'atom' table and the 'connected' table to find the relevant atoms based on their IDs, filtered by a placeholder for the bond ID."
        },
        {
            "sample_id": 9702,
            "vt": "SELECT DISTINCT bond.bond_id, molecule.label FROM bond INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE bond.bond_type = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of bond IDs along with their corresponding molecule labels from the 'bond' and 'molecule' tables. It filters the results based on a specific bond type, which is represented by a placeholder for string values."
        },
        {
            "sample_id": 9712,
            "vt": "SELECT DISTINCT atom.element FROM atom WHERE atom.molecule_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct elements from the 'atom' table for a specific molecule identified by its molecule_id. The placeholder in the WHERE clause represents the unique identifier of the molecule."
        },
        {
            "sample_id": 9725,
            "vt": "SELECT COUNT(bond.bond_id), molecule.label FROM bond INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE bond.bond_type = '[placeholder-type:string]' AND molecule.molecule_id = '[placeholder-type:string]' GROUP BY molecule.label",
            "ba": "The virtual table provides a count of bonds of a specific type for a given molecule, along with the carcinogenic label of that molecule. It joins the 'bond' table with the 'molecule' table to retrieve the necessary information, filtering by bond type and molecule ID."
        },
        {
            "sample_id": 9666,
            "vt": "SELECT molecule.label FROM molecule INNER JOIN (SELECT T.molecule_id, COUNT(T.bond_type) FROM bond AS T WHERE T.bond_type = '=' GROUP BY T.molecule_id ORDER BY COUNT(T.bond_type) DESC LIMIT 1) AS T2 ON T1.molecule_id = T2.molecule_id",
            "ba": "The virtual table retrieves the label of the molecule that has the highest number of double bonds. It does this by first counting the number of double bonds for each molecule in the 'bond' table, then selecting the molecule with the maximum count and joining it with the 'molecule' table to get the corresponding label."
        },
        {
            "sample_id": 9758,
            "vt": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE bond.bond_type = '[placeholder-type:string]' AND molecule.label = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct molecules from the 'molecule' table that are associated with a specific type of bond from the 'bond' table. It filters the results based on the bond type and whether the molecule is carcinogenic or not, using placeholders for these criteria."
        },
        {
            "sample_id": 9663,
            "vt": "SELECT COUNT(molecule.molecule_id) FROM molecule WHERE molecule.label = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of molecules from the 'molecule' table based on their carcinogenic label. The placeholder in the WHERE clause represents whether the molecules are carcinogenic or not."
        },
        {
            "sample_id": 9724,
            "vt": "SELECT DISTINCT atom.element FROM atom INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE connected.bond_id = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct elements of atoms that are connected by a specific bond in the 'atom' table. It uses an inner join with the 'connected' table to filter the results based on the bond ID provided as a placeholder."
        },
        {
            "sample_id": 9736,
            "vt": "SELECT COUNT(bond.bond_id) FROM bond WHERE bond.bond_type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of bonds from the 'bond' table that match a specific bond type. The placeholder in the WHERE clause represents the type of bond being queried."
        },
        {
            "sample_id": 9759,
            "vt": "SELECT DISTINCT atom.element, bond.bond_type FROM atom INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE atom.molecule_id = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct elements and bond types associated with a specific molecule from the 'atom' and 'bond' tables. The placeholder in the WHERE clause represents the unique identifier of the molecule."
        },
        {
            "sample_id": 9691,
            "vt": "SELECT COUNT(bond.bond_id) FROM atom INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE atom.element = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of bonds associated with atoms of a specific element from the 'atom' table, while also joining with the 'molecule' and 'bond' tables to ensure the correct relationships are maintained. The placeholder in the WHERE clause represents the element type being queried."
        },
        {
            "sample_id": 9679,
            "vt": "SELECT DISTINCT connected.atom_id2 FROM atom INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE atom.element = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct identifiers of atoms that are connected to a specific atom of a given element from the 'atom' table. The connection is established through the 'connected' table, which links pairs of atoms via their bond identifiers. The placeholder in the WHERE clause represents the element type of the atom being queried."
        },
        {
            "sample_id": 9709,
            "vt": "SELECT CAST(COUNT(CASE WHEN bond.bond_type = '[placeholder-type:string]' THEN bond.bond_id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(bond.bond_id) FROM bond WHERE bond.molecule_id = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of a specific type of bond in a given molecule. It counts the number of bonds of a specified type and divides it by the total number of bonds in that molecule, then multiplies the result by a numeric placeholder. The placeholders represent the bond type, molecule ID, and a numeric multiplier."
        },
        {
            "sample_id": 9683,
            "vt": "SELECT DISTINCT bond.bond_id FROM bond INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE molecule.label = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves unique bond identifiers from the 'bond' table for molecules that are classified as either carcinogenic or non-carcinogenic. The query uses an inner join to connect the 'bond' table with the 'molecule' table based on the molecule's ID, filtering the results based on the carcinogenic label provided as a placeholder."
        },
        {
            "sample_id": 9733,
            "vt": "SELECT COUNT(DISTINCT T1.molecule_id) FROM atom INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE atom.element <> '[placeholder-type:string]' AND bond.bond_type <> '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct molecules from the 'atom' table that are associated with bonds from the 'bond' table, filtering out specific elements and bond types. The placeholders represent the element to exclude and the bond type to exclude."
        },
        {
            "sample_id": 9739,
            "vt": "SELECT COUNT(CASE WHEN molecule.label = '[placeholder-type:string]' AND atom.element = '[placeholder-type:string]' THEN molecule.molecule_id ELSE NULL END) * [placeholder-type:numeric] / COUNT(molecule.molecule_id) FROM atom INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id",
            "ba": "The virtual table calculates the proportion of molecules with a specific carcinogenic label that contain a certain element, scaled by a numeric factor. It counts the number of molecules that match the specified label and element, and divides this by the total number of molecules, multiplying the result by a placeholder for numeric values."
        },
        {
            "sample_id": 9750,
            "vt": "SELECT atom.element FROM atom INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE atom.molecule_id = '[placeholder-type:string]' AND bond.bond_type = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the elements of atoms from the 'atom' table that are part of a specific molecule and have a specific type of bond. The placeholders represent the molecule's identifier and the bond type."
        },
        {
            "sample_id": 9619,
            "vt": "SELECT AVG(subquery_oxygen_counts.oxygen_count) FROM (SELECT atom.molecule_id, COUNT(atom.element) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '-' AND T1.element = 'o' GROUP BY T1.molecule_id) AS oxygen_counts",
            "ba": "The virtual table calculates the average count of oxygen atoms in molecules that are connected by non-carcinogenic bonds. It first identifies the relevant tables, 'atom' and 'bond', and performs an inner join on the 'molecule_id' to link atoms to their respective bonds. The query filters for bonds that are non-carcinogenic (indicated by the bond type '-') and counts the number of oxygen atoms (where the element is 'o') for each molecule. Finally, it computes the average of these counts across all relevant molecules."
        },
        {
            "sample_id": 9631,
            "vt": "SELECT DISTINCT bond.bond_type FROM bond INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE atom.element = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct bond types from the 'bond' table, which represent the connections between atoms in various molecules. It uses inner joins to connect the 'bond' table with the 'connected' table and the 'atom' table, filtering the results based on a specific element type from the 'atom' table. The placeholder in the WHERE clause allows users to specify the element they are interested in."
        },
        {
            "sample_id": 9618,
            "vt": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE atom.element = '[placeholder-type:string]' AND molecule.label = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct molecules from the 'molecule' table that contain atoms of a specific element and have a specific carcinogenic label. The placeholders represent the element type and the carcinogenic status of the molecules."
        },
        {
            "sample_id": 9729,
            "vt": "SELECT atom.element FROM connected INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE connected.bond_id = '[placeholder-type:string]'",
            "ba": "The virtual table describes the elements of atoms that are connected by a specific bond in the database. It retrieves the element type from the 'atom' table by joining it with the 'connected' table based on the bond identifier. The placeholder in the WHERE clause represents the bond's unique identifier."
        }
    ],
    "mondial_geo": [
        {
            "sample_id": 8437,
            "vt": "SELECT country.name FROM country INNER JOIN economy AS T2 ON T1.Code = T2.Country ORDER BY economy.gdp LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table that are joined with their corresponding economic data from the 'economy' table. The results are ordered by the gross domestic product (GDP) in descending order, and the number of countries returned is limited by a specified numeric placeholder."
        },
        {
            "sample_id": 8250,
            "vt": "SELECT COUNT(located.city) FROM located INNER JOIN lake AS T2 ON T1.Lake = T2.Name WHERE lake.type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cities that are located near lakes of a specific type. It joins the 'located' table, which contains information about cities and their locations, with the 'lake' table to filter lakes based on their type. The placeholder in the WHERE clause represents the type of lake being queried."
        },
        {
            "sample_id": 8466,
            "vt": "SELECT country.name, country.name FROM country INNER JOIN borders AS T2 ON T1.Code = T2.Country1 INNER JOIN country AS T3 ON T3.Code = T2.Country2 ORDER BY borders.length LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries that share borders with each other, along with the length of their borders. It retrieves data from the 'country' table and joins it with the 'borders' table to find pairs of countries. The results are ordered by the length of the border, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 8348,
            "vt": "SELECT language.country FROM language WHERE language.name = '[placeholder-type:string]' AND language.percentage = [placeholder-type:numeric]",
            "ba": "The virtual table lists the countries where a specific language is spoken, along with the percentage of speakers of that language in each country. The placeholders in the WHERE clause represent the language name and the percentage of speakers."
        },
        {
            "sample_id": 8381,
            "vt": "SELECT country.capital FROM mountain INNER JOIN geo_mountain AS T2 ON T1.Name = T2.Mountain INNER JOIN province AS T3 ON T3.Name = T2.Province INNER JOIN country AS T4 ON T4.Province = T3.Name WHERE mountain.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the capital city of a country that has a specific mountain. It joins the 'mountain' table with the 'geo_mountain' table to find the province where the mountain is located, and then it joins with the 'province' table to get the corresponding country. The placeholder in the WHERE clause represents the name of the mountain being queried."
        },
        {
            "sample_id": 8417,
            "vt": "SELECT located.city FROM sea INNER JOIN located AS T2 ON T1.Name = T2.Sea INNER JOIN city AS T3 ON T3.Name = T2.City WHERE (SELECT sea.depth FROM sea WHERE Name LIKE '%Bengal%') - sea.depth = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of cities that are located near a specific sea, where the depth of that sea differs from a certain value. It involves joining the 'sea' table with the 'located' table to find cities associated with the sea, and then filtering based on the depth of the sea."
        },
        {
            "sample_id": 8447,
            "vt": "SELECT continent.area, COUNT(country.name) FROM continent INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent INNER JOIN country AS T3 ON T3.Code = T2.Country WHERE continent.name = '[placeholder-type:string]' GROUP BY continent.name, continent.area",
            "ba": "The virtual table provides the total area of a specified continent along with the count of countries that are part of that continent. It joins the 'continent' table with the 'encompasses' table to link countries to their respective continents, and then counts the number of countries associated with the specified continent's name."
        },
        {
            "sample_id": 8356,
            "vt": "SELECT language.percentage * country.population FROM language INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE language.name = '[placeholder-type:string]' AND country.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total population of speakers of a specific language in a specific country by multiplying the percentage of that language spoken in the country by the country's total population. It retrieves data from the 'language' and 'country' tables, joining them on the country code."
        },
        {
            "sample_id": 8492,
            "vt": "SELECT country.name FROM population INNER JOIN country AS T2 ON T1.Country = T2.Code ORDER BY population.infant_mortality LIMIT [placeholder-type:numeric] OFFSET [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table, which are joined with the 'population' table to filter based on infant mortality rates. The results are ordered by the infant mortality rate in ascending order, and the query allows for pagination through the use of LIMIT and OFFSET placeholders."
        },
        {
            "sample_id": 8374,
            "vt": "SELECT province.country, economy.service, SUM(province.population) / SUM(province.area) FROM province INNER JOIN economy AS T2 ON T1.Country = T2.Country WHERE province.country IN (SELECT economy.country FROM encompasses WHERE Continent = 'Europe') GROUP BY province.country, economy.service ORDER BY COUNT(province.name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the population density of provinces in Europe, along with their service sector contribution to the economy. It calculates the population density by dividing the total population of each province by its area. The data is filtered to include only those provinces that belong to countries in Europe, and it groups the results by country and service sector contribution. The results are ordered by the number of provinces and limited to a specified number of entries."
        },
        {
            "sample_id": 8445,
            "vt": "SELECT country.name FROM country WHERE country.code IN (SELECT politics.country FROM politics WHERE government = 'British Overseas Territories')",
            "ba": "The virtual table lists the names of countries that are classified under the British Overseas Territories. It retrieves this information by first filtering the 'politics' table to find countries with a specific type of government, and then using those country codes to select the corresponding country names from the 'country' table."
        },
        {
            "sample_id": 8239,
            "vt": "SELECT population.infant_mortality FROM country INNER JOIN population AS T2 ON T1.Code = T2.Country WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the infant mortality rate from the 'population' table for a specific country. It joins the 'country' table to filter the results based on the country's name provided as a placeholder."
        },
        {
            "sample_id": 8441,
            "vt": "SELECT country.name FROM country INNER JOIN language AS T2 ON T1.Code = T2.Country WHERE language.name = '[placeholder-type:string]' AND language.percentage = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of countries from the 'country' table that have a specific language spoken within them, along with the percentage of that language's prevalence. The query uses an inner join to connect the 'country' table with the 'language' table based on the country code. The placeholders in the WHERE clause represent the name of the language and its corresponding percentage in the country."
        },
        {
            "sample_id": 8507,
            "vt": "SELECT desert.name FROM desert WHERE desert.latitude < [placeholder-type:numeric] OR desert.latitude > [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of deserts from the 'desert' table that are located either below a certain latitude or above a certain latitude. The placeholders in the WHERE clause represent the latitude values that define the boundaries for filtering the deserts."
        },
        {
            "sample_id": 8401,
            "vt": "SELECT politics.independence FROM country INNER JOIN politics AS T2 ON T1.Code = T2.Country WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the independence date of a specific country from the 'country' and 'politics' tables. It uses an inner join to connect these tables based on the country code, allowing for the selection of the independence date corresponding to the specified country name."
        },
        {
            "sample_id": 8468,
            "vt": "SELECT country.name FROM country INNER JOIN borders AS T2 ON T1.Code = T2.Country1 WHERE borders.length > [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries that share a border with another country, where the length of that border exceeds a specified numeric value. It utilizes an inner join between the 'country' table and the 'borders' table to filter countries based on the length of their borders."
        },
        {
            "sample_id": 8486,
            "vt": "SELECT country.capital FROM country INNER JOIN politics AS T2 ON T1.Code = T2.Country WHERE politics.government = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the capital cities of countries from the 'country' table, filtering based on the type of government as specified in the 'politics' table. The placeholder in the WHERE clause represents the type of government being queried."
        },
        {
            "sample_id": 8312,
            "vt": "SELECT desert.name FROM country INNER JOIN encompasses AS T2 ON T1.Code = T2.Country INNER JOIN continent AS T3 ON T3.Name = T2.Continent INNER JOIN geo_desert AS T4 ON T4.Country = T1.Code INNER JOIN desert AS T5 ON T5.Name = T4.Desert WHERE continent.name = '[placeholder-type:string]' ORDER BY desert.area LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of deserts from the 'desert' table that are located in countries belonging to a specific continent. It joins multiple tables to filter deserts based on the continent's name and limits the results based on a specified number."
        },
        {
            "sample_id": 8455,
            "vt": "SELECT country.name FROM country INNER JOIN organization AS T2 ON T1.Code = T2.Country INNER JOIN politics AS T3 ON T3.Country = T2.Country WHERE STRFTIME('%Y', organization.established) > '[placeholder-type:string]' AND politics.government = '[placeholder-type:string]' GROUP BY country.name ORDER BY COUNT(DISTINCT T2.Name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries that are associated with organizations established after a certain year and have a specific type of government. The query joins the 'country', 'organization', and 'politics' tables to filter and group the results based on the conditions provided."
        },
        {
            "sample_id": 8327,
            "vt": "SELECT AVG(city.population) FROM city INNER JOIN located AS T2 ON T1.Name = T2.City INNER JOIN sea AS T3 ON T3.Name = T2.Sea WHERE sea.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average population of cities that are located near a specific sea. It joins the 'city' table with the 'located' table to find the cities associated with the specified sea, and then computes the average of their populations."
        },
        {
            "sample_id": 8235,
            "vt": "SELECT country.name, population.population_growth FROM country INNER JOIN population AS T2 ON T1.Code = T2.Country ORDER BY population.infant_mortality LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table presents the names of countries along with their population growth rates. It retrieves data from the 'country' table and joins it with the 'population' table based on the country code. The results are ordered by the infant mortality rate, and a limit is applied to restrict the number of records returned."
        },
        {
            "sample_id": 8430,
            "vt": "SELECT country.name, country.capital FROM country ORDER BY country.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of countries along with their capitals, sorted by the population of each country. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return."
        },
        {
            "sample_id": 8308,
            "vt": "SELECT COUNT(DISTINCT T1.Name) FROM country INNER JOIN politics AS T2 ON T1.Code = T2.Country INNER JOIN borders AS T3 ON T3.Country1 = T2.Country WHERE politics.government = '[placeholder-type:string]' AND borders.length > [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of countries that have a specific type of government and share a border with another country, where the length of the border exceeds a specified value. It combines data from the 'country', 'politics', and 'borders' tables to achieve this."
        },
        {
            "sample_id": 8388,
            "vt": "SELECT island.longitude FROM mountain INNER JOIN mountainOnIsland AS T2 ON T1.Name = T2.Mountain INNER JOIN island AS T3 ON T3.Name = T2.Island WHERE mountain.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the longitude of islands that have mountains on them, specifically filtering for a mountain with a given name. It joins the 'mountain' table with the 'mountainOnIsland' table to find the corresponding islands, and then selects the longitude from the 'island' table."
        },
        {
            "sample_id": 8355,
            "vt": "SELECT geo_desert.country, desert.latitude, desert.longitude FROM desert INNER JOIN geo_desert AS T2 ON T1.Name = T2.Desert WHERE desert.name = (SELECT desert.name FROM desert ORDER BY Area ASC LIMIT 1)",
            "ba": "The virtual table provides information about the country, latitude, and longitude of the smallest desert from the 'desert' table. It uses an inner join with the 'geo_desert' table to link the desert's name with its geographical data, filtering for the desert with the smallest area."
        },
        {
            "sample_id": 8277,
            "vt": "SELECT COUNT(DISTINCT T2.Mountain) FROM country INNER JOIN geo_mountain AS T2 ON T1.Code = T2.Country WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct mountains associated with a specific country. It retrieves data from the 'country' table and joins it with the 'geo_mountain' table based on the country code. The placeholder in the WHERE clause represents the name of the country for which the distinct mountain count is being queried."
        },
        {
            "sample_id": 8439,
            "vt": "SELECT religion.country FROM country INNER JOIN religion AS T2 ON T1.Code = T2.Country INNER JOIN language AS T3 ON T3.Country = T2.Country WHERE (religion.name = '[placeholder-type:string]' OR religion.name = '[placeholder-type:string]' OR religion.name = '[placeholder-type:string]') AND language.name = '[placeholder-type:string]' AND language.percentage = [placeholder-type:numeric] GROUP BY country.name HAVING COUNT(country.name) = [placeholder-type:numeric]",
            "ba": "The virtual table identifies countries that have specific religions and languages. It retrieves the country codes from the 'country' table, joining it with the 'religion' table to filter by specified religion names and with the 'language' table to filter by a specific language name and its percentage. The results are grouped by country, ensuring that only countries with a certain count of matching religions are included."
        },
        {
            "sample_id": 8431,
            "vt": "SELECT MAX(continent.area) - MIN(continent.area) FROM continent WHERE continent.name = '[placeholder-type:string]' OR continent.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between the maximum and minimum area of continents specified by their names. The placeholders represent the names of the continents for which this area difference is being calculated."
        },
        {
            "sample_id": 8254,
            "vt": "SELECT country.name FROM country INNER JOIN language AS T2 ON T1.Code = T2.Country GROUP BY country.name ORDER BY COUNT(language.name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table that are associated with languages from the 'language' table. It groups the results by country name and orders them based on the count of languages spoken in each country, limiting the output to a specified number of countries."
        },
        {
            "sample_id": 8337,
            "vt": "SELECT river.name, river.length FROM city INNER JOIN located AS T2 ON T1.Name = T2.City INNER JOIN river AS T3 ON T3.Name = T2.River WHERE city.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and lengths of rivers that are located in a specific city. It retrieves data from the 'city' table and joins it with the 'located' table to find the corresponding river for that city, and then joins with the 'river' table to get the length of each river."
        },
        {
            "sample_id": 8320,
            "vt": "SELECT city.name, city.population FROM city INNER JOIN locatedOn AS T2 ON T1.Name = T2.City INNER JOIN island AS T3 ON T3.Name = T2.Island WHERE island.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and populations of cities that are located on a specific island. It retrieves data from the 'city' table and joins it with the 'locatedOn' table to find the relationship between cities and islands, filtering the results based on the specified island name."
        },
        {
            "sample_id": 8280,
            "vt": "SELECT encompasses.percentage FROM country INNER JOIN encompasses AS T2 ON T1.Code = T2.Country INNER JOIN continent AS T3 ON T3.Name = T2.Continent WHERE continent.name = '[placeholder-type:string]' AND country.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the percentage of a country's area that belongs to a specified continent. It joins the 'country' table with the 'encompasses' table to link country codes with their respective continent names, and filters the results based on the specified continent and country names."
        },
        {
            "sample_id": 8273,
            "vt": "SELECT borders.country1, borders.country2 FROM country INNER JOIN borders AS T2 ON T1.Code = T2.Country1 ORDER BY borders.length LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays pairs of countries that share a border, along with the length of that border. It retrieves the country codes from the 'borders' table and joins it with the 'country' table to ensure that the country codes are valid. The results are ordered by the length of the border, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 8389,
            "vt": "SELECT country.name FROM country INNER JOIN economy AS T2 ON T1.Code = T2.Country WHERE country.area < [placeholder-type:numeric] ORDER BY economy.gdp LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table that have an area smaller than a specified value. It joins the 'country' table with the 'economy' table to access economic data, specifically the GDP, for sorting purposes. The results are ordered by GDP in ascending order and limited to a specified number of entries."
        },
        {
            "sample_id": 8256,
            "vt": "SELECT language.country FROM country INNER JOIN language AS T2 ON T1.Code = T2.Country WHERE country.population < [placeholder-type:numeric] GROUP BY language.country HAVING COUNT(country.name) > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a list of countries that have a population below a specified threshold. It joins the 'country' table with the 'language' table to ensure that only countries with a certain number of languages are included. The placeholders in the query represent the population limit and the minimum count of languages a country must have."
        },
        {
            "sample_id": 8400,
            "vt": "SELECT COUNT(mountain.name) FROM mountain INNER JOIN geo_mountain AS T2 ON T1.Name = T2.Mountain INNER JOIN province AS T3 ON T3.Name = T2.Province INNER JOIN country AS T4 ON T4.Province = T3.Name WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of mountains from the 'mountain' table that are located in a specific country. It joins the 'geo_mountain' table to link mountains with their geographical locations, the 'province' table to associate those locations with provinces, and the 'country' table to filter by a specific country name. The placeholder in the WHERE clause represents the name of the country for which the mountain count is being queried."
        },
        {
            "sample_id": 8483,
            "vt": "SELECT country.population FROM country INNER JOIN population AS T2 ON T1.Code = T2.Country ORDER BY population.infant_mortality LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the population of countries from the 'country' table, joining it with the 'population' table to access additional demographic information. The results are ordered by the infant mortality rate, allowing for an analysis of population in relation to this health metric. The query limits the number of results returned based on a specified numeric placeholder."
        },
        {
            "sample_id": 8413,
            "vt": "SELECT * FROM river WHERE river.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves all information about a specific river from the 'river' table based on its name. The placeholder in the WHERE clause represents the name of the river being queried."
        },
        {
            "sample_id": 8294,
            "vt": "SELECT country.population * (ethnicgroup.percentage - ethnicgroup.percentage) FROM ethnicgroup INNER JOIN ethnicGroup AS T2 ON T1.Country = T2.Country INNER JOIN country AS T3 ON T1.Country = T3.Code WHERE ethnicgroup.name = '[placeholder-type:string]' AND ethnicgroup.name = '[placeholder-type:string]' AND country.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the population of a specific country based on the percentage of two ethnic groups within that country. It joins the 'ethnicgroup' table with itself to compare two different ethnic groups and also joins with the 'country' table to access the country's population. The placeholders represent the names of the ethnic groups and the country."
        },
        {
            "sample_id": 8278,
            "vt": "SELECT island.latitude FROM island INNER JOIN mountainOnIsland AS T2 ON T1.Name = T2.Island WHERE mountainonisland.mountain = '[placeholder-type:string]'",
            "ba": "The virtual table provides the latitude of islands that have specific mountains located on them. It retrieves this information by joining the 'island' table with the 'mountainOnIsland' table, filtering for a particular mountain using a placeholder."
        },
        {
            "sample_id": 8378,
            "vt": "SELECT language.percentage FROM language INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE country.name = '[placeholder-type:string]' AND language.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the percentage of a specific language spoken in a specified country. It joins the 'language' table with the 'country' table to filter results based on the country's name and the language's name."
        },
        {
            "sample_id": 8315,
            "vt": "SELECT COUNT(DISTINCT T1.Name) FROM country INNER JOIN language AS T2 ON T1.Code = T2.Country INNER JOIN population AS T3 ON T3.Country = T2.Country WHERE language.name = '[placeholder-type:string]' AND population.population_growth < [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of countries that have a specific language and a population growth rate below a certain threshold. It joins the 'country' table with the 'language' table to filter by language name, and also joins with the 'population' table to apply the condition on population growth."
        },
        {
            "sample_id": 8449,
            "vt": "SELECT country.name FROM country INNER JOIN politics AS T2 ON T1.Code = T2.Country ORDER BY politics.independence LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table that are joined with the 'politics' table to filter based on their independence status. The results are ordered by the date of independence, and a limit is applied to restrict the number of countries returned."
        },
        {
            "sample_id": 8311,
            "vt": "SELECT COUNT(continent.name) FROM country INNER JOIN encompasses AS T2 ON T1.Code = T2.Country INNER JOIN continent AS T3 ON T3.Name = T2.Continent INNER JOIN province AS T4 ON T4.Country = T1.Code INNER JOIN geo_mountain AS T5 ON T5.Province = T4.Name WHERE continent.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of countries that belong to a specific continent. It joins the 'country' table with the 'encompasses' table to link countries to their respective continents, and further joins with the 'province' and 'geo_mountain' tables to ensure that the provinces of those countries are considered. The placeholder in the WHERE clause represents the name of the continent being queried."
        },
        {
            "sample_id": 8249,
            "vt": "SELECT COUNT(country.name) FROM country INNER JOIN economy AS T2 ON T1.Code = T2.Country WHERE economy.agriculture < [placeholder-type:numeric] AND country.area > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of countries from the 'country' table that have an agriculture percentage in their economy below a specified threshold and an area greater than a specified size. The placeholders represent the numeric values for the agriculture percentage and the area of the country."
        },
        {
            "sample_id": 8457,
            "vt": "SELECT mountain.name FROM mountain INNER JOIN geo_mountain AS T2 ON T1.Name = T2.Mountain INNER JOIN province AS T3 ON T3.Name = T2.Province WHERE province.name = '[placeholder-type:string]' AND mountain.type = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of mountains from the 'mountain' table that are located in a specific province and of a certain type. The placeholders in the WHERE clause represent the province's name and the type of the mountain."
        },
        {
            "sample_id": 8429,
            "vt": "SELECT country.capital, country.province FROM country WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the capital and province of a specific country from the 'country' table. The placeholder in the WHERE clause represents the name of the country being queried."
        },
        {
            "sample_id": 8435,
            "vt": "SELECT lake.name FROM lake ORDER BY lake.area * lake.depth LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of lakes from the 'lake' table, ordered by the product of their area and depth. The placeholder in the LIMIT clause allows the user to specify the maximum number of lake names to retrieve."
        },
        {
            "sample_id": 8338,
            "vt": "SELECT mountain.height, mountain.latitude, mountain.longitude FROM mountain INNER JOIN geo_mountain AS T2 ON T1.Name = T2.Mountain INNER JOIN province AS T3 ON T3.Name = T2.Province INNER JOIN located AS T4 ON T4.Province = T3.Name WHERE located.river = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the height, latitude, and longitude of mountains that are located near a specific river. It combines data from the 'mountain' table with geographical information from the 'geo_mountain' table, and further links to the 'province' table to ensure the mountains are in the correct province. The filtering condition specifies a particular river using a placeholder for string values."
        },
        {
            "sample_id": 8342,
            "vt": "SELECT geo_river.province, river.name FROM geo_river INNER JOIN river AS T2 ON T1.River = T2.Name WHERE river.length > [placeholder-type:numeric]",
            "ba": "The virtual table describes the provinces and names of rivers from the 'geo_river' table that are associated with rivers in the 'river' table, filtered by the length of the river being greater than a specified numeric value. The placeholders represent the length of the river."
        },
        {
            "sample_id": 8478,
            "vt": "SELECT borders.length FROM borders WHERE borders.country1 = '[placeholder-type:string]' AND borders.country2 = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the length of the border between two specified countries from the 'borders' table. The placeholders represent the country codes for both countries involved in the border measurement."
        },
        {
            "sample_id": 8509,
            "vt": "SELECT province.capprov FROM province WHERE province.population < [placeholder-type:numeric] ORDER BY province.population / province.area LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of provinces' capitals from the 'province' table where the population of the province is below a specified threshold. The results are ordered by the population density (population divided by area) and limited to a certain number of entries."
        },
        {
            "sample_id": 8335,
            "vt": "SELECT CAST(SUM(CASE WHEN mountain.type <> '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM mountain WHERE mountain.mountains = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average height of mountains that belong to a specific mountain range. It sums the heights of mountains that are not of a specified type and divides this sum by the total count of mountains in that range, applying a scaling factor represented by a placeholder."
        },
        {
            "sample_id": 8420,
            "vt": "SELECT borders.country1, borders.country2 FROM continent INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent INNER JOIN country AS T3 ON T3.Code = T2.Country INNER JOIN borders AS T4 ON T4.Country1 = T3.Code WHERE continent.name = '[placeholder-type:string]' AND borders.length = [placeholder-type:numeric]",
            "ba": "The virtual table describes the countries that share borders with each other, filtered by a specific continent and the length of the border. The placeholders represent the continent's name and the length of the border between the countries."
        },
        {
            "sample_id": 8346,
            "vt": "SELECT MAX(city.population) - MIN(city.population) FROM city INNER JOIN located AS T2 ON T1.Name = T2.City INNER JOIN river AS T3 ON T3.Name = T2.River WHERE river.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between the maximum and minimum population of cities that are located near a specific river. It joins the 'city' table with the 'located' table to find cities associated with the specified river, and then it retrieves the population data to compute the desired difference."
        },
        {
            "sample_id": 8221,
            "vt": "SELECT economy.gdp, politics.government FROM economy INNER JOIN politics AS T2 ON T1.Country = T2.Country INNER JOIN country AS T3 ON T3.Code = T2.Country WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the GDP and type of government of a specific country. It combines data from the 'economy' and 'politics' tables by matching the country codes, and also includes the 'country' table to filter results based on the country's name."
        },
        {
            "sample_id": 8329,
            "vt": "SELECT river.name FROM river WHERE river.sea = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of rivers that flow into a specific sea. The placeholder in the WHERE clause represents the name of the sea."
        },
        {
            "sample_id": 8279,
            "vt": "SELECT country.code FROM country INNER JOIN geo_mountain AS T2 ON T1.Code = T2.Country WHERE geo_mountain.mountain = (SELECT country.name FROM mountain ORDER BY Height DESC LIMIT 1 OFFSET 1)",
            "ba": "The virtual table retrieves the country code of the country that has the second highest mountain. It does this by joining the 'country' table with the 'geo_mountain' table, where it matches the country code with the country associated with a specific mountain. The mountain selected is determined by a subquery that orders mountains by their height in descending order and limits the result to the second highest mountain."
        },
        {
            "sample_id": 8324,
            "vt": "SELECT city.province, province.capital FROM province INNER JOIN city AS T2 ON T1.Name = T2.Province AND T1.Country = T2.Country WHERE city.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the province and its capital for a specific city. It retrieves the province name and the corresponding capital by joining the 'province' table with the 'city' table based on matching province and country codes. The placeholder in the WHERE clause represents the name of the city for which the information is being queried."
        },
        {
            "sample_id": 8485,
            "vt": "SELECT politics.government FROM country INNER JOIN economy AS T2 ON T1.Code = T2.Country INNER JOIN politics AS T3 ON T3.Country = T2.Country ORDER BY economy.agriculture LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides information about the type of government in various countries, along with their economic data. It combines data from the 'country', 'economy', and 'politics' tables. The results are ordered by the percentage of agriculture in the economy, and the number of results returned is limited by a numeric placeholder."
        },
        {
            "sample_id": 8350,
            "vt": "SELECT DISTINCT located.river FROM located INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE country.name = '[placeholder-type:string]' AND NOT located.river IS NULL",
            "ba": "The virtual table lists distinct rivers from the 'located' table that are associated with a specific country. It filters the results based on the country name provided, ensuring that only rivers that are not null are included in the output."
        },
        {
            "sample_id": 8297,
            "vt": "SELECT country.capital FROM country INNER JOIN geo_mountain AS T2 ON T1.Code = T2.Country GROUP BY country.name, country.capital HAVING COUNT(country.name) > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the capitals of countries that have more than a specified number of mountains. It joins the 'country' table with the 'geo_mountain' table based on the country code, grouping the results by country name and capital, and filtering the groups to include only those with a count of mountains exceeding a placeholder value."
        },
        {
            "sample_id": 8228,
            "vt": "SELECT politics.country FROM population INNER JOIN politics AS T2 ON T1.Country = T2.Country WHERE politics.government = '[placeholder-type:string]' ORDER BY population.population_growth LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists countries that have a specific type of government, along with their population growth rates. The query joins the 'population' and 'politics' tables on the country code to filter the results based on the government type specified by the user. The results are ordered by population growth and limited to a specified number of entries."
        },
        {
            "sample_id": 8340,
            "vt": "SELECT mountain.name, mountain.height FROM mountain INNER JOIN geo_mountain AS T2 ON T1.Name = T2.Mountain INNER JOIN province AS T3 ON T3.Name = T2.Province INNER JOIN geo_source AS T4 ON T4.Province = T3.Name WHERE geo_source.river = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and heights of mountains that are associated with a specific river. It retrieves data from the 'mountain' table and joins it with the 'geo_mountain', 'province', and 'geo_source' tables to filter mountains based on the river they are connected to."
        },
        {
            "sample_id": 8368,
            "vt": "SELECT sea.name FROM islandin INNER JOIN sea AS T2 ON T2.Name = T1.Sea WHERE islandin.island = (SELECT island.name FROM island ORDER BY Area DESC LIMIT 1)",
            "ba": "The virtual table lists the names of seas that are associated with the largest island in terms of area. It does this by joining the 'islandin' table, which connects islands to various bodies of water, with the 'sea' table to retrieve the names of those seas. The largest island is determined by selecting the island with the maximum area from the 'island' table."
        },
        {
            "sample_id": 8323,
            "vt": "SELECT DISTINCT island.name, city.name FROM city INNER JOIN locatedOn AS T2 ON T1.Name = T2.City INNER JOIN island AS T3 ON T3.Name = T2.Island WHERE island.area < [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct names of islands and cities from the 'city' and 'island' tables, respectively. It filters the results to include only those islands that have an area smaller than a specified numeric value. The query uses inner joins to connect the 'city' table with the 'locatedOn' table and then with the 'island' table, ensuring that only relevant records are selected based on the area condition."
        },
        {
            "sample_id": 8469,
            "vt": "SELECT country.name FROM ismember INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE ismember.organization = '[placeholder-type:string]' ORDER BY country.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries that are members of a specified organization. It retrieves data from the 'ismember' table, which links countries to organizations, and joins it with the 'country' table to access country names. The results are ordered by the population of the countries, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 8347,
            "vt": "SELECT river.name, river.length FROM river INNER JOIN located AS T2 ON T1.Name = T2.River INNER JOIN city AS T3 ON T3.Name = T2.City WHERE city.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and lengths of rivers that are located in a specific city. It retrieves data from the 'river' table and joins it with the 'located' table to find the corresponding city. The placeholder in the WHERE clause represents the name of the city for which the river information is being queried."
        },
        {
            "sample_id": 8397,
            "vt": "SELECT country.name FROM continent INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent INNER JOIN country AS T3 ON T3.Code = T2.Country GROUP BY country.name HAVING COUNT(country.name) > [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries that are part of a continent, specifically those that belong to more than a specified number of countries. It utilizes joins to connect the 'continent', 'encompasses', and 'country' tables, ensuring that only countries meeting the count criteria are included in the results."
        },
        {
            "sample_id": 8344,
            "vt": "SELECT DISTINCT river.name, river.length FROM city INNER JOIN located AS T2 ON T1.Name = T2.City INNER JOIN river AS T3 ON T3.Name = T2.River WHERE located.country = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of distinct rivers along with their lengths that are associated with cities in a specific country. The query joins the 'city' table with the 'located' table to find the cities and their corresponding rivers, filtering the results based on the specified country code."
        },
        {
            "sample_id": 8353,
            "vt": "SELECT ethnicgroup.percentage * country.population FROM country INNER JOIN ethnicGroup AS T2 ON T1.Code = T2.Country WHERE country.name = '[placeholder-type:string]' AND ethnicgroup.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total population represented by a specific ethnic group within a specified country. It does this by multiplying the percentage of the ethnic group by the total population of the country. The placeholders in the WHERE clause represent the country's name and the ethnic group's name, allowing users to specify which country and ethnic group they are interested in."
        },
        {
            "sample_id": 8502,
            "vt": "SELECT STRFTIME('%Y', organization.established) FROM continent INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent INNER JOIN country AS T3 ON T2.Country = T3.Code INNER JOIN organization AS T4 ON T4.Country = T3.Code WHERE continent.name = '[placeholder-type:string]' GROUP BY STRFTIME('%Y', organization.established) ORDER BY COUNT(organization.name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of years when organizations were established, grouped by year, for countries that belong to a specific continent. The placeholder in the WHERE clause represents the name of the continent, while the LIMIT placeholder specifies the maximum number of years to return."
        },
        {
            "sample_id": 8264,
            "vt": "SELECT COUNT(economy.country) FROM economy INNER JOIN population AS T2 ON T1.Country = T2.Country WHERE economy.gdp > [placeholder-type:numeric] AND population.population_growth > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of countries from the 'economy' table that have a gross domestic product (GDP) greater than a specified value and a population growth rate greater than another specified value. It achieves this by joining the 'economy' table with the 'population' table on the country code, ensuring that only countries meeting both criteria are included in the count."
        },
        {
            "sample_id": 8383,
            "vt": "SELECT DISTINCT country.name FROM city INNER JOIN located AS T2 ON T1.Name = T2.City INNER JOIN river AS T3 ON T3.Name = T2.River INNER JOIN country AS T4 ON T4.Code = T2.Country WHERE river.name = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct country names from the 'country' table based on cities that are located near a specific river. It joins the 'city' table with the 'located' table to find the cities associated with the river, and then links to the 'river' table to filter by a specific river name. The placeholder in the WHERE clause represents the name of the river."
        },
        {
            "sample_id": 8423,
            "vt": "SELECT island.islands FROM island INNER JOIN mountainOnIsland AS T2 ON T1.Name = T2.Island INNER JOIN mountain AS T3 ON T3.Name = T2.Mountain WHERE mountain.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the group of islands that contain a specific mountain. It retrieves the 'islands' from the 'island' table by joining it with the 'mountainOnIsland' table to find the relationship between mountains and islands, and then further joins with the 'mountain' table to filter by a specific mountain name."
        },
        {
            "sample_id": 8412,
            "vt": "SELECT country.capital FROM country WHERE country.population <= (SELECT MAX(country.population) - MAX(country.population) * [placeholder-type:numeric] FROM country)",
            "ba": "The virtual table retrieves the capital cities of countries from the 'country' table where the population of those countries is less than or equal to a certain percentage of the maximum population found in the same table. The placeholder in the WHERE clause represents a numeric value that indicates the percentage of the maximum population to filter the results."
        },
        {
            "sample_id": 8461,
            "vt": "SELECT organization.name FROM organization WHERE STRFTIME('%Y', organization.established) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of organizations from the 'organization' table that were established within a specific range of years. The placeholders in the WHERE clause represent the start and end years of the establishment period."
        },
        {
            "sample_id": 8362,
            "vt": "SELECT politics.government, politics.government FROM politics INNER JOIN borders AS T2 ON T1.Country = T2.Country1 INNER JOIN politics AS T3 ON T3.Country = T2.Country2 ORDER BY borders.length LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides information about the types of government in countries that share borders. It retrieves the government types from the 'politics' table for each country involved in the border relationship, joining the 'borders' table to identify the countries that share a border. The results are ordered by the length of the border and limited to a specified number of entries."
        },
        {
            "sample_id": 8233,
            "vt": "SELECT country.capital, country.population FROM country INNER JOIN economy AS T2 ON T1.Code = T2.Country WHERE economy.gdp > [placeholder-type:numeric]",
            "ba": "The virtual table provides information about countries, specifically their capital cities and populations, filtered by those countries that have a gross domestic product (GDP) exceeding a specified threshold. The query joins the 'country' table with the 'economy' table to access GDP data."
        },
        {
            "sample_id": 8326,
            "vt": "SELECT locatedon.city, locatedon.province FROM locatedon WHERE locatedon.island IN (SELECT island.name FROM island WHERE Type = 'coral')",
            "ba": "The virtual table describes the cities and provinces from the 'locatedon' table that are situated on coral islands. The query filters the results by checking if the islands belong to a specific type, which is 'coral'."
        },
        {
            "sample_id": 8428,
            "vt": "SELECT country.population / country.area FROM country INNER JOIN organization AS T2 ON T1.Code = T2.Country WHERE STRFTIME('%Y', organization.established) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the population density of countries by dividing the population by the area. It retrieves data from the 'country' table and joins it with the 'organization' table to filter countries based on the year of establishment of organizations. The placeholder in the WHERE clause represents the specific year of establishment being queried."
        },
        {
            "sample_id": 8352,
            "vt": "SELECT city.province, city.population FROM city INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE country.name = '[placeholder-type:string]' ORDER BY city.population LIMIT [placeholder-type:numeric] OFFSET [placeholder-type:numeric]",
            "ba": "The virtual table provides information about the provinces and populations of cities from the 'city' table that are located in a specific country. It joins the 'city' table with the 'country' table to filter cities based on the country's name, and it allows for pagination through the use of LIMIT and OFFSET placeholders."
        },
        {
            "sample_id": 8493,
            "vt": "SELECT country.name FROM country INNER JOIN religion AS T2 ON T1.Code = T2.Country GROUP BY country.name ORDER BY COUNT(DISTINCT T2.Name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table that have associated religions. It uses an inner join to connect the 'country' table with the 'religion' table based on the country code. The results are grouped by country name and ordered by the count of distinct religions associated with each country. The limit on the number of results is specified by a numeric placeholder."
        },
        {
            "sample_id": 8260,
            "vt": "SELECT COUNT(organization.province) FROM country INNER JOIN organization AS T2 ON T1.Code = T2.Country INNER JOIN ethnicGroup AS T3 ON T3.Country = T2.Country GROUP BY country.name ORDER BY COUNT(ethnicgroup.name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of organizations based in each country, grouped by country name. It joins the 'country' table with the 'organization' table to associate organizations with their respective countries, and further joins with the 'ethnicgroup' table to count the number of ethnic groups present in each country. The result is ordered by the count of ethnic groups, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 8490,
            "vt": "SELECT mountain.height, mountain.name FROM mountain WHERE mountain.type = '[placeholder-type:string]' ORDER BY mountain.height LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the heights and names of mountains from the 'mountain' table that belong to a specific type of mountain. The placeholders in the WHERE clause represent the type of mountain and the limit on the number of results to return."
        },
        {
            "sample_id": 8427,
            "vt": "SELECT politics.independence FROM politics WHERE economy.country = (SELECT economy.country FROM economy WHERE GDP = 1100)",
            "ba": "The virtual table retrieves the independence date of a country from the 'politics' table, where the country is identified by its GDP from the 'economy' table. The placeholder in the subquery represents the GDP value used to filter the country."
        },
        {
            "sample_id": 8316,
            "vt": "SELECT AVG(economy.agriculture) FROM continent INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent INNER JOIN country AS T3 ON T3.Code = T2.Country INNER JOIN economy AS T4 ON T4.Country = T3.Code WHERE continent.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average percentage of agriculture in the GDP for countries that belong to a specific continent. It joins the 'continent' table with the 'encompasses' table to find the countries in that continent, then joins with the 'country' table to get the country codes, and finally joins with the 'economy' table to access the agriculture data."
        },
        {
            "sample_id": 8234,
            "vt": "SELECT economy.service * economy.gdp FROM country INNER JOIN economy AS T2 ON T1.Code = T2.Country WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total service sector contribution to the GDP of a specific country by multiplying the service percentage of the economy with the GDP value. It retrieves this information by joining the 'country' table with the 'economy' table based on the country code."
        },
        {
            "sample_id": 8358,
            "vt": "SELECT DISTINCT country.name FROM located INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE located.sea = (SELECT country.name FROM sea ORDER BY Depth ASC LIMIT 1)",
            "ba": "The virtual table lists the distinct names of countries that have cities located by the shallowest sea. It joins the 'located' table, which contains information about cities and their geographical features, with the 'country' table to retrieve the country names based on the country code. The filtering condition ensures that only those countries whose cities are adjacent to the sea with the least depth are included."
        },
        {
            "sample_id": 8322,
            "vt": "SELECT DISTINCT city.name FROM island WHERE island.area > (SELECT DISTINCT island.area FROM city AS T1 INNER JOIN locatedOn AS T2 ON T1.Name = T2.City INNER JOIN island AS T3 ON T3.Name = T2.Island WHERE T1.Province = 'Warwickshire')",
            "ba": "The virtual table lists the distinct names of cities that are located on islands with an area greater than the area of islands where cities in the province of Warwickshire are located."
        },
        {
            "sample_id": 8266,
            "vt": "SELECT lake.area * [placeholder-type:numeric] / country.area FROM located INNER JOIN lake AS T2 ON T1.Lake = T2.Name INNER JOIN country AS T3 ON T3.Code = T1.Country ORDER BY lake.longitude LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the area of lakes in relation to the area of their respective countries. It retrieves the area of each lake and multiplies it by a specified numeric placeholder, then divides this product by the area of the corresponding country. The results are ordered by the longitude of the lakes, and a limit is applied to the number of results returned, which is also specified by a numeric placeholder."
        },
        {
            "sample_id": 8503,
            "vt": "SELECT borders.country2, borders.length FROM country INNER JOIN borders AS T2 ON T1.Code = T2.Country1 INNER JOIN country AS T3 ON T3.Code = T2.Country2 WHERE country.name = (SELECT country.name FROM country ORDER BY Population DESC LIMIT 1)",
            "ba": "The virtual table provides information about the second country and the length of the border it shares with the most populous country. It retrieves data from the 'borders' table, which contains border information between countries, and joins it with the 'country' table to filter based on the country with the highest population."
        },
        {
            "sample_id": 8314,
            "vt": "SELECT COUNT(country.name) FROM country INNER JOIN encompasses AS T2 ON T1.Code = T2.Country INNER JOIN continent AS T3 ON T3.Name = T2.Continent INNER JOIN population AS T4 ON T4.Country = T1.Code WHERE continent.name = '[placeholder-type:string]' AND population.infant_mortality < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of countries from the 'country' table that are part of a specific continent and have an infant mortality rate below a specified threshold. It joins the 'country' table with the 'encompasses' table to link countries to continents, and then further joins with the 'continent' and 'population' tables to apply the necessary filters."
        },
        {
            "sample_id": 8268,
            "vt": "SELECT country.name FROM country INNER JOIN economy AS T2 ON T1.Code = T2.Country GROUP BY country.name, economy.inflation HAVING economy.inflation > AVG(economy.inflation) * [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries that have an inflation rate higher than the average inflation rate of all countries, based on data from the 'country' and 'economy' tables. The query groups the results by country name and inflation rate, using a placeholder for the numeric value to specify the threshold for comparison."
        },
        {
            "sample_id": 8476,
            "vt": "SELECT country.capital, organization.name FROM organization INNER JOIN country AS T2 ON T1.City = T2.Capital WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table displays the capital city of a specified country along with the name of the organization headquartered in that capital. The query joins the 'organization' table with the 'country' table to retrieve this information, filtering by the country's name using a placeholder."
        },
        {
            "sample_id": 8361,
            "vt": "SELECT politics.country FROM politics INNER JOIN population AS T2 ON T1.Country = T2.Country WHERE STRFTIME('%Y', politics.independence) = '[placeholder-type:string]' ORDER BY population.infant_mortality LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the countries from the 'politics' table that gained independence in a specific year. It joins with the 'population' table to filter the results based on the infant mortality rate, allowing for an ordered output of countries based on this demographic metric. The placeholders represent the year of independence and the limit on the number of results returned."
        },
        {
            "sample_id": 8448,
            "vt": "SELECT country.province FROM country INNER JOIN organization AS T2 ON T1.Code = T2.Country WHERE country.name = '[placeholder-type:string]' GROUP BY country.province ORDER BY COUNT(country.name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the provinces associated with a specific country from the 'country' table, while also considering the organizations present in those provinces. It uses an inner join to connect the 'country' and 'organization' tables based on the country code. The results are grouped by province and ordered by the count of organizations in each province, with a limit on the number of results returned."
        },
        {
            "sample_id": 8501,
            "vt": "SELECT politics.government FROM country INNER JOIN economy AS T2 ON T1.Code = T2.Country INNER JOIN politics AS T3 ON T3.Country = T2.Country WHERE NOT economy.gdp IS NULL ORDER BY economy.gdp LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the type of government for countries that have a recorded GDP. It joins the 'country' table with the 'economy' table to filter out countries with null GDP values, and then further joins with the 'politics' table to get the government type. The results are ordered by GDP in ascending order and limited to a specified number of entries."
        },
        {
            "sample_id": 8304,
            "vt": "SELECT mountain.name FROM country INNER JOIN politics AS T2 ON T1.Code = T2.Country INNER JOIN geo_mountain AS T3 ON T3.Country = T2.Country INNER JOIN mountain AS T4 ON T4.Name = T3.Mountain WHERE NOT politics.independence IS NULL ORDER BY mountain.height LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of mountains from the 'mountain' table that are located in countries which are independent. It retrieves this information by joining the 'country', 'politics', 'geo_mountain', and 'mountain' tables. The results are ordered by the height of the mountains, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 8238,
            "vt": "SELECT country.name, economy.gdp FROM country INNER JOIN population AS T2 ON T1.Code = T2.Country INNER JOIN economy AS T3 ON T3.Country = T2.Country WHERE population.population_growth > [placeholder-type:numeric]",
            "ba": "The virtual table presents the names of countries along with their gross domestic product (GDP) from the 'country' and 'economy' tables. It filters the results to include only those countries that have a population growth rate exceeding a specified numeric value."
        },
        {
            "sample_id": 8267,
            "vt": "SELECT SUM(population.population_growth) / COUNT(population.country) FROM country INNER JOIN language AS T2 ON T1.Code = T2.Country INNER JOIN population AS T3 ON T3.Country = T2.Country WHERE language.country IN (SELECT language.country FROM language GROUP BY Country HAVING COUNT(Country) > 3) GROUP BY population.country",
            "ba": "The virtual table calculates the average population growth rate for countries that have more than three languages spoken. It does this by summing the population growth rates from the 'population' table and dividing by the count of countries. The query joins the 'country', 'language', and 'population' tables to filter and aggregate the necessary data."
        },
        {
            "sample_id": 8359,
            "vt": "SELECT economy.country FROM politics INNER JOIN economy AS T2 ON T1.Country = T2.Country WHERE politics.government = '[placeholder-type:string]' ORDER BY economy.gdp LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the countries that have a specific type of government, along with their corresponding economic data. The query joins the 'politics' table with the 'economy' table to filter countries based on the type of government specified by the user. The results are ordered by the GDP of the countries, and the number of results returned is limited by a numeric placeholder."
        },
        {
            "sample_id": 8384,
            "vt": "SELECT country.name FROM country INNER JOIN politics AS T2 ON T1.Code = T2.Country WHERE politics.independence = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of countries from the 'country' table that have a specific independence date. It uses an inner join with the 'politics' table to filter countries based on their independence status."
        },
        {
            "sample_id": 8299,
            "vt": "SELECT COUNT((SELECT T1.Country FROM economy AS T1 INNER JOIN geo_mountain AS T2 ON T1.Country = T2.Country WHERE T1.Industry < 40 GROUP BY T1.Country HAVING COUNT(T1.Country) < 2).country) FROM (SELECT economy.country FROM economy AS T1 INNER JOIN geo_mountain AS T2 ON T1.Country = T2.Country WHERE T1.Industry < 40 GROUP BY T1.Country HAVING COUNT(T1.Country) < 2) AS t3",
            "ba": "The virtual table counts the number of countries that have less than 40% of their GDP coming from the industry sector and are associated with fewer than 2 mountains. It does this by first selecting countries from the economy table that meet the industry percentage criteria and then joining with the geo_mountain table to filter based on the number of mountains associated with each country."
        },
        {
            "sample_id": 8394,
            "vt": "SELECT religion.name FROM country INNER JOIN religion AS T2 ON T1.Code = T2.Country WHERE country.name = '[placeholder-type:string]' ORDER BY religion.percentage LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of religions practiced in a specific country, ordered by the percentage of the population that adheres to each religion. The query joins the 'country' table with the 'religion' table to filter results based on the country's name and limits the number of results returned."
        },
        {
            "sample_id": 8440,
            "vt": "SELECT country.name FROM country INNER JOIN economy AS T2 ON T1.Code = T2.Country ORDER BY economy.inflation LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table that are joined with their corresponding economic data from the 'economy' table. The results are ordered by the inflation rate in ascending order, and the number of results returned is limited by a specified numeric placeholder."
        },
        {
            "sample_id": 8305,
            "vt": "SELECT COUNT(DISTINCT T3.Name) FROM country INNER JOIN geo_mountain AS T2 ON T1.Code = T2.Country INNER JOIN mountain AS T3 ON T3.Name = T2.Mountain WHERE mountain.type = '[placeholder-type:string]' AND country.population <= [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct names of mountains from the 'mountain' table that are located in countries with a specified population limit and a specific type of mountain. It joins the 'country' table to filter based on the population of the country and the 'geo_mountain' table to link mountains to their respective countries."
        },
        {
            "sample_id": 8377,
            "vt": "SELECT language.name FROM language WHERE language.country = '[placeholder-type:string]' ORDER BY language.percentage LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of languages spoken in a specific country, ordered by the percentage of speakers. The placeholders allow users to specify the country code and the maximum number of languages to retrieve."
        },
        {
            "sample_id": 8336,
            "vt": "SELECT city.name, city.province FROM city INNER JOIN located AS T2 ON T1.Name = T2.City INNER JOIN river AS T3 ON T3.Name = T2.River WHERE river.sea = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and provinces of cities that are located near a specific river flowing into a particular sea. The placeholders in the query represent the name of the sea."
        },
        {
            "sample_id": 8270,
            "vt": "SELECT religion.name FROM country INNER JOIN religion AS T2 ON T1.Code = T2.Country WHERE country.name = '[placeholder-type:string]' ORDER BY country.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of religions from the 'religion' table that are associated with a specific country. It retrieves this information by joining the 'country' table with the 'religion' table based on the country code. The results are ordered by the population of the country, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 8246,
            "vt": "SELECT COUNT(country.name) FROM country INNER JOIN economy AS T2 ON T1.Code = T2.Country WHERE economy.gdp > [placeholder-type:numeric] AND country.population > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of countries from the 'country' table that have a GDP greater than a specified value and a population greater than another specified value. It uses an inner join with the 'economy' table to access GDP data, linking the country code from both tables."
        },
        {
            "sample_id": 8442,
            "vt": "SELECT COUNT(organization.name) FROM country INNER JOIN politics AS T2 ON T1.Code = T2.Country INNER JOIN organization AS T3 ON T3.Country = T2.Country WHERE politics.independence = NULL AND STRFTIME('%Y', organization.established) > '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of organizations headquartered in countries that are not independent and were established after a certain year. It joins the 'country' table with the 'politics' table to filter for countries without independence, and then joins with the 'organization' table to count the organizations based on their establishment year."
        },
        {
            "sample_id": 8410,
            "vt": "SELECT SUM(CASE WHEN island.area <= [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) * [placeholder-type:numeric] / COUNT(*) FROM island WHERE island.islands = '[placeholder-type:string]' AND (island.type <> '[placeholder-type:string]' OR island.type IS NULL)",
            "ba": "The virtual table calculates a weighted average of the area of islands belonging to a specific group, filtering out certain types of islands. It sums the areas of islands that are less than or equal to a specified value, applies a multiplier, and divides by the count of islands that meet the criteria. The placeholders represent the maximum area, the multiplier, and the specific group and type of islands."
        },
        {
            "sample_id": 8272,
            "vt": "SELECT country.name FROM located INNER JOIN river AS T2 ON T1.River = T2.Name INNER JOIN country AS T3 ON T3.Code = T1.Country WHERE river.name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of countries that have cities located on a specific river. It joins the 'located' table, which contains information about cities and their corresponding rivers, with the 'river' table to filter by the river's name. Additionally, it joins the 'country' table to retrieve the names of the countries associated with those cities."
        },
        {
            "sample_id": 8276,
            "vt": "SELECT COUNT(DISTINCT T2.Mountain) FROM country INNER JOIN geo_mountain AS T2 ON T1.Code = T2.Country WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct mountains located in a specific country. It joins the 'country' table with the 'geo_mountain' table based on the country code, filtering by the name of the country provided as a placeholder."
        },
        {
            "sample_id": 8217,
            "vt": "SELECT country.name FROM ethnicgroup INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE ethnicgroup.name = '[placeholder-type:string]' GROUP BY country.name, ethnicgroup.percentage ORDER BY ethnicgroup.percentage LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries that have a specific ethnic group, along with the percentage of that ethnic group in each country. The query joins the 'ethnicgroup' table with the 'country' table to filter results based on the specified ethnic group name. The results are grouped by country name and the percentage of the ethnic group, and ordered by the percentage in descending order, limiting the output to a specified number of countries."
        },
        {
            "sample_id": 8373,
            "vt": "SELECT language.percentage * country.population FROM country INNER JOIN language AS T2 ON T1.Code = T2.Country INNER JOIN politics AS T3 ON T3.Country = T2.Country WHERE politics.dependent = '[placeholder-type:string]' AND language.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total population of a specific language in a country that is dependent on another country. It does this by multiplying the percentage of the language spoken in that country by the total population of the country. The query joins the 'country', 'language', and 'politics' tables to filter for countries that are dependent on a specified country and to focus on a specific language."
        },
        {
            "sample_id": 8404,
            "vt": "SELECT MAX(river.length) / MIN(river.length) FROM located INNER JOIN river AS T2 ON T1.River = T2.Name WHERE located.country = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the ratio of the maximum length of rivers to the minimum length of rivers for a specific country. It joins the 'located' table, which contains information about cities and their associated rivers, with the 'river' table to access river lengths. The placeholder in the WHERE clause represents the country code for which this calculation is performed."
        },
        {
            "sample_id": 8399,
            "vt": "SELECT population.infant_mortality * country.population * population.population_growth FROM country INNER JOIN population AS T2 ON T1.Code = T2.Country WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the product of the infant mortality rate, total population, and population growth rate for a specific country. It retrieves this information by joining the 'country' table with the 'population' table based on the country code."
        },
        {
            "sample_id": 8450,
            "vt": "SELECT politics.country FROM politics WHERE politics.government = '[placeholder-type:string]' AND STRFTIME('%Y', politics.independence) >= '[placeholder-type:string]' AND politics.country IN (SELECT politics.country FROM country) ORDER BY politics.independence LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists countries that have a specific type of government and gained independence on or after a certain year. The results are filtered to include only those countries that exist in the 'country' table, and the output is ordered by the year of independence, with a limit on the number of results returned."
        },
        {
            "sample_id": 8436,
            "vt": "SELECT borders.country1, borders.country2 FROM borders ORDER BY borders.length LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists pairs of countries that share a border, along with the length of that border. The results are ordered by the length of the border, and a placeholder is provided to limit the number of results returned."
        },
        {
            "sample_id": 8508,
            "vt": "SELECT desert.latitude, desert.longitude FROM desert INNER JOIN geo_desert AS T2 ON T1.Name = T2.Desert GROUP BY desert.name, desert.latitude, desert.longitude HAVING COUNT(desert.name) > [placeholder-type:numeric]",
            "ba": "The virtual table provides the geographic coordinates (latitude and longitude) of deserts from the 'desert' table. It joins with the 'geo_desert' table to filter the results based on the desert's name. The results are grouped by the desert's name, latitude, and longitude, and only those deserts that appear more than a specified number of times in the data are included in the final output."
        },
        {
            "sample_id": 8465,
            "vt": "SELECT organization.name, organization.city FROM organization WHERE organization.name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and cities of organizations from the 'organization' table that match a specific name pattern. The placeholder in the WHERE clause allows for flexible searching based on the organization's name."
        },
        {
            "sample_id": 8220,
            "vt": "SELECT CAST(SUM(CASE WHEN politics.government = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(politics.country) FROM politics WHERE STRFTIME('%Y', politics.independence) > '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of a numeric value based on the type of government in the 'politics' table. It sums up a specific numeric value for countries with a specified type of government and multiplies it by a placeholder numeric value, then divides by the count of countries that have an independence date after a specified year."
        },
        {
            "sample_id": 8248,
            "vt": "SELECT country.name FROM country INNER JOIN economy AS T2 ON T1.Code = T2.Country WHERE NOT economy.inflation IS NULL ORDER BY economy.inflation LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table that have a non-null inflation rate in their economy. It joins the 'country' table with the 'economy' table based on the country code, ensuring that only countries with specified inflation rates are included. The results are ordered by the inflation rate, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 8444,
            "vt": "SELECT COUNT(DISTINCT T2.province), sea.depth FROM country INNER JOIN located AS T2 ON T1.Code = T2.Country INNER JOIN sea AS T3 ON T3.Name = T2.Sea WHERE country.code = '[placeholder-type:string]' AND sea.name = '[placeholder-type:string]' GROUP BY sea.depth",
            "ba": "The virtual table provides a count of distinct provinces associated with a specific country and sea, along with the depth of that sea. It combines data from the 'country', 'located', and 'sea' tables, filtering by the country code and sea name provided as placeholders."
        },
        {
            "sample_id": 8343,
            "vt": "SELECT geo_mountain.province, geo_mountain.country, mountain.height FROM mountain INNER JOIN geo_mountain AS T2 ON T1.Name = T2.Mountain WHERE mountain.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the province and country of a specific mountain along with its height. The query joins the 'mountain' table with the 'geo_mountain' table to retrieve the relevant information based on the mountain's name, which is represented by a placeholder."
        },
        {
            "sample_id": 8419,
            "vt": "SELECT continent.name FROM continent INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent INNER JOIN country AS T3 ON T3.Code = T2.Country INNER JOIN economy AS T4 ON T4.Country = T3.Code ORDER BY economy.inflation LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of continents from the 'continent' table, along with their associated countries and economic data. It joins the 'encompasses' table to link continents to countries, and the 'economy' table to include economic information such as inflation rates. The results are ordered by the inflation rate, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 8391,
            "vt": "SELECT city.name FROM country INNER JOIN province AS T2 ON T1.Code = T2.Country INNER JOIN city AS T3 ON T3.Province = T2.Name WHERE country.name = '[placeholder-type:string]' AND city.name <> country.capital ORDER BY city.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of cities from a specific country, excluding the capital city. It retrieves data by joining the 'country', 'province', and 'city' tables based on their relationships. The results are filtered by the country's name and ordered by the population of the cities, with a limit on the number of cities returned."
        },
        {
            "sample_id": 8363,
            "vt": "SELECT country.name FROM country INNER JOIN language AS T2 ON T1.Code = T2.Country WHERE language.name = '[placeholder-type:string]' AND language.percentage = [placeholder-type:numeric] ORDER BY country.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table that have a specific language spoken within them, along with a specified percentage of speakers. The query joins the 'country' table with the 'language' table to filter countries based on the language name and its percentage of speakers. The results are ordered by the population of the countries and limited to a specified number of entries."
        },
        {
            "sample_id": 8317,
            "vt": "SELECT COUNT(DISTINCT T1.Name) FROM country INNER JOIN politics AS T2 ON T1.Code = T2.Country INNER JOIN economy AS T3 ON T3.Country = T2.Country WHERE NOT politics.independence IS NULL AND economy.gdp > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of distinct countries that have a recorded independence date and a GDP greater than a specified value. It combines data from the 'country', 'politics', and 'economy' tables to filter out non-independent countries and those with insufficient GDP."
        },
        {
            "sample_id": 8497,
            "vt": "SELECT province.name, lake.name, lake.depth FROM lake INNER JOIN located AS T2 ON T1.Name = T2.Lake INNER JOIN province AS T3 ON T3.Name = T2.Province INNER JOIN country AS T4 ON T4.Code = T3.Country WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and depths of lakes along with their corresponding provinces from the 'lake' and 'province' tables. It filters the results based on the specified country name, ensuring that only lakes located in provinces of that country are included."
        },
        {
            "sample_id": 8426,
            "vt": "SELECT country.name FROM country INNER JOIN religion AS T2 ON T1.Code = T2.Country WHERE religion.name = '[placeholder-type:string]' ORDER BY country.population / country.area LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table that have a specific religion. It joins the 'country' table with the 'religion' table based on the country code, filtering for a specified religion name. The results are ordered by the population density (population divided by area) of each country, and the number of results returned is limited by a specified numeric value."
        },
        {
            "sample_id": 8223,
            "vt": "SELECT ethnicgroup.name FROM country INNER JOIN ethnicGroup AS T2 ON T1.Code = T2.Country WHERE country.population > [placeholder-type:numeric] GROUP BY ethnicgroup.name, ethnicgroup.percentage ORDER BY ethnicgroup.percentage LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of ethnic groups from the 'country' table, filtered by countries with a population greater than a specified number. It joins the 'country' table with the 'ethnicgroup' table to access the relevant data, groups the results by ethnic group name and percentage, and orders them by the percentage of each ethnic group. The placeholders represent the population threshold and the limit on the number of results returned."
        },
        {
            "sample_id": 8379,
            "vt": "SELECT country.name FROM country INNER JOIN located AS T2 ON T1.Code = T2.Country WHERE located.river = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of countries from the 'country' table that are associated with a specific river. The query uses an inner join with the 'located' table to filter countries based on their relationship with the specified river, represented by a placeholder."
        },
        {
            "sample_id": 8255,
            "vt": "SELECT country.capital FROM country INNER JOIN language AS T2 ON T1.Code = T2.Country WHERE language.name = '[placeholder-type:string]' AND language.percentage > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the capital cities of countries where a specific language is spoken by a significant percentage of the population. The query joins the 'country' table with the 'language' table to filter based on the language name and its percentage of speakers."
        },
        {
            "sample_id": 8443,
            "vt": "SELECT city.province FROM city INNER JOIN located AS T2 ON T1.Name = T2.City INNER JOIN river AS T3 ON T3.Name = T2.River WHERE river.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides the provinces of cities that are located near a specific river. It retrieves this information by joining the 'city' table with the 'located' table to find the relationship between cities and rivers, filtering the results based on the specified river name."
        },
        {
            "sample_id": 8257,
            "vt": "SELECT COUNT(organization.name) FROM country INNER JOIN organization AS T2 ON T1.Code = T2.Country WHERE country.population < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of organizations based in countries with a population below a specified threshold. It joins the 'country' table with the 'organization' table on the country code, filtering the results based on the population of the country."
        },
        {
            "sample_id": 8425,
            "vt": "SELECT country.name FROM country WHERE country.code IN (SELECT encompasses.country FROM encompasses GROUP BY country HAVING COUNT(continent) > 1) AND country.population / country.area <= [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries that are part of multiple continents and have a population density (population divided by area) below a specified threshold. The query first identifies countries that belong to more than one continent using a subquery on the 'encompasses' table, and then filters these countries based on their population density."
        },
        {
            "sample_id": 8376,
            "vt": "SELECT desert.name FROM desert ORDER BY desert.area LIMIT [placeholder-type:numeric] OFFSET [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of deserts from the 'desert' table, ordered by their area. The query allows for pagination by using placeholders for the limit and offset values, enabling users to specify how many desert names to retrieve and from which point in the list to start."
        },
        {
            "sample_id": 8453,
            "vt": "SELECT desert.name FROM desert INNER JOIN geo_desert AS T2 ON T1.Name = T2.Desert INNER JOIN country AS T3 ON T3.Code = T2.Country WHERE country.name = '[placeholder-type:string]' ORDER BY desert.area LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of deserts from the 'desert' table that are located in a specific country. It joins the 'geo_desert' table to find the corresponding country for each desert and filters the results based on the specified country name. The results are ordered by the area of the deserts and limited to a specified number of entries."
        },
        {
            "sample_id": 8357,
            "vt": "SELECT COUNT(geo_mountain.mountain) FROM geo_mountain WHERE geo_mountain.country = (SELECT country.code FROM country ORDER BY Area DESC LIMIT 1)",
            "ba": "The virtual table counts the number of mountains from the 'geo_mountain' table that are located in the country with the largest area. The subquery retrieves the country code of the country with the maximum area from the 'country' table, which is then used to filter the mountains in the main query."
        },
        {
            "sample_id": 8285,
            "vt": "SELECT politics.independence FROM country INNER JOIN politics AS T2 ON T1.Code = T2.Country WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the independence date of a specific country from the 'country' and 'politics' tables. It uses an inner join to connect the country code in the 'country' table with the corresponding country code in the 'politics' table, allowing for the extraction of the independence information based on the country's name provided as a placeholder."
        },
        {
            "sample_id": 8259,
            "vt": "SELECT COUNT(organization.country) FROM economy INNER JOIN organization AS T2 ON T1.Country = T2.Country WHERE organization.country IN (SELECT economy.country FROM organization GROUP BY Country HAVING COUNT(Country) > 3) AND economy.inflation > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of organizations located in countries that have more than three organizations and an inflation rate above a specified threshold. It combines data from the 'economy' and 'organization' tables, filtering based on the number of organizations per country and the inflation rate."
        },
        {
            "sample_id": 8284,
            "vt": "SELECT country.province FROM country INNER JOIN geo_mountain AS T2 ON T1.Code = T2.Country INNER JOIN mountain AS T3 ON T3.Name = T2.Mountain WHERE mountain.type = '[placeholder-type:string]' ORDER BY mountain.height LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the provinces of countries that have mountains of a specific type. It joins the 'country' table with the 'geo_mountain' table to link countries with their respective mountains, and then further joins with the 'mountain' table to filter mountains based on their type. The results are ordered by the height of the mountains and limited to a specified number of entries."
        },
        {
            "sample_id": 8499,
            "vt": "SELECT country.name, economy.gdp FROM country INNER JOIN economy AS T2 ON T1.Code = T2.Country WHERE country.population BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] ORDER BY economy.gdp LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table presents the names of countries along with their gross domestic product (GDP) from the 'country' and 'economy' tables. It filters the countries based on their population, allowing users to specify a range for the population size. The results are ordered by GDP, and a limit can be set on the number of results returned."
        },
        {
            "sample_id": 8295,
            "vt": "SELECT city.name FROM country INNER JOIN city AS T2 ON T1.Code = T2.Country WHERE country.name = (SELECT city.name FROM country ORDER BY CAST(Population AS FLOAT) / Area LIMIT 1 OFFSET 11) ORDER BY city.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of cities from the 'city' table that belong to a specific country. The country is determined by selecting the country with the 12th highest population density (population divided by area) from the 'country' table. The results are ordered by the population of the cities, and a limit is applied to restrict the number of cities returned."
        },
        {
            "sample_id": 8227,
            "vt": "SELECT economy.agriculture FROM country INNER JOIN economy AS T2 ON T1.Code = T2.Country WHERE country.area > [placeholder-type:numeric] AND NOT economy.agriculture IS NULL",
            "ba": "The virtual table retrieves the percentage of agriculture in the GDP from the 'economy' table for countries that have an area greater than a specified value. It joins the 'country' table to filter out countries based on their area and ensures that only countries with a non-null agriculture percentage are included in the results."
        },
        {
            "sample_id": 8460,
            "vt": "SELECT organization.name, organization.established FROM organization WHERE organization.abbreviation = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and establishment dates of organizations from the 'organization' table that match a specific abbreviation. The placeholder in the WHERE clause represents the abbreviation of the organization."
        },
        {
            "sample_id": 8489,
            "vt": "SELECT politics.independence FROM politics INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the independence date of a specific country from the 'politics' table by joining it with the 'country' table. The placeholder in the WHERE clause represents the name of the country for which the independence date is being queried."
        },
        {
            "sample_id": 8275,
            "vt": "SELECT DISTINCT country.name FROM country INNER JOIN geo_mountain AS T2 ON T1.Code = T2.Country WHERE geo_mountain.mountain = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct names of countries that have a specific mountain. It retrieves data from the 'country' table and joins it with the 'geo_mountain' table to filter countries based on the mountain name provided in the placeholder."
        },
        {
            "sample_id": 8232,
            "vt": "SELECT population.population_growth * country.population FROM country INNER JOIN population AS T2 ON T1.Code = T2.Country WHERE NOT population.infant_mortality IS NULL ORDER BY population.infant_mortality LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total population growth of countries based on their population and the growth rate, while filtering out countries with null infant mortality rates. It retrieves data from the 'country' and 'population' tables, joining them on the country code. The results are ordered by infant mortality rates and limited to a specified number of entries."
        },
        {
            "sample_id": 8244,
            "vt": "SELECT country.name FROM country INNER JOIN ethnicGroup AS T2 ON T1.Code = T2.Country GROUP BY country.name HAVING COUNT(country.name) > [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table that have a significant number of ethnic groups. The query joins the 'country' table with the 'ethnicgroup' table based on the country code, groups the results by country name, and filters to include only those countries that have more than a specified number of ethnic groups."
        },
        {
            "sample_id": 8438,
            "vt": "SELECT country.name FROM country INNER JOIN ethnicGroup AS T2 ON T1.Code = T2.Country WHERE ethnicgroup.name = '[placeholder-type:string]' ORDER BY ethnicgroup.percentage LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table that have a specific ethnic group. It joins the 'country' table with the 'ethnicgroup' table based on the country code, filtering for a specified ethnic group's name. The results are ordered by the percentage of the ethnic group in each country and limited to a specified number of entries."
        },
        {
            "sample_id": 8251,
            "vt": "SELECT lake.depth FROM located INNER JOIN lake AS T2 ON T1.Lake = T2.Name WHERE located.province = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the depth of lakes located in a specific province. It joins the 'located' table, which contains information about cities and their corresponding lakes, with the 'lake' table to access the depth of each lake. The placeholder in the WHERE clause represents the province name for which the lake depth is being queried."
        },
        {
            "sample_id": 8406,
            "vt": "SELECT ethnicgroup.country, ethnicgroup.name FROM ethnicgroup WHERE ethnicgroup.percentage < [placeholder-type:numeric] AND ethnicgroup.percentage = (SELECT MAX(ethnicgroup.percentage) FROM ethnicGroup AS T2 WHERE T1.Country = T2.Country)",
            "ba": "The virtual table provides a list of countries along with the names of their predominant ethnic groups, specifically those ethnic groups whose percentage representation is below a specified threshold. Additionally, it ensures that only the ethnic group with the highest percentage representation for each country is included in the results."
        },
        {
            "sample_id": 8293,
            "vt": "SELECT CAST(country.population AS FLOAT) / country.area FROM country INNER JOIN city AS T2 ON T1.Code = T2.Country WHERE city.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the population density of a specific city by dividing the population of the country it belongs to by the total area of that country. The placeholder in the WHERE clause represents the name of the city for which the population density is being calculated."
        },
        {
            "sample_id": 8454,
            "vt": "SELECT mergeswith.sea2, sea.depth FROM sea INNER JOIN mergesWith AS T2 ON T1.Name = T2.Sea1 WHERE sea.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the depth of a specific sea along with the country code it merges with. The placeholder in the WHERE clause represents the name of the sea being queried."
        },
        {
            "sample_id": 8261,
            "vt": "SELECT organization.name FROM language INNER JOIN organization AS T2 ON T1.Country = T2.Country WHERE language.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of organizations from the 'organization' table that are located in countries where a specific language is spoken. The query uses an inner join between the 'language' and 'organization' tables, linking them through the country code. The placeholder in the WHERE clause represents the name of the language being queried."
        },
        {
            "sample_id": 8291,
            "vt": "SELECT COUNT(*) FROM river WHERE river.sea IN (SELECT river.name FROM sea WHERE Depth = 459)",
            "ba": "The virtual table counts the number of rivers that flow into seas with a specific depth. It uses a subquery to first identify the names of seas that have a depth equal to a placeholder value, and then counts how many rivers are associated with those seas."
        },
        {
            "sample_id": 8271,
            "vt": "SELECT country.name FROM country INNER JOIN religion AS T2 ON T1.Code = T2.Country WHERE religion.name = '[placeholder-type:string]' AND religion.percentage = [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table that have a specific religion with a defined percentage of followers. The query uses an INNER JOIN to connect the 'country' table with the 'religion' table based on the country code, filtering results based on the specified religion name and its percentage of followers."
        },
        {
            "sample_id": 8474,
            "vt": "SELECT country.name, country.capital FROM country WHERE country.code IN (SELECT ismember.country FROM isMember WHERE type = 'Category III' AND Organization = 'IFAD')",
            "ba": "The virtual table lists the names and capitals of countries that are members of a specific organization categorized as 'Category III'. The query filters the countries based on their codes, which are obtained from a subquery that selects countries from the 'isMember' table where the organization is 'IFAD'."
        },
        {
            "sample_id": 8219,
            "vt": "SELECT ethnicgroup.name, ethnicgroup.percentage FROM ethnicgroup INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE country.name = '[placeholder-type:string]' GROUP BY ethnicgroup.name, ethnicgroup.percentage",
            "ba": "The virtual table provides a list of ethnic groups and their corresponding percentages for a specified country. It retrieves data from the 'ethnicgroup' table and joins it with the 'country' table to filter results based on the country's name."
        },
        {
            "sample_id": 8418,
            "vt": "SELECT located.city FROM lake INNER JOIN located AS T2 ON T1.Name = T2.Lake INNER JOIN province AS T3 ON T3.Name = T2.Province INNER JOIN city AS T4 ON T4.Province = T3.Name WHERE lake.longitude = -[placeholder-type:numeric] AND lake.latitude = [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of cities that are located near a specific lake, identified by its geographic coordinates (longitude and latitude). The query joins multiple tables: 'lake' to identify the lake, 'located' to find the cities associated with that lake, 'province' to ensure the cities belong to the correct province, and 'city' to retrieve the city names."
        },
        {
            "sample_id": 8332,
            "vt": "SELECT mountain.name, mountain.latitude, mountain.longitude FROM mountain WHERE mountain.type = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names, latitudes, and longitudes of mountains from the 'mountain' table that belong to a specific type. The placeholder in the WHERE clause represents the type of the mountain."
        },
        {
            "sample_id": 8411,
            "vt": "SELECT CAST(SUM(CASE WHEN language.percentage = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(country.name) FROM country INNER JOIN language AS T2 ON T1.Code = T2.Country WHERE language.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of a specific language's percentage in a country, based on the total number of countries. It sums the values of the language percentage for countries where the percentage matches a specified value, and then divides this sum by the count of countries. The result is multiplied by a placeholder value to adjust the final output."
        },
        {
            "sample_id": 8409,
            "vt": "SELECT SUM(CASE WHEN country.name = '[placeholder-type:string]' THEN borders.length ELSE [placeholder-type:numeric] END) * [placeholder-type:numeric] / SUM(borders.length) FROM borders LEFT JOIN country AS T2 ON T1.Country1 = T2.Code",
            "ba": "The virtual table calculates the weighted average length of borders for a specific country by summing the lengths of borders with that country and adjusting it based on a specified multiplier. It uses a conditional sum to include only the lengths of borders where the country matches the specified name, while also considering the total length of all borders for normalization."
        },
        {
            "sample_id": 8281,
            "vt": "SELECT country.area * [placeholder-type:numeric] / continent.area FROM country INNER JOIN encompasses AS T2 ON T1.Code = T2.Country INNER JOIN continent AS T3 ON T3.Name = T2.Continent WHERE continent.name = '[placeholder-type:string]' AND country.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the area of a specific country as a percentage of the total area of a specified continent. It retrieves the area of the country from the 'country' table and the area of the continent from the 'continent' table, using an inner join on the 'encompasses' table to link countries to their respective continents. The placeholders represent the continent's name and the country's name, allowing users to specify which country and continent they are interested in."
        },
        {
            "sample_id": 8328,
            "vt": "SELECT CAST(city.population AS FLOAT) * [placeholder-type:numeric] / province.population FROM city INNER JOIN province AS T2 ON T1.Province = T2.Name WHERE city.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the population of a specific city as a percentage of its province's total population. It retrieves the population of the city and the province it belongs to, then applies a multiplier to express the city's population in relation to the province's population."
        },
        {
            "sample_id": 8240,
            "vt": "SELECT economy.gdp * economy.industry FROM country INNER JOIN economy AS T2 ON T1.Code = T2.Country WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total industrial contribution to the GDP of a specific country by multiplying the GDP value with the percentage of the industry in that GDP. It retrieves this information from the 'country' and 'economy' tables, filtering by the country's name."
        },
        {
            "sample_id": 8319,
            "vt": "SELECT island.name, island.area FROM city INNER JOIN locatedOn AS T2 ON T1.Name = T2.City INNER JOIN island AS T3 ON T3.Name = T2.Island WHERE city.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and areas of islands that are associated with a specific city. It retrieves data from the 'city' table and joins it with the 'locatedOn' table to find the corresponding islands. The placeholder in the WHERE clause represents the name of the city for which the islands are being queried."
        },
        {
            "sample_id": 8364,
            "vt": "SELECT geo_desert.province FROM geo_desert WHERE geo_desert.desert = (SELECT desert.name FROM desert ORDER BY Area DESC LIMIT 1)",
            "ba": "The virtual table retrieves the province associated with the largest desert from the 'geo_desert' table. It uses a subquery to identify the desert with the maximum area from the 'desert' table, ensuring that the result reflects the province where this largest desert is located."
        },
        {
            "sample_id": 8500,
            "vt": "SELECT encompasses.country FROM continent INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent INNER JOIN country AS T3 ON T2.Country = T3.Code INNER JOIN economy AS T4 ON T4.Country = T3.Code WHERE continent.name = '[placeholder-type:string]' ORDER BY economy.agriculture LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the countries that are part of a specific continent, along with their agricultural GDP percentage. It joins the 'continent', 'encompasses', 'country', and 'economy' tables to filter countries based on the continent name and orders the results by the agricultural GDP percentage, limiting the number of results returned."
        },
        {
            "sample_id": 8366,
            "vt": "SELECT religion.name FROM continent INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent INNER JOIN country AS T3 ON T3.Code = T2.Country INNER JOIN religion AS T4 ON T4.Country = T3.Code WHERE continent.name = '[placeholder-type:string]' GROUP BY religion.name ORDER BY SUM(religion.percentage) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of religions from countries that belong to a specific continent. It aggregates the percentage of each religion across those countries, allowing for a summary of the most prevalent religions within the specified continent. The placeholders represent the continent's name and the limit on the number of results to return."
        },
        {
            "sample_id": 8218,
            "vt": "SELECT country.name FROM ethnicgroup INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE ethnicgroup.name = '[placeholder-type:string]' AND ethnicgroup.percentage > [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table that have a specific ethnic group represented by a given name and a percentage greater than a specified value. The query uses an inner join between the 'ethnicgroup' and 'country' tables to filter the results based on the ethnic group's name and its percentage in the country."
        }
    ],
    "software_company": [
        {
            "sample_id": 8564,
            "vt": "SELECT COUNT(customers.id) FROM customers INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID INNER JOIN Demog AS T3 ON T1.GEOID = T3.GEOID WHERE customers.marital_status = '[placeholder-type:string]' AND mailings1_2.response = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table who have a specific marital status and have responded to a mailing. It joins the 'customers' table with the 'mailings1_2' table to check for responses and with the 'demog' table to access geographic identifiers."
        },
        {
            "sample_id": 8567,
            "vt": "SELECT customers.educationnum, demog.income_k FROM customers INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID INNER JOIN Demog AS T3 ON T1.GEOID = T3.GEOID WHERE customers.age >= [placeholder-type:numeric] AND customers.age <= [placeholder-type:numeric] AND mailings1_2.response = '[placeholder-type:string]'",
            "ba": "The virtual table provides a view of the education level and average income per inhabitant for customers within a specified age range who have responded to a marketing mailing. The placeholders allow users to specify the age limits and the response status."
        },
        {
            "sample_id": 8510,
            "vt": "SELECT COUNT(customers.id) FROM customers WHERE customers.marital_status = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table who have a specific marital status. The placeholder in the WHERE clause represents the marital status of the customers."
        },
        {
            "sample_id": 8523,
            "vt": "SELECT COUNT(customers.id) FROM customers INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID WHERE customers.sex = '[placeholder-type:string]' AND customers.marital_status = '[placeholder-type:string]' AND mailings1_2.response = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table who match specific criteria based on their sex, marital status, and response to a mailing. The placeholders represent the values for sex, marital status, and response status."
        },
        {
            "sample_id": 8536,
            "vt": "SELECT customers.educationnum, customers.occupation FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE demog.income_k < [placeholder-type:numeric] AND customers.age >= [placeholder-type:numeric] AND customers.age <= [placeholder-type:numeric]",
            "ba": "The virtual table describes the education level and occupation of customers from the 'customers' table who live in geographic areas with an average income below a specified threshold and are within a certain age range. The placeholders in the WHERE clause represent the income limit and the age range."
        },
        {
            "sample_id": 8557,
            "vt": "SELECT CAST(SUM(CASE WHEN customers.age BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(customers.id) FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE demog.income_k > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average income per inhabitant for a specific age range from the 'customers' table, while filtering based on the average income from the 'demog' table. It sums the sales amounts for customers within the specified age range and divides it by the total number of customers, adjusting for the income threshold."
        },
        {
            "sample_id": 8517,
            "vt": "SELECT DISTINCT customers.occupation FROM customers INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID WHERE customers.age > [placeholder-type:numeric] AND mailings1_2.response = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct occupations of customers who are older than a specified age and have a specific response to a marketing mailing. It combines data from the 'customers' table and the 'mailings1_2' table based on customer ID, filtering by age and response status."
        },
        {
            "sample_id": 8525,
            "vt": "SELECT DISTINCT demog.inhabitants_k FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID ORDER BY demog.inhabitants_k",
            "ba": "The virtual table retrieves distinct values of the number of inhabitants (in thousands) from the 'demog' table, which is joined with the 'customers' table based on the geographic identifier. The results are ordered by the number of inhabitants."
        },
        {
            "sample_id": 8547,
            "vt": "SELECT COUNT(customers.id) FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE customers.sex = '[placeholder-type:string]' AND customers.age >= [placeholder-type:numeric] AND customers.age <= [placeholder-type:numeric] AND demog.inhabitants_k >= [placeholder-type:numeric] AND demog.inhabitants_k <= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of customers from the 'customers' table who meet specific criteria based on their sex and age, while also considering the demographic information from the 'demog' table. The placeholders represent the sex of the customer, the age range, and the population size of the geographic area."
        },
        {
            "sample_id": 8549,
            "vt": "SELECT CAST(SUM(CASE WHEN demog.income_k > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE customers.marital_status = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average income of customers based on their marital status from the 'customers' and 'demog' tables. It sums the income of customers whose income exceeds a specified threshold and divides it by the total number of customers, adjusting for a specific factor. The placeholders represent the income threshold, adjustment factor, and marital status."
        },
        {
            "sample_id": 8528,
            "vt": "SELECT AVG(customers.educationnum) FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID ORDER BY demog.income_k LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average level of education of customers by joining the 'customers' table with the 'demog' table based on the geographic identifier. The result is ordered by the average income per inhabitant per month from the 'demog' table, and it limits the output to a specified number of results."
        },
        {
            "sample_id": 8524,
            "vt": "SELECT COUNT(customers.id) FROM customers INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID INNER JOIN Demog AS T3 ON T1.GEOID = T3.GEOID WHERE mailings1_2.response = '[placeholder-type:string]' ORDER BY demog.income_k LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of customers from the 'customers' table who have responded to a mailing, joining with the 'mailings1_2' table to filter based on the response status. It also joins with the 'demog' table to potentially use demographic information, specifically filtering based on geographic identifiers. The results are ordered by average income per inhabitant and limited to a specified number of results."
        },
        {
            "sample_id": 8577,
            "vt": "SELECT CAST(SUM(CASE WHEN customers.sex = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN customers.sex = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM customers WHERE customers.age BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND customers.educationnum > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the ratio of a specific demographic group based on sex within a defined age range and education level from the 'customers' table. The placeholders represent the sex, age range, and education level criteria for filtering the data."
        },
        {
            "sample_id": 8574,
            "vt": "SELECT DISTINCT customers.occupation, mailings1_2.response FROM customers INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID INNER JOIN Demog AS T3 ON T1.GEOID = T3.GEOID WHERE customers.sex = '[placeholder-type:string]' AND demog.inhabitants_k >= [placeholder-type:numeric] AND demog.inhabitants_k <= [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct occupations of customers along with their responses to marketing mailings. It combines data from the 'customers' table and the 'mailings1_2' table based on customer ID, and also joins with the 'demog' table to filter based on geographic identifiers. The placeholders in the WHERE clause represent the customer's sex and a range for the number of inhabitants in thousands."
        },
        {
            "sample_id": 8551,
            "vt": "SELECT AVG(demog.income_k) FROM demog",
            "ba": "The virtual table calculates the average income per inhabitant per month from the 'demog' table. This average is derived from the 'income_k' column, which represents the average income in thousands of dollars."
        },
        {
            "sample_id": 8563,
            "vt": "SELECT DISTINCT customers.marital_status FROM customers WHERE customers.educationnum = [placeholder-type:numeric] AND customers.age = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct marital statuses of customers from the 'customers' table based on their education level and age. The placeholders represent the specific education level and age criteria for filtering the results."
        },
        {
            "sample_id": 8529,
            "vt": "SELECT AVG(customers.age) FROM customers INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID WHERE mailings1_2.response = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average age of customers from the 'customers' table who have a specific response to the marketing mailing in the 'mailings1_2' table. The placeholder in the WHERE clause represents the response status, which can be either true or false."
        },
        {
            "sample_id": 8521,
            "vt": "SELECT customers.id FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE customers.id = [placeholder-type:numeric] OR customers.id = [placeholder-type:numeric] ORDER BY demog.inhabitants_k LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of customers from the 'customers' table who are associated with specific geographic identifiers in the 'demog' table. The query uses an INNER JOIN to link the two tables based on the 'geoid' column, allowing for filtering based on customer IDs. The results are ordered by the number of inhabitants in thousands, and a limit is applied to the number of records returned."
        },
        {
            "sample_id": 8546,
            "vt": "SELECT demog.inhabitants_k FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE customers.occupation = '[placeholder-type:string]' AND customers.sex = '[placeholder-type:string]' AND customers.age >= [placeholder-type:numeric] AND customers.age <= [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the number of inhabitants (in thousands) from the 'demog' table for customers who meet specific criteria based on their occupation, sex, and age range. The placeholders in the WHERE clause allow users to specify the occupation, sex, and age limits for filtering the results."
        },
        {
            "sample_id": 8526,
            "vt": "SELECT COUNT(customers.id) FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE demog.inhabitants_k = [placeholder-type:numeric] AND customers.sex = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table who live in geographic areas with a specific number of inhabitants (in thousands) and have a specified sex. The query joins the 'customers' table with the 'demog' table based on the geographic identifier to filter the results accordingly."
        },
        {
            "sample_id": 8520,
            "vt": "SELECT COUNT(customers.geoid) FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE customers.occupation = '[placeholder-type:string]' AND demog.inhabitants_k > [placeholder-type:numeric] AND demog.inhabitants_k < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of customers from the 'customers' table who have a specific occupation and live in geographic areas with a population within a specified range. The placeholders represent the occupation type and the lower and upper limits of the population in thousands."
        },
        {
            "sample_id": 8558,
            "vt": "SELECT COUNT(mailings1_2.refid) FROM mailings1_2 WHERE mailings1_2.response = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'mailings1_2' table who have responded to a marketing mailing, based on a specified response status. The placeholder in the WHERE clause represents the response status, which can be either true or false."
        },
        {
            "sample_id": 8530,
            "vt": "SELECT COUNT(customers.id) FROM customers WHERE customers.sex = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table based on their sex. The placeholder in the WHERE clause represents the sex of the customers being queried."
        },
        {
            "sample_id": 8533,
            "vt": "SELECT demog.geoid FROM demog WHERE demog.income_k >= [placeholder-type:numeric] AND demog.income_k <= [placeholder-type:numeric]",
            "ba": "The virtual table retrieves unique geographic identifiers from the 'demog' table for regions where the average income per inhabitant per month falls within a specified range. The placeholders represent the minimum and maximum income thresholds."
        },
        {
            "sample_id": 8545,
            "vt": "SELECT demog.inhabitants_k FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE customers.occupation = '[placeholder-type:string]' AND customers.sex = '[placeholder-type:string]' AND customers.age >= [placeholder-type:numeric] AND customers.age <= [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the number of inhabitants (in thousands) from the 'demog' table for customers who meet specific criteria based on their occupation, sex, and age range. The placeholders in the query allow users to specify the desired occupation, sex, and age limits for filtering the results."
        },
        {
            "sample_id": 8537,
            "vt": "SELECT COUNT(customers.id) FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE customers.marital_status = '[placeholder-type:string]' AND customers.age < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of customers from the 'customers' table who are joined with the 'demog' table based on their geographic identifier. It filters the results based on the marital status and age of the customers, where the marital status is specified by a placeholder for string values and the age is specified by a placeholder for numeric values."
        },
        {
            "sample_id": 8559,
            "vt": "SELECT mailings1_2.refid FROM mailings1_2 WHERE mailings1_2.response = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of customers from the 'mailings1_2' table who have responded to a marketing mailing. The response is filtered based on a specified value, which indicates whether the response was positive or negative."
        },
        {
            "sample_id": 8565,
            "vt": "SELECT mailings1_2.response, demog.inhabitants_k FROM customers INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID INNER JOIN Demog AS T3 ON T1.GEOID = T3.GEOID WHERE customers.sex = '[placeholder-type:string]' ORDER BY customers.age LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the responses to marketing mailings along with the number of inhabitants in specific geographic areas. It combines data from the 'customers', 'mailings1_2', and 'demog' tables, filtering results based on the sex of the customers and limiting the output based on age."
        },
        {
            "sample_id": 8556,
            "vt": "SELECT CAST(SUM(CASE WHEN customers.marital_status = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE customers.geoid = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average income of customers based on their marital status from the 'customers' table, while also considering the demographic data from the 'demog' table. It sums up the income for customers with a specific marital status and divides it by the total number of customers to get the average. The placeholders represent the marital status, a numeric value for income calculation, and the geographic identifier."
        },
        {
            "sample_id": 8531,
            "vt": "SELECT customers.geoid FROM customers WHERE customers.occupation = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the geographic identifiers of customers from the 'customers' table who have a specific occupation. The placeholder in the WHERE clause represents the occupation of interest."
        },
        {
            "sample_id": 8515,
            "vt": "SELECT COUNT(customers.id) FROM customers WHERE customers.educationnum > [placeholder-type:numeric] AND customers.sex = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table who have an education level greater than a specified value and belong to a specific sex. The placeholders represent the education level and sex of the customers."
        },
        {
            "sample_id": 8552,
            "vt": "SELECT COUNT(mailings1_2.refid) FROM mailings1_2 WHERE mailings1_2.response = '[placeholder-type:string]' AND mailings1_2.ref_date BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of responses from customers in the 'mailings1_2' table based on their response status and the date range of the mailing."
        },
        {
            "sample_id": 8516,
            "vt": "SELECT COUNT(customers.id) FROM customers INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID WHERE customers.sex = '[placeholder-type:string]' AND mailings1_2.response = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table who have a specific sex and have responded to a mailing from the 'mailings1_2' table. The placeholders represent the sex of the customers and their response status to the mailing."
        },
        {
            "sample_id": 8569,
            "vt": "SELECT customers.educationnum, mailings1_2.response FROM customers INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID INNER JOIN Demog AS T3 ON T1.GEOID = T3.GEOID WHERE customers.age >= [placeholder-type:numeric] AND customers.age <= [placeholder-type:numeric] ORDER BY demog.inhabitants_k LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the education level and response status of customers from the 'customers' table who fall within a specific age range. It joins the 'customers' table with the 'mailings1_2' table to get the response to marketing mailings, and also joins with the 'demog' table to access demographic information such as the number of inhabitants. The placeholders in the WHERE clause represent the age range of customers, and the LIMIT clause specifies how many records to return."
        },
        {
            "sample_id": 8543,
            "vt": "SELECT demog.income_k FROM demog WHERE demog.geoid IN (SELECT demog.geoid FROM Customers WHERE EDUCATIONNUM < 5 AND SEX = 'Female' AND MARITAL_STATUS = 'Widowed')",
            "ba": "The virtual table retrieves the average income per inhabitant from the 'demog' table for geographic identifiers associated with female customers who have less than a specified level of education and are widowed."
        },
        {
            "sample_id": 8562,
            "vt": "SELECT COUNT(demog.geoid) FROM demog WHERE demog.income_k < [placeholder-type:numeric] AND demog.geoid >= [placeholder-type:numeric] AND demog.geoid <= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of unique geographic identifiers from the 'demog' table where the average income per inhabitant per month is below a specified threshold and the geographic identifier falls within a defined range."
        },
        {
            "sample_id": 8519,
            "vt": "SELECT COUNT(customers.id) FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID ORDER BY demog.income_k LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of customers from the 'customers' table who are associated with geographic identifiers in the 'demog' table. The result is ordered by the average income per inhabitant per month, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 8583,
            "vt": "SELECT demog.income_k, demog.inhabitants_k * demog.income_k * [placeholder-type:numeric] FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE customers.id = [placeholder-type:numeric] OR customers.id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total income per year for specific customers by joining the 'customers' table with the 'demog' table based on the geographic identifier. It selects the average income per inhabitant and multiplies it by the number of inhabitants (in thousands) and a placeholder for the number of months in a year. The query filters results for specific customer IDs using placeholders."
        },
        {
            "sample_id": 8561,
            "vt": "SELECT demog.geoid FROM demog WHERE demog.inhabitants_k < [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique geographic identifiers from the 'demog' table for geographic units that have a number of inhabitants less than a specified threshold. The placeholder in the WHERE clause represents the maximum number of inhabitants in thousands."
        },
        {
            "sample_id": 8527,
            "vt": "SELECT COUNT(customers.id) FROM customers INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID WHERE customers.age >= [placeholder-type:numeric] AND customers.age <= [placeholder-type:numeric] AND mailings1_2.response = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table who fall within a specified age range and have a specific response to a mailing. It joins the 'customers' table with the 'mailings1_2' table based on the customer ID, filtering by age and response status."
        },
        {
            "sample_id": 8582,
            "vt": "SELECT mailings3.response FROM customers INNER JOIN mailings3 AS T2 ON T1.ID = T2.REFID WHERE customers.geoid = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the response to marketing mailings from the 'mailings3' table for customers identified in the 'customers' table based on their geographic identifier. The placeholder in the WHERE clause represents the geographic identifier of the customers."
        },
        {
            "sample_id": 8580,
            "vt": "SELECT demog.inhabitants_k * demog.income_k * [placeholder-type:numeric] FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE customers.sex = '[placeholder-type:string]' AND customers.occupation = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total income per year for a specific demographic group by multiplying the number of inhabitants (in thousands) by the average income per inhabitant (in dollars) and then scaling it to a yearly figure. It filters the results based on the sex and occupation of customers, joining the 'customers' table with the 'demog' table using the geographic identifier."
        },
        {
            "sample_id": 8581,
            "vt": "SELECT customers.educationnum, customers.occupation, customers.age FROM customers INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE demog.inhabitants_k = [placeholder-type:numeric] AND customers.sex = '[placeholder-type:string]' AND customers.marital_status = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the education level, occupation, and age of customers from the 'customers' table, while joining with the 'demog' table to filter based on the number of inhabitants and specific customer characteristics such as sex and marital status. The placeholders represent the number of inhabitants, sex, and marital status of the customers."
        },
        {
            "sample_id": 8550,
            "vt": "SELECT customers.id, customers.geoid FROM customers WHERE customers.educationnum < [placeholder-type:numeric] AND customers.age > [placeholder-type:numeric]",
            "ba": "The virtual table describes the unique identifiers and geographic identifiers of customers from the 'customers' table who have an education level below a specified threshold and are older than a certain age. The placeholders in the WHERE clause represent the numeric values for education level and age."
        },
        {
            "sample_id": 8571,
            "vt": "SELECT DISTINCT customers.marital_status, mailings1_2.response FROM customers INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID WHERE customers.educationnum > [placeholder-type:numeric] AND customers.sex = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of marital statuses and responses from customers who have a higher education level and belong to a specific gender. It combines data from the 'customers' table and the 'mailings1_2' table based on the customer ID."
        }
    ],
    "financial": [
        {
            "sample_id": 9522,
            "vt": "SELECT COUNT(client.client_id) FROM district INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE client.gender = '[placeholder-type:string]' AND STRFTIME('%Y', client.birth_date) < '[placeholder-type:string]' AND district.a2 = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of clients from the 'client' table who belong to a specific district, are of a certain gender, and were born before a specified year. It joins the 'district' table to filter clients based on their district name."
        },
        {
            "sample_id": 9609,
            "vt": "SELECT COUNT(disp.account_id) FROM account INNER JOIN disp AS T2 ON T2.account_id = T1.account_id WHERE account.frequency = '[placeholder-type:string]' AND disp.type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of accounts associated with a specific frequency and disposition type. It joins the 'account' table with the 'disp' table to filter the results based on the specified frequency and type of disposition."
        },
        {
            "sample_id": 9552,
            "vt": "SELECT COUNT(disp.account_id) FROM district INNER JOIN client AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.client_id = T3.client_id WHERE district.a3 = '[placeholder-type:string]' AND disp.type <> '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of accounts associated with clients in a specific region, excluding a certain type of disposition. It joins the 'district', 'client', and 'disp' tables to filter based on the region and disposition type."
        },
        {
            "sample_id": 9614,
            "vt": "SELECT AVG(loan.amount) FROM account INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE loan.status IN ('[placeholder-type:string]', '[placeholder-type:string]') AND account.frequency = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average loan amount from the 'loan' table for accounts that meet specific criteria. It joins the 'account' table with the 'loan' table based on the account ID. The query filters loans based on their status, which can be either completed or ongoing, and also considers the frequency of the account, which indicates how often transactions occur."
        },
        {
            "sample_id": 9545,
            "vt": "SELECT account.account_id, district.a2, district.a3 FROM account INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE loan.amount > [placeholder-type:numeric]",
            "ba": "The virtual table describes the account IDs along with the district name and region from the 'account' and 'district' tables. It filters the results to include only those accounts that have a loan amount greater than a specified value."
        },
        {
            "sample_id": 9566,
            "vt": "SELECT AVG(trans.amount) FROM card INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE STRFTIME('%Y', trans.date) = '[placeholder-type:string]' AND trans.operation = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average transaction amount from the 'trans' table for credit cards associated with specific dispositions. It joins the 'card', 'disp', 'account', and 'trans' tables to filter transactions based on the year of the transaction date and the type of transaction operation. The placeholders represent the year and the operation type, allowing users to specify their criteria for the average calculation."
        },
        {
            "sample_id": 9517,
            "vt": "SELECT account.account_id FROM account INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id INNER JOIN district AS T4 ON T4.district_id = T1.district_id WHERE disp.client_id = (SELECT client.client_id FROM client ORDER BY birth_date DESC LIMIT 1) GROUP BY district.a11, account.account_id",
            "ba": "The virtual table retrieves the account IDs from the 'account' table for the most recently added client based on their birth date. It joins the 'disp' table to link accounts to clients, and the 'client' table to access client details. Additionally, it joins the 'district' table to group the results by the average salary in each district. The query ensures that only accounts associated with the latest client are selected, and the results are grouped by the average salary of the districts."
        },
        {
            "sample_id": 9533,
            "vt": "SELECT COUNT(account.account_id) FROM district INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', account.date) = '[placeholder-type:string]' AND district.a2 = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of accounts from the 'account' table that are associated with a specific district. It filters the accounts based on the creation date and the district name. The placeholders represent the year of account creation and the name of the district."
        },
        {
            "sample_id": 9548,
            "vt": "SELECT CAST(SUM(district.a2 = '[placeholder-type:string]') AS FLOAT) * [placeholder-type:numeric] / COUNT(account.account_id) FROM district INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', account.date) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of accounts per district for a specific year, weighted by a factor. It sums the number of districts that match a given name and multiplies this sum by a numeric placeholder, then divides by the total count of accounts created in that year."
        },
        {
            "sample_id": 9519,
            "vt": "SELECT disp.client_id FROM account INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE account.frequency = '[placeholder-type:string]' AND disp.type = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the client IDs from the 'disp' table by joining it with the 'account' table. It filters the results based on the frequency of the account and the type of disposition associated with the client."
        },
        {
            "sample_id": 9572,
            "vt": "SELECT COUNT(account.account_id) FROM district INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE trans.bank = '[placeholder-type:string]' AND district.a3 = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of accounts from the 'account' table that are associated with a specific bank and located in a particular region. It joins the 'district' table to filter accounts based on their district and the 'trans' table to filter transactions by bank."
        },
        {
            "sample_id": 9555,
            "vt": "SELECT district.district_id, district.a2 FROM district ORDER BY district.a13 LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of district IDs along with their corresponding names from the 'district' table. The results are ordered by the unemployment rate in 1996, and the number of records returned is limited by a specified numeric placeholder."
        },
        {
            "sample_id": 9538,
            "vt": "SELECT CAST((SUM(CASE WHEN trans.date = '[placeholder-type:string]' THEN trans.balance ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN trans.date = '[placeholder-type:string]' THEN trans.balance ELSE [placeholder-type:numeric] END)) AS FLOAT) * [placeholder-type:numeric] / SUM(CASE WHEN trans.date = '[placeholder-type:string]' THEN trans.balance ELSE [placeholder-type:numeric] END) FROM loan INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T3.account_id = T2.account_id WHERE loan.date = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the financial ratio based on the balance of transactions for a specific date and loan approval date. It sums the balances of transactions for a given date, subtracts the balances for another date, and then computes a ratio using a placeholder for numeric values. The query involves joining the 'loan', 'account', and 'trans' tables to gather necessary data."
        },
        {
            "sample_id": 9550,
            "vt": "SELECT district.a2, COUNT(client.client_id) FROM client INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE client.gender = '[placeholder-type:string]' GROUP BY district.district_id, district.a2 ORDER BY COUNT(client.client_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the number of clients grouped by district name, specifically filtering by gender. It joins the 'client' table with the 'district' table to access district names and counts the number of clients for each district based on the specified gender. The results are ordered by the count of clients and limited to a specified number of districts."
        },
        {
            "sample_id": 9577,
            "vt": "SELECT CAST(SUM(card.type = '[placeholder-type:string]' AND STRFTIME('%Y', card.issued) < '[placeholder-type:string]') AS FLOAT) * [placeholder-type:numeric] / COUNT(card.card_id) FROM card",
            "ba": "The virtual table calculates the weighted average of a specific type of credit card issued before a certain year. It sums the number of cards of the specified type that were issued before the given year, multiplies this sum by a numeric placeholder, and divides it by the total count of credit cards to get the average."
        },
        {
            "sample_id": 9542,
            "vt": "SELECT account.account_id, account.frequency FROM account INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE district.a3 = '[placeholder-type:string]' AND STRFTIME('%Y', account.date) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table describes the account IDs and their frequencies from the 'account' table, filtered by a specific region and a date range for account creation. The placeholders represent the region name and the start and end years for the date range."
        },
        {
            "sample_id": 9564,
            "vt": "SELECT DISTINCT account.account_id FROM trans INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE trans.k_symbol = '[placeholder-type:string]' AND district.a2 = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct account IDs from the 'trans' table, which records transactions. It joins the 'account' table to access account details and the 'district' table to filter based on district names. The query specifically looks for transactions with a certain purpose (indicated by the k_symbol) and within a specified district name."
        },
        {
            "sample_id": 9611,
            "vt": "SELECT account.account_id FROM client INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id AND T4.account_id = T3.account_id WHERE client.gender = '[placeholder-type:string]' ORDER BY client.birth_date, district.a11 LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the account IDs from the 'account' table for clients of a specific gender. It joins multiple tables: 'client' to filter by gender, 'district' to link clients to their respective districts, and 'disp' to ensure the correct account is associated with each client. The results are ordered by the clients' birth dates and the average salary of their districts, with a limit on the number of results returned."
        },
        {
            "sample_id": 9525,
            "vt": "SELECT disp.client_id FROM client INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE card.issued = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the client IDs from the 'client' table who have a corresponding disposition in the 'disp' table and a credit card in the 'card' table that was issued on a specific date. The query uses inner joins to connect these tables based on their relationships, ensuring that only clients with issued cards are selected."
        },
        {
            "sample_id": 9557,
            "vt": "SELECT COUNT(trans.account_id) FROM trans INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE trans.balance < [placeholder-type:numeric] AND trans.operation = '[placeholder-type:string]' AND account.frequency = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of transactions from the 'trans' table that meet specific criteria. It filters transactions where the balance is below a certain threshold, the type of operation matches a specified value, and the account frequency corresponds to a given frequency. The query joins the 'trans' table with the 'account' table to access the frequency information."
        },
        {
            "sample_id": 9511,
            "vt": "SELECT COUNT(account.account_id) FROM district INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE district.a3 = '[placeholder-type:string]' AND account.frequency = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of accounts from the 'account' table that are associated with a specific district and have a certain frequency. It joins the 'district' table to filter based on the region and uses placeholders for the district name and account frequency."
        },
        {
            "sample_id": 9592,
            "vt": "SELECT COUNT(trans.account_id) FROM trans WHERE STRFTIME('%Y', trans.date) > '[placeholder-type:string]' AND trans.operation = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of transactions from the 'trans' table that occurred after a specified year and match a specific type of operation. The placeholders represent the year and the type of operation for filtering the results."
        },
        {
            "sample_id": 9573,
            "vt": "SELECT DISTINCT district.a2 FROM district INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE trans.type = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct district names from the 'district' table, which are associated with accounts in the 'account' table. It filters the results based on the type of transaction from the 'trans' table, using a placeholder for the transaction type."
        },
        {
            "sample_id": 9590,
            "vt": "SELECT CAST(SUM(client.gender = '[placeholder-type:string]') AS FLOAT) * [placeholder-type:numeric] / COUNT(client.client_id) FROM district INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE district.a11 > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the percentage of clients of a specific gender in districts where the average salary exceeds a certain threshold. It does this by summing the number of clients matching the specified gender and dividing it by the total number of clients in those districts, then multiplying by a specified numeric value for scaling."
        },
        {
            "sample_id": 9606,
            "vt": "SELECT COUNT(client.client_id) FROM client INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE client.gender = '[placeholder-type:string]' AND card.type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of clients from the 'client' table who have a specific gender and possess a certain type of credit card. It joins the 'client' table with the 'disp' table to link clients to their dispositions, and then further joins with the 'card' table to filter based on the card type. The placeholders in the WHERE clause represent the gender of the client and the type of credit card they hold."
        },
        {
            "sample_id": 9553,
            "vt": "SELECT district.a3 FROM account INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE loan.status IN ('[placeholder-type:string]', '[placeholder-type:string]') GROUP BY district.a3 ORDER BY SUM(loan.amount) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the regions (a3) from the 'district' table associated with accounts that have loans. It joins the 'account' table with the 'district' table to get the district information and also joins with the 'loan' table to filter based on the loan status. The results are grouped by region and ordered by the total loan amount, with a limit on the number of results returned."
        },
        {
            "sample_id": 9534,
            "vt": "SELECT district.a2 FROM district INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE client.birth_date = '[placeholder-type:string]' AND client.gender = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of districts from the 'district' table where clients, identified by their birth date and gender, are located. The placeholders represent the specific birth date and gender of the clients being queried."
        },
        {
            "sample_id": 9602,
            "vt": "SELECT client.client_id, account.account_id FROM client INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id AND T4.account_id = T3.account_id WHERE district.a3 = '[placeholder-type:string]' AND STRFTIME('%Y', client.birth_date) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique client IDs and their corresponding account IDs from the 'client' and 'account' tables. It joins the 'client' table with the 'district' table to filter clients based on their district region. Additionally, it joins the 'disp' table to link clients to their accounts, ensuring that only relevant accounts are selected. The query also includes conditions to filter results based on a specific region and a range of birth years for the clients."
        },
        {
            "sample_id": 9569,
            "vt": "SELECT COUNT(client.client_id) FROM client INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE client.gender = '[placeholder-type:string]' AND district.a3 = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of clients from the 'client' table who belong to a specific gender and are located in a specific region. The query joins the 'client' table with the 'district' table to filter clients based on their district's region. The placeholders represent the gender of the clients and the region they are located in."
        },
        {
            "sample_id": 9615,
            "vt": "SELECT disp.client_id, district.district_id, district.a2 FROM account INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id WHERE disp.type = '[placeholder-type:string]'",
            "ba": "The virtual table provides a view of client IDs, district IDs, and district names for accounts that are associated with a specific type of disposition. It combines data from the 'account', 'district', and 'disp' tables, linking them through their respective foreign keys. The placeholder in the WHERE clause allows users to specify the type of disposition they are interested in, such as 'OWNER', 'USER', or 'DISPONENT'."
        },
        {
            "sample_id": 9544,
            "vt": "SELECT district.a2, district.a3 FROM account INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE loan.loan_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the district name and region associated with an account based on a specific loan identified by its loan ID. The placeholders in the WHERE clause represent the loan ID to filter the results accordingly."
        },
        {
            "sample_id": 9586,
            "vt": "SELECT client.client_id FROM \"order\" INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T4 ON T4.account_id = T2.account_id INNER JOIN client AS T3 ON T4.client_id = T3.client_id WHERE order.order_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique client identifier from the 'client' table for a specific order. It joins the 'order' table with the 'account' table to link the order to its corresponding account, then further joins with the 'disp' table to associate the account with its client. The query filters results based on a specific order ID provided as a placeholder."
        },
        {
            "sample_id": 9560,
            "vt": "SELECT COUNT(client.client_id) FROM client INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE client.gender = '[placeholder-type:string]' AND district.a15 = (SELECT district.a15 FROM district AS T3 ORDER BY T3.A15 DESC LIMIT 1 OFFSET 1)",
            "ba": "The virtual table counts the number of clients from the 'client' table who belong to a specific gender and are located in districts with a certain number of committed crimes in 1996. The query joins the 'client' table with the 'district' table to filter based on gender and the second highest number of committed crimes."
        },
        {
            "sample_id": 9570,
            "vt": "SELECT account.account_id FROM district INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE disp.type = '[placeholder-type:string]' AND district.a2 = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the account IDs from the 'account' table based on specific conditions related to the district and disposition type. It joins the 'district' table with the 'account' table to filter accounts by their district, and further joins with the 'disp' table to filter by the type of disposition associated with each account."
        },
        {
            "sample_id": 9543,
            "vt": "SELECT account.account_id, account.date FROM account INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE district.a2 = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of account IDs and their creation dates from the 'account' table, filtered by a specific district name. The placeholder in the WHERE clause represents the name of the district."
        },
        {
            "sample_id": 9530,
            "vt": "SELECT trans.amount FROM loan INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id ORDER BY loan.amount, trans.date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the transaction amounts from the 'trans' table for accounts that have loans, ordered by the loan amount and transaction date. The placeholder in the LIMIT clause allows the user to specify how many records to return."
        },
        {
            "sample_id": 9561,
            "vt": "SELECT COUNT(card.card_id) FROM card INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE card.type = '[placeholder-type:string]' AND disp.type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of credit cards from the 'card' table that are associated with specific dispositions from the 'disp' table. It filters the results based on the type of credit card and the type of disposition, both of which are represented by placeholders for string values."
        },
        {
            "sample_id": 9558,
            "vt": "SELECT COUNT(account.account_id) FROM account INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE loan.date BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND account.frequency = '[placeholder-type:string]' AND loan.amount >= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of accounts from the 'account' table that have associated loans within a specified date range, with a specific frequency and a minimum loan amount. The placeholders represent the date range, frequency of the account, and the minimum loan amount."
        },
        {
            "sample_id": 9574,
            "vt": "SELECT AVG(district.a15) FROM district INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', account.date) >= '[placeholder-type:string]' AND district.a15 > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of committed crimes in a specific district from the 'district' table. It joins the 'district' table with the 'account' table based on the district ID. The query filters accounts created after a certain year and only includes districts where the number of committed crimes exceeds a specified threshold."
        },
        {
            "sample_id": 9523,
            "vt": "SELECT trans.account_id FROM trans WHERE STRFTIME('%Y', trans.date) = '[placeholder-type:string]' ORDER BY trans.date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the account IDs from the 'trans' table for transactions that occurred in a specific year. The placeholder in the WHERE clause represents the year, and the LIMIT clause allows for controlling the number of results returned, based on a numeric value."
        },
        {
            "sample_id": 9610,
            "vt": "SELECT loan.account_id FROM loan INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE loan.duration > [placeholder-type:numeric] AND STRFTIME('%Y', account.date) < '[placeholder-type:string]' ORDER BY loan.amount LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves account IDs from the 'loan' table for loans that have a duration greater than a specified number of months and were created before a certain year. The results are ordered by the loan amount and limited to a specified number of entries."
        },
        {
            "sample_id": 9589,
            "vt": "SELECT disp.client_id FROM card INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE card.type = '[placeholder-type:string]' AND card.issued >= '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the client IDs associated with credit cards of a specific type that were issued on or after a certain date. It joins the 'card' table with the 'disp' table to link card information with client details."
        },
        {
            "sample_id": 9563,
            "vt": "SELECT account.district_id FROM account INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T1.account_id = T3.account_id WHERE STRFTIME('%Y', trans.date) = '[placeholder-type:string]' GROUP BY account.district_id HAVING SUM(trans.amount) > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the district IDs from the 'account' table, joining it with the 'district' table to get district information and the 'trans' table to filter transactions. It groups the results by district ID and only includes those districts where the total transaction amount exceeds a specified numeric threshold for a given year."
        },
        {
            "sample_id": 9514,
            "vt": "SELECT COUNT(DISTINCT T2.district_id) FROM client INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE client.gender = '[placeholder-type:string]' AND district.a11 BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of districts from the 'district' table that have clients of a specific gender. It filters the clients based on their gender and checks if the average salary in those districts falls within a specified range."
        },
        {
            "sample_id": 9515,
            "vt": "SELECT COUNT(client.client_id) FROM client INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE client.gender = '[placeholder-type:string]' AND district.a3 = '[placeholder-type:string]' AND district.a11 > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of clients from the 'client' table who are of a specific gender, belong to a district in a specified region, and have an average salary above a certain threshold. The placeholders represent the gender, region, and salary criteria."
        },
        {
            "sample_id": 9559,
            "vt": "SELECT COUNT(account.account_id) FROM account INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE account.district_id = [placeholder-type:numeric] AND (loan.status = '[placeholder-type:string]' OR loan.status = '[placeholder-type:string]')",
            "ba": "The virtual table counts the number of accounts from the 'account' table that are located in a specific district and have a loan status that matches either of two specified statuses. The query joins the 'account' table with the 'district' table to filter by district and with the 'loan' table to filter by loan status."
        },
        {
            "sample_id": 9512,
            "vt": "SELECT COUNT(account.account_id) FROM account INNER JOIN loan AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T1.district_id = T3.district_id WHERE district.a3 = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of accounts from the 'account' table that have associated loans, filtered by a specific region from the 'district' table. The placeholder in the WHERE clause represents the region's name."
        },
        {
            "sample_id": 9582,
            "vt": "SELECT COUNT(loan.account_id) FROM loan INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE account.frequency = '[placeholder-type:string]' AND loan.amount < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of loans associated with accounts that have a specific frequency and where the loan amount is below a certain threshold. It joins the 'loan' table with the 'account' table to filter based on the account's frequency and the loan amount."
        },
        {
            "sample_id": 9532,
            "vt": "SELECT disp.disp_id FROM disp INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE trans.date = '[placeholder-type:string]' AND trans.amount = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the disposition IDs from the 'disp' table for transactions that occurred on a specific date and involved a specific amount. It joins the 'disp' table with the 'account' table to link accounts with their dispositions, and further joins with the 'trans' table to filter transactions based on the provided date and amount."
        },
        {
            "sample_id": 9588,
            "vt": "SELECT COUNT(account.account_id) FROM district INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE district.a2 = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of accounts associated with a specific district from the 'district' table. It joins the 'account' table to filter accounts based on the district name provided in the placeholder."
        },
        {
            "sample_id": 9601,
            "vt": "SELECT SUM(trans.amount) FROM client INNER JOIN disp AS T4 ON T1.client_id = T4.client_id INNER JOIN account AS T2 ON T4.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE STRFTIME('%Y', trans.date) = '[placeholder-type:string]' AND client.client_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total amount of transactions for a specific client from the 'client', 'disp', 'account', and 'trans' tables. It filters the transactions based on the year extracted from the transaction date and the unique client identifier."
        },
        {
            "sample_id": 9605,
            "vt": "SELECT COUNT(account.account_id) FROM account INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', account.date) > '[placeholder-type:string]' AND district.a2 = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of accounts from the 'account' table that were created after a specific year and belong to a specific district. The placeholders represent the year and the district name."
        },
        {
            "sample_id": 9546,
            "vt": "SELECT loan.loan_id, district.a2, district.a11 FROM account INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE loan.duration = [placeholder-type:numeric]",
            "ba": "The virtual table provides a view of loan information along with the corresponding district name and average salary. It retrieves the loan ID from the 'loan' table, the district name from the 'district' table, and the average salary from the same table. The data is filtered based on the loan duration, which is specified by a placeholder for numeric values."
        },
        {
            "sample_id": 9594,
            "vt": "SELECT SUM(disp.type = '[placeholder-type:string]'), SUM(disp.type = '[placeholder-type:string]') FROM disp WHERE disp.account_id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the count of different types of dispositions associated with accounts within a specified range of account IDs. The placeholders represent the type of disposition and the numeric range for account IDs."
        },
        {
            "sample_id": 9556,
            "vt": "SELECT COUNT(account.account_id) FROM district INNER JOIN account AS T2 ON T1.district_id = T2.district_id GROUP BY district.a16 ORDER BY district.a16 LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of accounts grouped by the unemployment rate in 1996 from the 'district' table. It joins the 'district' table with the 'account' table based on the district ID, allowing for analysis of how the number of accounts varies with the unemployment rate. The result is ordered by the unemployment rate and limited to a specified number of results."
        },
        {
            "sample_id": 9565,
            "vt": "SELECT disp.account_id FROM disp INNER JOIN card AS T1 ON T1.disp_id = T2.disp_id WHERE card.type = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the account IDs from the 'disp' table for clients who have a specific type of credit card. It uses an inner join with the 'card' table to filter the results based on the card type specified by the user."
        },
        {
            "sample_id": 9527,
            "vt": "SELECT account.district_id FROM account INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE loan.date = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the district ID associated with accounts that have loans approved on a specific date. It joins the 'account' table with the 'loan' table to filter the results based on the loan approval date provided by the user."
        },
        {
            "sample_id": 9537,
            "vt": "SELECT CAST(SUM(client.gender = '[placeholder-type:string]') AS FLOAT) * [placeholder-type:numeric] / COUNT(client.client_id) FROM client INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE district.a3 = '[placeholder-type:string]' GROUP BY district.a4 ORDER BY district.a4 LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the percentage of clients of a specific gender from the 'client' table, grouped by a specific district attribute. It uses a join with the 'district' table to filter clients based on the region and aggregates the data to provide a ratio of clients of the specified gender to the total number of clients in that district. The placeholders represent the gender, region, and limit for the number of results returned."
        },
        {
            "sample_id": 9541,
            "vt": "SELECT account.account_id, district.a2, district.a3 FROM account INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE account.frequency = '[placeholder-type:string]' AND STRFTIME('%Y', account.date) = '[placeholder-type:string]'",
            "ba": "The virtual table describes the account IDs along with the district name and region from the 'account' and 'district' tables. It filters the results based on the frequency of the account and the year of the account's creation date, using placeholders for these values."
        },
        {
            "sample_id": 9524,
            "vt": "SELECT DISTINCT account.account_id FROM trans INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', account.date) < '[placeholder-type:string]' AND trans.amount > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct account IDs from the 'trans' table, which records transactions associated with accounts. It joins the 'trans' table with the 'account' table to filter accounts based on their creation date and the amount of transactions. The placeholder in the WHERE clause represents a specific year for filtering accounts created before that year, and another placeholder is used to filter transactions that exceed a specified amount."
        },
        {
            "sample_id": 9603,
            "vt": "SELECT client.client_id FROM client INNER JOIN disp AS T4 ON T1.client_id = T4.client_id INNER JOIN account AS T2 ON T4.account_id = T2.account_id INNER JOIN loan AS T3 ON T2.account_id = T3.account_id AND T4.account_id = T3.account_id WHERE client.gender = '[placeholder-type:string]' ORDER BY loan.amount LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique client IDs from the 'client' table for clients of a specific gender who have associated accounts and loans. It joins the 'client' table with the 'disp' table to link clients to their accounts, and then further joins with the 'account' and 'loan' tables to filter based on loan amounts. The results are ordered by the loan amount and limited to a specified number of entries."
        },
        {
            "sample_id": 9579,
            "vt": "SELECT district.a15 FROM district INNER JOIN \"account\" AS T2 ON T1.district_id = T2.district_id WHERE account.account_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the number of committed crimes in 1995 from the 'district' table for a specific account identified by its account ID. It joins the 'district' table with the 'account' table based on the district ID to filter the relevant district information associated with the given account."
        },
        {
            "sample_id": 9513,
            "vt": "SELECT DISTINCT CASE WHEN AVG(district.a13) > AVG(district.a12) THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM district",
            "ba": "The virtual table calculates the average unemployment rates for two different years (1995 and 1996) from the 'district' table. It uses a conditional statement to determine if the average unemployment rate for 1996 is greater than that of 1995. Depending on the result, it returns a specific string value as a placeholder, indicating the comparison outcome."
        }
    ],
    "movie": [
        {
            "sample_id": 766,
            "vt": "SELECT actor.networth FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE movie.title = '[placeholder-type:string]' AND actor.\"height (inches)\" BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND actor.gender = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the net worth of actors from the 'actor' table who have played in a specific movie, filtered by the movie's title, the actor's height range, and gender. The placeholders allow users to specify the movie title, height range, and gender criteria."
        },
        {
            "sample_id": 756,
            "vt": "SELECT actor.name FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE movie.\"release date\" = '[placeholder-type:string]' AND characters.creditorder = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of actors from the 'actor' table who played characters in movies released on a specific date and with a specific credit order. The placeholders in the WHERE clause represent the release date of the movie and the credit order of the character."
        },
        {
            "sample_id": 775,
            "vt": "SELECT actor.name FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE actor.gender = '[placeholder-type:string]' AND movie.title = '[placeholder-type:string]' AND actor.\"birth city\" = '[placeholder-type:string]' AND actor.\"height (inches)\" * [placeholder-type:numeric] > (SELECT AVG(actor.\"height (inches)\") FROM actor) * [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of actors from the 'actor' table who have played in a specific movie, filtered by their gender, birth city, and height. The query also ensures that the actor's height is above a certain average height multiplied by a numeric placeholder, indicating a focus on taller actors."
        },
        {
            "sample_id": 745,
            "vt": "SELECT movie.\"mpaa rating\" FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID WHERE characters.\"character name\" = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the MPAA rating of movies from the 'movie' table based on a specific character's name from the 'characters' table. The query uses an inner join to connect the 'movie' and 'characters' tables through the movie ID, allowing for filtering by the character's name."
        },
        {
            "sample_id": 749,
            "vt": "SELECT actor.name FROM characters INNER JOIN actor AS T2 ON T1.ActorID = T2.ActorID WHERE characters.\"character name\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of actors from the 'actor' table who have played a specific character in a movie. The query uses an inner join between the 'characters' and 'actor' tables to link the actor's ID with the character's name, allowing for the retrieval of the actor's name based on the specified character name."
        },
        {
            "sample_id": 740,
            "vt": "SELECT actor.name FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE movie.title = '[placeholder-type:string]' ORDER BY actor.\"height (inches)\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of actors from the 'actor' table who have played in a specific movie. The query joins the 'movie' and 'characters' tables to link movies with their respective characters and actors. It filters the results based on the movie title provided as a placeholder and orders the actors by their height in inches. Additionally, it limits the number of results returned based on a numeric placeholder."
        },
        {
            "sample_id": 759,
            "vt": "SELECT movie.movieid FROM movie WHERE movie.rating BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND movie.budget = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of movies from the 'movie' table that fall within a specified rating range and have a specific budget. The placeholders represent the numeric values for the rating range and budget."
        },
        {
            "sample_id": 751,
            "vt": "SELECT actor.\"birth city\" FROM characters INNER JOIN actor AS T2 ON T1.ActorID = T2.ActorID WHERE characters.\"character name\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the birth city of actors from the 'actor' table who have played a specific character in a movie. The query joins the 'characters' table with the 'actor' table to find the relevant actor based on the character's name, using a placeholder for the character's name."
        },
        {
            "sample_id": 774,
            "vt": "SELECT SUM(CASE WHEN CAST(REPLACE(REPLACE(actor.networth, ',', ''), '$', '') AS FLOAT) > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN CAST(REPLACE(REPLACE(actor.networth, ',', ''), '$', '') AS FLOAT) < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE movie.genre = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between the total net worth of actors who are richer than a specified amount and the total net worth of actors who are less wealthy than that amount, filtered by a specific movie genre. The placeholders represent the numeric values for the net worth thresholds and the string value for the genre."
        },
        {
            "sample_id": 765,
            "vt": "SELECT movie.genre FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE movie.\"mpaa rating\" = '[placeholder-type:string]' ORDER BY CAST(REPLACE(REPLACE(actor.networth, ',', ''), '$', '') AS FLOAT) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the genres of movies from the 'movie' table that have a specific MPAA rating. It joins the 'characters' table to associate actors with their respective movies and the 'actor' table to access actor details, including their net worth. The results are ordered by the net worth of the actors, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 741,
            "vt": "SELECT COUNT(*) FROM characters INNER JOIN actor AS T2 ON T1.ActorID = T2.ActorID WHERE actor.gender = '[placeholder-type:string]' AND actor.ethnicity = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of characters from the 'characters' table who are portrayed by actors of a specific gender and ethnicity. It joins the 'characters' table with the 'actor' table to filter based on the actor's gender and ethnicity."
        },
        {
            "sample_id": 771,
            "vt": "SELECT actor.name FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE movie.gross = [placeholder-type:numeric] AND characters.\"character name\" = '[placeholder-type:string]' AND movie.genre = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of actors from the 'actor' table who played a specific character in a movie that has a certain gross revenue and belongs to a specific genre. The placeholders in the WHERE clause represent the gross revenue, character name, and genre of the movie."
        },
        {
            "sample_id": 747,
            "vt": "SELECT actor.name FROM characters INNER JOIN actor AS T2 ON T1.ActorID = T2.ActorID INNER JOIN movie AS T3 ON T3.MovieID = T1.MovieID WHERE movie.title = '[placeholder-type:string]' ORDER BY characters.screentime LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of actors who played characters in a specific movie. It joins the 'characters' table with the 'actor' table to retrieve actor names and the 'movie' table to filter by the movie title. The results are ordered by the screentime of the characters, indicating their importance, and limited to a specified number of results."
        },
        {
            "sample_id": 744,
            "vt": "SELECT movie.title FROM movie ORDER BY movie.budget LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies from the 'movie' table, ordered by their budget in ascending order. The placeholder in the LIMIT clause allows the user to specify the number of movie titles to retrieve."
        },
        {
            "sample_id": 762,
            "vt": "SELECT movie.genre FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE actor.\"birth city\" = '[placeholder-type:string]' AND movie.rating > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the genres of movies from the 'movie' table that feature actors born in a specific city and have a rating above a certain threshold. The placeholders represent the actor's birth city and the minimum movie rating."
        },
        {
            "sample_id": 736,
            "vt": "SELECT COUNT(*) FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE actor.name = '[placeholder-type:string]' AND movie.\"mpaa rating\" = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies that feature a specific actor and have a certain MPAA rating. It combines data from the 'movie', 'characters', and 'actor' tables to filter results based on the actor's name and the movie's MPAA rating."
        },
        {
            "sample_id": 754,
            "vt": "SELECT characters.\"character name\" FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID WHERE movie.title = '[placeholder-type:string]' AND characters.creditorder = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of characters from the 'movie' and 'characters' tables based on a specific movie title and the character's credit order. The placeholders in the WHERE clause represent the movie title and the credit order of the character."
        },
        {
            "sample_id": 731,
            "vt": "SELECT characters.\"character name\" FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID WHERE movie.title = '[placeholder-type:string]' ORDER BY characters.screentime LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of characters from movies based on a specific movie title. It retrieves character names by joining the 'movie' and 'characters' tables, filtering by the movie title provided as a placeholder. The results are ordered by the screentime of the characters, indicating their importance, and limited to a specified number of results."
        },
        {
            "sample_id": 737,
            "vt": "SELECT movie.title FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE actor.name = '[placeholder-type:string]' ORDER BY movie.rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies featuring a specific actor, ordered by their rating. It joins the 'movie', 'characters', and 'actor' tables to filter movies based on the actor's name and limits the results to a specified number."
        },
        {
            "sample_id": 767,
            "vt": "SELECT COUNT(*) FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE movie.title = '[placeholder-type:string]' AND actor.gender = '[placeholder-type:string]' AND actor.\"birth country\" = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies that feature actors of a specific gender from a particular birth country, filtered by the movie title."
        },
        {
            "sample_id": 755,
            "vt": "SELECT actor.name FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE movie.title = '[placeholder-type:string]' AND characters.creditorder = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of actors from the 'actor' table who played a specific character in a specific movie. The query joins the 'movie', 'characters', and 'actor' tables to filter based on the movie title and the character's credit order. The placeholders represent the movie title and the character's credit order."
        },
        {
            "sample_id": 733,
            "vt": "SELECT actor.name FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE movie.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of actors from the 'actor' table who have played in a specific movie. The query joins the 'movie' and 'characters' tables to link actors to their respective movies, filtering by the movie title provided as a placeholder."
        },
        {
            "sample_id": 753,
            "vt": "SELECT actor.\"height (inches)\" FROM characters INNER JOIN actor AS T2 ON T1.ActorID = T2.ActorID WHERE characters.\"character name\" = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the height of actors from the 'actor' table based on the character name they portrayed in the 'characters' table. The query uses an inner join to connect the 'characters' and 'actor' tables through the actor's unique ID, allowing for the selection of the height of the actor associated with a specific character name provided as a placeholder."
        },
        {
            "sample_id": 742,
            "vt": "SELECT AVG(movie.rating) FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE actor.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rating of movies featuring a specific actor. It joins the 'movie', 'characters', and 'actor' tables to correlate the actor's name with their respective movies and ratings."
        },
        {
            "sample_id": 761,
            "vt": "SELECT actor.name FROM actor WHERE actor.actorid = [placeholder-type:numeric] AND actor.gender = '[placeholder-type:string]' AND actor.ethnicity = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of actors from the 'actor' table who match a specific actor ID, gender, and ethnicity. The placeholders in the WHERE clause represent the actor's unique identifier, gender, and ethnicity."
        },
        {
            "sample_id": 773,
            "vt": "SELECT movie.runtime FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE actor.name = '[placeholder-type:string]' AND movie.rating > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the runtime of movies from the 'movie' table, specifically for those movies in which a particular actor has participated. It joins the 'characters' table to link actors to their respective movies and filters the results based on the actor's name and a minimum movie rating. The placeholders represent the actor's name and the minimum rating threshold."
        },
        {
            "sample_id": 758,
            "vt": "SELECT CAST(SUM(CASE WHEN actor.\"date of birth\" > '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(actor.\"date of birth\") FROM movie INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE movie.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average based on the birth dates of actors associated with a specific movie title. It sums up a conditional value based on whether the actor's date of birth is after a specified date, multiplies it by a placeholder numeric value, and divides by the count of actors' birth dates to get the average. The query involves joining the 'movie', 'characters', and 'actor' tables to gather the necessary data."
        }
    ],
    "sales": [
        {
            "sample_id": 5422,
            "vt": "SELECT sales.salesid FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE products.name LIKE '[placeholder-type:string]' AND products.price > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique sales IDs from the 'sales' table by joining it with the 'products' table. It filters the results based on the product name and ensures that the product price is greater than a specified numeric value. The placeholders represent the product name and price criteria."
        },
        {
            "sample_id": 5398,
            "vt": "SELECT (SELECT products.price FROM Products WHERE Name = 'HL Mountain Frame - Black, 42') - (SELECT products.price FROM Products WHERE Name = 'LL Mountain Frame - Black, 42')",
            "ba": "The virtual table calculates the price difference between two specific products from the 'Products' table. It retrieves the price of each product by their names and subtracts one from the other to find the difference."
        },
        {
            "sample_id": 5386,
            "vt": "SELECT CASE WHEN sales.productid = [placeholder-type:numeric] THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM sales INNER JOIN Customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.firstname = '[placeholder-type:string]'",
            "ba": "The virtual table provides a conditional selection of values based on the product ID from the 'sales' table, while also joining with the 'customers' table to filter results based on the customer's first name. The placeholders represent the product ID, two possible string outcomes based on the condition, and the customer's first name."
        },
        {
            "sample_id": 5371,
            "vt": "SELECT COUNT(sales.customerid) FROM sales INNER JOIN Products AS T2 ON T1.ProductID = T2.ProductID WHERE products.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of sales made to customers for a specific product from the 'sales' table. It joins the 'sales' table with the 'products' table to filter the results based on the product name provided as a placeholder."
        },
        {
            "sample_id": 5391,
            "vt": "SELECT products.productid FROM products ORDER BY products.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique product IDs from the 'products' table, ordered by their price. The placeholder in the LIMIT clause allows for specifying the maximum number of product IDs to retrieve."
        },
        {
            "sample_id": 5372,
            "vt": "SELECT COUNT(sales.salesid) FROM sales INNER JOIN Products AS T2 ON T1.ProductID = T2.ProductID WHERE products.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of sales transactions from the 'sales' table for a specific product. It joins the 'sales' table with the 'products' table to filter the results based on the product's name. The placeholder in the WHERE clause represents the name of the product being queried."
        },
        {
            "sample_id": 5412,
            "vt": "SELECT COUNT(customers.customerid) FROM customers WHERE customers.firstname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table whose first name matches a specified value. The placeholder in the WHERE clause represents the customer's first name."
        },
        {
            "sample_id": 5448,
            "vt": "SELECT employees.firstname, employees.middleinitial, employees.lastname FROM employees INNER JOIN Sales AS T2 ON T2.SalesPersonID = T1.EmployeeID GROUP BY sales.salespersonid, employees.firstname, employees.middleinitial, employees.lastname ORDER BY COUNT(sales.salesid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first name, middle initial, and last name of employees from the 'employees' table who have made sales. It uses an inner join with the 'sales' table to link employees to their sales records, grouping the results by salesperson ID and employee names, and ordering them by the count of sales made. The placeholder in the LIMIT clause represents the maximum number of records to return."
        },
        {
            "sample_id": 5430,
            "vt": "SELECT products.productid, products.name FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE sales.quantity BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] ORDER BY products.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the product IDs and names from the 'products' table that are associated with sales where the quantity sold falls within a specified range. The results are ordered by the product price and limited to a certain number of entries."
        },
        {
            "sample_id": 5403,
            "vt": "SELECT COUNT(sales.salespersonid) FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE products.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of sales made by a specific salesperson for a given product from the 'products' and 'sales' tables. The placeholder in the WHERE clause represents the name of the product being queried."
        },
        {
            "sample_id": 5413,
            "vt": "SELECT DISTINCT sales.quantity FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE products.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct quantities of products sold from the 'sales' table, filtered by the product name from the 'products' table. The join operation connects the 'products' and 'sales' tables based on the product ID, ensuring that only relevant sales data for the specified product is included."
        },
        {
            "sample_id": 5442,
            "vt": "SELECT CAST(SUM(CASE WHEN products.price BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(products.price) FROM sales INNER JOIN Products AS T2 ON T1.ProductID = T2.ProductID WHERE sales.salesid BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total price of products sold within a specified price range, adjusting for the quantity sold and averaging the results. It joins the 'sales' table with the 'products' table to access product pricing information, and it filters sales records based on a specified range of sales IDs."
        },
        {
            "sample_id": 5458,
            "vt": "SELECT COUNT(*) FROM (SELECT SUM(sales.quantity) FROM Sales WHERE ProductID IN (SELECT ProductID FROM Products WHERE Name = 'Touring-2000 Blue, 50') GROUP BY Quantity, SalesPersonID HAVING SUM(Quantity) > 20000)",
            "ba": "The virtual table calculates the total number of sales transactions for a specific product, 'Touring-2000 Blue, 50', where the total quantity sold by each salesperson exceeds 20,000 units. It first identifies the relevant product from the 'Products' table, then sums the quantities from the 'Sales' table grouped by salesperson, and finally counts how many salespersons meet the criteria."
        },
        {
            "sample_id": 5364,
            "vt": "SELECT SUM(sales.quantity) FROM sales WHERE sales.salesid BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total quantity of sales from the 'sales' table for a specific range of sales IDs. The placeholders represent the lower and upper bounds of the sales ID range."
        },
        {
            "sample_id": 5392,
            "vt": "SELECT COUNT(products.productid) FROM products WHERE products.price = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of products from the 'products' table that have a specific price. The placeholder in the WHERE clause represents the price of the product."
        },
        {
            "sample_id": 5466,
            "vt": "SELECT employees.firstname, employees.middleinitial, employees.lastname FROM employees INNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID ORDER BY sales.quantity * products.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first name, middle initial, and last name of employees from the 'employees' table who are associated with sales transactions. It joins the 'sales' table to link employees to their sales and the 'products' table to access product details. The results are ordered by the total price of the sales, calculated as the product of quantity and product price, and limited to a specified number of results."
        },
        {
            "sample_id": 5406,
            "vt": "SELECT DISTINCT customers.firstname, customers.middleinitial, customers.lastname FROM customers INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID WHERE products.name = '[placeholder-type:string]' AND products.price = [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct first names, middle initials, and last names of customers who have purchased a specific product with a specified price. The query joins the 'customers' table with the 'sales' table to link customers to their purchases, and then joins with the 'products' table to filter based on the product name and price."
        },
        {
            "sample_id": 5445,
            "vt": "SELECT COUNT(products.productid) FROM products WHERE products.name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of products from the 'products' table that match a specific name pattern. The placeholder in the LIKE clause allows for flexible searching of product names."
        },
        {
            "sample_id": 5390,
            "vt": "SELECT SUM(sales.quantity) FROM customers INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.firstname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total quantity of sales made by customers with a specific first name. It joins the 'customers' table with the 'sales' table to aggregate the quantity of products sold to those customers."
        },
        {
            "sample_id": 5378,
            "vt": "SELECT employees.lastname FROM employees INNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID WHERE sales.salesid = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the last names of employees from the 'employees' table who are associated with a specific sale identified by its sales ID. The query uses an inner join to connect the 'employees' table with the 'sales' table based on the salesperson's ID, ensuring that only the relevant employee's last name for the specified sale is returned."
        },
        {
            "sample_id": 5410,
            "vt": "SELECT products.name FROM products WHERE products.price IN ((SELECT MAX(products.price) FROM Products), (SELECT MIN(products.price) FROM Products))",
            "ba": "The virtual table retrieves the names of products from the 'products' table that have either the maximum or minimum price. The placeholders in the query represent the conditions for filtering the product prices based on their maximum and minimum values."
        },
        {
            "sample_id": 5401,
            "vt": "SELECT COUNT(sales.customerid) FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Employees AS T3 ON T2.SalesPersonID = T3.EmployeeID WHERE employees.firstname = '[placeholder-type:string]' AND employees.lastname = '[placeholder-type:string]' AND products.name = '[placeholder-type:string]' AND employees.middleinitial = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of sales made by a specific employee for a specific product. It joins the 'products', 'sales', and 'employees' tables to filter the results based on the employee's first name, last name, middle initial, and the product's name."
        },
        {
            "sample_id": 5405,
            "vt": "SELECT COUNT(sales.salesid) FROM sales INNER JOIN Customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.firstname = '[placeholder-type:string]' AND customers.middleinitial = '[placeholder-type:string]' AND customers.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of sales transactions from the 'sales' table for a specific customer identified by their first name, middle initial, and last name. It joins the 'sales' table with the 'customers' table to filter the results based on the customer's name."
        },
        {
            "sample_id": 5394,
            "vt": "SELECT DISTINCT employees.firstname, employees.middleinitial, employees.lastname FROM sales INNER JOIN Employees AS T2 ON T1.SalesPersonID = T2.EmployeeID WHERE sales.quantity = [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct first names, middle initials, and last names of employees from the 'employees' table who have made sales with a specific quantity. The query uses an INNER JOIN to connect the 'sales' table with the 'employees' table based on the salesperson's ID. The placeholder in the WHERE clause represents the quantity of sales made by the employees."
        },
        {
            "sample_id": 5421,
            "vt": "SELECT customers.firstname, customers.lastname FROM customers INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.firstname = '[placeholder-type:string]' ORDER BY sales.quantity LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of customers from the 'customers' table who have made purchases, filtered by a specific first name. The query also limits the results based on a specified quantity, allowing for a controlled output of customer names."
        },
        {
            "sample_id": 5431,
            "vt": "SELECT customers.firstname, customers.lastname FROM sales INNER JOIN Customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE customers.firstname = '[placeholder-type:string]' ORDER BY sales.quantity LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of customers from the 'customers' table who have made purchases, filtered by a specific first name. The query also limits the results based on a specified quantity, allowing for a controlled output of customer names."
        },
        {
            "sample_id": 5365,
            "vt": "SELECT AVG(sales.quantity) FROM sales WHERE sales.salesid BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average quantity of sales from the 'sales' table for a specific range of sales IDs. The placeholders represent the lower and upper bounds of the sales ID range."
        },
        {
            "sample_id": 5374,
            "vt": "SELECT customers.firstname FROM customers INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID WHERE sales.productid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first names of customers who have made purchases of a specific product. It retrieves data from the 'customers' table and joins it with the 'sales' table to link customers with their purchases, and further joins with the 'products' table to filter by a specific product ID. The placeholder in the WHERE clause represents the unique identifier of the product being queried."
        },
        {
            "sample_id": 5395,
            "vt": "SELECT products.name, sales.quantity FROM customers INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID WHERE sales.salesid BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of products and the quantities sold from the 'sales' table, while linking customer information from the 'customers' table. It filters the results based on a range of sales IDs using placeholders for numeric values."
        },
        {
            "sample_id": 5373,
            "vt": "SELECT DISTINCT products.name FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE sales.salespersonid = [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct names of products sold by a specific salesperson from the 'products' table. The query joins the 'products' table with the 'sales' table to filter the results based on the salesperson's unique identifier, represented by a placeholder for numeric values."
        },
        {
            "sample_id": 5460,
            "vt": "SELECT products.name, SUM(sales.quantity * products.price) FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID GROUP BY products.productid, products.name ORDER BY SUM(sales.quantity) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total sales revenue generated for each product by calculating the total price based on the quantity sold and the product's price. It joins the 'products' table with the 'sales' table to aggregate the sales data, grouping by product ID and name, and orders the results by the total quantity sold, limiting the output to a specified number of records."
        },
        {
            "sample_id": 5381,
            "vt": "SELECT customers.firstname, customers.middleinitial, customers.lastname FROM customers INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID WHERE sales.salespersonid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first name, middle initial, and last name of customers from the 'customers' table who have made purchases through a specific salesperson. The query joins the 'customers' table with the 'sales' table to filter the results based on the salesperson's unique identifier."
        },
        {
            "sample_id": 5437,
            "vt": "SELECT DISTINCT products.price, sales.quantity FROM sales INNER JOIN Products AS T2 ON T1.ProductID = T2.ProductID WHERE products.name = '[placeholder-type:string]'",
            "ba": "The virtual table displays the distinct prices of products along with the trading quantities from the 'sales' table. It joins the 'sales' table with the 'products' table to filter results based on a specific product name. The placeholder in the WHERE clause represents the name of the product being queried."
        },
        {
            "sample_id": 5369,
            "vt": "SELECT products.name FROM products WHERE products.productid BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of products from the 'products' table that fall within a specified range of product IDs. The placeholders represent the lower and upper bounds of the product ID range."
        },
        {
            "sample_id": 5459,
            "vt": "SELECT SUM(sales.quantity * products.price) FROM employees INNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID WHERE employees.firstname = '[placeholder-type:string]' AND employees.middleinitial = '[placeholder-type:string]' AND employees.lastname = '[placeholder-type:string]' AND products.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total sales amount for a specific employee based on their first name, middle initial, and last name, as well as the name of a specific product. It sums up the total price derived from the quantity sold multiplied by the product's price."
        },
        {
            "sample_id": 5399,
            "vt": "SELECT COUNT(sales.salesid) FROM sales INNER JOIN Employees AS T2 ON T1.SalesPersonID = T2.EmployeeID WHERE employees.firstname = '[placeholder-type:string]' AND employees.middleinitial = '[placeholder-type:string]' AND employees.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of sales made by a specific employee identified by their first name, middle initial, and last name. It joins the 'sales' table with the 'employees' table to filter the sales records based on the employee's details."
        },
        {
            "sample_id": 5446,
            "vt": "SELECT COUNT(customers.customerid) FROM customers GROUP BY customers.lastname ORDER BY COUNT(customers.lastname) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of customers grouped by their last names from the 'customers' table. The result is ordered by the count of customers with the same last name, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 5432,
            "vt": "SELECT sales.customerid, sales.salesid FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE products.price BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND sales.quantity < [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the customer ID and sales ID from the 'sales' table, while joining with the 'products' table to filter products based on their price range and the quantity sold."
        },
        {
            "sample_id": 5366,
            "vt": "SELECT DISTINCT sales.productid FROM sales WHERE sales.quantity = (SELECT MAX(sales.quantity) FROM Sales)",
            "ba": "The virtual table identifies the unique product IDs from the 'sales' table that have the highest trading quantity. The subquery calculates the maximum quantity sold, and the main query filters the results to show only those products that match this maximum quantity."
        },
        {
            "sample_id": 5380,
            "vt": "SELECT COUNT(products.productid) FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE sales.customerid = [placeholder-type:numeric] AND products.price = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of products sold at a specific price to a specific customer. It joins the 'products' table with the 'sales' table to filter the results based on the customer ID and the product price."
        },
        {
            "sample_id": 5443,
            "vt": "SELECT products.name FROM products WHERE products.price = (SELECT MAX(products.price) FROM Products)",
            "ba": "The virtual table retrieves the name of the product from the 'products' table that has the highest price. The subquery calculates the maximum price from the 'products' table, and the main query filters the products to find the one that matches this maximum price."
        },
        {
            "sample_id": 5450,
            "vt": "SELECT SUM(sales.quantity) FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE products.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total quantity sold of a specific product from the 'products' table by joining it with the 'sales' table. The placeholder in the WHERE clause represents the name of the product for which the total quantity is being calculated."
        },
        {
            "sample_id": 5382,
            "vt": "SELECT sales.salesid FROM sales INNER JOIN Employees AS T2 ON T1.SalesPersonID = T2.EmployeeID WHERE SUBSTRING(employees.firstname, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the sales IDs from the 'sales' table, specifically focusing on sales made by a particular employee. It joins the 'sales' table with the 'employees' table to access employee details. The query filters results based on a substring of the employee's first name, allowing for a flexible search based on specified starting position and length of the substring."
        },
        {
            "sample_id": 5408,
            "vt": "SELECT COUNT(employees.employeeid) FROM employees",
            "ba": "The virtual table counts the number of employees from the 'employees' table."
        },
        {
            "sample_id": 5463,
            "vt": "SELECT AVG(products.price) FROM products WHERE products.price BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average price of products from the 'products' table that fall within a specified price range. The placeholders represent the lower and upper bounds of the price range."
        },
        {
            "sample_id": 5388,
            "vt": "SELECT SUM(products.price * sales.quantity) FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE products.productid BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total price of products sold by summing the product prices multiplied by their respective quantities from the 'sales' table. It uses an inner join to connect the 'products' and 'sales' tables based on the product ID, and filters the results based on a range of product IDs specified by placeholders."
        },
        {
            "sample_id": 5462,
            "vt": "SELECT employees.middleinitial FROM employees GROUP BY employees.middleinitial ORDER BY COUNT(employees.middleinitial) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the middle initials of employees from the 'employees' table, grouping them to count occurrences. It orders the results by the count of each middle initial and limits the output to a specified number of results."
        },
        {
            "sample_id": 5387,
            "vt": "SELECT SUM(products.price * sales.quantity) FROM customers INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID WHERE customers.firstname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total price of products purchased by customers based on their first name. It joins the 'customers', 'sales', and 'products' tables to aggregate the total cost of products sold to a specific customer identified by their first name."
        },
        {
            "sample_id": 5385,
            "vt": "SELECT SUM(CASE WHEN employees.firstname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) + SUM(CASE WHEN employees.firstname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) + SUM(CASE WHEN employees.firstname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM sales INNER JOIN Employees AS T2 ON T1.SalesPersonID = T2.EmployeeID",
            "ba": "The virtual table calculates the total price of sales made by specific employees from the 'sales' table. It uses conditional aggregation to sum the total price based on the first names of the employees, with placeholders for employee first names and quantities. The query joins the 'sales' table with the 'employees' table to associate each sale with the corresponding employee."
        },
        {
            "sample_id": 5419,
            "vt": "SELECT SUM(sales.quantity) FROM customers INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN Employees AS T3 ON T2.SalesPersonID = T3.EmployeeID WHERE sales.salespersonid = [placeholder-type:numeric] AND customers.firstname = '[placeholder-type:string]' AND customers.lastname = '[placeholder-type:string]' AND employees.firstname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total quantity of sales made by a specific salesperson for a particular customer. It joins the 'customers', 'sales', and 'employees' tables to filter the results based on the salesperson's ID and the customer's first and last names, as well as the employee's first name."
        },
        {
            "sample_id": 5440,
            "vt": "SELECT customers.firstname, customers.lastname FROM sales INNER JOIN Customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE sales.quantity = [placeholder-type:numeric] AND sales.salesid BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of customers from the 'customers' table who have made a purchase. It filters the sales records based on the quantity of products sold and a range of sales IDs. The placeholders in the WHERE clause represent the quantity of products and the range of sales IDs."
        },
        {
            "sample_id": 5367,
            "vt": "SELECT COUNT(DISTINCT ProductID) FROM products WHERE products.price = (SELECT MAX(products.price) FROM Products)",
            "ba": "The virtual table counts the distinct product IDs from the 'products' table where the product price is equal to the maximum price found in the 'products' table. This indicates how many unique products are available at the highest price."
        },
        {
            "sample_id": 5429,
            "vt": "SELECT DISTINCT products.name FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Customers AS T3 ON T2.CustomerID = T3.CustomerID WHERE customers.firstname = '[placeholder-type:string]' AND customers.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct names of products purchased by customers from the 'products' table. It joins the 'sales' table to link products with sales transactions and the 'customers' table to filter based on the customer's first and last name. The placeholders in the WHERE clause represent the customer's first and last names."
        },
        {
            "sample_id": 5428,
            "vt": "SELECT COUNT(products.productid) FROM products WHERE products.productid < [placeholder-type:numeric] AND products.price <= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of products from the 'products' table that have a product ID less than a specified value and a price that is less than or equal to a specified price. The placeholders represent the numeric values for the product ID and price."
        },
        {
            "sample_id": 5415,
            "vt": "SELECT customers.firstname, customers.lastname FROM customers INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID ORDER BY sales.quantity LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of customers from the 'customers' table who have made purchases, by joining with the 'sales' table. The results are ordered by the quantity of products sold, and a limit is applied to restrict the number of records returned."
        },
        {
            "sample_id": 5455,
            "vt": "SELECT products.name FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE products.name LIKE '[placeholder-type:string]' GROUP BY sales.quantity, products.name ORDER BY SUM(sales.quantity) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of products from the 'products' table that match a specified pattern. It joins the 'products' table with the 'sales' table to correlate product sales data. The results are grouped by product name and quantity sold, allowing for an aggregated view of sales. The output is ordered by the total quantity sold, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 5411,
            "vt": "SELECT CAST(SUM(CASE WHEN employees.firstname = '[placeholder-type:string]' AND employees.middleinitial = '[placeholder-type:string]' AND employees.lastname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(sales.customerid) FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Employees AS T3 ON T2.SalesPersonID = T3.EmployeeID WHERE products.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average total price of products sold by a specific employee, identified by their first name, middle initial, and last name. It sums the total price of sales for a particular product and divides it by the count of customers associated with those sales. The placeholders represent the employee's name details and the product name."
        },
        {
            "sample_id": 5433,
            "vt": "SELECT sales.quantity, products.price FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Customers AS T3 ON T2.CustomerID = T3.CustomerID WHERE customers.firstname = '[placeholder-type:string]' AND customers.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table displays the quantity of products sold and their corresponding prices from the 'products' table, filtered by the first and last names of customers from the 'customers' table. The query joins the 'sales' table to link sales records with product details and customer information."
        },
        {
            "sample_id": 5389,
            "vt": "SELECT SUM(sales.quantity) FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE SUBSTRING(products.name, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total quantity sold of a specific product from the 'products' table by joining it with the 'sales' table. The query uses a substring function to filter products based on a specific portion of their name, indicated by placeholders for numeric values, while the product name itself is represented by a string placeholder."
        },
        {
            "sample_id": 5444,
            "vt": "SELECT COUNT(customers.customerid) FROM customers WHERE customers.firstname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customers' table whose first name matches a specified value. The placeholder in the WHERE clause represents the customer's first name."
        },
        {
            "sample_id": 5377,
            "vt": "SELECT DISTINCT sales.productid FROM employees INNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID WHERE employees.firstname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct product IDs from the 'sales' table, which are associated with sales made by employees whose first name matches a specified value. It uses an inner join to connect the 'employees' table with the 'sales' table based on the salesperson's ID."
        },
        {
            "sample_id": 5465,
            "vt": "SELECT customers.firstname, customers.middleinitial, customers.lastname FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Customers AS T3 ON T2.CustomerID = T3.CustomerID ORDER BY sales.quantity * products.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first name, middle initial, and last name of customers who have purchased products. It combines data from the 'customers', 'sales', and 'products' tables, filtering the results based on the quantity of products sold multiplied by their price. The results are ordered by the total price of the sales, and a limit is applied to restrict the number of records returned."
        },
        {
            "sample_id": 5452,
            "vt": "SELECT SUM(sales.quantity) FROM employees INNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID WHERE employees.firstname = '[placeholder-type:string]' AND employees.lastname = '[placeholder-type:string]' AND products.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total quantity of products sold by a specific employee identified by their first and last name, for a particular product name. It joins the 'employees', 'sales', and 'products' tables to gather the necessary data."
        },
        {
            "sample_id": 5436,
            "vt": "SELECT products.name FROM products INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Customers AS T3 ON T2.CustomerID = T3.CustomerID WHERE customers.firstname = '[placeholder-type:string]' AND customers.lastname = '[placeholder-type:string]' ORDER BY sales.quantity LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of products purchased by a specific customer from the 'products' table. It joins the 'sales' table to link products with sales transactions and the 'customers' table to filter by the customer's first and last name. The results are ordered by the quantity of products sold, and a limit is applied to restrict the number of results returned."
        }
    ],
    "synthea": [
        {
            "sample_id": 1425,
            "vt": "SELECT patients.first, patients.last FROM patients INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE medications.description = '[placeholder-type:string]' AND STRFTIME('%Y', medications.stop) - STRFTIME('%Y', medications.start) > [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of patients who have been prescribed a specific medication for a duration longer than a specified number of years. The query joins the 'patients' table with the 'medications' table to filter patients based on the medication description and the duration of the medication usage."
        },
        {
            "sample_id": 1380,
            "vt": "SELECT COUNT(DISTINCT T2.code) FROM patients INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE patients.prefix = '[placeholder-type:string]' AND patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct allergy codes associated with patients who have a specific prefix, first name, and last name. It joins the 'patients' table with the 'allergies' table based on the patient ID, filtering for the specified name criteria."
        },
        {
            "sample_id": 1524,
            "vt": "SELECT DISTINCT patients.first, patients.last FROM patients INNER JOIN conditions AS T2 ON T1.patient = T2.patient WHERE conditions.description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct first and last names of patients from the 'patients' table who have a specific condition. The query joins the 'patients' table with the 'conditions' table to filter patients based on the description of their condition, represented by a placeholder for string values."
        },
        {
            "sample_id": 1461,
            "vt": "SELECT CASE WHEN SUBSTRING(allergies.stop, -[placeholder-type:numeric], [placeholder-type:numeric]) <> '[placeholder-type:string]' THEN SUBSTRING(allergies.stop, LENGTH(allergies.stop) - [placeholder-type:numeric]) + [placeholder-type:numeric] END - CASE WHEN SUBSTRING(allergies.start, -[placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' THEN SUBSTRING(allergies.start, LENGTH(allergies.start) - [placeholder-type:numeric]) + [placeholder-type:numeric] ELSE SUBSTRING(allergies.start, LENGTH(allergies.start) - [placeholder-type:numeric]) + [placeholder-type:numeric] END, allergies.description FROM allergies INNER JOIN patients AS T2 ON T2.patient = T1.PATIENT WHERE NOT allergies.stop IS NULL AND NOT allergies.start IS NULL AND patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the duration of allergies for patients by subtracting the start date from the stop date, while also retrieving the description of the allergy. It filters the results to include only those allergies that have both a start and stop date, and it specifically looks for allergies associated with patients whose first and last names match the provided placeholders."
        },
        {
            "sample_id": 1421,
            "vt": "SELECT patients.first, patients.last FROM patients INNER JOIN procedures AS T2 ON T1.patient = T2.PATIENT WHERE procedures.description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of patients from the 'patients' table who have undergone a specific procedure. The query joins the 'patients' table with the 'procedures' table based on the patient ID, filtering the results to include only those procedures that match a specified description."
        },
        {
            "sample_id": 1396,
            "vt": "SELECT DISTINCT patients.first, patients.last, patients.suffix FROM patients INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE medications.description = '[placeholder-type:string]' AND STRFTIME('%Y', medications.start) = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of unique patients' first names, last names, and suffixes from the 'patients' table who have been prescribed a specific medication during a specified year. The placeholders in the WHERE clause represent the medication description and the year of the medication start date."
        },
        {
            "sample_id": 1517,
            "vt": "SELECT DISTINCT patients.first, patients.last FROM patients INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE allergies.description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct first and last names of patients from the 'patients' table who have a specific allergy. The query joins the 'patients' table with the 'allergies' table based on the patient ID, filtering for a specific allergy description using a placeholder."
        },
        {
            "sample_id": 1464,
            "vt": "SELECT immunizations.date FROM patients INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE immunizations.description = '[placeholder-type:string]' AND patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the dates of immunizations for patients based on their first and last names, as well as a specific description of the immunization. It joins the 'patients' table with the 'immunizations' table to filter the results accordingly."
        },
        {
            "sample_id": 1454,
            "vt": "SELECT COUNT(DISTINCT T1.patient) FROM patients INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE medications.reasondescription = '[placeholder-type:string]' AND patients.ethnicity = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct patients from the 'patients' table who have received medications for a specific reason and belong to a certain ethnicity. The placeholders in the WHERE clause represent the reason for medication and the ethnicity of the patients."
        },
        {
            "sample_id": 1385,
            "vt": "SELECT CAST(SUM(STRFTIME('%J', careplans.stop) - STRFTIME('%J', careplans.start)) AS FLOAT) / COUNT(patients.patient) FROM patients INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE patients.prefix = '[placeholder-type:string]' AND patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average duration of care plans for patients with a specific prefix, first name, and last name. It does this by summing the total number of days between the start and stop dates of the care plans and dividing that by the total number of patients that match the specified criteria."
        },
        {
            "sample_id": 1360,
            "vt": "SELECT SUM(CASE WHEN STRFTIME('%Y', observations.date) = '[placeholder-type:string]' THEN observations.value END) - SUM(CASE WHEN STRFTIME('%Y', observations.date) = '[placeholder-type:string]' THEN observations.value END), observations.units FROM patients INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND observations.description = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference in the sum of observation values for a specific patient between two years, while also providing the units of the observation. It joins the 'patients' table with the 'observations' table to filter by the patient's first and last name and the specific observation description."
        },
        {
            "sample_id": 1501,
            "vt": "SELECT COUNT(patients.patient), CAST(SUM(CASE WHEN encounters.description = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(patients.patient) FROM patients INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND STRFTIME('%Y', encounters.date) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table calculates the prevalence rate of a specific condition for a patient identified by their first and last name over a specified date range. It counts the total number of patients and sums the occurrences of encounters that match a given description, then computes the prevalence rate as a percentage of the total patient count."
        },
        {
            "sample_id": 1416,
            "vt": "SELECT DISTINCT observations.description, observations.value, observations.units FROM patients INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE observations.description = '[placeholder-type:string]' AND patients.address = '[placeholder-type:string]'",
            "ba": "The virtual table provides distinct observations made on patients, including the description of the observation, its value, and the units of measurement. It filters the results based on a specific observation description and the patient's address."
        },
        {
            "sample_id": 1543,
            "vt": "SELECT SUM(CASE WHEN patients.marital = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN patients.marital = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM conditions INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE conditions.description = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between the sum of a specific numeric value for patients with a certain marital status and the sum of the same numeric value for patients with a different marital status. It retrieves data from the 'conditions' table, which contains descriptions of conditions related to prevalent diseases, and joins it with the 'patients' table to filter based on the marital status of patients. The placeholder in the WHERE clause represents the condition description, while the placeholders in the SUM functions represent the numeric values to be summed based on marital status."
        },
        {
            "sample_id": 1540,
            "vt": "SELECT patients.first, patients.last FROM observations INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE observations.description = '[placeholder-type:string]' AND observations.units = '[placeholder-type:string]' AND observations.value = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of patients from the 'patients' table who have specific observations recorded in the 'observations' table. The query filters these observations based on a description, units, and a numeric value, allowing users to find patients associated with particular observation criteria."
        },
        {
            "sample_id": 1488,
            "vt": "SELECT encounters.reasondescription FROM patients INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND encounters.date LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the reason descriptions for medical encounters associated with a specific patient identified by their first and last names, along with a specific date of the encounter. The placeholders represent the patient's first name, last name, and the date of the encounter."
        },
        {
            "sample_id": 1457,
            "vt": "SELECT COUNT(DISTINCT T1.patient) FROM patients INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE medications.description = '[placeholder-type:string]' AND patients.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of patients who have been prescribed a specific medication and belong to a certain gender. It combines data from the 'patients' table and the 'medications' table, filtering based on the medication description and the patient's gender."
        },
        {
            "sample_id": 1364,
            "vt": "SELECT STRFTIME('%J', medications.stop) - STRFTIME('%J', medications.start) FROM patients INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND medications.description LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the duration of medication for a specific patient by subtracting the start date from the stop date of their medications. It retrieves this information by joining the 'patients' table with the 'medications' table based on the patient ID. The query filters results based on the patient's first name, last name, and a specific description of the medication."
        },
        {
            "sample_id": 1534,
            "vt": "SELECT patients.first, patients.last FROM conditions INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE conditions.description = '[placeholder-type:string]' AND ROUND((STRFTIME('%J', patients.deathdate) - STRFTIME('%J', patients.birthdate)) / [placeholder-type:numeric]) = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of patients who have a specific condition and whose age matches a certain value. The query joins the 'conditions' table with the 'patients' table to filter patients based on the condition description and calculates their age by subtracting the birthdate from the deathdate, using placeholders for the condition and age values."
        },
        {
            "sample_id": 1521,
            "vt": "SELECT COUNT(DISTINCT T1.patient) FROM patients INNER JOIN conditions AS T2 ON T1.patient = T2.patient WHERE STRFTIME('%Y', patients.birthdate) = '[placeholder-type:string]' AND patients.race = '[placeholder-type:string]' AND conditions.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct patients from the 'patients' table who have a specific condition, filtered by their birth year and race. The placeholders represent the birth year, race, and condition description respectively."
        },
        {
            "sample_id": 1399,
            "vt": "SELECT COUNT(DISTINCT T2.patient) FROM all_prevalences INNER JOIN conditions AS T2 ON LOWER(T1.ITEM) = LOWER(T2.DESCRIPTION) ORDER BY all_prevalences.\"prevalence rate\" LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of patients who have conditions matching prevalent diseases from the 'all_prevalences' table. It uses an inner join to connect the 'all_prevalences' and 'conditions' tables based on the disease description, ensuring that the comparison is case-insensitive. The result is ordered by the prevalence rate, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 1477,
            "vt": "SELECT DISTINCT patients.first, patients.last FROM patients INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE observations.description = '[placeholder-type:string]' AND observations.value < [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of unique first and last names of patients from the 'patients' table who have specific observations recorded in the 'observations' table. The query filters these observations based on a given description and a numeric value, ensuring that only those patients whose observation values are less than the specified numeric threshold are included."
        },
        {
            "sample_id": 1495,
            "vt": "SELECT encounters.date - patients.birthdate FROM patients INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' ORDER BY encounters.date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the age of patients at the time of their encounters by subtracting their birthdate from the encounter date. It retrieves data from the 'patients' and 'encounters' tables, filtering based on the patient's first and last names. The results are ordered by the encounter date, and a limit is applied to restrict the number of records returned."
        },
        {
            "sample_id": 1511,
            "vt": "SELECT DISTINCT patients.first, patients.last FROM careplans INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE careplans.description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct first and last names of patients from the 'patients' table who have a specific care plan description. The query uses an inner join between the 'careplans' and 'patients' tables to link patients with their care plans, filtering based on the care plan description provided by the user."
        },
        {
            "sample_id": 1446,
            "vt": "SELECT COUNT(DISTINCT T2.patient) FROM medications INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE medications.reasondescription = '[placeholder-type:string]' AND NOT medications.stop IS NULL AND patients.deathdate IS NULL",
            "ba": "The virtual table counts the number of distinct patients who have received medications for a specific reason, ensuring that only those who are currently alive and have completed their medication regimen are included in the count."
        },
        {
            "sample_id": 1386,
            "vt": "SELECT CAST(SUM(STRFTIME('%J', conditions.stop) - STRFTIME('%J', conditions.start)) AS FLOAT) / COUNT(conditions.patient) FROM patients INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE patients.prefix = '[placeholder-type:string]' AND patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND conditions.description = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average duration of a specific condition for a patient identified by their name and prefix. It does this by summing the total days of the condition (calculated from the start and stop dates) and dividing it by the number of occurrences of that condition for the specified patient. The placeholders represent the patient's prefix, first name, last name, and the description of the condition."
        },
        {
            "sample_id": 1503,
            "vt": "SELECT DISTINCT careplans.start FROM careplans INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE patients.maiden = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of distinct start dates for care plans from the 'careplans' table, specifically for patients who have a maiden name. The query joins the 'careplans' table with the 'patients' table to filter the results based on the maiden name of the patients."
        },
        {
            "sample_id": 1434,
            "vt": "SELECT DISTINCT patients.first FROM patients INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE conditions.description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct first names of patients from the 'patients' table who have a specific condition. The query joins the 'patients' table with the 'conditions' table to filter patients based on the condition's description, represented by a placeholder for string values."
        },
        {
            "sample_id": 1513,
            "vt": "SELECT COUNT(DISTINCT T2.patient) FROM careplans INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE patients.ethnicity = '[placeholder-type:string]' AND careplans.code = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of patients who have a specific care plan code and belong to a certain ethnicity. It combines data from the 'careplans' table and the 'patients' table using an inner join on the patient ID, ensuring that only patients with matching care plans are considered. The placeholders represent the ethnicity and care plan code that can be specified by the user."
        },
        {
            "sample_id": 1379,
            "vt": "SELECT COUNT(claims.billableperiod) FROM patients INNER JOIN claims AS T2 ON T1.patient = T2.PATIENT WHERE patients.prefix = '[placeholder-type:string]' AND patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND claims.billableperiod BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of billable periods from the 'claims' table for patients who match specific criteria. It filters patients based on their prefix, first name, and last name, and also restricts the results to those claims that fall within a specified date range for the billable period."
        },
        {
            "sample_id": 1458,
            "vt": "SELECT CAST(SUM(CASE WHEN allergies.description = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS REL) * [placeholder-type:numeric] / COUNT(patients.patient) FROM patients INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE patients.birthplace = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted sum of allergy occurrences for patients based on their birthplace. It sums the occurrences of a specific allergy description and multiplies it by a placeholder numeric value, then divides by the total number of patients from the specified birthplace."
        },
        {
            "sample_id": 1530,
            "vt": "SELECT AVG(observations.value) FROM observations INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE patients.race = '[placeholder-type:string]' AND observations.description = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average observation value from the 'observations' table for patients of a specific race and a specific observation description. The placeholders represent the race of the patients and the type of observation being queried."
        },
        {
            "sample_id": 1455,
            "vt": "SELECT COUNT(DISTINCT T1.patient) FROM patients INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE patients.marital = '[placeholder-type:string]' AND careplans.reasondescription = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct patients from the 'patients' table who have care plans associated with them. It filters the results based on the marital status of the patients and the reason description of the care plans. The placeholders represent the specific marital status and reason description that the user wants to query."
        },
        {
            "sample_id": 1442,
            "vt": "SELECT COUNT(DISTINCT T1.patient) FROM patients INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE immunizations.description = '[placeholder-type:string]' AND patients.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct patients who have received a specific immunization and belong to a certain gender. It combines data from the 'patients' table and the 'immunizations' table, filtering based on the immunization description and the patient's gender."
        },
        {
            "sample_id": 1433,
            "vt": "SELECT DISTINCT patients.birthdate FROM patients INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT WHERE encounters.description = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct birthdates of patients from the 'patients' table who have had encounters with a specific description. The query joins the 'patients' table with the 'encounters' table to filter based on the encounter description provided by the user."
        },
        {
            "sample_id": 1483,
            "vt": "SELECT COUNT(DISTINCT T2.patient) FROM conditions INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE conditions.description = '[placeholder-type:string]' AND patients.gender = '[placeholder-type:string]' AND patients.marital = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct patients from the 'conditions' table who have a specific condition description, filtered by their gender and marital status from the 'patients' table. The placeholders represent the condition description, gender, and marital status respectively."
        },
        {
            "sample_id": 1452,
            "vt": "SELECT DISTINCT claims.billableperiod FROM patients INNER JOIN claims AS T2 ON T1.patient = T2.PATIENT WHERE patients.last = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct billable periods from the 'claims' table for patients with a specific last name. It joins the 'patients' table with the 'claims' table based on the patient ID to filter the claims associated with those patients."
        },
        {
            "sample_id": 1450,
            "vt": "SELECT COUNT(DISTINCT T2.patient) FROM careplans INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient INNER JOIN observations AS T3 ON T2.patient = T3.PATIENT WHERE observations.description = '[placeholder-type:string]' AND careplans.description = '[placeholder-type:string]' AND observations.value > [placeholder-type:numeric] AND observations.units = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of patients who have specific care plans and observations. It joins the 'careplans' table with the 'patients' table to link patients to their care plans, and then further joins with the 'observations' table to filter based on specific observation descriptions, values, and units. The placeholders represent the criteria for filtering observations and care plans, allowing users to specify the desired conditions."
        },
        {
            "sample_id": 1520,
            "vt": "SELECT DISTINCT patients.first, patients.last FROM patients INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE medications.description = '[placeholder-type:string]' AND STRFTIME('%Y', medications.start) >= '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct first and last names of patients who have been prescribed a specific medication, filtered by the medication's description and the start date of the medication regimen."
        },
        {
            "sample_id": 1359,
            "vt": "SELECT observations.value, observations.units FROM patients INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND observations.date = '[placeholder-type:string]' AND observations.description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the observation values and their corresponding units for a specific patient identified by their first and last names. The query filters the observations based on the patient's name and a specific observation date, as well as the description of the observation."
        },
        {
            "sample_id": 1363,
            "vt": "SELECT patients.first, patients.last FROM patients INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE observations.value = (SELECT MAX(observations.value) FROM observations WHERE description = 'Systolic Blood Pressure') LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the first and last names of patients from the 'patients' table who have the highest recorded value for their systolic blood pressure from the 'observations' table. The query uses a subquery to find the maximum value of systolic blood pressure and limits the results based on a specified number of patients."
        },
        {
            "sample_id": 1378,
            "vt": "SELECT DISTINCT procedures.description FROM patients INNER JOIN procedures AS T2 ON T1.patient = T2.PATIENT WHERE patients.prefix = '[placeholder-type:string]' AND patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND procedures.date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct procedures performed on patients filtered by their name and prefix, as well as the date of the procedure. The placeholders represent the patient's prefix, first name, last name, and the specific date of the procedure."
        },
        {
            "sample_id": 1523,
            "vt": "SELECT patients.patient FROM patients INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT INNER JOIN all_prevalences AS T3 ON T3.ITEM = T2.DESCRIPTION ORDER BY all_prevalences.occurrences LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists unique patient identifiers from the 'patients' table who have conditions that match prevalent diseases recorded in the 'all_prevalences' table. The results are filtered to include only those patients with specific conditions, and they are ordered by the number of occurrences of these conditions, with a limit on the number of results returned."
        },
        {
            "sample_id": 1496,
            "vt": "SELECT conditions.description FROM patients INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND STRFTIME('%Y', conditions.start) = '[placeholder-type:string]'",
            "ba": "The virtual table describes the conditions associated with a specific patient identified by their first and last name, along with a specific year when the condition started. The query joins the 'patients' table with the 'conditions' table to retrieve the relevant condition descriptions for the patient whose first and last names match the provided placeholders, and filters the results based on the year extracted from the condition's start date."
        },
        {
            "sample_id": 1423,
            "vt": "SELECT patients.first, patients.last FROM patients INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE allergies.description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of patients from the 'patients' table who have a specific allergy. The query uses an inner join to connect the 'patients' table with the 'allergies' table based on the patient ID, and filters the results based on the allergy description provided as a placeholder."
        },
        {
            "sample_id": 1468,
            "vt": "SELECT COUNT(DISTINCT T1.patient) FROM patients INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE patients.marital = '[placeholder-type:string]' AND medications.reasondescription = '[placeholder-type:string]' AND medications.description = '[placeholder-type:string]' AND STRFTIME('%Y', medications.start) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of patients from the 'patients' table who have received medications based on specific criteria. It filters patients by their marital status and requires that the medications have a specific reason description and medication description. Additionally, it restricts the results to medications that started in a particular year."
        },
        {
            "sample_id": 1470,
            "vt": "SELECT COUNT(DISTINCT T1.patient) FROM patients INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT WHERE patients.ethnicity = '[placeholder-type:string]' AND encounters.date BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND encounters.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct patients from the 'patients' table who have had encounters recorded in the 'encounters' table. It filters the results based on the patient's ethnicity, the date range of the encounters, and a specific description of the encounter."
        },
        {
            "sample_id": 1408,
            "vt": "SELECT COUNT(DISTINCT T2.patient) FROM conditions INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE conditions.description = '[placeholder-type:string]' AND patients.deathdate IS NULL",
            "ba": "The virtual table counts the number of distinct patients from the 'conditions' table who have a specific condition and are still alive. It joins the 'conditions' table with the 'patients' table based on the patient ID, filtering for those patients whose death date is null, indicating they are living, and for a specific condition description."
        },
        {
            "sample_id": 1505,
            "vt": "SELECT CAST(SUM(CASE WHEN patients.race = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(careplans.patient) FROM careplans INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE STRFTIME('%Y', careplans.stop) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted sum of a specific race's occurrences in care plans, normalized by the total number of patients with care plans for a given year. The placeholders represent the race, a numeric value for weighting, and the year of interest."
        },
        {
            "sample_id": 1499,
            "vt": "SELECT COUNT(DISTINCT T2.PATIENT), careplans.description FROM encounters INNER JOIN careplans AS T2 ON T1.PATIENT = T2.PATIENT WHERE careplans.reasondescription = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of distinct patients associated with specific care plans, filtered by the reason for the care plan. It joins the 'encounters' table with the 'careplans' table to gather relevant patient data and care plan descriptions."
        },
        {
            "sample_id": 1411,
            "vt": "SELECT medications.description FROM medications INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE patients.ssn = '[placeholder-type:string]'",
            "ba": "The virtual table describes the medications prescribed to patients based on their social security number. It retrieves the medication descriptions from the 'medications' table, joining it with the 'patients' table to filter by the specified social security number."
        },
        {
            "sample_id": 1498,
            "vt": "SELECT STRFTIME('%J', medications.stop) - STRFTIME('%J', medications.start) FROM patients INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND medications.description = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the duration of medication for a specific patient by subtracting the start date from the stop date of their medications. It retrieves this information by joining the 'patients' table with the 'medications' table based on the patient ID. The query filters results based on the patient's first name, last name, and the description of the medication."
        },
        {
            "sample_id": 1538,
            "vt": "SELECT SUM(CASE WHEN patients.deathdate IS NULL THEN ROUND((STRFTIME('%J', DATE('[placeholder-type:string]')) - STRFTIME('%J', patients.birthdate)) / [placeholder-type:numeric]) ELSE ROUND((STRFTIME('%J', patients.deathdate) - STRFTIME('%J', patients.birthdate)) / [placeholder-type:numeric]) END) / COUNT(patients.patient) FROM conditions INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE conditions.description = '[placeholder-type:string]' AND patients.gender = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average age of patients with a specific condition, taking into account whether they are alive or deceased. It sums the ages of patients based on their birthdate and either their deathdate or the current date if they are still alive. The results are filtered by the condition description and the gender of the patients."
        },
        {
            "sample_id": 1410,
            "vt": "SELECT AVG(observations.value) FROM observations INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient INNER JOIN conditions AS T3 ON T2.patient = T3.PATIENT WHERE conditions.description = '[placeholder-type:string]' AND observations.description = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average value of observations for patients who have a specific condition. It joins the 'observations' table with the 'patients' table to link each observation to the corresponding patient, and then further joins with the 'conditions' table to filter observations based on a specific condition description. The placeholders represent the condition and observation descriptions that can be specified by the user."
        },
        {
            "sample_id": 1404,
            "vt": "SELECT COUNT(DISTINCT T2.patient) FROM conditions INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE patients.gender = '[placeholder-type:string]' AND conditions.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct patients from the 'conditions' table who have a specific condition and belong to a specified gender. It joins the 'conditions' table with the 'patients' table based on the patient ID, applying filters for both gender and condition description using placeholders."
        },
        {
            "sample_id": 1435,
            "vt": "SELECT COUNT(DISTINCT T1.patient) FROM patients INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE conditions.description = '[placeholder-type:string]' AND patients.marital = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct patients from the 'patients' table who have a specific condition and a specified marital status. It joins the 'patients' table with the 'conditions' table based on the patient ID, filtering results based on the condition description and marital status using placeholders for user input."
        },
        {
            "sample_id": 1537,
            "vt": "SELECT DISTINCT careplans.description FROM careplans INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE patients.ssn = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of unique care plan descriptions associated with patients identified by their social security number. It retrieves data from the 'careplans' table and joins it with the 'patients' table to filter based on the specified social security number."
        },
        {
            "sample_id": 1422,
            "vt": "SELECT observations.description, observations.value, observations.units FROM patients INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND observations.description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the observations made for a specific patient identified by their first and last name. It retrieves the description, value, and units of the observations from the 'observations' table, which is linked to the 'patients' table through the patient ID. The placeholders in the WHERE clause represent the patient's first name, last name, and the specific observation description being queried."
        },
        {
            "sample_id": 1527,
            "vt": "SELECT DISTINCT careplans.description FROM patients INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct care plan descriptions associated with patients from the 'patients' table. It filters the results based on the first and last names of the patients, using placeholders for these string values."
        },
        {
            "sample_id": 1448,
            "vt": "SELECT patients.first, patients.last FROM patients INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT GROUP BY patients.patient ORDER BY COUNT(DISTINCT T2.DESCRIPTION) > [placeholder-type:numeric]",
            "ba": "The virtual table lists the first and last names of patients from the 'patients' table who have a certain number of distinct allergies. The query joins the 'patients' table with the 'allergies' table based on the patient ID, groups the results by patient, and orders them based on the count of distinct allergy descriptions, using a placeholder for the numeric threshold."
        },
        {
            "sample_id": 1491,
            "vt": "SELECT patients.first, patients.last FROM procedures INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE procedures.description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of patients who have undergone a specific procedure. It retrieves data from the 'patients' table and joins it with the 'procedures' table based on the patient ID. The placeholder in the WHERE clause represents the description of the procedure being queried."
        },
        {
            "sample_id": 1516,
            "vt": "SELECT COUNT(DISTINCT T1.patient) FROM patients INNER JOIN conditions AS T2 WHERE conditions.description = '[placeholder-type:string]' AND patients.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct patients from the 'patients' table who have a specific condition and match a specified gender. It joins the 'patients' table with the 'conditions' table based on the patient ID, filtering for a particular condition description and gender using placeholders."
        },
        {
            "sample_id": 1426,
            "vt": "SELECT DISTINCT procedures.description, medications.description FROM procedures INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT INNER JOIN medications AS T3 ON T2.patient = T3.PATIENT WHERE conditions.description = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of procedure descriptions and medication descriptions for patients who have a specific condition. It combines data from the 'procedures' and 'medications' tables, linking them through the 'conditions' table to ensure that only relevant records for the specified condition are included."
        },
        {
            "sample_id": 1478,
            "vt": "SELECT DISTINCT observations.description, observations.value, observations.units FROM patients INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE observations.description = '[placeholder-type:string]' GROUP BY observations.value ORDER BY COUNT(observations.value) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of observation descriptions, their corresponding values, and units from the 'observations' table. It filters the results based on a specific observation description and groups the results by the observation value. The output is ordered by the count of each value, allowing for a limit on the number of results returned."
        },
        {
            "sample_id": 1388,
            "vt": "SELECT COUNT(conditions.patient) FROM conditions WHERE conditions.description = '[placeholder-type:string]' AND STRFTIME('%Y', conditions.start) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of patients from the 'conditions' table who have a specific condition description and whose condition started in a specific year. The placeholders represent the condition name and the year of the condition's start date."
        },
        {
            "sample_id": 1392,
            "vt": "SELECT observations.patient FROM observations WHERE observations.description = '[placeholder-type:string]' AND observations.units = '[placeholder-type:string]' ORDER BY observations.value LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the patients from the 'observations' table who have a specific observation description and unit. The placeholders in the WHERE clause represent the observation description and unit, while the LIMIT clause restricts the number of results returned."
        },
        {
            "sample_id": 1482,
            "vt": "SELECT COUNT(DISTINCT CASE WHEN T2.gender = 'M' THEN T2.patient END), COUNT(DISTINCT CASE WHEN T2.gender = 'F' THEN T2.patient END) FROM conditions INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE conditions.description = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of distinct male and female patients from the 'patients' table who have a specific condition described in the 'conditions' table. The query uses a conditional count to differentiate between male and female patients based on their gender, while joining the 'conditions' table with the 'patients' table to filter by the specified condition description."
        },
        {
            "sample_id": 1436,
            "vt": "SELECT DISTINCT patients.address FROM patients INNER JOIN claims AS T2 ON T1.patient = T2.PATIENT WHERE claims.billableperiod LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct addresses of patients from the 'patients' table who have claims with a specific billable period. The placeholder in the WHERE clause represents the billable period that is being queried."
        },
        {
            "sample_id": 1424,
            "vt": "SELECT COUNT(immunizations.code) FROM patients INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND immunizations.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of immunizations for a specific patient identified by their first and last name. It joins the 'patients' table with the 'immunizations' table to filter the records based on the patient's name and the description of the immunization."
        },
        {
            "sample_id": 1526,
            "vt": "SELECT DISTINCT careplans.start FROM patients INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of distinct start dates for care plans associated with patients identified by their first and last names. It retrieves this information by joining the 'patients' table with the 'careplans' table based on the patient ID, ensuring that only care plans related to the specified patients are included."
        },
        {
            "sample_id": 1472,
            "vt": "SELECT medications.reasondescription, medications.description, STRFTIME('%J', medications.stop) - STRFTIME('%J', medications.start), CASE WHEN patients.deathdate IS NULL THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM patients INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE medications.encounter = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about medications prescribed to patients, including the reason for the medication, a description of the medication, and the duration of the medication based on its start and stop dates. It also checks if the patient is alive or deceased, using a placeholder to indicate the patient's status. The data is filtered based on a specific medical encounter."
        },
        {
            "sample_id": 1533,
            "vt": "SELECT COUNT(DISTINCT T2.patient) FROM conditions INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient INNER JOIN allergies AS T3 ON T2.patient = T3.PATIENT WHERE conditions.description = '[placeholder-type:string]' AND allergies.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct patients who have specific conditions and allergies. It joins the 'conditions' table with the 'patients' table to filter patients based on their unique identifiers, and then further joins with the 'allergies' table to ensure that the patients also have specific allergies. The placeholders in the WHERE clause represent the specific condition and allergy descriptions that are being queried."
        },
        {
            "sample_id": 1371,
            "vt": "SELECT AVG(observations.value), observations.units FROM patients INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND observations.description = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average observation value for a specific patient identified by their first and last name, along with the units of that observation. It joins the 'patients' table with the 'observations' table to retrieve the necessary data, filtering based on the patient's name and the description of the observation."
        },
        {
            "sample_id": 1480,
            "vt": "SELECT careplans.description FROM patients INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND STRFTIME('%Y', careplans.start) = '[placeholder-type:string]'",
            "ba": "The virtual table describes the care plans associated with a specific patient identified by their first and last name, along with the year when the care plan started. The query retrieves the description of the care plans from the 'careplans' table, joining it with the 'patients' table to filter based on the patient's name and the year of the care plan's start date."
        },
        {
            "sample_id": 1362,
            "vt": "SELECT COUNT(observations.description) FROM patients INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND observations.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of specific observations recorded for a patient identified by their first and last name. It joins the 'patients' table with the 'observations' table to filter the observations based on the patient's name and the specific observation description provided."
        },
        {
            "sample_id": 1484,
            "vt": "SELECT DISTINCT procedures.description, medications.description FROM encounters INNER JOIN procedures AS T2 ON T1.PATIENT = T2.PATIENT INNER JOIN medications AS T3 ON T1.PATIENT = T3.PATIENT WHERE encounters.reasondescription = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of procedure descriptions and medication descriptions for patients based on a specific reason for the encounter. The query joins the encounters table with the procedures and medications tables to retrieve relevant information about the patient's care."
        },
        {
            "sample_id": 1449,
            "vt": "SELECT COUNT(DISTINCT T2.patient) FROM allergies INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient INNER JOIN immunizations AS T3 ON T2.patient = T3.PATIENT WHERE allergies.description = '[placeholder-type:string]' AND immunizations.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of patients who have a specific allergy and have also received a specific immunization. It joins the 'allergies' table with the 'patients' table to filter patients based on their allergy descriptions, and then further joins with the 'immunizations' table to ensure that these patients have received a particular immunization."
        },
        {
            "sample_id": 1494,
            "vt": "SELECT allergies.start, allergies.stop, allergies.description FROM patients INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]'",
            "ba": "The virtual table describes the start and stop dates along with the description of allergies for patients identified by their first and last names. The placeholders in the WHERE clause represent the first and last names of the patients."
        },
        {
            "sample_id": 1515,
            "vt": "SELECT COUNT(DISTINCT T2.patient) FROM careplans INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE patients.race = '[placeholder-type:string]' AND STRFTIME('%Y', careplans.stop) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct patients from the 'careplans' table who belong to a specific race and whose care plan has a stop date in a specified year. The query joins the 'careplans' table with the 'patients' table to filter based on the race and the year of the care plan's stop date."
        },
        {
            "sample_id": 1401,
            "vt": "SELECT DISTINCT conditions.patient FROM conditions INNER JOIN all_prevalences AS T2 ON LOWER(T2.ITEM) = LOWER(T1.DESCRIPTION) WHERE all_prevalences.\"prevalence percentage\" = CAST([placeholder-type:numeric] AS FLOAT)",
            "ba": "The virtual table identifies distinct patients who have conditions that match prevalent diseases based on a specified prevalence percentage. It joins the 'conditions' table with the 'all_prevalences' table to filter patients whose conditions correspond to diseases with a specific prevalence percentage."
        },
        {
            "sample_id": 1395,
            "vt": "SELECT COUNT(DISTINCT T1.patient) FROM patients INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE conditions.description = '[placeholder-type:string]' AND STRFTIME('%Y', patients.birthdate) LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of patients from the 'patients' table who have a specific condition and were born in a certain year. The query joins the 'patients' table with the 'conditions' table based on the patient ID, filtering for a specific condition description and a birth year using placeholders."
        },
        {
            "sample_id": 1361,
            "vt": "SELECT observations.value, observations.units FROM patients INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND observations.description = '[placeholder-type:string]' ORDER BY observations.value LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the observation values and their corresponding units for a specific patient identified by their first and last names. The query joins the 'patients' table with the 'observations' table to filter observations based on the patient's name and the specific observation description. The results are ordered by the observation value and limited to a specified number of entries."
        },
        {
            "sample_id": 1403,
            "vt": "SELECT COUNT(DISTINCT T1.patient) FROM immunizations INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE immunizations.description = '[placeholder-type:string]' AND conditions.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of patients who have received a specific immunization and also have a specific condition. It joins the 'immunizations' table with the 'conditions' table based on the patient ID, filtering for the specified immunization and condition descriptions."
        },
        {
            "sample_id": 1418,
            "vt": "SELECT CAST(SUM(CASE WHEN patients.gender = '[placeholder-type:string]' AND patients.race = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(patients.gender) FROM conditions INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE conditions.description = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted sum of occurrences of a specific condition based on the gender and race of patients. It uses a conditional aggregation to sum occurrences for patients matching the specified gender and race, while also considering the total count of patients to derive a prevalence rate. The placeholders represent the gender, race, and a numeric multiplier for the calculation."
        },
        {
            "sample_id": 1382,
            "vt": "SELECT encounters.description FROM patients INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT WHERE patients.prefix = '[placeholder-type:string]' AND patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND encounters.date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the descriptions of encounters for patients filtered by their prefix, first name, last name, and the date of the encounter. The placeholders represent the specific values for the patient's prefix, first name, last name, and the encounter date."
        },
        {
            "sample_id": 1389,
            "vt": "SELECT COUNT(allergies.patient) FROM allergies WHERE allergies.description = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of patients who have a specific allergy description from the 'allergies' table. The placeholder in the WHERE clause represents the allergy description being queried."
        },
        {
            "sample_id": 1485,
            "vt": "SELECT SUM(observations.value) / COUNT(observations.patient) FROM observations INNER JOIN (SELECT DISTINCT PATIENT FROM observations WHERE DESCRIPTION = 'Total Cholesterol' AND VALUE > 200) AS T2 ON T1.PATIENT = T2.PATIENT WHERE observations.description = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average value of a specific observation from the 'observations' table, filtered by patients who have a total cholesterol level greater than 200. It uses a subquery to first identify distinct patients with high cholesterol and then joins this with the main observations to compute the average for the specified observation type."
        },
        {
            "sample_id": 1465,
            "vt": "SELECT COUNT(DISTINCT T1.patient) FROM patients INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE immunizations.description = '[placeholder-type:string]' AND immunizations.date BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND patients.race = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of patients who have received a specific immunization. It filters the results based on the description of the immunization, the date range during which the immunization occurred, and the race of the patients."
        },
        {
            "sample_id": 1453,
            "vt": "SELECT DISTINCT patients.first, patients.last FROM patients INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE conditions.description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct first and last names of patients from the 'patients' table who have a specific condition listed in the 'conditions' table. The placeholder in the WHERE clause represents the condition's description."
        },
        {
            "sample_id": 1376,
            "vt": "SELECT DISTINCT all_prevalences.\"prevalence percentage\" FROM all_prevalences INNER JOIN conditions AS T2 ON LOWER(T1.ITEM) = LOWER(T2.DESCRIPTION) WHERE conditions.code = '[placeholder-type:string]'",
            "ba": "The virtual table provides the distinct prevalence percentages of diseases from the 'all_prevalences' table that match specific conditions. It uses an inner join to connect the 'all_prevalences' and 'conditions' tables based on the disease item and condition description, ensuring that the comparison is case-insensitive. The placeholder in the WHERE clause represents the specific condition code being queried."
        },
        {
            "sample_id": 1525,
            "vt": "SELECT COUNT(DISTINCT T1.patient) FROM patients INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE immunizations.description = '[placeholder-type:string]' AND patients.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct patients who have received a specific immunization and belong to a certain gender. It combines data from the 'patients' table and the 'immunizations' table, filtering based on the immunization description and the patient's gender."
        },
        {
            "sample_id": 1479,
            "vt": "SELECT COUNT(DISTINCT T2.PATIENT) FROM encounters INNER JOIN immunizations AS T2 ON T1.PATIENT = T2.PATIENT WHERE encounters.reasondescription = '[placeholder-type:string]' AND encounters.date = immunizations.date",
            "ba": "The virtual table counts the distinct number of patients who have received immunizations on the same date as their encounters, filtered by a specific reason description for the encounters."
        },
        {
            "sample_id": 1451,
            "vt": "SELECT patients.gender FROM patients INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE allergies.description = '[placeholder-type:string]' GROUP BY patients.gender ORDER BY COUNT(patients.gender) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the gender distribution of patients who have a specific allergy description. It retrieves the gender of patients from the 'patients' table and joins it with the 'allergies' table to filter based on the allergy description. The results are grouped by gender and ordered by the count of patients in each gender category, with a limit on the number of results returned."
        },
        {
            "sample_id": 1486,
            "vt": "SELECT SUM(CASE WHEN ROUND((STRFTIME('%J', observations.date) - STRFTIME('%J', patients.birthdate)) / [placeholder-type:numeric]) BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] THEN observations.value ELSE [placeholder-type:numeric] END) / COUNT(CASE WHEN ROUND((STRFTIME('%J', observations.date) - STRFTIME('%J', patients.birthdate)) / [placeholder-type:numeric]) BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] THEN observations.patient END) - SUM(CASE WHEN ROUND((STRFTIME('%J', observations.date) - STRFTIME('%J', patients.birthdate)) / [placeholder-type:numeric]) BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] THEN observations.value ELSE [placeholder-type:numeric] END) / COUNT(CASE WHEN ROUND((STRFTIME('%J', observations.date) - STRFTIME('%J', patients.birthdate)) / [placeholder-type:numeric]) BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] THEN observations.patient END) FROM patients INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE observations.description = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average observation value for patients within a specific age range, based on their birthdate and the date of the observation. It uses a conditional sum and count to filter observations that fall within the specified age range, represented by numeric placeholders. The final result is adjusted by subtracting the average observation value for the same age range."
        },
        {
            "sample_id": 1475,
            "vt": "SELECT COUNT(DISTINCT T2.DESCRIPTION) FROM patients INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct descriptions of medications prescribed to a specific patient identified by their first and last names. It joins the 'patients' table with the 'medications' table based on the patient ID, ensuring that only the medications related to the specified patient are considered."
        },
        {
            "sample_id": 1481,
            "vt": "SELECT DISTINCT careplans.description, procedures.description, medications.description, patients.first, patients.last FROM patients INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT INNER JOIN careplans AS T3 ON T1.patient = T3.PATIENT INNER JOIN procedures AS T4 ON T1.patient = T4.PATIENT INNER JOIN medications AS T5 ON T1.patient = T5.PATIENT WHERE encounters.id = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of care plan descriptions, procedure descriptions, and medication descriptions for patients, along with their first and last names. It combines data from multiple tables including 'patients', 'encounters', 'careplans', 'procedures', and 'medications'. The query filters results based on a specific encounter ID, which is represented by a placeholder."
        },
        {
            "sample_id": 1406,
            "vt": "SELECT STRFTIME('%Y', patients.deathdate) - STRFTIME('%Y', patients.birthdate) FROM conditions INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND conditions.description = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the age of a patient by subtracting the birth year from the death year. It retrieves this information from the 'patients' table and joins it with the 'conditions' table to filter based on the patient's first name, last name, and the description of their condition. The placeholders represent the specific first name, last name, and condition description of the patient."
        },
        {
            "sample_id": 1367,
            "vt": "SELECT medications.description FROM patients INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND medications.reasondescription = '[placeholder-type:string]'",
            "ba": "The virtual table describes the medication descriptions for patients based on their first and last names, as well as a specific reason for taking the medication. The placeholders in the WHERE clause represent the patient's first name, last name, and the reason for the medication."
        },
        {
            "sample_id": 1504,
            "vt": "SELECT patients.first, patients.last FROM careplans INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE patients.gender = '[placeholder-type:string]' ORDER BY careplans.start LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of patients from the 'patients' table who have care plans, filtered by a specific gender. The results are ordered by the start date of the care plans and limited to a specified number of entries."
        },
        {
            "sample_id": 1437,
            "vt": "SELECT DISTINCT patients.last FROM patients INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE allergies.description = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of unique last names of patients from the 'patients' table who have a specific allergy described in the 'allergies' table. The query uses an INNER JOIN to connect the 'patients' and 'allergies' tables based on the patient ID, filtering the results to only include those patients with the specified allergy description."
        },
        {
            "sample_id": 1372,
            "vt": "SELECT CAST(SUM(CASE WHEN patients.marital = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(DISTINCT T1.patient) FROM patients INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE conditions.description = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the prevalence rate of a specific condition among patients based on their marital status. It sums the occurrences of patients with a specified marital status and divides it by the total number of distinct patients who have that condition, then multiplies by a specified factor to adjust the prevalence rate."
        },
        {
            "sample_id": 1365,
            "vt": "SELECT DISTINCT medications.description FROM patients INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct medication descriptions prescribed to patients based on their first and last names. It retrieves data from the 'patients' table and joins it with the 'medications' table to filter the results according to the specified patient's name."
        },
        {
            "sample_id": 1444,
            "vt": "SELECT COUNT(DISTINCT T2.DESCRIPTION) FROM patients INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE patients.ethnicity = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct descriptions of allergies for patients belonging to a specific ethnicity. It joins the 'patients' table with the 'allergies' table based on the patient ID, filtering the results by the specified ethnicity."
        },
        {
            "sample_id": 1443,
            "vt": "SELECT DISTINCT encounters.description FROM patients INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT WHERE patients.birthplace = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct descriptions of encounters from the 'encounters' table for patients who were born in a specific birthplace. The placeholder in the WHERE clause represents the birthplace of the patients."
        },
        {
            "sample_id": 1532,
            "vt": "SELECT allergies.description FROM allergies INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' AND patients.ethnicity = '[placeholder-type:string]'",
            "ba": "The virtual table describes the allergies of patients filtered by their first name, last name, and ethnicity. The placeholders in the WHERE clause represent the specific values for the patient's first name, last name, and ethnicity."
        },
        {
            "sample_id": 1381,
            "vt": "SELECT patients.first, patients.last FROM patients INNER JOIN claims AS T2 ON T1.patient = T2.PATIENT WHERE claims.billableperiod = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of patients from the 'patients' table who have claims with a specific billable period. The placeholder in the WHERE clause represents the billable period for which the claims are being queried."
        },
        {
            "sample_id": 1497,
            "vt": "SELECT immunizations.date FROM patients INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE immunizations.description = '[placeholder-type:string]' AND patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]' ORDER BY immunizations.date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the dates of immunizations for patients based on their first and last names, filtering by a specific immunization description. The results are ordered by the date of immunization and limited to a specified number of entries."
        },
        {
            "sample_id": 1429,
            "vt": "SELECT all_prevalences.\"prevalence rate\" FROM conditions INNER JOIN all_prevalences AS T2 ON LOWER(T1.DESCRIPTION) = LOWER(T2.ITEM) WHERE conditions.start = '[placeholder-type:string]'",
            "ba": "The virtual table provides the prevalence rate of diseases from the 'all_prevalences' table based on specific conditions recorded in the 'conditions' table. It uses an inner join to match the disease descriptions in both tables, ensuring that the comparison is case-insensitive. The query filters the results based on a specific start date for the conditions, represented by a placeholder."
        },
        {
            "sample_id": 1374,
            "vt": "SELECT COUNT(careplans.patient) FROM patients INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE patients.prefix = '[placeholder-type:string]' AND patients.first = '[placeholder-type:string]' AND patients.last = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of patients who have care plans associated with them. It retrieves this information by joining the 'patients' table with the 'careplans' table based on the patient ID. The query filters the results to include only those patients whose prefix, first name, and last name match the specified placeholders."
        },
        {
            "sample_id": 1368,
            "vt": "SELECT DISTINCT patients.first, patients.last FROM patients INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE medications.description LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct first and last names of patients from the 'patients' table who have been prescribed a specific medication. The query joins the 'patients' table with the 'medications' table to filter patients based on the description of the medication, using a placeholder for the medication description."
        },
        {
            "sample_id": 1390,
            "vt": "SELECT conditions.patient FROM conditions WHERE conditions.start = (SELECT MAX(conditions.start) FROM conditions WHERE DESCRIPTION = 'Hypertension')",
            "ba": "The virtual table identifies patients who have a condition of 'Hypertension' by selecting their unique patient identifiers from the 'conditions' table. It filters the results to only include those patients whose condition started at the most recent date recorded for 'Hypertension'."
        }
    ],
    "cs_semester": [
        {
            "sample_id": 869,
            "vt": "SELECT prof.first_name, prof.last_name FROM prof INNER JOIN RA AS T2 ON T1.prof_id = T2.prof_id INNER JOIN student AS T3 ON T2.student_id = T3.student_id WHERE student.f_name = '[placeholder-type:string]' AND student.l_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of professors who advise a specific student identified by their first and last names. It combines data from the 'prof', 'ra', and 'student' tables to find the relevant professors based on the student's name."
        },
        {
            "sample_id": 914,
            "vt": "SELECT student.f_name, student.l_name, ra.capability, student.gpa FROM prof INNER JOIN RA AS T2 ON T1.prof_id = T2.prof_id INNER JOIN student AS T3 ON T2.student_id = T3.student_id WHERE prof.first_name = '[placeholder-type:string]' AND prof.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of students, their research capability, and GPA from the 'student' table, filtered by professors' names from the 'prof' table. The placeholders in the WHERE clause represent the first and last names of the professor."
        },
        {
            "sample_id": 925,
            "vt": "SELECT course.name FROM course WHERE course.diff = (SELECT MAX(course.diff) FROM course)",
            "ba": "The virtual table describes the name of the most difficult course from the 'course' table. The query uses a subquery to find the maximum difficulty level among all courses and filters the results to return the name of the course that matches this maximum difficulty."
        },
        {
            "sample_id": 880,
            "vt": "SELECT CASE registration.grade WHEN '[placeholder-type:string]' THEN [placeholder-type:numeric] WHEN '[placeholder-type:string]' THEN [placeholder-type:numeric] WHEN '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END FROM registration WHERE registration.student_id IN (SELECT registration.student_id FROM student WHERE f_name = 'Rik' AND l_name = 'Unsworth' AND course_id IN (SELECT course_id FROM course WHERE name = 'Computer Network'))",
            "ba": "The virtual table provides a way to evaluate the grades of a specific student named Rik Unsworth in the course 'Computer Network'. It uses a CASE statement to convert the letter grades into their corresponding numeric values, allowing for a numerical representation of the student's performance. The query filters the registration records to include only those associated with the specified student and course."
        },
        {
            "sample_id": 945,
            "vt": "SELECT student.f_name, student.l_name, student.phone_number FROM student WHERE student.gpa > [placeholder-type:numeric] AND student.intelligence < [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names along with the phone numbers of students from the 'student' table who have a GPA greater than a specified value and intelligence less than another specified value. The placeholders in the WHERE clause represent the thresholds for GPA and intelligence."
        },
        {
            "sample_id": 955,
            "vt": "SELECT AVG(registration.sat) - (SELECT AVG(registration.sat) FROM RA AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id WHERE T1.salary = 'free') FROM ra INNER JOIN registration AS T2 ON T1.student_id = T2.student_id WHERE ra.salary = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average student satisfaction (sat) from the registration table, subtracting the average satisfaction of students who are unpaid research assistants (RA). It joins the RA table with the registration table to filter based on the salary of the students, specifically focusing on those with a specified salary type. The placeholder in the WHERE clause represents the salary status of the students being analyzed."
        },
        {
            "sample_id": 896,
            "vt": "SELECT course.name FROM registration INNER JOIN course AS T2 ON T1.course_id = T2.course_id WHERE registration.grade = '[placeholder-type:string]' AND course.diff = [placeholder-type:numeric] GROUP BY course.name ORDER BY COUNT(registration.student_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of courses from the 'course' table that students have received a specific grade in, filtered by the difficulty level of the course. The query groups the results by course name and orders them based on the number of students enrolled in each course, limiting the output to a specified number of courses."
        },
        {
            "sample_id": 948,
            "vt": "SELECT CAST(SUM(ra.capability) AS FLOAT) / COUNT(ra.student_id) FROM ra INNER JOIN student AS T2 ON T1.student_id = T2.student_id WHERE student.gpa < [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average research capability of students who have a GPA below a specified threshold. It does this by summing the research capabilities of the students from the 'ra' table and dividing it by the count of those students, ensuring that only students with a GPA less than the given value are included in the calculation."
        },
        {
            "sample_id": 964,
            "vt": "SELECT student.f_name, student.l_name FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE course.name = '[placeholder-type:string]' AND registration.grade = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of students who are enrolled in a specific course and have received a particular grade. The placeholders in the WHERE clause represent the course name and the grade obtained by the students."
        },
        {
            "sample_id": 957,
            "vt": "SELECT prof.first_name, prof.last_name, prof.email FROM ra INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id WHERE prof.teachingability > (SELECT AVG(prof.teachingability) FROM prof) GROUP BY prof.prof_id HAVING COUNT(ra.student_id) >= [placeholder-type:numeric]",
            "ba": "The virtual table describes the first names, last names, and emails of professors who have a teaching ability greater than the average teaching ability of all professors. It also filters the results to include only those professors who advise a specified number of students, indicating their popularity or workload in research advising."
        },
        {
            "sample_id": 928,
            "vt": "SELECT registration.student_id FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE course.name = '[placeholder-type:string]' AND student.gpa = [placeholder-type:numeric]",
            "ba": "The virtual table describes the student IDs of students who are enrolled in a specific course and have a specific GPA. The placeholders in the WHERE clause represent the course name and the GPA of the students."
        },
        {
            "sample_id": 899,
            "vt": "SELECT DISTINCT course.name FROM registration INNER JOIN course AS T2 ON T1.course_id = T2.course_id WHERE registration.sat = [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct names of courses from the 'course' table that have a specific level of student satisfaction, as indicated by the 'sat' column in the 'registration' table. The query uses an INNER JOIN to connect the 'registration' and 'course' tables based on the course ID, ensuring that only courses with the specified satisfaction level are included."
        },
        {
            "sample_id": 908,
            "vt": "SELECT prof.first_name, prof.last_name FROM prof WHERE prof.graduate_from = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of professors from the 'prof' table who graduated from a specific school. The placeholder in the WHERE clause represents the name of the school from which the professor graduated."
        },
        {
            "sample_id": 937,
            "vt": "SELECT ra.capability FROM student INNER JOIN RA AS T2 ON T1.student_id = T2.student_id WHERE student.f_name = '[placeholder-type:string]' AND student.l_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the research capability of a student by joining the 'student' and 'ra' tables. It filters the results based on the student's first and last name, which are provided as placeholders."
        },
        {
            "sample_id": 929,
            "vt": "SELECT student.l_name FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE course.name = '[placeholder-type:string]' ORDER BY registration.sat LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the last names of students who are enrolled in a specific course from the 'course' table. It joins the 'student' table with the 'registration' table to link students to their respective courses, and it filters the results based on the course name provided as a placeholder. Additionally, it orders the results by student satisfaction with the course and limits the number of results returned based on a numeric placeholder."
        },
        {
            "sample_id": 858,
            "vt": "SELECT prof.first_name, prof.last_name FROM prof INNER JOIN RA AS T2 ON T1.prof_id = T2.prof_id INNER JOIN student AS T3 ON T2.student_id = T3.student_id WHERE student.f_name = '[placeholder-type:string]' AND student.l_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of professors who advise students with a specific first and last name. It retrieves this information by joining the 'prof' table with the 'ra' table, which links professors to their advised students, and then further joins with the 'student' table to filter based on the student's name. The placeholders in the WHERE clause represent the first and last names of the student."
        },
        {
            "sample_id": 865,
            "vt": "SELECT student.f_name, student.l_name FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE registration.grade IS NULL AND course.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of students who have not passed a specific course from the 'registration' table. It joins the 'student' table to get the names and the 'course' table to filter by the course name. The placeholder in the WHERE clause represents the name of the course."
        },
        {
            "sample_id": 930,
            "vt": "SELECT COUNT(ra.student_id) FROM ra INNER JOIN student AS T2 ON T1.student_id = T2.student_id WHERE ra.salary = '[placeholder-type:string]' AND student.gpa > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of research assistants (RAs) from the 'ra' table who have a specific salary status and a GPA above a certain threshold. The query joins the 'ra' table with the 'student' table to filter students based on their GPA, while the salary condition is specified using a placeholder for string values."
        },
        {
            "sample_id": 923,
            "vt": "SELECT course.name, course.credit FROM ra INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id INNER JOIN student AS T3 ON T1.student_id = T3.student_id INNER JOIN registration AS T4 ON T3.student_id = T4.student_id INNER JOIN course AS T5 ON T4.course_id = T5.course_id WHERE prof.gender = '[placeholder-type:string]' ORDER BY prof.teachingability LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names and credits of courses that are associated with students advised by professors of a specific gender. The query joins multiple tables to gather relevant information about courses, professors, and students, filtering based on the gender of the professors and limiting the results based on teaching ability."
        },
        {
            "sample_id": 951,
            "vt": "SELECT student.f_name, student.l_name, ra.capability FROM ra INNER JOIN student AS T2 ON T2.student_id = T1.student_id INNER JOIN registration AS T3 ON T2.student_id = T3.student_id WHERE registration.grade IS NULL OR registration.grade = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of students along with their research capability from the 'ra' table, which indicates their research ability. It joins the 'student' table to get the full names of the students and the 'registration' table to filter students based on their grades. The placeholder in the WHERE clause allows for filtering students who either have not passed a course or have a specific grade."
        },
        {
            "sample_id": 882,
            "vt": "SELECT student.f_name, student.l_name FROM prof INNER JOIN RA AS T2 ON T1.prof_id = T2.prof_id INNER JOIN student AS T3 ON T2.student_id = T3.student_id WHERE prof.first_name = '[placeholder-type:string]' AND student.type = '[placeholder-type:string]' AND prof.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of students who are advised by a specific professor, filtered by the professor's first name, last name, and the type of student. The placeholders in the WHERE clause represent the professor's first name, last name, and the type of student (e.g., TPG, RPG, UG)."
        },
        {
            "sample_id": 916,
            "vt": "SELECT student.f_name, student.l_name FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE registration.grade = '[placeholder-type:string]' ORDER BY course.diff LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of students who have received a specific grade in their courses. It joins the 'student' table with the 'registration' table to link students with their course registrations, and then further joins the 'course' table to access course details such as difficulty. The placeholders represent the grade to filter by and the limit on the number of results returned."
        },
        {
            "sample_id": 872,
            "vt": "SELECT COUNT(student.student_id) FROM student WHERE student.type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students from the 'student' table who belong to a specific type of student, such as taught postgraduate, research postgraduate, or undergraduate. The placeholder in the WHERE clause represents the type of student being queried."
        },
        {
            "sample_id": 885,
            "vt": "SELECT student.phone_number FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE course.name = '[placeholder-type:string]' AND registration.grade = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the phone numbers of students who are enrolled in a specific course and have achieved a particular grade in that course. The query joins the 'student', 'registration', and 'course' tables to filter the results based on the course name and the grade obtained by the students."
        },
        {
            "sample_id": 936,
            "vt": "SELECT course.name FROM course INNER JOIN registration AS T2 ON T1.course_id = T2.course_id WHERE registration.grade = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of courses from the 'course' table that students have registered for, filtered by a specific grade. The placeholder in the WHERE clause represents the grade that students have achieved in those courses."
        },
        {
            "sample_id": 962,
            "vt": "SELECT COUNT(student.student_id) FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE course.name = '[placeholder-type:string]' AND registration.sat = [placeholder-type:numeric] AND student.gpa = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students who are enrolled in a specific course and have a certain level of satisfaction with that course, as well as a specific GPA. It combines data from the 'student', 'registration', and 'course' tables to achieve this."
        },
        {
            "sample_id": 907,
            "vt": "SELECT ra.prof_id, ra.student_id FROM ra WHERE ra.capability = (SELECT MIN(ra.capability) FROM RA)",
            "ba": "The virtual table identifies the professor and student pairs from the 'ra' table where the student's research capability is at its minimum level. This allows for the analysis of which professors are advising students who may need additional support in their research capabilities."
        },
        {
            "sample_id": 888,
            "vt": "SELECT COUNT(course.course_id) FROM course WHERE course.diff = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of courses from the 'course' table that have a specific difficulty level. The placeholder in the WHERE clause represents the difficulty rating of the courses."
        },
        {
            "sample_id": 953,
            "vt": "SELECT prof.first_name, prof.last_name, prof.popularity FROM prof INNER JOIN RA AS T2 ON T1.prof_id = T2.prof_id GROUP BY prof.prof_id ORDER BY COUNT(ra.student_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of professors along with their first names, last names, and popularity ratings. It retrieves this information by joining the 'prof' table with the 'ra' table, which contains information about research assistants. The results are grouped by professor ID to aggregate the number of students each professor advises, and the output is ordered by the count of students in descending order. A placeholder is included to limit the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 902,
            "vt": "SELECT prof.popularity FROM ra INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id GROUP BY ra.prof_id, ra.capability ORDER BY COUNT(ra.student_id), ra.capability LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the popularity of professors who advise students in research assistant roles. It joins the 'ra' table, which contains information about research assistants and their capabilities, with the 'prof' table to access professor details. The results are grouped by professor ID and student capability, ordered by the number of students advised and the capability level, and limited to a specified number of results."
        },
        {
            "sample_id": 959,
            "vt": "SELECT student.f_name, student.l_name FROM student WHERE student.gpa = (SELECT MAX(student.gpa) FROM student)",
            "ba": "The virtual table describes the first and last names of students from the 'student' table who have the highest GPA among all students. The query uses a subquery to find the maximum GPA and filters the results accordingly."
        },
        {
            "sample_id": 938,
            "vt": "SELECT COUNT(student.student_id) FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE course.credit = [placeholder-type:numeric] AND student.gpa = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students who are enrolled in courses with a specific credit value and have a specific GPA. It combines data from the 'student', 'registration', and 'course' tables to achieve this."
        },
        {
            "sample_id": 873,
            "vt": "SELECT student.f_name, student.l_name FROM student WHERE student.gpa = (SELECT MAX(student.gpa) FROM student)",
            "ba": "The virtual table describes the first and last names of students from the 'student' table who have the highest GPA among all students. The query uses a subquery to find the maximum GPA and filters the results accordingly."
        },
        {
            "sample_id": 950,
            "vt": "SELECT AVG(student.gpa) FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE course.diff IN ([placeholder-type:numeric], [placeholder-type:numeric]) GROUP BY course.diff",
            "ba": "The virtual table calculates the average GPA of students from the 'student' table who are enrolled in courses with specific difficulty levels. It joins the 'student' table with the 'registration' table to link students to their courses, and then further joins with the 'course' table to filter based on the difficulty of the courses. The placeholders represent the difficulty levels of the courses being queried."
        },
        {
            "sample_id": 904,
            "vt": "SELECT COUNT(registration.student_id) FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id WHERE registration.grade IS NULL AND student.gpa BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students who have not passed any courses, as indicated by a NULL grade in the 'registration' table. It filters students based on their GPA, ensuring that only those within a specified GPA range are included in the count. The placeholders represent the lower and upper bounds of the GPA range."
        },
        {
            "sample_id": 926,
            "vt": "SELECT COUNT(student.student_id) FROM student WHERE student.gpa BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND student.type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students from the 'student' table whose GPA falls within a specified range and matches a specific type of student. The placeholders represent the GPA range and the type of student (e.g., TPG, RPG, UG)."
        },
        {
            "sample_id": 933,
            "vt": "SELECT COUNT(registration.student_id) FROM registration INNER JOIN student AS T2 ON T1.student_id = T2.student_id WHERE registration.grade = '[placeholder-type:string]' AND student.intelligence = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students who have received a specific grade in their courses, while also filtering based on the intelligence level of the students. It utilizes an inner join between the 'registration' table and the 'student' table to correlate student IDs and apply the necessary conditions."
        },
        {
            "sample_id": 965,
            "vt": "SELECT course.name FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE registration.sat = [placeholder-type:numeric] AND student.type = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of courses that students are enrolled in, filtered by their satisfaction rating and type. The placeholders represent the satisfaction score and the type of student (e.g., TPG, RPG, UG)."
        },
        {
            "sample_id": 935,
            "vt": "SELECT COUNT(ra.student_id) FROM ra INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id WHERE ra.capability = [placeholder-type:numeric] ORDER BY prof.popularity LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of research assistants (RAs) who have a specific capability level, by joining the 'ra' table with the 'prof' table to filter based on the professor's ID. The results are ordered by the popularity of the professors, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 922,
            "vt": "SELECT student.f_name, student.l_name, student.email, student.intelligence FROM student WHERE ra.student_id IN (SELECT ra.student_id FROM RA WHERE salary = 'high' AND capability = (SELECT MAX(capability) FROM RA))",
            "ba": "The virtual table describes the first name, last name, email, and intelligence of students from the 'student' table who are research assistants with a high salary and the highest research capability. The subquery filters the students based on their salary and capability, ensuring that only those with the highest capability are selected."
        },
        {
            "sample_id": 913,
            "vt": "SELECT student.f_name, student.l_name, student.email FROM ra INNER JOIN student AS T2 ON T1.student_id = T2.student_id WHERE ra.salary = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names along with the email addresses of students who are research assistants (RAs) with a specific salary status. The query joins the 'ra' table with the 'student' table to retrieve the relevant student information based on their unique student ID. The placeholder in the WHERE clause represents the salary status of the students, which can be categorized as 'med', 'high', 'low', or 'free'."
        },
        {
            "sample_id": 944,
            "vt": "SELECT CAST(SUM(registration.sat) AS FLOAT) / COUNT(registration.course_id) FROM registration WHERE registration.grade = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average student satisfaction from the 'registration' table for courses where students received a specific grade. The placeholder in the WHERE clause represents the grade that is being filtered."
        },
        {
            "sample_id": 862,
            "vt": "SELECT student.f_name, student.l_name FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE course.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of students who are enrolled in a specific course. It retrieves data from the 'student' table and joins it with the 'registration' table to link students with their respective courses. The condition in the WHERE clause filters the results based on the course name provided as a placeholder."
        },
        {
            "sample_id": 877,
            "vt": "SELECT prof.popularity FROM prof INNER JOIN RA AS T2 ON T1.prof_id = T2.prof_id INNER JOIN student AS T3 ON T2.student_id = T3.student_id WHERE student.f_name = '[placeholder-type:string]' AND student.l_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the popularity of professors who advise students with a specific first and last name. It joins the 'prof' table with the 'ra' table to link professors to their advised students, and then further joins with the 'student' table to filter by the student's first and last name."
        },
        {
            "sample_id": 884,
            "vt": "SELECT student.f_name, student.l_name FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE course.name = '[placeholder-type:string]' AND registration.grade IS NULL",
            "ba": "The virtual table describes the first and last names of students who are enrolled in a specific course but have not passed it. It retrieves data from the 'student' table, joining it with the 'registration' table to link students with their course registrations, and further joining with the 'course' table to filter by the course name. The placeholder in the WHERE clause represents the name of the course."
        },
        {
            "sample_id": 903,
            "vt": "SELECT CAST(COUNT(registration.student_id) AS FLOAT) / COUNT(DISTINCT T2.course_id) FROM registration INNER JOIN course AS T2 ON T1.course_id = T2.course_id WHERE course.diff = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of students enrolled in courses based on their difficulty level. It does this by counting the total number of student registrations and dividing it by the number of distinct courses that match the specified difficulty level. The placeholder in the WHERE clause represents the difficulty of the course, which is a numeric value."
        },
        {
            "sample_id": 864,
            "vt": "SELECT course.name FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE student.f_name = '[placeholder-type:string]' AND student.l_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of courses that a specific student is registered in. It retrieves data from the 'student' table, joining it with the 'registration' table to link students with their courses, and then further joining with the 'course' table to get the course names. The placeholders in the WHERE clause represent the first and last names of the student being queried."
        },
        {
            "sample_id": 883,
            "vt": "SELECT COUNT(registration.student_id) FROM course INNER JOIN registration AS T2 ON T1.course_id = T2.course_id WHERE course.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students registered for a specific course from the 'course' table. It joins the 'course' table with the 'registration' table to filter the results based on the course name provided as a placeholder."
        },
        {
            "sample_id": 857,
            "vt": "SELECT student.phone_number FROM student WHERE student.l_name = '[placeholder-type:string]' AND student.f_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the phone number of a student from the 'student' table based on their last name and first name. The placeholders in the WHERE clause represent the specific names of the student being queried."
        },
        {
            "sample_id": 901,
            "vt": "SELECT course.name FROM registration INNER JOIN course AS T2 ON T1.course_id = T2.course_id WHERE registration.grade = '[placeholder-type:string]' AND course.name IN ('[placeholder-type:string]', '[placeholder-type:string]') GROUP BY course.name ORDER BY COUNT(registration.student_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of courses from the 'course' table that students have received a specific grade in, filtered by a list of course names. The query joins the 'registration' table to associate students with their respective courses, groups the results by course name, and orders them based on the number of students enrolled in each course. The placeholders represent the grade, specific course names, and a limit on the number of results returned."
        },
        {
            "sample_id": 918,
            "vt": "SELECT student.f_name, student.l_name FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE course.name = '[placeholder-type:string]' ORDER BY registration.sat LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of students who are enrolled in a specific course. It retrieves data from the 'student' table and joins it with the 'registration' table to link students with their respective courses. Additionally, it joins the 'course' table to filter results based on the course name. The results are ordered by student satisfaction and limited to a specified number of entries."
        },
        {
            "sample_id": 911,
            "vt": "SELECT course.name, course.credit FROM course WHERE course.diff = (SELECT MIN(course.diff) FROM course)",
            "ba": "The virtual table describes the name and credit of the course from the 'course' table that has the lowest difficulty level. The placeholder in the WHERE clause represents the condition to filter for the minimum difficulty of courses."
        },
        {
            "sample_id": 874,
            "vt": "SELECT COUNT(registration.student_id) FROM registration INNER JOIN course AS T2 ON T1.course_id = T2.course_id WHERE registration.grade = '[placeholder-type:string]' AND course.credit = '[placeholder-type:string]' AND course.diff = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students who have received a specific grade in courses that meet certain criteria. It joins the 'registration' table with the 'course' table to filter based on the course's credit and difficulty level. The placeholders represent the grade, credit, and difficulty values that can be specified by the user."
        },
        {
            "sample_id": 875,
            "vt": "SELECT COUNT(registration.student_id) FROM registration INNER JOIN course AS T2 ON T1.course_id = T2.course_id WHERE course.diff = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of students registered for courses based on their difficulty level from the 'registration' and 'course' tables. The placeholder in the WHERE clause represents the difficulty level of the course, allowing users to specify which difficulty they are interested in."
        },
        {
            "sample_id": 906,
            "vt": "SELECT AVG(student.gpa), student.f_name, student.l_name FROM ra INNER JOIN student AS T2 ON T1.student_id = T2.student_id WHERE ra.salary = '[placeholder-type:string]' AND ra.capability = [placeholder-type:numeric] GROUP BY student.student_id",
            "ba": "The virtual table calculates the average GPA of students who are research assistants (RAs) with specific salary and capability criteria. It retrieves the first and last names of these students from the 'student' table, joining it with the 'ra' table based on the student ID. The results are grouped by each student's unique ID to ensure that the average GPA is calculated correctly for each individual student."
        },
        {
            "sample_id": 886,
            "vt": "SELECT CAST(SUM(CASE WHEN student.type = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(ra.student_id) FROM ra INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id INNER JOIN student AS T3 ON T1.student_id = T3.student_id WHERE prof.first_name = '[placeholder-type:string]' AND prof.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of research capabilities for students of a specific type advised by a particular professor. It sums the capabilities of students based on their type, applies a weight, and divides by the count of students advised by that professor. The placeholders represent the type of student, the weight factor, and the professor's first and last names."
        },
        {
            "sample_id": 890,
            "vt": "SELECT course.name FROM course WHERE course.credit = (SELECT MAX(course.credit) FROM course) AND course.diff = (SELECT MAX(course.diff) FROM course)",
            "ba": "The virtual table retrieves the name of the course from the 'course' table that has the highest credit value and the highest difficulty level. The placeholders in the query represent the criteria for filtering the courses based on their credit and difficulty attributes."
        },
        {
            "sample_id": 919,
            "vt": "SELECT CAST(SUM(course.credit * CASE registration.grade WHEN '[placeholder-type:string]' THEN [placeholder-type:numeric] WHEN '[placeholder-type:string]' THEN [placeholder-type:numeric] WHEN '[placeholder-type:string]' THEN [placeholder-type:numeric] WHEN '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / COUNT(course.credit) FROM registration INNER JOIN student AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T1.course_id = T3.course_id WHERE student.f_name = '[placeholder-type:string]' AND student.l_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the GPA of a specific student by summing the product of course credits and corresponding grade points, then dividing by the total number of credits. The query joins the 'registration', 'student', and 'course' tables to access the necessary data, filtering by the student's first and last name."
        },
        {
            "sample_id": 898,
            "vt": "SELECT COUNT(ra.student_id) FROM ra INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id WHERE prof.first_name = '[placeholder-type:string]' AND prof.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of research assistants (RAs) advised by a specific professor based on their first and last names. It joins the 'ra' table with the 'prof' table to filter the results according to the professor's name."
        },
        {
            "sample_id": 915,
            "vt": "SELECT student.f_name, student.l_name, registration.grade FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE course.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of students along with their grades from the 'registration' table for a specific course. The query joins the 'student' table to get student names and the 'registration' table to get grades, filtering by the course name using a placeholder."
        },
        {
            "sample_id": 946,
            "vt": "SELECT student.f_name, student.l_name FROM student INNER JOIN RA AS T2 ON T1.student_id = T2.student_id WHERE ra.capability > (SELECT AVG(ra.capability) FROM RA)",
            "ba": "The virtual table describes the first and last names of students from the 'student' table who have a research capability above the average capability of all students advised by professors. The query uses an inner join to connect the 'student' and 'ra' tables based on the student ID, and it filters the results based on a subquery that calculates the average research capability."
        },
        {
            "sample_id": 947,
            "vt": "SELECT student.f_name, student.l_name, course.name FROM student INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE student.intelligence = [placeholder-type:numeric] AND student.gpa < [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of students along with the names of the courses they are enrolled in. It filters the results based on the intelligence level of the students and their GPA, using placeholders for numeric values to allow for flexible querying."
        },
        {
            "sample_id": 924,
            "vt": "SELECT COUNT(prof.prof_id) FROM prof WHERE prof.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of professors from the 'prof' table based on their gender. The placeholder in the WHERE clause represents the gender of the professors being queried."
        },
        {
            "sample_id": 949,
            "vt": "SELECT prof.first_name, prof.last_name FROM prof INNER JOIN RA AS T2 ON T1.prof_id = T2.prof_id INNER JOIN student AS T3 ON T2.student_id = T3.student_id WHERE student.intelligence = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the first and last names of professors from the 'prof' table who advise students with a specific level of intelligence. The query uses inner joins to connect the 'prof', 'ra', and 'student' tables based on their respective IDs, ensuring that only professors advising students with the specified intelligence level are selected."
        },
        {
            "sample_id": 961,
            "vt": "SELECT ra.salary FROM ra INNER JOIN student AS T2 ON T1.student_id = T2.student_id WHERE student.email = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the salary of research assistants from the 'ra' table who are associated with a specific student identified by their email address. The query joins the 'ra' table with the 'student' table to filter the results based on the student's email."
        },
        {
            "sample_id": 859,
            "vt": "SELECT COUNT(ra.student_id) FROM ra INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id WHERE prof.first_name = '[placeholder-type:string]' AND prof.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of research assistants (RAs) advised by a specific professor identified by their first and last name. It joins the 'ra' table with the 'prof' table to filter the results based on the professor's name."
        },
        {
            "sample_id": 894,
            "vt": "SELECT COUNT(registration.student_id) FROM course INNER JOIN registration AS T2 ON T1.course_id = T2.course_id WHERE registration.grade = '[placeholder-type:string]' AND course.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of students who received a specific grade in a particular course. It joins the 'course' and 'registration' tables to filter the results based on the course name and the grade achieved by the students."
        }
    ],
    "movie_3": [
        {
            "sample_id": 9301,
            "vt": "SELECT COUNT(rental.rental_id) FROM rental GROUP BY rental.customer_id ORDER BY COUNT(rental.rental_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of rentals grouped by each customer from the 'rental' table. It orders the results based on the number of rentals in descending order and limits the output to a specified number of customers."
        },
        {
            "sample_id": 9099,
            "vt": "SELECT film.title FROM film WHERE film.release_year = [placeholder-type:numeric] AND film.rental_rate = [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films from the 'film' table that were released in a specific year and have a specific rental rate. The placeholders in the WHERE clause represent the year of release and the rental rate of the films."
        },
        {
            "sample_id": 9141,
            "vt": "SELECT address.phone FROM address WHERE address.address_id = '[placeholder-type:string]'",
            "ba": "The virtual table provides the phone number associated with a specific address from the 'address' table. The placeholder in the WHERE clause represents the unique identifier for the address."
        },
        {
            "sample_id": 9387,
            "vt": "SELECT actor.first_name, actor.last_name FROM film_actor INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of actors from the 'actor' table who have acted in a specific film. The query joins the 'film_actor' table to link actors to films, and filters the results based on the title of the film using a placeholder for string values."
        },
        {
            "sample_id": 9195,
            "vt": "SELECT film.title FROM film WHERE film.replacement_cost = (SELECT MIN(film.replacement_cost) FROM film)",
            "ba": "The virtual table lists the titles of films from the 'film' table that have the lowest replacement cost. The query uses a subquery to find the minimum replacement cost among all films and filters the results accordingly."
        },
        {
            "sample_id": 9157,
            "vt": "SELECT staff.email FROM address INNER JOIN staff AS T2 ON T1.address_id = T2.address_id WHERE address.address = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the email addresses of staff members from the 'staff' table who are associated with a specific address. The query joins the 'address' table with the 'staff' table based on the address ID, filtering results to match a particular address using a placeholder for string values."
        },
        {
            "sample_id": 9379,
            "vt": "SELECT COUNT(DISTINCT category_id) FROM category",
            "ba": "The virtual table counts the distinct categories from the 'category' table, providing insight into the variety of categories available."
        },
        {
            "sample_id": 9100,
            "vt": "SELECT film.title FROM film ORDER BY film.length LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films from the 'film' table, ordered by their length, and limits the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 9305,
            "vt": "SELECT address.address FROM customer INNER JOIN address AS T2 ON T1.address_id = T2.address_id WHERE customer.active = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the addresses of customers from the 'customer' table who are currently active. It uses an inner join to connect the 'customer' table with the 'address' table based on the address ID, ensuring that only active customers' addresses are selected."
        },
        {
            "sample_id": 9377,
            "vt": "SELECT customer.first_name, customer.last_name FROM customer WHERE customer.email = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of customers from the 'customer' table who have a specific email address. The placeholder in the WHERE clause represents the customer's email address."
        },
        {
            "sample_id": 9391,
            "vt": "SELECT (SELECT T3.title, COUNT(T1.customer_id) AS num FROM rental AS T1 INNER JOIN inventory AS T2 ON T1.inventory_id = T2.inventory_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id GROUP BY T3.title).title FROM (SELECT film.title, COUNT(rental.customer_id) FROM rental AS T1 INNER JOIN inventory AS T2 ON T1.inventory_id = T2.inventory_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id GROUP BY T3.title) AS t ORDER BY (SELECT T3.title, COUNT(T1.customer_id) AS num FROM rental AS T1 INNER JOIN inventory AS T2 ON T1.inventory_id = T2.inventory_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id GROUP BY T3.title).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of film titles along with the count of rentals for each title, ordered by the number of rentals. The query uses subqueries to first count the number of rentals for each film and then selects the titles based on that count, limiting the results to a specified number."
        },
        {
            "sample_id": 9417,
            "vt": "SELECT COUNT(payment.customer_id) FROM payment INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]' AND STRFTIME('%Y', payment.payment_date) = '[placeholder-type:string]' AND STRFTIME('%Y', payment.payment_date) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of payments made by a specific customer identified by their first and last names. It joins the 'payment' table with the 'customer' table to filter the results based on the customer's name and the year of the payment date. The placeholders represent the customer's first name, last name, and the year of the payment date."
        },
        {
            "sample_id": 9258,
            "vt": "SELECT country.country FROM country INNER JOIN city AS T2 ON T1.country_id = T2.country_id INNER JOIN address AS T3 ON T2.city_id = T3.city_id WHERE address.address = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of countries associated with a specific address. It joins the 'country', 'city', and 'address' tables to filter results based on the provided address value."
        },
        {
            "sample_id": 9146,
            "vt": "SELECT country.country FROM country INNER JOIN city AS T2 ON T1.country_id = T2.country_id WHERE city.city = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of countries associated with a specific city. It retrieves the country name from the 'country' table by joining it with the 'city' table based on the country_id. The placeholder in the WHERE clause represents the name of the city for which the country is being queried."
        },
        {
            "sample_id": 9220,
            "vt": "SELECT DISTINCT customer.first_name, customer.last_name, customer.email FROM payment INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id INNER JOIN address AS T3 ON T2.address_id = T3.address_id WHERE payment.amount > (SELECT AVG(payment.amount) FROM payment) * [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct first names, last names, and email addresses of customers from the 'customer' table who have made payments exceeding a certain threshold. This threshold is defined as a multiple of the average payment amount across all payments. The query involves joining the 'payment' table with the 'customer' table and the 'address' table to retrieve the necessary customer details."
        },
        {
            "sample_id": 9244,
            "vt": "SELECT (SELECT T2.first_name, T2.last_name, COUNT(T1.film_id) AS num FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id GROUP BY T2.first_name, T2.last_name).first_name, (SELECT T2.first_name, T2.last_name, COUNT(T1.film_id) AS num FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id GROUP BY T2.first_name, T2.last_name).last_name FROM (SELECT actor.first_name, actor.last_name, COUNT(film_actor.film_id) FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id GROUP BY T2.first_name, T2.last_name) AS t ORDER BY (SELECT T2.first_name, T2.last_name, COUNT(T1.film_id) AS num FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id GROUP BY T2.first_name, T2.last_name).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of actors along with the count of films they have appeared in, sorted by the number of films in descending order. The placeholder in the LIMIT clause allows the user to specify how many top actors they want to retrieve based on their film count."
        },
        {
            "sample_id": 9260,
            "vt": "SELECT film.title FROM film_category INNER JOIN film AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T1.category_id = T3.category_id WHERE category.name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of films from the 'film' table that belong to a specific category. It joins the 'film_category' table to associate films with their categories and filters the results based on the specified category name."
        },
        {
            "sample_id": 9125,
            "vt": "SELECT film.title FROM customer INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]' ORDER BY film.replacement_cost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films rented by a specific customer identified by their first and last name. It joins multiple tables: 'customer' to identify the customer, 'rental' to find their rental records, 'inventory' to link to the films available for rent, and 'film' to get the film titles. The results are ordered by the replacement cost of the films, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 9229,
            "vt": "SELECT COUNT(film.film_id) FROM film INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id WHERE inventory.inventory_id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND film.rating = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of films from the 'film' table that are associated with a specific range of inventory IDs and have a particular film rating. The placeholders represent the range of inventory IDs and the desired film rating."
        },
        {
            "sample_id": 9178,
            "vt": "SELECT COUNT(film_category.film_id) FROM film_category INNER JOIN category AS T2 ON T1.category_id = T2.category_id WHERE category.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of films that belong to a specific category from the 'film_category' table. It joins with the 'category' table to filter the results based on the category name provided by the user."
        },
        {
            "sample_id": 9262,
            "vt": "SELECT COUNT(rental.customer_id) FROM rental INNER JOIN staff AS T2 ON T1.staff_id = T2.staff_id WHERE staff.first_name = '[placeholder-type:string]' AND staff.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of rentals associated with a specific staff member identified by their first and last names. It joins the 'rental' table with the 'staff' table to filter the results based on the staff member's name."
        },
        {
            "sample_id": 9290,
            "vt": "SELECT address.district FROM customer INNER JOIN address AS T2 ON T1.address_id = T2.address_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the district information from the 'address' table for customers based on their first and last names. It uses an inner join to connect the 'customer' table with the 'address' table, ensuring that only the relevant address information for the specified customer is returned."
        },
        {
            "sample_id": 9155,
            "vt": "SELECT COUNT(film.film_id) FROM film INNER JOIN language AS T2 ON T1.language_id = T2.language_id WHERE language.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of films from the 'film' table that are associated with a specific language. It joins the 'film' table with the 'language' table to filter the results based on the language name provided by the user."
        },
        {
            "sample_id": 9263,
            "vt": "SELECT SUM(payment.amount) FROM rental INNER JOIN payment AS T2 ON T1.rental_id = T2.rental_id WHERE DATE(rental.rental_date) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total amount of payments received for rentals that occurred on a specific date. It joins the 'rental' table with the 'payment' table using the rental_id to ensure that only payments related to the rentals on that date are summed up."
        },
        {
            "sample_id": 9267,
            "vt": "SELECT COUNT(actor.actor_id) FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id INNER JOIN film_category AS T4 ON T3.film_id = T4.film_id INNER JOIN category AS T5 ON T4.category_id = T5.category_id WHERE category.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of actors associated with films that belong to a specific category. It joins multiple tables: 'actor', 'film_actor', 'film', 'film_category', and 'category' to filter actors based on the category name provided."
        },
        {
            "sample_id": 9370,
            "vt": "SELECT COUNT(film_actor.film_id) FROM film_actor INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id AND T2.first_name = 'NICK' AND T2.last_name = 'STALLONE'",
            "ba": "The virtual table counts the number of films associated with a specific actor identified by their first and last name from the 'film_actor' table. It uses an inner join with the 'actor' table to filter the results based on the actor's name."
        },
        {
            "sample_id": 9331,
            "vt": "SELECT CAST(SUM(CASE WHEN category.\"name\" = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) * [placeholder-type:numeric] / COUNT(film.film_id) AS FLOAT) FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T3.category_id = T2.category_id WHERE film.length > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average rental rate of films in a specific category, filtered by the length of the films. It sums the rental rates of films that belong to the specified category and divides it by the total count of films that meet the length criteria. The placeholders represent the category name, rental rate, and film length."
        },
        {
            "sample_id": 9190,
            "vt": "SELECT (SELECT T2.first_name, T2.last_name, COUNT(T1.rental_id) AS num FROM rental AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id GROUP BY T2.first_name, T2.last_name).first_name, (SELECT T2.first_name, T2.last_name, COUNT(T1.rental_id) AS num FROM rental AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id GROUP BY T2.first_name, T2.last_name).last_name FROM (SELECT customer.first_name, customer.last_name, COUNT(rental.rental_id) FROM rental AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id GROUP BY T2.first_name, T2.last_name) AS t ORDER BY (SELECT T2.first_name, T2.last_name, COUNT(T1.rental_id) AS num FROM rental AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id GROUP BY T2.first_name, T2.last_name).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of customers along with the count of rentals they have made, sorted by the number of rentals in descending order. The placeholder in the LIMIT clause allows the user to specify how many top customers they want to retrieve based on their rental activity."
        },
        {
            "sample_id": 9117,
            "vt": "SELECT COUNT(film.film_id) FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id INNER JOIN language AS T4 ON T3.language_id = T4.language_id WHERE language.name = '[placeholder-type:string]' AND actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of films associated with a specific actor who speaks a particular language. It joins the 'actor', 'film_actor', 'film', and 'language' tables to filter results based on the actor's first and last name, as well as the language name."
        },
        {
            "sample_id": 9334,
            "vt": "SELECT film.film_id FROM film WHERE film.rental_duration = (SELECT MAX(film.rental_duration) FROM film)",
            "ba": "The virtual table identifies the unique film ID from the 'film' table that has the longest rental duration. It uses a subquery to find the maximum rental duration among all films and filters the results accordingly."
        },
        {
            "sample_id": 9266,
            "vt": "SELECT film.title FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of films associated with a specific actor identified by their first and last names. It retrieves data from the 'film' table, joining it with the 'film_actor' table to link actors to their respective films, and filters the results based on the actor's name."
        },
        {
            "sample_id": 9308,
            "vt": "SELECT (SELECT T1.first_name, T1.last_name, SUM(T2.amount) AS num FROM customer AS T1 INNER JOIN payment AS T2 ON T1.customer_id = T2.customer_id GROUP BY T1.first_name, T1.last_name).first_name, (SELECT T1.first_name, T1.last_name, SUM(T2.amount) AS num FROM customer AS T1 INNER JOIN payment AS T2 ON T1.customer_id = T2.customer_id GROUP BY T1.first_name, T1.last_name).last_name FROM (SELECT customer.first_name, customer.last_name, SUM(payment.amount) FROM customer AS T1 INNER JOIN payment AS T2 ON T1.customer_id = T2.customer_id GROUP BY T1.first_name, T1.last_name) AS t ORDER BY (SELECT T1.first_name, T1.last_name, SUM(T2.amount) AS num FROM customer AS T1 INNER JOIN payment AS T2 ON T1.customer_id = T2.customer_id GROUP BY T1.first_name, T1.last_name).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total payment amounts made by customers, displaying their first and last names along with the total amount paid. The results are ordered by the total payment amount in descending order, and a limit is applied to restrict the number of records returned based on a specified numeric value."
        },
        {
            "sample_id": 9264,
            "vt": "SELECT customer.first_name FROM customer INNER JOIN address AS T2 ON T1.address_id = T2.address_id WHERE SUBSTRING(address.postal_code, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the first names of customers from the 'customer' table who have a specific postal code. It joins the 'customer' table with the 'address' table to access the postal code information, filtering based on a substring of the postal code using placeholders for numeric values and a string value."
        },
        {
            "sample_id": 9162,
            "vt": "SELECT film.title FROM film INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id WHERE inventory.inventory_id = [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films from the 'film' table that are associated with a specific inventory item. The query uses an INNER JOIN to connect the 'film' table with the 'inventory' table based on the film's unique identifier, ensuring that only the title of the film corresponding to the specified inventory ID is retrieved."
        },
        {
            "sample_id": 9239,
            "vt": "SELECT CAST(SUM(CASE WHEN film.rating = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(film.film_id) FROM film",
            "ba": "The virtual table calculates the weighted average of a specific film rating from the 'film' table. It sums up the values based on whether the film's rating matches a specified rating, and then divides this sum by the total count of films to get the average. The placeholders represent the rating to filter by, a numeric value for the calculation, and another numeric value for scaling the result."
        },
        {
            "sample_id": 9122,
            "vt": "SELECT COUNT(rental.rental_id) FROM customer INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of rentals associated with a specific customer identified by their first and last name. It joins the 'customer' table with the 'rental' table to retrieve the rental records for that customer."
        },
        {
            "sample_id": 9353,
            "vt": "SELECT AVG(film.rental_rate) FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T3.category_id = T2.category_id WHERE category.\"name\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rental rate of films from the 'film' table that belong to a specific category. It joins the 'film' table with the 'film_category' table to link films to their categories, and then further joins with the 'category' table to filter by the specified category name."
        },
        {
            "sample_id": 9184,
            "vt": "SELECT film.rental_rate FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE category.name = '[placeholder-type:string]' ORDER BY film.rental_rate / film.rental_duration LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the rental rates of films from the 'film' table, filtered by a specific category name. It joins the 'film' table with the 'film_category' table to associate films with their categories, and then further joins with the 'category' table to filter by the desired category. The results are ordered by the rental rate divided by the rental duration, allowing for a comparison of cost-effectiveness, and limited to a specified number of results."
        },
        {
            "sample_id": 9166,
            "vt": "SELECT COUNT(film.film_id) FROM film WHERE film.rating = '[placeholder-type:string]' AND film.release_year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of films from the 'film' table that have a specific rating and were released in a particular year. The placeholders represent the film's rating and the release year."
        },
        {
            "sample_id": 9410,
            "vt": "SELECT address.address FROM address INNER JOIN customer AS T2 ON T1.address_id = T2.address_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the address of a customer from the 'address' table by joining it with the 'customer' table. It filters the results based on the customer's first and last name, which are provided as placeholders."
        },
        {
            "sample_id": 9147,
            "vt": "SELECT COUNT(film_actor.actor_id) FROM film_actor INNER JOIN film AS T2 ON T1.film_id = T2.film_id WHERE film.release_year = [placeholder-type:numeric] AND film.rental_duration = [placeholder-type:numeric] AND film.rental_duration = [placeholder-type:numeric] AND film.length = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of actors associated with films that were released in a specific year, have a certain rental duration, and a specific length. The placeholders represent the year of release, rental duration, and film length."
        },
        {
            "sample_id": 9385,
            "vt": "SELECT customer.first_name, customer.last_name FROM payment INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE payment.amount > [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of customers from the 'customer' table who have made payments exceeding a specified amount. The query uses an INNER JOIN to connect the 'payment' table with the 'customer' table based on the customer ID, ensuring that only those customers who have made payments above the given threshold are selected."
        },
        {
            "sample_id": 9164,
            "vt": "SELECT CAST(SUM(CASE WHEN country.country = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN country.country = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM country INNER JOIN city AS T2 ON T1.country_id = T2.country_id",
            "ba": "The virtual table calculates the average of a specific numeric value for a given country from the 'country' table, by summing up the values conditionally based on the country name. It joins the 'country' table with the 'city' table to access the relevant data associated with each country."
        },
        {
            "sample_id": 9289,
            "vt": "SELECT SUM(CASE WHEN category.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN category.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM film_category INNER JOIN category AS T2 ON T1.category_id = T2.category_id",
            "ba": "The virtual table calculates the difference between the total sums of two categories from the 'film_category' table. It uses a conditional sum based on the category names provided as placeholders. The result will show the net total of films in the specified categories."
        },
        {
            "sample_id": 9246,
            "vt": "SELECT AVG(CASE WHEN country.country = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - AVG(CASE WHEN country.country = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM customer INNER JOIN address AS T2 ON T1.address_id = T2.address_id INNER JOIN city AS T3 ON T2.city_id = T3.city_id INNER JOIN country AS T4 ON T3.country_id = T4.country_id",
            "ba": "The virtual table calculates the average of a specific numeric value for customers from a specified country and compares it to the average of the same numeric value for customers from another specified country. It joins multiple tables: 'customer', 'address', 'city', and 'country' to gather the necessary data, filtering based on the country names provided as placeholders."
        },
        {
            "sample_id": 9283,
            "vt": "SELECT film.rental_rate / film.rental_duration FROM film WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the rental price per day for a specific film by dividing the rental rate by the rental duration. The placeholder in the WHERE clause represents the title of the film being queried."
        },
        {
            "sample_id": 9404,
            "vt": "SELECT inventory.store_id FROM film INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the store IDs from the 'inventory' table that contain a specific film title from the 'film' table. The join operation links the two tables based on the film ID, allowing us to filter the results by the film's title using a placeholder."
        },
        {
            "sample_id": 9273,
            "vt": "SELECT COUNT(customer.customer_id) FROM rental INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE customer.active = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of customers from the 'customer' table who have made rentals, filtered by their active status. The placeholder in the WHERE clause represents whether the customer is active or not, where 1 indicates active and 0 indicates not active."
        },
        {
            "sample_id": 9340,
            "vt": "SELECT COUNT(film.title) FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE category.name = '[placeholder-type:string]' AND film.rating = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of films from the 'film' table that belong to a specific category and have a certain rating. It joins the 'film' table with the 'film_category' table to link films to their categories, and then further joins with the 'category' table to filter by category name. The placeholders represent the category name and film rating."
        },
        {
            "sample_id": 9238,
            "vt": "SELECT customer.first_name, customer.last_name, customer.email FROM customer WHERE STRFTIME('%Y', customer.create_date) = '[placeholder-type:string]' AND customer.active = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first name, last name, and email address of customers from the 'customer' table who were created in a specific year and are currently active. The placeholders represent the year of creation and the active status of the customers."
        },
        {
            "sample_id": 9114,
            "vt": "SELECT COUNT(film_actor.film_id) FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE film.release_year = [placeholder-type:numeric] AND actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of films associated with a specific actor for a given release year. It joins the 'actor', 'film_actor', and 'film' tables to filter the results based on the actor's first and last name, as well as the film's release year."
        },
        {
            "sample_id": 9421,
            "vt": "SELECT AVG(payment.amount) FROM address INNER JOIN city AS T2 ON T1.city_id = T2.city_id INNER JOIN country AS T3 ON T2.country_id = T3.country_id INNER JOIN customer AS T4 ON T1.address_id = T4.address_id INNER JOIN payment AS T5 ON T4.customer_id = T5.customer_id WHERE country.country = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average payment amount from customers residing in a specific country. It joins multiple tables: 'address' to get customer addresses, 'city' to link cities to their respective countries, 'country' to filter by the specified country, 'customer' to associate customers with their addresses, and 'payment' to access payment details. The placeholder in the WHERE clause represents the name of the country."
        },
        {
            "sample_id": 9375,
            "vt": "SELECT CAST(SUM(CASE WHEN customer.active = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(customer.customer_id) FROM customer WHERE customer.store_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average active customer ratio for a specific store by summing the active customers and dividing by the total number of customers in that store. The placeholders represent the active status, the total number of customers, and the store identifier."
        },
        {
            "sample_id": 9327,
            "vt": "SELECT film.title FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE category.\"name\" = '[placeholder-type:string]' ORDER BY film.rental_rate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films from the 'film' table that belong to a specific category. It joins the 'film' table with the 'film_category' table to associate films with their categories, and then further joins with the 'category' table to filter by the category name. The results are ordered by the rental rate of the films, and a limit can be set on the number of titles returned."
        },
        {
            "sample_id": 9406,
            "vt": "SELECT SUM(CASE WHEN inventory.film_id = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN inventory.film_id = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM film_actor INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id INNER JOIN inventory AS T4 ON T3.film_id = T4.film_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference in the sum of two numeric values based on the film_id from the 'inventory' table, filtered by the first and last names of an actor from the 'actor' table. It uses a series of inner joins to connect the 'film_actor', 'actor', 'film', and 'inventory' tables, ensuring that only records matching the specified actor's name are included in the calculation."
        },
        {
            "sample_id": 9144,
            "vt": "SELECT film.description FROM film WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the main content of a film from the 'film' table based on its title. The placeholder in the WHERE clause represents the title of the film being queried."
        },
        {
            "sample_id": 9241,
            "vt": "SELECT AVG(payment.amount) FROM payment WHERE payment.customer_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average payment amount made by a specific customer from the 'payment' table. The placeholder in the WHERE clause represents the unique identifier of the customer whose payment average is being queried."
        },
        {
            "sample_id": 9182,
            "vt": "SELECT COUNT(film.film_id) FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE film.rental_duration = [placeholder-type:numeric] AND category.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of films from the 'film' table that belong to a specific category and have a defined rental duration. It joins the 'film' table with the 'film_category' table to link films to their categories, and then further joins with the 'category' table to filter by category name. The placeholders represent the rental duration and the category name."
        },
        {
            "sample_id": 9307,
            "vt": "SELECT actor.first_name, actor.last_name FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of actors from the 'actor' table who have acted in a specific film. The query joins the 'actor' table with the 'film_actor' table to link actors to their films, and then further joins with the 'film' table to filter by the film's title using a placeholder for string values."
        },
        {
            "sample_id": 9212,
            "vt": "SELECT film.title, category.name FROM film_category INNER JOIN category AS T2 ON T1.category_id = T2.category_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id INNER JOIN inventory AS T4 ON T3.film_id = T4.film_id INNER JOIN customer AS T5 ON T4.store_id = T5.store_id INNER JOIN rental AS T6 ON T4.inventory_id = T6.inventory_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]' AND STRFTIME('%Y', film.rental_rate) = '[placeholder-type:string]' AND STRFTIME('%m', film.rental_rate) = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of film titles along with their corresponding category names. It retrieves data from multiple tables including 'film_category', 'category', 'film', 'inventory', 'customer', and 'rental'. The results are filtered based on the first and last names of the customer, as well as the year and month extracted from the rental rate of the films."
        },
        {
            "sample_id": 9360,
            "vt": "SELECT actor.first_name, actor.last_name FROM film_actor INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of actors from the 'actor' table who have acted in a specific film. The query joins the 'film_actor' table to link actors to films and filters the results based on the title of the film provided as a placeholder."
        },
        {
            "sample_id": 9265,
            "vt": "SELECT rental.rental_date FROM rental INNER JOIN inventory AS T2 ON T1.inventory_id = T2.inventory_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table provides the rental dates of films from the 'rental' table, filtered by the title of the film. It joins the 'rental' table with the 'inventory' table to link rentals to specific inventory items, and then further joins with the 'film' table to access film details such as the title. The placeholder in the WHERE clause represents the specific title of the film being queried."
        },
        {
            "sample_id": 9205,
            "vt": "SELECT COUNT(film.film_id) FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE category.name = '[placeholder-type:string]' AND film.rating = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of films from the 'film' table that belong to a specific category and have a certain rating. It joins the 'film' table with the 'film_category' table to link films to their categories, and then further joins with the 'category' table to filter by category name. The placeholders represent the category name and film rating that the user wants to specify."
        },
        {
            "sample_id": 9250,
            "vt": "SELECT AVG(film_actor.actor_id) FROM film_actor INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id INNER JOIN actor AS T4 ON T4.actor_id = T1.actor_id WHERE category.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average actor ID from the 'film_actor' table, joining it with the 'film_category' and 'category' tables to filter by a specific film category. It also joins with the 'actor' table to include actor details, ensuring that only actors associated with films in the specified category are considered in the average calculation."
        },
        {
            "sample_id": 9324,
            "vt": "SELECT customer.first_name, customer.last_name FROM address INNER JOIN customer AS T2 ON T1.address_id = T2.address_id WHERE address.address = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of customers from the 'customer' table who are associated with a specific address. The query joins the 'address' table with the 'customer' table based on the address ID, filtering for a specific address using a placeholder."
        },
        {
            "sample_id": 9348,
            "vt": "SELECT film_actor.actor_id FROM film INNER JOIN film_actor AS T2 ON T1.film_id = T2.film_id WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of actors from the 'film_actor' table who acted in a specific film. The film is identified by its title, which is provided as a placeholder in the WHERE clause."
        },
        {
            "sample_id": 9255,
            "vt": "SELECT COUNT(actor.actor_id) FROM actor WHERE actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of actors from the 'actor' table whose last name matches a specified value. The placeholder in the WHERE clause represents the last name of the actor."
        },
        {
            "sample_id": 9165,
            "vt": "SELECT CAST(SUM(CASE WHEN actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(CASE WHEN actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM film_actor INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id",
            "ba": "The virtual table calculates a weighted average based on the films associated with a specific actor. It sums up a certain numeric value for films where the actor's first and last names match the provided placeholders, and divides this by the total sum of the same numeric value for all films associated with that actor. The result is then multiplied by another numeric placeholder, allowing for dynamic adjustments based on user input."
        },
        {
            "sample_id": 9291,
            "vt": "SELECT customer.first_name, customer.last_name FROM customer INNER JOIN address AS T2 ON T1.address_id = T2.address_id WHERE address.address = '[placeholder-type:string]' AND customer.active = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of customers from the 'customer' table who are active and have a specific address. The placeholders in the WHERE clause represent the address and the active status of the customer."
        },
        {
            "sample_id": 9411,
            "vt": "SELECT COUNT(customer.customer_id) FROM address INNER JOIN customer AS T2 ON T1.address_id = T2.address_id INNER JOIN city AS T3 ON T1.city_id = T3.city_id WHERE customer.active = [placeholder-type:numeric] AND city.city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from the 'customer' table who are active and belong to a specific city. It joins the 'address' table to link customer addresses and the 'city' table to filter by city name. The placeholders represent the active status of the customer and the name of the city."
        },
        {
            "sample_id": 9115,
            "vt": "SELECT film.title FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]' ORDER BY film.replacement_cost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films featuring a specific actor, identified by their first and last names. It joins the 'actor' table with the 'film_actor' table to link actors to their respective films, and then joins with the 'film' table to access the film titles. The results are ordered by the replacement cost of the films, and a limit is applied to restrict the number of titles returned."
        },
        {
            "sample_id": 9221,
            "vt": "SELECT COUNT(film.film_id) FROM film WHERE film.rental_rate = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of films from the 'film' table that have a specific rental rate. The placeholder in the WHERE clause represents the rental rate of the films."
        },
        {
            "sample_id": 9112,
            "vt": "SELECT COUNT(film_actor.actor_id) FROM film_actor INNER JOIN film AS T2 ON T1.film_id = T2.film_id WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of actors associated with a specific film from the 'film_actor' table. It joins the 'film_actor' table with the 'film' table to filter the results based on the film's title, which is represented by a placeholder for string values."
        },
        {
            "sample_id": 9339,
            "vt": "SELECT COUNT(film.film_id) FROM film INNER JOIN \"language\" AS T2 ON T1.language_id = T2.language_id WHERE language.\"name\" = '[placeholder-type:string]' AND film.special_features = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of films from the 'film' table that are associated with a specific language and have certain special features. The placeholders represent the language name and the special features of the films."
        },
        {
            "sample_id": 9160,
            "vt": "SELECT COUNT(film_category.film_id) FROM film_category INNER JOIN category AS T2 ON T1.category_id = T2.category_id WHERE category.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of films that belong to a specific category from the 'film_category' table. It joins with the 'category' table to filter the results based on the category name provided by the user."
        },
        {
            "sample_id": 9240,
            "vt": "SELECT film.title FROM film ORDER BY film.rental_rate / film.rental_duration LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films from the 'film' table, ordered by the rental rate divided by the rental duration, which indicates the cost-effectiveness of renting each film. The query limits the results to a specified number of films using a placeholder for numeric values."
        },
        {
            "sample_id": 9311,
            "vt": "SELECT address.address FROM store INNER JOIN address AS T2 ON T1.address_id = T2.address_id",
            "ba": "The virtual table retrieves the address of each store from the 'store' table by joining it with the 'address' table based on the address_id. This allows us to see the specific address associated with each store."
        },
        {
            "sample_id": 9213,
            "vt": "SELECT COUNT(rental.rental_id) FROM rental INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of rentals associated with a specific customer identified by their first and last name. It joins the 'rental' table with the 'customer' table to filter the results based on the customer's name."
        },
        {
            "sample_id": 9172,
            "vt": "SELECT staff.first_name, staff.last_name FROM staff WHERE staff.active = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of staff members from the 'staff' table who are currently active. The placeholder in the WHERE clause represents the active status of the staff, where 1 indicates active staff members."
        },
        {
            "sample_id": 9282,
            "vt": "SELECT customer.first_name, customer.last_name FROM customer WHERE customer.active = [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of customers from the 'customer' table who are either active or inactive, based on a specified active status. The placeholders in the WHERE clause represent the active status of the customer and the limit on the number of results returned."
        },
        {
            "sample_id": 9394,
            "vt": "SELECT film.title FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE category.name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of films from the 'film' table that belong to a specific category. It joins the 'film' table with the 'film_category' table to associate films with their categories, and then further joins with the 'category' table to filter by the category name provided in the placeholder."
        },
        {
            "sample_id": 9242,
            "vt": "SELECT COUNT(rental.customer_id) FROM rental WHERE rental.return_date - rental.rental_date > (SELECT AVG(rental.return_date - rental.rental_date) FROM rental)",
            "ba": "The virtual table counts the number of customers who have rented films and returned them after a duration longer than the average rental duration. It uses a subquery to calculate the average rental duration by subtracting the rental date from the return date for all rentals."
        },
        {
            "sample_id": 9177,
            "vt": "SELECT customer.first_name, customer.last_name FROM customer INNER JOIN (SELECT customer_id, COUNT(*) AS num_days FROM (SELECT *, DATE(days, '-' || rn || ' day') AS results FROM (SELECT customer_id, days, ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY days) AS rn FROM (SELECT DISTINCT customer_id, DATE(rental_date) AS days FROM rental))) GROUP BY customer_id, results HAVING num_days = 7) AS T2 ON T1.customer_id = T2.customer_id",
            "ba": "The virtual table retrieves the first and last names of customers who have rented films for exactly seven distinct days. It does this by first identifying unique rental dates for each customer, then counting the number of distinct rental days for each customer, and filtering those who have exactly seven days. The final result is a list of customers who meet this criterion."
        },
        {
            "sample_id": 9358,
            "vt": "SELECT SUM(payment.amount) FROM rental INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id INNER JOIN payment AS T3 ON T1.rental_id = T3.rental_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total payment amount made by a specific customer based on their first and last names. It retrieves data from the 'rental' table, joining it with the 'customer' table to identify the customer and the 'payment' table to sum up the payment amounts associated with their rentals. The placeholders in the WHERE clause represent the customer's first and last names."
        },
        {
            "sample_id": 9133,
            "vt": "SELECT AVG(film.replacement_cost) FROM film_category INNER JOIN category AS T2 ON T1.category_id = T2.category_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id WHERE category.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average replacement cost of films from a specific category. It joins the 'film_category' table with the 'category' table to filter by category name, and then joins with the 'film' table to access the replacement cost of each film."
        },
        {
            "sample_id": 9256,
            "vt": "SELECT COUNT(film.film_id) FROM film WHERE film.length > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of films from the 'film' table that have a length greater than a specified duration. The placeholder in the WHERE clause represents the minimum length of the films to be counted."
        },
        {
            "sample_id": 9230,
            "vt": "SELECT COUNT(actor.actor_id) FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE film.rental_rate = [placeholder-type:numeric] AND actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of actors from the 'actor' table who have acted in films with a specific rental rate. It joins the 'actor' table with the 'film_actor' table to link actors to their films, and then further joins with the 'film' table to filter based on the rental rate. The placeholders represent the rental rate and the first and last names of the actor."
        },
        {
            "sample_id": 9366,
            "vt": "SELECT film.title FROM customer INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]' ORDER BY rental.rental_date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films rented by a specific customer identified by their first and last names. It joins multiple tables: 'customer' to identify the customer, 'rental' to find their rental records, 'inventory' to link to the films available for rent, and 'film' to get the film titles. The results are ordered by the rental date and limited to a specified number of entries."
        },
        {
            "sample_id": 9315,
            "vt": "SELECT CAST(SUM(CASE WHEN category.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(film_category.film_id) FROM film_category INNER JOIN category AS T2 ON T1.category_id = T2.category_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id",
            "ba": "The virtual table calculates the average rental cost of films in a specific category by summing the rental rates of films that belong to that category and dividing it by the total number of films in that category. The placeholders represent the category name, rental rate, and a multiplier for the calculation."
        },
        {
            "sample_id": 9167,
            "vt": "SELECT COUNT(film_actor.actor_id) FROM film_actor WHERE film_actor.film_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of actors associated with a specific film from the 'film_actor' table. The placeholder in the WHERE clause represents the unique identifier of the film."
        },
        {
            "sample_id": 9143,
            "vt": "SELECT film.special_features FROM film WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the special features of a film from the 'film' table based on its title. The placeholder in the WHERE clause represents the title of the film."
        },
        {
            "sample_id": 9403,
            "vt": "SELECT film.title FROM film_actor INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of films from the 'film' table that are associated with a specific actor. The query joins the 'film_actor' table with the 'actor' table to filter by the actor's first and last names, using placeholders for these values."
        },
        {
            "sample_id": 9139,
            "vt": "SELECT address.postal_code FROM address WHERE address.address_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the postal code from the 'address' table based on a specific address ID. The placeholder in the WHERE clause represents the unique identifier for the address."
        },
        {
            "sample_id": 9226,
            "vt": "SELECT film.title FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]' AND film.replacement_cost = [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films featuring a specific actor, identified by their first and last names, and filters the results based on the film's replacement cost."
        },
        {
            "sample_id": 9365,
            "vt": "SELECT COUNT(rental.rental_id) FROM customer INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of rentals associated with a specific customer identified by their first and last name. It joins the 'customer' table with the 'rental' table to retrieve the rental records for that customer."
        },
        {
            "sample_id": 9101,
            "vt": "SELECT film.title FROM film WHERE film.title IN ('[placeholder-type:string]', '[placeholder-type:string]') ORDER BY film.replacement_cost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films from the 'film' table that match specific titles provided in the query. The results are ordered by the replacement cost of the films, and the number of results returned is limited by a numeric placeholder."
        },
        {
            "sample_id": 9392,
            "vt": "SELECT film_actor.film_id FROM film_actor INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique film IDs from the 'film_actor' table, which associates actors with films. It joins the 'actor' table to filter results based on the first and last names of the actor. The placeholders in the WHERE clause represent the actor's first and last names, allowing users to specify which actor's films they are interested in."
        },
        {
            "sample_id": 9218,
            "vt": "SELECT customer.first_name, customer.last_name FROM staff INNER JOIN address AS T2 ON T1.address_id = T2.address_id INNER JOIN customer AS T3 ON T2.address_id = T3.address_id WHERE staff.first_name = '[placeholder-type:string]' AND staff.last_name = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of customers associated with a specific staff member from the 'staff' table. It joins the 'staff' table with the 'address' table to link staff members to their addresses, and then further joins with the 'customer' table to retrieve customer information. The placeholders in the WHERE clause represent the first and last names of the staff member, and the LIMIT clause allows for controlling the number of results returned."
        },
        {
            "sample_id": 9275,
            "vt": "SELECT country.country FROM customer INNER JOIN store AS T2 ON T1.store_id = T2.store_id INNER JOIN address AS T3 ON T2.address_id = T3.address_id INNER JOIN city AS T4 ON T3.city_id = T4.city_id INNER JOIN country AS T5 ON T4.country_id = T5.country_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of countries associated with customers based on their first and last names. It retrieves data by joining multiple tables: 'customer', 'store', 'address', 'city', and 'country'. The placeholders in the WHERE clause represent the customer's first and last names, allowing for dynamic querying based on user input."
        },
        {
            "sample_id": 9227,
            "vt": "SELECT inventory.inventory_id FROM film INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique inventory IDs of films from the 'inventory' table that match a specific film title from the 'film' table. The join operation links the two tables based on the film ID, ensuring that only the inventory records corresponding to the specified film title are selected."
        },
        {
            "sample_id": 9310,
            "vt": "SELECT country.country FROM country INNER JOIN city AS T2 ON T1.country_id = T2.country_id WHERE city.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the name of the country associated with a specific city by joining the 'country' and 'city' tables based on the country_id. The placeholder in the WHERE clause represents the name of the city for which the country is being queried."
        },
        {
            "sample_id": 9187,
            "vt": "SELECT COUNT(city.city) FROM country INNER JOIN city AS T2 ON T1.country_id = T2.country_id WHERE country.country = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cities associated with a specific country from the 'country' and 'city' tables. The placeholder in the WHERE clause represents the name of the country for which the city count is being requested."
        },
        {
            "sample_id": 9110,
            "vt": "SELECT COUNT(film.film_id) FROM film INNER JOIN language AS T2 ON T1.language_id = T2.language_id WHERE language.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of films from the 'film' table that are associated with a specific language. It joins the 'film' table with the 'language' table to filter the results based on the language name provided by the user."
        },
        {
            "sample_id": 9288,
            "vt": "SELECT film.title FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE category.name = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films from the 'film' table that belong to a specific category. It joins the 'film' table with the 'film_category' table to associate films with their categories, and then further joins with the 'category' table to filter by the category name. The placeholders allow users to specify the desired category and limit the number of results returned."
        },
        {
            "sample_id": 9168,
            "vt": "SELECT film.special_features FROM film WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the special features of a film from the 'film' table based on its title. The placeholder in the WHERE clause represents the title of the film being queried."
        },
        {
            "sample_id": 9119,
            "vt": "SELECT film.title FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE category.name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of films from the 'film' table that belong to a specific category. It joins the 'film' table with the 'film_category' table to associate films with their categories, and then further joins with the 'category' table to filter by the category name provided in the placeholder."
        },
        {
            "sample_id": 9169,
            "vt": "SELECT COUNT(payment.customer_id) FROM payment WHERE SUBSTRING(payment.payment_date, [placeholder-type:numeric], [placeholder-type:numeric]) LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of payments made by customers from the 'payment' table, filtering based on a specific substring of the payment date. The placeholders represent the starting position and length for the substring extraction, as well as the pattern to match against the extracted substring."
        },
        {
            "sample_id": 9343,
            "vt": "SELECT film.title FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T3.category_id = T2.category_id WHERE category.name = '[placeholder-type:string]' ORDER BY film.length LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films from the 'film' table that belong to a specific category. It joins the 'film' table with the 'film_category' table to associate films with their categories, and then further joins with the 'category' table to filter by the specified category name. The results are ordered by the length of the films and limited to a specified number of entries."
        },
        {
            "sample_id": 9247,
            "vt": "SELECT CAST(SUM(CASE WHEN category.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(actor.actor_id) FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film_category AS T3 ON T2.film_id = T3.film_id INNER JOIN category AS T4 ON T3.category_id = T4.category_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average based on the sum of a specific category's values associated with actors. It joins multiple tables: 'actor', 'film_actor', 'film_category', and 'category' to filter actors by their first and last names and to sum values from a specified category. The result is then multiplied by a numeric placeholder and divided by the count of actors to provide an average value."
        },
        {
            "sample_id": 9349,
            "vt": "SELECT rental.inventory_id FROM customer INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the inventory IDs of rentals associated with a specific customer identified by their first and last names. It joins the 'customer' table with the 'rental' table to link customer information with their rental records."
        },
        {
            "sample_id": 9268,
            "vt": "SELECT (SELECT T4.first_name, T4.last_name, COUNT(T2.actor_id) AS num FROM film_category AS T1 INNER JOIN film_actor AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T1.category_id = T3.category_id INNER JOIN actor AS T4 ON T2.actor_id = T4.actor_id WHERE T3.name = 'Comedy' GROUP BY T4.first_name, T4.last_name).first_name, (SELECT T4.first_name, T4.last_name, COUNT(T2.actor_id) AS num FROM film_category AS T1 INNER JOIN film_actor AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T1.category_id = T3.category_id INNER JOIN actor AS T4 ON T2.actor_id = T4.actor_id WHERE T3.name = 'Comedy' GROUP BY T4.first_name, T4.last_name).last_name FROM (SELECT actor.first_name, actor.last_name, COUNT(film_actor.actor_id) FROM film_category AS T1 INNER JOIN film_actor AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T1.category_id = T3.category_id INNER JOIN actor AS T4 ON T2.actor_id = T4.actor_id WHERE T3.name = 'Comedy' GROUP BY T4.first_name, T4.last_name) AS t ORDER BY (SELECT T4.first_name, T4.last_name, COUNT(T2.actor_id) AS num FROM film_category AS T1 INNER JOIN film_actor AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T1.category_id = T3.category_id INNER JOIN actor AS T4 ON T2.actor_id = T4.actor_id WHERE T3.name = 'Comedy' GROUP BY T4.first_name, T4.last_name).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of actors who have appeared in films categorized as 'Comedy', along with the count of films they have acted in. The results are ordered by the number of films in descending order, and a limit can be applied to restrict the number of results returned."
        },
        {
            "sample_id": 9278,
            "vt": "SELECT CAST(SUM(CASE WHEN film.length < [placeholder-type:numeric] AND category.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(film_category.film_id) FROM film_category INNER JOIN film AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T1.category_id = T3.category_id",
            "ba": "The virtual table calculates the weighted average length of films in a specific category that are shorter than a given length. It sums the lengths of these films, applies a multiplier, and divides by the count of films in that category."
        },
        {
            "sample_id": 9369,
            "vt": "SELECT rental.rental_date - rental.return_date FROM customer INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id WHERE customer.first_name = '[placeholder-type:string]' AND film.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between the rental date and return date for films rented by a specific customer. It joins the 'customer', 'rental', 'inventory', and 'film' tables to retrieve the necessary information, filtering by the customer's first name and the film's title."
        },
        {
            "sample_id": 9253,
            "vt": "SELECT DISTINCT CASE WHEN SUM(CASE WHEN category.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN category.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) > [placeholder-type:numeric] THEN customer.first_name ELSE [placeholder-type:numeric] END FROM customer INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film_category AS T4 ON T4.film_id = T3.film_id INNER JOIN category AS T5 ON T4.category_id = T5.category_id GROUP BY customer.customer_id",
            "ba": "The virtual table summarizes the first names of customers based on their rental activity in a specific film category. It calculates the total rentals for a specified category and compares it to another value, using placeholders for category names and numeric values. The result is a distinct list of customer first names who meet the rental criteria."
        },
        {
            "sample_id": 9191,
            "vt": "SELECT COUNT(rental.rental_id) FROM film INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id INNER JOIN rental AS T3 ON T2.inventory_id = T3.inventory_id WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of rentals for a specific film from the 'film' table. It joins the 'inventory' table to link films to their inventory records and the 'rental' table to count how many times that film has been rented. The placeholder in the WHERE clause represents the title of the film being queried."
        },
        {
            "sample_id": 9111,
            "vt": "SELECT film.title FROM film_actor INNER JOIN film AS T2 ON T1.film_id = T2.film_id INNER JOIN actor AS T3 ON T1.actor_id = T3.actor_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of films from the 'film' table that are associated with a specific actor. The query uses inner joins to connect the 'film_actor' table with the 'film' and 'actor' tables, allowing for the retrieval of film titles based on the actor's first and last names provided as placeholders."
        },
        {
            "sample_id": 9372,
            "vt": "SELECT SUM(payment.amount) FROM payment INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]' AND SUBSTRING(payment.payment_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total payment amount made by a specific customer identified by their first and last name. It joins the 'payment' table with the 'customer' table to access the customer's details and filters the results based on the customer's name and a substring of the payment date."
        },
        {
            "sample_id": 9156,
            "vt": "SELECT address.address FROM address INNER JOIN customer AS T2 ON T1.address_id = T2.address_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the address of a customer from the 'address' table by joining it with the 'customer' table. The query filters the results based on the customer's first and last name, which are provided as placeholders."
        },
        {
            "sample_id": 9124,
            "vt": "SELECT COUNT(customer.customer_id) FROM customer INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id WHERE film.release_year = [placeholder-type:numeric] AND customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers who have rented films released in a specific year. It joins the 'customer', 'rental', 'inventory', and 'film' tables to filter based on the release year of the film and the first and last names of the customer."
        },
        {
            "sample_id": 9210,
            "vt": "SELECT film.title FROM customer INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]' AND STRFTIME('%Y', rental.rental_date) = '[placeholder-type:string]' AND STRFTIME('%m', rental.rental_date) = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of films rented by a specific customer identified by their first and last names during a specified year and month. The placeholders in the WHERE clause represent the customer's first name, last name, rental year, and rental month."
        },
        {
            "sample_id": 9236,
            "vt": "SELECT CAST(SUM(CASE WHEN film.rating = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / COUNT(film.film_id) FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rating of films associated with a specific actor based on their first and last names. It sums up the ratings of films that match a specified rating and divides it by the total count of films linked to that actor. The placeholders represent the rating to filter by and the actor's first and last names."
        },
        {
            "sample_id": 9127,
            "vt": "SELECT COUNT(customer.customer_id) FROM customer INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]' AND STRFTIME('%m', rental.return_date) = '[placeholder-type:string]' AND STRFTIME('%Y', rental.return_date) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of rentals associated with a specific customer identified by their first and last names. It filters the results based on the month and year of the rental return date, using placeholders for the customer's name and the date components."
        },
        {
            "sample_id": 9109,
            "vt": "SELECT language.name FROM film INNER JOIN language AS T2 ON T1.language_id = T2.language_id WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table provides the names of languages associated with a specific film title from the 'film' table. It uses an inner join with the 'language' table to match the language ID of the film, allowing users to retrieve the language name based on the film's title provided as a placeholder."
        },
        {
            "sample_id": 9367,
            "vt": "SELECT COUNT(film_category.film_id) FROM category INNER JOIN film_category AS T2 ON T1.category_id = T2.category_id WHERE category.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of films that belong to a specific category from the 'category' and 'film_category' tables. The placeholder in the WHERE clause represents the name of the category."
        },
        {
            "sample_id": 9384,
            "vt": "SELECT city.city FROM city INNER JOIN country AS T2 ON T2.country_id = T1.country_id WHERE country.country = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of cities from the 'city' table that are associated with a specific country. It uses an inner join with the 'country' table to filter cities based on the specified country name."
        },
        {
            "sample_id": 9140,
            "vt": "SELECT COUNT(address.address_id) FROM address WHERE address.district = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of addresses in the 'address' table that belong to a specific district. The placeholder in the WHERE clause represents the district name."
        },
        {
            "sample_id": 9120,
            "vt": "SELECT COUNT(film_category.film_id) FROM film_category INNER JOIN category AS T2 ON T1.category_id = T2.category_id WHERE category.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of films that belong to a specific category from the 'film_category' table. It joins the 'film_category' table with the 'category' table to filter the results based on the category name provided by the user."
        },
        {
            "sample_id": 9185,
            "vt": "SELECT address.address, address.address2, address.district FROM country INNER JOIN city AS T2 ON T1.country_id = T2.country_id INNER JOIN address AS T3 ON T2.city_id = T3.city_id INNER JOIN store AS T4 ON T3.address_id = T4.address_id WHERE store.store_id = [placeholder-type:numeric]",
            "ba": "The virtual table provides the address details including the primary address, secondary address (if any), and district for a specific store identified by its store ID. It retrieves this information by joining the 'country', 'city', 'address', and 'store' tables based on their relationships."
        },
        {
            "sample_id": 9132,
            "vt": "SELECT film.title FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]' ORDER BY film.rental_rate / film.rental_duration LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films featuring a specific actor, identified by their first and last names. It retrieves data from the 'actor', 'film_actor', and 'film' tables, joining them based on the actor's ID and the film's ID. The results are ordered by the rental rate divided by the rental duration, allowing for a ranking of films based on their rental cost efficiency. The query also limits the number of results returned based on a specified numeric placeholder."
        },
        {
            "sample_id": 9373,
            "vt": "SELECT AVG(film.replacement_cost) FROM film WHERE film.rental_rate = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average replacement cost of films from the 'film' table that have a specific rental rate. The placeholder in the WHERE clause represents the rental rate of the films."
        },
        {
            "sample_id": 9276,
            "vt": "SELECT AVG(payment.amount) FROM category INNER JOIN film_category AS T2 ON T1.category_id = T2.category_id INNER JOIN inventory AS T3 ON T2.film_id = T3.film_id INNER JOIN rental AS T4 ON T3.inventory_id = T4.inventory_id INNER JOIN payment AS T5 ON T4.rental_id = T5.rental_id WHERE category.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average payment amount for films that belong to a specific category. It joins multiple tables: 'category' to filter by category name, 'film_category' to link films to their categories, 'inventory' to access the inventory of films, 'rental' to track rentals of those films, and 'payment' to retrieve payment amounts associated with those rentals. The placeholder in the WHERE clause represents the name of the category being queried."
        },
        {
            "sample_id": 9337,
            "vt": "SELECT language.\"name\" FROM film INNER JOIN \"language\" AS T2 ON T1.language_id = T2.language_id WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of languages associated with a specific film title from the 'film' table. The query uses an INNER JOIN to connect the 'film' table with the 'language' table based on the language ID, filtering results to match a specific film title provided by the user."
        },
        {
            "sample_id": 9186,
            "vt": "SELECT COUNT(customer.customer_id) FROM city INNER JOIN address AS T2 ON T1.city_id = T2.city_id INNER JOIN customer AS T3 ON T2.address_id = T3.address_id WHERE city.city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of customers from a specific city by joining the 'city', 'address', and 'customer' tables. It filters the results based on the city name provided as a placeholder."
        },
        {
            "sample_id": 9158,
            "vt": "SELECT payment.amount FROM payment INNER JOIN rental AS T2 ON T1.rental_id = T2.rental_id WHERE rental.rental_date = '[placeholder-type:string]' AND rental.customer_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the payment amounts associated with rentals that occurred on a specific date for a particular customer. It joins the 'payment' table with the 'rental' table to link payments to their corresponding rentals, filtering by the rental date and customer ID."
        },
        {
            "sample_id": 9415,
            "vt": "SELECT COUNT(payment.customer_id) FROM payment INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of payments made by a specific customer identified by their first and last name. It joins the 'payment' table with the 'customer' table to filter the results based on the customer's name."
        },
        {
            "sample_id": 9151,
            "vt": "SELECT staff.first_name, staff.last_name FROM staff INNER JOIN store AS T2 ON T1.store_id = T2.store_id WHERE store.store_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of staff members from the 'staff' table who work at a specific store. The placeholder in the WHERE clause represents the unique identifier of the store."
        },
        {
            "sample_id": 9224,
            "vt": "SELECT film.title FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]' ORDER BY film.replacement_cost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films featuring a specific actor, identified by their first and last names. It retrieves data from the 'actor', 'film_actor', and 'film' tables, joining them based on the actor's ID and the film's ID. The results are ordered by the film's replacement cost, and a limit is applied to the number of titles returned."
        },
        {
            "sample_id": 9393,
            "vt": "SELECT category.name FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of categories associated with a specific film title from the 'film' table. It joins the 'film_category' table to link films to their respective categories and filters the results based on the specified film title."
        },
        {
            "sample_id": 9407,
            "vt": "SELECT address.postal_code FROM address WHERE address.address = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the postal code from the 'address' table based on a specific address provided by the user. The placeholder in the WHERE clause represents the address that the user wants to query."
        },
        {
            "sample_id": 9350,
            "vt": "SELECT film.title FROM film INNER JOIN film_actor AS T2 ON T1.film_id = T2.film_id INNER JOIN actor AS T3 ON T2.actor_id = T3.actor_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of films from the 'film' table that feature a specific actor. It joins the 'film' table with the 'film_actor' table to link films to their respective actors, and then further joins with the 'actor' table to filter by the actor's first and last name. The placeholders in the WHERE clause represent the first and last names of the actor being queried."
        },
        {
            "sample_id": 9383,
            "vt": "SELECT (SELECT T1.title, COUNT(T3.customer_id) AS num FROM film AS T1 INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id INNER JOIN rental AS T3 ON T2.inventory_id = T3.inventory_id WHERE T1.rental_duration > 5 GROUP BY T1.title).title FROM (SELECT film.title, COUNT(rental.customer_id) FROM film AS T1 INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id INNER JOIN rental AS T3 ON T2.inventory_id = T3.inventory_id WHERE T1.rental_duration > 5 GROUP BY T1.title) AS t WHERE (SELECT T1.title, COUNT(T3.customer_id) AS num FROM film AS T1 INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id INNER JOIN rental AS T3 ON T2.inventory_id = T3.inventory_id WHERE T1.rental_duration > 5 GROUP BY T1.title).num > [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of film titles from the 'film' table that have a rental duration greater than a specified number of days. It counts the number of customers who rented each film and filters the results to only include films that have been rented more than a specified number of times. The placeholder in the HAVING clause represents the minimum number of rentals required for a film to be included in the results."
        },
        {
            "sample_id": 9171,
            "vt": "SELECT SUM(payment.amount) FROM payment WHERE payment.rental_id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total amount of payments made for rentals that fall within a specified range of rental IDs. The placeholders represent the lower and upper bounds of the rental ID range."
        },
        {
            "sample_id": 9314,
            "vt": "SELECT (SELECT T2.first_name, T2.last_name, SUM(T1.film_id) AS num FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id GROUP BY T2.first_name, T2.last_name).first_name, (SELECT T2.first_name, T2.last_name, SUM(T1.film_id) AS num FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id GROUP BY T2.first_name, T2.last_name).last_name FROM (SELECT actor.first_name, actor.last_name, SUM(film_actor.film_id) FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id GROUP BY T2.first_name, T2.last_name) AS t ORDER BY (SELECT T2.first_name, T2.last_name, SUM(T1.film_id) AS num FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id GROUP BY T2.first_name, T2.last_name).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of actors along with the total number of films they have acted in, sorted by the number of films in descending order. The query aggregates the film counts for each actor by joining the 'film_actor' and 'actor' tables, and it limits the results to a specified number of top actors."
        },
        {
            "sample_id": 9231,
            "vt": "SELECT inventory.inventory_id FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id INNER JOIN inventory AS T4 ON T3.film_id = T4.film_id WHERE film.length BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the inventory IDs of films that feature a specific actor, filtered by the length of the films. The query joins multiple tables: 'actor', 'film_actor', 'film', and 'inventory' to connect actors to their films and then to the inventory records. The placeholders allow users to specify the length range of the films and the actor's first and last names."
        },
        {
            "sample_id": 9176,
            "vt": "SELECT film.title FROM film INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id WHERE inventory.store_id = [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films available in a specific store from the 'film' table. It joins the 'film' table with the 'inventory' table to filter films based on the store's ID, represented by a placeholder for numeric values."
        },
        {
            "sample_id": 9281,
            "vt": "SELECT DISTINCT category.name, category.category_id, category.last_update FROM category LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of category names along with their unique identifiers and the last update time from the 'category' table. The placeholder in the LIMIT clause allows the user to specify the maximum number of categories to retrieve."
        },
        {
            "sample_id": 9361,
            "vt": "SELECT film.title FROM film_actor INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of films from the 'film' table that are associated with a specific actor. The query joins the 'film_actor' table with the 'actor' table to filter by the actor's first and last name, using placeholders for these values."
        },
        {
            "sample_id": 9198,
            "vt": "SELECT AVG(payment.amount) FROM payment GROUP BY payment.customer_id",
            "ba": "The virtual table calculates the average payment amount made by each customer from the 'payment' table. The placeholder in the GROUP BY clause represents the unique identifier for each customer, allowing for aggregation of payment amounts per customer."
        },
        {
            "sample_id": 9173,
            "vt": "SELECT store.manager_staff_id FROM store WHERE store.store_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the manager's staff ID from the 'store' table based on a specific store ID. The placeholder in the WHERE clause represents the unique identifier for the store."
        },
        {
            "sample_id": 9131,
            "vt": "SELECT (SELECT T1.first_name, T1.last_name, COUNT(T1.customer_id) AS num FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE (T1.first_name = 'RUTH' AND T1.last_name = 'MARTINEZ') OR (T1.first_name = 'LINDA' AND T1.last_name = 'WILLIAMS') GROUP BY T1.first_name, T1.last_name).first_name, (SELECT T1.first_name, T1.last_name, COUNT(T1.customer_id) AS num FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE (T1.first_name = 'RUTH' AND T1.last_name = 'MARTINEZ') OR (T1.first_name = 'LINDA' AND T1.last_name = 'WILLIAMS') GROUP BY T1.first_name, T1.last_name).last_name FROM (SELECT customer.first_name, customer.last_name, COUNT(customer.customer_id) FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE (T1.first_name = 'RUTH' AND T1.last_name = 'MARTINEZ') OR (T1.first_name = 'LINDA' AND T1.last_name = 'WILLIAMS') GROUP BY T1.first_name, T1.last_name) AS t ORDER BY (SELECT T1.first_name, T1.last_name, COUNT(T1.customer_id) AS num FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE (T1.first_name = 'RUTH' AND T1.last_name = 'MARTINEZ') OR (T1.first_name = 'LINDA' AND T1.last_name = 'WILLIAMS') GROUP BY T1.first_name, T1.last_name).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of customers' first and last names along with the count of rentals they have made. It specifically focuses on two customers, identified by their first and last names, and orders the results based on the number of rentals. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 9292,
            "vt": "SELECT COUNT(film.film_id) FROM film INNER JOIN language AS T2 ON T1.language_id = T2.language_id WHERE language.name = '[placeholder-type:string]' AND film.length > [placeholder-type:numeric] AND film.replacement_cost < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of films from the 'film' table that are associated with a specific language and meet certain criteria regarding their length and replacement cost. The placeholders represent the language name, minimum film length, and maximum replacement cost."
        },
        {
            "sample_id": 9126,
            "vt": "SELECT customer.first_name, customer.last_name FROM customer INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id ORDER BY film.replacement_cost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of customers who have rented films, along with the details of the films they rented. It combines data from the 'customer', 'rental', 'inventory', and 'film' tables. The results are ordered by the replacement cost of the films, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 9395,
            "vt": "SELECT actor.last_name FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE film.rating = '[placeholder-type:string]'",
            "ba": "The virtual table describes the last names of actors from the 'actor' table who have acted in films with a specific rating. The query joins the 'actor' table with the 'film_actor' table to link actors to their films, and then joins with the 'film' table to filter by the film's rating. The placeholder in the WHERE clause represents the film rating being queried."
        },
        {
            "sample_id": 9341,
            "vt": "SELECT film.description FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE category.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the main content of films from the 'film' table that belong to a specific category. The query joins the 'film' table with the 'film_category' table to link films to their categories, and then further joins with the 'category' table to filter by the specified category name."
        },
        {
            "sample_id": 9254,
            "vt": "SELECT film.title FROM film WHERE film.rating = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of films from the 'film' table that have a specific rating. The placeholder in the WHERE clause represents the film's rating, allowing users to filter films based on their desired rating category."
        },
        {
            "sample_id": 9225,
            "vt": "SELECT film.title FROM film INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id WHERE inventory.store_id = [placeholder-type:numeric] ORDER BY film.rental_rate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films available in a specific store, ordered by their rental rate. The placeholders represent the store's unique identifier and the limit on the number of results to return."
        },
        {
            "sample_id": 9335,
            "vt": "SELECT film.title FROM film WHERE film.rental_rate = (SELECT MAX(film.rental_rate) FROM film)",
            "ba": "The virtual table lists the titles of films from the 'film' table that have the highest rental rate. The query uses a subquery to find the maximum rental rate among all films and filters the results accordingly."
        },
        {
            "sample_id": 9152,
            "vt": "SELECT address.address, address.address2, address.district FROM address INNER JOIN store AS T2 ON T1.address_id = T2.address_id WHERE store.store_id = [placeholder-type:numeric]",
            "ba": "The virtual table provides the address details including the primary address, secondary address (if any), and district for a specific store identified by its unique store ID. The placeholders in the query allow for dynamic input of the store ID to retrieve the corresponding address information."
        },
        {
            "sample_id": 9397,
            "vt": "SELECT COUNT(film.film_id) FROM film WHERE film.length BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of films from the 'film' table that have a length within a specified range. The placeholders represent the minimum and maximum lengths of the films in minutes."
        },
        {
            "sample_id": 9299,
            "vt": "SELECT customer.first_name FROM customer GROUP BY customer.first_name ORDER BY COUNT(customer.first_name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the first names of customers from the 'customer' table, grouped by their first names. It orders the results based on the count of occurrences of each first name and limits the output to a specified number of entries."
        },
        {
            "sample_id": 9280,
            "vt": "SELECT address.address_id FROM address WHERE address.district = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique address ID from the 'address' table for addresses located in a specific district. The placeholder in the WHERE clause represents the district name."
        },
        {
            "sample_id": 9107,
            "vt": "SELECT DISTINCT film.release_year FROM film WHERE film.replacement_cost = (SELECT MAX(film.replacement_cost) FROM film)",
            "ba": "The virtual table lists the unique release years of films from the 'film' table that have the highest replacement cost. The query uses a subquery to find the maximum replacement cost and filters the results accordingly."
        },
        {
            "sample_id": 9249,
            "vt": "SELECT (SELECT T1.first_name, T1.last_name, COUNT(T1.customer_id) AS num FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id INNER JOIN film_category AS T5 ON T4.film_id = T5.film_id GROUP BY T1.first_name, T1.last_name).first_name, (SELECT T1.first_name, T1.last_name, COUNT(T1.customer_id) AS num FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id INNER JOIN film_category AS T5 ON T4.film_id = T5.film_id GROUP BY T1.first_name, T1.last_name).last_name FROM (SELECT customer.first_name, customer.last_name, COUNT(customer.customer_id) FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id INNER JOIN film_category AS T5 ON T4.film_id = T5.film_id GROUP BY T1.first_name, T1.last_name) AS t WHERE (SELECT T1.first_name, T1.last_name, COUNT(T1.customer_id) AS num FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id INNER JOIN film_category AS T5 ON T4.film_id = T5.film_id GROUP BY T1.first_name, T1.last_name).num > [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of customers along with the count of films they have rented, filtered by a minimum number of rentals. It aggregates data from multiple tables including 'customer', 'rental', 'inventory', 'film', and 'film_category' to determine how many films each customer has rented. The placeholder in the WHERE clause represents the minimum number of rentals a customer must have to be included in the results."
        },
        {
            "sample_id": 9234,
            "vt": "SELECT inventory.inventory_id FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id INNER JOIN inventory AS T4 ON T3.film_id = T4.film_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]' AND film.rental_rate = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the inventory IDs of films associated with a specific actor based on their first and last names, as well as a specified rental rate for those films. It involves joining multiple tables: 'actor', 'film_actor', 'film', and 'inventory' to connect actors to their films and the corresponding inventory details."
        },
        {
            "sample_id": 9108,
            "vt": "SELECT film.title FROM film WHERE film.replacement_cost = (SELECT MAX(film.replacement_cost) FROM film) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films from the 'film' table that have the highest replacement cost. The query uses a subquery to find the maximum replacement cost among all films and limits the results to a specified number of titles."
        },
        {
            "sample_id": 9364,
            "vt": "SELECT actor.first_name, actor.last_name FROM film_actor INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of actors from the 'actor' table who have acted in a specific film. The query joins the 'film_actor' table to link actors to films, and filters the results based on the title of the film using a placeholder for string values."
        },
        {
            "sample_id": 9313,
            "vt": "SELECT (SELECT T1.city, COUNT(T3.customer_id) AS num FROM city AS T1 INNER JOIN address AS T2 ON T2.city_id = T1.city_id INNER JOIN customer AS T3 ON T2.address_id = T3.address_id GROUP BY T1.city).city FROM (SELECT city.city, COUNT(customer.customer_id) FROM city AS T1 INNER JOIN address AS T2 ON T2.city_id = T1.city_id INNER JOIN customer AS T3 ON T2.address_id = T3.address_id GROUP BY T1.city) AS t ORDER BY (SELECT T1.city, COUNT(T3.customer_id) AS num FROM city AS T1 INNER JOIN address AS T2 ON T2.city_id = T1.city_id INNER JOIN customer AS T3 ON T2.address_id = T3.address_id GROUP BY T1.city).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of cities along with the count of customers associated with each city from the 'city', 'address', and 'customer' tables. The result is ordered by the number of customers in descending order, and a limit is applied to restrict the number of cities returned."
        },
        {
            "sample_id": 9274,
            "vt": "SELECT film.title FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id ORDER BY film.length LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films from the 'film' table that are associated with specific categories. It joins the 'film' table with the 'film_category' table to link films to their respective categories, and then further joins with the 'category' table to access category details. The results are ordered by the length of the films and limited to a specified number of entries."
        },
        {
            "sample_id": 9294,
            "vt": "SELECT film.title FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films featuring a specific actor identified by their first and last name. It joins the 'actor' table with the 'film_actor' table to link actors to their respective films, and then joins with the 'film' table to retrieve the film titles. The placeholders in the WHERE clause represent the actor's first and last names, while the LIMIT placeholder specifies the maximum number of film titles to return."
        },
        {
            "sample_id": 9344,
            "vt": "SELECT category.name FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T3.category_id = T2.category_id WHERE film.title = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of categories associated with a specific film title from the 'film' table. It joins the 'film_category' table to link films to their respective categories and filters the results based on the specified film title."
        },
        {
            "sample_id": 9356,
            "vt": "SELECT film.title FROM film WHERE film.replacement_cost = [placeholder-type:numeric] AND film.rating = '[placeholder-type:string]' AND film.length = [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films from the 'film' table that meet specific criteria regarding their replacement cost, rating, and length. The placeholders represent the values for replacement cost (numeric), film rating (string), and film length (numeric)."
        },
        {
            "sample_id": 9116,
            "vt": "SELECT actor.first_name, actor.last_name FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id ORDER BY film.replacement_cost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of actors from the 'actor' table who have appeared in films. It joins the 'actor' table with the 'film_actor' table to link actors to their respective films, and then further joins with the 'film' table to access film details. The results are ordered by the replacement cost of the films, and a limit is applied to restrict the number of returned records."
        },
        {
            "sample_id": 9161,
            "vt": "SELECT (SELECT T2.name, COUNT(T1.film_id) AS num FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id GROUP BY T2.name).name FROM (SELECT category.name, COUNT(film_category.film_id) FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id GROUP BY T2.name) AS t ORDER BY (SELECT T2.name, COUNT(T1.film_id) AS num FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id GROUP BY T2.name).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of film categories along with the count of films in each category, ordered by the number of films. The placeholder in the LIMIT clause allows the user to specify how many categories they want to retrieve."
        },
        {
            "sample_id": 9237,
            "vt": "SELECT address.address FROM address WHERE address.district = '[placeholder-type:string]' AND address.city_id = (SELECT MIN(address.city_id) FROM address WHERE district = 'Texas')",
            "ba": "The virtual table retrieves the address of locations in a specific district from the 'address' table. It filters the results based on the district name provided by the user and ensures that the city_id corresponds to the minimum city_id for that district, which is specifically set to 'Texas'."
        },
        {
            "sample_id": 9217,
            "vt": "SELECT customer.email, address.address, city.city, country.country FROM customer INNER JOIN address AS T2 ON T1.address_id = T2.address_id INNER JOIN city AS T3 ON T2.city_id = T3.city_id INNER JOIN country AS T4 ON T3.country_id = T4.country_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of customer emails along with their corresponding addresses, cities, and countries. It retrieves this information by joining the 'customer' table with the 'address', 'city', and 'country' tables based on their respective foreign key relationships. The placeholders in the WHERE clause allow for filtering the results based on the customer's first and last names."
        },
        {
            "sample_id": 9381,
            "vt": "SELECT COUNT(customer.customer_id) FROM customer WHERE customer.active = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of customers from the 'customer' table who are either active or inactive based on the specified condition. The placeholder in the WHERE clause represents the active status of the customers, where 1 indicates active and 0 indicates inactive."
        },
        {
            "sample_id": 9396,
            "vt": "SELECT AVG(film.rental_rate) FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rental rate of films associated with a specific actor identified by their first and last name. It joins the 'actor' table with the 'film_actor' table to link actors to their films, and then joins with the 'film' table to access the rental rate of those films. The placeholders in the WHERE clause represent the first and last names of the actor."
        },
        {
            "sample_id": 9106,
            "vt": "SELECT staff.first_name, staff.last_name FROM staff WHERE staff.active = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of staff members from the 'staff' table who are currently active. The placeholder in the WHERE clause represents the active status of the staff, where 1 indicates active and 0 indicates not active."
        },
        {
            "sample_id": 9181,
            "vt": "SELECT (SELECT T2.first_name, T2.last_name, COUNT(T1.film_id) AS num FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id GROUP BY T2.first_name, T2.last_name).first_name, (SELECT T2.first_name, T2.last_name, COUNT(T1.film_id) AS num FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id GROUP BY T2.first_name, T2.last_name).last_name FROM (SELECT actor.first_name, actor.last_name, COUNT(film_actor.film_id) FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id GROUP BY T2.first_name, T2.last_name) AS t ORDER BY (SELECT T2.first_name, T2.last_name, COUNT(T1.film_id) AS num FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id GROUP BY T2.first_name, T2.last_name).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of actors along with the count of films they have appeared in, sorted by the number of films in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return."
        },
        {
            "sample_id": 9245,
            "vt": "SELECT (SELECT T1.first_name, T1.last_name, COUNT(T2.film_id) AS num FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film_category AS T3 ON T2.film_id = T3.film_id WHERE T3.category_id = 7 GROUP BY T1.first_name, T1.last_name).first_name, (SELECT T1.first_name, T1.last_name, COUNT(T2.film_id) AS num FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film_category AS T3 ON T2.film_id = T3.film_id WHERE T3.category_id = 7 GROUP BY T1.first_name, T1.last_name).last_name FROM (SELECT actor.first_name, actor.last_name, COUNT(film_actor.film_id) FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film_category AS T3 ON T2.film_id = T3.film_id WHERE T3.category_id = 7 GROUP BY T1.first_name, T1.last_name) AS t ORDER BY (SELECT T1.first_name, T1.last_name, COUNT(T2.film_id) AS num FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film_category AS T3 ON T2.film_id = T3.film_id WHERE T3.category_id = 7 GROUP BY T1.first_name, T1.last_name).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of actors along with the count of films they have acted in for a specific category. The results are ordered by the number of films in descending order, and a limit can be applied to restrict the number of results returned."
        },
        {
            "sample_id": 9209,
            "vt": "SELECT film.title FROM film INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id INNER JOIN rental AS T3 ON T2.inventory_id = T3.inventory_id WHERE SUBSTRING(rental.rental_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the titles of films that have been rented on a specific date. It joins the 'film' table with the 'inventory' table to link films to their inventory records, and then further joins with the 'rental' table to filter based on the rental date. The placeholders allow users to specify the exact date they are interested in."
        },
        {
            "sample_id": 9329,
            "vt": "SELECT SUM(payment.amount) FROM payment INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id INNER JOIN address AS T3 ON T3.address_id = T2.address_id WHERE address.district = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total payment amounts made by customers who reside in a specific district. It combines data from the 'payment', 'customer', and 'address' tables to calculate the sum of payments for customers filtered by their district."
        },
        {
            "sample_id": 9408,
            "vt": "SELECT COUNT(customer.customer_id) FROM customer WHERE customer.active = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of customers from the 'customer' table based on their active status. The placeholder in the WHERE clause represents whether the customer is active or not, where 1 indicates active and 0 indicates not active."
        },
        {
            "sample_id": 9414,
            "vt": "SELECT payment.amount FROM payment INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE customer.first_name = '[placeholder-type:string]' AND customer.last_name = '[placeholder-type:string]' ORDER BY payment.amount LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the payment amounts made by a specific customer identified by their first and last names. It joins the 'payment' table with the 'customer' table to filter the results based on the customer's name, and it orders the results by the payment amount, limiting the number of results returned."
        },
        {
            "sample_id": 9148,
            "vt": "SELECT film.rating FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]' AND film.length = [placeholder-type:numeric] AND film.replacement_cost = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the ratings of films associated with a specific actor based on their first and last names, as well as the film's length and replacement cost. It involves joining the 'actor', 'film_actor', and 'film' tables to filter the results accordingly."
        },
        {
            "sample_id": 9206,
            "vt": "SELECT category.name FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id INNER JOIN film_category AS T4 ON T2.film_id = T4.film_id INNER JOIN category AS T5 ON T4.category_id = T5.category_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of categories associated with films in which a specific actor has appeared. It retrieves this information by joining multiple tables: 'actor', 'film_actor', 'film', 'film_category', and 'category'. The placeholders in the WHERE clause represent the first and last names of the actor."
        },
        {
            "sample_id": 9412,
            "vt": "SELECT customer.first_name, customer.last_name FROM address INNER JOIN city AS T2 ON T1.city_id = T2.city_id INNER JOIN country AS T3 ON T2.country_id = T3.country_id INNER JOIN customer AS T4 ON T1.address_id = T4.address_id WHERE country.country = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of customers from the 'customer' table who reside in a specific country. It joins the 'address', 'city', and 'country' tables to filter customers based on their country of residence. The placeholder in the WHERE clause represents the name of the country."
        },
        {
            "sample_id": 9257,
            "vt": "SELECT SUM(payment.amount) FROM payment WHERE payment.payment_date LIKE '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total amount of payments made on a specific date from the 'payment' table. The placeholder in the WHERE clause represents the date for which the total payment amount is being calculated."
        },
        {
            "sample_id": 9325,
            "vt": "SELECT film.title FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T3.category_id = T2.category_id WHERE category.\"name\" = '[placeholder-type:string]' AND film.length > [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of films from the 'film' table that belong to a specific category and have a length greater than a specified duration. The query uses inner joins to connect the 'film', 'film_category', and 'category' tables, filtering results based on the category name and the film length."
        },
        {
            "sample_id": 9363,
            "vt": "SELECT film.title, category.name, film.special_features FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE film.rental_duration * film.rental_rate > [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of films, their associated categories, and any special features they may have from the 'film' table. It joins the 'film_category' table to link films with their categories and filters the results based on a condition that checks if the product of rental duration and rental rate exceeds a specified numeric value."
        },
        {
            "sample_id": 9175,
            "vt": "SELECT film.title FROM actor INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE actor.first_name = '[placeholder-type:string]' AND actor.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of films associated with a specific actor identified by their first and last name. It combines data from the 'actor', 'film_actor', and 'film' tables to achieve this."
        },
        {
            "sample_id": 9192,
            "vt": "SELECT (SELECT T1.first_name, T1.last_name, COUNT(T2.film_id) AS num FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T3.rating = 'R' GROUP BY T1.first_name, T1.last_name).first_name, (SELECT T1.first_name, T1.last_name, COUNT(T2.film_id) AS num FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T3.rating = 'R' GROUP BY T1.first_name, T1.last_name).last_name FROM (SELECT actor.first_name, actor.last_name, COUNT(film_actor.film_id) FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T3.rating = 'R' GROUP BY T1.first_name, T1.last_name) AS t ORDER BY (SELECT T1.first_name, T1.last_name, COUNT(T2.film_id) AS num FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T3.rating = 'R' GROUP BY T1.first_name, T1.last_name).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of actors who have appeared in films rated 'R', along with the count of such films they have acted in. The results are ordered by the number of 'R' rated films each actor has participated in, and the output is limited to a specified number of results."
        },
        {
            "sample_id": 9130,
            "vt": "SELECT (SELECT T1.title, COUNT(T3.rental_id) AS num FROM film AS T1 INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id INNER JOIN rental AS T3 ON T2.inventory_id = T3.inventory_id GROUP BY T1.title).title FROM (SELECT film.title, COUNT(rental.rental_id) FROM film AS T1 INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id INNER JOIN rental AS T3 ON T2.inventory_id = T3.inventory_id GROUP BY T1.title) AS t ORDER BY (SELECT T1.title, COUNT(T3.rental_id) AS num FROM film AS T1 INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id INNER JOIN rental AS T3 ON T2.inventory_id = T3.inventory_id GROUP BY T1.title).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of film titles along with the count of how many times each film has been rented. It aggregates data from the 'film', 'inventory', and 'rental' tables, counting the rental occurrences for each film title. The results are ordered by the number of rentals in descending order, and a limit is applied to restrict the number of titles returned."
        },
        {
            "sample_id": 9328,
            "vt": "SELECT film.description FROM film INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE category.\"name\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the main content of films from the 'film' table that belong to a specific category. The query joins the 'film' table with the 'film_category' table to link films to their categories, and then further joins with the 'category' table to filter by the specified category name."
        },
        {
            "sample_id": 9399,
            "vt": "SELECT COUNT(customer.customer_id) FROM customer WHERE customer.first_name = '[placeholder-type:string]' AND customer.active = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of customers from the 'customer' table who have a specific first name and are marked as active or inactive. The placeholders represent the customer's first name and their active status."
        }
    ],
    "sales_in_weather": [
        {
            "sample_id": 8191,
            "vt": "SELECT relation.station_nbr FROM sales_in_weather INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr ORDER BY sales_in_weather.units LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the weather station numbers associated with specific stores from the 'sales_in_weather' and 'relation' tables. It uses an inner join to connect the two tables based on the store number, ensuring that only relevant records are included. The results are ordered by the quantity of units sold, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 8206,
            "vt": "SELECT relation.station_nbr, sales_in_weather.item_nbr FROM relation INNER JOIN sales_in_weather AS T2 ON T1.store_nbr = T2.store_nbr WHERE relation.store_nbr = [placeholder-type:numeric] GROUP BY relation.station_nbr, sales_in_weather.item_nbr",
            "ba": "The virtual table retrieves the weather station numbers and item numbers sold from the 'relation' and 'sales_in_weather' tables. It joins these tables based on the store number, filtering results for a specific store number provided as a placeholder. The results are grouped by both the weather station number and item number to aggregate the data appropriately."
        },
        {
            "sample_id": 8144,
            "vt": "SELECT sales_in_weather.units FROM sales_in_weather INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr WHERE relation.store_nbr = [placeholder-type:numeric] AND SUBSTRING(sales_in_weather.\"date\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND sales_in_weather.item_nbr = [placeholder-type:numeric] ORDER BY weather.tmax LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the quantity of items sold from the 'sales_in_weather' table, filtered by a specific store number and item number. It joins the 'sales_in_weather' table with the 'relation' table to link stores with their corresponding weather stations, and then further joins with the 'weather' table to access weather data. The query also includes a condition to filter sales by a specific date substring and orders the results by maximum temperature, limiting the output to a specified number of records."
        },
        {
            "sample_id": 8211,
            "vt": "SELECT SUM(CASE WHEN relation.station_nbr = [placeholder-type:numeric] THEN sales_in_weather.units ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN relation.station_nbr = [placeholder-type:numeric] THEN sales_in_weather.units ELSE [placeholder-type:numeric] END) FROM relation INNER JOIN sales_in_weather AS T2 ON T1.store_nbr = T2.store_nbr WHERE sales_in_weather.\"date\" LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference in total units sold for a specific store based on weather station data. It uses a conditional sum to aggregate the units sold from the 'sales_in_weather' table, filtered by the store number from the 'relation' table. The query also includes a date filter to specify the sales date."
        },
        {
            "sample_id": 8216,
            "vt": "SELECT (SELECT CAST(SUM(weather.tavg) AS FLOAT) / COUNT(weather.\"date\") FROM weather AS T1 INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr AND T1.\"date\" LIKE '%2012-05%' AND T2.store_nbr = 6) - (SELECT CAST(SUM(weather.tavg) AS FLOAT) / COUNT(weather.\"date\") FROM weather AS T1 INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE T1.\"date\" LIKE '%2012-05%' AND T2.store_nbr = 7)",
            "ba": "The virtual table calculates the difference in average temperatures for two specific stores during a given month. It does this by first summing the average temperatures from the 'weather' table for store number 6 and dividing by the count of dates to get the average for that store. Then, it performs a similar calculation for store number 7. The final result is the difference between these two average temperatures."
        },
        {
            "sample_id": 8179,
            "vt": "SELECT COUNT(sales_in_weather.item_nbr) FROM sales_in_weather WHERE sales_in_weather.store_nbr = [placeholder-type:numeric] AND sales_in_weather.units = [placeholder-type:numeric] AND sales_in_weather.\"date\" = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of items sold from the 'sales_in_weather' table for a specific store on a given date, filtering by the store number and the quantity of units sold."
        },
        {
            "sample_id": 8153,
            "vt": "SELECT sales_in_weather.item_nbr FROM sales_in_weather INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr WHERE sales_in_weather.store_nbr = [placeholder-type:numeric] AND sales_in_weather.\"date\" LIKE '[placeholder-type:string]' AND weather.tmax = (SELECT MAX(weather.tmax) FROM sales_in_weather AS T1 INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr WHERE T1.store_nbr = 3 AND T1.\"date\" LIKE '%2012%') GROUP BY sales_in_weather.item_nbr ORDER BY SUM(sales_in_weather.units) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves item numbers from the 'sales_in_weather' table for a specific store on a given date, while also considering the maximum temperature recorded on that date. It joins the 'sales_in_weather' table with the 'relation' table to link stores with their corresponding weather stations, and then further joins with the 'weather' table to access temperature data. The query filters results based on the store number and date, and it groups the results by item number, ordering them by the total units sold, with a limit on the number of results returned."
        },
        {
            "sample_id": 8186,
            "vt": "SELECT sales_in_weather.item_nbr FROM sales_in_weather INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr WHERE weather.station_nbr = [placeholder-type:numeric] AND sales_in_weather.\"date\" LIKE '[placeholder-type:string]' AND weather.codesum = '[placeholder-type:string]' ORDER BY sales_in_weather.units LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves item numbers from the 'sales_in_weather' table, filtering based on specific weather conditions and store associations. It joins the 'sales_in_weather' table with the 'relation' table to link stores with their corresponding weather stations, and then further joins with the 'weather' table to apply conditions based on the weather station number, date, and weather codes. The results are ordered by the quantity of units sold and limited to a specified number of results."
        },
        {
            "sample_id": 8187,
            "vt": "SELECT relation.station_nbr FROM sales_in_weather INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr WHERE sales_in_weather.item_nbr = [placeholder-type:numeric] GROUP BY relation.station_nbr ORDER BY SUM(sales_in_weather.units) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the weather station numbers associated with specific stores based on sales data. It joins the 'sales_in_weather' table with the 'relation' table to find the corresponding weather stations for stores that sold a particular item. The results are grouped by the weather station number and ordered by the total quantity of units sold, with a limit on the number of results returned."
        },
        {
            "sample_id": 8215,
            "vt": "SELECT SUM(sales_in_weather.units) FROM weather INNER JOIN sales_in_weather AS T5 ON T4.\"date\" = T5.\"date\" INNER JOIN relation AS T6 ON T5.store_nbr = T6.store_nbr WHERE sales_in_weather.item_nbr = [placeholder-type:numeric] AND weather.tavg < (SELECT AVG(weather.tavg) FROM weather AS T1 INNER JOIN sales_in_weather AS T2 ON T1.\"date\" = T2.\"date\" INNER JOIN relation AS T3 ON T2.store_nbr = T3.store_nbr WHERE T2.item_nbr = 10)",
            "ba": "The virtual table summarizes the total quantity of a specific item sold from the 'sales_in_weather' table, filtered by weather conditions. It joins the 'weather' and 'relation' tables to correlate sales data with weather data based on the date and store number. The query also includes a condition to compare the average temperature of the weather data against a subquery that calculates the average temperature for a specific item, allowing for analysis of sales performance under varying temperature conditions."
        },
        {
            "sample_id": 8148,
            "vt": "SELECT sales_in_weather.\"date\" FROM relation INNER JOIN sales_in_weather AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T1.station_nbr = T3.station_nbr WHERE sales_in_weather.store_nbr = [placeholder-type:numeric] AND sales_in_weather.item_nbr = [placeholder-type:numeric] AND sales_in_weather.units > [placeholder-type:numeric] ORDER BY weather.tmax - weather.tmin LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the sales dates from the 'sales_in_weather' table for specific stores and items, while also considering the weather conditions. It joins the 'relation' table to link stores with their corresponding weather stations, and then joins the 'weather' table to access temperature data. The query filters results based on store number, item number, and a minimum quantity sold, ordering the results by the temperature difference (maximum minus minimum) and limiting the number of results returned."
        },
        {
            "sample_id": 8209,
            "vt": "SELECT sales_in_weather.item_nbr FROM weather INNER JOIN sales_in_weather AS T2 ON T1.\"date\" = T2.\"date\" INNER JOIN relation AS T3 ON T2.store_nbr = T3.store_nbr AND T1.station_nbr = T3.station_nbr WHERE sales_in_weather.store_nbr = [placeholder-type:numeric] AND weather.codesum LIKE '[placeholder-type:string]' OR '[placeholder-type:string]' OR '[placeholder-type:string]' GROUP BY sales_in_weather.item_nbr ORDER BY sales_in_weather.units LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves item numbers from the 'sales_in_weather' table based on specific weather conditions and store identifiers. It joins the 'weather' table with 'sales_in_weather' using the date, and also connects to the 'relation' table to match store and weather station numbers. The query filters results for a specific store number and checks if the weather code summary matches any of the specified conditions. The results are grouped by item number and ordered by the quantity sold, with a limit on the number of results returned."
        },
        {
            "sample_id": 8185,
            "vt": "SELECT sales_in_weather.store_nbr FROM sales_in_weather INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr WHERE relation.station_nbr = [placeholder-type:numeric] AND sales_in_weather.\"date\" LIKE '[placeholder-type:string]' AND sales_in_weather.item_nbr = [placeholder-type:numeric] AND sales_in_weather.units >= [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the store numbers from the 'sales_in_weather' table that have sales data for a specific item on a given date, while also ensuring that the store is associated with a particular weather station. The query filters results based on the weather station number, the date of sales, the item number, and a minimum quantity of units sold."
        },
        {
            "sample_id": 8201,
            "vt": "SELECT weather.tmax, weather.tmin FROM weather WHERE weather.station_nbr = [placeholder-type:numeric] AND weather.\"date\" = '[placeholder-type:string]'",
            "ba": "The virtual table provides the maximum and minimum temperatures recorded at a specific weather station on a given date. The placeholders allow users to specify the weather station's identifier and the date for which they want to retrieve temperature data."
        },
        {
            "sample_id": 8204,
            "vt": "SELECT SUM(sales_in_weather.units) FROM weather INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr INNER JOIN sales_in_weather AS T3 ON T2.store_nbr = T3.store_nbr WHERE relation.store_nbr = [placeholder-type:numeric] AND sales_in_weather.item_nbr = [placeholder-type:numeric] AND weather.snowfall < [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total quantity of a specific item sold from the 'sales_in_weather' table, filtered by a specific store and snowfall conditions. It combines data from the 'weather', 'relation', and 'sales_in_weather' tables to achieve this."
        },
        {
            "sample_id": 8173,
            "vt": "SELECT weather.preciptotal FROM weather INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE weather.\"date\" = '[placeholder-type:string]' AND relation.store_nbr = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the total precipitation recorded on a specific date for a particular store by joining the 'weather' and 'relation' tables. The placeholders represent the date and store number for which the precipitation data is being queried."
        },
        {
            "sample_id": 8161,
            "vt": "SELECT relation.station_nbr FROM relation GROUP BY relation.station_nbr ORDER BY COUNT(relation.station_nbr) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a list of unique weather station numbers from the 'relation' table, grouping them to count occurrences and ordering the results based on the frequency of each station number. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 8158,
            "vt": "SELECT sales_in_weather.units FROM sales_in_weather WHERE sales_in_weather.\"date\" = '[placeholder-type:string]' AND sales_in_weather.store_nbr = [placeholder-type:numeric] AND sales_in_weather.item_nbr = [placeholder-type:numeric]",
            "ba": "The virtual table describes the quantity of items sold from the 'sales_in_weather' table for a specific date, store number, and item number. The placeholders in the WHERE clause represent the date, store number, and item number respectively."
        },
        {
            "sample_id": 8199,
            "vt": "SELECT COUNT(DISTINCT \"date\") FROM weather WHERE weather.sunrise < TIME('[placeholder-type:string]')",
            "ba": "The virtual table counts the distinct dates from the 'weather' table where the sunrise time is earlier than a specified time. The placeholder in the WHERE clause represents the time to compare against."
        },
        {
            "sample_id": 8212,
            "vt": "SELECT SUM(CASE WHEN relation.store_nbr = [placeholder-type:numeric] THEN weather.tavg ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN relation.store_nbr = [placeholder-type:numeric] THEN weather.tavg ELSE [placeholder-type:numeric] END) FROM relation INNER JOIN weather AS T2 ON T1.station_nbr = T2.station_nbr WHERE weather.\"date\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference in average temperatures for a specific store on a given date by summing the average temperatures from the weather data associated with that store. The placeholders represent the store number and the date for which the temperature difference is being calculated."
        },
        {
            "sample_id": 8188,
            "vt": "SELECT relation.station_nbr FROM relation INNER JOIN weather AS T2 ON T1.station_nbr = T2.station_nbr WHERE NOT weather.sunrise IS NULL AND weather.\"date\" LIKE '[placeholder-type:string]' AND relation.station_nbr IN (SELECT weather.station_nbr FROM relation GROUP BY station_nbr HAVING COUNT(store_nbr) = 1) ORDER BY weather.sunrise LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the station numbers from the 'relation' table that are associated with weather data. It filters the results to include only those records where the sunrise time is not null and the date matches a specified pattern. Additionally, it ensures that the station numbers are unique to a single store by checking that they appear only once in the 'relation' table. The results are ordered by sunrise time and limited to a specified number of entries."
        },
        {
            "sample_id": 8182,
            "vt": "SELECT weather.station_nbr FROM weather WHERE SUBSTRING(weather.\"date\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND SUBSTRING(weather.\"date\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND weather.depart < [placeholder-type:numeric] GROUP BY weather.station_nbr HAVING COUNT(DISTINCT \"date\") = (SELECT COUNT(DISTINCT \"date\") FROM weather WHERE SUBSTRING(\"date\", 1, 4) = '2014' AND SUBSTRING(\"date\", 6, 2) = '03' AND depart < 0 GROUP BY station_nbr ORDER BY COUNT(\"date\") DESC LIMIT 1)",
            "ba": "The virtual table identifies weather stations based on specific date criteria and temperature departures. It filters the weather data for a particular month and year, checking if the temperature departure is below a certain threshold. The results are grouped by station number, and only those stations with a count of distinct dates matching a subquery condition are returned."
        },
        {
            "sample_id": 8154,
            "vt": "SELECT COUNT(DISTINCT T1.item_nbr) FROM sales_in_weather INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr AND T1.store_nbr = 3 AND SUBSTRING(T1.\"date\", 1, 4) = '2012' AND T1.units = 0 GROUP BY weather.tmax ORDER BY weather.tmax LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of items sold from the 'sales_in_weather' table for a specific store in the year 2012, where no units were sold. It joins the 'sales_in_weather' table with the 'relation' table to link stores with their corresponding weather stations, and then further joins with the 'weather' table to access weather data. The results are grouped by the maximum temperature recorded, and the output is limited to a specified number of results."
        },
        {
            "sample_id": 8210,
            "vt": "SELECT CAST((MAX(weather.tmax) - MIN(weather.tmin)) AS FLOAT) / MIN(weather.tmin) FROM weather INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE relation.store_nbr = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the temperature range difference as a ratio of the maximum temperature to the minimum temperature for a specific store. It joins the 'weather' table with the 'relation' table to link weather data to store information, filtering by a specific store number."
        },
        {
            "sample_id": 8213,
            "vt": "SELECT SUM(sales_in_weather.units) FROM weather INNER JOIN sales_in_weather AS T2 ON T1.\"date\" = T2.\"date\" INNER JOIN relation AS T3 ON T2.store_nbr = T3.store_nbr WHERE sales_in_weather.item_nbr = [placeholder-type:numeric] AND weather.tavg = [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total quantity of a specific item sold on a given date, by joining sales data with weather data and store relations. It filters the results based on the item number and the average temperature recorded on that date."
        },
        {
            "sample_id": 8176,
            "vt": "SELECT CAST((SUM(CASE WHEN weather.\"date\" = '[placeholder-type:string]' THEN weather.tavg * [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN weather.\"date\" = '[placeholder-type:string]' THEN weather.tavg * [placeholder-type:numeric] ELSE [placeholder-type:numeric] END)) AS FLOAT) * [placeholder-type:numeric] / SUM(CASE WHEN weather.\"date\" = '[placeholder-type:string]' THEN weather.tavg * [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM weather INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE relation.store_nbr = [placeholder-type:numeric]",
            "ba": "The virtual table calculates a specific temperature-related metric based on average temperatures from the 'weather' table, adjusted by certain factors. It uses a combination of conditional summation and joins to relate sales data from the 'sales_in_weather' table with weather data through the 'relation' table. The placeholders represent specific dates, numeric factors for calculations, and store identifiers, allowing users to customize the query for different stores and conditions."
        },
        {
            "sample_id": 8207,
            "vt": "SELECT weather.\"date\" FROM weather INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE relation.store_nbr = [placeholder-type:numeric] AND weather.codesum LIKE '[placeholder-type:string]' OR '[placeholder-type:string]' OR '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the dates from the 'weather' table for specific stores based on weather conditions. It joins the 'weather' table with the 'relation' table to link weather data to store information. The query filters results for a particular store number and checks if the weather code summary matches any of the specified conditions."
        },
        {
            "sample_id": 8150,
            "vt": "SELECT sales_in_weather.\"date\" FROM sales_in_weather INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr WHERE relation.store_nbr = [placeholder-type:numeric] AND sales_in_weather.item_nbr = [placeholder-type:numeric] AND sales_in_weather.units > [placeholder-type:numeric] AND weather.avgspeed > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the sales date from the 'sales_in_weather' table for a specific store and item, while also ensuring that the quantity sold exceeds a certain threshold and that the average wind speed recorded at the corresponding weather station is above a specified value. The placeholders represent the store number, item number, minimum units sold, and minimum average wind speed."
        },
        {
            "sample_id": 8142,
            "vt": "SELECT CASE WHEN (SUM(CASE WHEN weather.\"date\" = '[placeholder-type:string]' THEN weather.avgspeed ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN weather.\"date\" = '[placeholder-type:string]' THEN weather.avgspeed ELSE [placeholder-type:numeric] END)) > [placeholder-type:numeric] THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM weather WHERE weather.station_nbr = [placeholder-type:numeric]",
            "ba": "The virtual table calculates a conditional result based on the average wind speed from the 'weather' table for a specific date and weather station. It uses placeholders to allow users to specify the date, a numeric threshold for comparison, and the output strings based on the condition evaluated."
        },
        {
            "sample_id": 8192,
            "vt": "SELECT COUNT(relation.store_nbr) FROM (SELECT weather.station_nbr FROM weather ORDER BY heat DESC LIMIT 1) AS t1 INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr",
            "ba": "The virtual table counts the number of stores associated with the weather station that has the highest heating degree from the 'weather' table. It first identifies the station with the maximum heating degree and then joins this information with the 'relation' table to find the corresponding stores."
        },
        {
            "sample_id": 8157,
            "vt": "SELECT sales_in_weather.item_nbr FROM sales_in_weather WHERE sales_in_weather.\"date\" = '[placeholder-type:string]' AND sales_in_weather.store_nbr = [placeholder-type:numeric] ORDER BY sales_in_weather.units LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the item numbers from the 'sales_in_weather' table for a specific date and store number. The results are ordered by the quantity of units sold, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 8137,
            "vt": "SELECT sales_in_weather.units FROM sales_in_weather WHERE sales_in_weather.\"date\" = '[placeholder-type:string]' AND sales_in_weather.store_nbr = [placeholder-type:numeric] AND sales_in_weather.item_nbr = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the quantity of items sold from the 'sales_in_weather' table for a specific date, store number, and item number. The placeholders represent the date as a string, and the store and item numbers as numeric values."
        },
        {
            "sample_id": 8196,
            "vt": "SELECT CAST(SUM(CASE WHEN sales_in_weather.store_nbr = [placeholder-type:numeric] THEN sales_in_weather.units * [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(sales_in_weather.units) FROM relation INNER JOIN sales_in_weather AS T2 ON T1.store_nbr = T2.store_nbr WHERE relation.station_nbr = [placeholder-type:numeric] AND sales_in_weather.item_nbr = [placeholder-type:numeric] AND sales_in_weather.\"date\" LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of units sold for a specific item in a specific store on a given date, adjusted by a specified factor. It joins the 'relation' table with the 'sales_in_weather' table to filter sales data based on store and weather station identifiers. The query uses placeholders for the store number, adjustment factor, item number, and date to allow for dynamic input."
        },
        {
            "sample_id": 8172,
            "vt": "SELECT weather.sealevel FROM weather INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE weather.\"date\" = '[placeholder-type:string]' AND relation.store_nbr = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the sea level data from the 'weather' table for a specific date and store number. It joins the 'weather' table with the 'relation' table to link weather stations with stores, ensuring that the data corresponds to the correct store and date."
        },
        {
            "sample_id": 8169,
            "vt": "SELECT weather.sunrise FROM weather INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE weather.\"date\" = '[placeholder-type:string]' AND relation.store_nbr = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the sunrise time from the 'weather' table for a specific date and store number. It joins the 'weather' table with the 'relation' table to link weather data to the corresponding store."
        },
        {
            "sample_id": 8147,
            "vt": "SELECT t2.units FROM relation INNER JOIN sales_in_weather AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T1.station_nbr = T3.station_nbr WHERE sales_in_weather.store_nbr = [placeholder-type:numeric] AND sales_in_weather.item_nbr = [placeholder-type:numeric] ORDER BY t3.tmax - t3.tmin LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the quantity of units sold for a specific item in a specific store, while also considering the weather conditions associated with that store. It joins the 'relation' table to link stores with their corresponding weather stations, and then joins the 'sales_in_weather' table to get the sales data. The results are filtered by store number and item number, and are ordered by the temperature difference (maximum temperature minus minimum temperature) from the 'weather' table, with a limit on the number of results returned."
        },
        {
            "sample_id": 8205,
            "vt": "SELECT COUNT(DISTINCT item_nbr) FROM weather INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr INNER JOIN sales_in_weather AS T3 ON T2.store_nbr = T3.store_nbr WHERE sales_in_weather.store_nbr = [placeholder-type:numeric] AND weather.snowfall <> [placeholder-type:numeric] AND NOT weather.snowfall IS NULL",
            "ba": "The virtual table counts the distinct number of items sold from the 'sales_in_weather' table, filtered by a specific store number and ensuring that there is snowfall recorded in the 'weather' table. The query joins the 'weather' and 'relation' tables to link weather data with store data, while also excluding records where snowfall is null or equal to a specified value."
        },
        {
            "sample_id": 8139,
            "vt": "SELECT sales_in_weather.item_nbr FROM sales_in_weather WHERE sales_in_weather.\"date\" = '[placeholder-type:string]' AND sales_in_weather.store_nbr = [placeholder-type:numeric] ORDER BY sales_in_weather.units LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the item numbers from the 'sales_in_weather' table for a specific date and store number. The results are ordered by the quantity of units sold, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 8140,
            "vt": "SELECT weather.tmax - weather.tmin FROM weather WHERE weather.station_nbr = [placeholder-type:numeric] AND weather.\"date\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the temperature difference between the maximum and minimum temperatures recorded at a specific weather station on a given date. The placeholders represent the weather station's ID and the date for which the temperature difference is being queried."
        },
        {
            "sample_id": 8175,
            "vt": "SELECT CAST(SUM(CASE WHEN relation.store_nbr = [placeholder-type:numeric] THEN sales_in_weather.units * [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(sales_in_weather.units) FROM sales_in_weather INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr WHERE sales_in_weather.\"date\" = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of units sold for a specific store on a given date, adjusting for a specified factor. It joins the 'sales_in_weather' table with the 'relation' table to filter sales data based on store numbers. The result is a float value representing the adjusted sales figure."
        },
        {
            "sample_id": 8165,
            "vt": "SELECT weather.dewpoint FROM weather INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE relation.store_nbr = [placeholder-type:numeric] AND weather.\"date\" = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the dewpoint temperature from the 'weather' table for a specific store and date. It joins the 'weather' table with the 'relation' table to link weather data to the corresponding store using the store number as a filter. The placeholders represent the store number and the date for which the dewpoint is being queried."
        },
        {
            "sample_id": 8145,
            "vt": "SELECT weather.dewpoint FROM sales_in_weather INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr WHERE relation.store_nbr = [placeholder-type:numeric] AND SUBSTRING(sales_in_weather.\"date\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND sales_in_weather.item_nbr = [placeholder-type:numeric] ORDER BY sales_in_weather.units LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the dewpoint values from the 'weather' table for specific stores and items on a given date. It joins the 'sales_in_weather' table with the 'relation' table to link stores to their corresponding weather stations, and then further joins with the 'weather' table to access weather data. The placeholders allow users to specify the store number, date substring parameters, item number, and limit for the number of results returned."
        },
        {
            "sample_id": 8155,
            "vt": "SELECT CAST(SUM(sales_in_weather.units) AS FLOAT) / COUNT(sales_in_weather.\"date\") FROM sales_in_weather INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr WHERE sales_in_weather.store_nbr = [placeholder-type:numeric] AND sales_in_weather.item_nbr = [placeholder-type:numeric] AND weather.tmax > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average units sold of a specific item from a specific store, filtered by the maximum temperature recorded at the corresponding weather station. It joins the 'sales_in_weather' table with the 'relation' table to link stores to their respective weather stations, and then joins with the 'weather' table to apply the temperature condition. The placeholders represent the store number, item number, and the temperature threshold."
        },
        {
            "sample_id": 8167,
            "vt": "SELECT COUNT((SELECT DISTINCT store_nbr FROM relation WHERE station_nbr = (SELECT station_nbr FROM weather ORDER BY avgspeed DESC LIMIT 1)).store_nbr) FROM (SELECT DISTINCT relation.store_nbr FROM relation WHERE station_nbr = (SELECT station_nbr FROM weather ORDER BY avgspeed DESC LIMIT 1)) AS t",
            "ba": "The virtual table counts the number of distinct stores that are associated with the weather station that has the highest average wind speed. It first identifies the weather station with the maximum average wind speed, then retrieves the distinct store numbers linked to that station from the relation table, and finally counts those distinct store numbers."
        },
        {
            "sample_id": 8193,
            "vt": "SELECT weather.tmin FROM relation INNER JOIN weather AS T2 ON T1.station_nbr = T2.station_nbr WHERE relation.store_nbr = [placeholder-type:numeric] AND weather.\"date\" = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the minimum temperature recorded on a specific date for a particular store by joining the 'relation' table with the 'weather' table. The placeholders represent the store number and the date for which the temperature is being queried."
        },
        {
            "sample_id": 8168,
            "vt": "SELECT weather.tmax FROM weather INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE relation.store_nbr = [placeholder-type:numeric] AND weather.\"date\" = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum temperature recorded on a specific date for a particular store by joining the 'weather' and 'relation' tables. The placeholders represent the store number and the date for which the temperature is being queried."
        },
        {
            "sample_id": 8151,
            "vt": "SELECT SUM(sales_in_weather.units) FROM sales_in_weather INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr WHERE relation.store_nbr = [placeholder-type:numeric] AND sales_in_weather.\"date\" LIKE '[placeholder-type:string]' GROUP BY weather.tmax ORDER BY weather.tmax LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total units sold from the 'sales_in_weather' table, filtered by a specific store number and date. It joins the 'relation' table to connect stores with their corresponding weather stations, and then joins the 'weather' table to access weather data. The results are grouped by the maximum temperature recorded, allowing for analysis of sales in relation to temperature. The placeholders represent the store number, date pattern, and limit for the number of results returned."
        },
        {
            "sample_id": 8170,
            "vt": "SELECT relation.store_nbr FROM weather INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr ORDER BY weather.snowfall LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the store numbers from the 'relation' table that are associated with weather data from the 'weather' table. It performs an inner join on the 'station_nbr' to link the two tables, ensuring that only stores with corresponding weather data are included. The results are ordered by the snowfall amount, and a limit is applied to restrict the number of returned store numbers based on a specified numeric value."
        }
    ],
    "bike_share_1": [
        {
            "sample_id": 9054,
            "vt": "SELECT SUM(CASE WHEN weather.zip_code = [placeholder-type:numeric] AND weather.date = '[placeholder-type:string]' THEN weather.max_temperature_f - weather.min_temperature_f ELSE [placeholder-type:numeric] END) FROM weather",
            "ba": "The virtual table calculates the difference between the maximum and minimum temperatures recorded on a specific date for a given zip code from the 'weather' table. The placeholders represent the zip code and the date for which the temperature difference is being calculated."
        },
        {
            "sample_id": 9021,
            "vt": "SELECT COUNT(trip.id) FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE trip.subscription_type = '[placeholder-type:string]' AND weather.min_visibility_miles = [placeholder-type:numeric] AND trip.duration < [placeholder-type:numeric] AND trip.start_station_name = '[placeholder-type:string]' AND trip.end_station_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of trips from the 'trip' table that meet specific criteria related to weather conditions and subscription type. It filters trips based on the subscription type, the minimum visibility in miles from the 'weather' table, the duration of the trip, and the names of the start and end stations."
        },
        {
            "sample_id": 9073,
            "vt": "SELECT CAST(SUM(CASE WHEN trip.subscription_type = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN trip.subscription_type = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM trip WHERE trip.start_station_name = '[placeholder-type:string]' AND trip.end_station_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average duration of trips that start and end at specified stations, filtered by subscription type. It uses conditional aggregation to sum the durations based on the subscription type and divides it by the total number of trips for that subscription type."
        },
        {
            "sample_id": 9028,
            "vt": "SELECT weather.date, trip.bike_id FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE SUBSTRING(CAST(weather.date AS TEXT), -[placeholder-type:numeric]) = '[placeholder-type:string]' AND weather.events = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the date and bike ID from the 'trip' table, joining it with the 'weather' table based on matching zip codes. It filters the results to include only those records where the last few characters of the date match a specified value and where specific weather events occurred."
        },
        {
            "sample_id": 9055,
            "vt": "SELECT status.bikes_available FROM station INNER JOIN status AS T2 ON T1.id = T2.station_id WHERE station.name = '[placeholder-type:string]' AND status.time = '[placeholder-type:string]'",
            "ba": "The virtual table provides the number of available bikes at a specific station by joining the 'station' and 'status' tables. It filters the results based on the station's name and the time of the status report."
        },
        {
            "sample_id": 9036,
            "vt": "SELECT trip.id FROM trip LEFT JOIN station AS T2 ON T2.name = T1.start_station_name WHERE station.city = '[placeholder-type:string]' AND trip.duration = (SELECT MAX(trip.duration) FROM trip AS T1 LEFT JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T2.city = 'Redwood City')",
            "ba": "The virtual table retrieves the trip IDs from the 'trip' table for trips that started at stations located in a specific city. It identifies the longest trip duration from the same city by using a subquery that finds the maximum duration of trips starting from stations in 'Redwood City'. The join between the 'trip' and 'station' tables is based on matching the station names, allowing for filtering based on the city."
        },
        {
            "sample_id": 8999,
            "vt": "SELECT MAX(trip.duration) FROM trip WHERE trip.start_date LIKE '[placeholder-type:string]' AND trip.end_date LIKE '[placeholder-type:string]'",
            "ba": "The virtual table provides the maximum duration of bike trips from the 'trip' table that started and ended within specified date ranges. The placeholders in the WHERE clause represent the start and end dates for filtering the trips."
        },
        {
            "sample_id": 9010,
            "vt": "SELECT trip.start_station_name, station.installation_date FROM trip INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE trip.subscription_type = '[placeholder-type:string]' GROUP BY trip.start_station_name ORDER BY COUNT(trip.subscription_type) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the start station names and their installation dates from the 'trip' and 'station' tables. It filters the trips based on a specific subscription type and groups the results by start station name, ordering them by the count of trips for that subscription type. The placeholders represent the subscription type and the limit on the number of results returned."
        },
        {
            "sample_id": 9063,
            "vt": "SELECT MAX(trip.duration) FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE weather.date LIKE '[placeholder-type:string]' AND weather.events = '[placeholder-type:string]' AND weather.zip_code = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the maximum duration of trips from the 'trip' table, filtered by specific weather conditions on a given date and location. The placeholders represent the date, weather events, and zip code for which the maximum trip duration is being queried."
        },
        {
            "sample_id": 9024,
            "vt": "SELECT MIN(trip.duration), MIN(trip.duration) - AVG(trip.duration), weather.min_temperature_f FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE trip.start_date = '[placeholder-type:string]' AND trip.end_date = '[placeholder-type:string]' AND trip.start_station_name = '[placeholder-type:string]' AND trip.end_station_name = '[placeholder-type:string]' AND trip.subscription_type = '[placeholder-type:string]'",
            "ba": "The virtual table provides insights into bike trip durations and weather conditions for specific trips. It calculates the minimum trip duration, the difference between the minimum and average trip duration, and the minimum temperature recorded on the trip date. The query filters results based on the start and end dates of the trip, the names of the start and end stations, and the type of subscription used for the trip."
        },
        {
            "sample_id": 9086,
            "vt": "SELECT COUNT(weather.zip_code), weather.max_temperature_f FROM trip INNER JOIN weather AS T3 ON T3.zip_code = T2.zip_code WHERE weather.zip_code = [placeholder-type:numeric] AND trip.subscription_type = '[placeholder-type:string]' ORDER BY weather.max_temperature_f LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of trips associated with a specific zip code and subscription type, along with the maximum temperature recorded for that zip code. It combines data from the 'trip' and 'weather' tables based on matching zip codes, allowing users to analyze how many trips were taken under certain weather conditions."
        },
        {
            "sample_id": 9092,
            "vt": "SELECT COUNT(station.name), SUM(CASE WHEN trip.subscription_type = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM station INNER JOIN trip AS T2 ON T2.start_station_name = T1.name WHERE station.installation_date = '[placeholder-type:string]' AND trip.subscription_type = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of station names and a conditional sum of trips based on subscription type from the 'station' and 'trip' tables. It filters the results by the installation date of the station and the type of subscription used for the trips."
        },
        {
            "sample_id": 9052,
            "vt": "SELECT COUNT(station.installation_date) FROM station WHERE station.city = '[placeholder-type:string]' AND (SUBSTRING(CAST(station.installation_date AS TEXT), [placeholder-type:numeric], INSTR(station.installation_date, '/') - [placeholder-type:numeric]) IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]') AND SUBSTRING(CAST(station.installation_date AS TEXT), -[placeholder-type:numeric]) = '[placeholder-type:string]') OR SUBSTRING(CAST(station.installation_date AS TEXT), -[placeholder-type:numeric]) > '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of stations installed in a specific city based on their installation date. The placeholders allow for filtering by city name and specific date components, such as month and year, to determine the count of stations installed during certain periods."
        },
        {
            "sample_id": 9069,
            "vt": "SELECT SUM(CASE WHEN weather.zip_code = [placeholder-type:numeric] AND weather.events = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM weather",
            "ba": "The virtual table calculates the total precipitation from the 'weather' table for a specific zip code and weather event type. The placeholders represent the zip code and the type of weather event, allowing users to specify their criteria for the query."
        },
        {
            "sample_id": 9078,
            "vt": "SELECT trip.end_station_name, station.city, CAST(SUM(trip.duration) AS FLOAT) / [placeholder-type:numeric] FROM trip INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE trip.bike_id = [placeholder-type:numeric] AND trip.start_station_name <> trip.end_station_name",
            "ba": "The virtual table summarizes the total duration of trips taken on a specific bike, grouped by the end station name and city. It calculates the average trip duration by dividing the total duration by a specified number. The data is retrieved from the 'trip' table and joined with the 'station' table to get the city information for each end station, ensuring that the start and end stations are different."
        },
        {
            "sample_id": 9038,
            "vt": "SELECT COUNT(trip.subscription_type) FROM trip INNER JOIN station AS T2 ON T2.name = T1.end_station_name WHERE trip.subscription_type = '[placeholder-type:string]' AND station.city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of trips from the 'trip' table based on the subscription type and the city of the end station. It joins the 'trip' table with the 'station' table to filter trips that end at stations in a specific city and are associated with a particular subscription type."
        },
        {
            "sample_id": 8984,
            "vt": "SELECT trip.start_station_name, trip.end_station_name FROM trip WHERE trip.duration = (SELECT MAX(trip.duration) FROM trip)",
            "ba": "The virtual table describes the start and end station names of the longest bike trip recorded in the 'trip' table. The query identifies the trip with the maximum duration and retrieves the corresponding start and end station names."
        },
        {
            "sample_id": 9076,
            "vt": "SELECT COUNT(trip.id) FROM station INNER JOIN trip AS T2 ON T2.start_station_name = T1.name WHERE station.city = '[placeholder-type:string]' AND trip.start_date LIKE '[placeholder-type:string]' AND trip.start_station_name LIKE '[placeholder-type:string]' AND trip.end_station_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of trips that started at a specific station in a given city, filtered by the start date and the names of the start and end stations. It combines data from the 'station' and 'trip' tables using an inner join on the station name."
        },
        {
            "sample_id": 9004,
            "vt": "SELECT DISTINCT CASE WHEN weather.date = '[placeholder-type:string]' AND weather.zip_code = [placeholder-type:numeric] THEN weather.max_dew_point_f END FROM weather",
            "ba": "The virtual table retrieves the maximum dew point temperature from the 'weather' table for a specific date and zip code. The placeholders represent the date and zip code values that can be specified by the user."
        },
        {
            "sample_id": 9089,
            "vt": "SELECT MIN(trip.duration), MAX(weather.max_wind_speed_mph) FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE trip.start_station_name = '[placeholder-type:string]' AND weather.date = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the minimum trip duration and the maximum wind speed for a specific start station on a given date. It combines data from the 'trip' and 'weather' tables based on the zip code, filtering results by the start station name and the weather date."
        },
        {
            "sample_id": 9046,
            "vt": "SELECT trip.id FROM trip INNER JOIN weather AS T2 WHERE weather.events = '[placeholder-type:string]' AND trip.start_station_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the IDs of trips from the 'trip' table that are associated with specific weather events and start station names. The placeholders represent the weather event type and the name of the starting station."
        },
        {
            "sample_id": 9030,
            "vt": "SELECT trip.start_date FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code AND T2.date = SUBSTRING(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1) WHERE weather.date LIKE '[placeholder-type:string]' AND trip.start_station_name = '[placeholder-type:string]' AND trip.end_station_name = '[placeholder-type:string]' AND weather.min_temperature_f = (SELECT MIN(weather.min_temperature_f) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code AND T2.date = SUBSTRING(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1) WHERE T2.date LIKE '8/%/2013' AND T1.start_station_name = 'Market at 10th' AND T1.end_station_name = 'South Van Ness at Market')",
            "ba": "The virtual table retrieves the start dates of trips from the 'trip' table, joining it with the 'weather' table to correlate weather data based on the zip code and the date of the trip. It filters the results based on specific conditions for the weather date, start station name, and end station name. Additionally, it finds the minimum recorded temperature for trips that occurred on a specific date and between specified start and end stations."
        },
        {
            "sample_id": 9057,
            "vt": "SELECT COUNT(trip.id) FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE weather.date LIKE '[placeholder-type:string]' AND weather.zip_code = [placeholder-type:numeric] AND weather.max_temperature_f > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of trips from the 'trip' table that occurred on a specific date and in a specific zip code, while also ensuring that the maximum temperature recorded on that date exceeds a certain threshold. The query joins the 'trip' table with the 'weather' table based on the zip code to filter the trips according to weather conditions."
        },
        {
            "sample_id": 9065,
            "vt": "SELECT COUNT(trip.id) FROM trip INNER JOIN station AS T2 ON T2.ID = T1.start_station_id WHERE station.city = '[placeholder-type:string]' AND trip.subscription_type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of trips that started from stations located in a specific city and were made by users with a certain subscription type. It combines data from the 'trip' and 'station' tables, filtering based on the city and subscription type provided by the user."
        },
        {
            "sample_id": 9049,
            "vt": "SELECT AVG(weather.mean_temperature_f) FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE SUBSTRING(CAST(weather.date AS TEXT), -[placeholder-type:numeric]) = '[placeholder-type:string]' AND trip.start_station_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average mean temperature from the 'weather' table for trips that start at a specific station. It joins the 'trip' table with the 'weather' table based on the zip code, filtering the results by the last few digits of the date and the name of the starting station."
        },
        {
            "sample_id": 8988,
            "vt": "SELECT station.name, station.long FROM station INNER JOIN status AS T2 ON T2.station_id = T1.id WHERE status.time = '[placeholder-type:string]' AND status.bikes_available = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names and longitudes of stations from the 'station' table that have a specific status at a given time. The query joins the 'station' table with the 'status' table to filter for stations based on the availability of bikes and a specific time. The placeholders represent the time and the number of available bikes."
        },
        {
            "sample_id": 9041,
            "vt": "SELECT CAST(SUM(CASE WHEN trip.duration > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(trip.id) FROM trip INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE station.city = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average duration of trips that exceed a specified duration threshold, adjusted by a given factor, for a specific city. It aggregates the trip durations from the 'trip' table, filtering the results based on the start station's name and the city from the 'station' table."
        },
        {
            "sample_id": 9048,
            "vt": "SELECT trip.duration FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE weather.max_wind_speed_mph = [placeholder-type:numeric] ORDER BY trip.duration LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the duration of trips from the 'trip' table, filtering the results based on the maximum wind speed recorded in the 'weather' table. The join condition links the two tables using the zip code, ensuring that only trips corresponding to specific weather conditions are considered. The results are ordered by trip duration and limited to a specified number of entries."
        },
        {
            "sample_id": 9011,
            "vt": "SELECT DISTINCT station.name FROM station INNER JOIN status AS T2 ON T2.station_id = T1.id WHERE status.bikes_available = [placeholder-type:numeric] AND status.time LIKE '[placeholder-type:string]'",
            "ba": "The virtual table lists the unique names of stations from the 'station' table that have a specific number of available bikes, as indicated by the 'bikes_available' column in the 'status' table. The query joins the 'station' and 'status' tables on the station ID to filter results based on the availability of bikes and a specific time condition."
        },
        {
            "sample_id": 9075,
            "vt": "SELECT DISTINCT trip.start_station_name, trip.end_station_name FROM weather INNER JOIN trip AS T2 ON T1.zip_code = T2.zip_code WHERE weather.date LIKE '[placeholder-type:string]' AND weather.mean_temperature_f = [placeholder-type:numeric] * [placeholder-type:numeric] + [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct start and end station names from the 'trip' table, filtered by weather conditions. It joins the 'weather' table with the 'trip' table based on the zip code, and applies conditions on the date and mean temperature, where the mean temperature is calculated using placeholders for numeric values."
        },
        {
            "sample_id": 9008,
            "vt": "SELECT weather.max_humidity FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE trip.start_date LIKE '[placeholder-type:string]' AND trip.bike_id = [placeholder-type:numeric] AND trip.start_station_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum humidity recorded from the 'weather' table for trips that match specific criteria. It joins the 'trip' table with the 'weather' table based on the zip code, ensuring that the weather data corresponds to the location of the trip. The query filters results based on the start date of the trip, the bike ID used, and the name of the start station."
        },
        {
            "sample_id": 9002,
            "vt": "SELECT SUM(CASE WHEN station.city = '[placeholder-type:string]' AND station.dock_count > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM station",
            "ba": "The virtual table calculates the total number of bikes that can be held at stations located in a specific city, provided that the number of docks at those stations exceeds a certain threshold. The placeholders represent the city name and the minimum dock count required for the calculation."
        },
        {
            "sample_id": 9081,
            "vt": "SELECT trip.bike_id, trip.start_station_name, trip.end_station_name, station.city, CAST(trip.duration AS FLOAT) / [placeholder-type:numeric] FROM station INNER JOIN trip AS T2 ON T1.name = T2.start_station_name GROUP BY trip.bike_id ORDER BY COUNT(trip.id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the bike trips from various stations, showing the bike ID, start and end station names, and the city of the start station. It calculates the duration of each trip divided by a specified numeric value, allowing for analysis of trip durations relative to that value. The results are grouped by bike ID and ordered by the count of trips, with a limit on the number of results returned based on another specified numeric value."
        },
        {
            "sample_id": 9025,
            "vt": "SELECT AVG(trip.duration) FROM trip WHERE trip.start_date = '[placeholder-type:string]' AND trip.end_date = '[placeholder-type:string]' AND trip.start_station_name = '[placeholder-type:string]' AND trip.end_station_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average duration of trips from the 'trip' table based on specific start and end dates, as well as the names of the start and end stations. The placeholders in the WHERE clause represent the start date, end date, start station name, and end station name."
        },
        {
            "sample_id": 9026,
            "vt": "SELECT AVG(weather.max_temperature_f), AVG(weather.min_temperature_f) FROM weather WHERE weather.date LIKE '[placeholder-type:string]' AND weather.mean_humidity BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average maximum and minimum temperatures from the 'weather' table for a specific date, while also filtering the results based on a range of mean humidity values. The placeholders represent the date and the lower and upper bounds of the mean humidity range."
        },
        {
            "sample_id": 9066,
            "vt": "SELECT COUNT(trip.start_station_name) FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE weather.date LIKE '[placeholder-type:string]' AND weather.zip_code = [placeholder-type:numeric] AND trip.start_station_name = '[placeholder-type:string]' ORDER BY weather.max_temperature_f LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of trips that started from a specific station on a given date, while also considering the weather conditions for that date and location. It joins the 'trip' table with the 'weather' table based on the zip code, filtering by the specified date and zip code, and only counting trips that started from the specified station name. The results are ordered by the maximum temperature recorded on that date, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 9072,
            "vt": "SELECT (weather.max_temperature_f - [placeholder-type:numeric]) / [placeholder-type:numeric], (weather.mean_temperature_f - [placeholder-type:numeric]) / [placeholder-type:numeric], (weather.min_temperature_f - [placeholder-type:numeric]) / [placeholder-type:numeric] FROM weather WHERE SUBSTRING(CAST(weather.date AS TEXT), [placeholder-type:numeric], INSTR(weather.date, '/') - [placeholder-type:numeric]) = '[placeholder-type:string]' AND SUBSTRING(CAST(weather.date AS TEXT), -[placeholder-type:numeric]) = '[placeholder-type:string]' AND weather.zip_code = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the normalized temperature values (max, mean, and min) from the 'weather' table based on specific conditions. It filters the records by extracting the month and year from the date and matches them with provided placeholders, while also filtering by zip code."
        },
        {
            "sample_id": 9068,
            "vt": "SELECT DISTINCT trip.end_station_name FROM trip WHERE trip.start_station_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the unique names of end stations from the 'trip' table where the bike was borrowed from a specific start station. The placeholder in the WHERE clause represents the name of the start station."
        },
        {
            "sample_id": 9014,
            "vt": "SELECT station.name, station.installation_date, station.city FROM station WHERE (SUBSTRING(CAST(station.installation_date AS TEXT), [placeholder-type:numeric], INSTR(station.installation_date, '/') - [placeholder-type:numeric]) = '[placeholder-type:string]' AND SUBSTRING(CAST(station.installation_date AS TEXT), INSTR(station.installation_date, '/') + [placeholder-type:numeric], -[placeholder-type:numeric]) >= '[placeholder-type:string]' AND SUBSTRING(CAST(station.installation_date AS TEXT), -[placeholder-type:numeric]) = '[placeholder-type:string]') OR (SUBSTRING(CAST(station.installation_date AS TEXT), [placeholder-type:numeric], INSTR(station.installation_date, '/') - [placeholder-type:numeric]) IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]') AND SUBSTRING(CAST(station.installation_date AS TEXT), -[placeholder-type:numeric]) = '[placeholder-type:string]')",
            "ba": "The virtual table describes the names, installation dates, and cities of bike stations from the 'station' table that meet specific date criteria. The placeholders in the WHERE clause represent various components of the installation date, allowing for filtering based on month, day, and year values."
        },
        {
            "sample_id": 8990,
            "vt": "SELECT MAX(weather.max_temperature_f) FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code AND T2.date = SUBSTRING(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1) WHERE trip.id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the maximum temperature recorded on the date corresponding to the start date of a specific trip. It joins the 'trip' table with the 'weather' table based on matching zip codes and the date derived from the start date of the trip. The placeholder in the WHERE clause represents the unique identifier of the trip."
        },
        {
            "sample_id": 9016,
            "vt": "SELECT status.time, station.name, station.lat, station.long FROM station INNER JOIN status AS T2 ON T2.station_id = T1.id WHERE status.bikes_available = [placeholder-type:numeric]",
            "ba": "The virtual table provides information about the status of bike stations, including the time of the status report, the name of the station, and its geographical coordinates (latitude and longitude). It retrieves data from the 'station' table and joins it with the 'status' table to filter for stations that have a specific number of available bikes, represented by a placeholder for numeric values."
        },
        {
            "sample_id": 9090,
            "vt": "SELECT SUM(status.bikes_available), station.long, station.lat FROM station INNER JOIN status AS T2 ON T2.station_id = T1.id WHERE status.time = '[placeholder-type:string]' AND station.name = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total number of available bikes at a specific station, along with its geographical coordinates (longitude and latitude). It combines data from the 'station' and 'status' tables, filtering results based on a specific time and the name of the station."
        },
        {
            "sample_id": 9084,
            "vt": "SELECT station.city, SUM(station.dock_count) FROM station WHERE station.name = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total number of docks available across all stations in a specific city, identified by the station's name. The placeholder in the WHERE clause represents the name of the station being queried."
        },
        {
            "sample_id": 9056,
            "vt": "SELECT station.city FROM trip INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE trip.id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the cities of the stations from which trips started, based on a specific trip ID. The query joins the 'trip' table with the 'station' table to retrieve the city information for the start station of the specified trip."
        },
        {
            "sample_id": 9061,
            "vt": "SELECT SUM(status.docks_available) FROM trip INNER JOIN status AS T2 ON T2.station_id = T1.end_station_id WHERE trip.id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total number of available docks at the end station for a specific trip. It combines data from the 'trip' and 'status' tables, linking them through the end station ID. The placeholder in the WHERE clause represents the unique identifier of the trip."
        },
        {
            "sample_id": 9031,
            "vt": "SELECT trip.start_station_name, trip.end_station_name, trip.duration FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE weather.events = '[placeholder-type:string]' OR weather.events = '[placeholder-type:string]' ORDER BY trip.duration LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the start and end station names along with the duration of trips from the 'trip' table, filtered by specific weather events. The placeholders in the WHERE clause represent the types of weather events to filter by, and the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 8985,
            "vt": "SELECT CAST(COUNT(trip.subscription_type) AS FLOAT) * [placeholder-type:numeric] / (SELECT COUNT(trip.subscription_type) FROM trip) FROM trip WHERE trip.subscription_type = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage of trips taken by a specific subscription type from the total number of trips recorded in the 'trip' table. It uses a placeholder for the subscription type to filter the trips and another placeholder for numeric values to represent the scaling factor for the percentage calculation."
        },
        {
            "sample_id": 9029,
            "vt": "SELECT weather.mean_visibility_miles, weather.mean_wind_speed_mph, weather.events, station.lat, station.long, trip.start_station_name, trip.end_station_name FROM station INNER JOIN trip AS T2 ON T2.start_station_name = T1.name INNER JOIN weather AS T3 ON T3.zip_code = T2.zip_code WHERE weather.events = '[placeholder-type:string]' ORDER BY trip.duration LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides information about the mean visibility, mean wind speed, and weather events associated with bike trips, along with the latitude and longitude of the starting station. It combines data from the 'station', 'trip', and 'weather' tables, filtering results based on specific weather events and limiting the number of results based on trip duration."
        },
        {
            "sample_id": 9045,
            "vt": "SELECT trip.id FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code ORDER BY weather.max_temperature_f LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the IDs of trips from the 'trip' table, joining it with the 'weather' table based on matching zip codes. The results are ordered by the maximum temperature recorded in the weather data, and the number of results returned is limited by a numeric placeholder."
        },
        {
            "sample_id": 9020,
            "vt": "SELECT weather.max_gust_speed_mph, weather.cloud_cover FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code AND T2.date = SUBSTRING(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1) WHERE trip.bike_id = [placeholder-type:numeric] AND weather.mean_temperature_f > [placeholder-type:numeric] AND trip.subscription_type = '[placeholder-type:string]' AND trip.start_station_name = '[placeholder-type:string]' AND trip.end_station_name = '[placeholder-type:string]' AND trip.duration = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the maximum gust speed and cloud cover from the 'weather' table, based on specific conditions related to bike trips. It joins the 'trip' table with the 'weather' table using the zip code and the date derived from the start date of the trip. The query filters results for a specific bike ID, mean temperature greater than a certain value, subscription type, start station name, end station name, and trip duration."
        },
        {
            "sample_id": 8995,
            "vt": "SELECT trip.start_station_name, trip.end_station_name, weather.mean_temperature_f FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE trip.duration < [placeholder-type:numeric]",
            "ba": "The virtual table describes the start and end station names of bike trips along with the mean temperature on the day of the trip. It combines data from the 'trip' and 'weather' tables based on matching zip codes, filtering for trips that have a duration shorter than a specified value."
        },
        {
            "sample_id": 8986,
            "vt": "SELECT trip.end_station_id, station.city FROM station INNER JOIN trip AS T2 ON T1.name = T2.end_station_name WHERE trip.bike_id = [placeholder-type:numeric] ORDER BY trip.end_date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the end station IDs and corresponding cities from the 'station' table for trips that involve a specific bike ID. It joins the 'station' table with the 'trip' table based on the end station name, filtering results by the bike ID and ordering them by the end date, with a limit on the number of results."
        },
        {
            "sample_id": 9079,
            "vt": "SELECT CAST(SUM(CASE WHEN trip.subscription_type = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(CASE WHEN trip.subscription_type = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM trip LEFT JOIN station AS T2 ON T2.name = T1.start_station_name WHERE station.city = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of trip durations based on subscription types from the 'trip' table, filtered by the city of the station. It uses a LEFT JOIN to connect the 'trip' table with the 'station' table based on the start station name. The placeholders represent the subscription type, numeric values for calculations, and the city name for filtering."
        },
        {
            "sample_id": 9006,
            "vt": "SELECT MIN(trip.duration), trip.bike_id FROM station INNER JOIN trip AS T2 ON T2.start_station_name = T1.name WHERE trip.start_date LIKE '[placeholder-type:string]' AND station.lat = [placeholder-type:numeric] AND station.long = -[placeholder-type:numeric]",
            "ba": "The virtual table retrieves the minimum duration of trips associated with a specific bike from a station, based on the station's geographical coordinates and the start date of the trip. It combines data from the 'station' and 'trip' tables, filtering trips that started at a station with a matching name and location, while also considering the specified start date."
        },
        {
            "sample_id": 8989,
            "vt": "SELECT trip.start_station_name, station.city FROM station INNER JOIN trip AS T2 ON T2.start_station_name = T1.name GROUP BY trip.start_station_name ORDER BY COUNT(trip.start_station_name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the start station names and their corresponding cities from the 'station' table, showing how many trips started at each station. It uses an inner join with the 'trip' table to link trips to their starting stations, grouping the results by station name and ordering them by the count of trips, limiting the output to a specified number of results."
        },
        {
            "sample_id": 9018,
            "vt": "SELECT SUM(station.dock_count - status.bikes_available) FROM station INNER JOIN status AS T2 ON T1.id = T2.station_id WHERE station.name = '[placeholder-type:string]' AND status.time = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of available docks across all stations by subtracting the number of available bikes from the dock count for a specific station and time. It combines data from the 'station' and 'status' tables using an inner join on the station ID, filtering results based on the station's name and the specific time."
        },
        {
            "sample_id": 9015,
            "vt": "SELECT AVG(trip.duration) FROM trip WHERE trip.start_station_name = '[placeholder-type:string]' AND trip.end_station_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average duration of trips that start and end at specific stations. The placeholders represent the names of the start and end stations, allowing users to specify which stations they are interested in."
        },
        {
            "sample_id": 9094,
            "vt": "SELECT COUNT(trip.id), station.dock_count FROM trip INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE trip.end_station_name = '[placeholder-type:string]' AND trip.subscription_type = '[placeholder-type:string]' AND station.dock_count = [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of trips that started from a specific station and ended at a specified station, along with the dock count of the starting station. The placeholders represent the end station's name, the subscription type of the trip, and the number of docks available at the starting station."
        },
        {
            "sample_id": 9000,
            "vt": "SELECT CAST(trip.duration AS FLOAT) / [placeholder-type:numeric] FROM trip WHERE trip.bike_id = [placeholder-type:numeric] AND trip.end_station_name = '[placeholder-type:string]' AND trip.start_station_name = '[placeholder-type:string]' AND trip.start_date LIKE '[placeholder-type:string]' AND trip.end_date LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the duration of trips in hours for a specific bike, filtering by the start and end station names, as well as the start and end dates. The duration is converted from seconds to hours by dividing by a placeholder for the number of seconds in an hour."
        },
        {
            "sample_id": 9033,
            "vt": "SELECT DISTINCT trip.start_station_name, station.city FROM trip INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE trip.duration > (SELECT AVG(trip.duration) FROM trip AS T1 LEFT JOIN station AS T2 ON T2.name = T1.start_station_name)",
            "ba": "The virtual table provides a list of unique start station names along with their corresponding cities from the 'trip' and 'station' tables. It filters the trips to include only those with a duration greater than the average trip duration. The join condition links the start station names in the 'trip' table with the station names in the 'station' table."
        },
        {
            "sample_id": 9035,
            "vt": "SELECT COUNT(station.city) FROM trip INNER JOIN station AS T2 ON T2.name = T1.end_station_name WHERE station.city = '[placeholder-type:string]' AND trip.start_date LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of trips that ended in a specific city from the 'station' table, based on the end station's name and filtered by the start date of the trip. The placeholders represent the city name and the start date pattern."
        },
        {
            "sample_id": 9085,
            "vt": "SELECT SUM(station.dock_count), COUNT(trip.subscription_type) FROM trip INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE station.name = '[placeholder-type:string]' AND trip.start_station_name = station.name AND trip.subscription_type = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total number of docks available at a specific station and counts the number of trips made by a specific subscription type that started from that station. The placeholders represent the station name and the subscription type."
        },
        {
            "sample_id": 9017,
            "vt": "SELECT trip.id, station.lat, station.long FROM trip LEFT JOIN station AS T2 ON T2.name = T1.start_station_name WHERE trip.start_station_name = trip.end_station_name",
            "ba": "The virtual table retrieves the trip IDs along with the latitude and longitude of the starting station from the 'trip' and 'station' tables. It uses a LEFT JOIN to connect the two tables based on the station name, ensuring that even if there is no matching station, the trip information is still displayed. The query specifically filters for trips where the starting station is the same as the ending station."
        },
        {
            "sample_id": 9082,
            "vt": "SELECT COUNT(CASE WHEN trip.subscription_type = '[placeholder-type:string]' AND trip.start_station_name = '[placeholder-type:string]' THEN trip.id END) FROM trip",
            "ba": "The virtual table counts the number of trips from the 'trip' table that match a specific subscription type and start station name. The placeholders represent the subscription type and the name of the start station."
        },
        {
            "sample_id": 9042,
            "vt": "SELECT COUNT(trip.duration) FROM trip WHERE trip.start_date LIKE '[placeholder-type:string]' AND trip.duration > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of trips from the 'trip' table that started on a specific date and had a duration longer than a specified value. The placeholders represent the date and the minimum duration for filtering the trips."
        },
        {
            "sample_id": 9067,
            "vt": "SELECT AVG(trip.duration) FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE weather.date LIKE '[placeholder-type:string]' AND trip.start_station_name = '[placeholder-type:string]' AND weather.max_temperature_f = (SELECT weather.max_temperature_f FROM weather ORDER BY max_temperature_f DESC LIMIT 1)",
            "ba": "The virtual table calculates the average duration of trips that started from a specific station on a specific date, while also considering the maximum temperature recorded on that date. It joins the 'trip' table with the 'weather' table based on the zip code, filtering for the specified date and start station name. Additionally, it checks for the maximum temperature recorded in the weather data."
        },
        {
            "sample_id": 9019,
            "vt": "SELECT trip.id FROM trip INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE trip.bike_id = [placeholder-type:numeric] AND weather.mean_temperature_f > [placeholder-type:numeric] AND trip.subscription_type = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the IDs of trips from the 'trip' table that meet specific conditions related to weather and bike usage. It joins the 'trip' table with the 'weather' table based on matching zip codes. The query filters trips based on the bike ID, ensures that the mean temperature is above a certain threshold, and specifies the type of subscription used for the trip."
        }
    ],
    "codebase_community": [
        {
            "sample_id": 10118,
            "vt": "SELECT COUNT(tags.id) FROM tags WHERE tags.tagname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of tags from the 'tags' table that match a specific tag name. The placeholder in the WHERE clause represents the name of the tag being queried."
        },
        {
            "sample_id": 10071,
            "vt": "SELECT posthistory.id, posts.lasteditdate FROM posthistory INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE posts.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the post history ID and the last edit date of posts from the 'posthistory' and 'posts' tables. It filters the results based on the title of the post, which is represented by a placeholder for string values."
        },
        {
            "sample_id": 10083,
            "vt": "SELECT users.age FROM users WHERE users.reputation = (SELECT MAX(users.reputation) FROM users)",
            "ba": "The virtual table retrieves the age of the user with the highest reputation from the 'users' table. The inner query identifies the maximum reputation value among all users, and the outer query filters the users to find the age corresponding to that maximum reputation."
        },
        {
            "sample_id": 10114,
            "vt": "SELECT badges.date - users.creationdate FROM badges INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE users.displayname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between the date a user obtained a badge and the date the user account was created. It retrieves this information for users with a specific display name."
        },
        {
            "sample_id": 10102,
            "vt": "SELECT AVG(posts.score) FROM users INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE users.displayname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average score of posts created by a specific user identified by their display name. It joins the 'users' table with the 'posts' table based on the user ID, filtering for the user whose display name is provided as a placeholder."
        },
        {
            "sample_id": 9957,
            "vt": "SELECT COUNT(users.id) FROM users WHERE users.upvotes > [placeholder-type:numeric] AND users.downvotes > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users from the 'users' table who have received more upvotes than a specified number and have also received more downvotes than another specified number. The placeholders represent the thresholds for upvotes and downvotes."
        },
        {
            "sample_id": 10125,
            "vt": "SELECT COUNT(tags.id) FROM tags WHERE tags.count <= [placeholder-type:numeric] AND tags.id < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of tags from the 'tags' table that have a count less than or equal to a specified value and have an id less than a specified value. The placeholders represent the numeric values for the tag count and tag id."
        },
        {
            "sample_id": 10036,
            "vt": "SELECT CAST(COUNT(users.id) AS FLOAT) * [placeholder-type:numeric] / (SELECT COUNT(badges.id) FROM users) FROM users INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE badges.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage of users who have obtained a specific badge from the total number of users. It does this by counting the number of users who have received the badge and dividing it by the total number of users, then multiplying by a placeholder for scaling the result. The badge name is specified using a placeholder for string values."
        },
        {
            "sample_id": 10031,
            "vt": "SELECT COUNT(posts.id) FROM posts WHERE posts.score = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of posts from the 'posts' table that have a specific score. The placeholder in the WHERE clause represents the score value to filter the posts."
        },
        {
            "sample_id": 10016,
            "vt": "SELECT users.id, users.reputation FROM comments INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE comments.postid = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the user ID and reputation of users who have commented on a specific post. It joins the 'comments' table with the 'users' table to associate each comment with the corresponding user, filtering the results based on the post ID provided as a placeholder."
        },
        {
            "sample_id": 10131,
            "vt": "SELECT COUNT(comments.id) FROM comments INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE posts.viewcount < [placeholder-type:numeric] AND posts.score = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of comments associated with posts that have a view count below a specified threshold and a specific score. It joins the 'comments' table with the 'posts' table to filter the comments based on the conditions applied to the posts."
        },
        {
            "sample_id": 10112,
            "vt": "SELECT badges.name FROM badges INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE users.displayname = '[placeholder-type:string]' ORDER BY badges.date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of badges obtained by users from the 'badges' table. It joins the 'badges' table with the 'users' table to filter results based on the user's display name. The results are ordered by the date the badges were obtained, and a limit is applied to restrict the number of returned records."
        },
        {
            "sample_id": 10087,
            "vt": "SELECT CAST(COUNT(postlinks.id) AS FLOAT) / [placeholder-type:numeric] FROM postlinks INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE posts.answercount <= [placeholder-type:numeric] AND STRFTIME('%Y', postlinks.creationdate) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of post links created in a specific year for posts that have a certain number of answers. It joins the 'postlinks' table with the 'posts' table to filter the posts based on their answer count and the creation date of the post links."
        },
        {
            "sample_id": 10130,
            "vt": "SELECT users.creationdate, users.age FROM comments INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE comments.text LIKE '[placeholder-type:string]'",
            "ba": "The virtual table provides the creation date and age of users who have made comments containing specific text. It joins the 'comments' table with the 'users' table based on the user ID, allowing us to filter comments by their content using a placeholder for string values."
        },
        {
            "sample_id": 9985,
            "vt": "SELECT posts.favoritecount FROM posts INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE comments.creationdate = '[placeholder-type:string]' AND comments.userid = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the favorite count of posts from the 'posts' table, specifically for those posts that have comments created on a certain date by a specific user. The placeholders represent the date of comment creation and the user ID."
        },
        {
            "sample_id": 10035,
            "vt": "SELECT badges.date FROM users INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE users.location = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the dates on which users obtained their badges from the 'badges' table, filtered by the users' location. The placeholder in the WHERE clause represents the specific location of the users."
        },
        {
            "sample_id": 10044,
            "vt": "SELECT badges.name FROM users INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE users.displayname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of badges obtained by users from the 'badges' table, filtered by the user's display name from the 'users' table. The placeholder in the WHERE clause represents the specific display name of the user."
        },
        {
            "sample_id": 10057,
            "vt": "SELECT COUNT(users.id) FROM users INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id INNER JOIN votes AS T4 ON T4.PostId = T3.Id WHERE users.displayname = '[placeholder-type:string]' GROUP BY posthistory.postid, votes.id HAVING COUNT(votes.id) > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users who have voted on posts created by a specific user, identified by their display name. It joins the 'users' table with the 'posthistory' table to find posts made by the user, then joins with the 'posts' table to access the posts' details, and finally joins with the 'votes' table to count the votes on those posts. The result is grouped by post history ID and vote ID, and only includes groups where the count of votes exceeds a specified numeric threshold."
        },
        {
            "sample_id": 9954,
            "vt": "SELECT users.displayname FROM users WHERE STRFTIME('%Y', users.creationdate) = '[placeholder-type:string]'",
            "ba": "The virtual table describes the display names of users from the 'users' table who created their accounts in a specific year. The placeholder in the WHERE clause represents the year of account creation."
        },
        {
            "sample_id": 10038,
            "vt": "SELECT comments.score FROM comments INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE comments.creationdate = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the score of comments from the 'comments' table that are associated with posts in the 'posts' table. The query filters the comments based on their creation date, which is specified by a placeholder for string values."
        },
        {
            "sample_id": 10039,
            "vt": "SELECT comments.text FROM comments INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE comments.creationdate = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the text of comments from the 'comments' table that are associated with posts created on a specific date. The query uses an inner join to connect the 'comments' table with the 'posts' table based on the post ID, ensuring that only comments related to posts created on the specified date are selected."
        },
        {
            "sample_id": 10040,
            "vt": "SELECT users.age FROM users INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE users.location = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the ages of users from the 'users' table who have obtained badges, filtered by their location. The placeholder in the WHERE clause represents the specific location of the users."
        },
        {
            "sample_id": 10065,
            "vt": "SELECT users.displayname, users.age FROM users WHERE users.views = (SELECT MAX(users.views) FROM users)",
            "ba": "The virtual table describes the display name and age of the user who has the highest number of views from the 'users' table. The placeholder in the WHERE clause represents the maximum view count among all users."
        },
        {
            "sample_id": 9976,
            "vt": "SELECT users.displayname FROM badges INNER JOIN users AS T2 ON T1.UserId = T2.Id GROUP BY users.displayname ORDER BY COUNT(badges.id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the display names of users who have obtained badges, showing how many badges each user has received. The results are grouped by the user's display name and ordered by the count of badges in descending order, with a limit on the number of users returned based on a specified numeric value."
        },
        {
            "sample_id": 10094,
            "vt": "SELECT COUNT(users.id) FROM users INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE users.location = '[placeholder-type:string]' AND posts.favoritecount >= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users from the 'users' table who have created posts in a specific location and have a certain number of favorites on their posts. The placeholders represent the user's location and the minimum favorite count for the posts."
        },
        {
            "sample_id": 9959,
            "vt": "SELECT COUNT(posts.id) FROM posts INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE users.displayname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of posts created by users with a specific display name from the 'posts' table. It joins the 'posts' table with the 'users' table to filter the posts based on the user's display name, which is represented by a placeholder."
        },
        {
            "sample_id": 10109,
            "vt": "SELECT COUNT(comments.id) FROM posts INNER JOIN comments AS T2 ON T1.Id = T2.PostId GROUP BY posts.id ORDER BY SUM(posts.score) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of comments associated with each post from the 'posts' table. It joins the 'comments' table to aggregate the number of comments per post, grouping the results by post ID. The results are ordered by the total score of each post, and a limit is applied to restrict the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 10119,
            "vt": "SELECT users.reputation, users.views FROM users WHERE users.displayname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the reputation and views of users from the 'users' table who have a specific display name. The placeholder in the WHERE clause represents the user's display name."
        },
        {
            "sample_id": 9958,
            "vt": "SELECT COUNT(users.id) FROM users WHERE STRFTIME('%Y', users.creationdate) > '[placeholder-type:string]' AND users.views > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users from the 'users' table who created their accounts after a specific year and have a number of views exceeding a certain threshold. The placeholders represent the year and the minimum views required."
        },
        {
            "sample_id": 10084,
            "vt": "SELECT COUNT(posts.id) FROM posts INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE votes.bountyamount = [placeholder-type:numeric] AND STRFTIME('%Y', votes.creationdate) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of posts from the 'posts' table that have received votes with a specific bounty amount and were created in a specified year. The placeholders represent the bounty amount and the year for filtering the results."
        },
        {
            "sample_id": 10077,
            "vt": "SELECT posts.title, postlinks.linktypeid FROM posts INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId INNER JOIN posts AS T3 ON T2.RelatedPostId = T3.Id WHERE posts.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of posts along with their corresponding link type IDs from the 'posts' table. It retrieves this information by joining the 'posts' table with the 'postlinks' table to find related posts based on the specified title. The placeholder in the WHERE clause represents the title of the post being queried."
        },
        {
            "sample_id": 10061,
            "vt": "SELECT CAST(SUM(CASE WHEN tags.tagname = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(users.id) FROM users INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN tags AS T3 ON T3.ExcerptPostId = T2.PostId WHERE users.displayname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average score based on user interactions with posts that are tagged with a specific tag name. It sums up the scores of users who have interacted with posts containing the specified tag, adjusts this sum by a given multiplier, and then divides it by the total number of users to get an average score. The placeholders represent the tag name, a numeric value for adjustment, and the user's display name for filtering."
        },
        {
            "sample_id": 9988,
            "vt": "SELECT users.reputation FROM users INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE posts.id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the reputation of users who own specific posts from the 'users' table. It joins the 'users' table with the 'posts' table to find the user associated with a particular post identified by its ID. The placeholder in the WHERE clause represents the unique identifier of the post."
        },
        {
            "sample_id": 10097,
            "vt": "SELECT COUNT(users.id) FROM users WHERE users.reputation > [placeholder-type:numeric] AND users.views > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users from the 'users' table who have a reputation greater than a specified value and have also received more views than another specified value. The placeholders in the WHERE clause represent the minimum reputation and view count thresholds."
        },
        {
            "sample_id": 9991,
            "vt": "SELECT COUNT(posts.id) FROM posts INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE posts.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of posts from the 'posts' table that have received votes, filtering based on a specific title. The placeholder in the LIKE clause represents the title of the post being searched for."
        },
        {
            "sample_id": 10023,
            "vt": "SELECT posts.score, postlinks.linktypeid FROM posts INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE postlinks.postid = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the score of posts along with the type of links associated with those posts. It joins the 'posts' table with the 'postlinks' table based on the post ID, allowing for a comprehensive view of how posts are rated and their related links."
        },
        {
            "sample_id": 10081,
            "vt": "SELECT COUNT(tags.id) FROM tags WHERE tags.count BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of tags from the 'tags' table that have a count of posts within a specified range. The placeholders represent the minimum and maximum counts of posts that a tag must have to be included in the count."
        },
        {
            "sample_id": 10127,
            "vt": "SELECT users.reputation, users.upvotes FROM comments INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE comments.text = '[placeholder-type:string]'",
            "ba": "The virtual table displays the reputation and upvotes of users who have made comments matching a specific text. It retrieves data from the 'comments' table and joins it with the 'users' table to associate each comment with the corresponding user, using the user ID as the linking key."
        },
        {
            "sample_id": 10000,
            "vt": "SELECT users.displayname, users.reputation FROM users INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE posts.title = '[placeholder-type:string]'",
            "ba": "The virtual table displays the display names and reputations of users from the 'users' table who are the owners of posts with a specific title. The query uses an inner join to connect the 'users' table with the 'posts' table based on the user ID, ensuring that only users who have authored posts with the specified title are included in the results."
        },
        {
            "sample_id": 10053,
            "vt": "SELECT COUNT(users.id) FROM users INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId WHERE users.displayname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users from the 'users' table who have a specific display name and have made posts in the 'posthistory' table. The placeholder in the WHERE clause represents the user's display name."
        },
        {
            "sample_id": 10012,
            "vt": "SELECT users.id FROM users WHERE users.views = (SELECT MIN(users.views) FROM users)",
            "ba": "The virtual table identifies the user with the least number of views from the 'users' table. The placeholder in the WHERE clause represents the condition to find the minimum views among all users."
        },
        {
            "sample_id": 10004,
            "vt": "SELECT posts.title FROM posts INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE users.displayname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of posts from the 'posts' table that are owned by users with a specific display name. The query joins the 'posts' table with the 'users' table to filter the results based on the user's display name, represented by a placeholder."
        },
        {
            "sample_id": 10013,
            "vt": "SELECT COUNT(badges.id) FROM badges WHERE STRFTIME('%Y', badges.date) = '[placeholder-type:string]' AND badges.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of badges obtained by users in a specific year and with a specific badge name from the 'badges' table. The placeholders represent the year and the badge name respectively."
        },
        {
            "sample_id": 10134,
            "vt": "SELECT posts.id, comments.text FROM comments INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE posts.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the IDs of posts along with their associated comments from the 'comments' and 'posts' tables. It uses an inner join to connect these two tables based on the post ID, ensuring that only comments related to the specified post title are included in the results. The placeholder in the WHERE clause represents the title of the post being queried."
        },
        {
            "sample_id": 10132,
            "vt": "SELECT COUNT(comments.id) FROM comments INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE posts.commentcount = [placeholder-type:numeric] AND posts.score = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of comments associated with posts that have a specific number of comments and a specific score. It joins the 'comments' table with the 'posts' table to filter the posts based on the provided criteria."
        },
        {
            "sample_id": 9996,
            "vt": "SELECT users.displayname FROM users WHERE users.websiteurl = '[placeholder-type:string]'",
            "ba": "The virtual table describes the display names of users from the 'users' table who have a specific website URL. The placeholder in the WHERE clause represents the website URL of the user."
        },
        {
            "sample_id": 9979,
            "vt": "SELECT CAST(SUM(CASE WHEN users.age > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(posts.id) FROM posts INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE posts.score > [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average of user ages for posts that have a score above a specified threshold. It sums the ages of users who are older than a certain age and applies a multiplier to this sum, then divides by the total count of posts that meet the score condition."
        },
        {
            "sample_id": 10052,
            "vt": "SELECT posts.tags FROM users INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE users.displayname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the tags associated with posts made by a specific user identified by their display name. It involves joining the 'users' table with the 'posthistory' table to find the posts made by that user, and then joining with the 'posts' table to access the tags related to those posts."
        },
        {
            "sample_id": 10120,
            "vt": "SELECT posts.commentcount, posts.answercount FROM posts WHERE posts.title = '[placeholder-type:string]'",
            "ba": "The virtual table provides the number of comments and answers associated with a specific post from the 'posts' table. The placeholder in the WHERE clause represents the title of the post being queried."
        },
        {
            "sample_id": 10088,
            "vt": "SELECT posts.id FROM votes INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE votes.userid = [placeholder-type:numeric] ORDER BY posts.favoritecount LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the IDs of posts that have been voted on by a specific user. It joins the 'votes' table with the 'posts' table to filter the posts based on the user ID and orders the results by the number of favorites each post has received, limiting the output to a specified number of results."
        },
        {
            "sample_id": 10121,
            "vt": "SELECT users.creationdate FROM users WHERE users.displayname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the creation date of a user from the 'users' table based on the user's display name. The placeholder in the WHERE clause represents the specific display name of the user."
        },
        {
            "sample_id": 10049,
            "vt": "SELECT COUNT(users.id) FROM users WHERE users.age BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users from the 'users' table whose age falls within a specified range. The placeholders represent the lower and upper bounds of the age range."
        },
        {
            "sample_id": 10124,
            "vt": "SELECT COUNT(posts.id) FROM posts WHERE posts.score < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of posts from the 'posts' table that have a score lower than a specified value. The placeholder in the WHERE clause represents the score threshold."
        },
        {
            "sample_id": 10089,
            "vt": "SELECT posts.title FROM posts INNER JOIN postLinks AS T2 ON T2.PostId = T1.Id ORDER BY posts.creaiondate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of posts from the 'posts' table, joining with the 'postlinks' table to associate related posts. The results are ordered by the creation date of the posts, and a limit is applied to restrict the number of titles returned."
        },
        {
            "sample_id": 10110,
            "vt": "SELECT COUNT(posts.id) FROM posts WHERE posts.viewcount > [placeholder-type:numeric] AND posts.commentcount = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of posts from the 'posts' table that have a view count greater than a specified number and have an exact number of comments. The placeholders represent the numeric values for the view count threshold and the comment count."
        },
        {
            "sample_id": 9963,
            "vt": "SELECT users.displayname FROM posts INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id ORDER BY posts.favoritecount LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the display names of users who own posts, sorted by the number of favorites each post has received. The query limits the results to a specified number of users."
        },
        {
            "sample_id": 10068,
            "vt": "SELECT posts.title, comments.userdisplayname FROM posts INNER JOIN comments AS T2 ON T2.PostId = T2.Id WHERE posts.score > [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of posts along with the display names of users who commented on those posts. It filters the posts to only include those with a score greater than a specified numeric value."
        },
        {
            "sample_id": 10116,
            "vt": "SELECT comments.text, users.displayname FROM users INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE posts.title = '[placeholder-type:string]' ORDER BY users.creationdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the text of comments and the display names of users who made those comments on posts with a specific title. The query joins the 'users', 'posts', and 'comments' tables to retrieve this information, filtering by the post title and limiting the number of results based on a numeric placeholder."
        },
        {
            "sample_id": 10045,
            "vt": "SELECT COUNT(users.id) FROM users INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE users.age > [placeholder-type:numeric] AND badges.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users from the 'users' table who have obtained a specific badge and are above a certain age. The query joins the 'users' table with the 'badges' table based on the user ID, applying filters for age and badge name."
        },
        {
            "sample_id": 10111,
            "vt": "SELECT users.displayname, users.location FROM posts INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE posts.id = [placeholder-type:numeric] ORDER BY posts.lasteditdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the display name and location of users who own a specific post from the 'posts' table. The query joins the 'users' table to retrieve the relevant user information based on the owner user ID of the post. The placeholders represent the unique post ID and the limit for the number of results returned."
        },
        {
            "sample_id": 10076,
            "vt": "SELECT users.displayname, users.location FROM tags INNER JOIN posts AS T2 ON T1.ExcerptPostId = T2.Id INNER JOIN users AS T3 ON T3.Id = T2.OwnerUserId WHERE tags.tagname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the display names and locations of users who have created posts associated with a specific tag. The query joins the 'tags' table with the 'posts' table to find posts that contain the specified tag, and then it joins with the 'users' table to retrieve the relevant user information."
        },
        {
            "sample_id": 10014,
            "vt": "SELECT COUNT(badges.userid) FROM (SELECT badges.userid, COUNT(badges.name) FROM badges GROUP BY UserId) AS t WHERE (SELECT UserId, COUNT(Name) AS num FROM badges GROUP BY UserId).num > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users who have obtained more than a specified number of badges. It first groups the badges by user ID and counts the number of badges each user has. Then, it filters this grouped data to only include users who have a badge count greater than a specified numeric value."
        },
        {
            "sample_id": 9961,
            "vt": "SELECT users.displayname FROM posts INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE posts.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the display names of users who own posts with a specific title from the 'posts' table. The query joins the 'users' table to retrieve the display name of the user associated with the post owner."
        },
        {
            "sample_id": 10003,
            "vt": "SELECT users.displayname FROM posts INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE posts.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the display names of users who own posts with a specific title from the 'posts' table. The query joins the 'users' table to retrieve the display name of the user associated with the post owner, using a placeholder for the post title."
        },
        {
            "sample_id": 10033,
            "vt": "SELECT users.reputation FROM users INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE badges.date = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the reputation of users from the 'users' table who have obtained badges on a specific date. The query joins the 'users' table with the 'badges' table to filter users based on the date they received their badges."
        },
        {
            "sample_id": 10043,
            "vt": "SELECT badges.name FROM users INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE users.reputation = (SELECT MIN(users.reputation) FROM users)",
            "ba": "The virtual table retrieves the names of badges obtained by the user with the lowest reputation from the 'users' table. It uses an inner join between the 'users' and 'badges' tables to connect users with their respective badges, filtering for the user with the minimum reputation."
        },
        {
            "sample_id": 10115,
            "vt": "SELECT COUNT(posts.id) FROM users INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T3.PostId = T2.Id ORDER BY users.creationdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of posts created by users, along with the comments associated with those posts. It joins the 'users' table with the 'posts' table to link each post to its owner, and then further joins the 'comments' table to include comments related to those posts. The results are ordered by the creation date of the users, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 9955,
            "vt": "SELECT COUNT(users.id) FROM users WHERE DATE(users.lastaccessdate) > '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users from the 'users' table who have accessed their accounts after a specific date. The placeholder in the WHERE clause represents the date to filter the users' last access date."
        },
        {
            "sample_id": 10123,
            "vt": "SELECT CAST(SUM(CASE WHEN posts.score > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(users.id) FROM users INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN (SELECT MAX(Reputation) AS max_reputation FROM users) AS T3 ON T1.Reputation = T3.max_reputation",
            "ba": "The virtual table calculates a weighted average score of posts created by users, where the score is adjusted based on a specified threshold. It sums the scores of posts that exceed this threshold and applies a multiplier, then divides by the total number of users to get the average. The query also ensures that only the posts from users with the maximum reputation are considered."
        },
        {
            "sample_id": 10085,
            "vt": "SELECT users.id FROM users WHERE users.age = (SELECT MIN(users.age) FROM users)",
            "ba": "The virtual table identifies the user with the minimum age from the 'users' table. It selects the 'id' of the user who is the youngest."
        },
        {
            "sample_id": 10126,
            "vt": "SELECT tags.excerptpostid, tags.wikipostid FROM tags WHERE tags.tagname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the excerpt post ID and wiki post ID from the 'tags' table for a specific tag name. The placeholder in the WHERE clause represents the name of the tag being queried."
        },
        {
            "sample_id": 9977,
            "vt": "SELECT AVG(posts.score) FROM posts INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE users.displayname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average score of posts created by users with a specific display name. It joins the 'posts' table with the 'users' table to filter posts based on the owner's display name, represented by a placeholder for string values."
        },
        {
            "sample_id": 9982,
            "vt": "SELECT COUNT(badges.id) FROM badges WHERE badges.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of badges obtained by users from the 'badges' table that match a specific badge name. The placeholder in the WHERE clause represents the name of the badge being queried."
        },
        {
            "sample_id": 10028,
            "vt": "SELECT badges.name FROM badges WHERE badges.date = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of badges obtained by users from the 'badges' table on a specific date. The placeholder in the WHERE clause represents the date when the badge was obtained."
        },
        {
            "sample_id": 10103,
            "vt": "SELECT users.displayname FROM users INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', posts.creaiondate) = '[placeholder-type:string]' AND posts.viewcount > [placeholder-type:numeric]",
            "ba": "The virtual table describes the display names of users from the 'users' table who own posts that were created in a specific year and have a view count greater than a specified number. The placeholders in the WHERE clause represent the year of creation and the minimum view count for filtering the results."
        },
        {
            "sample_id": 10010,
            "vt": "SELECT COUNT(comments.id) FROM comments WHERE comments.userid = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of comments made by a specific user from the 'comments' table. The placeholder in the WHERE clause represents the unique user ID for which the comment count is being retrieved."
        },
        {
            "sample_id": 10070,
            "vt": "SELECT users.displayname, users.websiteurl FROM users INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE posts.favoritecount > [placeholder-type:numeric]",
            "ba": "The virtual table describes the display names and website URLs of users from the 'users' table who own posts that have a high number of favorites. The placeholder in the WHERE clause represents the minimum favorite count for filtering the posts."
        },
        {
            "sample_id": 10059,
            "vt": "SELECT posts.tags FROM users INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId WHERE users.displayname = '[placeholder-type:string]' AND posts.commentcount = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the tags associated with posts made by a specific user, identified by their display name. It joins the 'users' table with the 'posthistory' table to find the posts made by that user, and then further joins with the 'posts' table to access the tags of those posts. Additionally, it filters the results to include only those posts that have a specific number of comments."
        },
        {
            "sample_id": 10001,
            "vt": "SELECT comments.text FROM comments INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE posts.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the text of comments associated with posts that have a specific title. It joins the 'comments' table with the 'posts' table to filter comments based on the title of the post."
        },
        {
            "sample_id": 9986,
            "vt": "SELECT comments.text FROM posts INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE posts.parentid = [placeholder-type:numeric] AND posts.commentcount = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the text of comments from the 'comments' table that are associated with posts from the 'posts' table. It specifically filters for posts that are child posts (indicated by a non-null parent ID) and have a specified number of comments."
        },
        {
            "sample_id": 10047,
            "vt": "SELECT COUNT(users.id) FROM users WHERE users.location = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users from the 'users' table who are located in a specific area. The placeholder in the WHERE clause represents the location of the users."
        },
        {
            "sample_id": 10113,
            "vt": "SELECT COUNT(users.id) FROM users WHERE users.age BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND users.upvotes > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users from the 'users' table who fall within a specific age range and have received more upvotes than a specified threshold. The placeholders represent the minimum and maximum ages, as well as the minimum number of upvotes."
        },
        {
            "sample_id": 9970,
            "vt": "SELECT users.location FROM posts INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE posts.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the location of users who own posts with a specific title from the 'posts' table. It uses an inner join to connect the 'posts' table with the 'users' table based on the owner user ID, allowing us to access user details related to their posts."
        },
        {
            "sample_id": 9981,
            "vt": "SELECT votes.creationdate FROM votes GROUP BY votes.creationdate ORDER BY COUNT(votes.id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the creation dates of votes from the 'votes' table, grouped by each unique creation date. It orders the results based on the count of votes for each date, allowing users to see which dates had the most voting activity. The placeholder in the LIMIT clause represents the maximum number of results to return."
        },
        {
            "sample_id": 10019,
            "vt": "SELECT COUNT(badges.id) FROM badges INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE users.location = '[placeholder-type:string]' AND badges.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of badges obtained by users from the 'badges' table, filtered by the users' location and the specific badge name. The placeholders represent the user's location and the badge name."
        },
        {
            "sample_id": 10098,
            "vt": "SELECT users.displayname FROM users WHERE users.age BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table describes the display names of users from the 'users' table who fall within a specific age range. The placeholders in the WHERE clause represent the minimum and maximum ages."
        },
        {
            "sample_id": 10060,
            "vt": "SELECT users.displayname FROM users INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE badges.\"name\" = '[placeholder-type:string]'",
            "ba": "The virtual table describes the display names of users from the 'users' table who have obtained a specific badge. The placeholder in the WHERE clause represents the name of the badge."
        },
        {
            "sample_id": 10105,
            "vt": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', posts.creaiondate) = '[placeholder-type:string]' AND users.reputation > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(users.id) FROM users INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId",
            "ba": "The virtual table calculates a weighted average score based on the reputation of users who created posts in a specific year. It sums a value based on a condition that checks if the post's creation year matches a specified year and if the user's reputation exceeds a certain threshold. The result is then multiplied by a placeholder value and divided by the count of users to provide an average score."
        },
        {
            "sample_id": 10073,
            "vt": "SELECT posts.title FROM postlinks INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN posts AS T3 ON T1.RelatedPostId = T3.Id WHERE posts.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the titles of posts that are linked to other related posts in the 'postlinks' table. It uses inner joins to connect the 'postlinks' table with the 'posts' table twice, once for the original post and once for the related post. The placeholder in the WHERE clause represents the title of the post being queried."
        },
        {
            "sample_id": 10032,
            "vt": "SELECT badges.name FROM users INNER JOIN badges AS T2 ON T1.Id = T2.UserId ORDER BY users.reputation LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of badges obtained by users, ordered by their reputation. The placeholder in the LIMIT clause allows for specifying the maximum number of badge names to retrieve."
        },
        {
            "sample_id": 9969,
            "vt": "SELECT COUNT(posts.id) FROM posts INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE posts.score >= [placeholder-type:numeric] AND users.age > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of posts from the 'posts' table that have a score greater than a specified value and are owned by users older than a specified age. It joins the 'posts' table with the 'users' table to filter based on the owner's age."
        },
        {
            "sample_id": 9997,
            "vt": "SELECT badges.name FROM users INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE users.displayname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of badges obtained by users from the 'badges' table, specifically for a user identified by their display name from the 'users' table. The placeholder in the WHERE clause represents the user's display name."
        },
        {
            "sample_id": 9964,
            "vt": "SELECT SUM(posts.commentcount) FROM posts INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE users.displayname = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total number of comments from posts created by a specific user. It retrieves the sum of the 'commentcount' from the 'posts' table, joining it with the 'users' table to filter by the user's display name."
        },
        {
            "sample_id": 9990,
            "vt": "SELECT users.displayname FROM users INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE votes.id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the display names of users who have voted on a specific post. It joins the 'users' table with the 'votes' table to find the relevant user information based on the vote ID provided."
        },
        {
            "sample_id": 9966,
            "vt": "SELECT users.displayname FROM posts INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE posts.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the display names of users who last edited posts from the 'posts' table, filtered by a specific post title. The placeholder in the WHERE clause represents the title of the post."
        },
        {
            "sample_id": 10090,
            "vt": "SELECT users.displayname FROM users INNER JOIN badges AS T2 ON T1.Id = T2.UserId GROUP BY users.displayname ORDER BY COUNT(users.id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the display names of users from the 'users' table who have obtained badges, showing only unique names. The results are grouped by the display name and ordered by the count of badges each user has obtained, limiting the output to a specified number of users."
        },
        {
            "sample_id": 10135,
            "vt": "SELECT users.upvotes FROM comments INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE comments.text = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the number of upvotes for users who have commented with a specific text. It joins the 'comments' table with the 'users' table to associate each comment with the corresponding user, filtering based on the content of the comment."
        },
        {
            "sample_id": 9962,
            "vt": "SELECT posts.title FROM posts INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE users.displayname = '[placeholder-type:string]' ORDER BY posts.viewcount LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of posts from the 'posts' table that are owned by users with a specific display name. It joins the 'posts' table with the 'users' table to filter the results based on the user's display name. The results are ordered by the view count of the posts, and a limit is applied to restrict the number of titles returned."
        },
        {
            "sample_id": 10051,
            "vt": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', votes.creationdate) = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN STRFTIME('%Y', votes.creationdate) = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM votes",
            "ba": "The virtual table calculates the average number of votes received by posts in a specific year. It uses the 'votes' table to sum the votes based on the creation date filtered by the specified year. The placeholders represent the year and the numeric values for the votes."
        },
        {
            "sample_id": 9956,
            "vt": "SELECT users.displayname FROM users WHERE users.views = (SELECT MAX(users.views) FROM users)",
            "ba": "The virtual table displays the display names of users from the 'users' table who have the highest number of views. The placeholder in the WHERE clause represents the maximum view count among all users."
        },
        {
            "sample_id": 10007,
            "vt": "SELECT SUM(votes.bountyamount) FROM posts INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE posts.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total bounty amount associated with posts that have a specific title. It retrieves this information by joining the 'posts' table with the 'votes' table, where the title of the post matches a specified string."
        },
        {
            "sample_id": 10108,
            "vt": "SELECT posts.id FROM posts WHERE posts.viewcount > (SELECT AVG(posts.viewcount) FROM posts)",
            "ba": "The virtual table identifies the unique post IDs from the 'posts' table that have a view count greater than the average view count of all posts. This allows users to find posts that are more popular than the average."
        },
        {
            "sample_id": 10017,
            "vt": "SELECT posthistory.userid FROM users INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE posts.viewcount >= [placeholder-type:numeric] GROUP BY posthistory.userid HAVING COUNT(DISTINCT T2.PostHistoryTypeId) = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the user IDs of users who have a significant number of post history entries related to posts that have a high view count. The query filters users based on the view count of their posts and groups the results by user ID, ensuring that only those users who have a specific number of distinct post history types are included."
        },
        {
            "sample_id": 9989,
            "vt": "SELECT COUNT(users.id) FROM users INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE users.displayname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users from the 'users' table who have created posts. It filters the results based on the display name of the user, which is provided as a placeholder. This allows for identifying how many posts a specific user has authored."
        },
        {
            "sample_id": 10117,
            "vt": "SELECT COUNT(badges.id) FROM badges WHERE badges.\"name\" = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of badges obtained by users from the 'badges' table that match a specific badge name. The placeholder in the WHERE clause represents the badge's name."
        },
        {
            "sample_id": 9992,
            "vt": "SELECT badges.name FROM users INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE users.displayname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of badges obtained by users from the 'badges' table, filtered by the user's display name from the 'users' table. The placeholder in the WHERE clause represents the specific display name of the user."
        },
        {
            "sample_id": 10104,
            "vt": "SELECT posts.owneruserid, users.displayname FROM users INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', users.creationdate) = '[placeholder-type:string]' ORDER BY posts.favoritecount LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the owner user IDs and their corresponding display names from the 'users' table who created their accounts in a specific year. The query joins the 'users' table with the 'posts' table to filter users based on the year of account creation, using a placeholder for the year and ordering the results by the number of favorites of their posts, limiting the output to a specified number."
        },
        {
            "sample_id": 10048,
            "vt": "SELECT COUNT(votes.id) FROM votes WHERE STRFTIME('%Y', votes.creationdate) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of votes from the 'votes' table for a specific year. The placeholder in the WHERE clause represents the year for which the vote count is being queried."
        },
        {
            "sample_id": 10054,
            "vt": "SELECT COUNT(users.id) FROM users INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN votes AS T3 ON T3.PostId = T2.PostId WHERE users.displayname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users who have participated in post history and voting, filtered by a specific user's display name. It joins the 'users' table with the 'postHistory' table to find the relevant user activities and then further joins with the 'votes' table to include only those users who have cast votes on posts."
        },
        {
            "sample_id": 10078,
            "vt": "SELECT users.displayname FROM users WHERE posts.id = (SELECT posts.owneruserid FROM posts WHERE NOT ParentId IS NULL ORDER BY Score DESC LIMIT 1)",
            "ba": "The virtual table retrieves the display names of users who own the highest-scoring child post from the 'posts' table. The query uses a subquery to find the owner user ID of the child post, which is determined by checking that the ParentId is not null, indicating it is a child post. The results are ordered by the score of the posts in descending order, and only the top result is selected."
        },
        {
            "sample_id": 10072,
            "vt": "SELECT users.lastaccessdate, users.location FROM users INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE badges.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about users' last access date and location from the 'users' table, specifically for those users who have obtained a badge with a specified name. The query uses an INNER JOIN to connect the 'users' table with the 'badges' table based on the user ID, filtering the results to include only those badges that match the given name."
        }
    ],
    "coinmarketcap": [
        {
            "sample_id": 6286,
            "vt": "SELECT coins.name FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE historical.volume_24h = (SELECT MAX(historical.volume_24h) FROM historical)",
            "ba": "The virtual table lists the names of coins from the 'coins' table that have the highest trading volume in the last 24 hours, by joining with the 'historical' table to access the volume data."
        },
        {
            "sample_id": 6280,
            "vt": "SELECT coins.name, coins.symbol FROM coins WHERE coins.date_added LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the names and symbols of coins from the 'coins' table that were added on a specific date. The placeholder in the WHERE clause represents the date when the coins were added."
        },
        {
            "sample_id": 6263,
            "vt": "SELECT coins.name FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE historical.date = '[placeholder-type:string]' AND historical.cmc_rank = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of coins from the 'coins' table that are associated with a specific transaction date and have a particular CMC rank. The placeholders in the WHERE clause represent the date and CMC rank criteria for filtering the results."
        },
        {
            "sample_id": 6257,
            "vt": "SELECT AVG(historical.price) FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE coins.name = '[placeholder-type:string]' AND STRFTIME('%Y', historical.date) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average price of a specific coin from the 'coins' table by joining it with the 'historical' table based on the coin's unique identifier. The query filters the results based on the coin's name and the year of the transaction date, both represented by placeholders for user input."
        },
        {
            "sample_id": 6277,
            "vt": "SELECT coins.name FROM coins WHERE coins.status = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of coins from the 'coins' table that have a specific status. The placeholder in the WHERE clause represents the status of the coins, which can be active, untracked, inactive, or extinct."
        },
        {
            "sample_id": 6293,
            "vt": "SELECT historical.date FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE coins.name = '[placeholder-type:string]' ORDER BY historical.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the transaction dates of a specific coin from the 'coins' table by joining it with the 'historical' table based on the coin's unique identifier. The results are filtered by the coin's name and ordered by the price, with a limit on the number of records returned."
        },
        {
            "sample_id": 6279,
            "vt": "SELECT COUNT(id) AS num FROM coins WHERE STRFTIME('%Y-%m', date_added) = '2013-05' UNION ALL SELECT name FROM coins WHERE STRFTIME('%Y-%m', date_added) = '2013-05'",
            "ba": "The virtual table provides a count of coins added in May 2013 and lists their names. It combines two queries: one that counts the number of coins added during that month and another that retrieves the names of those coins."
        },
        {
            "sample_id": 6252,
            "vt": "SELECT historical.time_high, historical.time_low, historical.date FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE coins.name = '[placeholder-type:string]' AND STRFTIME('%Y-%m', historical.date) = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the highest and lowest prices of a specific coin over a specified month. It retrieves the time of these price points along with the corresponding date from the 'historical' table, which is linked to the 'coins' table based on the coin's unique identifier. The placeholders allow users to specify the coin's name and the month they are interested in."
        },
        {
            "sample_id": 6273,
            "vt": "SELECT coins.name FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE historical.date = '[placeholder-type:string]' AND coins.name IN ('[placeholder-type:string]', '[placeholder-type:string]') ORDER BY historical.circulating_supply LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of specific coins from the 'coins' table that have historical transaction data on a given date. It filters the results based on the specified date and a list of coin names, ordering the results by their circulating supply and limiting the number of results returned."
        },
        {
            "sample_id": 6290,
            "vt": "SELECT historical.date FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE coins.name = '[placeholder-type:string]' ORDER BY historical.market_cap LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the transaction dates of a specific coin from the 'coins' table by joining it with the 'historical' table based on the coin's unique identifier. The results are filtered by the coin's name and ordered by market capitalization, with a limit on the number of records returned."
        },
        {
            "sample_id": 6275,
            "vt": "SELECT AVG(historical.price) FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE STRFTIME('%Y', historical.date) = '[placeholder-type:string]' AND coins.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average price of a specific coin from the 'coins' table, based on its name, for a given year. The query joins the 'coins' table with the 'historical' table using the coin's unique identifier. The placeholders represent the year and the name of the coin, allowing users to specify which coin's average price they want to retrieve for that year."
        },
        {
            "sample_id": 6276,
            "vt": "SELECT CAST((SUM(historical.max_supply) - SUM(historical.total_supply)) AS FLOAT) / SUM(historical.total_supply) FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE historical.date < '[placeholder-type:string]' AND coins.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage of coins that have been burned relative to the total supply of a specific coin by joining the 'coins' and 'historical' tables. It sums the difference between the maximum supply and total supply of the coin, divides it by the total supply, and filters the results based on a specific date and coin name."
        },
        {
            "sample_id": 6255,
            "vt": "SELECT CAST(SUM(historical.circulating_supply) AS FLOAT) / [placeholder-type:numeric] FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE coins.name = '[placeholder-type:string]' AND STRFTIME('%Y', historical.date) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average circulating supply of a specific coin over a given year. It joins the 'coins' table with the 'historical' table based on the coin's ID, filtering by the coin's name and the year of the transaction date."
        },
        {
            "sample_id": 6285,
            "vt": "SELECT historical.date FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE coins.name = '[placeholder-type:string]' ORDER BY historical.low LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the transaction dates of a specific coin from the 'coins' table by joining it with the 'historical' table based on the coin's unique identifier. The results are filtered by the coin's name and ordered by the lowest price recorded in the historical data, with a limit on the number of results returned."
        },
        {
            "sample_id": 6291,
            "vt": "SELECT coins.name FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE historical.date = '[placeholder-type:string]' AND historical.cmc_rank <= [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of coins from the 'coins' table that have historical data matching a specific date and a CMC rank that is less than or equal to a specified value. The placeholders in the WHERE clause represent the date and the CMC rank criteria."
        },
        {
            "sample_id": 6254,
            "vt": "SELECT coins.name, historical.date, historical.price FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE historical.percent_change_24h = (SELECT MAX(historical.percent_change_24h) FROM historical)",
            "ba": "The virtual table displays the names of coins along with their historical transaction dates and prices. It retrieves data from the 'coins' table and the 'historical' table, joining them based on the coin's unique identifier. The query specifically filters for the coin that has experienced the highest percentage change in price over the last 24 hours, ensuring that users can identify which coin has had the most significant price movement recently."
        },
        {
            "sample_id": 6264,
            "vt": "SELECT historical.market_cap FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE historical.date = '[placeholder-type:string]' AND coins.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the market capitalization of a specific coin from the 'coins' and 'historical' tables based on a given date and the coin's name. The placeholders represent the date for which the market cap is being queried and the name of the coin."
        },
        {
            "sample_id": 6256,
            "vt": "SELECT coins.name, MAX(historical.date) FROM coins INNER JOIN historical AS T2 ON T1.ID = T2.coin_id WHERE coins.status = '[placeholder-type:string]' ORDER BY historical.date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of coins from the 'coins' table along with the most recent transaction date from the 'historical' table. It filters the results based on the status of the coins, which can be active, untracked, inactive, or extinct. The query also limits the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 6269,
            "vt": "SELECT historical.max_supply - historical.total_supply FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE historical.date = '[placeholder-type:string]' AND coins.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the number of coins that have been verifiably burned by subtracting the total supply from the maximum supply for a specific coin on a given date. It retrieves this information by joining the 'coins' table with the 'historical' table based on the coin's ID, while filtering for a specific date and coin name."
        },
        {
            "sample_id": 6294,
            "vt": "SELECT COUNT(historical.coin_id) FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE coins.name = '[placeholder-type:string]' AND STRFTIME('%Y-%m', historical.date) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of historical records for a specific coin based on its name and the date in a specified month. It joins the 'coins' table with the 'historical' table using the coin's unique identifier, filtering results to match the provided coin name and the formatted date string representing the year and month."
        },
        {
            "sample_id": 6251,
            "vt": "SELECT T2.price FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Zetacoin' AND T2.date BETWEEN '2013-11-01' AND '2013-11-07' UNION ALL SELECT AVG(T2.PRICE) FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Zetacoin' AND T2.date BETWEEN '2013-11-01' AND '2013-11-07'",
            "ba": "The virtual table retrieves the price of a specific coin, identified by its name, from the 'coins' table and correlates it with historical price data from the 'historical' table for a specified date range. Additionally, it calculates the average price of the same coin over that date range. The placeholders in the query represent the coin's name and the date range for which the prices are being queried."
        },
        {
            "sample_id": 6253,
            "vt": "SELECT historical.date FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE coins.name = '[placeholder-type:string]' ORDER BY historical.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the transaction dates of a specific coin from the 'coins' table by joining it with the 'historical' table based on the coin's unique identifier. The results are filtered by the coin's name and ordered by the price, with a limit on the number of records returned."
        },
        {
            "sample_id": 6265,
            "vt": "SELECT coins.name FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE historical.date = '[placeholder-type:string]' AND historical.open IS NULL",
            "ba": "The virtual table describes the names of coins from the 'coins' table that have not opened yet on a specific date. It joins the 'coins' table with the 'historical' table based on the coin's ID, filtering for records where the opening price is null and the date matches a specified placeholder."
        },
        {
            "sample_id": 6268,
            "vt": "SELECT historical.high - historical.low FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE historical.date = '[placeholder-type:string]' AND coins.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the maximum profit that can be made today by subtracting the lowest price from the highest price of a specific coin on a given date. It retrieves this information by joining the 'coins' table with the 'historical' table based on the coin's unique identifier. The placeholders represent the date for which the historical data is being queried and the name of the coin."
        },
        {
            "sample_id": 6278,
            "vt": "SELECT coins.description FROM coins WHERE coins.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the description of a specific coin from the 'coins' table based on its name. The placeholder in the WHERE clause represents the name of the coin being queried."
        },
        {
            "sample_id": 6288,
            "vt": "SELECT historical.date FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE coins.name = '[placeholder-type:string]' ORDER BY historical.close LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the transaction dates of a specific coin from the 'coins' table by joining it with the 'historical' table based on the coin's unique identifier. The results are filtered by the coin's name and ordered by the closing price, with a limit on the number of records returned."
        },
        {
            "sample_id": 6281,
            "vt": "SELECT coins.name FROM coins WHERE coins.date_added LIKE '[placeholder-type:string]' AND coins.status = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of coins from the 'coins' table that were added on a specific date and have a specific status. The placeholders in the WHERE clause represent the date added and the status of the coins."
        },
        {
            "sample_id": 6292,
            "vt": "SELECT DISTINCT historical.date FROM coins INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE coins.name = '[placeholder-type:string]' AND (historical.open IS NULL OR historical.open = [placeholder-type:numeric])",
            "ba": "The virtual table retrieves distinct transaction dates for a specific coin from the 'coins' and 'historical' tables. It filters the results based on the coin's name and checks if the opening price is either null or zero, indicating that the coin has not opened yet for trading on that date."
        }
    ],
    "citeseer": [
        {
            "sample_id": 4149,
            "vt": "SELECT DISTINCT paper.paper_id, paper.class_label FROM paper INNER JOIN content AS T2 ON T1.paper_id = T2.paper_id GROUP BY content.paper_id, paper.class_label HAVING COUNT(content.word_cited_id) > [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of paper IDs and their corresponding class labels from the 'paper' table, filtered by the number of words cited in the associated content. The query joins the 'paper' table with the 'content' table to ensure that only papers with a specified count of cited words are included."
        },
        {
            "sample_id": 4156,
            "vt": "SELECT paper.paper_id FROM paper INNER JOIN content AS T2 ON T1.paper_id = T2.paper_id WHERE paper.class_label = '[placeholder-type:string]' GROUP BY paper.paper_id ORDER BY COUNT(content.word_cited_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique IDs of papers from the 'paper' table that belong to a specific class label. It joins the 'content' table to count the occurrences of words cited in each paper. The results are grouped by paper ID and ordered by the count of cited words, with a limit on the number of results returned."
        },
        {
            "sample_id": 4151,
            "vt": "SELECT cites.cited_paper_id, COUNT(cites.cited_paper_id), (SELECT cites.cited_paper_id FROM cites GROUP BY cited_paper_id ORDER BY COUNT(cited_paper_id) ASC LIMIT 1), (SELECT COUNT(cites.cited_paper_id) FROM cites GROUP BY cited_paper_id ORDER BY COUNT(cited_paper_id) ASC LIMIT 1) FROM cites GROUP BY cites.cited_paper_id ORDER BY COUNT(cites.cited_paper_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the citation relationships between papers. It retrieves the cited paper IDs along with the count of how many times each paper has been cited. Additionally, it includes a subquery to find the least cited paper ID and its corresponding citation count. The results are grouped by the cited paper ID and ordered by the citation count, with a limit on the number of results returned based on a numeric placeholder."
        },
        {
            "sample_id": 4139,
            "vt": "SELECT CAST(COUNT(CASE WHEN paper.class_label = '[placeholder-type:string]' THEN paper.paper_id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(paper.paper_id) FROM paper",
            "ba": "The virtual table calculates the proportion of papers with a specific class label in relation to the total number of papers. It counts the number of papers that match the specified class label and multiplies this count by a numeric placeholder, then divides by the total count of papers."
        },
        {
            "sample_id": 4148,
            "vt": "SELECT DISTINCT paper.class_label, COUNT(content.word_cited_id) FROM paper INNER JOIN content AS T2 ON T1.paper_id = T2.paper_id WHERE paper.paper_id = '[placeholder-type:string]' GROUP BY paper.class_label",
            "ba": "The virtual table summarizes the distinct class labels of papers along with the count of words cited in each paper. It joins the 'paper' and 'content' tables based on the paper ID, filtering for a specific paper ID using a placeholder. The result groups the data by class label, providing insights into the classification and citation frequency of the specified paper."
        },
        {
            "sample_id": 4152,
            "vt": "SELECT CAST(COUNT(CASE WHEN paper.class_label = '[placeholder-type:string]' THEN paper.paper_id ELSE NULL END) AS FLOAT) / COUNT(paper.paper_id) FROM paper",
            "ba": "The virtual table calculates the proportion of papers with a specific class label in relation to the total number of papers. It counts the number of papers that match the specified class label and divides it by the total count of papers, providing a ratio that reflects the prevalence of that class label among all papers."
        },
        {
            "sample_id": 4146,
            "vt": "SELECT paper.paper_id, paper.class_label FROM paper INNER JOIN content AS T2 ON T1.paper_id = T2.paper_id WHERE content.word_cited_id = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique paper IDs and their corresponding class labels from the 'paper' table, filtered by the presence of a specific word in the content of the paper. The placeholder in the WHERE clause represents the word being cited."
        },
        {
            "sample_id": 4140,
            "vt": "SELECT content.word_cited_id, COUNT(content.paper_id) FROM content GROUP BY content.word_cited_id ORDER BY COUNT(content.word_cited_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the count of papers for each word cited in the content of papers. It groups the results by the 'word_cited_id' to show how many papers reference each word, and orders the results by the count of occurrences, limiting the output to a specified number of results."
        },
        {
            "sample_id": 4145,
            "vt": "SELECT paper.paper_id, paper.class_label FROM paper INNER JOIN content AS T2 ON T1.paper_id = T2.paper_id GROUP BY paper.paper_id, paper.class_label ORDER BY COUNT(content.word_cited_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique paper IDs and their corresponding class labels from the 'paper' table, while also considering the presence of words cited in the associated 'content' table. It groups the results by paper ID and class label, orders them based on the count of cited words, and limits the output to a specified number of results."
        },
        {
            "sample_id": 4143,
            "vt": "SELECT content.word_cited_id FROM paper INNER JOIN content AS T2 ON T1.paper_id = T2.paper_id WHERE paper.class_label = '[placeholder-type:string]' GROUP BY content.word_cited_id ORDER BY COUNT(content.word_cited_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the word cited IDs from the 'content' table for papers that belong to a specific class label in the 'paper' table. It uses an inner join to connect the two tables based on the paper ID, ensuring that only relevant content is selected. The results are grouped by the word cited ID and ordered by the count of occurrences, with a limit on the number of results returned."
        },
        {
            "sample_id": 4147,
            "vt": "SELECT DISTINCT content.word_cited_id FROM paper INNER JOIN content AS T2 ON T1.paper_id = T2.paper_id WHERE paper.class_label = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct word identifiers that are cited in papers classified under a specific class label. It joins the 'paper' and 'content' tables based on the paper ID, filtering results to include only those papers that match the specified class label."
        }
    ],
    "card_games": [
        {
            "sample_id": 9856,
            "vt": "SELECT COUNT(sets.id) FROM sets INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE set_translations.language = '[placeholder-type:string]' AND (sets.mtgocode IS NULL OR sets.mtgocode = '[placeholder-type:string]')",
            "ba": "The virtual table counts the number of sets from the 'sets' table that have translations in a specified language. It joins the 'sets' table with the 'set_translations' table to filter sets based on the provided language and checks if the set is either not available on Magic: The Gathering Online or has a specific Magic: The Gathering Online code."
        },
        {
            "sample_id": 9874,
            "vt": "SELECT DISTINCT cards.name FROM cards WHERE cards.istextless = [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct names of cards from the 'cards' table that have a specific property indicating whether they are textless or not. The placeholder in the WHERE clause represents a numeric value that determines if the card is textless (1) or not (0)."
        },
        {
            "sample_id": 9773,
            "vt": "SELECT cards.name FROM cards INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE foreign_data.language = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of cards from the 'cards' table that have corresponding foreign data in a specified language. The query uses an INNER JOIN to connect the 'cards' table with the 'foreign_data' table based on the unique identifier 'uuid'. The WHERE clause filters the results to include only those entries where the language matches a specified placeholder value."
        },
        {
            "sample_id": 9805,
            "vt": "SELECT COUNT(cards.id) FROM cards INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE legalities.status = '[placeholder-type:string]' AND cards.bordercolor = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cards from the 'cards' table that have a specific legality status and a specified border color. The placeholders in the WHERE clause represent the legality status and the border color of the cards."
        },
        {
            "sample_id": 9913,
            "vt": "SELECT sets.mcmname FROM sets WHERE sets.releasedate = '[placeholder-type:string]'",
            "ba": "The virtual table provides the name of card sets from the 'sets' table that were released on a specific date. The placeholder in the WHERE clause represents the release date of the set."
        },
        {
            "sample_id": 9816,
            "vt": "SELECT COUNT(cards.id) FROM cards WHERE cards.bordercolor = '[placeholder-type:string]' AND NOT cards.cardkingdomid IS NULL AND NOT cards.cardkingdomfoilid IS NULL",
            "ba": "The virtual table counts the number of cards from the 'cards' table that have a specific border color and are associated with both a card kingdom ID and a card kingdom foil ID. The placeholders in the WHERE clause represent the border color of the cards."
        },
        {
            "sample_id": 9915,
            "vt": "SELECT sets.parentcode FROM sets WHERE sets.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the parent code of a specific card set from the 'sets' table based on the set's name. The placeholder in the WHERE clause represents the name of the card set being queried."
        },
        {
            "sample_id": 9788,
            "vt": "SELECT legalities.format FROM cards INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE cards.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the formats in which a specific card is legal to play from the 'legalities' table by joining it with the 'cards' table based on their unique identifiers. The placeholder in the WHERE clause represents the name of the card being queried."
        },
        {
            "sample_id": 9877,
            "vt": "SELECT DISTINCT cards.name FROM cards WHERE cards.ispromo = [placeholder-type:numeric] AND NOT cards.side IS NULL",
            "ba": "The virtual table lists the distinct names of cards from the 'cards' table that are promotional and have multiple faces. The placeholder in the WHERE clause indicates whether to filter for promotional cards based on a numeric value."
        },
        {
            "sample_id": 9764,
            "vt": "SELECT cards.name FROM cards ORDER BY cards.faceconvertedmanacost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of cards from the 'cards' table, ordered by their face converted mana cost. The result is limited to a specified number of entries, allowing users to retrieve a manageable subset of card names based on their mana cost."
        },
        {
            "sample_id": 9780,
            "vt": "SELECT DISTINCT cards.bordercolor FROM cards WHERE cards.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct border colors of cards from the 'cards' table based on a specific card name. The placeholder in the WHERE clause represents the name of the card being queried."
        },
        {
            "sample_id": 9904,
            "vt": "SELECT DISTINCT cards.type FROM cards INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE cards.name = '[placeholder-type:string]' AND foreign_data.language = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct card types from the 'cards' table based on the card's name and the language of the foreign data. It joins the 'cards' table with the 'foreign_data' table using the unique identifier (uuid) to ensure that the correct foreign language data is associated with each card."
        },
        {
            "sample_id": 9785,
            "vt": "SELECT COUNT(DISTINCT T1.id) FROM cards INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE legalities.status = '[placeholder-type:string]' AND cards.isstarter = [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct card IDs from the 'cards' table that are associated with specific legalities. It filters the results based on the legality status and whether the card is part of a starter deck."
        },
        {
            "sample_id": 9929,
            "vt": "SELECT CAST(SUM(CASE WHEN sets.isonlineonly = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(sets.id) FROM sets WHERE sets.code IN (SELECT set_translations.setcode FROM set_translations WHERE language = 'Portuguese (Brazil)')",
            "ba": "The virtual table calculates the average value of a specific attribute from the 'sets' table, specifically focusing on sets that are only available online. It uses a conditional sum to differentiate between online-only sets and others, applying a multiplier to the result. The query filters the sets based on their translations in Portuguese (Brazil)."
        },
        {
            "sample_id": 9909,
            "vt": "SELECT CAST(SUM(CASE WHEN NOT cards.cardkingdomfoilid IS NULL AND NOT cards.cardkingdomid IS NULL THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(cards.id) FROM cards INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE sets.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average value of a specific metric related to cards from a particular set. It sums up a conditional count of cards that have both a non-null card kingdom foil ID and a non-null card kingdom ID, multiplies this sum by a placeholder numeric value, and then divides it by the total count of card IDs. The query filters the results based on the name of the set, which is provided as a string placeholder."
        },
        {
            "sample_id": 9811,
            "vt": "SELECT cards.id, rulings.date FROM cards INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE cards.originaltype = '[placeholder-type:string]'",
            "ba": "The virtual table displays the IDs of cards along with their corresponding ruling dates from the 'cards' and 'rulings' tables. It filters the results based on the original type of the card, which is specified by a placeholder."
        },
        {
            "sample_id": 9870,
            "vt": "SELECT DISTINCT cards.name, cards.type FROM cards INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE cards.watermark = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of card names and their types from the 'cards' table, specifically filtering for cards that have a certain watermark. The watermark is specified using a placeholder for string values, allowing users to input the desired watermark to retrieve relevant card information."
        },
        {
            "sample_id": 9763,
            "vt": "SELECT cards.id FROM cards WHERE cards.bordercolor = '[placeholder-type:string]' AND (cards.cardkingdomid IS NULL OR cards.cardkingdomid IS NULL)",
            "ba": "The virtual table retrieves the IDs of cards from the 'cards' table that have a specific border color and do not have a Card Kingdom ID associated with them."
        },
        {
            "sample_id": 9841,
            "vt": "SELECT COUNT(cards.id) FROM cards WHERE cards.edhrecrank > [placeholder-type:numeric] AND cards.bordercolor = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cards from the 'cards' table that have an EDHRec rank greater than a specified value and a specific border color. The placeholders represent the numeric rank threshold and the string value for the border color."
        },
        {
            "sample_id": 9901,
            "vt": "SELECT SUM(CASE WHEN cards.power LIKE '[placeholder-type:string]' OR cards.power IS NULL THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM cards INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE sets.name = '[placeholder-type:string]' AND cards.convertedmanacost > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total power of cards from the 'cards' table that meet specific criteria. It sums the power of cards that either match a given string pattern or have a null value, while also applying a filter based on the set name and the converted mana cost of the cards."
        },
        {
            "sample_id": 9928,
            "vt": "SELECT CAST(SUM(CASE WHEN sets.isnonfoilonly = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(sets.id) FROM sets WHERE sets.code IN (SELECT set_translations.setcode FROM set_translations WHERE language = 'Japanese')",
            "ba": "The virtual table calculates the average value of a specific attribute from the 'sets' table, specifically focusing on sets that are only available in non-foil format. It sums up the values based on a condition and divides it by the total count of sets that match a specific language translation, in this case, Japanese. The placeholders represent numeric values that can be adjusted to filter or modify the calculation as needed."
        },
        {
            "sample_id": 9799,
            "vt": "SELECT COUNT(cards.id) FROM cards WHERE cards.originaltype = '[placeholder-type:string]' AND cards.subtypes <> '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cards from the 'cards' table that have a specific original type and do not belong to a specified subtype. The placeholders represent the original type and subtype criteria for filtering the results."
        },
        {
            "sample_id": 9880,
            "vt": "SELECT COUNT(CASE WHEN cards.availability LIKE '[placeholder-type:string]' AND cards.bordercolor = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE NULL END) FROM cards",
            "ba": "The virtual table counts the number of cards from the 'cards' table that match specific criteria for availability and border color. The placeholders represent the desired availability type and border color, allowing users to filter the results based on their preferences."
        },
        {
            "sample_id": 9920,
            "vt": "SELECT set_translations.translation FROM cards INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE cards.name = '[placeholder-type:string]' AND set_translations.language = '[placeholder-type:string]' AND NOT set_translations.translation IS NULL",
            "ba": "The virtual table retrieves the translations of card set names from the 'set_translations' table based on the card's name and the specified language. It ensures that only non-null translations are returned."
        },
        {
            "sample_id": 9927,
            "vt": "SELECT set_translations.translation FROM set_translations WHERE set_translations.setcode IN (SELECT sets.code FROM sets WHERE name = 'Mirrodin') AND set_translations.language = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the translations of a specific card set from the 'set_translations' table. It filters the results based on the set code associated with the set name 'Mirrodin' from the 'sets' table, and it further narrows down the results to a specific language using a placeholder."
        },
        {
            "sample_id": 9779,
            "vt": "SELECT cards.promotypes FROM cards WHERE cards.name = '[placeholder-type:string]' AND NOT cards.promotypes IS NULL",
            "ba": "The virtual table retrieves the promotional types associated with a specific card from the 'cards' table. It filters the results based on the card's name, ensuring that only cards with non-null promotional types are included."
        },
        {
            "sample_id": 9801,
            "vt": "SELECT cards.id FROM cards WHERE cards.dueldeck = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of cards from the 'cards' table that belong to a specific duel deck. The placeholder in the WHERE clause represents the name of the duel deck."
        },
        {
            "sample_id": 9873,
            "vt": "SELECT SUM(CASE WHEN cards.availability = '[placeholder-type:string]' AND cards.hand = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM cards",
            "ba": "The virtual table calculates the total sum of a specified numeric value from the 'cards' table, based on conditions related to the card's availability and hand size. The placeholders represent the specific availability type and hand size to filter the results accordingly."
        },
        {
            "sample_id": 9847,
            "vt": "SELECT cards.id FROM cards WHERE cards.subtypes = '[placeholder-type:string]' AND cards.side IS NULL",
            "ba": "The virtual table retrieves the unique identifiers of cards from the 'cards' table that belong to a specific subtype and do not have multiple faces."
        },
        {
            "sample_id": 9815,
            "vt": "SELECT COUNT(cards.id) FROM cards WHERE (cards.cardkingdomid IS NULL OR cards.cardkingdomfoilid IS NULL) AND cards.artist = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cards from the 'cards' table where either the 'cardkingdomid' or 'cardkingdomfoilid' is null, indicating that these cards do not have a corresponding entry in the Card Kingdom database. Additionally, it filters the results based on the artist's name provided as a placeholder."
        },
        {
            "sample_id": 9863,
            "vt": "SELECT set_translations.setcode FROM sets INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE sets.releasedate = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the set codes of card sets from the 'sets' table that were released on a specific date. It uses an inner join with the 'set_translations' table to link the set codes, allowing for translations of the set names to be included in the results."
        },
        {
            "sample_id": 9808,
            "vt": "SELECT COUNT(cards.id) FROM cards INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE cards.frameversion = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cards from the 'cards' table that have a specific frame version. It joins the 'legalities' table to filter the results based on the card's unique identifier (uuid). The placeholder in the WHERE clause represents the frame version being queried."
        },
        {
            "sample_id": 9897,
            "vt": "SELECT SUM(CASE WHEN cards.bordercolor = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM cards INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE sets.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of cards with a specific border color from the 'cards' table, filtered by the name of the set from the 'sets' table. The placeholders represent the border color and the set name."
        },
        {
            "sample_id": 9925,
            "vt": "SELECT cards.type FROM sets WHERE sets.code IN (SELECT cards.setcode FROM cards WHERE name = 'Samite Pilgrim')",
            "ba": "The virtual table retrieves the types of cards from the 'sets' table that are associated with a specific card name, 'Samite Pilgrim'. It uses a subquery to first find the set codes from the 'cards' table where the card name matches the specified value."
        },
        {
            "sample_id": 9942,
            "vt": "SELECT cards.artist, legalities.format FROM cards INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid GROUP BY cards.artist ORDER BY COUNT(cards.id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table presents a list of artists along with the formats of play for cards they have illustrated. It aggregates the data by artist, counting the number of cards associated with each artist, and limits the results to a specified number of artists."
        },
        {
            "sample_id": 9951,
            "vt": "SELECT sets.name FROM sets WHERE sets.code IN (SELECT set_translations.setcode FROM set_translations WHERE language = 'Korean' AND NOT language LIKE '%Japanese%')",
            "ba": "The virtual table lists the names of card sets from the 'sets' table that are available in Korean, excluding any sets that are also available in Japanese. The query uses a subquery to filter the set codes based on the specified language criteria."
        },
        {
            "sample_id": 9820,
            "vt": "SELECT cards.manacost FROM cards WHERE cards.artist = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the mana cost of cards from the 'cards' table that are illustrated by a specific artist. The placeholder in the WHERE clause represents the name of the artist."
        },
        {
            "sample_id": 9772,
            "vt": "SELECT foreign_data.language FROM cards INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE cards.name = '[placeholder-type:string]' AND cards.number = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the languages of foreign flavor text associated with a specific card from the 'cards' table. It uses the card's name and number to filter the results, ensuring that only the relevant foreign data is returned."
        },
        {
            "sample_id": 9851,
            "vt": "SELECT set_translations.language, sets.type FROM sets INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE set_translations.id = [placeholder-type:numeric]",
            "ba": "The virtual table provides information about the languages and types of card sets from the 'sets' table, specifically focusing on a particular set identified by its unique ID. It utilizes an inner join with the 'set_translations' table to correlate the set code with its translations, allowing for a comprehensive view of the set's details in different languages."
        },
        {
            "sample_id": 9839,
            "vt": "SELECT CAST(SUM(CASE WHEN set_translations.language = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(sets.id) FROM sets INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE sets.type = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average based on the number of translations available for a specific card set type. It sums up the values from the set_translations table where the language matches a specified placeholder, and divides this sum by the total count of sets of the specified type. The result is then multiplied by a numeric placeholder to adjust the final output."
        },
        {
            "sample_id": 9944,
            "vt": "SELECT cards.name, legalities.format FROM cards INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE cards.edhrecrank = [placeholder-type:numeric] AND legalities.status = '[placeholder-type:string]' GROUP BY cards.name, legalities.format",
            "ba": "The virtual table describes the names of cards along with their legal formats from the 'cards' and 'legalities' tables. It filters the results based on a specific EDHRec rank and the legality status of the cards. The placeholders represent the rank and legality status that can be specified by the user."
        },
        {
            "sample_id": 9778,
            "vt": "SELECT COUNT(*) FROM cards WHERE cards.power = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cards from the 'cards' table that have a specific power value. The placeholder in the WHERE clause represents the power of the cards being queried."
        },
        {
            "sample_id": 9940,
            "vt": "WITH MaxBanned AS (SELECT format, COUNT(*) AS count_banned FROM legalities WHERE status = 'Banned' GROUP BY format ORDER BY COUNT(*) DESC LIMIT 1) SELECT legalities.format, cards.name FROM cards INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid INNER JOIN MaxBanned AS MB ON MB.format = T2.format WHERE legalities.status = '[placeholder-type:string]'",
            "ba": "The virtual table identifies the card names from the 'cards' table that are associated with the format that has the highest number of banned cards. It uses a common table expression (CTE) to first determine which format has the most banned cards, and then retrieves the names of the cards that are banned in that format."
        },
        {
            "sample_id": 9864,
            "vt": "SELECT DISTINCT sets.basesetsize, set_translations.setcode FROM sets INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE sets.block IN ('[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table provides a distinct list of base set sizes and their corresponding set codes from the 'sets' table, filtered by specific block names. The placeholders in the WHERE clause represent the block names that the user can specify to retrieve relevant data."
        },
        {
            "sample_id": 9855,
            "vt": "SELECT CAST(SUM(CASE WHEN set_translations.language = '[placeholder-type:string]' AND sets.isonlineonly = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM sets INNER JOIN set_translations AS T2 ON T1.code = T2.setCode",
            "ba": "The virtual table calculates a weighted average based on the number of sets that are available only online and the translations of those sets in a specified language. It sums up a conditional value based on whether the set is online-only and matches the specified language, then divides this sum by the total count of sets to get the average. The placeholders represent the language, online availability status, and a multiplier for scaling the result."
        },
        {
            "sample_id": 9902,
            "vt": "SELECT foreign_data.flavortext FROM cards INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE cards.name = '[placeholder-type:string]' AND foreign_data.language = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the foreign flavor text of a specific card from the 'cards' table based on the card's name and the specified language. It joins the 'cards' table with the 'foreign_data' table using the unique identifier (UUID) to ensure that the correct flavor text is associated with the corresponding card."
        },
        {
            "sample_id": 9879,
            "vt": "SELECT DISTINCT cards.purchaseurls FROM cards WHERE cards.promotypes = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of unique purchase URLs for cards from the 'cards' table that belong to a specific promotional type. The placeholder in the WHERE clause represents the promotional type of the card."
        },
        {
            "sample_id": 9914,
            "vt": "SELECT sets.type FROM sets WHERE sets.name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the types of card sets from the 'sets' table that match a specific name pattern. The placeholder in the WHERE clause represents the name of the set being queried."
        },
        {
            "sample_id": 9766,
            "vt": "SELECT DISTINCT cards.id FROM cards INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE legalities.format = '[placeholder-type:string]' AND legalities.status = '[placeholder-type:string]' AND cards.rarity = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves unique card IDs from the 'cards' table that are associated with specific legalities. It filters the results based on the format of play, the legality status, and the rarity of the cards."
        },
        {
            "sample_id": 9938,
            "vt": "SELECT COUNT((SELECT T1.id FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Volkan Ba\u01f5a' AND T2.language = 'French' GROUP BY T1.id).id) FROM (SELECT cards.id FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Volkan Ba\u01f5a' AND T2.language = 'French' GROUP BY T1.id) AS t3",
            "ba": "The virtual table counts the number of unique card IDs illustrated by a specific artist in a specified foreign language. It joins the 'cards' table with the 'foreign_data' table to filter cards based on the artist's name and the language of the foreign text."
        },
        {
            "sample_id": 9774,
            "vt": "SELECT CAST(SUM(CASE WHEN foreign_data.language = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(cards.id) FROM cards INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid",
            "ba": "The virtual table calculates a weighted average based on the foreign language data associated with each card in the 'cards' table. It sums up a specific numeric value for cards that match a given foreign language and divides it by the total count of cards, adjusting the result by a specified multiplier."
        },
        {
            "sample_id": 9930,
            "vt": "SELECT DISTINCT cards.availability FROM cards WHERE cards.artist = '[placeholder-type:string]' AND cards.istextless = [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of card availability types from the 'cards' table, filtered by a specific artist's name and whether the card is textless or not. The placeholders allow users to specify the artist's name and the textless status."
        },
        {
            "sample_id": 9857,
            "vt": "SELECT cards.id FROM cards WHERE cards.bordercolor = '[placeholder-type:string]' GROUP BY cards.id",
            "ba": "The virtual table retrieves the unique identifiers of cards from the 'cards' table that have a specific border color. The placeholder in the WHERE clause represents the desired border color of the cards."
        },
        {
            "sample_id": 9912,
            "vt": "SELECT sets.mcmid FROM sets WHERE sets.code = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the Magic: The Gathering set identifier from the 'sets' table based on a specific set code. The placeholder in the WHERE clause represents the set code that the user wants to query."
        },
        {
            "sample_id": 9949,
            "vt": "SELECT rulings.text FROM cards INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE cards.artist = '[placeholder-type:string]' ORDER BY rulings.date",
            "ba": "The virtual table retrieves the rulings associated with cards illustrated by a specific artist from the 'cards' table. The results are ordered by the date of the rulings."
        },
        {
            "sample_id": 9905,
            "vt": "SELECT DISTINCT foreign_data.text FROM foreign_data INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE sets.name = '[placeholder-type:string]' AND foreign_data.language = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct foreign text descriptions of cards from the 'foreign_data' table. It joins the 'cards' table to link each card's unique identifier (uuid) and the 'sets' table to filter results based on the specific set name and language. The placeholders represent the set name and the language for which the foreign text is requested."
        },
        {
            "sample_id": 9894,
            "vt": "SELECT COUNT(DISTINCT T1.id) FROM sets INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE sets.block = '[placeholder-type:string]' AND set_translations.language = '[placeholder-type:string]' AND NOT set_translations.translation IS NULL",
            "ba": "The virtual table counts the distinct set IDs from the 'sets' table that belong to a specific block and have translations available in a specified language. It ensures that only sets with non-null translations are included in the count."
        },
        {
            "sample_id": 9844,
            "vt": "SELECT foreign_data.language FROM foreign_data WHERE foreign_data.multiverseid = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the languages of foreign flavor text associated with a specific card identified by its multiverse ID from the 'foreign_data' table."
        },
        {
            "sample_id": 9807,
            "vt": "SELECT rulings.text FROM cards INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE cards.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the rulings associated with a specific card from the 'cards' table based on the card's name. It uses an inner join to connect the 'cards' table with the 'rulings' table, ensuring that only the relevant rulings for the specified card are returned."
        },
        {
            "sample_id": 9828,
            "vt": "SELECT cards.id FROM cards INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid INNER JOIN legalities AS T3 ON T1.uuid = T3.uuid WHERE legalities.status = '[placeholder-type:string]' AND cards.types = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the IDs of cards from the 'cards' table that have specific legal statuses and types. It joins the 'rulings' and 'legalities' tables to filter the results based on the legality status and card types provided by the user."
        },
        {
            "sample_id": 9865,
            "vt": "SELECT set_translations.setcode FROM sets INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE sets.type = '[placeholder-type:string]' GROUP BY set_translations.setcode",
            "ba": "The virtual table retrieves the set codes of card sets from the 'sets' table that match a specific type. It uses an inner join with the 'set_translations' table to ensure that only relevant translations are included. The results are grouped by the set code to avoid duplicates."
        },
        {
            "sample_id": 9854,
            "vt": "SELECT sets.id FROM sets INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE set_translations.language = '[placeholder-type:string]' GROUP BY sets.basesetsize ORDER BY sets.basesetsize LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of card sets from the 'sets' table, joining it with the 'set_translations' table to filter by a specific language. The results are grouped by the base set size and ordered accordingly, with a limit on the number of results returned."
        },
        {
            "sample_id": 9933,
            "vt": "SELECT cards.frameeffects FROM cards WHERE NOT cards.cardkingdomfoilid IS NULL AND NOT cards.cardkingdomid IS NULL GROUP BY cards.frameeffects ORDER BY COUNT(cards.frameeffects) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique frame effects of cards from the 'cards' table that have both a non-null card kingdom foil ID and a non-null card kingdom ID. The results are grouped by the frame effects and ordered by the count of occurrences, allowing users to see the most common frame effects up to a specified limit."
        },
        {
            "sample_id": 9836,
            "vt": "SELECT set_translations.language FROM sets INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE sets.block = '[placeholder-type:string]' AND sets.basesetsize = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the languages of translations for card sets that belong to a specific block and have a defined base set size. The placeholders allow users to specify the block name and the number of cards in the set."
        },
        {
            "sample_id": 9903,
            "vt": "SELECT foreign_data.language FROM cards INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE cards.name = '[placeholder-type:string]' AND NOT foreign_data.flavortext IS NULL",
            "ba": "The virtual table retrieves the languages of foreign versions of a specific card from the 'cards' table, ensuring that the foreign flavor text is not null. The placeholder in the WHERE clause represents the name of the card being queried."
        },
        {
            "sample_id": 9822,
            "vt": "SELECT set_translations.setcode FROM set_translations WHERE set_translations.language = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of set codes from the 'set_translations' table for a specific language. The placeholder in the WHERE clause represents the language for which the set codes are being queried."
        },
        {
            "sample_id": 9939,
            "vt": "SELECT COUNT(cards.id) FROM cards INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE cards.rarity = '[placeholder-type:string]' AND cards.types = '[placeholder-type:string]' AND cards.name = '[placeholder-type:string]' AND legalities.status = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cards from the 'cards' table that meet specific criteria. It joins the 'legalities' table to filter cards based on their legality status. The placeholders represent the rarity, type, name of the card, and its legality status."
        },
        {
            "sample_id": 9765,
            "vt": "SELECT cards.id FROM cards WHERE cards.edhrecrank < [placeholder-type:numeric] AND cards.frameversion = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the IDs of cards from the 'cards' table that have an EDHRec rank lower than a specified numeric value and belong to a specific frame version, also represented by a numeric placeholder."
        },
        {
            "sample_id": 9882,
            "vt": "SELECT cards.artist FROM cards WHERE cards.flavorname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the artist of the card from the 'cards' table where the flavor name matches a specific value. The placeholder in the WHERE clause represents the flavor name of the card."
        },
        {
            "sample_id": 9888,
            "vt": "SELECT COUNT(cards.id) FROM cards INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE set_translations.translation = '[placeholder-type:string]' AND cards.artist = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cards from the 'cards' table that are illustrated by a specific artist and belong to a specific set translation. The placeholders represent the artist's name and the translated name of the set."
        },
        {
            "sample_id": 9782,
            "vt": "SELECT set_translations.language FROM set_translations WHERE cards.id IN (SELECT cards.id FROM cards WHERE name = 'Angel of Mercy')",
            "ba": "The virtual table retrieves the languages in which the card 'Angel of Mercy' has translations available. It does this by first selecting the IDs of the cards that match the name 'Angel of Mercy' from the 'cards' table, and then using those IDs to find corresponding entries in the 'set_translations' table."
        },
        {
            "sample_id": 9835,
            "vt": "SELECT COUNT(DISTINCT T1.id) FROM cards INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE cards.rarity = '[placeholder-type:string]' AND rulings.date = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct card IDs from the 'cards' table that have a specific rarity and are associated with rulings made on a specific date. It uses an inner join to connect the 'cards' and 'rulings' tables based on their unique identifiers (UUIDs). The placeholders represent the rarity of the card and the date of the ruling."
        },
        {
            "sample_id": 9762,
            "vt": "SELECT cards.id FROM cards WHERE NOT cards.cardkingdomfoilid IS NULL AND NOT cards.cardkingdomid IS NULL",
            "ba": "The virtual table retrieves the IDs of cards from the 'cards' table that have both a non-null 'cardkingdomfoilid' and a non-null 'cardkingdomid'. This indicates that these cards are associated with specific card kingdom identifiers for both foil and non-foil versions."
        },
        {
            "sample_id": 9800,
            "vt": "SELECT cards.id FROM cards WHERE NOT cards.cardkingdomid IS NULL AND NOT cards.cardkingdomfoilid IS NULL",
            "ba": "The virtual table retrieves the IDs of cards from the 'cards' table that have both a non-null 'cardkingdomid' and a non-null 'cardkingdomfoilid'. This indicates that these cards are available in both standard and foil versions on Card Kingdom."
        },
        {
            "sample_id": 9889,
            "vt": "SELECT sets.basesetsize FROM sets INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE set_translations.translation = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the base set size of a specific card set from the 'sets' table, using a join with the 'set_translations' table to filter by the translated name of the set. The placeholder in the WHERE clause represents the translated name of the card set."
        },
        {
            "sample_id": 9790,
            "vt": "SELECT CAST(SUM(CASE WHEN cards.bordercolor = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(cards.id) FROM cards",
            "ba": "The virtual table calculates a weighted average based on the border color of cards from the 'cards' table. It sums up a specific numeric value for cards that match a given border color and divides it by the total count of cards, applying a multiplier to the result. The placeholders represent the border color to filter by, a numeric value to sum, and a multiplier for the final calculation."
        },
        {
            "sample_id": 9916,
            "vt": "SELECT rulings.text, CASE WHEN cards.hascontentwarning = [placeholder-type:numeric] THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM cards INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE cards.artist = '[placeholder-type:string]'",
            "ba": "The virtual table presents the rulings associated with cards illustrated by a specific artist, along with a conditional statement that indicates whether the card has a content warning or not. The placeholders allow for dynamic input of the artist's name and the content warning status."
        },
        {
            "sample_id": 9859,
            "vt": "SELECT cards.id FROM cards WHERE cards.bordercolor = '[placeholder-type:string]' AND cards.isfullart = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of cards from the 'cards' table that have a specific border color and are marked as full art. The placeholders allow users to specify the desired border color and whether the card is full art or not."
        },
        {
            "sample_id": 9837,
            "vt": "SELECT CAST(SUM(CASE WHEN cards.hascontentwarning = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(cards.id) FROM cards INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE legalities.format = '[placeholder-type:string]' AND legalities.status = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average value of cards that have a content warning based on their legality status in a specific format. It sums up the values of cards with a content warning and divides it by the total count of cards, applying a multiplier to the result. The placeholders represent the numeric values for the content warning and the multiplier, as well as string values for the legality format and status."
        },
        {
            "sample_id": 9853,
            "vt": "SELECT sets.name, sets.id FROM sets INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE set_translations.language = '[placeholder-type:string]' AND sets.isfoilonly = [placeholder-type:numeric] AND sets.isforeignonly = [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of set names and their corresponding IDs from the 'sets' table, filtered by the specified language of the set translation, and whether the set is only available in foil or foreign editions."
        },
        {
            "sample_id": 9829,
            "vt": "SELECT cards.subtypes, cards.supertypes FROM cards INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE foreign_data.language = '[placeholder-type:string]' AND NOT cards.subtypes IS NULL AND NOT cards.supertypes IS NULL",
            "ba": "The virtual table retrieves the subtypes and supertypes of cards from the 'cards' table, joining with the 'foreign_data' table to filter results based on a specific language. The query ensures that only cards with defined subtypes and supertypes are included in the results."
        },
        {
            "sample_id": 9892,
            "vt": "SELECT DISTINCT sets.releasedate FROM cards INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE cards.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the distinct release dates of card sets from the 'sets' table that are associated with a specific card name from the 'cards' table. The query uses an inner join to connect the two tables based on the set code, ensuring that only relevant sets for the specified card name are considered."
        },
        {
            "sample_id": 9917,
            "vt": "SELECT sets.releasedate FROM cards INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE cards.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the release date of a specific card from the 'sets' table by joining it with the 'cards' table based on the set code. The placeholder in the WHERE clause represents the name of the card being queried."
        },
        {
            "sample_id": 9918,
            "vt": "SELECT sets.basesetsize FROM sets INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE set_translations.translation = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the base set size of a specific card set from the 'sets' table, joining it with the 'set_translations' table to filter by the translated name of the set. The placeholder in the WHERE clause represents the translated name of the card set."
        },
        {
            "sample_id": 9948,
            "vt": "SELECT COUNT(cards.id) FROM cards WHERE cards.artist = '[placeholder-type:string]' AND cards.availability = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cards from the 'cards' table that are illustrated by a specific artist and are available in a specified printing type. The placeholders in the WHERE clause represent the artist's name and the availability type of the cards."
        },
        {
            "sample_id": 9769,
            "vt": "SELECT cards.id, rulings.text, cards.hascontentwarning FROM cards INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE cards.artist = '[placeholder-type:string]'",
            "ba": "The virtual table displays the card ID, ruling text, and content warning status from the 'cards' table, filtered by the artist's name. It combines data from the 'cards' and 'rulings' tables using a join on the unique identifier (UUID) to ensure that the rulings correspond to the correct cards."
        },
        {
            "sample_id": 9840,
            "vt": "SELECT DISTINCT cards.availability FROM cards WHERE cards.artist = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of card availability types from the 'cards' table, filtered by a specific artist's name. The placeholder in the WHERE clause represents the artist's name."
        },
        {
            "sample_id": 9896,
            "vt": "SELECT COUNT(sets.id) FROM sets INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE NOT set_translations.translation IS NULL AND sets.basesetsize < [placeholder-type:numeric] AND set_translations.language = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of sets from the 'sets' table that have translations available in a specified language and have a base set size smaller than a given numeric value. It uses an inner join with the 'set_translations' table to filter out sets that do not have translations."
        },
        {
            "sample_id": 9797,
            "vt": "SELECT cards.id FROM cards WHERE cards.convertedmanacost = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of cards from the 'cards' table that have a specific converted mana cost. The placeholder in the WHERE clause represents the numeric value of the converted mana cost."
        },
        {
            "sample_id": 9775,
            "vt": "SELECT sets.name, sets.totalsetsize FROM sets INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE set_translations.language = '[placeholder-type:string]'",
            "ba": "The virtual table provides the names and total sizes of card sets from the 'sets' table, filtered by a specific language from the 'set_translations' table. The placeholder in the WHERE clause represents the language for which the set translations are being queried."
        },
        {
            "sample_id": 9924,
            "vt": "SELECT sets.releasedate FROM sets INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE set_translations.translation = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the release date of a specific card set from the 'sets' table by joining it with the 'set_translations' table. The join is based on the set code, and it filters the results to only include the translation that matches a specified placeholder value."
        },
        {
            "sample_id": 9908,
            "vt": "SELECT CAST(SUM(CASE WHEN cards.convertedmanacost = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(cards.id) FROM cards INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE sets.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average converted mana cost of cards from a specific set, adjusting the total based on a specified multiplier. It sums the converted mana costs of cards that match a certain value and divides this sum by the total number of cards in the set, providing a weighted average based on the given multiplier."
        },
        {
            "sample_id": 9875,
            "vt": "SELECT DISTINCT cards.manacost FROM cards WHERE cards.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct mana costs from the 'cards' table for a specific card name. The placeholder in the WHERE clause represents the name of the card being queried."
        },
        {
            "sample_id": 9792,
            "vt": "SELECT COUNT(cards.id) FROM cards INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE cards.bordercolor = '[placeholder-type:string]' AND foreign_data.language = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cards from the 'cards' table that have a specific border color and are available in a specified foreign language. It joins the 'cards' table with the 'foreign_data' table based on the unique identifier (uuid) to filter the results accordingly."
        },
        {
            "sample_id": 9899,
            "vt": "SELECT cards.artist FROM cards INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE (sets.name = '[placeholder-type:string]' AND cards.artist = '[placeholder-type:string]') OR (sets.name = '[placeholder-type:string]' AND cards.artist = '[placeholder-type:string]') OR (sets.name = '[placeholder-type:string]' AND cards.artist = '[placeholder-type:string]') GROUP BY cards.artist",
            "ba": "The virtual table retrieves the names of artists who illustrated cards from specific sets. It filters the results based on the set names and artist names provided as placeholders. The query groups the results by artist to ensure unique entries for each artist."
        },
        {
            "sample_id": 9831,
            "vt": "SELECT COUNT(cards.id) FROM cards INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN rulings AS T3 ON T1.uuid = T3.uuid WHERE legalities.format = '[placeholder-type:string]' AND rulings.text = '[placeholder-type:string]' AND cards.side IS NULL",
            "ba": "The virtual table counts the number of cards from the 'cards' table that meet specific criteria related to their legality and rulings. It filters the results based on the format of play and the description of the ruling, while also ensuring that only cards without multiple faces are included in the count."
        },
        {
            "sample_id": 9862,
            "vt": "SELECT DISTINCT foreign_data.language FROM foreign_data WHERE foreign_data.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves a distinct list of languages from the 'foreign_data' table for a specific card name. The placeholder in the WHERE clause represents the card name being queried."
        },
        {
            "sample_id": 9812,
            "vt": "SELECT cards.colors, legalities.format FROM cards INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE cards.id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table displays the colors associated with each card and the formats in which they are legal. It retrieves data from the 'cards' table and joins it with the 'legalities' table based on the unique identifier (uuid) of the cards. The query filters the results to include only those cards whose IDs fall within a specified numeric range."
        },
        {
            "sample_id": 9858,
            "vt": "SELECT cards.id FROM cards WHERE cards.frameeffects = '[placeholder-type:string]' GROUP BY cards.id",
            "ba": "The virtual table retrieves the unique identifiers of cards from the 'cards' table that have specific visual frame effects. The placeholder in the WHERE clause represents the desired frame effect to filter the results."
        },
        {
            "sample_id": 9932,
            "vt": "SELECT cards.artist FROM cards WHERE cards.side IS NULL ORDER BY cards.convertedmanacost LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of artists who illustrated cards from the 'cards' table that do not have multiple faces (indicated by a NULL value in the 'side' column). The results are ordered by the converted mana cost of the cards, and the number of results returned is limited by a numeric placeholder."
        },
        {
            "sample_id": 9884,
            "vt": "SELECT set_translations.translation FROM set_translations WHERE cards.setcode IN (SELECT cards.setcode FROM cards WHERE name = 'Ancestor''s Chosen') AND set_translations.language = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the translations of a specific card set in a specified language. It filters the set translations based on the set code associated with a card named 'Ancestor's Chosen'. The placeholder in the WHERE clause represents the language for which the translation is requested."
        },
        {
            "sample_id": 9926,
            "vt": "SELECT COUNT(cards.id) FROM cards WHERE cards.setcode IN (SELECT sets.code FROM sets WHERE name = 'World Championship Decks 2004') AND cards.convertedmanacost = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of cards from the 'cards' table that belong to a specific set, identified by its name, and have a specified converted mana cost. The placeholder in the WHERE clause represents the converted mana cost of the cards being queried."
        },
        {
            "sample_id": 9824,
            "vt": "SELECT CAST(SUM(CASE WHEN cards.istextless = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(cards.id) FROM cards WHERE cards.isstoryspotlight = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average value of a specific numeric property from the 'cards' table, where the cards are filtered based on whether they are marked as story spotlight cards. It uses a conditional sum to account for textless cards and applies a multiplier to the result before dividing by the total count of cards that meet the criteria."
        },
        {
            "sample_id": 9934,
            "vt": "SELECT SUM(CASE WHEN cards.power = '[placeholder-type:string]' OR cards.power IS NULL THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM cards WHERE cards.hasfoil = [placeholder-type:numeric] AND cards.dueldeck = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total power of cards from the 'cards' table that meet specific criteria. It sums the power of cards, considering a condition where if the power is equal to a specified value or is null, it uses a placeholder for a numeric value; otherwise, it uses another placeholder for a numeric value. The query also filters the results based on whether the cards are available in foil and belong to a specific duel deck."
        },
        {
            "sample_id": 9767,
            "vt": "SELECT DISTINCT legalities.status FROM cards INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE cards.type = '[placeholder-type:string]' AND legalities.format = '[placeholder-type:string]' AND cards.side IS NULL",
            "ba": "The virtual table retrieves the distinct legality statuses of cards from the 'cards' table that match a specific type and format. It filters out cards that have multiple faces by checking if the 'side' column is null."
        },
        {
            "sample_id": 9878,
            "vt": "SELECT DISTINCT cards.subtypes, cards.supertypes FROM cards WHERE cards.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of subtypes and supertypes for a specific card from the 'cards' table based on the card's name. The placeholder in the WHERE clause represents the name of the card being queried."
        },
        {
            "sample_id": 9937,
            "vt": "SELECT cards.originalreleasedate, legalities.format FROM cards INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE cards.rarity = '[placeholder-type:string]' AND NOT cards.originalreleasedate IS NULL AND legalities.status = '[placeholder-type:string]' ORDER BY cards.originalreleasedate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of original release dates and formats of play for cards from the 'cards' table that match a specific rarity and legality status. The query filters out cards with null original release dates and orders the results by the release date, limiting the number of results based on a specified numeric value."
        },
        {
            "sample_id": 9786,
            "vt": "SELECT DISTINCT legalities.status FROM cards INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE cards.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of legal statuses for a specific card from the 'cards' table by joining it with the 'legalities' table based on their unique identifiers. The placeholder in the WHERE clause represents the name of the card being queried."
        },
        {
            "sample_id": 9869,
            "vt": "SELECT set_translations.setcode FROM sets INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE sets.type = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the set codes of card sets from the 'sets' table that match a specific type. It uses an inner join with the 'set_translations' table to ensure that the set codes are correctly associated with their translations."
        },
        {
            "sample_id": 9784,
            "vt": "SELECT rulings.text FROM cards INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE cards.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides the rulings associated with a specific card from the 'cards' table. It retrieves the ruling text by joining the 'cards' table with the 'rulings' table based on their unique identifiers (UUID). The placeholder in the WHERE clause represents the name of the card for which the rulings are being queried."
        },
        {
            "sample_id": 9945,
            "vt": "SELECT (CAST(SUM(sets.id) AS FLOAT) / COUNT(sets.id)) / [placeholder-type:numeric], set_translations.language FROM sets INNER JOIN set_translations AS T2 ON T1.id = T2.id WHERE sets.releasedate BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' GROUP BY sets.releasedate ORDER BY COUNT(set_translations.language) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average of the set IDs from the 'sets' table, divided by a specified numeric placeholder, and groups the results by the release date of the sets. It also retrieves the corresponding language from the 'set_translations' table, which is joined on the set ID. The results are filtered based on a specified date range and limited to a certain number of entries based on another numeric placeholder."
        },
        {
            "sample_id": 9832,
            "vt": "SELECT cards.id FROM cards INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE cards.artist = '[placeholder-type:string]' AND legalities.format = '[placeholder-type:string]' AND cards.availability = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of cards from the 'cards' table that are illustrated by a specific artist, are legal in a specified format, and have a certain availability status. The placeholders in the WHERE clause represent the artist's name, the format of play, and the card's availability type."
        },
        {
            "sample_id": 9848,
            "vt": "SELECT sets.name FROM sets WHERE sets.mtgocode IS NULL ORDER BY sets.name LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of card sets from the 'sets' table that are not available on Magic: The Gathering Online. The results are ordered by the set name and limited to a specified number of entries."
        },
        {
            "sample_id": 9802,
            "vt": "SELECT cards.edhrecrank FROM cards WHERE cards.frameversion = [placeholder-type:numeric]",
            "ba": "The virtual table provides the EDHRec rank of cards from the 'cards' table that have a specific frame version. The placeholder in the WHERE clause represents the frame version number."
        }
    ],
    "movielens": [
        {
            "sample_id": 2305,
            "vt": "SELECT movies2actors.actorid FROM movies INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid WHERE movies.runningtime = [placeholder-type:numeric] AND movies.isenglish = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the identifiers of actors from the 'movies2actors' table for movies that meet specific criteria. It filters movies based on their running time and whether they are in English. The placeholders represent the running time as a numeric value and the English language status as a string value."
        },
        {
            "sample_id": 2283,
            "vt": "SELECT COUNT(DISTINCT T2.userid) FROM users INNER JOIN u2base AS T2 ON T1.userid = T2.userid INNER JOIN movies AS T3 ON T2.movieid = T3.movieid WHERE users.u_gender = '[placeholder-type:string]' AND movies.country = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of users who have rated movies from a specific country and belong to a specified gender. It combines data from the 'users', 'u2base', and 'movies' tables to achieve this."
        },
        {
            "sample_id": 2255,
            "vt": "SELECT DISTINCT u2base.movieid FROM u2base INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE movies.country = '[placeholder-type:string]' AND movies.isenglish = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a distinct list of movie identifiers from the 'u2base' table, which contains user ratings for movies. It joins with the 'movies' table to filter the results based on the specified country and whether the movies are in English. The placeholders allow users to specify the country and language criteria, as well as limit the number of results returned."
        },
        {
            "sample_id": 2291,
            "vt": "SELECT COUNT(users.userid) FROM users INNER JOIN u2base AS T2 ON T1.userid = T2.userid WHERE u2base.userid = [placeholder-type:numeric] AND users.u_gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users from the 'users' table who have provided ratings for movies in the 'u2base' table. It filters the results based on a specific user ID and gender, represented by placeholders for numeric and string values respectively."
        },
        {
            "sample_id": 2309,
            "vt": "SELECT COUNT(movies2actors.actorid) FROM movies2actors INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE movies.country = '[placeholder-type:string]' OR movies.country = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of actors associated with movies from a specific country or countries. It joins the 'movies2actors' table with the 'movies' table to filter the results based on the country of the movies. The placeholders in the WHERE clause represent the names of the countries being queried."
        },
        {
            "sample_id": 2247,
            "vt": "SELECT DISTINCT movies2directors.directorid FROM u2base INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE u2base.rating > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a distinct list of director IDs from the 'movies2directors' table based on user ratings from the 'u2base' table. It filters the results to include only those movies that have received a rating higher than a specified value."
        },
        {
            "sample_id": 2344,
            "vt": "SELECT SUM(CASE WHEN actors.a_gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END), SUM(CASE WHEN actors.a_gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END), CAST(SUM(CASE WHEN actors.a_quality = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*), CAST(SUM(CASE WHEN actors.a_quality = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*), (SELECT movies2directors.directorid FROM movies2directors WHERE movieid = 1684910), (SELECT movies2directors.genre FROM movies2directors WHERE movieid = 1684910) FROM actors WHERE actors.actorid IN (SELECT actors.actorid FROM movies2actors WHERE movieid = 1684910)",
            "ba": "The virtual table aggregates data related to actors from the 'actors' table based on specific conditions. It calculates the sum of certain values based on the gender of the actors, and also computes a weighted average of actor quality. Additionally, it retrieves the director ID and genre for a specific movie from the 'movies2directors' table, using a subquery to filter by movie ID. The placeholders represent dynamic values that can be modified to generate specific queries."
        },
        {
            "sample_id": 2250,
            "vt": "SELECT COUNT(u2base.movieid) FROM u2base INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE movies.country = '[placeholder-type:string]' AND u2base.rating < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of movies rated by users from a specific country that have a rating below a certain threshold. It combines data from the 'u2base' table, which contains user ratings, and the 'movies' table, which includes information about the movies such as their country of origin. The placeholders represent the country name and the rating threshold."
        },
        {
            "sample_id": 2327,
            "vt": "SELECT CAST(SUM(CASE WHEN actors.a_gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN actors.a_gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM movies INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid INNER JOIN actors AS T3 ON T2.actorid = T3.actorid WHERE movies.country = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the ratio of the total number of actors of a specific gender to the total number of actors in movies from a specified country. It uses a conditional sum to count actors based on their gender and divides it by the total count of actors, providing a float result. The placeholders represent the gender of the actors and the country of the movies."
        },
        {
            "sample_id": 2312,
            "vt": "SELECT COUNT(movies.movieid) FROM movies INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE movies.country = '[placeholder-type:string]' AND movies2directors.genre = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies from the 'movies' table that are associated with a specific genre and produced in a specific country. The placeholders in the WHERE clause represent the country and genre criteria."
        },
        {
            "sample_id": 2340,
            "vt": "SELECT COUNT(movies2directors.movieid) FROM movies2directors INNER JOIN movies AS T2 ON T1.movieid = T2.movieid INNER JOIN directors AS T3 ON T1.directorid = T3.directorid WHERE movies2directors.genre = '[placeholder-type:string]' AND directors.d_quality = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of movies directed by directors of a specific quality within a certain genre. It joins the 'movies2directors' table with the 'movies' and 'directors' tables to filter based on the genre and director quality."
        },
        {
            "sample_id": 2332,
            "vt": "SELECT CAST(SUM(CASE WHEN actors.a_gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN actors.a_gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM actors WHERE actors.a_quality = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the ratio of the total number of actors of a specific gender to the total number of actors of that gender who meet a certain quality criterion. The placeholders represent the gender and quality level of the actors."
        },
        {
            "sample_id": 2266,
            "vt": "SELECT movies.movieid FROM movies INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid INNER JOIN directors AS T3 ON T2.directorid = T3.directorid WHERE movies.runningtime = [placeholder-type:numeric] AND directors.avg_revenue = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of movies from the 'movies' table that meet specific criteria regarding their running time and the average revenue of their directors. The placeholders in the WHERE clause represent the running time of the movies and the average revenue of the directors, allowing users to filter results based on these values."
        },
        {
            "sample_id": 2334,
            "vt": "SELECT movies2directors.genre FROM movies2directors GROUP BY movies2directors.genre ORDER BY COUNT(movies2directors.movieid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the genres of movies from the 'movies2directors' table, grouping them to count how many movies belong to each genre. The result is ordered by the number of movies in each genre, and the output is limited to a specified number of genres."
        },
        {
            "sample_id": 2322,
            "vt": "SELECT DISTINCT u2base.movieid FROM u2base INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE u2base.rating = [placeholder-type:numeric] AND movies.year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct movie identifiers from the 'u2base' table, which contains user ratings for movies. It joins with the 'movies' table to filter results based on a specific rating and the year of release. The placeholders represent the rating value and the year of the movie."
        },
        {
            "sample_id": 2260,
            "vt": "SELECT COUNT(u2base.userid) FROM u2base INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid INNER JOIN actors AS T3 ON T2.actorid = T3.actorid INNER JOIN users AS T4 ON T1.userid = T4.userid WHERE actors.a_quality = [placeholder-type:numeric] AND u2base.rating > [placeholder-type:numeric] AND users.u_gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users who have rated movies featuring actors of a specific quality, filtered by the user's gender and a minimum rating threshold."
        },
        {
            "sample_id": 2304,
            "vt": "SELECT movies2actors.actorid FROM movies2actors INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE movies.year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the identifiers of actors from the 'movies2actors' table who have acted in movies released in a specific year. The query joins the 'movies2actors' table with the 'movies' table to filter the results based on the year of release, using a placeholder for the year value."
        },
        {
            "sample_id": 2297,
            "vt": "SELECT u2base.movieid FROM u2base INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE u2base.rating = [placeholder-type:numeric] AND movies2directors.genre = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the identifiers of movies from the 'u2base' table that have been rated by users. It filters the results based on a specific rating and genre of the movies, which is determined by joining the 'u2base' table with the 'movies2directors' table. The placeholders represent the rating value and the genre of the movies."
        },
        {
            "sample_id": 2341,
            "vt": "SELECT movies2directors.genre FROM movies INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE movies.runningtime <= [placeholder-type:numeric] AND movies.isenglish = '[placeholder-type:string]' AND movies.country = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the genre of movies from the 'movies' table that meet specific criteria regarding their running time, language, and country of origin. The placeholders allow users to specify the maximum running time, the language of the movie, and the country of production."
        },
        {
            "sample_id": 2272,
            "vt": "SELECT movies2actors.movieid FROM actors INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid GROUP BY movies2actors.actorid ORDER BY AVG(actors.a_quality) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a list of movie identifiers from the 'movies2actors' table, which links movies to their respective actors. It uses an inner join with the 'actors' table to access actor quality ratings. The results are grouped by actor identifiers to aggregate the average quality of actors associated with each movie. The final output is ordered by the average quality of actors, and a limit is applied to restrict the number of results returned based on a numeric placeholder."
        },
        {
            "sample_id": 2326,
            "vt": "SELECT u2base.movieid FROM u2base INNER JOIN movies2directors AS T3 ON T2.movieid = T3.movieid WHERE movies2directors.genre = '[placeholder-type:string]' GROUP BY u2base.movieid ORDER BY AVG(u2base.rating) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves movie identifiers from the 'u2base' table, which contains user ratings for movies. It joins with the 'movies2directors' table to filter movies based on a specific genre. The results are grouped by movie identifiers and ordered by the average rating, allowing users to see the top-rated movies in a particular genre, limited to a specified number of results."
        },
        {
            "sample_id": 2289,
            "vt": "SELECT COUNT(*) FROM (SELECT DISTINCT movies2directors.movieid FROM directors AS T1 INNER JOIN movies2directors AS T2 ON T1.directorid = T2.directorid INNER JOIN u2base AS T3 ON T2.movieid = T3.movieid WHERE T1.d_quality = 5 GROUP BY T2.movieid HAVING AVG(T3.rating) > 3.5) AS t1",
            "ba": "The virtual table counts the number of distinct movies directed by directors with a quality rating of 5, where the average user rating for those movies is greater than 3.5. It involves joining the 'directors', 'movies2directors', and 'u2base' tables to filter and aggregate the relevant data."
        },
        {
            "sample_id": 2258,
            "vt": "SELECT COUNT(u2base.movieid) FROM u2base INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE movies.country = '[placeholder-type:string]' AND movies.runningtime < [placeholder-type:numeric] AND u2base.rating = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of movie ratings provided by users from the 'u2base' table, filtered by specific criteria. It joins the 'u2base' table with the 'movies' table to access movie details. The query filters movies based on their country and running time, as well as the rating given by users. The placeholders represent the country name, maximum running time, and the rating value."
        },
        {
            "sample_id": 2274,
            "vt": "SELECT CAST(SUM(CASE WHEN users.u_gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(users.userid) FROM u2base INNER JOIN users AS T2 ON T1.userid = T2.userid WHERE u2base.rating = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the weighted average rating of movies based on the gender of users from the 'users' table. It sums the ratings for a specific gender and normalizes it by the total number of users, allowing for a comparison of movie ratings based on user demographics. The placeholders represent the gender to filter by, the numeric values for ratings, and a multiplier for the calculation."
        },
        {
            "sample_id": 2279,
            "vt": "SELECT u2base.movieid FROM u2base INNER JOIN users AS T2 ON T1.userid = T2.userid WHERE users.u_gender = '[placeholder-type:string]' GROUP BY u2base.movieid ORDER BY COUNT(users.userid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves movie identifiers from the 'u2base' table, which links users to movies they have rated. It joins with the 'users' table to filter results based on the gender of users. The results are grouped by movie identifiers and ordered by the count of users who rated each movie, allowing for a limit on the number of results returned."
        },
        {
            "sample_id": 2342,
            "vt": "SELECT DISTINCT movies.movieid FROM movies INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid INNER JOIN u2base AS T3 ON T1.movieid = T3.movieid INNER JOIN users AS T4 ON T3.userid = T4.userid WHERE movies.country = '[placeholder-type:string]' AND movies2directors.genre = '[placeholder-type:string]' AND movies.runningtime = [placeholder-type:numeric] AND u2base.rating = [placeholder-type:numeric] AND users.age BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND movies.isenglish = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct movie identifiers from the 'movies' table based on specific criteria. It filters movies by country, genre, running time, user ratings, user age range, and whether the movie is in English. The query joins multiple tables to correlate movies with their directors and user ratings."
        },
        {
            "sample_id": 2343,
            "vt": "SELECT CAST(SUM(CASE WHEN movies.isenglish = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN movies.isenglish = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(movies.movieid) FROM movies INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE movies.country = '[placeholder-type:string]' AND movies.year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average of movie ratings based on whether the movies are in English or not. It sums the ratings for English and non-English movies separately, then computes the difference between these sums, scales it by a specified factor, and divides by the total count of movies. The results are filtered by the country of the movies and the year they were released."
        },
        {
            "sample_id": 2262,
            "vt": "SELECT movies2actors.actorid, movies2directors.genre FROM movies INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid INNER JOIN actors AS T3 ON T2.actorid = T3.actorid INNER JOIN movies2directors AS T4 ON T1.movieid = T4.movieid WHERE movies2directors.directorid = [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of actor identifiers and the corresponding genres of movies directed by a specific director. It combines data from the 'movies', 'movies2actors', 'actors', and 'movies2directors' tables to achieve this."
        },
        {
            "sample_id": 2286,
            "vt": "SELECT COUNT(DISTINCT T1.actorid) FROM actors INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid INNER JOIN movies AS T3 ON T2.movieid = T3.movieid WHERE movies.isenglish = '[placeholder-type:string]' AND actors.a_gender = '[placeholder-type:string]' AND actors.a_quality = [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of actors from the 'actors' table who have acted in English movies, filtered by their gender and quality rating. The placeholders represent the criteria for filtering the movies' language, the actors' gender, and their quality rating."
        },
        {
            "sample_id": 2338,
            "vt": "SELECT u2base.movieid FROM users INNER JOIN u2base AS T2 ON T1.userid = T2.userid INNER JOIN movies AS T3 ON T2.movieid = T3.movieid WHERE users.u_gender = '[placeholder-type:string]' AND users.occupation = [placeholder-type:numeric] AND u2base.rating = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the movie identifiers from the 'u2base' table, which links users to movies they have rated. It joins the 'users' table to filter based on user gender and occupation, and it also joins the 'movies' table to ensure the movies are correctly identified. The placeholders represent the user's gender, occupation, and the rating given to the movies."
        },
        {
            "sample_id": 2261,
            "vt": "SELECT u2base.userid FROM u2base WHERE u2base.rating = [placeholder-type:numeric] GROUP BY u2base.userid ORDER BY COUNT(u2base.movieid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves unique user identifiers from the 'u2base' table based on a specific rating. It groups the results by user ID and orders them by the count of movies rated, limiting the output to a specified number of users."
        },
        {
            "sample_id": 2277,
            "vt": "SELECT COUNT(movies.movieid) FROM movies INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE movies.country = '[placeholder-type:string]' AND movies.isenglish = '[placeholder-type:string]' AND movies2directors.genre = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies from the 'movies' table that meet specific criteria. It filters movies based on their country, whether they are in English, and their genre. The query joins the 'movies' table with the 'movies2directors' table to access the genre information associated with each movie."
        },
        {
            "sample_id": 2275,
            "vt": "SELECT SUM(CASE WHEN users.u_gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN users.u_gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM u2base INNER JOIN users AS T2 ON T1.userid = T2.userid INNER JOIN movies2directors AS T3 ON T3.movieid = T1.movieid WHERE movies2directors.genre = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference in ratings between two genders for movies of a specific genre. It sums the ratings from the 'u2base' table, joining with the 'users' table to filter by gender, and the 'movies2directors' table to filter by genre. The placeholders represent the gender and genre values."
        },
        {
            "sample_id": 2333,
            "vt": "SELECT movies2actors.actorid FROM movies2actors GROUP BY movies2actors.actorid ORDER BY COUNT(movies2actors.movieid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists unique actor identifiers from the 'movies2actors' table, grouping them by the number of movies they have appeared in. The results are ordered by the count of movies in descending order, and a limit is applied to restrict the number of actors returned based on a specified numeric value."
        },
        {
            "sample_id": 2308,
            "vt": "SELECT DISTINCT movies.movieid FROM movies INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid WHERE movies.year = [placeholder-type:numeric] AND movies2actors.cast_num = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves unique movie identifiers from the 'movies' table that are associated with specific actors. It filters the results based on the year of release and the cast number of the actors in the movie. The placeholders represent the year and cast number criteria for the query."
        },
        {
            "sample_id": 2317,
            "vt": "SELECT DISTINCT directors.avg_revenue FROM directors INNER JOIN movies2directors AS T2 ON T1.directorid = T2.directorid WHERE directors.d_quality = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the average revenue of directors from the 'directors' table who have a specific quality rating. The query joins the 'directors' table with the 'movies2directors' table to associate directors with their movies, filtering the results based on the quality of the directors using a numeric placeholder."
        },
        {
            "sample_id": 2300,
            "vt": "SELECT movies2directors.genre FROM movies INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE movies.isenglish = '[placeholder-type:string]' GROUP BY movies2directors.genre ORDER BY COUNT(movies.movieid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the genres of movies from the 'movies' table that are in English. It joins the 'movies' table with the 'movies2directors' table to access the genre information. The results are grouped by genre and ordered by the count of movies in each genre, allowing for a limit on the number of genres returned."
        },
        {
            "sample_id": 2301,
            "vt": "SELECT movies2actors.actorid, movies2directors.directorid FROM movies2actors INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE movies2actors.movieid = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the identifiers of actors and directors associated with a specific movie from the 'movies2actors' and 'movies2directors' tables. The placeholder in the WHERE clause represents the unique identifier of the movie."
        },
        {
            "sample_id": 2276,
            "vt": "SELECT movies2directors.genre FROM movies INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE movies.year = [placeholder-type:numeric] AND movies.isenglish = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the genre of movies from the 'movies' table that were released in a specific year and are in English. The query uses an INNER JOIN to connect the 'movies' table with the 'movies2directors' table based on the movie identifier. The placeholders represent the year of release and the language of the movies."
        },
        {
            "sample_id": 2293,
            "vt": "SELECT actors.actorid, actors.a_quality FROM actors INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid WHERE movies2actors.movieid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the unique identifiers and quality ratings of actors from the 'actors' table who are associated with a specific movie. The placeholder in the WHERE clause represents the movie's identifier."
        },
        {
            "sample_id": 2280,
            "vt": "SELECT COUNT(DISTINCT T1.movieid) FROM u2base INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE movies.country = '[placeholder-type:string]' AND u2base.rating = [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of movies rated by users from a specific country that have received a certain rating. It combines data from the 'u2base' table, which contains user ratings, and the 'movies' table, which includes information about the movies, specifically filtering by the country and the rating value."
        },
        {
            "sample_id": 2335,
            "vt": "SELECT movies2directors.genre FROM directors INNER JOIN movies2directors AS T2 ON T1.directorid = T2.directorid WHERE directors.d_quality = [placeholder-type:numeric] GROUP BY movies2directors.genre ORDER BY COUNT(movies2directors.movieid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the genres of movies directed by directors who meet a specific quality criterion. It joins the 'directors' table with the 'movies2directors' table to filter and group the results based on the directors' quality, counting the number of movies in each genre and limiting the output to a specified number of genres."
        },
        {
            "sample_id": 2263,
            "vt": "SELECT movies2actors.actorid, movies2directors.directorid FROM movies2directors INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid WHERE movies2directors.genre = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the identifiers of actors and directors associated with movies of a specific genre. It combines data from the 'movies2actors' and 'movies2directors' tables using an inner join on the movie identifier, ensuring that only those records matching the specified genre are included."
        },
        {
            "sample_id": 2302,
            "vt": "SELECT CAST(SUM(CASE WHEN actors.a_quality >= [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(movies.movieid) FROM movies INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid INNER JOIN actors AS T3 ON T2.actorid = T3.actorid WHERE movies.country = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average rating of movies based on the quality of actors involved, filtered by the country of the movies. It sums up the ratings of movies where the actor quality meets a certain threshold, applies a scaling factor, and divides by the total count of movies in that country."
        },
        {
            "sample_id": 2294,
            "vt": "SELECT directors.directorid FROM directors INNER JOIN movies2directors AS T2 ON T1.directorid = T2.directorid WHERE directors.d_quality = [placeholder-type:numeric] GROUP BY directors.directorid ORDER BY COUNT(movies2directors.movieid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of directors from the 'directors' table who have a specific quality rating. It joins the 'directors' table with the 'movies2directors' table to count the number of movies associated with each director. The results are grouped by director ID and ordered by the count of movies, allowing for a limit on the number of directors returned based on the specified quality rating and limit."
        },
        {
            "sample_id": 2298,
            "vt": "SELECT movies2directors.directorid FROM movies INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE movies.country = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of directors from the 'movies2directors' table, which is linked to the 'movies' table. The query filters the results based on the country of the movies, allowing users to find directors associated with films from a specific country."
        },
        {
            "sample_id": 2269,
            "vt": "SELECT movies2actors.actorid FROM users INNER JOIN u2base AS T2 ON T1.userid = T2.userid INNER JOIN movies2actors AS T3 ON T2.movieid = T3.movieid WHERE users.occupation = [placeholder-type:numeric] GROUP BY u2base.movieid ORDER BY COUNT(users.userid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the actor identifiers from the 'movies2actors' table for users who have a specific occupation. It joins the 'users' table with the 'u2base' table to filter users based on their occupation and then joins with the 'movies2actors' table to get the corresponding actors for the movies rated by those users. The results are grouped by movie identifier and ordered by the count of users, limiting the output to a specified number of results."
        },
        {
            "sample_id": 2336,
            "vt": "SELECT u2base.movieid FROM movies INNER JOIN u2base AS T2 ON T1.movieid = T2.movieid WHERE movies.isenglish = '[placeholder-type:string]' AND movies.country = '[placeholder-type:string]' ORDER BY u2base.rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves movie identifiers from the 'movies' table that meet specific criteria regarding language and country. It joins the 'u2base' table to filter based on user ratings, ensuring that only movies that are either in English or from a specified country are included. The results are ordered by user ratings, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 2252,
            "vt": "SELECT AVG(users.occupation) FROM u2base INNER JOIN users AS T2 ON T1.userid = T2.userid WHERE u2base.rating < [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average occupation of users from the 'users' table who have rated movies in the 'u2base' table with a rating lower than a specified value. The query joins the 'u2base' and 'users' tables on the user ID to filter the relevant users based on their ratings."
        },
        {
            "sample_id": 2268,
            "vt": "SELECT movies2directors.genre FROM movies2directors INNER JOIN u2base AS T2 ON T1.movieid = T2.movieid INNER JOIN users AS T3 ON T2.userid = T3.userid WHERE users.age = [placeholder-type:numeric] GROUP BY movies2directors.genre ORDER BY COUNT(movies2directors.movieid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the genres of movies from the 'movies2directors' table, filtered by the age group of users who rated those movies. It joins the 'u2base' table to connect users with their movie ratings and the 'users' table to filter based on the specified age. The results are grouped by genre and ordered by the count of movies in each genre, with a limit on the number of results returned."
        },
        {
            "sample_id": 2299,
            "vt": "SELECT users.userid, users.age FROM u2base INNER JOIN users AS T2 ON T1.userid = T2.userid WHERE u2base.movieid = [placeholder-type:numeric]",
            "ba": "The virtual table describes the user IDs and their corresponding age groups from the 'users' table, filtered by a specific movie ID from the 'u2base' table. The placeholder in the WHERE clause represents the movie's identifier."
        },
        {
            "sample_id": 2307,
            "vt": "SELECT COUNT(movies2actors.actorid) FROM movies INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid WHERE movies.country = '[placeholder-type:string]' AND movies2actors.cast_num > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of actors associated with movies from a specific country that have a cast number exceeding a certain value. It combines data from the 'movies' table and the 'movies2actors' table using an inner join on the movie identifier."
        },
        {
            "sample_id": 2316,
            "vt": "SELECT COUNT(DISTINCT T1.movieid) FROM movies2directors INNER JOIN u2base AS T2 ON T1.movieid = T2.movieid WHERE u2base.rating = [placeholder-type:numeric] AND movies2directors.genre = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of movies from the 'movies2directors' table that have been rated by users in the 'u2base' table. It filters the results based on a specific rating and genre, where the placeholders represent the rating value and the genre type."
        },
        {
            "sample_id": 2296,
            "vt": "SELECT COUNT(u2base.movieid) FROM u2base INNER JOIN users AS T2 ON T1.userid = T2.userid WHERE u2base.rating = [placeholder-type:numeric] AND users.age BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of movies rated by users from the 'u2base' table, filtered by a specific rating and a range of ages. The placeholders represent the rating value and the age range for filtering."
        },
        {
            "sample_id": 2339,
            "vt": "SELECT SUM(CASE WHEN actors.a_gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END), movies.country, movies.runningtime FROM actors INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid INNER JOIN movies AS T3 ON T2.movieid = T3.movieid WHERE movies2actors.movieid = [placeholder-type:numeric] GROUP BY movies.country, movies.runningtime",
            "ba": "The virtual table summarizes the total count of actors based on their gender for a specific movie, along with the country and running time of that movie. The placeholders represent the gender to filter by and the movie identifier."
        },
        {
            "sample_id": 2284,
            "vt": "SELECT COUNT(DISTINCT T2.directorid) FROM movies2directors INNER JOIN directors AS T3 ON T2.directorid = T3.directorid WHERE movies2directors.genre = '[placeholder-type:string]' AND directors.d_quality = [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of directors from the 'directors' table who have directed movies of a specific genre. The query joins the 'movies2directors' table with the 'directors' table based on the director's ID. It filters the results based on the specified genre and the quality of the directors, where the genre is represented as a string placeholder and the quality as a numeric placeholder."
        },
        {
            "sample_id": 2315,
            "vt": "SELECT CAST(SUM(CASE WHEN u2base.rating = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(u2base.movieid) FROM u2base INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE movies.country = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average rating of movies based on user ratings from the 'u2base' table, filtered by the country of the movies. It uses a conditional sum to differentiate between specific rating values and applies a multiplier to adjust the average. The placeholders represent the rating values, the multiplier, and the country name for filtering."
        },
        {
            "sample_id": 2267,
            "vt": "SELECT movies2directors.genre FROM movies INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE movies.country = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the genre of movies from the 'movies' table that are produced in a specific country. It uses an inner join with the 'movies2directors' table to link movies with their respective genres. The placeholder in the WHERE clause represents the country of interest."
        }
    ],
    "cookbook": [
        {
            "sample_id": 8921,
            "vt": "SELECT recipe.title FROM recipe INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id WHERE quantity.max_qty <> quantity.min_qty",
            "ba": "The virtual table lists the titles of recipes from the 'recipe' table that require ingredients with specific quantity constraints. It filters for recipes where the maximum quantity of an ingredient differs from the minimum quantity, indicating that those ingredients must be rationed."
        },
        {
            "sample_id": 8909,
            "vt": "SELECT recipe.title, recipe.prep_min + recipe.cook_min + recipe.stnd_min FROM recipe INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE ingredient.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides the titles and total preparation time of recipes that include a specific ingredient. It combines data from the 'recipe', 'quantity', and 'ingredient' tables, calculating the total time by summing the preparation, cooking, and standing minutes."
        },
        {
            "sample_id": 8870,
            "vt": "SELECT nutrition.calories FROM recipe INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE recipe.title = '[placeholder-type:string]'",
            "ba": "The virtual table provides the calorie content of a specific recipe from the 'recipe' table by joining it with the 'nutrition' table. The placeholder in the WHERE clause represents the title of the recipe being queried."
        },
        {
            "sample_id": 8915,
            "vt": "SELECT AVG(nutrition.vitamin_c) FROM nutrition INNER JOIN Recipe AS T2 ON T2.recipe_id = T1.recipe_id WHERE recipe.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average vitamin C content from the 'nutrition' table for recipes that match a specific title. The placeholder in the WHERE clause allows users to specify the recipe title they are interested in."
        },
        {
            "sample_id": 8906,
            "vt": "SELECT CAST(SUM(CASE WHEN nutrition.sodium < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM recipe INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE recipe.source = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average sodium content of recipes from a specific source, applying a conditional sum based on a sodium threshold. It uses placeholders for the sodium threshold and the source of the recipes."
        },
        {
            "sample_id": 8899,
            "vt": "SELECT recipe.title FROM recipe INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE ingredient.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of recipes that include a specific ingredient. It retrieves data from the 'recipe' table and joins it with the 'quantity' and 'ingredient' tables to filter recipes based on the ingredient's name."
        },
        {
            "sample_id": 8897,
            "vt": "SELECT ingredient.name, CAST(COUNT(quantity.ingredient_id) AS FLOAT) * [placeholder-type:numeric] / (SELECT COUNT(quantity.ingredient_id) FROM Ingredient AS T1 INNER JOIN Quantity AS T2 ON T2.ingredient_id = T1.ingredient_id) FROM ingredient INNER JOIN Quantity AS T2 ON T2.ingredient_id = T1.ingredient_id GROUP BY quantity.ingredient_id ORDER BY COUNT(quantity.ingredient_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of ingredient names along with a calculated value representing the proportion of each ingredient used in recipes, based on the total count of ingredients. The calculation involves counting the occurrences of each ingredient in the quantity table, scaling it by a specified numeric placeholder, and normalizing it against the total count of ingredients. The results are grouped by ingredient and ordered by their count, with a limit applied to the number of results returned."
        },
        {
            "sample_id": 8903,
            "vt": "SELECT recipe.title FROM recipe INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE nutrition.iron > [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of recipes from the 'recipe' table that contain a specified amount of iron. It joins the 'recipe' table with the 'nutrition' table to filter recipes based on their iron content, using a placeholder for the numeric value of iron."
        },
        {
            "sample_id": 8892,
            "vt": "SELECT ingredient.name FROM recipe INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE recipe.title = '[placeholder-type:string]' AND quantity.optional = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of ingredients used in recipes that match a specific title and have a specified optional status. The placeholders in the WHERE clause represent the recipe title and whether the ingredient is optional or not."
        },
        {
            "sample_id": 8914,
            "vt": "SELECT recipe.title FROM recipe INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE nutrition.alcohol = [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of recipes from the 'recipe' table that contain a specific amount of alcohol. The query joins the 'recipe' table with the 'nutrition' table to filter recipes based on their alcohol content, using a placeholder for numeric values."
        },
        {
            "sample_id": 8891,
            "vt": "SELECT ingredient.name FROM recipe INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE recipe.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of ingredients used in a specific recipe from the 'recipe' table. It joins the 'recipe' table with the 'quantity' table to link recipes with their respective ingredients, and filters the results based on the title of the recipe provided as a placeholder."
        },
        {
            "sample_id": 8896,
            "vt": "SELECT quantity.recipe_id, recipe.prep_min + recipe.cook_min + recipe.stnd_min FROM recipe INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id GROUP BY quantity.recipe_id ORDER BY COUNT(quantity.ingredient_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of recipes along with their total preparation time, which is calculated by summing the preparation, cooking, and standing minutes. It retrieves the recipe ID and the total time for each recipe by joining the 'recipe' table with the 'quantity' table, allowing us to group the results by recipe ID and order them based on the number of ingredients used in each recipe. The placeholder in the LIMIT clause allows users to specify how many recipes they want to retrieve."
        },
        {
            "sample_id": 8893,
            "vt": "SELECT recipe.title FROM recipe INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE nutrition.alcohol > [placeholder-type:numeric] ORDER BY recipe.prep_min LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of recipes from the 'recipe' table that contain a specified amount of alcohol, joining with the 'nutrition' table to filter based on the alcohol content. The results are ordered by the preparation time of the recipes and limited to a certain number of entries."
        },
        {
            "sample_id": 8857,
            "vt": "SELECT nutrition.total_fat - nutrition.sat_fat FROM recipe INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE recipe.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the unsaturated fat content of a specific recipe by subtracting the saturated fat from the total fat. It retrieves this information from the 'nutrition' table, which is linked to the 'recipe' table through the recipe ID. The placeholder in the WHERE clause represents the title of the recipe being queried."
        },
        {
            "sample_id": 8860,
            "vt": "SELECT DISTINCT CASE WHEN CASE WHEN recipe.title = '[placeholder-type:string]' THEN nutrition.vitamin_c END > CASE WHEN recipe.title = '[placeholder-type:string]' THEN nutrition.vitamin_c END THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM nutrition INNER JOIN Recipe AS T2 ON T2.recipe_id = T1.recipe_id",
            "ba": "The virtual table provides a comparison of the vitamin C content in recipes based on their titles. It uses a conditional statement to determine which recipe has a higher vitamin C content, allowing users to compare two specific recipes by their titles. The placeholders represent the titles of the recipes being compared."
        },
        {
            "sample_id": 8856,
            "vt": "SELECT recipe.title FROM recipe INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id ORDER BY nutrition.total_fat LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of recipes from the 'recipe' table, joined with the 'nutrition' table to access nutritional information. The results are ordered by the total fat content in ascending order, and the number of results returned is limited by a numeric placeholder."
        },
        {
            "sample_id": 8883,
            "vt": "SELECT AVG(nutrition.calories) FROM ingredient INNER JOIN Quantity AS T2 ON T2.ingredient_id = T1.ingredient_id INNER JOIN Nutrition AS T3 ON T3.recipe_id = T2.recipe_id WHERE ingredient.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average calorie content of recipes that include a specific ingredient. It joins the 'ingredient', 'quantity', and 'nutrition' tables to gather the necessary data, filtering by the name of the ingredient provided as a placeholder."
        },
        {
            "sample_id": 8867,
            "vt": "SELECT quantity.min_qty FROM recipe INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE recipe.title = '[placeholder-type:string]' AND ingredient.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the minimum quantity of a specific ingredient required for a recipe based on the recipe's title and the ingredient's name. It joins the 'recipe', 'quantity', and 'ingredient' tables to access the necessary data."
        },
        {
            "sample_id": 8863,
            "vt": "SELECT quantity.optional FROM recipe INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE recipe.title = '[placeholder-type:string]' AND ingredient.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about whether a specific ingredient is optional for a given recipe. It retrieves this information by joining the 'recipe', 'quantity', and 'ingredient' tables based on their relationships. The placeholders in the WHERE clause represent the title of the recipe and the name of the ingredient."
        },
        {
            "sample_id": 8877,
            "vt": "SELECT quantity.preparation FROM recipe INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE recipe.title = '[placeholder-type:string]' AND ingredient.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the preparation methods for specific ingredients used in a recipe, identified by its title. The placeholders in the WHERE clause represent the recipe title and the ingredient name."
        },
        {
            "sample_id": 8858,
            "vt": "SELECT recipe.title FROM recipe INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE nutrition.sodium < [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of recipes from the 'recipe' table that have a sodium content below a specified threshold. The query joins the 'recipe' table with the 'nutrition' table to filter recipes based on their sodium levels, using a placeholder for the sodium value."
        },
        {
            "sample_id": 8911,
            "vt": "SELECT nutrition.total_fat FROM recipe INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE recipe.title = '[placeholder-type:string]'",
            "ba": "The virtual table provides the total fat content of a specific recipe from the 'recipe' table by joining it with the 'nutrition' table. The placeholder in the WHERE clause represents the title of the recipe being queried."
        },
        {
            "sample_id": 8862,
            "vt": "SELECT nutrition.calories FROM recipe INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE recipe.title = '[placeholder-type:string]'",
            "ba": "The virtual table provides the calorie content of a specific recipe from the 'recipe' table by joining it with the 'nutrition' table. The placeholder in the WHERE clause represents the title of the recipe being queried."
        },
        {
            "sample_id": 8881,
            "vt": "SELECT recipe.title FROM recipe INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id GROUP BY recipe.title ORDER BY COUNT(recipe.title) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of recipes from the 'recipe' table, joining with the 'quantity' table to count the number of ingredients associated with each recipe. The results are grouped by recipe title and ordered by the count of ingredients, limiting the output to a specified number of recipes."
        },
        {
            "sample_id": 8900,
            "vt": "SELECT ingredient.name FROM recipe INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE recipe.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of ingredients used in a specific recipe from the 'recipe' table. It joins the 'recipe' table with the 'quantity' table to link recipes with their respective ingredients, and then retrieves the ingredient names from the 'ingredient' table based on a specified recipe title."
        },
        {
            "sample_id": 8871,
            "vt": "SELECT COUNT(*) FROM ingredient INNER JOIN Quantity AS T2 ON T1.ingredient_id = T2.ingredient_id WHERE ingredient.name = '[placeholder-type:string]' AND quantity.unit = '[placeholder-type:string]' AND quantity.recipe_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of specific ingredients used in a recipe based on their name and unit of measurement. It joins the 'ingredient' table with the 'quantity' table to filter the results according to the specified ingredient name, unit, and recipe ID."
        },
        {
            "sample_id": 8866,
            "vt": "SELECT COUNT(*) FROM ingredient INNER JOIN Quantity AS T2 ON T1.ingredient_id = T2.ingredient_id WHERE ingredient.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of occurrences of a specific ingredient in the 'ingredient' table by joining it with the 'quantity' table. The placeholder in the WHERE clause represents the name of the ingredient being queried."
        },
        {
            "sample_id": 8918,
            "vt": "SELECT recipe.title FROM recipe INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id ORDER BY nutrition.calories LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of recipes from the 'recipe' table, joined with the 'nutrition' table to access nutritional information. The results are ordered by the calorie content of the recipes, and a limit is applied to restrict the number of titles returned."
        },
        {
            "sample_id": 8879,
            "vt": "SELECT recipe.title FROM recipe INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id ORDER BY nutrition.vitamin_c LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of recipes from the 'recipe' table that are joined with the 'nutrition' table to filter based on the vitamin C content. The results are ordered by the vitamin C content, and a limit is applied to the number of results returned."
        },
        {
            "sample_id": 8886,
            "vt": "SELECT ingredient.name FROM ingredient INNER JOIN Quantity AS T2 ON T1.ingredient_id = T2.ingredient_id WHERE quantity.preparation = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of ingredients from the 'ingredient' table that require a specific preparation method. The placeholder in the WHERE clause represents the preparation type of the ingredient."
        },
        {
            "sample_id": 8865,
            "vt": "SELECT ingredient.name FROM recipe INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE recipe.title = '[placeholder-type:string]' AND quantity.preparation IS NULL",
            "ba": "The virtual table describes the names of ingredients from the 'ingredient' table that are used in a specific recipe, identified by its title. The query filters for ingredients that do not require any preparation, indicated by a NULL value in the 'preparation' column of the 'quantity' table."
        },
        {
            "sample_id": 8859,
            "vt": "SELECT recipe.title FROM recipe INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE nutrition.iron > [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of recipes from the 'recipe' table that contain a specified amount of iron. The query joins the 'recipe' table with the 'nutrition' table to filter recipes based on their iron content, using a placeholder for the iron value."
        },
        {
            "sample_id": 8919,
            "vt": "SELECT COUNT(quantity.recipe_id) FROM ingredient INNER JOIN Quantity AS T2 ON T2.ingredient_id = T1.ingredient_id INNER JOIN Nutrition AS T3 ON T3.recipe_id = T2.recipe_id WHERE NOT ingredient.category LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of recipes that include ingredients from a specific category, excluding those that match a given category name. It joins the 'ingredient', 'quantity', and 'nutrition' tables to gather the necessary data."
        },
        {
            "sample_id": 8910,
            "vt": "SELECT CAST(SUM(CASE WHEN recipe.servings >= [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM recipe INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE ingredient.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average quantity of a specific ingredient used in recipes that serve a certain number of people. It sums the quantities of the ingredient from the 'Quantity' table, filtering based on the ingredient's name and the number of servings in the 'Recipe' table. The result is then scaled by a placeholder value and divided by the count of recipes to provide an average."
        },
        {
            "sample_id": 8889,
            "vt": "SELECT ingredient.name FROM ingredient INNER JOIN Quantity AS T2 ON T1.ingredient_id = T2.ingredient_id GROUP BY quantity.ingredient_id ORDER BY COUNT(quantity.ingredient_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of ingredients from the 'ingredient' table that are used in recipes, joining with the 'quantity' table to ensure that only ingredients with specified quantities are included. The results are grouped by ingredient ID to count how many recipes each ingredient appears in, and the output is limited to a specified number of ingredients based on the user's input."
        },
        {
            "sample_id": 8890,
            "vt": "SELECT COUNT(*) FROM recipe INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE ingredient.category = '[placeholder-type:string]' AND recipe.title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of recipes that include ingredients from a specific category and have a specific title. It joins the 'recipe', 'quantity', and 'ingredient' tables to filter the results based on the ingredient category and recipe title."
        },
        {
            "sample_id": 8861,
            "vt": "SELECT recipe.title FROM recipe INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE recipe.prep_min > [placeholder-type:numeric] ORDER BY nutrition.calories LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of recipes from the 'recipe' table that require a preparation time greater than a specified number of minutes. It joins the 'recipe' table with the 'nutrition' table to access nutritional information, and it orders the results by the calorie content of the recipes, limiting the output to a specified number of entries."
        },
        {
            "sample_id": 8882,
            "vt": "SELECT CAST(SUM(CASE WHEN recipe.title = '[placeholder-type:string]' THEN nutrition.sodium ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(CASE WHEN recipe.title = '[placeholder-type:string]' THEN nutrition.sodium ELSE [placeholder-type:numeric] END) FROM recipe INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id",
            "ba": "The virtual table calculates the total sodium content of a specific recipe identified by its title, adjusting it by a specified numeric factor. It uses a conditional aggregation to sum the sodium values from the nutrition table, filtering based on the recipe title, and then applies a mathematical operation to derive the final result."
        },
        {
            "sample_id": 8908,
            "vt": "SELECT COUNT(*) FROM ingredient INNER JOIN Quantity AS T2 ON T1.ingredient_id = T2.ingredient_id WHERE ingredient.category = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of ingredients from the 'ingredient' table that belong to a specific category. It joins the 'ingredient' table with the 'quantity' table to ensure that only ingredients with associated quantities are considered. The placeholder in the WHERE clause represents the category of the ingredient."
        },
        {
            "sample_id": 8913,
            "vt": "SELECT COUNT(*) FROM recipe INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE recipe.title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of ingredients used in a specific recipe identified by its title. It joins the 'recipe', 'quantity', and 'ingredient' tables to gather the necessary data."
        },
        {
            "sample_id": 8887,
            "vt": "SELECT COUNT(*) FROM nutrition INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id WHERE nutrition.vitamin_a > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of recipes from the 'nutrition' table that have a vitamin A content exceeding a specified threshold. It joins the 'nutrition' table with the 'quantity' table to ensure that the recipes are properly linked to their respective ingredients, allowing for a comprehensive analysis of recipes based on their nutritional content."
        }
    ],
    "social_media": [
        {
            "sample_id": 837,
            "vt": "SELECT COUNT(DISTINCT TweetID) FROM twitter WHERE twitter.weekday = '[placeholder-type:string]' AND twitter.isreshare = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of distinct tweets from the 'twitter' table that were posted on a specific weekday and are categorized as either reshared or not reshared. The placeholders in the WHERE clause represent the specific weekday and the resharing status of the tweets."
        },
        {
            "sample_id": 829,
            "vt": "SELECT twitter.text FROM twitter INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE location.city = '[placeholder-type:string]' AND location.state = '[placeholder-type:string]' AND location.country = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the text of tweets from the 'twitter' table that are associated with a specific location. It joins the 'twitter' table with the 'location' table based on the location ID, and filters the results to include only those tweets posted in a specified city, state, and country. The placeholders in the WHERE clause represent the city, state, and country names."
        },
        {
            "sample_id": 821,
            "vt": "SELECT twitter.text FROM twitter INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE user.gender = '[placeholder-type:string]'",
            "ba": "The virtual table describes the text of tweets from the 'twitter' table that are posted by users of a specific gender. The query joins the 'twitter' table with the 'user' table to filter tweets based on the gender of the user. The placeholder in the WHERE clause represents the gender of the user."
        },
        {
            "sample_id": 833,
            "vt": "SELECT COUNT(DISTINCT T1.TweetID) / COUNT(DISTINCT T1.UserID) / [placeholder-type:numeric] FROM twitter INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE user.gender = '[placeholder-type:string]' AND twitter.day BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of unique tweets per user for a specific gender over a defined range of days. It joins the 'twitter' and 'user' tables based on the user ID, counts distinct tweets, and divides by the count of distinct users. The placeholders represent the gender of the user and the range of days for filtering the tweets."
        },
        {
            "sample_id": 802,
            "vt": "SELECT COUNT(twitter.tweetid) FROM twitter INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE twitter.sentiment > [placeholder-type:numeric] AND location.state = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of tweets from the 'twitter' table that have a positive sentiment and are associated with a specific state in the 'location' table. The placeholders represent the sentiment threshold and the state name."
        },
        {
            "sample_id": 782,
            "vt": "SELECT COUNT(twitter.tweetid) FROM twitter INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE location.country = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of tweets from the 'twitter' table that are associated with a specific country. It joins the 'twitter' table with the 'location' table based on the location ID, filtering the results to include only those tweets from users located in the specified country. The placeholders represent the country name and a limit on the number of results returned."
        },
        {
            "sample_id": 814,
            "vt": "SELECT twitter.weekday FROM twitter WHERE twitter.tweetid = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the weekday on which a specific tweet was posted from the 'twitter' table. The placeholder in the WHERE clause represents the unique identifier of the tweet."
        },
        {
            "sample_id": 831,
            "vt": "SELECT (SELECT T2.Country, SUM(T1.Sentiment) AS num FROM twitter AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE T1.Sentiment > 0 GROUP BY T2.Country).country FROM (SELECT location.country, SUM(twitter.sentiment) FROM twitter AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE T1.Sentiment > 0 GROUP BY T2.Country) AS t ORDER BY (SELECT T2.Country, SUM(T1.Sentiment) AS num FROM twitter AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE T1.Sentiment > 0 GROUP BY T2.Country).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total positive sentiment of tweets grouped by country from the 'twitter' and 'location' tables. It retrieves the country names and their corresponding total positive sentiment scores, ordering them by the sentiment score in descending order and limiting the results to a specified number."
        },
        {
            "sample_id": 849,
            "vt": "SELECT (SELECT T2.City, COUNT(T1.TweetID) AS num FROM twitter AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE T2.Country = 'Canada' GROUP BY T2.City).city FROM (SELECT location.city, COUNT(twitter.tweetid) FROM twitter AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE T2.Country = 'Canada' GROUP BY T2.City) AS t ORDER BY (SELECT T2.City, COUNT(T1.TweetID) AS num FROM twitter AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE T2.Country = 'Canada' GROUP BY T2.City).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of cities in Canada along with the count of tweets posted from each city. It retrieves the city names from the 'location' table and counts the number of tweets associated with each city from the 'twitter' table. The results are ordered by the number of tweets in descending order, and a limit is applied to restrict the number of cities returned based on a specified numeric value."
        },
        {
            "sample_id": 835,
            "vt": "SELECT twitter.text FROM twitter WHERE twitter.lang <> '[placeholder-type:string]'",
            "ba": "The virtual table describes the text of tweets from the 'twitter' table that are not in a specific language. The placeholder in the WHERE clause represents the language to be excluded."
        },
        {
            "sample_id": 815,
            "vt": "SELECT twitter.reach FROM twitter WHERE twitter.text = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the reach of tweets from the 'twitter' table that match a specific tweet text. The placeholder in the WHERE clause represents the text of the tweet being queried."
        },
        {
            "sample_id": 797,
            "vt": "SELECT COUNT(location.state) FROM location WHERE location.country = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of states from the 'location' table that belong to a specific country. The placeholder in the WHERE clause represents the country's name."
        },
        {
            "sample_id": 787,
            "vt": "SELECT location.country FROM twitter INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE location.country IN ('[placeholder-type:string]', '[placeholder-type:string]') AND twitter.sentiment > [placeholder-type:numeric] GROUP BY location.country ORDER BY COUNT(twitter.tweetid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the countries from the 'location' table where tweets have been posted, filtering for specific countries and positive sentiment tweets. It groups the results by country and orders them based on the count of tweets, limiting the output to a specified number of countries."
        },
        {
            "sample_id": 784,
            "vt": "SELECT COUNT(twitter.tweetid) FROM twitter INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE location.city = '[placeholder-type:string]' AND twitter.isreshare = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of tweets from the 'twitter' table that have been posted from a specific city and are either reshared or not reshared. The placeholders in the WHERE clause represent the city name and the resharing status of the tweets."
        },
        {
            "sample_id": 820,
            "vt": "SELECT user.gender FROM twitter INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE twitter.tweetid = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the gender of the user who posted a specific tweet from the 'twitter' table by joining it with the 'user' table based on the user ID."
        },
        {
            "sample_id": 776,
            "vt": "SELECT COUNT(twitter.tweetid) FROM twitter WHERE twitter.lang = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of tweets from the 'twitter' table that are posted in a specific language. The placeholder in the WHERE clause represents the language of the tweets."
        },
        {
            "sample_id": 816,
            "vt": "SELECT COUNT(DISTINCT TweetID) FROM twitter WHERE twitter.lang = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct tweets from the 'twitter' table that are posted in a specific language. The placeholder in the WHERE clause represents the language of the tweets."
        },
        {
            "sample_id": 851,
            "vt": "SELECT twitter.text FROM user INNER JOIN twitter AS T2 ON T1.UserID = T2.UserID INNER JOIN location AS T3 ON T2.LocationID = T3.LocationID WHERE location.country = '[placeholder-type:string]' AND user.gender = '[placeholder-type:string]' ORDER BY twitter.likes LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the text of tweets from users filtered by their gender and the country of their location. It joins the 'user', 'twitter', and 'location' tables to access the necessary information, applying conditions to filter by country and gender. The results are ordered by the number of likes on the tweets, and a limit is set on the number of results returned."
        },
        {
            "sample_id": 803,
            "vt": "SELECT twitter.text FROM twitter INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE location.state = '[placeholder-type:string]' ORDER BY twitter.klout LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the text of tweets from the 'twitter' table that are associated with a specific state. It joins the 'twitter' table with the 'location' table to filter tweets based on the state provided in the placeholder. The results are ordered by the klout score of the tweets, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 818,
            "vt": "SELECT COUNT(twitter.tweetid) FROM twitter WHERE twitter.weekday = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of tweets posted on a specific weekday from the 'twitter' table. The placeholder in the WHERE clause represents the day of the week for which the tweet count is being queried."
        },
        {
            "sample_id": 796,
            "vt": "SELECT COUNT(user.userid) FROM user WHERE user.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users from the 'user' table who match a specific gender. The placeholder in the WHERE clause represents the gender of the users being counted."
        },
        {
            "sample_id": 812,
            "vt": "SELECT SUM(CASE WHEN user.gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) / COUNT(twitter.tweetid) FROM twitter INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID INNER JOIN user AS T3 ON T3.UserID = T1.UserID WHERE location.state = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average of a specific gender's tweets from users in a particular state. It sums the counts of tweets based on the user's gender and divides it by the total number of tweets posted in that state. The placeholders represent the gender and state values."
        },
        {
            "sample_id": 794,
            "vt": "SELECT SUM(CASE WHEN location.city = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) / COUNT(twitter.tweetid) FROM twitter INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE location.country = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average of a specific metric based on tweets posted from a particular city and country. It sums up a conditional value for tweets from the specified city and divides it by the total count of tweets, filtering the results by the specified country."
        },
        {
            "sample_id": 793,
            "vt": "SELECT twitter.text FROM twitter INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID INNER JOIN user AS T2 ON T2.UserID = T1.UserID INNER JOIN user AS T3 ON T1.UserID = T3.UserID WHERE user.city = '[placeholder-type:string]' AND user.gender = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the text of tweets from the 'twitter' table, filtering based on the city and gender of the users who posted them. It joins the 'twitter' table with the 'location' and 'user' tables to access the necessary user and location information."
        },
        {
            "sample_id": 801,
            "vt": "SELECT location.country FROM twitter INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE twitter.reach = [placeholder-type:numeric]",
            "ba": "The virtual table describes the countries associated with tweets from the 'twitter' table that have a specific reach. The query joins the 'twitter' table with the 'location' table to filter the results based on the reach of the tweets, using a placeholder for numeric values in the WHERE clause."
        },
        {
            "sample_id": 778,
            "vt": "SELECT COUNT(twitter.tweetid) FROM twitter WHERE twitter.reach > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of tweets from the 'twitter' table that have a reach greater than a specified value. The placeholder in the WHERE clause represents the minimum reach threshold for filtering the tweets."
        },
        {
            "sample_id": 800,
            "vt": "SELECT COUNT(twitter.tweetid) FROM twitter INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE location.state = '[placeholder-type:string]' AND twitter.isreshare = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of tweets from the 'twitter' table that are reshared, filtered by a specific state from the 'location' table. The placeholders represent the state name and whether the tweet is reshared or not."
        },
        {
            "sample_id": 819,
            "vt": "SELECT twitter.text FROM twitter WHERE twitter.weekday = '[placeholder-type:string]'",
            "ba": "The virtual table describes the text of tweets from the 'twitter' table that have been posted on a specific weekday. The placeholder in the WHERE clause represents the day of the week for which the tweets are being queried."
        },
        {
            "sample_id": 810,
            "vt": "SELECT COUNT(twitter.tweetid) FROM twitter INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE twitter.weekday = '[placeholder-type:string]' AND location.state = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of tweets from the 'twitter' table that were posted on a specific weekday and from a specific state. It joins the 'twitter' table with the 'location' table based on the location ID to filter the results accordingly. The placeholders in the WHERE clause represent the weekday and state for which the tweet count is being queried."
        },
        {
            "sample_id": 807,
            "vt": "SELECT user.gender FROM twitter INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE twitter.retweetcount = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the gender of users who have posted tweets that have a specific number of retweets. It combines data from the 'twitter' table and the 'user' table based on the user ID, allowing for analysis of user demographics in relation to tweet engagement."
        },
        {
            "sample_id": 843,
            "vt": "SELECT COUNT(DISTINCT T1.TweetID) FROM twitter INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE twitter.lang = '[placeholder-type:string]' AND location.country = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct tweets from the 'twitter' table that have been posted in a specific language and from a specific country. It joins the 'twitter' table with the 'location' table based on the location ID to filter the results accordingly. The placeholders represent the language of the tweets and the country from which they originate."
        },
        {
            "sample_id": 783,
            "vt": "SELECT location.city FROM twitter INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE location.country = '[placeholder-type:string]' GROUP BY location.city ORDER BY COUNT(twitter.tweetid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the cities from which tweets have been posted, filtered by a specific country. It aggregates the data by counting the number of tweets per city and orders the results based on the tweet count. The placeholders represent the country name and the limit on the number of cities to return."
        },
        {
            "sample_id": 811,
            "vt": "SELECT location.statecode FROM twitter INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE twitter.tweetid = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the state code associated with a specific tweet from the 'twitter' table by joining it with the 'location' table based on the location ID. The placeholder in the WHERE clause represents the unique identifier of the tweet."
        },
        {
            "sample_id": 836,
            "vt": "SELECT twitter.userid FROM twitter GROUP BY twitter.userid ORDER BY COUNT(DISTINCT TweetID) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a list of unique user IDs from the 'twitter' table, grouping the results by user ID. It orders the users based on the count of distinct tweets they have posted, limiting the results to a specified number of users."
        },
        {
            "sample_id": 806,
            "vt": "SELECT location.city FROM twitter INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE twitter.text = '[placeholder-type:string]'",
            "ba": "The virtual table describes the cities from the 'location' table where tweets containing specific text have been posted. The query joins the 'twitter' table with the 'location' table based on the location ID, allowing us to filter tweets by their content and retrieve the corresponding city names."
        },
        {
            "sample_id": 791,
            "vt": "SELECT user.gender FROM twitter INNER JOIN user AS T2 ON T1.UserID = T2.UserID ORDER BY twitter.reach LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the gender of users who have posted tweets, by joining the 'twitter' and 'user' tables based on the user ID. The results are ordered by the reach of the tweets, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 850,
            "vt": "SELECT DISTINCT location.city FROM twitter INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE twitter.sentiment = [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct cities from the 'location' table where tweets have a specific sentiment score. The query joins the 'twitter' table with the 'location' table based on the location ID, filtering the results to include only those tweets that match the specified sentiment value."
        },
        {
            "sample_id": 786,
            "vt": "SELECT location.country FROM twitter INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID ORDER BY twitter.likes LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the countries associated with tweets from the 'twitter' table, joining it with the 'location' table based on the location ID. The results are ordered by the number of likes each tweet has received, and a limit is applied to restrict the number of countries returned based on a specified numeric value."
        },
        {
            "sample_id": 788,
            "vt": "SELECT COUNT(twitter.tweetid) FROM twitter INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE location.city = '[placeholder-type:string]' AND twitter.weekday = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of tweets from the 'twitter' table that have been posted by users in a specific city on a specific weekday. It joins the 'twitter' table with the 'location' table to filter tweets based on the city and weekday criteria."
        },
        {
            "sample_id": 777,
            "vt": "SELECT twitter.text FROM twitter WHERE twitter.isreshare = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the text of tweets from the 'twitter' table based on whether they are reshared or not. The placeholder in the WHERE clause indicates the resharing status of the tweets."
        },
        {
            "sample_id": 781,
            "vt": "SELECT location.city FROM location WHERE NOT location.city IS NULL AND location.country = '[placeholder-type:string]'",
            "ba": "The virtual table describes the cities from the 'location' table that are not null and belong to a specific country. The placeholder in the WHERE clause represents the country's name."
        },
        {
            "sample_id": 845,
            "vt": "SELECT SUM(CASE WHEN twitter.sentiment > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN twitter.sentiment = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM twitter INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE user.gender = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between the sum of positive sentiments and the sum of neutral sentiments of tweets posted by users of a specific gender. It joins the 'twitter' table with the 'user' table based on the user ID, and filters the results based on the specified gender."
        },
        {
            "sample_id": 840,
            "vt": "SELECT COUNT(DISTINCT T1.TweetID) FROM twitter INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE user.gender = '[placeholder-type:string]' AND twitter.weekday = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct tweets from the 'twitter' table that have been posted by users of a specific gender on a specific weekday. It joins the 'twitter' table with the 'user' table based on the user ID, and filters the results based on the gender and weekday using placeholders."
        },
        {
            "sample_id": 834,
            "vt": "SELECT COUNT(DISTINCT TweetID) FROM twitter WHERE twitter.klout > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of unique tweets from the 'twitter' table that have a klout score greater than a specified value. The placeholder in the WHERE clause represents the minimum klout score to filter the tweets."
        },
        {
            "sample_id": 795,
            "vt": "SELECT SUM(CASE WHEN user.gender = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) / COUNT(twitter.tweetid) FROM twitter INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE twitter.sentiment > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of tweets posted by users of a specific gender from the 'twitter' table, filtered by a positive sentiment score. It uses a conditional sum to count tweets based on the user's gender and divides this by the total count of tweets that have a sentiment greater than a specified value."
        },
        {
            "sample_id": 823,
            "vt": "SELECT (SELECT T2.Gender, COUNT(text) AS num FROM twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE T1.Lang = 'en' GROUP BY T2.Gender).gender FROM (SELECT user.gender, COUNT(twitter.text) FROM twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE T1.Lang = 'en' GROUP BY T2.Gender) AS t ORDER BY (SELECT T2.Gender, COUNT(text) AS num FROM twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE T1.Lang = 'en' GROUP BY T2.Gender).num LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the number of tweets in English grouped by the gender of the users who posted them. It counts the tweets for each gender and orders the results based on the count, allowing for a limit on the number of results returned."
        }
    ],
    "food_inspection_2": [
        {
            "sample_id": 6136,
            "vt": "SELECT employee.salary FROM employee INNER JOIN (SELECT T.employee_id, COUNT(T.inspection_id) FROM inspection AS T GROUP BY T.employee_id ORDER BY COUNT(T.inspection_id) DESC LIMIT 1) AS T2 ON T1.employee_id = T2.employee_id",
            "ba": "The virtual table retrieves the salary of the employee who has conducted the highest number of inspections. It does this by first creating a subquery that counts the number of inspections for each employee, ordering them in descending order, and limiting the results to the top employee. This subquery is then joined with the main employee table to get the corresponding salary."
        },
        {
            "sample_id": 6149,
            "vt": "SELECT COUNT(DISTINCT T1.license_no) FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE inspection.inspection_date BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND establishment.ward = [placeholder-type:numeric] AND establishment.license_no IN (SELECT establishment.license_no FROM (SELECT license_no FROM inspection WHERE results = 'Fail' GROUP BY license_no HAVING COUNT(results) >= 5))",
            "ba": "The virtual table counts the number of distinct facilities (establishments) that have undergone inspections resulting in failure. It filters the inspections based on a specific date range and a designated ward. Additionally, it only includes establishments that have had five or more failed inspections."
        },
        {
            "sample_id": 6159,
            "vt": "SELECT employee.last_name FROM employee WHERE employee.address = '[placeholder-type:string]' AND employee.city = '[placeholder-type:string]' AND employee.state = '[placeholder-type:string]'",
            "ba": "The virtual table describes the last names of employees from the 'employee' table who reside at a specific address in a particular city and state. The placeholders in the WHERE clause represent the address, city, and state of the employee's residence."
        },
        {
            "sample_id": 6198,
            "vt": "SELECT DISTINCT inspection.results FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE establishment.dba_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of inspection results for establishments based on their 'doing business as' (DBA) name. It joins the 'establishment' table with the 'inspection' table using the license number to filter the results accordingly."
        },
        {
            "sample_id": 6140,
            "vt": "SELECT DISTINCT establishment.dba_name FROM establishment WHERE establishment.address = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct dba names of establishments from the 'establishment' table that have a specific physical address. The placeholder in the WHERE clause represents the address of the establishment."
        },
        {
            "sample_id": 6233,
            "vt": "SELECT COUNT(DISTINCT T1.license_no) FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE STRFTIME('%Y-%m', inspection.inspection_date) = '[placeholder-type:string]' AND establishment.facility_type = '[placeholder-type:string]' AND inspection.results = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct facilities from the 'establishment' table that have undergone inspections in a specific month and year. It filters the results based on the facility type and the inspection results, allowing users to analyze the number of unique establishments that meet these criteria."
        },
        {
            "sample_id": 6220,
            "vt": "SELECT establishment.facility_type FROM establishment WHERE establishment.dba_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the facility types of establishments from the 'establishment' table that have a specific doing business as (DBA) name. The placeholder in the WHERE clause represents the DBA name of the facility."
        },
        {
            "sample_id": 6234,
            "vt": "SELECT DISTINCT inspection.inspection_id FROM employee INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE employee.first_name = '[placeholder-type:string]' AND employee.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct inspection IDs from the 'inspection' table for employees with a specific first and last name. It joins the 'employee' table with the 'inspection' table based on the employee's ID, allowing us to filter inspections conducted by a particular employee."
        },
        {
            "sample_id": 6173,
            "vt": "SELECT SUM(CASE WHEN violation.fine = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN violation.fine = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM employee INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE employee.salary BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the difference between the total fines for specific violations and the total fines for other violations associated with employees whose salaries fall within a specified range. It joins the 'employee', 'inspection', and 'violation' tables to gather the necessary data for this calculation."
        },
        {
            "sample_id": 6230,
            "vt": "SELECT DISTINCT inspection_point.point_level FROM inspection_point INNER JOIN violation AS T2 ON T1.point_id = T2.point_id WHERE violation.fine = [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of inspection point levels from the 'inspection_point' table, which are associated with violations that have a specific fine amount. The query joins the 'inspection_point' table with the 'violation' table to filter the results based on the fine value, allowing users to see the different levels of points (Critical, Serious, Minor) that correspond to violations of a specified fine."
        },
        {
            "sample_id": 6189,
            "vt": "SELECT CAST(COUNT(CASE WHEN inspection.results LIKE '[placeholder-type:string]' THEN inspection.inspection_id END) AS FLOAT) * [placeholder-type:numeric] / COUNT(inspection.inspection_id), COUNT(DISTINCT T2.license_no) FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE establishment.city = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage of inspections that resulted in a specific outcome (like 'Pass' or 'Fail') for establishments located in a specified city. It also counts the number of unique establishments that have undergone inspections. The placeholders represent the inspection result type and the numeric value for scaling the percentage, as well as the city name for filtering the establishments."
        },
        {
            "sample_id": 6130,
            "vt": "SELECT COUNT(violation.point_id) FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE inspection.inspection_date = '[placeholder-type:string]' AND establishment.dba_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of violations associated with inspections for a specific establishment on a given inspection date. It joins the 'establishment', 'inspection', and 'violation' tables to gather the necessary data, filtering by the inspection date and the establishment's DBA name."
        },
        {
            "sample_id": 6181,
            "vt": "SELECT DISTINCT establishment.dba_name FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN employee AS T3 ON T2.employee_id = T3.employee_id WHERE inspection.inspection_date = '[placeholder-type:string]' AND employee.first_name = '[placeholder-type:string]' AND employee.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct dba names of establishments that have undergone inspections conducted by specific employees on a given inspection date. The placeholders represent the inspection date and the first and last names of the employees."
        },
        {
            "sample_id": 6221,
            "vt": "SELECT employee.salary FROM employee WHERE employee.first_name = '[placeholder-type:string]' AND employee.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the salary of an employee from the 'employee' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the employee being queried."
        },
        {
            "sample_id": 6244,
            "vt": "SELECT COUNT(DISTINCT T2.inspection_id) FROM inspection_point INNER JOIN violation AS T2 ON T1.point_id = T2.point_id WHERE inspection_point.point_level = '[placeholder-type:string]' AND violation.fine = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of distinct inspections associated with specific inspection points that have a defined point level and fine amount. It joins the 'inspection_point' table with the 'violation' table to filter results based on the point level and the fine amount, allowing users to analyze the frequency of inspections that resulted in violations of a certain severity and financial penalty."
        },
        {
            "sample_id": 6170,
            "vt": "SELECT inspection_point.description, violation.inspector_comment FROM inspection_point INNER JOIN violation AS T2 ON T1.point_id = T2.point_id WHERE violation.inspection_id = [placeholder-type:numeric]",
            "ba": "The virtual table provides details about specific inspection points and the corresponding comments made by inspectors regarding violations. It combines data from the 'inspection_point' and 'violation' tables, linking them through the point_id. The placeholder in the WHERE clause represents the unique identifier for a specific inspection, allowing users to filter results based on that inspection ID."
        },
        {
            "sample_id": 6215,
            "vt": "SELECT DISTINCT employee.title FROM employee INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE inspection.license_no = [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct career titles of employees who have conducted inspections at facilities, filtered by a specific license number. The placeholder in the WHERE clause represents the license number of the facility being inspected."
        },
        {
            "sample_id": 6218,
            "vt": "SELECT CAST(COUNT(CASE WHEN establishment.risk_level = [placeholder-type:numeric] THEN establishment.license_no END) AS FLOAT) * [placeholder-type:numeric] / COUNT(establishment.license_no) FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE inspection.results = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of facilities with a specific risk level that have passed inspections, multiplied by a specified factor. It does this by counting the number of facilities with the given risk level and dividing it by the total number of facilities, filtering the results based on the inspection outcomes."
        },
        {
            "sample_id": 6157,
            "vt": "SELECT CAST(COUNT(DISTINCT T2.inspection_id) AS FLOAT) / [placeholder-type:numeric], employee.first_name, employee.last_name FROM employee INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE employee.title = '[placeholder-type:string]' ORDER BY employee.salary LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of inspections conducted by employees with a specific title from the 'employee' table. It retrieves the first and last names of these employees, and the results are ordered by their salary. The placeholders allow for dynamic input of the title and limit on the number of results returned."
        },
        {
            "sample_id": 6129,
            "vt": "SELECT COUNT(violation.point_id) FROM inspection_point INNER JOIN violation AS T2 ON T1.point_id = T2.point_id WHERE violation.inspection_id = '[placeholder-type:string]' AND inspection_point.category = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of violations associated with a specific inspection point category for a given inspection. It combines data from the 'inspection_point' and 'violation' tables, filtering by the unique inspection ID and the category of the inspection point."
        },
        {
            "sample_id": 6179,
            "vt": "SELECT DISTINCT establishment.dba_name, inspection.results FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE establishment.city = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of distinct doing business as (DBA) names and their corresponding inspection results for establishments located in a specific city. The query joins the 'establishment' and 'inspection' tables based on the license number, ensuring that only establishments from the specified city are included."
        },
        {
            "sample_id": 6174,
            "vt": "SELECT COUNT(inspection.inspection_id) FROM inspection WHERE STRFTIME('%Y-%m', inspection.inspection_date) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of inspections conducted in a specific month and year from the 'inspection' table. The placeholder in the WHERE clause represents the year and month in the format 'YYYY-MM'."
        },
        {
            "sample_id": 6209,
            "vt": "SELECT COUNT(DISTINCT T1.employee_id) FROM employee INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE inspection.results = '[placeholder-type:string]' AND employee.salary > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of distinct employees from the 'employee' table who have conducted inspections with specific results and whose salary exceeds a certain amount. The placeholders represent the inspection result and the salary threshold."
        },
        {
            "sample_id": 6161,
            "vt": "SELECT DISTINCT establishment.address FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE STRFTIME('%Y-%m', inspection.inspection_date) = '[placeholder-type:string]' AND inspection.results = '[placeholder-type:string]' AND establishment.facility_type = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of addresses for establishments that have undergone inspections. It filters the results based on the inspection date (formatted to year and month), the results of the inspection, and the type of facility. The placeholders represent the specific month and year, the inspection result status, and the facility type."
        },
        {
            "sample_id": 6248,
            "vt": "SELECT CAST(COUNT(CASE WHEN establishment.facility_type = '[placeholder-type:string]' THEN establishment.license_no END) AS FLOAT) * [placeholder-type:numeric] / COUNT(establishment.facility_type) FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE violation.fine = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the proportion of facilities of a specific type that have violations with a certain fine. It counts the number of facilities matching the specified facility type and multiplies it by a numeric placeholder, then divides this by the total count of facilities of that type. The query joins the 'establishment', 'inspection', and 'violation' tables to filter the results based on the specified fine amount."
        },
        {
            "sample_id": 6142,
            "vt": "SELECT COUNT(establishment.license_no) FROM establishment WHERE establishment.risk_level = [placeholder-type:numeric] AND establishment.dba_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of establishments from the 'establishment' table that have a specific risk level and a specific doing business as (DBA) name. The placeholders represent the risk level as a numeric value and the DBA name as a string value."
        },
        {
            "sample_id": 6206,
            "vt": "SELECT MIN(inspection.inspection_date) FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE establishment.dba_name = '[placeholder-type:string]' AND STRFTIME('%Y', inspection.inspection_date) = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the earliest inspection date for a specific establishment identified by its 'dba_name' for a given year. It joins the 'establishment' and 'inspection' tables based on the license number, filtering results by the establishment's name and the year of the inspection date."
        },
        {
            "sample_id": 6165,
            "vt": "SELECT DISTINCT employee.first_name, employee.last_name FROM employee INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id INNER JOIN inspection_point AS T4 ON T3.point_id = T4.point_id WHERE inspection_point.category = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct first and last names of employees who have been involved in inspections that resulted in violations categorized under a specific inspection category. The placeholders in the WHERE clause represent the category of the inspection points."
        },
        {
            "sample_id": 6237,
            "vt": "SELECT DISTINCT establishment.dba_name FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE establishment.risk_level = [placeholder-type:numeric] AND inspection.results = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct dba names of establishments from the 'establishment' table that have a specific risk level and inspection results. The placeholders represent the risk level as a numeric value and the inspection results as a string value."
        },
        {
            "sample_id": 6171,
            "vt": "SELECT violation.inspector_comment, inspection_point.code FROM inspection_point INNER JOIN violation AS T2 ON T1.point_id = T2.point_id WHERE violation.inspection_id = [placeholder-type:numeric] AND violation.point_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the inspector's comments and the corresponding sanitary operating requirement codes for specific violations recorded during inspections. The placeholders in the WHERE clause represent the unique identifiers for the inspection and the inspection point, allowing users to filter results based on specific violations."
        },
        {
            "sample_id": 6139,
            "vt": "SELECT COUNT(employee.employee_id) FROM employee WHERE employee.zip = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees from the 'employee' table who reside in a specific postal code area. The placeholder in the WHERE clause represents the zip code of the employees."
        },
        {
            "sample_id": 6242,
            "vt": "SELECT DISTINCT inspection_point.category FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id INNER JOIN inspection_point AS T4 ON T3.point_id = T4.point_id WHERE establishment.dba_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct categories of inspection points associated with establishments that have a specific doing business as (DBA) name. It combines data from the 'establishment', 'inspection', 'violation', and 'inspection_point' tables to filter results based on the DBA name provided."
        },
        {
            "sample_id": 6163,
            "vt": "SELECT DISTINCT inspection.inspection_id FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE establishment.dba_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct inspection IDs from the 'inspection' table that are associated with establishments having a specific DBA (Doing Business As) name. The query uses an INNER JOIN to connect the 'establishment' and 'inspection' tables based on the license number, ensuring that only inspections related to the specified establishment are included."
        },
        {
            "sample_id": 6114,
            "vt": "SELECT COUNT(DISTINCT T1.license_no) FROM inspection INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE STRFTIME('%Y', inspection.inspection_date) = '[placeholder-type:string]' AND establishment.facility_type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct facilities that have undergone inspections in a specific year and belong to a certain facility type. It combines data from the 'inspection' and 'establishment' tables, filtering by the year of the inspection date and the type of facility."
        },
        {
            "sample_id": 6190,
            "vt": "SELECT CAST(COUNT(CASE WHEN employee.first_name = '[placeholder-type:string]' AND employee.last_name = '[placeholder-type:string]' THEN inspection.inspection_id ELSE [placeholder-type:numeric] END) AS FLOAT) / [placeholder-type:numeric] FROM employee INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE STRFTIME('%Y', inspection.inspection_date) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of inspections conducted by a specific employee over a specified time period. It counts the inspections associated with the employee's first and last name, and divides this count by a numeric placeholder representing the total number of inspections in that period."
        },
        {
            "sample_id": 6132,
            "vt": "SELECT (SELECT T2.employee_id, T2.first_name, T2.last_name, COUNT(T1.inspection_id) FROM inspection AS T1 INNER JOIN employee AS T2 ON T1.employee_id = T2.employee_id GROUP BY T2.employee_id, T2.first_name, T2.last_name ORDER BY COUNT(T1.inspection_id) DESC LIMIT 1).first_name, (SELECT T2.employee_id, T2.first_name, T2.last_name, COUNT(T1.inspection_id) FROM inspection AS T1 INNER JOIN employee AS T2 ON T1.employee_id = T2.employee_id GROUP BY T2.employee_id, T2.first_name, T2.last_name ORDER BY COUNT(T1.inspection_id) DESC LIMIT 1).last_name FROM (SELECT employee.employee_id, employee.first_name, employee.last_name, COUNT(inspection.inspection_id) FROM inspection AS T1 INNER JOIN employee AS T2 ON T1.employee_id = T2.employee_id GROUP BY T2.employee_id, T2.first_name, T2.last_name ORDER BY COUNT(T1.inspection_id) DESC LIMIT 1) AS t",
            "ba": "The virtual table identifies the employee who has conducted the highest number of inspections. It retrieves the first name and last name of that employee by counting the number of inspections associated with each employee and ordering the results in descending order. The query uses subqueries to ensure that only the employee with the maximum count of inspections is selected."
        },
        {
            "sample_id": 6145,
            "vt": "SELECT MIN(inspection.inspection_date) FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE establishment.dba_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the earliest inspection date for a specific establishment based on its 'dba_name'. It joins the 'establishment' table with the 'inspection' table using the license number to filter the results accordingly."
        },
        {
            "sample_id": 6172,
            "vt": "SELECT CAST(COUNT(CASE WHEN establishment.risk_level = [placeholder-type:numeric] THEN establishment.license_no END) AS FLOAT) * [placeholder-type:numeric] / COUNT(establishment.risk_level) FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE inspection.results = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of facilities with a specific risk level that have passed inspections, multiplied by a specified factor. It does this by counting the number of facilities with the given risk level and dividing it by the total number of facilities, filtering the results based on the inspection outcomes."
        },
        {
            "sample_id": 6135,
            "vt": "SELECT employee.phone FROM inspection INNER JOIN employee AS T2 ON T1.employee_id = T2.employee_id WHERE inspection.inspection_id = [placeholder-type:numeric] AND employee.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the phone numbers of employees from the 'employee' table who conducted a specific inspection. The query joins the 'inspection' table with the 'employee' table to link the employee responsible for the inspection with their contact information. The placeholders represent the unique inspection identifier and the title of the employee."
        },
        {
            "sample_id": 6126,
            "vt": "SELECT COUNT(inspection.inspection_id) FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE establishment.facility_type = '[placeholder-type:string]' AND establishment.dba_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of inspections conducted for establishments of a specific facility type and DBA name. It joins the 'establishment' table with the 'inspection' table based on the license number, filtering results by the specified facility type and DBA name."
        },
        {
            "sample_id": 6155,
            "vt": "SELECT DISTINCT employee.first_name, employee.last_name FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN employee AS T3 ON T2.employee_id = T3.employee_id WHERE establishment.dba_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct first and last names of employees who conducted inspections at establishments with a specific 'doing business as' (DBA) name. The query joins the 'establishment' table with the 'inspection' table and the 'employee' table to filter results based on the DBA name provided as a placeholder."
        },
        {
            "sample_id": 6187,
            "vt": "SELECT SUM(violation.fine) FROM inspection_point INNER JOIN violation AS T2 ON T1.point_id = T2.point_id WHERE inspection_point.category = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total fines associated with inspection points of a specific category from the 'inspection_point' and 'violation' tables. It uses an INNER JOIN to link the two tables based on the point_id, and filters the results by the specified category using a placeholder."
        },
        {
            "sample_id": 6223,
            "vt": "SELECT COUNT(employee.employee_id) FROM employee WHERE employee.title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees from the 'employee' table who hold a specific job title. The placeholder in the WHERE clause represents the job title of the employees being queried."
        },
        {
            "sample_id": 6203,
            "vt": "SELECT SUM(employee.salary) FROM inspection INNER JOIN employee AS T2 ON T1.employee_id = T2.employee_id WHERE inspection.inspection_id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total salary of employees who conducted inspections within a specified range of inspection IDs. It joins the 'inspection' table with the 'employee' table to access employee salary information based on their unique IDs."
        },
        {
            "sample_id": 6227,
            "vt": "SELECT employee.first_name, employee.last_name FROM employee WHERE employee.salary = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of employees from the 'employee' table who have a specific salary. The placeholder in the WHERE clause represents the salary amount."
        },
        {
            "sample_id": 6152,
            "vt": "SELECT establishment.latitude, establishment.longitude FROM establishment INNER JOIN (SELECT license_no FROM inspection WHERE results = 'Fail' GROUP BY license_no ORDER BY COUNT(results) DESC LIMIT 1) AS T2 ON T1.license_no = T2.license_no",
            "ba": "The virtual table provides the latitude and longitude of the facility that has failed the most inspections. It does this by first identifying the license number of the facility with the highest count of failed inspections from the 'inspection' table, and then joining this result with the 'establishment' table to retrieve the corresponding geographical coordinates."
        },
        {
            "sample_id": 6193,
            "vt": "SELECT employee.last_name FROM employee INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE inspection.inspection_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the last names of employees from the 'employee' table who are responsible for a specific inspection identified by its unique inspection ID. The query uses an INNER JOIN to connect the 'employee' table with the 'inspection' table based on the employee's ID, ensuring that only those employees who conducted the specified inspection are selected."
        },
        {
            "sample_id": 6110,
            "vt": "SELECT employee.first_name, employee.last_name FROM employee WHERE employee.title = '[placeholder-type:string]' AND employee.supervisor = (SELECT employee.employee_id FROM employee WHERE first_name = 'Darlisha' AND last_name = 'Jacobs')",
            "ba": "The virtual table describes the first and last names of employees from the 'employee' table who hold a specific title and report to a supervisor named Darlisha Jacobs. The placeholder in the WHERE clause represents the title of the employee."
        },
        {
            "sample_id": 6243,
            "vt": "SELECT DISTINCT establishment.dba_name FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE STRFTIME('%Y-%m', inspection.inspection_date) = '[placeholder-type:string]' AND inspection.results = '[placeholder-type:string]' AND establishment.facility_type = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct dba names of establishments that have undergone inspections. It filters the results based on the inspection date, inspection results, and facility type, allowing users to focus on specific criteria."
        },
        {
            "sample_id": 6146,
            "vt": "SELECT employee.first_name, employee.last_name FROM (SELECT inspection.employee_id, COUNT(inspection.inspection_id) FROM inspection AS T1 WHERE STRFTIME('%Y-%m', T1.inspection_date) = '2016-03' GROUP BY T1.employee_id ORDER BY COUNT(T1.inspection_id) DESC LIMIT 1) AS t2 INNER JOIN employee AS T3 ON T2.employee_id = T3.employee_id",
            "ba": "The virtual table identifies the employee who conducted the most inspections in March 2016 by selecting their first and last names from the 'employee' table. It first counts the number of inspections per employee for that month, orders them in descending order, and limits the result to the top employee."
        },
        {
            "sample_id": 6211,
            "vt": "SELECT DISTINCT establishment.dba_name FROM employee INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id INNER JOIN establishment AS T3 ON T2.license_no = T3.license_no WHERE employee.first_name = '[placeholder-type:string]' AND employee.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct dba names of establishments that have been inspected by employees with a specific first and last name. The query joins the 'employee' table with the 'inspection' table to find inspections conducted by the specified employee, and then joins with the 'establishment' table to retrieve the dba names of those establishments."
        },
        {
            "sample_id": 6133,
            "vt": "SELECT COUNT(inspection.inspection_id) FROM inspection INNER JOIN employee AS T2 ON T1.employee_id = T2.employee_id WHERE employee.first_name = '[placeholder-type:string]' AND employee.last_name = '[placeholder-type:string]' AND inspection.results = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of inspections conducted by a specific employee based on their first and last names, and filters the results by the inspection outcome."
        },
        {
            "sample_id": 6238,
            "vt": "SELECT inspection.inspection_id FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN employee AS T3 ON T2.employee_id = T3.employee_id WHERE employee.first_name = '[placeholder-type:string]' AND employee.last_name = '[placeholder-type:string]' AND establishment.dba_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique inspection IDs from the 'inspection' table for inspections conducted by a specific employee at a facility with a given DBA name. It joins the 'establishment' and 'employee' tables to filter results based on the employee's first and last names and the DBA name of the establishment."
        },
        {
            "sample_id": 6150,
            "vt": "SELECT employee.salary FROM employee INNER JOIN (SELECT employee_id, COUNT(inspection_id) FROM inspection GROUP BY employee_id ORDER BY COUNT(inspection_id) DESC LIMIT 1) AS T2 ON T1.employee_id = T2.employee_id",
            "ba": "The virtual table retrieves the salary of the employee who has conducted the highest number of inspections. It does this by first creating a subquery that counts the number of inspections for each employee, ordering them in descending order, and limiting the results to the top employee. This subquery is then joined with the employee table to get the corresponding salary."
        },
        {
            "sample_id": 6143,
            "vt": "SELECT COUNT(violation.inspection_id) FROM violation WHERE violation.point_id = [placeholder-type:numeric] AND violation.fine = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of violations recorded in the 'violation' table for a specific inspection point and fine amount. The placeholders represent the unique identifier for the inspection point and the fine amount associated with the violation."
        },
        {
            "sample_id": 6186,
            "vt": "SELECT SUM(violation.fine) FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE establishment.dba_name = '[placeholder-type:string]' AND establishment.ward = [placeholder-type:numeric] AND inspection.results = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total fines from violations associated with inspections of establishments that match a specific dba name and ward number, while also filtering for a particular inspection result."
        },
        {
            "sample_id": 6200,
            "vt": "SELECT establishment.dba_name FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE inspection.inspection_type = '[placeholder-type:string]'",
            "ba": "The virtual table describes the dba names of establishments that have undergone inspections of a specific type. It retrieves data from the 'establishment' table and joins it with the 'inspection' table based on the license number. The placeholder in the WHERE clause represents the type of inspection being queried."
        },
        {
            "sample_id": 6229,
            "vt": "SELECT DISTINCT establishment.dba_name FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE establishment.facility_type = '[placeholder-type:string]' AND violation.fine = [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct dba names of establishments that have been inspected and have violations with specific fines. It filters the results based on the facility type and the fine amount associated with the violations."
        },
        {
            "sample_id": 6116,
            "vt": "SELECT COUNT(DISTINCT T1.license_no) FROM inspection INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE STRFTIME('%Y', inspection.inspection_date) = '[placeholder-type:string]' AND establishment.ward = [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of facilities that have undergone inspections in a specific year and ward. It joins the 'inspection' table with the 'establishment' table based on the license number, filtering the results by the year of the inspection date and the ward number."
        },
        {
            "sample_id": 6235,
            "vt": "SELECT DISTINCT inspection.inspection_type FROM employee INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE employee.first_name = '[placeholder-type:string]' AND employee.last_name = '[placeholder-type:string]' AND inspection.inspection_date = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of inspection types conducted by a specific employee, identified by their first and last names, on a particular inspection date. It combines data from the 'employee' and 'inspection' tables, ensuring that only unique inspection types are returned based on the specified criteria."
        },
        {
            "sample_id": 6213,
            "vt": "SELECT DISTINCT establishment.risk_level FROM employee INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id INNER JOIN establishment AS T3 ON T2.license_no = T3.license_no WHERE employee.first_name = '[placeholder-type:string]' AND employee.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the distinct risk levels of establishments associated with a specific employee identified by their first and last names. It joins the 'employee' table with the 'inspection' table to find inspections conducted by that employee, and then further joins with the 'establishment' table to access the risk level of those establishments."
        },
        {
            "sample_id": 6122,
            "vt": "SELECT COUNT(DISTINCT T2.license_no) FROM inspection INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE STRFTIME('%Y', inspection.inspection_date) = '[placeholder-type:string]' AND establishment.risk_level = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of distinct facilities (identified by their license number) that have undergone inspections in a specific year and have a certain risk level. The placeholders represent the year of inspection and the risk level of the establishments."
        },
        {
            "sample_id": 6240,
            "vt": "SELECT violation.inspection_id FROM inspection_point INNER JOIN violation AS T2 ON T1.point_id = T2.point_id WHERE inspection_point.category = '[placeholder-type:string]' AND violation.inspector_comment = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique inspection IDs from the 'inspection_point' and 'violation' tables, where the inspection point category matches a specified category and the inspector's comment matches a specified comment."
        },
        {
            "sample_id": 6169,
            "vt": "SELECT violation.inspection_id FROM inspection_point INNER JOIN violation AS T2 ON T1.point_id = T2.point_id WHERE violation.fine = [placeholder-type:numeric] AND inspection_point.point_level = '[placeholder-type:string]' AND violation.inspector_comment = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique inspection IDs from the 'inspection_point' and 'violation' tables, filtering based on specific criteria related to fines, point levels, and inspector comments. The placeholders allow users to specify the fine amount, the level of the inspection point, and any comments made by the inspector."
        },
        {
            "sample_id": 6210,
            "vt": "SELECT DISTINCT establishment.dba_name FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE STRFTIME('%Y', inspection.inspection_date) = '[placeholder-type:string]' AND inspection.results = '[placeholder-type:string]' AND establishment.facility_type = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct dba names of establishments that have undergone inspections in a specific year, with a particular result and facility type. The placeholders represent the year of inspection, the result of the inspection, and the type of facility."
        },
        {
            "sample_id": 6219,
            "vt": "SELECT employee.address, employee.city, employee.state FROM employee WHERE employee.first_name = '[placeholder-type:string]' AND employee.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the physical address details of employees from the 'employee' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the employees being queried."
        },
        {
            "sample_id": 6182,
            "vt": "SELECT DISTINCT inspection_point.category, violation.fine FROM inspection INNER JOIN employee AS T2 ON T1.employee_id = T2.employee_id INNER JOIN violation AS T3 ON T1.inspection_id = T3.inspection_id INNER JOIN inspection_point AS T4 ON T3.point_id = T4.point_id WHERE employee.first_name = '[placeholder-type:string]' AND employee.last_name = '[placeholder-type:string]' AND STRFTIME('%Y-%m', inspection.inspection_date) = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct categories of inspection points and their associated fines for violations conducted by a specific employee during a specified month and year. The placeholders in the WHERE clause represent the employee's first name, last name, and the year-month of the inspection date."
        },
        {
            "sample_id": 6208,
            "vt": "SELECT DISTINCT establishment.dba_name FROM employee INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id INNER JOIN establishment AS T3 ON T2.license_no = T3.license_no WHERE employee.first_name = '[placeholder-type:string]' AND employee.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct dba names of establishments associated with employees based on their first and last names. It joins the 'employee' table with the 'inspection' table to find inspections conducted by the specified employee, and then joins with the 'establishment' table to get the corresponding dba names."
        },
        {
            "sample_id": 6184,
            "vt": "SELECT inspection.inspection_type, inspection.results FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE establishment.facility_type = '[placeholder-type:string]'",
            "ba": "The virtual table describes the types and results of inspections conducted on establishments filtered by their facility type. The placeholder in the WHERE clause represents the specific facility type being queried."
        },
        {
            "sample_id": 6212,
            "vt": "SELECT COUNT(DISTINCT T1.license_no) FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE STRFTIME('%Y-%m', inspection.inspection_date) = '[placeholder-type:string]' AND inspection.results = '[placeholder-type:string]' AND establishment.facility_type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of facilities from the 'establishment' table that have undergone inspections. It filters the results based on the month and year of the inspection date, the outcome of the inspection, and the type of facility. The placeholders represent the specific month and year, the inspection result, and the facility type."
        },
        {
            "sample_id": 6113,
            "vt": "SELECT DISTINCT establishment.dba_name FROM employee INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id INNER JOIN establishment AS T3 ON T2.license_no = T3.license_no WHERE employee.first_name = '[placeholder-type:string]' AND employee.last_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of distinct 'doing business as' (DBA) names of establishments that have been inspected by employees with a specific first and last name. It combines data from the 'employee', 'inspection', and 'establishment' tables to achieve this."
        },
        {
            "sample_id": 6156,
            "vt": "SELECT T.first_name, T.last_name FROM (SELECT employee.first_name, employee.last_name, SUM(violation.fine) FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id GROUP BY T1.first_name, T1.last_name ORDER BY SUM(T3.fine) DESC LIMIT 1) AS t",
            "ba": "The virtual table retrieves the first and last names of the employee who has the highest total fines from violations associated with their inspections. It does this by joining the 'employee', 'inspection', and 'violation' tables, summing the fines for each employee, and ordering the results to find the employee with the maximum fines."
        },
        {
            "sample_id": 6199,
            "vt": "SELECT DISTINCT inspection.inspection_type FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE establishment.dba_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of inspection types associated with establishments based on their 'doing business as' (DBA) name. It combines data from the 'establishment' and 'inspection' tables, filtering the results to show only those inspections related to a specific DBA name provided by the user."
        },
        {
            "sample_id": 6117,
            "vt": "SELECT DISTINCT employee.first_name, employee.last_name FROM employee INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id INNER JOIN establishment AS T3 ON T2.license_no = T3.license_no WHERE establishment.dba_name = '[placeholder-type:string]' AND employee.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct first and last names of employees from the 'employee' table who are associated with inspections of establishments that have a specific 'doing business as' (DBA) name and hold a particular job title. The placeholders in the WHERE clause represent the DBA name of the establishment and the title of the employee."
        },
        {
            "sample_id": 6176,
            "vt": "SELECT CAST(COUNT(CASE WHEN violation.fine = [placeholder-type:numeric] THEN violation.inspection_id END) AS FLOAT) * [placeholder-type:numeric] / COUNT(violation.inspection_id) FROM violation",
            "ba": "The virtual table calculates the average fine amount for violations recorded in inspections. It counts the number of inspections that have a specific fine amount and multiplies it by a placeholder for a numeric value, then divides this by the total number of violations to get the average fine. The placeholders represent the specific fine amount to filter and a multiplier for the calculation."
        },
        {
            "sample_id": 6128,
            "vt": "SELECT COUNT(inspection.license_no) FROM establishment INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE inspection.inspection_date = '[placeholder-type:string]' AND establishment.facility_type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of inspections conducted for establishments of a specific facility type on a given inspection date. It joins the 'establishment' table with the 'inspection' table based on the license number, filtering results by the inspection date and facility type."
        },
        {
            "sample_id": 6147,
            "vt": "SELECT DISTINCT establishment.dba_name FROM inspection INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE STRFTIME('%Y-%m', inspection.inspection_date) = '[placeholder-type:string]' AND inspection.results = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct dba names of establishments that have undergone inspections. It filters the results based on a specific month and year, as well as the inspection results, allowing users to see which establishments had inspections during that time frame and their corresponding outcomes."
        },
        {
            "sample_id": 6121,
            "vt": "SELECT inspection.followup_to FROM inspection INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE establishment.dba_name = '[placeholder-type:string]' AND inspection.results = '[placeholder-type:string]' AND inspection.inspection_date = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the follow-up inspection IDs from the 'inspection' table, joining it with the 'establishment' table to filter results based on the establishment's DBA name, the inspection results, and the date of the inspection. The placeholders represent the DBA name of the establishment, the results of the inspection, and the date of the inspection respectively."
        },
        {
            "sample_id": 6225,
            "vt": "SELECT COUNT(employee.employee_id) FROM employee WHERE employee.state = '[placeholder-type:string]' AND employee.city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of employees from the 'employee' table who are located in a specific state and city. The placeholders in the WHERE clause represent the state and city names."
        },
        {
            "sample_id": 6144,
            "vt": "SELECT COUNT(employee.employee_id) FROM employee WHERE employee.supervisor = (SELECT employee.employee_id FROM employee WHERE first_name = 'Gregory' AND last_name = 'Cardenas')",
            "ba": "The virtual table counts the number of employees who report to a specific supervisor identified by their first and last name. It retrieves the supervisor's employee ID by filtering the 'employee' table for the given name, and then counts how many employees have that supervisor ID."
        },
        {
            "sample_id": 6188,
            "vt": "SELECT establishment.dba_name, establishment.longitude, establishment.latitude FROM inspection INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE inspection.inspection_date = '[placeholder-type:string]' AND inspection.results = '[placeholder-type:string]'",
            "ba": "The virtual table describes the dba name, longitude, and latitude of establishments that have undergone inspections on a specific date with certain results. The placeholders in the WHERE clause represent the inspection date and the results of the inspection."
        },
        {
            "sample_id": 6195,
            "vt": "SELECT DISTINCT employee.address FROM employee INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE inspection.inspection_date = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct addresses of employees from the 'employee' table who conducted inspections on a specific date. It uses an inner join to connect the 'employee' and 'inspection' tables based on the employee's ID, ensuring that only those employees who performed inspections on the given date are included in the results."
        },
        {
            "sample_id": 6119,
            "vt": "SELECT employee.first_name, employee.last_name FROM employee INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id INNER JOIN establishment AS T3 ON T2.license_no = T3.license_no WHERE inspection.inspection_date = '[placeholder-type:string]' AND establishment.dba_name = '[placeholder-type:string]' AND employee.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of employees from the 'employee' table who conducted inspections at a specific establishment on a given date. The query filters results based on the inspection date, the establishment's DBA name, and the employee's title."
        }
    ],
    "hockey": [
        {
            "sample_id": 7640,
            "vt": "SELECT CAST(coaches.w AS FLOAT) / coaches.g, master.firstname, master.lastname, coaches.year FROM master INNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID INNER JOIN (SELECT coachID FROM Coaches ORDER BY CAST(w AS FLOAT) / g DESC LIMIT 1) AS T3 ON T2.coachID = T3.coachID",
            "ba": "The virtual table calculates the winning percentage of coaches by dividing the number of wins by the number of games coached. It retrieves the first and last names of the coach with the highest winning percentage along with the year they coached."
        },
        {
            "sample_id": 7749,
            "vt": "SELECT DISTINCT teams.name FROM teamshalf INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE teamshalf.half = [placeholder-type:numeric] AND teamshalf.rank = [placeholder-type:numeric] AND teamshalf.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct names of teams from the 'teamshalf' table that have a specific ranking in a given half of the season. It joins with the 'Teams' table to ensure that the team IDs and years match. The placeholders represent the half of the season, the rank, and a range of years."
        },
        {
            "sample_id": 7614,
            "vt": "SELECT master.firstname, master.lastname FROM master WHERE master.hofid IS NULL",
            "ba": "The virtual table describes the first and last names of players from the 'master' table who are not inducted into the Hall of Fame. The condition in the WHERE clause checks for players with a null value in the 'hofid' column, indicating they have not received this honor."
        },
        {
            "sample_id": 7718,
            "vt": "SELECT goalies.playerid FROM goalies INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE goalies.year = '[placeholder-type:string]' AND master.weight > [placeholder-type:numeric] ORDER BY goalies.ga LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the player IDs of goalies from the 'goalies' table who played in a specific year and have a weight greater than a specified value. The results are ordered by the number of goals against (ga) and limited to a certain number of entries."
        },
        {
            "sample_id": 7663,
            "vt": "SELECT COUNT(master.coachid) FROM master INNER JOIN AwardsCoaches AS T2 ON T1.coachID = T2.coachID WHERE NOT master.deathyear IS NULL AND awardscoaches.year > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of coaches from the 'master' table who have received awards, ensuring that only those who are deceased are included. The query filters the results to include only those awards that were given after a specified year."
        },
        {
            "sample_id": 7758,
            "vt": "SELECT teams.name FROM teamssc INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE teamssc.year = '[placeholder-type:string]' AND teamssc.w > teamssc.l",
            "ba": "The virtual table lists the names of teams from the 'teamssc' table that have more wins than losses in a specific year. It joins the 'teamssc' table with the 'Teams' table to ensure that the team IDs and years match, filtering for teams that have a winning record."
        },
        {
            "sample_id": 7635,
            "vt": "SELECT DISTINCT master.firstname, master.lastname, teams.name FROM goalies INNER JOIN Master AS T2 ON T2.playerID = T1.playerID INNER JOIN Teams AS T3 ON T1.lgID = T3.lgID WHERE master.birthcountry = '[placeholder-type:string]' AND NOT master.deathyear IS NULL AND master.pos = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct first and last names of goalies along with their team names from the 'goalies' and 'teams' tables. It filters the results based on the birth country of the players and ensures that only deceased players are included, while also specifying the position of the players."
        },
        {
            "sample_id": 7677,
            "vt": "SELECT master.birthcountry FROM master INNER JOIN AwardsPlayers AS T2 ON T1.playerID = T2.playerID GROUP BY master.birthcountry ORDER BY COUNT(awardsplayers.award) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the birth countries of players from the 'master' table who have received awards, grouping the results by country and ordering them by the count of awards received. The placeholder in the LIMIT clause allows for specifying the maximum number of countries to return."
        },
        {
            "sample_id": 7781,
            "vt": "SELECT CAST(SUM(teamssc.pim) AS FLOAT) / COUNT(teamssc.pim) FROM teams INNER JOIN TeamsSC AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE teams.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average penalty minutes (PIM) for a specific team by summing the total penalty minutes from the 'teamssc' table and dividing it by the count of penalty minutes recorded for that team. The query joins the 'teams' table with the 'teamssc' table based on the team ID and year, filtering for a specific team name using a placeholder."
        },
        {
            "sample_id": 7788,
            "vt": "SELECT COUNT(master.playerid) FROM master WHERE master.lastname = '[placeholder-type:string]' AND master.coachid IS NULL",
            "ba": "The virtual table counts the number of players from the 'master' table who have a specific last name and are not identified as coaches. The placeholder in the WHERE clause represents the last name of the player being queried."
        },
        {
            "sample_id": 7775,
            "vt": "SELECT DISTINCT teams.name FROM teamvsteam INNER JOIN Teams AS T2 ON T1.year = T2.year AND T1.oppID = T2.tmID INNER JOIN Teams AS T3 ON T1.year = T3.year AND T1.tmID = T3.tmID WHERE teams.name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct names of teams that have played against a specified opponent in a given year. It utilizes the 'teamvsteam' table to identify matchups and joins with the 'Teams' table to retrieve the names of both the specified team and its opponent."
        },
        {
            "sample_id": 7747,
            "vt": "SELECT teams.rank, teams.year, teams.name FROM scoring INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE scoring.sha >= [placeholder-type:numeric] ORDER BY scoring.a LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the rank, year, and name of teams from the 'Teams' table that have players with a specified number of shorthanded assists. The query joins the 'scoring' table with the 'Teams' table based on team ID and year, filtering results where the shorthanded assists are greater than or equal to a specified numeric value. The results are ordered by assists and limited to a specified number of entries."
        },
        {
            "sample_id": 7811,
            "vt": "SELECT COUNT(scoring.gp) FROM master INNER JOIN Scoring AS T2 ON T1.playerID = T2.playerID WHERE master.birthcountry = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of games played by players from a specific birth country. It joins the 'master' table, which contains player identification and birth information, with the 'scoring' table that records game participation. The placeholder in the WHERE clause represents the birth country of the players."
        },
        {
            "sample_id": 7724,
            "vt": "SELECT CAST(SUM(teams.ppg) AS FLOAT) * [placeholder-type:numeric] / SUM(teams.ppc) FROM teams GROUP BY teams.tmid ORDER BY SUM(teams.l) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the power play percentage for each team by summing the power play goals (ppg) and dividing it by the total power play chances (ppc). The result is then multiplied by a placeholder numeric value for scaling purposes. The results are grouped by team ID (tmid) and ordered by the total number of losses (l), limiting the output to a specified number of results."
        },
        {
            "sample_id": 7705,
            "vt": "SELECT scoringsc.lgid FROM scoringsc WHERE scoringsc.playerid = '[placeholder-type:string]' AND scoringsc.year = [placeholder-type:numeric]",
            "ba": "The virtual table provides the league ID of a specific player for a given year from the 'scoringsc' table. The placeholders represent the player's ID and the year of interest."
        },
        {
            "sample_id": 7729,
            "vt": "SELECT master.pos FROM master WHERE NOT master.birthyear IS NULL ORDER BY master.birthyear, master.birthmon, master.birthday LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the positions of players from the 'master' table who have a recorded birth year. The results are ordered by the player's birth date, including year, month, and day, and limited to a specified number of entries."
        },
        {
            "sample_id": 7740,
            "vt": "SELECT master.namegiven FROM scoring INNER JOIN Master AS T2 ON T1.playerID = T2.playerID AND T1.PIM BETWEEN 200 AND 250 AND T1.year BETWEEN 2003 AND 2005 ORDER BY scoring.gp LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the given names of players from the 'master' table who have accumulated penalty minutes between 200 and 250 during the years 2003 to 2005. The results are ordered by the number of games played, and a limit is applied to the number of records returned."
        },
        {
            "sample_id": 7813,
            "vt": "SELECT SUM(scoring.g) FROM teams INNER JOIN Scoring AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE teams.divid = '[placeholder-type:string]' AND teams.tmid = '[placeholder-type:string]' AND teams.year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total number of goals scored by a specific team in a given year and division. It combines data from the 'teams' table and the 'scoring' table, filtering results based on the team's division, team ID, and year."
        },
        {
            "sample_id": 7617,
            "vt": "SELECT master.firstname, master.lastname FROM master INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE goalies.year >= [placeholder-type:numeric] AND goalies.year <= [placeholder-type:numeric] GROUP BY goalies.playerid HAVING COUNT(DISTINCT T2.tmID) > [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of players who have played as goalies in a specified range of years, grouped by their player ID. The query filters for goalies who have played for more than a certain number of teams during that time period."
        },
        {
            "sample_id": 7772,
            "vt": "SELECT DISTINCT master.namenick FROM coaches INNER JOIN Teams AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID INNER JOIN Master AS T3 ON T1.coachID = T3.coachID WHERE teams.name = '[placeholder-type:string]' AND master.birthcountry = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct nicknames of coaches from the 'master' table who have coached a specific team in a given year and are from a specified birth country. The query joins the 'coaches' table with the 'teams' table to filter by team name and year, and then joins with the 'master' table to access the nickname and birth country of the coaches."
        },
        {
            "sample_id": 7703,
            "vt": "SELECT scoringsc.g FROM scoringsc WHERE scoringsc.playerid = '[placeholder-type:string]' AND scoringsc.year = [placeholder-type:numeric]",
            "ba": "The virtual table provides the goals scored by a specific player during a particular year from the 'scoringsc' table. The placeholders represent the player's ID and the year of interest."
        },
        {
            "sample_id": 7806,
            "vt": "SELECT DISTINCT master.firstname FROM master INNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID WHERE coaches.year > [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct first names of individuals from the 'master' table who have served as coaches in a specific year. The query joins the 'master' table with the 'coaches' table to filter out those who were coaching in years greater than a specified year, represented by a numeric placeholder."
        },
        {
            "sample_id": 7753,
            "vt": "SELECT SUM(teams.pts), teams.year FROM teams GROUP BY teams.year, teams.tmid ORDER BY SUM(teams.pts) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total points earned by teams in each year from the 'teams' table. It groups the results by year and team ID, allowing for an aggregated view of team performance over time. The placeholder in the LIMIT clause indicates the maximum number of records to return, which can be adjusted as needed."
        },
        {
            "sample_id": 7750,
            "vt": "SELECT master.namegiven, master.lastname, master.birthyear, master.birthmon, master.birthday, teams.tmid FROM scoring INNER JOIN Master AS T2 ON T2.playerID = T1.playerID INNER JOIN Teams AS T3 ON T3.tmID = T1.tmID WHERE (master.firstnhl - master.birthyear) BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND teams.g < [placeholder-type:numeric]",
            "ba": "The virtual table describes players' names, birth dates, and team IDs from the 'master' and 'teams' tables, filtered by the age of players at their first NHL season and the number of games played by their teams. The placeholders represent the age range and maximum games played criteria."
        },
        {
            "sample_id": 7697,
            "vt": "SELECT teams.name FROM goalies INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID WHERE goalies.year = [placeholder-type:numeric] GROUP BY teams.name ORDER BY SUM(goalies.posteng) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of teams from the 'Teams' table that have goalies who played in a specific year. The query joins the 'goalies' table with the 'Teams' table based on the team ID, filtering the results by the specified year. The results are grouped by team name and ordered by the total number of empty net goals scored by the goalies, with a limit on the number of teams returned."
        },
        {
            "sample_id": 7739,
            "vt": "SELECT DISTINCT master.firstnhl - scoring.year, master.namegiven, master.firstname, master.lastname FROM scoring INNER JOIN Teams AS T2 ON T2.tmID = T1.tmID INNER JOIN Master AS T3 ON T1.playerID = T3.playerID GROUP BY master.firstname, master.lastname, master.namegiven, master.firstnhl - scoring.year, master.firstname, master.lastname ORDER BY SUM(scoring.\"+/-\") LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of players along with their first NHL season year, given name, first name, and last name. It retrieves this information by joining the 'scoring' table with the 'teams' table to associate players with their respective teams, and then with the 'master' table to access player details. The results are grouped by the player's names and first NHL season year, and ordered by the sum of their plus/minus statistics, limiting the output to a specified number of entries."
        },
        {
            "sample_id": 7726,
            "vt": "SELECT DISTINCT master.birthcountry, master.birthyear FROM master GROUP BY master.birthcountry, master.birthyear ORDER BY COUNT(master.birthcountry) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of birth countries and birth years of players from the 'master' table. It groups the results by birth country and year, allowing for an ordered count of occurrences, and limits the output to a specified number of results."
        },
        {
            "sample_id": 7665,
            "vt": "SELECT COUNT(DISTINCT T1.coachID) FROM master INNER JOIN HOF AS T2 ON T1.hofID = T2.hofID WHERE master.weight > [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of coaches from the 'master' table who have been inducted into the Hall of Fame (HOF) and have a weight greater than a specified value. The join between 'master' and 'hof' is based on the hall of fame ID, ensuring that only those coaches who are recognized in the Hall of Fame are included in the count."
        },
        {
            "sample_id": 7658,
            "vt": "SELECT DISTINCT awardscoaches.award FROM master INNER JOIN AwardsCoaches AS T2 ON T1.coachID = T2.coachID WHERE master.birthcountry = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct awards received by coaches from the 'awardscoaches' table, filtered by the birth country of the individuals in the 'master' table. The placeholder in the WHERE clause represents the specific birth country being queried."
        },
        {
            "sample_id": 7783,
            "vt": "SELECT SUM(CAST(teamssc.w AS FLOAT) / teamssc.g) / SUM(teamssc.g + teamssc.w) FROM teams INNER JOIN TeamsSC AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE teams.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average winning percentage of a specific team over a given year by summing the wins and games played from the 'teamssc' table. It uses an inner join between the 'teams' and 'teamssc' tables to filter results based on the team's name and year. The result is a ratio of total wins to total games played, providing insight into the team's performance."
        },
        {
            "sample_id": 7807,
            "vt": "SELECT master.height, master.weight FROM master INNER JOIN AwardsCoaches AS T2 ON T1.coachID = T2.coachID WHERE awardscoaches.year = '[placeholder-type:string]'",
            "ba": "The virtual table describes the height and weight of coaches from the 'master' table who have received awards in a specific year. The join with the 'awardscoaches' table allows filtering based on the year of the award, represented by a placeholder."
        },
        {
            "sample_id": 7735,
            "vt": "SELECT SUM(scoring.a), master.firstname, master.lastname FROM scoring INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE scoring.lgid = '[placeholder-type:string]' GROUP BY master.firstname, master.lastname ORDER BY SUM(scoring.a) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total assists made by players in a specific league, identified by the league ID. It retrieves the first and last names of the players from the 'master' table, joining it with the 'scoring' table to calculate the sum of assists for each player. The results are grouped by player names and ordered by the total assists, with a limit on the number of results returned."
        },
        {
            "sample_id": 7619,
            "vt": "SELECT DISTINCT master.namegiven, master.birthcountry FROM master INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID GROUP BY master.namegiven, master.birthcountry HAVING SUM(goalies.min) > [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of unique names and birth countries of goalies from the 'master' table, filtered by those who have played more than a specified number of minutes in their games. The query joins the 'master' table with the 'goalies' table to access the relevant statistics and groups the results by name and country, ensuring that only distinct entries are returned."
        },
        {
            "sample_id": 7692,
            "vt": "SELECT master.firstname, master.lastname FROM master INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE goalies.stint = [placeholder-type:numeric] ORDER BY master.weight LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of players who are goalies, filtered by their stint in the season. The results are ordered by the players' weight and limited to a specified number of entries."
        },
        {
            "sample_id": 7761,
            "vt": "SELECT teamssc.pim FROM teamssc INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE teamssc.year = '[placeholder-type:string]' AND teams.rank = [placeholder-type:numeric]",
            "ba": "The virtual table provides the penalty minutes (pim) for teams from the 'teamssc' table, filtered by a specific year and the final standing rank of the teams. The placeholders allow users to specify the year and rank they are interested in."
        },
        {
            "sample_id": 7671,
            "vt": "SELECT COUNT(DISTINCT T1.playerID) FROM master INNER JOIN AwardsPlayers AS T2 ON T1.playerID = T2.playerID WHERE master.deathstate = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of players from the 'master' table who have received awards from the 'awardsplayers' table, filtered by the state of death of the players."
        },
        {
            "sample_id": 7652,
            "vt": "SELECT DISTINCT COUNT(goalies.tmid) FROM goalies WHERE goalies.postw = goalies.postl",
            "ba": "The virtual table counts the number of distinct teams from the 'goalies' table where the number of postseason wins equals the number of postseason losses. This indicates teams that have a balanced postseason performance in terms of wins and losses."
        },
        {
            "sample_id": 7725,
            "vt": "SELECT CAST(COUNT(hof.name) AS FLOAT) / [placeholder-type:numeric] FROM hof WHERE hof.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND hof.category = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of Hall of Fame inductees per year for a specified category over a given range of years. The placeholders represent the range of years and the specific category of induction."
        },
        {
            "sample_id": 7802,
            "vt": "SELECT DISTINCT master.playerid FROM master GROUP BY master.playerid HAVING AVG(master.height) = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves unique player IDs from the 'master' table, grouping them by player ID and filtering to include only those players whose average height matches a specified value. The placeholder in the HAVING clause represents the average height to be compared against."
        },
        {
            "sample_id": 7643,
            "vt": "SELECT master.firstname, master.lastname, goalies.year, CAST(goalies.w AS FLOAT) / goalies.gp FROM master INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE master.birthyear = [placeholder-type:numeric] AND master.shootcatch IS NULL",
            "ba": "The virtual table provides a list of goalies along with their first and last names, the year they played, and their winning percentage calculated as the ratio of wins to games played. The data is filtered to include only those goalies who were born in a specific year and have no specified shooting or catching hand."
        },
        {
            "sample_id": 7759,
            "vt": "SELECT teams.name FROM teamssc INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE teamssc.year = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of teams from the 'teamssc' table for a specific year. It joins the 'teamssc' table with the 'Teams' table to ensure that the team names correspond to the correct year, using a placeholder for the year value."
        },
        {
            "sample_id": 7805,
            "vt": "SELECT DISTINCT master.playerid FROM master WHERE NOT master.deathyear IS NULL AND NOT master.playerid IS NULL",
            "ba": "The virtual table lists unique player IDs from the 'master' table for players who have a recorded death year, ensuring that only those who are no longer living are included in the results."
        },
        {
            "sample_id": 7784,
            "vt": "SELECT hof.name FROM hof WHERE hof.category IN ('[placeholder-type:string]', '[placeholder-type:string]') ORDER BY hof.year LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of individuals from the 'hof' table who belong to specific categories of the Hall of Fame. The query filters the results based on the provided categories and orders them by the year of induction, limiting the number of results returned."
        },
        {
            "sample_id": 7645,
            "vt": "SELECT master.firstname, master.lastname FROM master INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE NOT master.deathyear IS NULL GROUP BY master.playerid HAVING CAST(SUM(goalies.min) AS FLOAT) / SUM(goalies.gp) > [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of players from the 'master' table who have played as goalies and have a recorded death year. It filters the results to include only those players whose average minutes played per game exceeds a specified numeric threshold. The placeholder in the HAVING clause represents this threshold value."
        },
        {
            "sample_id": 7736,
            "vt": "SELECT SUM(scoring.a), master.firstname, master.lastname FROM scoring INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE scoring.lgid = '[placeholder-type:string]' GROUP BY master.firstname, master.lastname ORDER BY SUM(scoring.a) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total assists made by players in a specific league, grouped by their first and last names. The query joins the 'scoring' table with the 'master' table to retrieve player names and calculates the sum of assists for each player. The results are ordered by the total assists in descending order, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 7814,
            "vt": "SELECT SUM(teams.l), SUM(scoring.a) FROM teams INNER JOIN Scoring AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE teams.tmid = '[placeholder-type:string]' AND teams.year = [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total number of losses from the 'teams' table and the total number of assists from the 'scoring' table for a specific team in a given year. The placeholders represent the team ID and the year respectively."
        },
        {
            "sample_id": 7618,
            "vt": "SELECT AVG(master.weight) FROM master WHERE master.height > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average weight of players from the 'master' table who have a height greater than a specified value. The placeholder in the WHERE clause represents the height threshold."
        },
        {
            "sample_id": 7683,
            "vt": "SELECT goalies.tmid FROM goalies WHERE goalies.playerid = '[placeholder-type:string]' AND goalies.year = [placeholder-type:numeric]",
            "ba": "The virtual table lists the team IDs of goalies from the 'goalies' table based on a specific player's ID and the year of play. The placeholders represent the player's unique identifier and the year for which the data is being queried."
        },
        {
            "sample_id": 7766,
            "vt": "SELECT COUNT(DISTINCT hofID) FROM coaches INNER JOIN Teams AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID INNER JOIN Master AS T3 ON T1.coachID = T3.coachID WHERE teams.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct hall of fame IDs of coaches who have coached a specific team in a given year. It joins the 'coaches' table with the 'teams' table to match the year and team ID, and then further joins with the 'master' table to link the coach's ID. The placeholder in the WHERE clause represents the name of the team being queried."
        },
        {
            "sample_id": 7681,
            "vt": "SELECT CAST(COUNT(CASE WHEN master.birthcountry = '[placeholder-type:string]' THEN master.playerid ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(master.playerid) FROM master INNER JOIN HOF AS T2 ON T1.hofID = T2.hofID",
            "ba": "The virtual table calculates the percentage of players from a specific birth country who are inducted into the Hall of Fame. It counts the number of players from the specified country and divides it by the total number of players, then multiplies by a placeholder for scaling the result."
        },
        {
            "sample_id": 7631,
            "vt": "SELECT master.firstname, master.lastname, master.pos FROM master WHERE master.deathyear IS NULL AND master.pos LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names, along with the position of players from the 'master' table who are still alive and play a specific position. The placeholder in the LIKE clause represents the position of the player."
        },
        {
            "sample_id": 7738,
            "vt": "SELECT teams.name FROM seriespost INNER JOIN Teams AS T2 ON T1.year = T2.year AND tmIDLoser = tmID WHERE seriespost.note = '[placeholder-type:string]' AND teams.year = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of teams that lost in a specific series during a given year. It retrieves this information by joining the 'seriespost' table with the 'teams' table based on the year and the team ID of the losing team. The placeholders represent the series note and the year for which the data is being queried."
        },
        {
            "sample_id": 7816,
            "vt": "SELECT (SELECT DISTINCT playerID, tmID FROM Scoring WHERE year BETWEEN 1925 AND 1936).playerid, (SELECT DISTINCT playerID, tmID FROM Scoring WHERE year BETWEEN 1925 AND 1936).tmid FROM (SELECT master.playerid FROM Master WHERE NOT height IS NULL ORDER BY height ASC LIMIT 1) AS t1 INNER JOIN (SELECT DISTINCT playerID, tmID FROM Scoring WHERE year BETWEEN 1925 AND 1936) AS T2 ON T1.playerID = T2.playerID",
            "ba": "The virtual table retrieves the player ID and team ID of the shortest player from the 'Master' table who played in the NHL between the years 1925 and 1936. It first selects distinct player IDs and team IDs from the 'Scoring' table for the specified years, then finds the shortest player by height from the 'Master' table, and finally joins these two results to get the relevant player and team information."
        },
        {
            "sample_id": 7625,
            "vt": "SELECT DISTINCT master.firstname, master.lastname, teams.name FROM master INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID INNER JOIN Teams AS T3 ON T2.tmID = T3.tmID WHERE goalies.year = [placeholder-type:numeric] AND master.height < [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of distinct first and last names of players from the 'master' table who are goalies, along with their team names from the 'teams' table. The results are filtered based on a specific year and a height condition, allowing users to find goalies who meet these criteria."
        },
        {
            "sample_id": 7629,
            "vt": "SELECT master.firstname, master.lastname FROM master WHERE master.birthcountry <> master.deathcountry ORDER BY master.birthyear",
            "ba": "The virtual table describes the first and last names of individuals from the 'master' table who were born in a different country than where they died. The results are ordered by the year of birth."
        },
        {
            "sample_id": 7656,
            "vt": "SELECT DISTINCT master.namenick FROM master INNER JOIN HOF AS T2 ON T1.hofID = T2.hofID WHERE hof.year = [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique nicknames of players from the 'master' table who have been inducted into the Hall of Fame in a specific year. The query joins the 'master' table with the 'hof' table to filter the results based on the year of induction."
        },
        {
            "sample_id": 7690,
            "vt": "SELECT master.pos FROM master INNER JOIN AwardsPlayers AS T2 ON T1.playerID = T2.playerID WHERE master.firstname = '[placeholder-type:string]' AND master.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the positions of players from the 'master' table who have received awards, filtered by their first and last names. The placeholders in the WHERE clause represent the player's first and last names."
        },
        {
            "sample_id": 7630,
            "vt": "SELECT master.namegiven, master.firstnhl, master.firstwha FROM master WHERE NOT master.firstnhl IS NULL AND NOT master.firstwha IS NULL",
            "ba": "The virtual table describes the given names and the first seasons in both the NHL and WHA for players from the 'master' table who have valid entries for both leagues."
        },
        {
            "sample_id": 7624,
            "vt": "SELECT master.firstname, master.lastname, goalies.year FROM master INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE NOT CAST(goalies.ga AS FLOAT) / goalies.sa IS NULL ORDER BY CAST(goalies.ga AS FLOAT) / goalies.sa LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of first and last names of players from the 'master' table along with the year they played as goalies from the 'goalies' table. It filters out any records where the goals against (ga) divided by shots against (sa) is not null, indicating valid data for calculating the goals against average. The results are ordered by this average and limited to a specified number of entries."
        },
        {
            "sample_id": 7815,
            "vt": "SELECT SUM(master.weight) FROM master INNER JOIN Scoring AS T2 ON T1.playerID = T2.playerID WHERE scoring.year = [placeholder-type:numeric] AND scoring.tmid = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total weight of players from the 'master' table who have participated in scoring during a specific year and for a specific team. The placeholders represent the year and team ID for which the total weight is being calculated."
        },
        {
            "sample_id": 7661,
            "vt": "SELECT awardscoaches.award FROM master INNER JOIN AwardsCoaches AS T2 ON T1.coachID = T2.coachID WHERE master.birthyear = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the awards received by coaches from the 'awardscoaches' table, specifically for those coaches who were born in a certain year. The query joins the 'master' table, which contains information about players and coaches, with the 'awardscoaches' table based on the coach ID. The placeholder in the WHERE clause represents the birth year of the coaches."
        },
        {
            "sample_id": 7731,
            "vt": "SELECT teamsplits.octl, teamsplits.tmid FROM teamsplits WHERE teamsplits.year = '[placeholder-type:string]' ORDER BY teamsplits.octl LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides information about the number of overtime losses and the team ID from the 'teamsplits' table for a specific year. The placeholders allow users to specify the year of interest and limit the number of results returned."
        },
        {
            "sample_id": 7695,
            "vt": "SELECT master.firstname, master.lastname FROM master INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE goalies.year = [placeholder-type:numeric] AND goalies.ga > [placeholder-type:numeric] GROUP BY goalies.playerid, master.birthyear, master.birthmon, master.birthmon HAVING SUM(goalies.ga) ORDER BY master.birthyear, master.birthmon, SUM(master.birthday) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the first and last names of players from the 'master' table who are goalies, filtered by a specific year and goals against. The results are grouped by player ID and birth date, ensuring that only those goalies with a total number of goals against exceeding a certain threshold are included. The output is ordered by the player's birth year and month, and limited to a specified number of results."
        },
        {
            "sample_id": 7632,
            "vt": "SELECT master.namenick, master.lastnhl FROM master ORDER BY master.height LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the nicknames and last NHL seasons of players from the 'master' table, ordered by their height. The placeholder in the LIMIT clause represents the maximum number of records to return."
        },
        {
            "sample_id": 7648,
            "vt": "SELECT COUNT(coaches.coachid) FROM coaches WHERE coaches.year = [placeholder-type:numeric] AND coaches.notes = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of coaches from the 'coaches' table based on a specific year and additional notes. The placeholders represent the year of coaching and any relevant notes associated with the coaches."
        },
        {
            "sample_id": 7627,
            "vt": "SELECT master.firstname, master.lastname, goalies.year, AVG(goalies.min) FROM master INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE master.playerid = (SELECT master.playerid FROM Goalies GROUP BY playerID ORDER BY COUNT(playerID) DESC LIMIT 1) GROUP BY master.firstname, master.lastname, goalies.year",
            "ba": "The virtual table provides the first and last names of players from the 'master' table who have played as goalies, along with the year they played and the average minutes they spent on the ice. The query specifically focuses on the player who has appeared as a goalie the most times, as determined by counting their appearances in the 'goalies' table."
        },
        {
            "sample_id": 7742,
            "vt": "SELECT master.pos, awardscoaches.award, master.namegiven, master.lastname FROM master INNER JOIN AwardsCoaches AS T2 ON T2.coachID = T1.coachID GROUP BY master.pos, awardscoaches.award, master.namegiven, master.lastname ORDER BY COUNT(awardscoaches.award) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the positions, awards, given names, and last names of coaches from the 'master' table who have received awards. It joins the 'master' table with the 'awardscoaches' table to gather relevant information about the coaches and their awards. The results are grouped by position, award, given name, and last name, and ordered by the count of awards received, limiting the output to a specified number of entries."
        },
        {
            "sample_id": 7812,
            "vt": "SELECT SUM(teams.pts), coaches.coachid FROM coaches INNER JOIN Teams AS T2 ON T2.tmID = T1.tmID WHERE teams.tmid = '[placeholder-type:string]' GROUP BY coaches.coachid",
            "ba": "The virtual table summarizes the total points earned by teams coached by each coach, identified by their unique coach ID. It combines data from the 'coaches' and 'teams' tables, filtering results based on a specific team ID. The results are grouped by the coach's ID to show the total points for each coach's team."
        },
        {
            "sample_id": 7748,
            "vt": "SELECT coaches.coachid FROM coaches INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE coaches.year = [placeholder-type:numeric] AND teams.rank = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of coaches from the 'coaches' table who are associated with teams that have a specific rank in a given year. The query uses an inner join to connect the 'coaches' and 'teams' tables based on the team ID and year, ensuring that only coaches from teams with the specified rank in the specified year are selected."
        },
        {
            "sample_id": 7777,
            "vt": "SELECT teamssc.w FROM teams INNER JOIN TeamsSC AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE teams.name = '[placeholder-type:string]' AND teamssc.pim = [placeholder-type:numeric]",
            "ba": "The virtual table describes the number of wins from the 'teamssc' table for a specific team based on its name and penalty minutes. It joins the 'teams' table with the 'teamssc' table to filter the results according to the specified team name and penalty minutes."
        },
        {
            "sample_id": 7733,
            "vt": "SELECT scoring.year, scoring.year - master.birthyear FROM scoring INNER JOIN Master AS T2 ON T1.playerID = T2.playerID GROUP BY scoring.year, scoring.year - master.birthyear ORDER BY SUM(scoring.g) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the years in which players scored, along with their ages during those years. It combines data from the 'scoring' table, which contains player performance statistics, and the 'master' table, which holds player birth years. The results are grouped by year and age, and ordered by the total number of goals scored, with a limit on the number of results returned."
        },
        {
            "sample_id": 7794,
            "vt": "SELECT SUM(goalies.gp) FROM goalies INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE master.legendsid = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of games played by goalies from the 'goalies' table, joining it with the 'master' table to filter by a specific legend's ID. The placeholder in the WHERE clause represents the unique identifier for the legend."
        },
        {
            "sample_id": 7693,
            "vt": "SELECT master.firstname, master.lastname FROM master INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID GROUP BY goalies.playerid, master.height HAVING SUM(goalies.eng) > [placeholder-type:numeric] ORDER BY master.height LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of players from the 'master' table who are also goalies, filtered by the number of empty net goals they have allowed. The results are grouped by player ID and height, ensuring that only those goalies who have allowed more than a specified number of empty net goals are included. The output is ordered by height and limited to a specified number of results."
        },
        {
            "sample_id": 7798,
            "vt": "SELECT COUNT(DISTINCT T1.playerID) FROM goalies INNER JOIN Master AS T2 ON T1.playerID = T2.playerID INNER JOIN Teams AS T3 ON T1.tmID = T3.tmID AND T1.year = T3.year WHERE teams.name = '[placeholder-type:string]' AND NOT master.hofid IS NULL",
            "ba": "The virtual table counts the distinct number of players who have played as goalies for a specific team in a given year, while also ensuring that these players are recognized in the Hall of Fame. The placeholders represent the team name that is being queried."
        },
        {
            "sample_id": 7730,
            "vt": "SELECT SUM(goalies.postga) FROM goalies WHERE goalies.lgid = '[placeholder-type:string]' AND goalies.year = '[placeholder-type:string]' GROUP BY goalies.playerid ORDER BY SUM(goalies.postga) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total goals against for goalies in a specific league and year. The results are grouped by each goalie's player ID, allowing for an analysis of individual performance. The placeholder in the WHERE clause represents the league ID and year, while the LIMIT placeholder controls the number of results returned, focusing on the top goalies based on goals against."
        },
        {
            "sample_id": 7700,
            "vt": "SELECT coaches.coachid FROM coaches INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID WHERE teams.year = [placeholder-type:numeric] ORDER BY CAST(teams.ppg AS FLOAT) / teams.ppc LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of coaches from the 'coaches' table who are associated with teams in a specific year. The results are filtered based on the year of the teams and ordered by the power play percentage, which is calculated as the ratio of power play goals to power play chances. The output is limited to a specified number of results."
        },
        {
            "sample_id": 7678,
            "vt": "SELECT master.birthcountry FROM master INNER JOIN HOF AS T2 ON T1.hofID = T2.hofID GROUP BY master.birthcountry ORDER BY COUNT(master.playerid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the birth countries of players from the 'master' table who are also listed in the 'hof' (Hall of Fame) table. It groups the results by birth country and orders them based on the count of players from each country, limiting the results to a specified number."
        },
        {
            "sample_id": 7763,
            "vt": "SELECT teamvsteam.w FROM teamvsteam INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE teamvsteam.year = [placeholder-type:numeric] AND teamvsteam.tmid = (SELECT DISTINCT teams.tmid FROM Teams WHERE name = 'Philadelphia Flyers') AND teamvsteam.oppid = (SELECT DISTINCT teams.tmid FROM Teams WHERE name = 'Boston Bruins')",
            "ba": "The virtual table provides the number of wins for a specific team against a specific opponent in a given year. It retrieves data from the 'teamvsteam' table and joins it with the 'Teams' table to ensure that the team IDs and years match. The placeholders represent the year, the team name for the Philadelphia Flyers, and the opponent name for the Boston Bruins."
        },
        {
            "sample_id": 7641,
            "vt": "SELECT master.namegiven, master.birthyear, master.birthmon, master.birthday, teams.name FROM goalies INNER JOIN Master AS T2 ON T2.playerID = T1.playerID INNER JOIN Teams AS T3 ON T3.lgID = T1.lgID WHERE teams.tmid = '[placeholder-type:string]' GROUP BY master.namegiven, master.birthyear, master.birthmon, master.birthday, teams.name ORDER BY COUNT(master.coachid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides information about goalies, including their given names and birth dates, along with the names of the teams they played for. It filters the results based on a specific team ID and groups the data to avoid duplicates, ordering the results by the count of coaches associated with each goalie, while limiting the number of results returned."
        },
        {
            "sample_id": 7675,
            "vt": "SELECT master.birthmon FROM master INNER JOIN AwardsPlayers AS T2 ON T1.playerID = T2.playerID GROUP BY awardsplayers.playerid ORDER BY COUNT(awardsplayers.award) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the birth month of players from the 'master' table who have received awards, as indicated in the 'awardsplayers' table. It groups the results by player ID and orders them based on the count of awards each player has received, limiting the output to a specified number of players."
        },
        {
            "sample_id": 7711,
            "vt": "SELECT master.birthyear, master.birthmon, master.birthday FROM master INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE goalies.year = [placeholder-type:numeric] ORDER BY goalies.ga LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the birth year, month, and day of players who have played as goalies in a specific year. It retrieves data from the 'master' table, which contains player identification and birth details, and joins it with the 'goalies' table to filter for goalies based on the specified year. The results are ordered by the goals against (ga) statistic and limited to a specified number of entries."
        },
        {
            "sample_id": 7713,
            "vt": "SELECT master.weight FROM master INNER JOIN Scoring AS T2 ON T1.playerID = T2.playerID WHERE scoring.year > [placeholder-type:numeric] GROUP BY master.playerid, master.weight ORDER BY SUM(scoring.ppg) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the weights of players from the 'master' table who have participated in scoring during a specific year. It joins the 'master' table with the 'scoring' table to filter players based on their performance in terms of power play goals (ppg). The results are grouped by player ID and weight, and ordered by the total power play goals scored, with a limit on the number of results returned."
        },
        {
            "sample_id": 7638,
            "vt": "SELECT DISTINCT master.namegiven, teams.name, teams.year FROM coaches INNER JOIN Master AS T2 ON T2.coachID = T1.coachID INNER JOIN Teams AS T3 ON T1.lgID = T3.lgID WHERE NOT master.playerid IS NULL AND NOT master.coachid IS NULL",
            "ba": "The virtual table provides a distinct list of names of individuals who have both player and coach IDs, along with the names of the teams they coached and the corresponding years. It combines data from the 'coaches', 'master', and 'teams' tables, ensuring that only those individuals who have transitioned from players to coaches are included."
        },
        {
            "sample_id": 7626,
            "vt": "SELECT DISTINCT master.namenick, teams.year, teams.name FROM master INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID INNER JOIN Teams AS T3 ON T2.tmID = T3.tmID WHERE master.playerid = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of nicknames, years, and full team names for goalies from the 'master' table who have played in a specific year. The query joins the 'master' table with the 'goalies' table to filter by player ID and then joins with the 'teams' table to get the corresponding team names."
        },
        {
            "sample_id": 7782,
            "vt": "SELECT SUM(teamssc.w / teamssc.g) / SUM(teamssc.g + teamssc.w) FROM teams INNER JOIN TeamsSC AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE teams.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the winning percentage of a specific team by summing the wins and games played from the 'teamssc' table, and then dividing the total wins by the total games played. The placeholder in the WHERE clause represents the name of the team for which the winning percentage is being calculated."
        },
        {
            "sample_id": 7668,
            "vt": "SELECT DISTINCT master.birthcity FROM master INNER JOIN AwardsPlayers AS T2 ON T1.playerID = T2.playerID WHERE awardsplayers.year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct birth cities of players from the 'master' table who have received awards in a specific year. The query joins the 'master' table with the 'awardsplayers' table to filter players based on the year of the award, using a placeholder for the year value."
        },
        {
            "sample_id": 7741,
            "vt": "SELECT master.lastnhl - master.birthyear FROM goaliessc INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE NOT master.lastnhl IS NULL GROUP BY master.lastnhl, master.birthyear ORDER BY SUM(goaliessc.ga) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the difference between the last NHL season year and the birth year of players who have played as goalies, filtering out those without a recorded last NHL season. It groups the results by the last NHL season and birth year, ordering them by the total goals against (GA) in the goaliessc table, and limits the output to a specified number of results."
        },
        {
            "sample_id": 7737,
            "vt": "SELECT DISTINCT coaches.coachid, awardscoaches.award FROM awardscoaches INNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID GROUP BY coaches.coachid, awardscoaches.award ORDER BY SUM(coaches.w) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct coach IDs along with the awards they have received. It combines data from the 'awardscoaches' and 'coaches' tables, grouping the results by coach ID and award name. The results are ordered by the total number of wins associated with each coach, and a limit is applied to restrict the number of records returned based on a specified numeric value."
        },
        {
            "sample_id": 7790,
            "vt": "SELECT master.firstname, master.lastname FROM goalies INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE goalies.eng = [placeholder-type:numeric] ORDER BY master.height LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of goalies from the 'goalies' table who have a specific number of empty net goals. The query joins the 'goalies' table with the 'master' table to retrieve the names of the goalies based on their player ID, and it filters the results based on the number of empty net goals using a numeric placeholder. The results are ordered by the height of the goalies and limited to a specified number of entries."
        },
        {
            "sample_id": 7666,
            "vt": "SELECT DISTINCT master.firstname, master.lastname FROM master INNER JOIN HOF AS T2 ON T1.hofID = T2.hofID WHERE master.shootcatch IS NULL",
            "ba": "The virtual table describes the distinct first and last names of players from the 'master' table who have not specified their shooting or catching hand, and who are also included in the Hall of Fame (HOF) based on their hall of fame ID."
        },
        {
            "sample_id": 7654,
            "vt": "SELECT COUNT(hof.hofid) FROM hof WHERE hof.category = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of entries in the 'hof' table where the category of the Hall of Fame is specified. The placeholder in the WHERE clause represents the category of the Hall of Fame."
        },
        {
            "sample_id": 7760,
            "vt": "SELECT COUNT(teamssc.tmid) FROM teamssc INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE teamssc.year = '[placeholder-type:string]' AND teams.pts > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of teams from the 'teamssc' table that have a certain number of points in a specified year. It joins the 'teamssc' table with the 'Teams' table based on the team ID and year, filtering for teams that have points greater than a specified value."
        },
        {
            "sample_id": 7659,
            "vt": "SELECT COUNT(coaches.coachid) FROM master INNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID WHERE coaches.w > [placeholder-type:numeric] AND master.birthcountry = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of coaches from the 'master' table who have a winning record greater than a specified number and were born in a specific country. The placeholders represent the minimum winning record and the country of birth."
        },
        {
            "sample_id": 7651,
            "vt": "SELECT DISTINCT goalies.year FROM goalies WHERE goalies.lgid = '[placeholder-type:string]' AND NOT goalies.sa IS NULL",
            "ba": "The virtual table lists the distinct years in which goalies played, filtered by a specific league ID. The placeholder in the WHERE clause represents the league's abbreviated name, ensuring that only relevant data is retrieved for goalies who have recorded shots against."
        },
        {
            "sample_id": 7642,
            "vt": "SELECT DISTINCT master.firstname, master.lastname, teams.name FROM master INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID INNER JOIN Teams AS T3 ON T2.year = T3.year AND T2.tmID = T3.tmID WHERE master.pos = '[placeholder-type:string]' AND goalies.l > goalies.w GROUP BY master.firstname, master.lastname, teams.name HAVING COUNT(teams.year) > [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of distinct first and last names of players from the 'master' table who are goalies, along with their team names from the 'teams' table. It filters for goalies who have lost more games than they have won and groups the results by player name and team name. Additionally, it requires that the player's position matches a specified value and that the number of years they played exceeds a certain numeric threshold."
        },
        {
            "sample_id": 7756,
            "vt": "SELECT teams.name FROM teams WHERE teams.year = [placeholder-type:numeric] GROUP BY teams.tmid, teams.name ORDER BY SUM(teams.pim) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of teams from the 'teams' table for a specific year. The results are grouped by team ID and name, and ordered by the total penalty minutes (pim) incurred by each team, limiting the output to a specified number of teams."
        },
        {
            "sample_id": 7728,
            "vt": "SELECT teamsplits.tmid FROM teamsplits WHERE teamsplits.year = '[placeholder-type:string]' ORDER BY teamsplits.rw LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the team IDs from the 'teamsplits' table for a specific year, ordered by the number of road wins. The placeholders allow users to specify the year and limit the number of results returned."
        },
        {
            "sample_id": 7745,
            "vt": "SELECT master.namegiven, master.lastname FROM scoring INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE scoring.shg BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] ORDER BY scoring.gwg LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of players' given names and last names from the 'master' table who have scored a specific range of shorthanded goals in the 'scoring' table. The results are ordered by game-winning goals and limited to a specified number of entries."
        },
        {
            "sample_id": 7613,
            "vt": "SELECT master.namegiven FROM master WHERE master.shootcatch IS NULL AND master.pos = '[placeholder-type:string]'",
            "ba": "The virtual table describes the given names of players from the 'master' table who are ambidextrous in shooting or catching (indicated by a NULL value in the 'shootcatch' column) and play a specific position. The placeholder in the WHERE clause represents the player's position."
        },
        {
            "sample_id": 7698,
            "vt": "SELECT SUM(goalies.sho) FROM scoring INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE goalies.year = [placeholder-type:numeric] GROUP BY goalies.tmid ORDER BY SUM(goalies.postsho) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total shutouts achieved by goalies in a specific year, grouped by team. It retrieves the sum of shutouts from the 'goalies' table, joining it with the 'scoring' table to correlate player performance. The results are ordered by the total postseason shutouts and limited to a specified number of entries."
        },
        {
            "sample_id": 7771,
            "vt": "SELECT COUNT(DISTINCT T3.coachID) FROM coaches INNER JOIN Teams AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID INNER JOIN Master AS T3 ON T1.coachID = T3.coachID WHERE teams.name = '[placeholder-type:string]' AND NOT master.deathyear IS NULL",
            "ba": "The virtual table counts the distinct number of coaches from the 'coaches' table who have coached a specific team in a given year, where the team name is specified. It filters out any coaches who have a recorded death year, ensuring that only living coaches are counted. The query joins the 'coaches', 'teams', and 'master' tables to gather the necessary information."
        },
        {
            "sample_id": 7773,
            "vt": "SELECT COUNT(DISTINCT T3.coachID) FROM coaches INNER JOIN TeamsSC AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID INNER JOIN Master AS T3 ON T1.coachID = T3.coachID WHERE teamssc.year = [placeholder-type:numeric] AND master.birthcountry = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of coaches from the 'coaches' table who have coached teams in a specific year and belong to a specific country. It joins the 'coaches' table with the 'teamsSC' table to filter by year and team ID, and then further joins with the 'master' table to filter by the birth country of the coaches."
        },
        {
            "sample_id": 7684,
            "vt": "SELECT goalies.gp FROM goalies WHERE goalies.playerid = '[placeholder-type:string]' AND goalies.year = [placeholder-type:numeric]",
            "ba": "The virtual table provides the number of games played by a specific goalie in a given year from the 'goalies' table. The placeholders represent the goalie's unique identifier and the year of interest."
        },
        {
            "sample_id": 7670,
            "vt": "SELECT COUNT(master.playerid) FROM master INNER JOIN AwardsPlayers AS T2 ON T1.playerID = T2.playerID WHERE awardsplayers.award = '[placeholder-type:string]' AND NOT master.deathyear IS NULL",
            "ba": "The virtual table counts the number of players from the 'master' table who have received a specific award from the 'awardsplayers' table and are not deceased. The placeholder in the WHERE clause represents the name of the award."
        },
        {
            "sample_id": 7722,
            "vt": "SELECT teams.benchminor, teams.name FROM teams ORDER BY teams.t LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the number of bench minor penalties and the full names of teams from the 'teams' table, sorted in ascending order based on the number of bench minors. The placeholder in the LIMIT clause represents the maximum number of records to return."
        },
        {
            "sample_id": 7744,
            "vt": "SELECT COUNT(DISTINCT oppID), teamvsteam.tmid, teamvsteam.oppid FROM teams INNER JOIN TeamVsTeam AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID WHERE teamvsteam.year = [placeholder-type:numeric] GROUP BY teamvsteam.tmid, teamvsteam.oppid ORDER BY SUM(teamvsteam.w) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of distinct opponents faced by each team in a specified year, along with the team ID and opponent ID. It aggregates the data from the 'teams' and 'teamvsteam' tables, filtering by the year and grouping the results by team and opponent. The results are ordered by the total number of wins against those opponents, with a limit on the number of results returned."
        },
        {
            "sample_id": 7633,
            "vt": "SELECT AVG(CASE WHEN master.birthyear < [placeholder-type:numeric] THEN master.height ELSE NULL END) - AVG(CASE WHEN master.birthyear >= [placeholder-type:numeric] THEN master.height ELSE NULL END) FROM master",
            "ba": "The virtual table calculates the average height difference between players born before a specified year and those born in or after that year from the 'master' table. The placeholders represent the year used to categorize the players."
        },
        {
            "sample_id": 7634,
            "vt": "SELECT DISTINCT master.firstname, master.lastname, teams.name FROM goalies INNER JOIN Master AS T2 ON T2.playerID = T1.playerID INNER JOIN Teams AS T3 ON T1.lgID = T3.lgID WHERE NOT goalies.playerid IS NULL AND NOT master.coachid IS NULL AND master.shootcatch = '[placeholder-type:string]' AND master.pos = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct first and last names of goalies along with their team names from the 'goalies' and 'teams' tables. It filters the results to include only those goalies who are also identified as coaches, ensuring that the player's shooting or catching hand and position are specified using placeholders."
        },
        {
            "sample_id": 7649,
            "vt": "SELECT COUNT(combinedshutouts.year) FROM combinedshutouts WHERE combinedshutouts.year = [placeholder-type:numeric] AND combinedshutouts.\"r/p\" = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of combined shutouts recorded in a specific year for a given type of shutout (regular or playoff) from the 'combinedshutouts' table. The placeholders represent the year and the type of shutout."
        },
        {
            "sample_id": 7673,
            "vt": "SELECT DISTINCT master.namenick FROM master INNER JOIN AwardsPlayers AS T2 ON T1.playerID = T2.playerID WHERE awardsplayers.award = '[placeholder-type:string]' AND master.birthmon = [placeholder-type:numeric]",
            "ba": "The virtual table lists unique nicknames of players from the 'master' table who have received a specific award and were born in a particular month. The query joins the 'master' table with the 'awardsplayers' table to filter players based on their award and birth month."
        },
        {
            "sample_id": 7660,
            "vt": "SELECT COUNT(coaches.coachid) FROM master INNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID WHERE coaches.lgid = '[placeholder-type:string]' AND master.birthcountry = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of coaches from the 'master' table who are associated with a specific league and were born in a specific country. The placeholders represent the league ID and the birth country of the coaches."
        },
        {
            "sample_id": 7746,
            "vt": "SELECT SUM(coaches.l), coaches.coachid FROM coaches INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE coaches.notes = '[placeholder-type:string]' AND coaches.year = '[placeholder-type:string]' AND teams.name = '[placeholder-type:string]' GROUP BY coaches.coachid",
            "ba": "The virtual table summarizes the total number of losses for each coach from the 'coaches' table, filtered by specific notes, year, and team name. The results are grouped by the coach's ID, allowing for an aggregated view of losses per coach based on the provided criteria."
        },
        {
            "sample_id": 7804,
            "vt": "SELECT DISTINCT master.firstname, master.lastname FROM master WHERE master.birthcountry = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct first and last names of players from the 'master' table who were born in a specific country. The placeholder in the WHERE clause represents the name of the country."
        },
        {
            "sample_id": 7774,
            "vt": "SELECT teams.name FROM teamvsteam INNER JOIN Teams AS T2 ON T1.year = T2.year AND T1.oppID = T2.tmID INNER JOIN Teams AS T3 ON T1.year = T3.year AND T1.tmID = T3.tmID WHERE teamvsteam.year = [placeholder-type:numeric] AND teams.name = '[placeholder-type:string]' GROUP BY teams.name ORDER BY SUM(teams.g) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of teams from the 'teamvsteam' table that have played against a specified opponent in a given year. The query joins the 'teamvsteam' table with the 'Teams' table twice to retrieve the names of both the specified team and its opponent, filtering by the year and grouping the results by team name. The results are ordered by the total number of games played by the teams, with a limit on the number of results returned."
        },
        {
            "sample_id": 7657,
            "vt": "SELECT CASE WHEN master.hofid IS NULL THEN '[placeholder-type:string]' ELSE hof.year END FROM master LEFT JOIN HOF AS T2 ON T1.hofID = T2.hofID WHERE master.height = (SELECT MAX(master.height) FROM Master)",
            "ba": "The virtual table retrieves the year of induction into the Hall of Fame for the tallest player in the 'master' table. If the player is not in the Hall of Fame, it returns a placeholder value. The query uses a LEFT JOIN to connect the 'master' table with the 'hof' table based on the Hall of Fame ID, and it filters for the maximum height from the 'master' table."
        },
        {
            "sample_id": 7646,
            "vt": "SELECT COUNT(awardsmisc.note) FROM awardsmisc WHERE NOT awardsmisc.note IS NULL",
            "ba": "The virtual table counts the number of non-null notes associated with awards from the 'awardsmisc' table. The placeholder in the WHERE clause indicates that only notes that are not empty or null are considered in the count."
        },
        {
            "sample_id": 7699,
            "vt": "SELECT coaches.coachid, master.namenick FROM master INNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID WHERE coaches.year = [placeholder-type:numeric] ORDER BY CAST(coaches.w AS FLOAT) / (coaches.w + coaches.l) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of coach IDs and their nicknames from the 'master' table, filtered by the year they coached. It calculates the winning rate of each coach by dividing the number of wins by the total number of games (wins + losses) and orders the results based on this winning rate. The placeholders allow users to specify the year and limit the number of results returned."
        },
        {
            "sample_id": 7702,
            "vt": "SELECT COUNT(scoringsc.year) FROM scoringsc WHERE scoringsc.playerid = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of seasons a specific player has participated in, as recorded in the 'scoringsc' table. The placeholder represents the unique identifier for the player."
        },
        {
            "sample_id": 7778,
            "vt": "SELECT teams.year FROM teams INNER JOIN TeamsSC AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE teams.name = '[placeholder-type:string]' AND teamssc.pim = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the years in which a specific team, identified by its name, has played, while also filtering for teams that have a specific number of penalty minutes recorded in the 'TeamsSC' table. The placeholders allow users to specify the team name and the penalty minutes for their query."
        },
        {
            "sample_id": 7628,
            "vt": "SELECT DISTINCT master.firstname, master.lastname, (SELECT playerID, year FROM Goalies WHERE CAST(SHO AS FLOAT) / GA > 0.05).year FROM master INNER JOIN (SELECT playerID, year FROM Goalies WHERE CAST(SHO AS FLOAT) / GA > 0.05) AS T2 ON T2.playerID = T1.playerID",
            "ba": "The virtual table lists the distinct first and last names of players from the 'master' table who have a significant shutout percentage, specifically those whose shutouts divided by goals against is greater than 0.05. It also includes the year of those performances from the 'Goalies' table."
        },
        {
            "sample_id": 7792,
            "vt": "SELECT COUNT(DISTINCT T1.tmID) FROM goalies INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE master.lastname = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct team IDs from the 'goalies' table for players whose last name matches a specified value. It joins the 'goalies' table with the 'master' table to filter the results based on the player's last name."
        },
        {
            "sample_id": 7707,
            "vt": "SELECT SUM(teams.w) FROM goalies INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID WHERE teams.year = [placeholder-type:numeric] GROUP BY goalies.tmid HAVING COUNT(DISTINCT T1.playerID) = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total number of wins for goalies from the 'goalies' table, grouped by their team IDs. It joins the 'goalies' table with the 'Teams' table to filter the results based on a specific year. The query also ensures that only teams with a specified number of distinct goalies are included in the results."
        },
        {
            "sample_id": 7650,
            "vt": "SELECT COUNT(goalies.tmid) FROM goalies WHERE goalies.year = [placeholder-type:numeric] AND goalies.eng IS NULL",
            "ba": "The virtual table counts the number of goalies from the 'goalies' table who played in a specific year and did not have any empty net goals."
        },
        {
            "sample_id": 7612,
            "vt": "SELECT master.firstname, master.lastname FROM master WHERE master.birthyear = [placeholder-type:numeric] AND master.birthcountry <> '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of players from the 'master' table who were born in a specific year and are not from a specified country. The placeholders represent the year of birth and the country name."
        }
    ],
    "public_review_platform": [
        {
            "sample_id": 3915,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.active LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses from the 'business' table that are either currently active or not active, based on a specified condition. The placeholder in the WHERE clause represents the status of the business, indicating whether it is active or inactive."
        },
        {
            "sample_id": 3880,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.state LIKE '[placeholder-type:string]' AND business.active LIKE '[placeholder-type:string]' AND business.review_count LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses from the 'business' table that are located in a specific state, are currently active, and have a certain number of reviews. The placeholders in the WHERE clause represent the state, active status, and review count criteria."
        },
        {
            "sample_id": 3970,
            "vt": "SELECT CAST(SUM(CASE WHEN business.active = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(business.business_id) FROM business",
            "ba": "The virtual table calculates the weighted average of a certain metric for businesses based on their active status. It sums up a conditional value based on whether the business is active or not, multiplies it by a specified factor, and divides by the total count of businesses to derive the average."
        },
        {
            "sample_id": 4014,
            "vt": "SELECT users.user_id FROM users WHERE users.user_average_stars = [placeholder-type:numeric] ORDER BY users.user_yelping_since_year LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of users from the 'users' table who have an average star rating equal to a specified value. The results are ordered by the year the user joined Yelp, and the number of results returned is limited to a specified count."
        },
        {
            "sample_id": 4133,
            "vt": "SELECT DISTINCT categories.category_name FROM business_categories INNER JOIN Business AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T1.category_id = T3.category_id WHERE business.active = '[placeholder-type:string]' AND business.state = '[placeholder-type:string]' AND business.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct category names from the 'categories' table for businesses that are active and located in a specific city and state. The placeholders represent the business's active status, state, and city."
        },
        {
            "sample_id": 4081,
            "vt": "SELECT tips.user_id, tips.business_id, reviews.review_length FROM tips INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id ORDER BY tips.likes LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the user IDs and business IDs from the 'tips' table along with the length of reviews from the 'reviews' table. It combines data from both tables based on matching business IDs, allowing users to see which tips are associated with which reviews. The results are ordered by the number of likes on the tips, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 4062,
            "vt": "SELECT COUNT(business.business_id) FROM business INNER JOIN Business_Categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T2.category_id = T3.category_id WHERE categories.category_name = '[placeholder-type:string]' AND business.stars < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of businesses that belong to a specific category and have a star rating below a certain threshold. It joins the 'business' table with 'business_categories' and 'categories' to filter based on the category name and the star rating of the business."
        },
        {
            "sample_id": 3963,
            "vt": "SELECT COUNT(users_compliments.user_id) FROM users INNER JOIN Users_Compliments AS T2 ON T1.user_id = T2.user_id INNER JOIN Compliments AS T3 ON T2.compliment_id = T3.compliment_id WHERE users.user_yelping_since_year = [placeholder-type:numeric] AND users.user_average_stars = [placeholder-type:numeric] AND users.user_fans = '[placeholder-type:string]' AND compliments.compliment_type = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users who have received compliments based on specific criteria such as the year they joined Yelp, their average star rating, the number of fans they have, and the type of compliment they received."
        },
        {
            "sample_id": 3980,
            "vt": "SELECT users.user_average_stars, elite.year_id, compliments.compliment_type, users_compliments.number_of_compliments FROM elite INNER JOIN Users AS T2 ON T1.user_id = T2.user_id INNER JOIN Users_Compliments AS T3 ON T2.user_id = T3.user_id INNER JOIN Compliments AS T4 ON T3.compliment_id = T4.compliment_id INNER JOIN Years AS T5 ON T1.year_id = T5.year_id WHERE users_compliments.number_of_compliments = '[placeholder-type:string]' AND users_compliments.user_id = [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of user ratings, compliments received, and the year of elite status for users in the Yelp database. It combines data from multiple tables including users, elite, compliments, and users_compliments. The placeholders allow for filtering based on the number of compliments a user has received and the specific user ID."
        },
        {
            "sample_id": 3844,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.state LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses located in a specific state from the 'business' table. The placeholder in the WHERE clause represents the state name."
        },
        {
            "sample_id": 4102,
            "vt": "SELECT business.business_id FROM business WHERE business.stars > [placeholder-type:numeric] AND business.city = '[placeholder-type:string]' AND business.review_count = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of businesses from the 'business' table that have a star rating greater than a specified value, are located in a specific city, and have a certain number of reviews. The placeholders represent the minimum star rating, the city name, and the review count respectively."
        },
        {
            "sample_id": 4058,
            "vt": "SELECT DISTINCT days.day_of_week FROM business_categories INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business_Hours AS T3 ON T1.business_id = T3.business_id INNER JOIN Days AS T4 ON T3.day_id = T4.day_id WHERE categories.category_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct days of the week when businesses belonging to a specific category are open. It joins multiple tables to filter the results based on the category name provided as a placeholder."
        },
        {
            "sample_id": 3950,
            "vt": "SELECT [placeholder-type:numeric] * ((SELECT SUM(business.stars) FROM Business AS T1 INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE T1.state = 'SC') + (SELECT SUM(business.stars) FROM Business AS T1 INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE T1.state = 'CA')) / (SELECT SUM(business.stars) FROM Business AS T1 INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id)",
            "ba": "The virtual table calculates a weighted average of business ratings based on reviews from two specific states, South Carolina (SC) and California (CA). It multiplies a placeholder numeric value by the sum of stars from businesses in these two states, divided by the total sum of stars from all businesses. This allows for an analysis of how ratings from these states contribute to the overall rating average."
        },
        {
            "sample_id": 3940,
            "vt": "SELECT business_attributes.business_id FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE business_attributes.attribute_value LIKE '[placeholder-type:string]' AND attributes.attribute_name LIKE '[placeholder-type:string]' AND attributes.attribute_name LIKE '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of businesses from the 'business_attributes' table based on specific attribute values and names. It joins the 'attributes' table to filter by attribute names and the 'business' table to ensure the businesses are correctly identified. The placeholders represent the attribute value and names, allowing users to specify their criteria for the query."
        },
        {
            "sample_id": 4039,
            "vt": "SELECT DISTINCT business_hours.business_id FROM business_hours WHERE business_hours.day_id >= [placeholder-type:numeric] AND business_hours.day_id < [placeholder-type:numeric] AND business_hours.opening_time = business_hours.closing_time",
            "ba": "The virtual table identifies distinct businesses from the 'business_hours' table that are closed on specific days of the week. The placeholders represent a range of day IDs, and the condition checks if the opening time is equal to the closing time, indicating that the business is not open on those days."
        },
        {
            "sample_id": 4108,
            "vt": "SELECT users.user_average_stars FROM tips INNER JOIN Users AS T2 ON T1.user_id = T2.user_id GROUP BY users.user_id ORDER BY SUM(tips.likes) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the average star ratings of users based on the tips they have provided. It joins the 'tips' table with the 'users' table to associate each tip with the corresponding user. The results are grouped by user ID and ordered by the total number of likes received on their tips, allowing for a limit on the number of users returned."
        },
        {
            "sample_id": 3860,
            "vt": "SELECT COUNT(business.business_id) FROM reviews INNER JOIN Business AS T2 ON T1.business_id = T2.business_id WHERE business.state LIKE '[placeholder-type:string]' AND reviews.user_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of businesses that have been reviewed by a specific user in a given state. It joins the 'reviews' table with the 'business' table to filter the results based on the user's ID and the state of the business."
        },
        {
            "sample_id": 3817,
            "vt": "SELECT COUNT(business.business_id) FROM business INNER JOIN Business_Categories ON T1.business_id = Business_Categories.business_id INNER JOIN Categories AS T3 ON Business_Categories.category_id = T3.category_id WHERE business.stars = [placeholder-type:numeric] AND categories.category_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses from the 'business' table that belong to a specific category and have a certain star rating. It joins the 'business' table with the 'business_categories' table to link businesses with their respective categories, and then further joins with the 'categories' table to filter by category name. The placeholders represent the star rating and the category name to be specified by the user."
        },
        {
            "sample_id": 3904,
            "vt": "SELECT attributes.attribute_name FROM business_hours INNER JOIN Days AS T2 ON T1.day_id = T2.day_id INNER JOIN Business AS T3 ON T1.business_id = T3.business_id INNER JOIN Business_Attributes AS T4 ON T3.business_id = T4.business_id INNER JOIN Attributes AS T5 ON T4.attribute_id = T5.attribute_id WHERE days.day_id LIKE '[placeholder-type:string]' AND '[placeholder-type:string]' AND '[placeholder-type:string]' AND '[placeholder-type:string]' AND '[placeholder-type:string]' AND '[placeholder-type:string]' AND '[placeholder-type:string]' AND business_hours.opening_time = business_hours.closing_time GROUP BY attributes.attribute_name",
            "ba": "The virtual table retrieves the names of attributes associated with businesses that have specific opening and closing times on a given day of the week. It joins multiple tables to filter businesses based on their hours of operation and attributes."
        },
        {
            "sample_id": 3933,
            "vt": "SELECT CAST(SUM(CASE WHEN business.stars < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(business.stars) FROM business INNER JOIN Business_Categories ON T1.business_id = Business_Categories.business_id INNER JOIN Categories AS T3 ON Business_Categories.category_id = T3.category_id WHERE categories.category_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of business ratings based on a specified threshold for star ratings. It sums the ratings of businesses that fall below a certain star rating and applies a multiplier to this sum, then divides by the total count of businesses in a specific category. The placeholders represent the threshold for star ratings, the multiplier, and the category name."
        },
        {
            "sample_id": 3787,
            "vt": "SELECT SUM(CASE WHEN categories.category_name LIKE '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN categories.category_name LIKE '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id",
            "ba": "The virtual table calculates the difference between two sums based on a condition applied to the 'category_name' from the 'categories' table. It uses a placeholder for the category name to filter the results. The sums are derived from a join between the 'categories' table and the 'business_categories' table, which associates businesses with their respective categories."
        },
        {
            "sample_id": 4046,
            "vt": "SELECT DISTINCT compliments.compliment_type FROM users INNER JOIN Users_Compliments AS T2 ON T1.user_id = T2.user_id INNER JOIN Compliments AS T3 ON T2.compliment_id = T3.compliment_id WHERE users.user_fans = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct types of compliments received by users who have a specific number of fans. It joins the 'users' table with the 'users_compliments' table to link users with their compliments, and then further joins with the 'compliments' table to get the compliment types."
        },
        {
            "sample_id": 3951,
            "vt": "SELECT SUM(CASE WHEN days.day_of_week = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN days.day_of_week = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM business INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE business_hours.opening_time = '[placeholder-type:string]' AND business_hours.closing_time = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total time a business is open on a specific day of the week by subtracting the total opening time from the total closing time. It joins the 'business' table with 'business_hours' and 'days' to filter the results based on the specified day and the opening and closing times."
        },
        {
            "sample_id": 3959,
            "vt": "SELECT business_attributes.attribute_value FROM business_attributes INNER JOIN Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE attributes.attribute_name = '[placeholder-type:string]' AND business_attributes.business_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the attribute value for a specific business based on the attribute name. It joins the 'business_attributes' table with the 'attributes' table to filter the results according to the provided attribute name and business ID."
        },
        {
            "sample_id": 3955,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.review_count = '[placeholder-type:string]' AND business.city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses from the 'business' table that have a specific review count and are located in a specific city. The placeholders represent the review count and the city name."
        },
        {
            "sample_id": 4122,
            "vt": "SELECT business.business_id FROM business WHERE business.stars >= [placeholder-type:numeric] AND business.stars < [placeholder-type:numeric] AND business.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of businesses from the 'business' table that have a star rating within a specified range and are located in a specific city. The placeholders represent the minimum and maximum star ratings as well as the city name."
        },
        {
            "sample_id": 3759,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.state LIKE '[placeholder-type:string]' AND business.active LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses from the 'business' table that are located in a specific state and are currently active. The placeholders in the WHERE clause represent the state and the active status of the businesses."
        },
        {
            "sample_id": 3885,
            "vt": "SELECT COUNT(business.business_id) FROM business INNER JOIN Business_Categories ON T1.business_id = Business_Categories.business_id INNER JOIN Categories AS T3 ON Business_Categories.category_id = T3.category_id WHERE business.stars < [placeholder-type:numeric] AND categories.category_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses from the 'business' table that belong to a specific category and have a star rating below a certain threshold. It joins the 'business' table with the 'business_categories' table to link businesses with their respective categories, and then further joins with the 'categories' table to filter based on the category name. The placeholders represent the maximum star rating and the category name to be searched."
        },
        {
            "sample_id": 3946,
            "vt": "SELECT COUNT(users.user_fans) FROM users INNER JOIN Tips AS T2 ON T1.user_id = T2.user_id ORDER BY COUNT(tips.likes) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of fans for users who have provided tips, ordering the results by the number of likes those tips have received. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 3794,
            "vt": "SELECT CAST(SUM(CASE WHEN business.city LIKE '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(business_attributes.business_id) FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE attributes.attribute_name LIKE '[placeholder-type:string]' AND business_attributes.attribute_value LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average value of a specific attribute for businesses located in a specified city. It sums the values of the attribute for businesses that match the city condition and divides it by the count of business attributes to get the average. The placeholders represent the city name, attribute name, and attribute value, allowing users to customize the query for different cities and attributes."
        },
        {
            "sample_id": 4093,
            "vt": "SELECT days.day_id - business_hours.day_id FROM business INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE business.state = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between the day IDs from the 'days' table and the 'business_hours' table for businesses located in a specific state. This helps to identify the days when businesses are open or closed based on their operating hours."
        },
        {
            "sample_id": 3820,
            "vt": "SELECT business.city FROM business INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE reviews.review_votes_funny LIKE '[placeholder-type:string]' GROUP BY business.city",
            "ba": "The virtual table retrieves the cities of businesses from the 'business' table that have received a specific type of funny votes on their reviews. The query joins the 'business' table with the 'reviews' table to filter businesses based on the funny votes received, and groups the results by city."
        },
        {
            "sample_id": 4054,
            "vt": "SELECT DISTINCT business_hours.business_id FROM business_hours WHERE business_hours.day_id = [placeholder-type:numeric] AND business_hours.opening_time = '[placeholder-type:string]'",
            "ba": "The virtual table identifies unique businesses from the 'business_hours' table that are open at a specific time on a given day of the week. The placeholders represent the day of the week and the opening time for filtering the results."
        },
        {
            "sample_id": 3902,
            "vt": "SELECT COUNT(users_compliments.user_id) FROM users_compliments INNER JOIN Compliments AS T2 ON T1.compliment_id = T2.compliment_id WHERE users_compliments.number_of_compliments LIKE '[placeholder-type:string]' AND compliments.compliment_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users who have received a specific number of compliments from other users. It joins the 'users_compliments' table with the 'compliments' table to filter based on the number of compliments and a specific compliment type."
        },
        {
            "sample_id": 3887,
            "vt": "SELECT categories.category_name FROM business INNER JOIN Business_Categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T2.category_id = T3.category_id ORDER BY business.stars LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of categories associated with businesses from the 'business' table. It joins the 'business_categories' table to link businesses with their respective categories and the 'categories' table to get the category names. The results are ordered by the star ratings of the businesses, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 4047,
            "vt": "SELECT CAST(SUM(elite.year_id - users.user_yelping_since_year) AS FLOAT) / COUNT(users.user_id) FROM users INNER JOIN Elite AS T2 ON T1.user_id = T2.user_id WHERE users.user_fans = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of years users have been on Yelp since they joined, weighted by the number of fans they have. It does this by summing the difference between the year a user joined and the year they are being compared to, then dividing by the total count of users who meet the specified fan criteria."
        },
        {
            "sample_id": 3869,
            "vt": "SELECT COUNT(users.user_id) FROM users INNER JOIN Elite AS T2 ON T1.user_id = T2.user_id WHERE users.user_yelping_since_year = elite.year_id",
            "ba": "The virtual table counts the number of users who have joined Yelp in a specific year and are classified as elite users. It joins the 'users' table with the 'elite' table based on the user ID and filters the results to match the year when the user joined Yelp with the year in the elite table."
        },
        {
            "sample_id": 3907,
            "vt": "SELECT CAST(SUM(CASE WHEN users.user_average_stars = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / COUNT(elite.user_id), SUM(CASE WHEN users.user_average_stars = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) * [placeholder-type:numeric] / COUNT(elite.user_id) FROM users INNER JOIN Elite AS T2 ON T1.user_id = T2.user_id WHERE elite.year_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average rating of users who are part of the elite group for a specific year. It sums up the average stars of users based on a condition and divides it by the count of elite users to get the average. Additionally, it multiplies the sum of the average stars by a placeholder value and divides it by the count of elite users to provide another metric related to user ratings."
        },
        {
            "sample_id": 4120,
            "vt": "SELECT business.business_id FROM business WHERE business.review_count = '[placeholder-type:string]' AND business.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier of businesses from the 'business' table that have a specific review count and are located in a specified city. The placeholders represent the review count and city name."
        },
        {
            "sample_id": 3937,
            "vt": "SELECT COUNT(users.user_id) FROM users WHERE users.user_average_stars = [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users from the 'users' table who have an average star rating equal to a specified value. The placeholders represent the average star rating and the limit on the number of results returned."
        },
        {
            "sample_id": 3826,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.city LIKE '[placeholder-type:string]' AND business.active LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses from the 'business' table that are located in a specific city and are currently active. The placeholders in the WHERE clause represent the city name and the active status of the business."
        },
        {
            "sample_id": 4007,
            "vt": "SELECT business.business_id FROM business WHERE business.city = '[placeholder-type:string]' AND business.active = '[placeholder-type:string]' AND business.review_count = '[placeholder-type:string]' ORDER BY business.stars LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of businesses from the 'business' table that are located in a specific city, are currently active, and have a specified number of reviews. The results are ordered by the star ratings of the businesses, and the number of results returned is limited to a specified numeric value."
        },
        {
            "sample_id": 3909,
            "vt": "SELECT COUNT(reviews.business_id), STRFTIME('%Y', 'now') - users.user_yelping_since_year FROM reviews INNER JOIN Users AS T2 ON T1.user_id = T2.user_id WHERE reviews.user_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of reviews associated with a specific user and calculates the number of years since the user joined Yelp. It joins the 'reviews' table with the 'users' table based on the user ID, filtering for a specific user using a placeholder for the user ID."
        },
        {
            "sample_id": 4065,
            "vt": "SELECT COUNT(DISTINCT T1.category_id) FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE business.review_count = '[placeholder-type:string]' AND business.stars > [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct categories associated with businesses that have a specific review count and a star rating greater than a specified value. It joins the 'categories' table with the 'business_categories' table to link categories to businesses, and then further joins with the 'business' table to apply the filtering conditions based on review count and star rating."
        },
        {
            "sample_id": 3936,
            "vt": "SELECT users_compliments.user_id FROM users_compliments WHERE users_compliments.number_of_compliments LIKE '[placeholder-type:string]' GROUP BY users_compliments.user_id ORDER BY COUNT(users_compliments.number_of_compliments) > [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the user IDs from the 'users_compliments' table based on a specific number of compliments received by users. It groups the results by user ID and orders them by the count of compliments that exceed a specified numeric threshold, limiting the results to a certain number of entries."
        },
        {
            "sample_id": 3877,
            "vt": "SELECT business_hours.closing_time + [placeholder-type:numeric] - business_hours.opening_time FROM business_hours INNER JOIN Days AS T2 ON T1.day_id = T2.day_id WHERE business_hours.business_id = [placeholder-type:numeric] AND (days.day_of_week = '[placeholder-type:string]' OR days.day_of_week = '[placeholder-type:string]')",
            "ba": "The virtual table calculates the total time a business is open on specific days of the week by subtracting the opening time from the closing time. It retrieves this information from the 'business_hours' table, joining it with the 'days' table to filter for the desired days of the week. The placeholders represent the business ID and the days of the week being queried."
        },
        {
            "sample_id": 3780,
            "vt": "SELECT COUNT(reviews.review_length) FROM reviews WHERE reviews.business_id = [placeholder-type:numeric] AND reviews.review_stars = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of reviews for a specific business that have a certain star rating. The placeholders represent the business identifier and the star rating to filter the reviews accordingly."
        },
        {
            "sample_id": 3958,
            "vt": "SELECT attributes.attribute_name FROM business INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id INNER JOIN Attributes AS T3 ON T2.attribute_id = T3.attribute_id WHERE business.city = '[placeholder-type:string]' AND business.review_count = '[placeholder-type:string]' AND attributes.attribute_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of attributes associated with businesses located in a specific city, which have a certain number of reviews, and match a specified attribute name. The placeholders in the WHERE clause represent the city name, review count, and attribute name respectively."
        },
        {
            "sample_id": 3771,
            "vt": "SELECT users.user_yelping_since_year FROM tips INNER JOIN Users AS T2 ON T1.user_id = T2.user_id WHERE tips.tip_length LIKE '[placeholder-type:string]' GROUP BY users.user_yelping_since_year ORDER BY COUNT(tips.tip_length) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the years since users joined Yelp, based on the length of tips they have provided. It joins the 'tips' table with the 'users' table to correlate tip lengths with user information. The results are grouped by the year users joined, ordered by the count of tips, and limited to a specified number of results."
        },
        {
            "sample_id": 3925,
            "vt": "SELECT categories.category_name FROM reviews INNER JOIN Business AS T2 ON T1.business_id = T2.business_id INNER JOIN Business_Categories AS T3 ON T2.business_id = T3.business_id INNER JOIN Categories AS T4 ON T3.category_id = T4.category_id WHERE reviews.review_length LIKE '[placeholder-type:string]' AND business.business_id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] ORDER BY reviews.review_stars LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of categories associated with businesses based on specific review criteria. It joins the 'reviews' table with the 'business' table to link reviews to their respective businesses, then further joins with the 'business_categories' and 'categories' tables to access category names. The query filters reviews based on their length and limits the results to a specified range of business IDs, ordering them by review stars."
        },
        {
            "sample_id": 3830,
            "vt": "SELECT COUNT(compliments.compliment_type) FROM users_compliments INNER JOIN Compliments AS T2 ON T1.compliment_id = T2.compliment_id WHERE users_compliments.user_id = [placeholder-type:numeric] AND compliments.compliment_type LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of compliments of a specific type received by a user from the 'users_compliments' table, joining it with the 'compliments' table to filter by compliment type. The placeholders represent the user ID and the compliment type to be counted."
        },
        {
            "sample_id": 3797,
            "vt": "SELECT COUNT(users.user_id) FROM users WHERE users.user_id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND users.user_fans LIKE '[placeholder-type:string]' AND users.user_review_count LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users from the 'users' table who have a user ID within a specified range, and also meet certain conditions regarding their number of fans and review count. The placeholders represent the range of user IDs and the specific criteria for fans and review counts."
        },
        {
            "sample_id": 3998,
            "vt": "SELECT COUNT(users.user_id) FROM users INNER JOIN Users_Compliments AS T2 ON T1.user_id = T2.user_id INNER JOIN Compliments AS T3 ON T2.compliment_id = T3.compliment_id INNER JOIN Reviews AS T4 ON T1.user_id = T4.user_id WHERE compliments.compliment_type = '[placeholder-type:string]' AND reviews.review_votes_cool = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users who have received a specific type of compliment and have a certain number of cool votes on their reviews. It joins the 'users', 'users_compliments', 'compliments', and 'reviews' tables to filter users based on the compliment type and the cool votes they received."
        },
        {
            "sample_id": 3976,
            "vt": "SELECT business.business_id, business.active, users.user_id, users.user_yelping_since_year FROM business INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id INNER JOIN Users AS T3 ON T2.user_id = T3.user_id WHERE reviews.review_votes_cool = '[placeholder-type:string]' AND reviews.review_votes_funny = '[placeholder-type:string]' AND reviews.review_length = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the business ID, active status, user ID, and the year the user joined Yelp from the 'business' and 'users' tables. It joins these tables with the 'reviews' table to filter based on the number of cool votes, funny votes, and the length of the reviews using placeholders for specific values."
        },
        {
            "sample_id": 3874,
            "vt": "SELECT reviews.user_id FROM reviews INNER JOIN Business AS T2 ON T1.business_id = T2.business_id WHERE business.state LIKE '[placeholder-type:string]' GROUP BY reviews.user_id ORDER BY COUNT(reviews.user_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique user IDs from the 'reviews' table for businesses located in a specific state. It joins the 'reviews' table with the 'business' table to filter the results based on the state of the business. The results are grouped by user ID and ordered by the count of reviews each user has written, limiting the output to a specified number of users."
        },
        {
            "sample_id": 3972,
            "vt": "SELECT elite.year_id FROM elite WHERE elite.year_id IN ([placeholder-type:numeric], [placeholder-type:numeric]) GROUP BY elite.year_id ORDER BY COUNT(elite.user_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique year identifiers from the 'elite' table for users who have been active in specific years. It filters the results based on a list of year IDs provided as placeholders, groups the results by year, and orders them by the count of users associated with each year. The result is limited to a specified number of entries."
        },
        {
            "sample_id": 4044,
            "vt": "SELECT COUNT(reviews.business_id) FROM business WHERE reviews.business_id IN (SELECT DISTINCT business.business_id FROM Business AS T1 INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE T1.state = 'AZ' GROUP BY T1.business_id HAVING SUM(T2.review_stars) / COUNT(T2.user_id) < 3)",
            "ba": "The virtual table counts the number of businesses in the 'business' table that have received an average review star rating of less than 3 from users, specifically for businesses located in the state of Arizona (AZ). It uses a subquery to first identify the distinct business IDs from the 'business' table that meet this criterion, and then counts how many such businesses exist."
        },
        {
            "sample_id": 3888,
            "vt": "SELECT categories.category_name FROM reviews INNER JOIN Business AS T2 ON T1.business_id = T2.business_id INNER JOIN Business_Categories AS T3 ON T2.business_id = T3.business_id INNER JOIN Categories AS T4 ON T3.category_id = T4.category_id WHERE reviews.review_length LIKE '[placeholder-type:string]' AND business.business_id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] ORDER BY reviews.review_stars LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of categories associated with businesses based on specific review criteria. It joins the 'reviews' table with the 'business' table to link reviews to their respective businesses, then further joins with the 'business_categories' and 'categories' tables to access category names. The query filters reviews based on their length and limits the results based on the business ID range and a specified number of results to return."
        },
        {
            "sample_id": 3988,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.city = '[placeholder-type:string]' AND business.stars > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of businesses located in a specific city that have a star rating greater than a specified value. The placeholders represent the city name and the minimum star rating."
        },
        {
            "sample_id": 3873,
            "vt": "SELECT COUNT((SELECT T1.user_id FROM Users AS T1 INNER JOIN Elite AS T2 ON T1.user_id = T2.user_id INNER JOIN Reviews AS T3 ON T1.user_id = T3.user_id WHERE NOT T3.user_id IS NULL GROUP BY T3.user_id HAVING COUNT(T3.user_id) > 10).user_id) FROM (SELECT users.user_id FROM Users AS T1 INNER JOIN Elite AS T2 ON T1.user_id = T2.user_id INNER JOIN Reviews AS T3 ON T1.user_id = T3.user_id WHERE NOT T3.user_id IS NULL GROUP BY T3.user_id HAVING COUNT(T3.user_id) > 10) AS t4",
            "ba": "The virtual table counts the number of elite users who have written more than ten reviews. It does this by joining the 'Users', 'Elite', and 'Reviews' tables to filter out users who are elite and have a significant number of reviews. The final count gives insight into the number of highly active elite users in the database."
        },
        {
            "sample_id": 3854,
            "vt": "SELECT COUNT(categories.category_id) FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id WHERE categories.category_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of categories from the 'categories' table that match a specific category name. It uses an inner join with the 'business_categories' table to link categories to businesses, filtering based on the provided category name placeholder."
        },
        {
            "sample_id": 4041,
            "vt": "SELECT COUNT(users.user_id), users.user_average_stars FROM reviews INNER JOIN Users AS T2 ON T1.user_id = T2.user_id WHERE reviews.review_votes_funny = '[placeholder-type:string]' AND reviews.review_votes_useful = '[placeholder-type:string]' AND reviews.review_votes_cool = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users and their average star ratings from the 'Users' table, filtered by the number of funny, useful, and cool votes received on their reviews. The placeholders represent the specific counts of funny, useful, and cool votes that are used to filter the results."
        },
        {
            "sample_id": 3968,
            "vt": "SELECT CAST(SUM(CASE WHEN categories.category_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN categories.category_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM business_categories INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id",
            "ba": "The virtual table calculates the average of a specific numeric value from the 'business_categories' table, filtered by a given category name. It uses a conditional sum to differentiate between the specified category and others, ensuring that the average is computed correctly based on the provided category name."
        },
        {
            "sample_id": 3954,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.stars = [placeholder-type:numeric] AND business.city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses in a specific city that have a certain star rating. The placeholders represent the star rating and the city name."
        },
        {
            "sample_id": 3808,
            "vt": "SELECT categories.category_name FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id INNER JOIN Business_Hours AS T4 ON T3.business_id = T4.business_id WHERE business.city LIKE '[placeholder-type:string]' AND business_hours.opening_time < '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of categories from the 'categories' table for businesses located in a specific city that open before a certain time. It joins multiple tables to connect categories with businesses and their operating hours."
        },
        {
            "sample_id": 4012,
            "vt": "SELECT CAST(SUM(CASE WHEN users.user_fans = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(users.user_id) FROM users WHERE users.user_average_stars >= [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average fan count of users who have an average star rating above a specified threshold. It uses a conditional sum to account for users with a specific number of fans, and divides this by the total count of users meeting the star rating criteria. The placeholders represent the specific values for fan count, a multiplier, and the minimum average star rating."
        },
        {
            "sample_id": 3934,
            "vt": "SELECT business_hours.closing_time, days.day_of_week FROM business INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE business.city LIKE '[placeholder-type:string]' AND business.active LIKE '[placeholder-type:string]' AND business.stars > [placeholder-type:numeric] * (SELECT AVG(business.stars) FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE T1.city LIKE 'Scottsdale' AND T1.active LIKE 'TRUE')",
            "ba": "The virtual table provides information about the closing times of businesses located in a specific city that are currently active and have a star rating above the average star rating of businesses in Scottsdale. It includes the day of the week for which the closing time is applicable."
        },
        {
            "sample_id": 3991,
            "vt": "SELECT (SELECT COUNT(reviews.business_id) FROM Reviews GROUP BY business_id ORDER BY COUNT(business_id) DESC LIMIT 1) - (SELECT COUNT(reviews.business_id) FROM Reviews GROUP BY business_id ORDER BY COUNT(business_id) ASC LIMIT 1)",
            "ba": "The virtual table calculates the difference between the highest and lowest number of reviews received by any business. It does this by first counting the number of reviews for each business, grouping them by 'business_id', and ordering the results to find the maximum and minimum counts. The result is a single value representing the disparity in review counts among businesses."
        },
        {
            "sample_id": 3886,
            "vt": "SELECT business.business_id, business.stars FROM business INNER JOIN Business_Categories ON T1.business_id = Business_Categories.business_id INNER JOIN Categories AS T3 ON Business_Categories.category_id = T3.category_id WHERE business.active LIKE '[placeholder-type:string]' AND categories.category_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier and star rating of businesses that are currently active and belong to a specific category. The placeholders in the WHERE clause represent the status of the business and the name of the category."
        },
        {
            "sample_id": 3870,
            "vt": "SELECT business_hours.closing_time + [placeholder-type:numeric] - business_hours.opening_time FROM business_hours INNER JOIN Days AS T2 ON T1.day_id = T2.day_id INNER JOIN Business AS T3 ON T1.business_id = T3.business_id INNER JOIN Business_Categories AS T4 ON T3.business_id = T4.business_id INNER JOIN Categories AS T5 ON T4.category_id = T5.category_id WHERE days.day_of_week LIKE '[placeholder-type:string]' AND categories.category_name LIKE '[placeholder-type:string]' ORDER BY business_hours.closing_time + [placeholder-type:numeric] - business_hours.opening_time LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total time a business is open by subtracting the opening time from the closing time, with an additional placeholder for numeric adjustments. It joins multiple tables to filter results based on the day of the week and the category of the business, allowing users to specify which day and category they are interested in. The results are ordered by the calculated open time and limited to a specified number of entries."
        },
        {
            "sample_id": 3878,
            "vt": "SELECT CAST(SUM(business.stars) AS FLOAT) / COUNT(business_hours.business_id) FROM business_hours INNER JOIN Days AS T2 ON T1.day_id = T2.day_id INNER JOIN Business AS T3 ON T1.business_id = T3.business_id WHERE days.day_of_week LIKE '[placeholder-type:string]' AND business_hours.closing_time LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average star rating of businesses that are open on a specific day of the week and have a specified closing time. It does this by summing the star ratings from the 'business' table and dividing by the count of business IDs from the 'business_hours' table, filtered by the day of the week and closing time."
        },
        {
            "sample_id": 3893,
            "vt": "SELECT business.city FROM business INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE business_hours.closing_time LIKE '[placeholder-type:string]' AND business_hours.opening_time LIKE '[placeholder-type:string]' AND days.day_of_week LIKE '[placeholder-type:string]' GROUP BY business.city",
            "ba": "The virtual table retrieves the cities of businesses that have specific opening and closing times on a particular day of the week. It joins the 'business' table with 'business_hours' to filter based on the opening and closing times, and also joins with the 'days' table to specify the day of the week. The placeholders represent the respective values for closing time, opening time, and the day of the week."
        },
        {
            "sample_id": 4125,
            "vt": "SELECT DISTINCT attributes.attribute_name FROM business INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id INNER JOIN Attributes AS T3 ON T2.attribute_id = T3.attribute_id WHERE business.city = '[placeholder-type:string]' AND business.review_count = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct attribute names associated with businesses located in a specific city and having a certain review count. It joins the 'business' table with 'business_attributes' to link businesses to their attributes, and then further joins with the 'attributes' table to get the names of those attributes."
        },
        {
            "sample_id": 4134,
            "vt": "SELECT DISTINCT business.city FROM business INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE business_hours.opening_time = '[placeholder-type:string]' AND business_hours.closing_time = '[placeholder-type:string]' AND days.day_of_week = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct cities where businesses operate based on their opening and closing hours for a specific day of the week. The placeholders represent the specific opening time, closing time, and the day of the week."
        },
        {
            "sample_id": 3908,
            "vt": "SELECT CAST(COUNT(CASE WHEN elite.year_id < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(CASE WHEN elite.year_id = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE NULL END) FROM elite",
            "ba": "The virtual table calculates the ratio of the count of elite users who joined before a specified year to the count of elite users who joined in a specified year, multiplied by a given factor. The placeholders represent the year and the factor for scaling the result."
        },
        {
            "sample_id": 3964,
            "vt": "SELECT COUNT(users_compliments.number_of_compliments) FROM compliments INNER JOIN Users_Compliments AS T2 ON T1.compliment_id = T2.compliment_id WHERE compliments.compliment_type = '[placeholder-type:string]' AND users_compliments.user_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of compliments received by a specific user based on the type of compliment. It joins the 'compliments' table with the 'users_compliments' table to filter the results according to the specified compliment type and user ID."
        },
        {
            "sample_id": 4042,
            "vt": "SELECT CAST(SUM(CASE WHEN business.stars BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN business.stars BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM business INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id",
            "ba": "The virtual table calculates the average rating of businesses based on their star ratings within a specified range. It uses a conditional sum to count the number of businesses that fall within the given star rating range and divides it by the total number of businesses in that range. The query joins the 'business' table with the 'business_hours' table to ensure that only businesses with recorded hours are considered in the calculation."
        },
        {
            "sample_id": 4010,
            "vt": "SELECT DISTINCT elite.user_id FROM users INNER JOIN Elite AS T2 ON T1.user_id = T2.user_id WHERE users.user_yelping_since_year = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a distinct list of user IDs from the 'users' table who are classified as elite members based on their joining year. It filters users who joined Yelp in a specific year, using a placeholder for the year value."
        },
        {
            "sample_id": 3815,
            "vt": "SELECT COUNT(business.business_id) FROM business INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id WHERE business_attributes.attribute_value LIKE '[placeholder-type:string]' AND business.state LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses from the 'business' table that have specific attributes and are located in a certain state. It joins the 'business' table with the 'business_attributes' table to filter businesses based on the attribute value and state, using placeholders for these criteria."
        },
        {
            "sample_id": 4055,
            "vt": "SELECT DISTINCT business_hours.day_id FROM business_hours WHERE business_hours.opening_time = '[placeholder-type:string]' AND business_hours.closing_time = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct day identifiers from the 'business_hours' table where the opening and closing times match specified values. This allows users to identify which days a business operates during specific hours."
        },
        {
            "sample_id": 3999,
            "vt": "SELECT COUNT(*) FROM business WHERE business_attributes.business_id IN (SELECT business.business_id FROM Business AS T1 INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id WHERE T1.active = 'false' GROUP BY T1.business_id HAVING COUNT(DISTINCT T2.attribute_id) > 10)",
            "ba": "The virtual table counts the number of businesses that have more than 10 distinct attributes and are currently inactive. It does this by first selecting the business IDs from the 'business' table where the business is marked as inactive. Then, it joins this with the 'business_attributes' table to filter those businesses that have more than 10 distinct attributes associated with them."
        },
        {
            "sample_id": 4068,
            "vt": "SELECT categories.category_name FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Tips AS T3 ON T2.business_id = T3.business_id WHERE tips.user_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of categories associated with businesses that have received tips from a specific user. It joins the 'categories' table with the 'business_categories' table to link categories to businesses, and then further joins with the 'tips' table to filter results based on the user who provided the tips."
        },
        {
            "sample_id": 3839,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.city LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses located in a specific city from the 'business' table. The placeholder in the WHERE clause represents the name of the city."
        },
        {
            "sample_id": 4085,
            "vt": "SELECT reviews.user_id, reviews.review_length FROM users INNER JOIN Reviews AS T2 ON T1.user_id = T2.user_id WHERE users.user_yelping_since_year = [placeholder-type:numeric] AND users.user_average_stars = [placeholder-type:numeric]",
            "ba": "The virtual table describes the user IDs and the lengths of their reviews from the 'Reviews' table, filtered by users who joined Yelp in a specific year and have a certain average star rating. The placeholders represent the year the user joined and their average star rating."
        },
        {
            "sample_id": 3897,
            "vt": "SELECT business_hours.closing_time, days.day_of_week FROM business INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE business.city LIKE '[placeholder-type:string]' AND business.active LIKE '[placeholder-type:string]' AND business.stars > [placeholder-type:numeric] * (SELECT AVG(business.stars) FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE T1.city LIKE 'Tempe' AND T1.active LIKE 'TRUE')",
            "ba": "The virtual table provides the closing times of businesses along with the corresponding day of the week. It filters businesses based on their city, active status, and ensures that the business has a star rating greater than the average star rating of businesses in a specific city that are currently active."
        },
        {
            "sample_id": 3899,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.review_count LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses from the 'business' table that have a specific review count. The placeholder in the WHERE clause represents the review count criteria."
        },
        {
            "sample_id": 4050,
            "vt": "SELECT DISTINCT categories.category_name FROM business_hours INNER JOIN Business AS T2 ON T1.business_id = T2.business_id INNER JOIN Business_Categories AS T3 ON T2.business_id = T3.business_id INNER JOIN Categories AS T4 ON T3.category_id = T4.category_id WHERE business.active = '[placeholder-type:string]' AND business.city = '[placeholder-type:string]' AND business_hours.opening_time >= '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves distinct category names from the 'categories' table for businesses that are active and located in a specific city. It filters the results based on the opening time of the business and limits the number of results returned."
        },
        {
            "sample_id": 3905,
            "vt": "SELECT business.business_id FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id INNER JOIN Reviews AS T4 ON T3.business_id = T4.business_id WHERE categories.category_name LIKE '[placeholder-type:string]' AND categories.category_id = [placeholder-type:numeric] GROUP BY business.business_id ORDER BY COUNT(reviews.user_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of businesses that belong to a specific category, filtering by the category name and ID. It joins multiple tables to connect categories with businesses and their reviews, ensuring that only businesses matching the specified criteria are included. The results are grouped by business ID and ordered by the count of reviews, with a limit on the number of results returned."
        },
        {
            "sample_id": 3948,
            "vt": "SELECT COUNT(business_categories.business_id) FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE categories.category_name = '[placeholder-type:string]' AND business.review_count = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses that belong to a specific category and have a certain number of reviews. It joins the 'categories' table with the 'business_categories' table to link categories to businesses, and then joins with the 'business' table to filter based on the review count. The placeholders represent the category name and the review count respectively."
        },
        {
            "sample_id": 3924,
            "vt": "SELECT attributes.attribute_name FROM business INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id INNER JOIN Attributes AS T3 ON T2.attribute_id = T3.attribute_id ORDER BY business.stars LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of attributes associated with businesses from the 'business' table. It joins the 'business_attributes' table to link each business with its corresponding attributes and then joins the 'attributes' table to get the attribute names. The results are ordered by the star ratings of the businesses, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 3792,
            "vt": "SELECT business_attributes.business_id FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE business.business_id < [placeholder-type:numeric] AND business.city LIKE '[placeholder-type:string]' AND attributes.attribute_name LIKE '[placeholder-type:string]' AND business_attributes.attribute_value LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the business IDs from the 'business_attributes' table by joining it with the 'attributes' and 'business' tables. It filters the results based on specific conditions: the business ID must be less than a certain numeric value, the city must match a specified string pattern, and both the attribute name and attribute value must also match specified string patterns."
        },
        {
            "sample_id": 3777,
            "vt": "SELECT COUNT(users.user_id) FROM users WHERE users.user_yelping_since_year = [placeholder-type:numeric] AND users.user_fans LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users who joined Yelp in a specific year and have a certain number of fans. The placeholders represent the year of joining and the fan count criteria."
        },
        {
            "sample_id": 4079,
            "vt": "SELECT users.user_id, users.user_yelping_since_year FROM reviews INNER JOIN Users AS T2 ON T1.user_id = T2.user_id WHERE reviews.business_id = [placeholder-type:numeric] AND reviews.review_stars = [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of user IDs and the year they joined Yelp for users who have reviewed a specific business with a certain star rating. The placeholders represent the business ID and the star rating of the review."
        },
        {
            "sample_id": 4115,
            "vt": "SELECT COUNT(business_attributes.business_id) FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE attributes.attribute_name = '[placeholder-type:string]' AND business_attributes.attribute_value IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table counts the number of businesses that possess specific attributes from the 'attributes' and 'business_attributes' tables. It filters the results based on a given attribute name and checks if the attribute values match any of the specified values."
        },
        {
            "sample_id": 3828,
            "vt": "SELECT DISTINCT business.business_id FROM reviews INNER JOIN Business AS T2 ON T1.business_id = T2.business_id WHERE business.state LIKE '[placeholder-type:string]' AND reviews.review_stars = [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a distinct list of business IDs from the 'reviews' table, filtering based on the state of the business and the star rating of the reviews. The placeholders allow users to specify the state, the desired star rating, and the limit on the number of results returned."
        },
        {
            "sample_id": 3867,
            "vt": "SELECT categories.category_name FROM business_hours INNER JOIN Days AS T2 ON T1.day_id = T2.day_id INNER JOIN Business_Categories AS T3 ON T1.business_id = T3.business_id INNER JOIN Categories AS T4 ON T4.category_id = T4.category_id WHERE business_hours.closing_time = '[placeholder-type:string]' AND days.day_of_week = '[placeholder-type:string]' GROUP BY categories.category_name",
            "ba": "The virtual table retrieves the names of categories associated with businesses that have specific closing times on particular days of the week. It joins the 'business_hours' table with the 'days' table to filter by the day of the week, and then further joins with 'business_categories' and 'categories' to get the relevant category names."
        },
        {
            "sample_id": 4076,
            "vt": "SELECT reviews.user_id, reviews.review_stars FROM reviews WHERE reviews.business_id = [placeholder-type:numeric] AND reviews.review_length = '[placeholder-type:string]'",
            "ba": "The virtual table describes the user IDs and their corresponding star ratings from the 'reviews' table for a specific business and review length. The placeholders represent the business ID and the length of the review."
        },
        {
            "sample_id": 4006,
            "vt": "SELECT COUNT(business_attributes.business_id) FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE attributes.attribute_name = '[placeholder-type:string]' AND business_attributes.attribute_value = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses that have a specific attribute based on the attribute name and its corresponding value. It joins the 'attributes' table with the 'business_attributes' table to filter the results accordingly."
        },
        {
            "sample_id": 3758,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.state LIKE '[placeholder-type:string]' AND business.stars < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of businesses located in a specific state that have a star rating below a certain threshold. The placeholders represent the state name and the star rating limit."
        },
        {
            "sample_id": 3791,
            "vt": "SELECT users_compliments.user_id FROM users_compliments WHERE compliments.compliment_id IN (SELECT compliments.compliment_id FROM Compliments WHERE compliment_type LIKE 'funny')",
            "ba": "The virtual table identifies users who have received compliments of the type 'funny' from the 'users_compliments' table. It filters the user IDs based on the compliment IDs that match the specified compliment type in the 'compliments' table."
        },
        {
            "sample_id": 4035,
            "vt": "SELECT elite.year_id FROM elite GROUP BY elite.year_id ORDER BY COUNT(elite.user_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves unique year identifiers from the 'elite' table, grouping the results by year and ordering them based on the count of users associated with each year. The placeholder in the LIMIT clause allows for specifying the maximum number of years to return."
        },
        {
            "sample_id": 3989,
            "vt": "SELECT users.user_id FROM users WHERE users.user_yelping_since_year = [placeholder-type:numeric] AND users.user_average_stars < [placeholder-type:numeric]",
            "ba": "The virtual table identifies users from the 'users' table who joined Yelp in a specific year and have an average star rating below a certain threshold. The placeholders represent the year of joining and the average star rating criteria."
        },
        {
            "sample_id": 3766,
            "vt": "SELECT categories.category_name FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id INNER JOIN Reviews AS T4 ON T3.business_id = T4.business_id WHERE reviews.review_stars = [placeholder-type:numeric] GROUP BY categories.category_name ORDER BY COUNT(categories.category_name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of categories from the 'categories' table that are associated with businesses having a specific review star rating. It joins the 'categories' table with the 'business_categories' table to link categories to businesses, and then further joins with the 'business' table to filter by business ID. Finally, it joins with the 'reviews' table to filter based on the specified review star rating. The results are grouped by category name and ordered by the count of occurrences, limited to a specified number of results."
        },
        {
            "sample_id": 4136,
            "vt": "SELECT DISTINCT business_hours.opening_time FROM business INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE business.city = '[placeholder-type:string]' AND business.review_count = '[placeholder-type:string]' AND business.active = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct opening times of businesses located in a specific city, filtered by the total number of reviews and whether the business is currently active. The placeholders represent the city name, review count, and active status of the business."
        },
        {
            "sample_id": 3767,
            "vt": "SELECT users.user_yelping_since_year FROM reviews INNER JOIN Users AS T2 ON T1.user_id = T2.user_id WHERE reviews.review_stars = [placeholder-type:numeric] GROUP BY users.user_yelping_since_year ORDER BY COUNT(reviews.review_stars) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the years since users have joined Yelp, filtered by the star ratings of their reviews. It aggregates the data to show how many users have given a specific rating, allowing for analysis of user engagement over time."
        },
        {
            "sample_id": 4096,
            "vt": "SELECT COUNT(users_compliments.user_id) FROM compliments INNER JOIN Users_Compliments AS T2 ON T1.compliment_id = T2.compliment_id WHERE compliments.compliment_type = '[placeholder-type:string]' AND users_compliments.number_of_compliments = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users who have received a specific type of compliment and have a certain number of compliments. It joins the 'compliments' table with the 'users_compliments' table to filter based on the compliment type and the number of compliments received by users."
        },
        {
            "sample_id": 4082,
            "vt": "SELECT users_compliments.user_id, users_compliments.number_of_compliments FROM compliments INNER JOIN Users_Compliments AS T2 ON T1.compliment_id = T2.compliment_id INNER JOIN Elite AS T3 ON T2.user_id = T3.user_id WHERE elite.year_id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND compliments.compliment_type = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the user IDs and the number of compliments received by users from the 'users_compliments' table. It joins the 'compliments' table to filter based on a specific compliment type and the 'elite' table to ensure that only users who are part of the elite group within a specified year range are included."
        },
        {
            "sample_id": 4024,
            "vt": "SELECT COUNT(business.business_id) FROM business_attributes INNER JOIN Business AS T2 ON T1.business_id = T2.business_id WHERE business.city = '[placeholder-type:string]' AND business_attributes.attribute_value IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table counts the number of businesses in a specific city that have certain attributes. It joins the 'business_attributes' table with the 'business' table to filter businesses based on their city and the specified attribute values."
        },
        {
            "sample_id": 3824,
            "vt": "SELECT attributes.attribute_id FROM attributes WHERE attributes.attribute_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier for attributes from the 'attributes' table based on a specified attribute name. The placeholder in the WHERE clause allows for filtering by any given attribute name."
        },
        {
            "sample_id": 4027,
            "vt": "SELECT categories.category_name FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id WHERE business_categories.business_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of categories associated with a specific business from the 'categories' table. It uses an inner join with the 'business_categories' table to link the category IDs to the corresponding business ID provided as a placeholder."
        },
        {
            "sample_id": 3784,
            "vt": "SELECT COUNT(business_attributes.business_id) FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE attributes.attribute_name LIKE '[placeholder-type:string]' AND business_attributes.attribute_value LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses that have specific attributes based on the provided attribute name and attribute value. It joins the 'attributes' table with the 'business_attributes' table to filter the results according to the specified criteria."
        },
        {
            "sample_id": 3884,
            "vt": "SELECT DISTINCT attributes.attribute_id, attributes.attribute_name FROM business INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.attribute_id INNER JOIN Attributes AS T3 ON T2.attribute_id = T3.attribute_id WHERE business.review_count = '[placeholder-type:string]' AND business.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct attribute IDs and names from the 'attributes' table, which are associated with businesses that meet specific criteria. It joins the 'business' table with 'business_attributes' to link businesses to their attributes, and filters the results based on the review count and city of the business."
        },
        {
            "sample_id": 4004,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.active = '[placeholder-type:string]' AND business.city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses from the 'business' table that are either active or inactive based on the specified status and located in a specific city. The placeholders represent the business status and city name."
        },
        {
            "sample_id": 3848,
            "vt": "SELECT COUNT(reviews.review_length) FROM reviews WHERE reviews.user_id = [placeholder-type:numeric] AND reviews.review_length LIKE '[placeholder-type:string]' AND reviews.review_votes_useful LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of reviews written by a specific user, filtered by the length of the reviews and the number of useful votes received. The placeholders represent the user ID, review length criteria, and useful vote criteria."
        },
        {
            "sample_id": 4113,
            "vt": "SELECT COUNT(DISTINCT T1.user_id) FROM users INNER JOIN Reviews AS T2 ON T1.user_id = T2.user_id WHERE users.user_votes_cool = '[placeholder-type:string]' AND reviews.review_votes_cool = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of users who have written reviews, filtering based on the number of cool votes they have received and the number of cool votes their reviews have received. The placeholders represent the specific thresholds for cool votes that users and their reviews must meet."
        },
        {
            "sample_id": 3829,
            "vt": "SELECT attributes.attribute_name FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE business_attributes.attribute_value LIKE '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of attributes from the 'attributes' table that are associated with a specific business attribute value. It uses an inner join with the 'business_attributes' table to filter the results based on the provided attribute value, allowing users to find relevant attributes for businesses that match their criteria."
        },
        {
            "sample_id": 4034,
            "vt": "SELECT reviews.business_id FROM reviews GROUP BY reviews.business_id ORDER BY COUNT(reviews.user_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique business IDs from the 'reviews' table, grouping them to count the number of reviews each business has received. It orders the results by the count of user reviews in descending order and limits the output to a specified number of businesses."
        },
        {
            "sample_id": 3823,
            "vt": "SELECT reviews.review_votes_useful FROM reviews WHERE reviews.user_id = [placeholder-type:numeric] AND reviews.business_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the number of useful votes received for reviews written by a specific user on a specific business. The placeholders represent the user ID and business ID, allowing for dynamic querying based on user input."
        },
        {
            "sample_id": 4124,
            "vt": "SELECT reviews.review_length FROM reviews WHERE reviews.user_id = [placeholder-type:numeric] AND reviews.business_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the length of reviews written by a specific user for a specific business from the 'reviews' table. The placeholders represent the user ID and business ID, allowing users to specify which user's review length they are interested in for a particular business."
        },
        {
            "sample_id": 4019,
            "vt": "SELECT DISTINCT business.city FROM business INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE reviews.review_length = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct cities from the 'business' table where businesses have reviews of a specific length. The query joins the 'business' table with the 'reviews' table to filter based on the length of the reviews, using a placeholder for the review length."
        },
        {
            "sample_id": 4052,
            "vt": "SELECT AVG(reviews.user_id) FROM business INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Reviews AS T3 ON T1.business_id = T3.business_id WHERE business.active = '[placeholder-type:string]' GROUP BY business_hours.closing_time - business_hours.opening_time HAVING SUM(business_hours.closing_time - business_hours.opening_time) < [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average user ID from the 'reviews' table for businesses that are currently active. It joins the 'business' table with 'business_hours' to determine the opening and closing times of each business. The results are grouped by the duration of business hours, and only those businesses with total operating hours less than a specified numeric value are included in the final output."
        },
        {
            "sample_id": 3842,
            "vt": "SELECT business.city FROM business ORDER BY business.review_count LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the cities where businesses are located, sorted by the total number of reviews each business has received. The placeholder in the LIMIT clause allows the user to specify how many cities they want to retrieve."
        },
        {
            "sample_id": 4131,
            "vt": "SELECT business_hours.opening_time, business_hours.closing_time FROM business INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id WHERE business.city = '[placeholder-type:string]' ORDER BY business.stars LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the opening and closing times of businesses located in a specific city. It retrieves this information by joining the 'business' table with the 'business_hours' table based on the business ID. The results are filtered by the specified city and ordered by the business ratings, with a limit on the number of results returned."
        },
        {
            "sample_id": 3799,
            "vt": "SELECT COUNT(business.business_id) FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id INNER JOIN Business_Hours AS T4 ON T3.business_id = T4.business_id WHERE business_hours.opening_time < '[placeholder-type:string]' AND categories.category_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses that belong to a specific category and are open before a certain time. It joins the 'categories', 'business_categories', 'business', and 'business_hours' tables to filter businesses based on their opening time and category name."
        },
        {
            "sample_id": 4005,
            "vt": "SELECT business_hours.opening_time FROM business_hours INNER JOIN Days AS T2 ON T1.day_id = T2.day_id WHERE business_hours.business_id = [placeholder-type:numeric] AND days.day_of_week = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the opening time of a business from the 'business_hours' table based on the specified business ID and the day of the week. The placeholders represent the business ID as a numeric value and the day of the week as a string value."
        },
        {
            "sample_id": 4059,
            "vt": "SELECT DISTINCT business_hours.opening_time, business_hours.day_id FROM business_categories INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business_Hours AS T3 ON T1.business_id = T3.business_id INNER JOIN Days AS T4 ON T3.day_id = T4.day_id WHERE categories.category_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of opening times and corresponding day IDs for businesses that belong to a specific category. It combines data from the 'business_categories', 'categories', 'business_hours', and 'days' tables to filter results based on the category name provided as a placeholder."
        },
        {
            "sample_id": 3921,
            "vt": "SELECT attributes.attribute_name FROM business INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id INNER JOIN Attributes AS T3 ON T2.attribute_id = T3.attribute_id WHERE business.review_count LIKE '[placeholder-type:string]' AND business.city LIKE '[placeholder-type:string]' GROUP BY attributes.attribute_name",
            "ba": "The virtual table retrieves the names of attributes associated with businesses that meet specific criteria. It joins the 'business' table with 'business_attributes' to link businesses to their attributes, and then further joins with the 'attributes' table to get the attribute names. The results are filtered based on the review count and city of the business, both of which are represented by placeholders for string values. The final output groups the results by attribute name to avoid duplicates."
        },
        {
            "sample_id": 3793,
            "vt": "SELECT CAST(SUM(business.stars) AS FLOAT) / COUNT(business_attributes.business_id) FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE attributes.attribute_name LIKE '[placeholder-type:string]' AND business_attributes.attribute_value LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average star rating of businesses that have a specific attribute and a specific attribute value. It does this by summing the star ratings from the 'business' table and dividing by the count of business IDs from the 'business_attributes' table that match the given attribute name and value."
        },
        {
            "sample_id": 4084,
            "vt": "SELECT business_hours.business_id, days.day_of_week FROM business INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE business.city = '[placeholder-type:string]' AND business.active = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of business IDs along with the corresponding days of the week for businesses located in a specific city that are currently active. The placeholders in the WHERE clause represent the city name and the active status of the business."
        },
        {
            "sample_id": 4087,
            "vt": "SELECT SUM(CASE WHEN business.city = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN business.city = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM business WHERE business.active = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference in sums of a certain numeric value for businesses located in a specified city, while also filtering for active businesses. The placeholders represent the city name and the numeric values to be summed."
        },
        {
            "sample_id": 4130,
            "vt": "SELECT COUNT(DISTINCT T1.business_id) FROM business INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id INNER JOIN Attributes AS T3 ON T2.attribute_id = T3.attribute_id WHERE attributes.attribute_name = '[placeholder-type:string]' AND business.review_count = '[placeholder-type:string]' AND business.active = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of businesses that have a specific attribute, a certain review count, and are currently active. It joins the 'business' table with 'business_attributes' and 'attributes' to filter based on the attribute name, review count, and active status of the business."
        },
        {
            "sample_id": 3996,
            "vt": "SELECT COUNT(business.business_id) FROM business INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE business.city = '[placeholder-type:string]' AND reviews.user_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of businesses located in a specific city that have been reviewed by a particular user. It joins the 'business' table with the 'reviews' table based on the business ID, filtering results by the specified city and user ID."
        },
        {
            "sample_id": 3949,
            "vt": "SELECT COUNT(business_attributes.business_id) FROM business_attributes INNER JOIN Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE attributes.attribute_name = '[placeholder-type:string]' AND business_attributes.attribute_value = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses that have a specific attribute based on the attribute name and its corresponding value. It joins the 'business_attributes' table with the 'attributes' table to filter the results accordingly."
        },
        {
            "sample_id": 3845,
            "vt": "SELECT business.city FROM business WHERE business.stars = [placeholder-type:numeric] GROUP BY business.city",
            "ba": "The virtual table lists the cities where businesses have received a specific star rating. The placeholder in the WHERE clause represents the star rating of the businesses."
        },
        {
            "sample_id": 3966,
            "vt": "SELECT business_attributes.attribute_value FROM business_attributes INNER JOIN Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE business_attributes.business_id = [placeholder-type:numeric] AND attributes.attribute_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the attribute value associated with a specific business from the 'business_attributes' table by joining it with the 'attributes' table. The placeholders represent the business ID and the attribute name to filter the results accordingly."
        },
        {
            "sample_id": 3838,
            "vt": "SELECT COUNT(business.business_id) FROM business INNER JOIN Checkins AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE checkins.label_time_4 LIKE '[placeholder-type:string]' AND business.state LIKE '[placeholder-type:string]' AND days.day_of_week LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses that have check-ins at a specific time on a specific day of the week and are located in a specific state. It joins the 'business' table with the 'checkins' table to filter based on check-in times, and it also joins with the 'days' table to filter based on the day of the week."
        },
        {
            "sample_id": 3796,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.review_count LIKE '[placeholder-type:string]' AND business.active LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses from the 'business' table that match specific criteria for review count and active status. The placeholders represent the values for review count and whether the business is currently active."
        },
        {
            "sample_id": 4048,
            "vt": "SELECT CAST(SUM(elite.year_id - users.user_yelping_since_year) AS FLOAT) / COUNT(users.user_id) FROM users INNER JOIN Elite AS T2 ON T1.user_id = T2.user_id",
            "ba": "The virtual table calculates the average number of years users have been on Yelp since they joined, compared to the years they have been recognized as elite users. It does this by summing the difference between the elite year and the year the user joined Yelp, and then dividing that sum by the total number of users."
        },
        {
            "sample_id": 3851,
            "vt": "SELECT COUNT(attributes.attribute_id) FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE attributes.attribute_name LIKE '[placeholder-type:string]' AND business_attributes.attribute_value LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of attributes from the 'attributes' table that match a specific attribute name and are associated with a business attribute value. The placeholders in the WHERE clause represent the attribute name and the attribute value to filter the results accordingly."
        },
        {
            "sample_id": 4011,
            "vt": "SELECT CAST(SUM(CASE WHEN reviews.review_length = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(reviews.review_length) FROM reviews WHERE reviews.review_stars = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average length of reviews for businesses that have received a specific star rating. It uses a conditional sum to account for the review lengths based on a placeholder value, and then multiplies this sum by a numeric placeholder before dividing by the count of reviews that match the specified star rating."
        },
        {
            "sample_id": 3901,
            "vt": "SELECT COUNT(business_attributes.attribute_id) FROM business_attributes WHERE business_attributes.business_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of attributes associated with a specific business from the 'business_attributes' table. The placeholder represents the unique identifier for the business."
        },
        {
            "sample_id": 3997,
            "vt": "SELECT business.city FROM business INNER JOIN Business_Categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T2.category_id = T3.category_id WHERE categories.category_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the cities of businesses that belong to a specific category. It joins the 'business' table with the 'business_categories' table to link businesses with their respective categories, and then further joins with the 'categories' table to filter by the specified category name."
        },
        {
            "sample_id": 4106,
            "vt": "SELECT COUNT(users.user_id) FROM users_compliments INNER JOIN Users AS T2 ON T1.user_id = T2.user_id WHERE users_compliments.number_of_compliments = '[placeholder-type:string]' AND users.user_fans = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users who have received a specific number of compliments and have a certain number of fans. It joins the 'users_compliments' table with the 'users' table to filter based on the number of compliments received and the number of fans each user has."
        },
        {
            "sample_id": 3941,
            "vt": "SELECT business.business_id FROM business INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE business.city LIKE '[placeholder-type:string]' AND business.active LIKE '[placeholder-type:string]' AND days.day_of_week LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of businesses from the 'business' table that are located in a specific city, are currently active, and are open on a specified day of the week. The placeholders in the WHERE clause represent the city name, the active status of the business, and the day of the week."
        },
        {
            "sample_id": 3837,
            "vt": "SELECT business_hours.closing_time - business_hours.opening_time FROM business INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id WHERE business.business_id = [placeholder-type:numeric] AND business.city LIKE '[placeholder-type:string]' AND business_hours.day_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total hours a business is open on a specific day by subtracting the opening time from the closing time. It retrieves this information from the 'business_hours' table, which is joined with the 'business' table to filter results based on the business ID and city."
        },
        {
            "sample_id": 4038,
            "vt": "SELECT business_hours.business_id FROM business_hours ORDER BY business_hours.closing_time - business_hours.opening_time LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique identifiers of businesses from the 'business_hours' table, ordered by the duration of their operating hours (calculated as closing time minus opening time). The placeholder in the LIMIT clause allows for specifying the maximum number of business IDs to return."
        },
        {
            "sample_id": 3864,
            "vt": "SELECT COUNT(business_hours.business_id) FROM business_hours INNER JOIN Days AS T2 ON T1.day_id = T2.day_id WHERE days.day_of_week LIKE '[placeholder-type:string]' AND business_hours.closing_time > '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses that have specific business hours on a given day of the week, where the closing time is later than a specified time. It joins the 'business_hours' table with the 'days' table to filter based on the day of the week."
        },
        {
            "sample_id": 4002,
            "vt": "SELECT CAST(SUM(CASE WHEN categories.category_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN categories.category_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM business_categories INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id",
            "ba": "The virtual table calculates the average of a specific numeric value from the 'business_categories' table, filtered by a given category name. It uses a conditional sum to differentiate between the specified category and others, ensuring that the average is computed correctly based on the provided category name."
        },
        {
            "sample_id": 4023,
            "vt": "SELECT DISTINCT users_compliments.user_id FROM users INNER JOIN Users_Compliments AS T2 ON T1.user_id = T2.user_id WHERE users.user_yelping_since_year = [placeholder-type:numeric] AND users_compliments.number_of_compliments = '[placeholder-type:string]'",
            "ba": "The virtual table identifies unique users who have received compliments based on their yelping history. It joins the 'users' table with the 'users_compliments' table to filter users who joined Yelp in a specific year and have a certain number of compliments."
        },
        {
            "sample_id": 3882,
            "vt": "SELECT COUNT(users.user_id) FROM users WHERE users.user_yelping_since_year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND users.user_fans LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users who joined Yelp within a specific range of years and have a certain number of fans. The placeholders represent the year range and the fan count criteria."
        },
        {
            "sample_id": 4043,
            "vt": "SELECT business_categories.business_id, categories.category_name FROM reviews INNER JOIN Business_categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T2.category_id = T3.category_id GROUP BY business_categories.business_id ORDER BY COUNT(reviews.user_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of business IDs along with their corresponding category names from the 'business_categories' and 'categories' tables. It aggregates the data by counting the number of reviews associated with each business, allowing users to see which businesses have received the most reviews, sorted in descending order. The placeholder in the LIMIT clause allows users to specify how many results they want to retrieve."
        },
        {
            "sample_id": 4069,
            "vt": "SELECT business.business_id, CAST(((SELECT COUNT(business_categories.business_id) FROM Business WHERE stars < 2) - (SELECT COUNT(business_categories.business_id) FROM Business WHERE stars > 2)) AS FLOAT) * [placeholder-type:numeric] / (SELECT COUNT(business.stars) FROM Business) FROM business_categories INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T1.business_id = T3.business_id WHERE categories.category_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted score based on the number of businesses in a specific category that have low and high star ratings. It selects the business ID and computes the difference between the count of businesses with star ratings less than 2 and those with star ratings greater than 2, multiplies this difference by a numeric placeholder, and divides it by the total count of businesses. The filtering is done based on a specific category name."
        },
        {
            "sample_id": 3872,
            "vt": "SELECT COUNT(users.user_id) FROM users INNER JOIN Elite AS T2 ON T1.user_id = T2.user_id INNER JOIN Reviews AS T3 ON T1.user_id = T3.user_id WHERE reviews.business_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users who are elite members and have written reviews for a specific business. It joins the 'users' table with the 'elite' table to filter elite users and then joins with the 'reviews' table to ensure that these users have submitted reviews for the specified business."
        },
        {
            "sample_id": 4018,
            "vt": "SELECT business_hours.opening_time, business_hours.closing_time FROM business_hours WHERE business_hours.business_id = [placeholder-type:numeric] AND business_hours.day_id = [placeholder-type:numeric]",
            "ba": "The virtual table provides the opening and closing times of a specific business on a particular day of the week from the 'business_hours' table. The placeholders represent the unique identifiers for the business and the day."
        },
        {
            "sample_id": 4017,
            "vt": "SELECT COUNT(business_attributes.business_id) FROM business_attributes WHERE business_attributes.attribute_value IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table counts the number of businesses that have specific attributes from the 'business_attributes' table. The placeholders represent the attribute values that are being queried."
        },
        {
            "sample_id": 4072,
            "vt": "SELECT AVG(users.user_id) FROM users WHERE users.user_yelping_since_year >= [placeholder-type:numeric] AND users.user_yelping_since_year <= [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average user ID from the 'users' table for users who joined Yelp within a specific range of years. The placeholders represent the start and end years for filtering the users."
        },
        {
            "sample_id": 3911,
            "vt": "SELECT CAST(COUNT(reviews.user_id) AS FLOAT) / COUNT(DISTINCT T1.business_id) FROM reviews INNER JOIN Elite AS T2 ON T1.user_id = T2.user_id",
            "ba": "The virtual table calculates the average number of reviews per business for elite users. It does this by counting the total number of reviews made by elite users and dividing it by the number of distinct businesses they have reviewed."
        },
        {
            "sample_id": 4091,
            "vt": "SELECT DISTINCT business.state FROM business INNER JOIN Tips AS T2 ON T1.business_id = T2.business_id WHERE tips.tip_length = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves a distinct list of states where businesses are located, based on the length of tips provided for those businesses. The query joins the 'business' table with the 'tips' table to filter results according to the specified tip length."
        },
        {
            "sample_id": 3977,
            "vt": "SELECT attributes.attribute_id, business_attributes.business_id, business.city FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE attributes.attribute_name = '[placeholder-type:string]' AND business.active = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier of attributes, the business identifier, and the city of businesses that possess a specific attribute and are currently active. The placeholders in the WHERE clause represent the attribute name and the active status of the business."
        },
        {
            "sample_id": 4045,
            "vt": "SELECT CAST(((SELECT COUNT(elite.user_id) FROM Users) - (SELECT COUNT(DISTINCT user_id) FROM Elite)) AS FLOAT) * [placeholder-type:numeric] / (SELECT COUNT(elite.user_id) FROM Users)",
            "ba": "The virtual table calculates the percentage of users who are not elite users in relation to the total number of users. It does this by counting the total number of users and subtracting the count of distinct elite users, then multiplying by a placeholder for a numeric value and dividing by the total number of users."
        },
        {
            "sample_id": 3776,
            "vt": "SELECT COUNT(users.user_id) FROM users WHERE users.user_yelping_since_year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of users who joined Yelp in a specific year. The placeholder in the WHERE clause represents the year when users started their Yelp journey."
        },
        {
            "sample_id": 3775,
            "vt": "SELECT CAST(SUM(CASE WHEN categories.category_name LIKE '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(business_categories.business_id) - CAST(SUM(CASE WHEN categories.category_name LIKE '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(business_categories.business_id) FROM business_categories INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id",
            "ba": "The virtual table calculates a weighted average based on the category names from the 'categories' table and the associated business categories. It sums up values conditionally based on whether the category name matches a specified string, and then adjusts this sum by a numeric placeholder, dividing it by the count of business IDs to derive an average. This allows for analysis of business performance or characteristics based on specific categories."
        },
        {
            "sample_id": 3846,
            "vt": "SELECT COUNT(reviews.review_length) FROM reviews WHERE reviews.user_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of reviews written by a specific user from the 'reviews' table. The placeholder in the WHERE clause represents the unique identifier of the user whose reviews are being counted."
        },
        {
            "sample_id": 4138,
            "vt": "SELECT DISTINCT business_hours.closing_time, days.day_of_week FROM business INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE business.active = '[placeholder-type:string]' AND business.city = '[placeholder-type:string]' AND business.stars > (SELECT AVG(business.stars) * [placeholder-type:numeric] FROM Business WHERE active = 'true' AND city = 'Goodyear')",
            "ba": "The virtual table provides a list of distinct closing times for businesses that are currently active in a specified city. It also includes the corresponding day of the week for each closing time. The query filters businesses based on their active status, city, and ensures that only those with a star rating above a certain average are included. The average star rating is calculated from all active businesses in a specific city, multiplied by a numeric placeholder to adjust the threshold."
        },
        {
            "sample_id": 3896,
            "vt": "SELECT CAST(SUM(CASE WHEN business.stars < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(business.stars) FROM business INNER JOIN Business_Categories ON T1.business_id = Business_Categories.business_id INNER JOIN Categories AS T3 ON Business_Categories.category_id = T3.category_id WHERE categories.category_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of business ratings based on a specified threshold for star ratings. It sums the ratings of businesses that fall below a certain star rating and applies a multiplier to this sum, then divides by the total count of businesses in a specific category. The placeholders represent the threshold for star ratings, the multiplier, and the category name."
        },
        {
            "sample_id": 3833,
            "vt": "SELECT categories.category_name FROM business_categories INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id WHERE business_categories.business_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of categories associated with a specific business from the 'business_categories' table by joining it with the 'categories' table. The placeholder in the WHERE clause represents the unique identifier of the business."
        },
        {
            "sample_id": 4000,
            "vt": "SELECT business.business_id FROM business INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id INNER JOIN Attributes AS T3 ON T2.attribute_id = T3.attribute_id WHERE business.city = '[placeholder-type:string]' AND attributes.attribute_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of businesses located in a specific city that possess a certain attribute. It joins the 'business' table with the 'business_attributes' table to link businesses with their attributes, and further joins the 'attributes' table to filter based on the attribute name."
        },
        {
            "sample_id": 3821,
            "vt": "SELECT CAST(SUM(CASE WHEN business.stars = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(business.business_id) FROM business INNER JOIN Business_Categories ON T1.business_id = Business_Categories.business_id INNER JOIN Categories AS T3 ON Business_Categories.category_id = T3.category_id WHERE business.city LIKE '[placeholder-type:string]' AND categories.category_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of business ratings based on specific criteria. It sums the ratings of businesses that match a given star rating and applies a multiplier, then divides by the total count of businesses in a specified city and category."
        },
        {
            "sample_id": 3805,
            "vt": "SELECT categories.category_name FROM reviews INNER JOIN Business AS T2 ON T1.business_id = T2.business_id INNER JOIN Business_Categories AS T3 ON T2.business_id = T3.business_id INNER JOIN Categories AS T4 ON T3.category_id = T4.category_id WHERE reviews.review_length LIKE '[placeholder-type:string]' AND business_categories.category_id BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] GROUP BY categories.category_name",
            "ba": "The virtual table retrieves the names of categories associated with reviews that meet specific criteria. It joins the 'reviews' table with the 'business' table to link reviews to businesses, then further joins with 'business_categories' to connect businesses to their respective categories. The query filters reviews based on their length and restricts the category IDs to a specified range, grouping the results by category name."
        },
        {
            "sample_id": 3856,
            "vt": "SELECT COUNT(business.business_id) FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id INNER JOIN Tips AS T4 ON T3.business_id = T4.business_id WHERE categories.category_name LIKE '[placeholder-type:string]' AND business.active LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses that belong to a specific category and are currently active. It joins the 'categories', 'business_categories', 'business', and 'tips' tables to filter businesses based on the category name and their active status."
        },
        {
            "sample_id": 4036,
            "vt": "SELECT COUNT(reviews.business_id) FROM reviews WHERE reviews.review_stars = [placeholder-type:numeric] AND reviews.review_votes_funny = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of reviews from the 'reviews' table that have a specific star rating and a specific number of funny votes. The placeholders represent the star rating and the funny votes criteria."
        },
        {
            "sample_id": 4057,
            "vt": "SELECT DISTINCT categories.category_name FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business_Hours AS T3 ON T2.business_id = T3.business_id INNER JOIN Days AS T4 ON T3.day_id = T4.day_id WHERE days.day_of_week = '[placeholder-type:string]' AND business_hours.opening_time <> '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct category names from the 'categories' table for businesses that are open on a specific day of the week. It joins the 'business_categories' table to link businesses with their respective categories, and the 'business_hours' table to check the opening times of these businesses. The query filters results based on the specified day of the week and ensures that the opening time is not equal to a placeholder value, indicating that the business is indeed open."
        },
        {
            "sample_id": 3926,
            "vt": "SELECT COUNT(business.business_id) FROM business INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id INNER JOIN Attributes AS T3 ON T2.attribute_id = T3.attribute_id WHERE attributes.attribute_name LIKE '[placeholder-type:string]' AND business.active LIKE '[placeholder-type:string]' AND business.review_count LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses that have specific attributes, are currently active, and meet a certain review count criteria. It joins the 'business' table with 'business_attributes' and 'attributes' to filter based on the attribute name, business status, and review count."
        },
        {
            "sample_id": 3827,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.state LIKE '[placeholder-type:string]' AND business.review_count LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses located in a specific state that have a certain number of reviews. The placeholders represent the state and the review count criteria."
        },
        {
            "sample_id": 4022,
            "vt": "SELECT COUNT(users.user_id) FROM users INNER JOIN Users_Compliments AS T2 ON T1.user_id = T2.user_id WHERE users_compliments.number_of_compliments = '[placeholder-type:string]' AND users.user_fans = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of users who have received a specific number of compliments and have a certain number of fans. It joins the 'users' table with the 'users_compliments' table to filter users based on the number of compliments they received and their fan count. The placeholders represent the specific values for the number of compliments and fans."
        },
        {
            "sample_id": 4095,
            "vt": "SELECT DISTINCT business.state FROM business_attributes INNER JOIN Business AS T2 ON T1.business_id = T2.business_id WHERE business_attributes.attribute_value = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves a distinct list of states where businesses have a specific attribute value. It joins the 'business_attributes' table with the 'business' table to filter businesses based on their attributes."
        },
        {
            "sample_id": 4003,
            "vt": "SELECT COUNT(business_categories.business_id) FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id WHERE categories.category_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses associated with a specific category from the 'categories' table. It uses an inner join with the 'business_categories' table to link categories to their respective businesses. The placeholder in the WHERE clause represents the name of the category being queried."
        },
        {
            "sample_id": 3807,
            "vt": "SELECT COUNT(users_compliments.number_of_compliments) FROM users_compliments INNER JOIN Reviews AS T2 ON T1.user_id = T2.user_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE business.city LIKE '[placeholder-type:string]' AND users_compliments.number_of_compliments LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of compliments received by users who have reviewed businesses located in a specific city. It joins the 'users_compliments' table with the 'reviews' table to link users to their reviews, and then further joins with the 'business' table to filter by the city of the business. The placeholders represent the city name and the number of compliments."
        },
        {
            "sample_id": 3834,
            "vt": "SELECT COUNT(business_categories.business_id) FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE business.city LIKE '[placeholder-type:string]' AND categories.category_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses that belong to a specific category and are located in a specified city. It joins the 'categories' table with the 'business_categories' table to link categories to businesses, and then further joins with the 'business' table to filter based on the city. The placeholders represent the city name and category name that the user can specify."
        },
        {
            "sample_id": 4008,
            "vt": "SELECT business.business_id, categories.category_name FROM business INNER JOIN Business_Categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T2.category_id = T3.category_id WHERE business.city = '[placeholder-type:string]' AND business.stars = [placeholder-type:numeric]",
            "ba": "The virtual table displays the business IDs and their corresponding category names for businesses located in a specific city with a certain star rating. The placeholders allow users to specify the city name and the star rating they are interested in."
        },
        {
            "sample_id": 3961,
            "vt": "SELECT business.business_id FROM business INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE business.city = '[placeholder-type:string]' AND reviews.review_stars = [placeholder-type:numeric] AND reviews.review_votes_funny = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of businesses located in a specific city, which have received a certain star rating in reviews and a specified number of funny votes on those reviews. The placeholders represent the city name, the star rating, and the number of funny votes."
        },
        {
            "sample_id": 3865,
            "vt": "SELECT business_hours.opening_time FROM business_hours INNER JOIN Days AS T2 ON T1.day_id = T2.day_id INNER JOIN Business AS T3 ON T1.business_id = T3.business_id WHERE days.day_of_week LIKE '[placeholder-type:string]' AND business.city LIKE '[placeholder-type:string]' AND business.active LIKE '[placeholder-type:string]' GROUP BY business_hours.opening_time",
            "ba": "The virtual table retrieves the opening times of businesses from the 'business_hours' table, filtered by the day of the week, the city where the business is located, and whether the business is currently active. The placeholders represent the specific day, city, and active status of the business."
        },
        {
            "sample_id": 3929,
            "vt": "SELECT categories.category_name FROM business INNER JOIN Business_Categories ON T1.business_id = Business_Categories.business_id INNER JOIN Categories AS T3 ON Business_Categories.category_id = T3.category_id WHERE business.active LIKE '[placeholder-type:string]' AND business.state LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of categories associated with businesses that are currently active and located in a specific state. The placeholders in the WHERE clause represent the business's active status and the state name."
        },
        {
            "sample_id": 3765,
            "vt": "SELECT SUM(CASE WHEN categories.category_name LIKE '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN categories.category_name LIKE '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id",
            "ba": "The virtual table calculates the difference between two sums based on a condition applied to the 'category_name' from the 'categories' table. It uses a placeholder for the category name to filter the results. The sums are derived from a join between the 'categories' table and the 'business_categories' table, allowing for aggregation of data related to business categories."
        },
        {
            "sample_id": 3850,
            "vt": "SELECT users.user_id FROM users WHERE users.user_fans LIKE '[placeholder-type:string]' GROUP BY users.user_id",
            "ba": "The virtual table retrieves the unique user IDs from the 'users' table where the number of fans for each user matches a specified value. The placeholder in the WHERE clause represents the number of fans that the user has."
        },
        {
            "sample_id": 3763,
            "vt": "SELECT business_attributes.attribute_value FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE business_attributes.business_id = [placeholder-type:numeric] AND attributes.attribute_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the attribute values associated with a specific business from the 'business_attributes' table, by joining it with the 'attributes' table to filter based on the attribute name. The placeholders represent the business ID and the attribute name to be searched."
        },
        {
            "sample_id": 4105,
            "vt": "SELECT COUNT(business.business_id) FROM business INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE reviews.review_votes_funny = '[placeholder-type:string]' AND business.active = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses from the 'business' table that have received a specific number of funny votes on their reviews and are currently active. The placeholders represent the criteria for funny votes and the active status of the business."
        },
        {
            "sample_id": 3898,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.city LIKE '[placeholder-type:string]' AND business.active LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses from the 'business' table that are located in a specific city and are currently active. The placeholders in the WHERE clause represent the city name and the active status of the business."
        },
        {
            "sample_id": 3953,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.active = '[placeholder-type:string]' AND business.city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses from the 'business' table that are either active or inactive based on a specified status, and located in a specific city. The placeholders represent the business status and the city name."
        },
        {
            "sample_id": 3835,
            "vt": "SELECT users_compliments.user_id FROM users_compliments INNER JOIN Compliments AS T2 ON T1.compliment_id = T2.compliment_id WHERE users_compliments.number_of_compliments LIKE '[placeholder-type:string]' AND compliments.compliment_type LIKE '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table identifies users who have received a specific number of compliments of a certain type. It retrieves the user IDs from the 'users_compliments' table and joins it with the 'compliments' table to filter based on the number of compliments and the type of compliment. The placeholders allow for dynamic input of the number of compliments and the compliment type, as well as limiting the number of results returned."
        },
        {
            "sample_id": 3947,
            "vt": "SELECT business.city FROM business INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE business_hours.closing_time = '[placeholder-type:string]' AND business_hours.opening_time = '[placeholder-type:string]' AND days.day_of_week = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the cities of businesses that have specific opening and closing times on a particular day of the week. It joins the 'business' table with 'business_hours' to access the opening and closing times, and with 'days' to filter by the day of the week."
        },
        {
            "sample_id": 3843,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.state LIKE '[placeholder-type:string]' AND business.stars > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of businesses located in a specific state that have a star rating greater than a specified value. The placeholders represent the state name and the minimum star rating for filtering the results."
        },
        {
            "sample_id": 3819,
            "vt": "SELECT business.business_id FROM business INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE business.city LIKE '[placeholder-type:string]' AND reviews.review_stars > [placeholder-type:numeric] GROUP BY business.business_id",
            "ba": "The virtual table lists the unique identifiers of businesses located in a specific city that have received a certain number of stars in their reviews. The query joins the 'business' table with the 'reviews' table to filter businesses based on their city and the star rating of their reviews. The placeholders represent the city name and the minimum star rating required."
        },
        {
            "sample_id": 3795,
            "vt": "SELECT business.business_id FROM business WHERE business.state LIKE '[placeholder-type:string]' AND business.stars = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifier of businesses from the 'business' table that are located in a specific state and have a certain star rating. The placeholders represent the state name and the star rating of the business."
        },
        {
            "sample_id": 4107,
            "vt": "SELECT compliments.compliment_type FROM users_compliments INNER JOIN Compliments AS T2 ON T1.compliment_id = T2.compliment_id GROUP BY compliments.compliment_type ORDER BY COUNT(compliments.compliment_type) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the types of compliments received by users, grouped by compliment type. It counts the occurrences of each compliment type and orders them to show the most common types first, limiting the results to a specified number."
        },
        {
            "sample_id": 4103,
            "vt": "SELECT COUNT(business_attributes.business_id) FROM business_attributes WHERE business_attributes.attribute_value > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of businesses that have a specific attribute value greater than a specified threshold. It retrieves data from the 'business_attributes' table, focusing on the 'business_id' column, and applies a condition to filter based on the 'attribute_value' using a numeric placeholder."
        },
        {
            "sample_id": 4098,
            "vt": "SELECT COUNT(business_attributes.business_id) FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE attributes.attribute_name = '[placeholder-type:string]' AND business_attributes.attribute_value = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses that have a specific attribute based on the attribute name and its corresponding value. It joins the 'attributes' table with the 'business_attributes' table to filter the results accordingly."
        },
        {
            "sample_id": 3879,
            "vt": "SELECT COUNT(business.city) FROM business WHERE business.city LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses located in a specific city from the 'business' table. The placeholder in the WHERE clause represents the name of the city."
        },
        {
            "sample_id": 3818,
            "vt": "SELECT business.city FROM business INNER JOIN Business_Categories ON T1.business_id = Business_Categories.business_id INNER JOIN Categories AS T3 ON Business_Categories.category_id = T3.category_id WHERE business.review_count LIKE '[placeholder-type:string]' AND categories.category_name LIKE '[placeholder-type:string]' GROUP BY business.city",
            "ba": "The virtual table retrieves the cities of businesses that have a specific review count and belong to a certain category. It joins the 'business' table with the 'business_categories' table and the 'categories' table to filter the results based on the specified conditions."
        },
        {
            "sample_id": 3772,
            "vt": "SELECT categories.category_name FROM tips INNER JOIN Business AS T2 ON T1.business_id = T2.business_id INNER JOIN Business_Categories AS T3 ON T2.business_id = T3.business_id INNER JOIN Categories AS T4 ON T3.category_id = T4.category_id WHERE tips.user_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of categories associated with tips made by a specific user. It joins the 'tips' table with the 'business' table to link tips to businesses, then further joins with the 'business_categories' table to find the categories related to those businesses, and finally joins with the 'categories' table to get the actual category names."
        },
        {
            "sample_id": 3912,
            "vt": "SELECT users.user_average_stars, COUNT(tips.likes) FROM elite INNER JOIN Users AS T2 ON T1.user_id = T2.user_id INNER JOIN Tips AS T3 ON T3.user_id = T2.user_id GROUP BY elite.user_id HAVING COUNT(elite.user_id) > [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the average star ratings of users who are part of the elite group and counts the number of likes their tips have received. It joins the 'elite' table with the 'users' table to get user details and then further joins with the 'tips' table to aggregate the likes for each user. The results are grouped by user, and only those users who have received a certain number of elite memberships are included in the final output."
        },
        {
            "sample_id": 4127,
            "vt": "SELECT DISTINCT business.business_id, business.stars FROM business INNER JOIN Business_Categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T2.category_id = T3.category_id WHERE categories.category_name = '[placeholder-type:string]' AND business.active = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of business IDs and their corresponding star ratings from the 'business' table. It filters the results based on a specific category name and checks if the business is currently active."
        },
        {
            "sample_id": 4097,
            "vt": "SELECT business.business_id FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE attributes.attribute_name = '[placeholder-type:string]' AND business_attributes.attribute_value = '[placeholder-type:string]' AND business.state = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of businesses from the 'business' table that have specific attributes. It joins the 'attributes' table to filter by attribute name and the 'business_attributes' table to filter by attribute value. Additionally, it checks the state of the business to ensure it matches the specified state."
        },
        {
            "sample_id": 3918,
            "vt": "SELECT business.business_id FROM business WHERE business.city LIKE '[placeholder-type:string]' AND business.stars BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of businesses located in a specific city and having a star rating within a defined range. The placeholders allow users to specify the city name and the minimum and maximum star ratings they are interested in."
        },
        {
            "sample_id": 4090,
            "vt": "SELECT SUM(tips.likes) FROM business INNER JOIN Tips AS T2 ON T1.business_id = T2.business_id WHERE business.city = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of likes received by tips associated with businesses located in a specific city. It joins the 'business' table with the 'tips' table on the business ID, filtering the results based on the city provided as a placeholder."
        },
        {
            "sample_id": 4032,
            "vt": "SELECT COUNT(business_attributes.business_id) FROM business_attributes INNER JOIN Business AS T2 ON T1.business_id = T2.business_id WHERE business.city = '[placeholder-type:string]' AND business_attributes.attribute_value = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses that have a specific attribute in a given city. It joins the 'business_attributes' table with the 'business' table to filter businesses based on their city and the attribute value."
        },
        {
            "sample_id": 3862,
            "vt": "SELECT business_hours.closing_time - business_hours.opening_time FROM business_hours INNER JOIN Days AS T2 ON T1.day_id = T2.day_id WHERE days.day_of_week LIKE '[placeholder-type:string]' AND business_hours.business_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total hours a business is open by subtracting the opening time from the closing time for a specific day of the week. It retrieves this information from the 'business_hours' table, joining it with the 'days' table to filter by the day of the week. The placeholders represent the day of the week and the business ID."
        },
        {
            "sample_id": 3978,
            "vt": "SELECT CAST(SUM(CASE WHEN attributes.attribute_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(attributes.attribute_name) FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id",
            "ba": "The virtual table calculates a weighted average of a specific attribute's value from the 'attributes' table, based on a condition that checks for a specific attribute name. It sums the values of the attribute for businesses that match the specified name and divides this sum by the count of those attributes to get the average. The result is then multiplied by a placeholder numeric value, allowing for dynamic scaling of the average based on user input."
        },
        {
            "sample_id": 3841,
            "vt": "SELECT COUNT(business.business_id) FROM business WHERE business.city LIKE '[placeholder-type:string]' AND business.stars > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of businesses located in a specific city that have a star rating greater than a specified value. The placeholders represent the city name and the minimum star rating."
        },
        {
            "sample_id": 3762,
            "vt": "SELECT COUNT(business_attributes.business_id) FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE attributes.attribute_name LIKE '[placeholder-type:string]' AND business_attributes.attribute_value LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses that have specific attributes based on the provided attribute name and attribute value. It joins the 'attributes' table with the 'business_attributes' table to filter the results according to the specified criteria."
        },
        {
            "sample_id": 3871,
            "vt": "SELECT business_hours.business_id FROM business_hours INNER JOIN Days AS T2 ON T1.day_id = T2.day_id INNER JOIN Business AS T3 ON T1.business_id = T3.business_id WHERE business_hours.closing_time + [placeholder-type:numeric] - business_hours.opening_time > [placeholder-type:numeric] AND days.day_of_week LIKE '[placeholder-type:string]' GROUP BY business_hours.business_id",
            "ba": "The virtual table identifies businesses based on their operating hours. It retrieves the business IDs from the 'business_hours' table, joining it with the 'days' table to filter by the specific day of the week. The query checks if the difference between closing time and opening time exceeds a specified duration, using placeholders for numeric values. Additionally, it filters results based on the day of the week using a string placeholder. This allows users to find businesses that are open for a certain amount of time on a specific day."
        },
        {
            "sample_id": 3995,
            "vt": "SELECT COUNT(checkins.business_id) FROM days INNER JOIN Checkins AS T2 ON T1.day_id = T2.day_id WHERE days.day_of_week = '[placeholder-type:string]' AND checkins.label_time_10 = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of check-ins for businesses on a specific day of the week at a specific time. It joins the 'days' table with the 'checkins' table to filter the results based on the day of the week and the check-in time."
        },
        {
            "sample_id": 3931,
            "vt": "SELECT business_attributes.attribute_value FROM business INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id INNER JOIN Attributes AS T3 ON T2.attribute_id = T3.attribute_id WHERE business.state LIKE '[placeholder-type:string]' AND business.review_count LIKE '[placeholder-type:string]' AND business.active LIKE '[placeholder-type:string]' AND business.city LIKE '[placeholder-type:string]' AND business.stars = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the attribute values associated with businesses based on specific criteria such as state, review count, active status, city, and star rating. The placeholders in the WHERE clause allow users to specify the desired values for filtering the results."
        },
        {
            "sample_id": 3916,
            "vt": "SELECT business.business_id FROM business WHERE business.city LIKE '[placeholder-type:string]' AND business.review_count LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier of businesses from the 'business' table that are located in a specific city and have a certain number of reviews. The placeholders in the WHERE clause represent the city name and the review count criteria."
        },
        {
            "sample_id": 3804,
            "vt": "SELECT DISTINCT reviews.business_id FROM reviews INNER JOIN Business AS T2 ON T1.business_id = T2.business_id INNER JOIN Business_Categories AS T3 ON T2.business_id = T3.business_id INNER JOIN Categories AS T4 ON T3.category_id = T4.category_id WHERE business.active LIKE '[placeholder-type:string]' AND reviews.review_votes_useful LIKE '[placeholder-type:string]'",
            "ba": "The virtual table identifies distinct business IDs from the 'reviews' table that are associated with active businesses and have received a specified number of useful votes. It joins multiple tables to ensure that only businesses that meet the criteria are selected, filtering based on the active status of the business and the usefulness of the reviews."
        },
        {
            "sample_id": 3814,
            "vt": "SELECT CAST(SUM(business.stars) AS FLOAT) / COUNT(business.business_id) FROM business WHERE business.active LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average star rating of businesses that are currently active or inactive. It sums the star ratings of all businesses and divides it by the total number of businesses that match the specified active status. The placeholder in the WHERE clause represents whether the business is active or not."
        },
        {
            "sample_id": 4066,
            "vt": "SELECT business_hours.business_id FROM business_hours INNER JOIN Business_Categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T2.category_id = T3.category_id WHERE categories.category_name = '[placeholder-type:string]' AND SUBSTRING(business_hours.opening_time, -[placeholder-type:numeric], [placeholder-type:numeric]) * [placeholder-type:numeric] < [placeholder-type:numeric] AND business_hours.opening_time LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the business IDs from the 'business_hours' table, filtering based on the category name from the 'categories' table and specific conditions related to the opening time of the business. The placeholders allow for dynamic input of category names, numeric values for time calculations, and string patterns for matching opening times."
        },
        {
            "sample_id": 4071,
            "vt": "SELECT SUM(CASE WHEN business.review_count = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END), SUM(CASE WHEN business.review_count = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END), SUM(CASE WHEN business.review_count = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM business WHERE business.city = '[placeholder-type:string]' AND business.active = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total review counts of businesses located in a specific city and their active status. It uses conditional aggregation to calculate sums based on the review count, allowing for analysis of businesses with different review characteristics."
        },
        {
            "sample_id": 4110,
            "vt": "SELECT business_hours.business_id FROM business_hours INNER JOIN Days AS T2 ON T1.day_id = T2.day_id WHERE business_hours.day_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of businesses from the 'business_hours' table based on a specific day of the week. The query uses an inner join with the 'days' table to correlate the day_id, allowing for filtering of business hours according to the specified day."
        },
        {
            "sample_id": 4074,
            "vt": "SELECT elite.user_id FROM elite WHERE elite.year_id = [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the user IDs of elite users from the 'elite' table for a specific year. The placeholders represent the year and the limit on the number of results returned."
        },
        {
            "sample_id": 3809,
            "vt": "SELECT COUNT(categories.category_name) FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id INNER JOIN Business_Hours AS T4 ON T3.business_id = T4.business_id WHERE business.city LIKE '[placeholder-type:string]' AND business_hours.opening_time LIKE '[placeholder-type:string]' AND business_hours.closing_time LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of categories associated with businesses located in a specific city that have defined opening and closing hours. The placeholders represent the city name, opening time, and closing time."
        },
        {
            "sample_id": 4053,
            "vt": "SELECT DISTINCT business_hours.business_id FROM business_hours WHERE business_hours.opening_time = '[placeholder-type:string]' AND business_hours.closing_time = '[placeholder-type:string]'",
            "ba": "The virtual table identifies unique businesses from the 'business_hours' table that have specific opening and closing times. The placeholders represent the desired opening and closing times for filtering the results."
        },
        {
            "sample_id": 4092,
            "vt": "SELECT SUM(business_hours.closing_time - business_hours.opening_time) FROM business INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id WHERE business.city = '[placeholder-type:string]' AND business.state = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total hours that businesses are open in a specific city and state by summing the difference between their closing and opening times. It joins the 'business' table with the 'business_hours' table to access the necessary data for the calculation."
        },
        {
            "sample_id": 4099,
            "vt": "SELECT CAST(SUM(CASE WHEN attributes.attribute_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(business_attributes.business_id) FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE business_attributes.attribute_value = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of a specific attribute's value for businesses that possess that attribute. It sums the values of the attribute from the 'attributes' table, applying a condition based on the attribute name and value, and then divides by the count of businesses that have that attribute. The result is cast to a float for precision, and a multiplier is applied to adjust the final output."
        },
        {
            "sample_id": 3960,
            "vt": "SELECT SUBSTRING(business_hours.closing_time, [placeholder-type:numeric], [placeholder-type:numeric]) + [placeholder-type:numeric] - SUBSTRING(business_hours.opening_time, [placeholder-type:numeric], [placeholder-type:numeric]) FROM business_hours INNER JOIN Days AS T2 ON T1.day_id = T2.day_id WHERE days.day_of_week = '[placeholder-type:string]' AND business_hours.business_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total hours a business is open on a specific day of the week by subtracting the opening time from the closing time. It retrieves this information from the 'business_hours' table, which contains the opening and closing times for each business, and joins it with the 'days' table to filter by the day of the week. The placeholders represent the specific day of the week and the business ID."
        },
        {
            "sample_id": 4063,
            "vt": "SELECT DISTINCT business.business_id FROM categories INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business_Hours AS T3 ON T2.business_id = T3.business_id INNER JOIN Business AS T4 ON T3.business_id = T4.business_id WHERE business.active = '[placeholder-type:string]' AND business_hours.opening_time = '[placeholder-type:string]' AND business_hours.closing_time = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct business IDs from the 'business' table based on specific conditions related to categories and business hours. It filters businesses that are either active or inactive and checks their opening and closing times."
        },
        {
            "sample_id": 3852,
            "vt": "SELECT COUNT(business_attributes.business_id) FROM attributes INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE attributes.attribute_name LIKE '[placeholder-type:string]' AND business_attributes.attribute_value LIKE '[placeholder-type:string]' AND business.state LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of businesses that have a specific attribute and attribute value, filtered by the state of the business. It joins the 'attributes', 'business_attributes', and 'business' tables to gather the necessary information."
        },
        {
            "sample_id": 3825,
            "vt": "SELECT reviews.review_length FROM reviews WHERE reviews.user_id = [placeholder-type:numeric] AND reviews.review_stars = [placeholder-type:numeric] AND reviews.business_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the length of reviews written by a specific user for a particular business, filtered by the star rating given to that business."
        }
    ],
    "european_football_2": [
        {
            "sample_id": 10488,
            "vt": "SELECT DISTINCT team_attributes.buildupplaypassingclass FROM team INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE team.team_short_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of buildup play passing classes for teams from the 'team_attributes' table, filtered by the team's short name. The placeholder in the WHERE clause represents the specific team's short name that the user wants to query."
        },
        {
            "sample_id": 10484,
            "vt": "SELECT DISTINCT player.player_name FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player_attributes.overall_rating > [placeholder-type:numeric] AND SUBSTRING(player_attributes.\"date\", [placeholder-type:numeric], [placeholder-type:numeric]) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct names of players from the 'player' table who have an overall rating above a specified threshold. It joins the 'player' table with the 'player_attributes' table to filter players based on their overall rating and a specific date range. The placeholders allow users to specify the minimum rating and the start and end dates for the filtering criteria."
        },
        {
            "sample_id": 10458,
            "vt": "SELECT DISTINCT team.team_long_name FROM team_attributes INNER JOIN Team AS t4 ON t3.team_api_id = t4.team_api_id WHERE SUBSTRING(team_attributes.\"date\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND team_attributes.buildupplaypassing > (SELECT CAST(SUM(team_attributes.buildupplaypassing) AS FLOAT) / COUNT(team.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE STRFTIME('%Y', t2.\"date\") = '2012')",
            "ba": "The virtual table lists the distinct long names of teams from the 'team' table that have a specific buildup play passing score above the average of all teams for a given year. The date is filtered using a substring function, and the buildup play passing score is compared to the average calculated from the 'team_attributes' table for the year 2012."
        },
        {
            "sample_id": 10494,
            "vt": "SELECT CAST(SUM(player_attributes.overall_rating) AS FLOAT) / COUNT(player_attributes.id) FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average overall rating of a specific player by summing their overall ratings from the 'player_attributes' table and dividing it by the count of their entries. The query joins the 'player' table with the 'player_attributes' table using the player_api_id to ensure that the correct player's ratings are being averaged. The placeholder in the WHERE clause represents the name of the player whose average rating is being queried."
        },
        {
            "sample_id": 10504,
            "vt": "SELECT league.name FROM country INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of leagues from the 'league' table that are associated with a specific country. The query uses an INNER JOIN to connect the 'country' table with the 'league' table based on the country ID, filtering the results by the name of the country provided as a placeholder."
        },
        {
            "sample_id": 10454,
            "vt": "SELECT league.name, (SELECT league_id, MAX(cnt) AS max_count FROM (SELECT league_id, COUNT(id) AS cnt FROM Match GROUP BY league_id) AS subquery).max_count FROM league JOIN (SELECT league_id, MAX(cnt) AS max_count FROM (SELECT league_id, COUNT(id) AS cnt FROM Match GROUP BY league_id) AS subquery) AS t1 ON t1.league_id = t2.id",
            "ba": "The virtual table provides the name of the league along with the maximum number of matches played in that league. It aggregates the match data by counting the number of matches for each league and identifies the league with the highest match count."
        },
        {
            "sample_id": 10528,
            "vt": "SELECT player_attributes.defensive_work_rate FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTRING(player_attributes.\"date\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the defensive work rate of a player from the 'player_attributes' table by joining it with the 'player' table. The query filters results based on a specific date range and the player's name, allowing users to find the defensive work rate for a particular player on a specific date."
        },
        {
            "sample_id": 10548,
            "vt": "SELECT player.player_name FROM country INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of players who participated in matches held in a specific country. It retrieves player names by joining the 'country' table with the 'match' table to filter matches based on the country, and then joins with the 'player' table to get the names of the home players."
        },
        {
            "sample_id": 10537,
            "vt": "SELECT (SUM(CASE WHEN player.player_name = '[placeholder-type:string]' THEN player_attributes.overall_rating ELSE [placeholder-type:numeric] END) * [placeholder-type:numeric] - SUM(CASE WHEN player.player_name = '[placeholder-type:string]' THEN player_attributes.overall_rating ELSE [placeholder-type:numeric] END)) * [placeholder-type:numeric] / SUM(CASE WHEN player.player_name = '[placeholder-type:string]' THEN player_attributes.overall_rating ELSE [placeholder-type:numeric] END) FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTRING(player_attributes.\"date\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a specific metric based on the overall ratings of players from the 'player_attributes' table, filtered by a player's name and a specific date. It uses conditional aggregation to sum the overall ratings for a specified player and applies mathematical operations to derive the final value. The placeholders represent the player's name, numeric values for calculations, and a date substring for filtering."
        },
        {
            "sample_id": 10539,
            "vt": "SELECT player.player_api_id FROM player ORDER BY player.weight LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique player API IDs from the 'player' table, ordered by the players' weight. The placeholder in the LIMIT clause allows for specifying the number of player records to retrieve."
        },
        {
            "sample_id": 10474,
            "vt": "SELECT COUNT(DISTINCT t1.id) FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player.weight < [placeholder-type:numeric] AND player_attributes.preferred_foot = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct players from the 'player' table who have a weight less than a specified value and a preferred foot that matches a given string. It joins the 'player' table with the 'player_attributes' table based on the player_api_id to access the attributes of each player."
        },
        {
            "sample_id": 10547,
            "vt": "SELECT DISTINCT player.player_name FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player_attributes.finishing = [placeholder-type:numeric] ORDER BY player.birthday LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct names of players from the 'player' table who have a specific finishing score from the 'player_attributes' table. The query joins these two tables based on the player_api_id, ensuring that only players with the specified finishing score are included. The results are ordered by the players' birthdays, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 10542,
            "vt": "SELECT SUM(match.away_team_goal) FROM player INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_5 WHERE player.player_name IN ('[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table calculates the total goals scored by a specific player in the away team position 5 during matches. It joins the 'player' table with the 'match' table to filter the results based on the player's name, which is provided as a placeholder."
        },
        {
            "sample_id": 10562,
            "vt": "SELECT player_attributes.sprint_speed, player_attributes.agility, player_attributes.acceleration FROM player_attributes WHERE player_attributes.player_api_id IN (SELECT player_attributes.player_api_id FROM Player WHERE player_name = 'Alexis Blin')",
            "ba": "The virtual table provides the sprint speed, agility, and acceleration of players from the 'player_attributes' table. It filters the results to include only those players whose names match a specific player's name, represented by a placeholder."
        },
        {
            "sample_id": 10522,
            "vt": "SELECT MAX(player_attributes.overall_rating) FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum overall rating of a player from the 'player_attributes' table by joining it with the 'player' table based on the player's API ID. The query filters the results to find the player with a specific name, represented by a placeholder."
        },
        {
            "sample_id": 10506,
            "vt": "SELECT COUNT(DISTINCT t1.player_name) FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE STRFTIME('%Y', player.birthday) < '[placeholder-type:string]' AND player_attributes.defensive_work_rate = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of players from the 'player' table who have a birthday before a specified year and a specific defensive work rate. The placeholders represent the year and the defensive work rate criteria."
        },
        {
            "sample_id": 10546,
            "vt": "SELECT DISTINCT player.player_name FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player_attributes.attacking_work_rate = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct names of players from the 'player' table who have a specific attacking work rate. The query joins the 'player' table with the 'player_attributes' table to filter players based on their attacking work rate, which is represented by a placeholder for string values."
        },
        {
            "sample_id": 10475,
            "vt": "SELECT DISTINCT team.team_short_name FROM team INNER JOIN Team_attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE team_attributes.chancecreationpassingclass = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct short names of teams from the 'team' table that are associated with specific passing classes in their chance creation attributes. The placeholder in the WHERE clause represents the passing class category, which can be modified to filter teams based on their passing style."
        },
        {
            "sample_id": 10445,
            "vt": "SELECT COUNT(player_attributes.id) FROM player_attributes WHERE player_attributes.overall_rating BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND player_attributes.defensive_work_rate = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of player attributes from the 'player_attributes' table that fall within a specified range of overall ratings and have a specific defensive work rate. The placeholders represent the numeric range for overall ratings and the string value for the defensive work rate."
        },
        {
            "sample_id": 10502,
            "vt": "SELECT COUNT(player_attributes.player_api_id) FROM player_attributes WHERE player_attributes.preferred_foot = '[placeholder-type:string]' AND player_attributes.attacking_work_rate = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of players from the 'player_attributes' table who have a specific preferred foot and attacking work rate. The placeholders in the WHERE clause represent the values for the preferred foot and attacking work rate that the user can specify."
        },
        {
            "sample_id": 10450,
            "vt": "SELECT team.team_long_name FROM league INNER JOIN Match AS matchData ON leagueData.id = matchData.league_id INNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id WHERE league.name = '[placeholder-type:string]' AND match.season = '[placeholder-type:string]' AND match.away_team_goal - match.home_team_goal > [placeholder-type:numeric] GROUP BY match.away_team_api_id ORDER BY COUNT(*) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of team names from the 'team' table that have played in a specific league and season, where the away team has scored more goals than the home team by a specified margin. The query joins the 'league', 'match', and 'team' tables to filter results based on the league name and season, while also counting the number of matches for each away team that meets the goal difference condition. The results are grouped by the away team and ordered by the count of matches, with a limit on the number of teams returned."
        },
        {
            "sample_id": 10464,
            "vt": "SELECT league.name FROM league INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE match.season = '[placeholder-type:string]' GROUP BY league.name HAVING (CAST(SUM(match.home_team_goal) AS FLOAT) / COUNT(DISTINCT t2.id)) - (CAST(SUM(match.away_team_goal) AS FLOAT) / COUNT(DISTINCT t2.id)) > [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of leagues from the 'league' table, which are associated with matches in a specific season. It calculates the average goal difference for home and away teams in those matches, filtering leagues where the average home team goals exceed the average away team goals by a specified numeric threshold."
        },
        {
            "sample_id": 10553,
            "vt": "SELECT CAST(SUM(player.height) AS FLOAT) / COUNT(player.id) FROM player INNER JOIN Match AS T2 ON T1.id = T2.id INNER JOIN Country AS T3 ON T2.country_id = T3.ID WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average height of players from a specific country by summing their heights and dividing by the total number of players. It joins the 'player' table with the 'match' table to filter matches based on the country, and uses a placeholder for the country name."
        },
        {
            "sample_id": 10477,
            "vt": "SELECT player.birthday FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY player_attributes.overall_rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the birthdays of players from the 'player' table, joining it with the 'player_attributes' table to access the overall rating of each player. The results are ordered by the overall rating, allowing users to see the birthdays of players ranked by their performance. The query limits the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 10544,
            "vt": "SELECT DISTINCT player.player_name FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player_attributes.overall_rating = (SELECT MAX(player_attributes.overall_rating) FROM Player_Attributes)",
            "ba": "The virtual table retrieves the names of players who have the highest overall rating from the 'player' table, using a join with the 'player_attributes' table to access the overall rating data."
        },
        {
            "sample_id": 10554,
            "vt": "SELECT player.player_name FROM player WHERE player.height > [placeholder-type:numeric] ORDER BY player.player_name LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players from the 'player' table who have a height greater than a specified value. The results are ordered by the player's name and limited to a certain number of entries, as indicated by the placeholders."
        },
        {
            "sample_id": 10531,
            "vt": "SELECT team_attributes.buildupplaydribblingclass FROM team INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE team.team_short_name = '[placeholder-type:string]' AND SUBSTRING(team_attributes.\"date\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table describes the dribbling class of a specific team from the 'team_attributes' table based on the team's short name and a specific date. The placeholders represent the team's short name and the date components to filter the results accordingly."
        },
        {
            "sample_id": 10532,
            "vt": "SELECT team_attributes.buildupplaypassingclass FROM team INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE team.team_long_name = '[placeholder-type:string]' AND team_attributes.\"date\" LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the buildup play passing class of a specific team from the 'team_attributes' table. It retrieves this information by joining the 'team' table with the 'team_attributes' table based on the team's API ID. The placeholders in the WHERE clause represent the team's long name and a specific date, allowing users to filter results accordingly."
        },
        {
            "sample_id": 10507,
            "vt": "SELECT player.player_name, player_attributes.crossing FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player.player_name IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]') ORDER BY player_attributes.crossing LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players along with their crossing scores from the 'player' and 'player_attributes' tables. It filters the results to include only specific players whose names are provided as placeholders. The results are ordered by the crossing score, and a limit is set on the number of results returned."
        },
        {
            "sample_id": 10523,
            "vt": "SELECT CAST(SUM(match.away_team_goal) AS FLOAT) / COUNT(match.id) FROM \"match\" INNER JOIN TEAM AS T2 ON T1.away_team_api_id = T2.team_api_id INNER JOIN Country AS T3 ON T1.country_id = T3.id WHERE team.team_long_name = '[placeholder-type:string]' AND country.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average goals scored by a specific away team in matches, based on the team's long name and the country's name. It does this by summing the total away team goals and dividing by the number of matches played, using placeholders for the team and country names."
        },
        {
            "sample_id": 10550,
            "vt": "SELECT country.name FROM country INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id GROUP BY country.name ORDER BY AVG(player.weight) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of country names from the 'country' table. It joins the 'match' table to filter matches based on the country and further joins the 'player' table to include players participating in those matches. The results are grouped by country name and ordered by the average weight of players from that country, with a limit on the number of results returned."
        },
        {
            "sample_id": 10462,
            "vt": "SELECT player.player_name FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player.height > [placeholder-type:numeric] GROUP BY player.id ORDER BY CAST(SUM(player_attributes.heading_accuracy) AS FLOAT) / COUNT(player_attributes.\"player_fifa_api_id\") LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of players from the 'player' table who have a height greater than a specified value. It joins the 'player' table with the 'player_attributes' table to access player attributes, specifically calculating the average heading accuracy for each player. The results are grouped by player ID and ordered by the average heading accuracy, with a limit on the number of results returned."
        },
        {
            "sample_id": 10545,
            "vt": "SELECT DISTINCT player.player_name FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY player_attributes.potential LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct names of players from the 'player' table, joining with the 'player_attributes' table to access their potential scores. The results are ordered by the potential score, and a limit is applied to restrict the number of returned player names."
        },
        {
            "sample_id": 10552,
            "vt": "SELECT DISTINCT team.team_short_name FROM team INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE team_attributes.chancecreationpassingclass = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct short names of teams from the 'team' table that have a specific classification for their chance creation passing. This classification is determined by the 'chancecreationpassingclass' column in the 'team_attributes' table, which categorizes teams based on their passing risk during chance creation."
        },
        {
            "sample_id": 10452,
            "vt": "SELECT league.name FROM match INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE match.season = '[placeholder-type:string]' AND match.home_team_goal = match.away_team_goal GROUP BY league.name ORDER BY COUNT(match.id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of leagues from the 'match' table where the matches ended in a draw during a specific season. It joins the 'match' table with the 'league' table to retrieve the league names, grouping the results by league name and ordering them by the count of matches that ended in a draw, limited to a specified number of results."
        },
        {
            "sample_id": 10517,
            "vt": "SELECT CAST(SUM(team_attributes.buildupplayspeed) AS FLOAT) / COUNT(team_attributes.id) FROM team INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE team.team_long_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average buildup play speed of a specific team by summing the buildup play speed scores from the 'team_attributes' table and dividing it by the count of entries for that team. The team is identified by its long name, which is provided as a placeholder."
        },
        {
            "sample_id": 10478,
            "vt": "SELECT league.name FROM country INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of leagues from the 'league' table that are associated with a specific country. It uses an inner join between the 'country' and 'league' tables based on the country ID, filtering the results by the name of the country provided as a placeholder."
        },
        {
            "sample_id": 10497,
            "vt": "SELECT player.player_name FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player_attributes.potential = '[placeholder-type:string]' ORDER BY player_attributes.balance LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of players from the 'player' table who have a specific potential rating. It joins the 'player' table with the 'player_attributes' table based on the player_api_id to filter players by their potential score. The results are ordered by the players' balance scores and limited to a specified number of entries."
        },
        {
            "sample_id": 10565,
            "vt": "SELECT MAX(match.home_team_goal) FROM league INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE league.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the maximum number of goals scored by home teams in matches from a specific league. It joins the 'league' table with the 'match' table to filter results based on the league's name, represented by a placeholder."
        },
        {
            "sample_id": 10482,
            "vt": "SELECT COUNT(player.id) FROM player WHERE STRFTIME('%Y', player.birthday) > '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of players from the 'player' table who were born after a specific year. The placeholder in the WHERE clause represents the year of birth."
        },
        {
            "sample_id": 10465,
            "vt": "SELECT team.team_short_name FROM team WHERE team.team_long_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the short name of a team from the 'team' table based on its long name. The placeholder in the WHERE clause represents the long name of the team."
        },
        {
            "sample_id": 10476,
            "vt": "SELECT DISTINCT player_attributes.defensive_work_rate FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique defensive work rates of players from the 'player_attributes' table based on the player's name from the 'player' table. The placeholder in the WHERE clause represents the specific player's name."
        },
        {
            "sample_id": 10536,
            "vt": "SELECT CAST(SUM(player_attributes.overall_rating) AS FLOAT) / COUNT(player_attributes.id) FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE player.player_name = '[placeholder-type:string]' AND SUBSTRING(player_attributes.\"date\", [placeholder-type:numeric], [placeholder-type:numeric]) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average overall rating of a player based on their name and a specific date range. It joins the 'player' table with the 'player_attributes' table to access the overall ratings, filtering by the player's name and the date of the attributes."
        },
        {
            "sample_id": 10499,
            "vt": "SELECT team.team_long_name FROM team WHERE team.team_short_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the long name of a team from the 'team' table based on its short name. The placeholder in the WHERE clause represents the team's short name."
        },
        {
            "sample_id": 10490,
            "vt": "SELECT CAST(SUM(player_attributes.overall_rating) AS FLOAT) / COUNT(player_attributes.id) FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player.height > [placeholder-type:numeric] AND STRFTIME('%Y', player_attributes.\"date\") >= '[placeholder-type:string]' AND STRFTIME('%Y', player_attributes.\"date\") <= '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average overall rating of players from the 'player_attributes' table, filtered by their height and a specific date range. The placeholders represent the minimum height of the players and the start and end years for the date range."
        },
        {
            "sample_id": 10508,
            "vt": "SELECT player_attributes.heading_accuracy FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the heading accuracy of a specific player from the 'player_attributes' table by joining it with the 'player' table based on the player's API ID. The placeholder in the WHERE clause represents the name of the player whose heading accuracy is being queried."
        },
        {
            "sample_id": 10448,
            "vt": "SELECT team.team_long_name FROM match INNER JOIN Team AS teamDetails ON matchData.home_team_api_id = teamDetails.team_api_id WHERE match.season = '[placeholder-type:string]' AND match.home_team_goal - match.away_team_goal < [placeholder-type:numeric] GROUP BY match.home_team_api_id ORDER BY COUNT(*) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the long names of teams that played at home in matches from a specific season, where the home team's goals scored minus the away team's goals scored is less than a specified numeric value. The results are grouped by the home team and ordered by the count of matches played, with a limit on the number of results returned."
        },
        {
            "sample_id": 10473,
            "vt": "SELECT DISTINCT (player.player_name) FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player_attributes.potential = (SELECT MAX(player_attributes.potential) FROM Player_Attributes)",
            "ba": "The virtual table lists the distinct names of players who have the highest potential rating from the player_attributes table. It joins the player table with the player_attributes table based on the player_api_id to ensure that only players with their corresponding attributes are considered. The potential rating is determined by finding the maximum value in the potential column of the player_attributes table."
        },
        {
            "sample_id": 10446,
            "vt": "SELECT player_attributes.id FROM player_attributes ORDER BY player_attributes.crossing LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique identifiers of players from the 'player_attributes' table, sorted by their crossing score. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return."
        },
        {
            "sample_id": 10472,
            "vt": "SELECT player_attributes.preferred_foot FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY player.birthday LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the preferred foot of players from the 'player_attributes' table, joining it with the 'player' table to access player details. The results are ordered by the players' birthdays, allowing for a chronological view of players' preferred foot based on their age. The query limits the number of results returned based on a specified numeric placeholder."
        },
        {
            "sample_id": 10513,
            "vt": "SELECT COUNT(match.id) FROM league INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE league.name = '[placeholder-type:string]' AND SUBSTRING(match.\"date\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of matches from a specific league that occurred in a particular month. It joins the 'league' table with the 'match' table based on the league ID, filtering by the league name and the month extracted from the match date."
        },
        {
            "sample_id": 10511,
            "vt": "SELECT COUNT(match.id) FROM country INNER JOIN Match AS t2 ON t1.id = t2.country_id WHERE country.name = '[placeholder-type:string]' AND match.season = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of matches from the 'match' table that are associated with a specific country and season. It joins the 'country' table to filter matches based on the country's name and the specified season."
        },
        {
            "sample_id": 10570,
            "vt": "SELECT CAST(COUNT(CASE WHEN player_attributes.overall_rating > [placeholder-type:numeric] THEN player.id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(player.id) FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player.height < [placeholder-type:numeric]",
            "ba": "The virtual table calculates the percentage of players with an overall rating above a specified threshold, adjusted by a multiplier, while filtering for players below a certain height. It joins the 'player' table with the 'player_attributes' table based on the player API ID to access the necessary attributes for the calculation."
        },
        {
            "sample_id": 10456,
            "vt": "SELECT player_attributes.player_api_id FROM player_attributes WHERE SUBSTRING(player_attributes.\"date\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' ORDER BY player_attributes.overall_rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the player API IDs from the 'player_attributes' table for players whose attributes were recorded on a specific date. The date is filtered using a substring function to extract a portion of the date string, and the results are ordered by the players' overall ratings. The query limits the number of results returned based on a specified numeric placeholder."
        },
        {
            "sample_id": 10505,
            "vt": "SELECT player.player_name FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY player_attributes.overall_rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of players from the 'player' table, joined with their attributes from the 'player_attributes' table. The results are ordered by the overall rating of the players, and a limit is applied to restrict the number of players returned based on a specified numeric value."
        },
        {
            "sample_id": 10451,
            "vt": "SELECT team_attributes.buildupplayspeed FROM team_attributes INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id ORDER BY team_attributes.buildupplayspeed LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the buildup play speed of teams from the 'team_attributes' table, which is joined with the 'team' table to correlate team attributes with their respective teams. The results are ordered by the buildup play speed, and a limit is applied to restrict the number of records returned based on a specified numeric value."
        },
        {
            "sample_id": 10481,
            "vt": "SELECT player.player_name FROM player WHERE player.height > [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players from the 'player' table who have a height greater than a specified value. The placeholder in the WHERE clause represents the height threshold."
        },
        {
            "sample_id": 10519,
            "vt": "SELECT SUM(player_attributes.crossing) FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total crossing score of a specific player from the 'player_attributes' table by joining it with the 'player' table. The placeholder in the WHERE clause represents the player's name, allowing users to specify which player's crossing score they want to sum up."
        },
        {
            "sample_id": 10489,
            "vt": "SELECT DISTINCT team.team_short_name FROM team INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE team_attributes.buildupplaypassing > [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct short names of teams from the 'team' table that have a buildup play passing score greater than a specified numeric value. This is achieved by joining the 'team' table with the 'team_attributes' table on the team API ID, allowing us to filter teams based on their passing attributes."
        },
        {
            "sample_id": 10551,
            "vt": "SELECT DISTINCT team.team_long_name FROM team INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE team_attributes.buildupplayspeedclass = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct long names of teams from the 'team' table that have a specific buildup play speed class. The placeholder in the WHERE clause represents the class of buildup play speed, which categorizes teams based on how quickly they organize their attacks."
        },
        {
            "sample_id": 10560,
            "vt": "SELECT league.name FROM country WHERE league.id IN (SELECT league.country_id FROM League WHERE name = 'Poland Ekstraklasa')",
            "ba": "The virtual table lists the names of leagues from the 'country' table that are associated with a specific league identified by its name, in this case, 'Poland Ekstraklasa'. The query uses a subquery to find the country ID of the specified league and filters the results accordingly."
        },
        {
            "sample_id": 10492,
            "vt": "SELECT country.name FROM country INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE league.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of countries associated with a specific league from the 'country' table. It uses an inner join to connect the 'country' table with the 'league' table based on the country ID, filtering the results by the league's name provided as a placeholder."
        },
        {
            "sample_id": 10559,
            "vt": "SELECT CAST(COUNT(CASE WHEN player_attributes.strength > [placeholder-type:numeric] AND player_attributes.stamina > [placeholder-type:numeric] THEN player_attributes.id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(player_attributes.id) FROM player_attributes",
            "ba": "The virtual table calculates the percentage of players from the 'player_attributes' table who have both strength and stamina ratings above a specified threshold. The result is then multiplied by a placeholder value to adjust the final output. This allows users to analyze the proportion of physically strong and enduring players in relation to the total number of players."
        },
        {
            "sample_id": 10449,
            "vt": "SELECT player.player_name FROM player_attributes INNER JOIN Player AS t2 ON t1.id = t2.id ORDER BY player_attributes.penalties LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of players from the 'player' table, based on their attributes from the 'player_attributes' table. It joins these two tables on the player ID, ensuring that only players with corresponding attributes are included. The results are ordered by the players' penalties score, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 10566,
            "vt": "SELECT player_attributes.id, player_attributes.finishing, player_attributes.curve FROM player_attributes WHERE player_attributes.player_api_id = (SELECT player_attributes.player_api_id FROM Player ORDER BY weight DESC LIMIT 1) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifier, finishing score, and curve score of players from the 'player_attributes' table. It specifically filters for the player with the highest weight from the 'Player' table, and limits the results to a specified number of entries."
        },
        {
            "sample_id": 10541,
            "vt": "SELECT SUM(match.home_team_goal) FROM player INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_9 WHERE player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of goals scored by the home team in matches where a specific player, identified by their name, played as the ninth away player. The query joins the 'player' table with the 'match' table to filter the results based on the player's name."
        },
        {
            "sample_id": 10479,
            "vt": "SELECT CAST(SUM(match.home_team_goal) AS FLOAT) / COUNT(match.id) FROM country INNER JOIN Match AS t2 ON t1.id = t2.country_id WHERE country.name = '[placeholder-type:string]' AND match.season = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of goals scored by the home team in matches for a specific country and season. It does this by summing the home team goals from the 'match' table and dividing by the total number of matches played in that country and season. The placeholders represent the country name and the season for which the average is being calculated."
        },
        {
            "sample_id": 10483,
            "vt": "SELECT COUNT(player.id) FROM player WHERE player.weight > [placeholder-type:numeric] AND player.player_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of players from the 'player' table who have a weight greater than a specified value and whose names match a certain pattern. The placeholders allow users to input their desired weight and name pattern for filtering the results."
        },
        {
            "sample_id": 10561,
            "vt": "SELECT match.home_team_goal, match.away_team_goal FROM league INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE league.name = '[placeholder-type:string]' AND match.\"date\" LIKE '[placeholder-type:string]'",
            "ba": "The virtual table displays the home and away team goals from the 'match' table, filtered by a specific league name and date. The placeholders represent the league's name and the date of the match."
        },
        {
            "sample_id": 10444,
            "vt": "SELECT player_attributes.preferred_foot FROM player_attributes WHERE NOT player_attributes.potential IS NULL ORDER BY player_attributes.potential LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the preferred foot of players from the 'player_attributes' table, specifically for those players who have a defined potential score. The results are ordered by the potential score in ascending order, and a limit is applied to restrict the number of records returned based on a specified numeric value."
        },
        {
            "sample_id": 10527,
            "vt": "SELECT player_attributes.attacking_work_rate FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player_attributes.\"date\" LIKE '[placeholder-type:string]' AND player.player_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides the attacking work rate of players from the 'player_attributes' table, which is joined with the 'player' table to filter results based on a specific player's name and a date. The placeholders represent the date and player's name that can be modified to retrieve the desired data."
        },
        {
            "sample_id": 10442,
            "vt": "SELECT player_attributes.player_api_id FROM player_attributes ORDER BY player_attributes.overall_rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the player API IDs from the 'player_attributes' table, sorted by the overall rating of the players in descending order. The result is limited to a specified number of entries, allowing users to see the top-rated players based on their overall performance."
        },
        {
            "sample_id": 10496,
            "vt": "SELECT team.team_short_name FROM team INNER JOIN Match AS t2 ON t1.team_api_id = t2.home_team_api_id WHERE match.home_team_goal = [placeholder-type:numeric]",
            "ba": "The virtual table describes the short names of teams from the 'team' table that have played matches where they were the home team and scored a specific number of goals. The placeholder in the WHERE clause represents the number of goals scored by the home team in those matches."
        },
        {
            "sample_id": 10460,
            "vt": "SELECT league.name, SUM(match.home_team_goal) + SUM(match.away_team_goal) FROM league INNER JOIN Match AS t2 ON t1.id = t2.league_id GROUP BY league.name ORDER BY SUM(match.home_team_goal) + SUM(match.away_team_goal) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total goals scored in matches for each league. It retrieves the league names and calculates the sum of home and away team goals from the 'match' table, grouping the results by league name. The results are ordered by the total goals scored, and a limit is applied to restrict the number of leagues returned."
        },
        {
            "sample_id": 10469,
            "vt": "SELECT player_attributes.heading_accuracy FROM player INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE player.player_name = '[placeholder-type:string]' AND SUBSTRING(player_attributes.\"date\", [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the heading accuracy of a specific player from the 'player_attributes' table by joining it with the 'player' table. The query filters results based on the player's name and a specific date substring, allowing users to specify the player's name and the date range they are interested in."
        },
        {
            "sample_id": 10514,
            "vt": "SELECT league.name FROM league JOIN Match AS t2 ON t1.id = t2.league_id WHERE match.season = '[placeholder-type:string]' GROUP BY league.name HAVING COUNT(match.id) = (SELECT MAX(subquery_q0.match_count) FROM (SELECT COUNT(t2.id) AS match_count FROM Match AS t2 WHERE t2.season = '2008/2009' GROUP BY t2.league_id))",
            "ba": "The virtual table lists the names of leagues from the 'league' table that have the maximum number of matches played in a specified season. It joins the 'league' table with the 'match' table to filter leagues based on the number of matches in that season, using a subquery to determine the maximum match count for comparison."
        }
    ],
    "ice_hockey_draft": [
        {
            "sample_id": 6993,
            "vt": "SELECT playerinfo.playername FROM playerinfo INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE seasonstatus.team = '[placeholder-type:string]' AND seasonstatus.season = '[placeholder-type:string]' ORDER BY seasonstatus.a LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players from the 'playerinfo' table who played for a specific team during a specific season. The query joins the 'playerinfo' table with the 'seasonstatus' table to filter players based on their team and season. The placeholders represent the team name and season, while the limit specifies the maximum number of player names to return."
        },
        {
            "sample_id": 6997,
            "vt": "SELECT DISTINCT CAST(COUNT(CASE WHEN playerinfo.nation = '[placeholder-type:string]' THEN playerinfo.eliteid ELSE NULL END) OVER (PARTITION BY seasonstatus.season) AS FLOAT) * [placeholder-type:numeric] / COUNT(playerinfo.eliteid) OVER (PARTITION BY seasonstatus.season) FROM playerinfo INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE seasonstatus.season IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table calculates the percentage of players from a specific nation who participated in certain seasons, based on their elite ID. It uses a conditional count to determine how many players belong to the specified nation and divides this by the total number of players in those seasons. The result is then multiplied by a numeric placeholder to adjust the final output, providing insights into the representation of players from that nation across the selected seasons."
        },
        {
            "sample_id": 6971,
            "vt": "SELECT playerinfo.playername FROM seasonstatus INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE seasonstatus.season = '[placeholder-type:string]' ORDER BY seasonstatus.pim LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players from the 'playerinfo' table who participated in a specific season, as indicated in the 'seasonstatus' table. The query joins these two tables on the 'eliteid' to correlate player information with their seasonal performance. The placeholders represent the season of interest and the limit on the number of results to return."
        },
        {
            "sample_id": 6940,
            "vt": "SELECT (SELECT T2.PlayerName, T1.G AS Rs_G FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T2.PlayerName = 'Pavel Brendl' AND T1.SEASON = '1998-1999' AND T1.GAMETYPE = 'Regular Season').rs_g - (SELECT T2.PlayerName, T1.G AS Pf_G FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T2.PlayerName = 'Pavel Brendl' AND T1.SEASON = '1998-1999' AND T1.GAMETYPE = 'Playoffs').pf_g FROM (SELECT playerinfo.playername, seasonstatus.g FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T2.PlayerName = 'Pavel Brendl' AND T1.SEASON = '1998-1999' AND T1.GAMETYPE = 'Regular Season') AS t3 INNER JOIN (SELECT T2.PlayerName, T1.G AS Pf_G FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T2.PlayerName = 'Pavel Brendl' AND T1.SEASON = '1998-1999' AND T1.GAMETYPE = 'Playoffs') AS T4 ON T3.PlayerName = T4.PlayerName",
            "ba": "The virtual table calculates the difference in goals scored by a player during the regular season and playoffs for a specific season. It retrieves the player's name and their goals scored in both game types, allowing for a comparison of performance between the two types of games."
        },
        {
            "sample_id": 6935,
            "vt": "SELECT playerinfo.playername FROM seasonstatus INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE seasonstatus.season BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' AND seasonstatus.league = '[placeholder-type:string]' ORDER BY seasonstatus.p LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of players from the 'playerinfo' table who participated in a specific league during a defined range of seasons. The results are ordered by their points scored in the draft year, with a limit on the number of players returned."
        },
        {
            "sample_id": 6950,
            "vt": "SELECT playerinfo.playername FROM playerinfo WHERE playerinfo.overallby = '[placeholder-type:string]' AND playerinfo.draftyear = '[placeholder-type:string]' ORDER BY playerinfo.css_rank LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of players from the 'playerinfo' table who were drafted by a specific team in a particular draft year. The query includes placeholders for the team identifier and the draft year, allowing users to specify these values. Additionally, the results are ordered by the Central Scouting Service ranking, and a limit is set on the number of results returned."
        },
        {
            "sample_id": 6995,
            "vt": "SELECT playerinfo.playername FROM playerinfo INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE seasonstatus.league = '[placeholder-type:string]' AND seasonstatus.season = '[placeholder-type:string]' ORDER BY playerinfo.birthdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players from the 'playerinfo' table who participated in a specific league and season. The query joins the 'playerinfo' table with the 'seasonstatus' table to filter players based on the league and season specified by placeholders. The results are ordered by the players' birthdates and limited to a specified number of entries."
        },
        {
            "sample_id": 6991,
            "vt": "SELECT playerinfo.playername FROM playerinfo INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE seasonstatus.team = '[placeholder-type:string]' AND seasonstatus.gametype = '[placeholder-type:string]' ORDER BY seasonstatus.g LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players from the 'playerinfo' table who are part of a specific team and have played in a certain type of game during a given season. The placeholders in the WHERE clause represent the team name and game type, while the ORDER BY clause sorts the results based on the number of games played, limited by a numeric placeholder."
        },
        {
            "sample_id": 6928,
            "vt": "SELECT CAST(SUM(height_info.height_in_cm) AS FLOAT) / COUNT(playerinfo.eliteid) FROM playerinfo INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE playerinfo.position_info = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average height in centimeters of players from the 'playerinfo' table who play a specific position. It joins the 'playerinfo' table with the 'height_info' table to access height data, filtering by the player's position using a placeholder for string values."
        },
        {
            "sample_id": 6996,
            "vt": "SELECT (SELECT T1.PlayerName, T3.height_in_cm FROM PlayerInfo AS T1 INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID INNER JOIN height_info AS T3 ON T1.height = T3.height_id WHERE T2.TEAM = 'USA U20' ORDER BY T3.height_in_cm DESC).playername FROM (SELECT playerinfo.playername, height_info.height_in_cm FROM PlayerInfo AS T1 INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID INNER JOIN height_info AS T3 ON T1.height = T3.height_id WHERE T2.TEAM = 'USA U20' ORDER BY T3.height_in_cm DESC) AS t WHERE (SELECT T1.PlayerName, T3.height_in_cm FROM PlayerInfo AS T1 INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID INNER JOIN height_info AS T3 ON T1.height = T3.height_id WHERE T2.TEAM = 'USA U20' ORDER BY T3.height_in_cm DESC).height_in_cm = (SELECT MAX(height_info.height_in_cm) FROM PlayerInfo AS T1 INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID INNER JOIN height_info AS T3 ON T1.height = T3.height_id WHERE T2.TEAM = 'USA U20')",
            "ba": "The virtual table describes the player names and their heights in centimeters from the 'PlayerInfo', 'SeasonStatus', and 'height_info' tables for players belonging to the 'USA U20' team. It specifically retrieves the name of the tallest player on that team by filtering the results based on the maximum height value."
        },
        {
            "sample_id": 6962,
            "vt": "SELECT DISTINCT seasonstatus.season FROM seasonstatus INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE playerinfo.playername = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct seasons from the 'seasonstatus' table for a specific player identified by their name. It joins the 'seasonstatus' table with the 'playerinfo' table to ensure that the player's information is correctly linked to their respective seasons."
        },
        {
            "sample_id": 6986,
            "vt": "SELECT weight_info.weight_in_kg FROM playerinfo INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE playerinfo.playername = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the weight in kilograms of a specific player from the 'playerinfo' table by joining it with the 'weight_info' table based on the player's weight ID. The placeholder in the WHERE clause represents the name of the player whose weight is being queried."
        },
        {
            "sample_id": 6945,
            "vt": "SELECT playerinfo.playername FROM weight_info INNER JOIN PlayerInfo AS T2 ON T1.weight_id = T2.weight WHERE weight_info.weight_in_kg = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players from the 'playerinfo' table who have a specific weight in kilograms. The query joins the 'weight_info' table with the 'playerinfo' table based on the weight ID, allowing us to filter players by their weight."
        },
        {
            "sample_id": 6963,
            "vt": "SELECT DISTINCT seasonstatus.gametype FROM seasonstatus INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE playerinfo.playername = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct game types that a specific player has participated in, by joining the 'seasonstatus' table with the 'playerinfo' table based on the player's unique identifier. The placeholder in the WHERE clause represents the player's name."
        },
        {
            "sample_id": 6988,
            "vt": "SELECT seasonstatus.team FROM playerinfo INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE seasonstatus.season = '[placeholder-type:string]' AND playerinfo.playername = '[placeholder-type:string]'",
            "ba": "The virtual table describes the teams that players belong to during a specific season. It retrieves the team information from the 'seasonstatus' table by joining it with the 'playerinfo' table based on the unique player identifier (eliteid). The placeholders in the WHERE clause represent the specific season and the player's name."
        },
        {
            "sample_id": 6923,
            "vt": "SELECT weight_info.weight_in_kg FROM playerinfo INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE playerinfo.sum_7yr_toi = (SELECT MAX(playerinfo.sum_7yr_toi) FROM PlayerInfo AS t)",
            "ba": "The virtual table retrieves the weight in kilograms of the player who has the highest total Time on Ice (TOI) in their first seven years of NHL career. It joins the 'playerinfo' table with the 'weight_info' table based on the weight ID, ensuring that only the relevant player's weight is selected based on their TOI performance."
        },
        {
            "sample_id": 6981,
            "vt": "SELECT playerinfo.playername FROM seasonstatus INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE seasonstatus.season = '[placeholder-type:string]' AND seasonstatus.league = '[placeholder-type:string]' AND seasonstatus.gametype = '[placeholder-type:string]' ORDER BY seasonstatus.a LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players from the 'playerinfo' table who participated in a specific season, league, and game type. The query joins the 'seasonstatus' table to filter players based on their performance metrics such as assists. The placeholders represent the season, league, game type, and limit for the number of results returned."
        },
        {
            "sample_id": 6956,
            "vt": "SELECT playerinfo.birthplace FROM playerinfo WHERE playerinfo.playername = '[placeholder-type:string]'",
            "ba": "The virtual table describes the birthplace of a player from the 'playerinfo' table based on the player's name. The placeholder in the WHERE clause represents the specific player's name."
        },
        {
            "sample_id": 6927,
            "vt": "SELECT CAST(weight_info.weight_in_kg AS FLOAT) / (CAST(height_info.height_in_cm AS FLOAT) / [placeholder-type:numeric] * (CAST(height_info.height_in_cm AS FLOAT) / [placeholder-type:numeric])) FROM playerinfo INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id INNER JOIN height_info AS T3 ON T1.height = T3.height_id WHERE playerinfo.playername = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the Body Mass Index (BMI) of players by using their weight in kilograms and height in centimeters. It joins the 'playerinfo' table with 'weight_info' and 'height_info' to access the necessary data. The BMI is computed by dividing the weight by the square of the height (converted to meters). The placeholder in the WHERE clause allows for filtering by a specific player's name."
        },
        {
            "sample_id": 6941,
            "vt": "SELECT CAST(SUM(weight_info.weight_in_lbs) AS FLOAT) / COUNT(playerinfo.eliteid) FROM playerinfo INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE playerinfo.css_rank = (SELECT MAX(playerinfo.css_rank) FROM PlayerInfo)",
            "ba": "The virtual table calculates the average weight in pounds of the player with the highest Central Scouting Service (CSS) ranking. It does this by summing the weights from the 'weight_info' table and dividing by the count of players from the 'playerinfo' table who have the highest CSS rank."
        },
        {
            "sample_id": 6957,
            "vt": "SELECT weight_info.weight_in_kg FROM playerinfo INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE playerinfo.playername = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the weight in kilograms of a specific player from the 'playerinfo' table by joining it with the 'weight_info' table based on the weight ID. The placeholder in the WHERE clause represents the player's name."
        },
        {
            "sample_id": 6926,
            "vt": "SELECT playerinfo.playername FROM playerinfo INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE weight_info.weight_in_kg > [placeholder-type:numeric] AND playerinfo.shoots = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of players from the 'playerinfo' table who have a weight greater than a specified value in kilograms and have a specific shooting preference. The query joins the 'playerinfo' table with the 'weight_info' table to filter players based on their weight and shooting style."
        },
        {
            "sample_id": 6943,
            "vt": "SELECT playerinfo.playername FROM seasonstatus INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE seasonstatus.season = '[placeholder-type:string]' AND seasonstatus.league = '[placeholder-type:string]' ORDER BY seasonstatus.g LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players from the 'playerinfo' table who participated in a specific season and league. The query joins the 'seasonstatus' table to filter players based on the season and league, with placeholders for the season and league values. Additionally, it limits the results to a specified number of players based on goals scored in the draft year, sorted in ascending order."
        },
        {
            "sample_id": 6976,
            "vt": "SELECT DISTINCT playerinfo.playername FROM seasonstatus INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE seasonstatus.season = '[placeholder-type:string]' AND seasonstatus.league = '[placeholder-type:string]' ORDER BY seasonstatus.p LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct names of players from the 'playerinfo' table who participated in a specific season and league. The query joins the 'seasonstatus' table with 'playerinfo' to filter players based on the provided season and league, and it orders the results by points scored in the draft year, limiting the number of results based on a numeric placeholder."
        },
        {
            "sample_id": 6977,
            "vt": "SELECT COUNT(playerinfo.eliteid) FROM weight_info INNER JOIN PlayerInfo AS T2 ON T1.weight_id = T2.weight WHERE weight_info.weight_in_lbs = [placeholder-type:numeric] AND STRFTIME('%Y', playerinfo.birthdate) = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of players from the 'playerinfo' table who have a specific weight in pounds and were born in a specific year. It joins the 'weight_info' table with the 'playerinfo' table based on the weight ID, filtering for the specified weight and birth year."
        },
        {
            "sample_id": 6983,
            "vt": "SELECT CAST(SUM(weight_info.weight_in_lbs) AS FLOAT) / COUNT(playerinfo.eliteid) FROM weight_info INNER JOIN PlayerInfo AS T2 ON T1.weight_id = T2.weight WHERE playerinfo.overallby = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average weight in pounds of players drafted by a specific team. It does this by summing the weights from the 'weight_info' table and dividing by the count of players from the 'playerinfo' table who were drafted by that team."
        },
        {
            "sample_id": 6925,
            "vt": "SELECT COUNT(playerinfo.eliteid) FROM playerinfo INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE weight_info.weight_in_kg > [placeholder-type:numeric] AND playerinfo.shoots = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of players from the 'playerinfo' table who have a weight greater than a specified value in kilograms and have a specific shooting preference. It joins the 'playerinfo' table with the 'weight_info' table to access the weight information of each player."
        },
        {
            "sample_id": 6936,
            "vt": "SELECT playerinfo.playername FROM seasonstatus INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE seasonstatus.season = '[placeholder-type:string]' AND seasonstatus.gametype = '[placeholder-type:string]' AND seasonstatus.team = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of players from the 'playerinfo' table who participated in a specific season and game type for a particular team. The placeholders in the WHERE clause represent the season, game type, and team name."
        },
        {
            "sample_id": 6958,
            "vt": "SELECT playerinfo.playername FROM playerinfo INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE weight_info.weight_in_lbs = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players from the 'playerinfo' table who have a specific weight in pounds. The query joins the 'playerinfo' table with the 'weight_info' table using the weight ID to filter players based on their weight in pounds, represented by a placeholder for numeric values."
        },
        {
            "sample_id": 6966,
            "vt": "SELECT playerinfo.playername FROM height_info INNER JOIN PlayerInfo AS T2 ON T1.height_id = T2.height WHERE playerinfo.nation = '[placeholder-type:string]' ORDER BY height_info.height_in_cm LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players from the 'playerinfo' table who belong to a specific nation, along with their height information from the 'height_info' table. The query joins these two tables based on the height ID and filters the results by the specified nation. The results are ordered by height in centimeters and limited to a specified number of entries."
        },
        {
            "sample_id": 6989,
            "vt": "SELECT (SELECT T2.TEAM, COUNT(DISTINCT T1.ELITEID) FROM PlayerInfo AS T1 INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE T1.nation = 'Sweden' GROUP BY T2.TEAM ORDER BY COUNT(DISTINCT T1.ELITEID) DESC LIMIT 1).team FROM (SELECT seasonstatus.team, COUNT(DISTINCT T1.ELITEID) FROM PlayerInfo AS T1 INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE T1.nation = 'Sweden' GROUP BY T2.TEAM ORDER BY COUNT(DISTINCT T1.ELITEID) DESC LIMIT 1) AS t",
            "ba": "The virtual table identifies the team with the highest number of distinct players from Sweden who participated in the draft. It does this by joining the 'PlayerInfo' and 'SeasonStatus' tables on the 'eliteid' field, filtering for players from Sweden, and counting the distinct 'eliteid' for each team. The result is ordered in descending order to find the team with the most Swedish players."
        },
        {
            "sample_id": 6921,
            "vt": "SELECT COUNT(playerinfo.eliteid) FROM playerinfo INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE weight_info.weight_in_kg > [placeholder-type:numeric] AND playerinfo.position_info = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of players from the 'playerinfo' table who have a weight greater than a specified value in kilograms and play a specific position. It joins the 'playerinfo' table with the 'weight_info' table to access the weight data associated with each player."
        },
        {
            "sample_id": 6970,
            "vt": "SELECT playerinfo.playername FROM weight_info INNER JOIN PlayerInfo AS T2 ON T1.weight_id = T2.weight WHERE playerinfo.nation = '[placeholder-type:string]' ORDER BY weight_info.weight_in_lbs LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of players from the 'playerinfo' table who belong to a specific nation, while also considering their weight information from the 'weight_info' table. The query joins these two tables based on the weight ID and filters the results by the specified nation. The results are ordered by the players' weight in pounds, and a limit is applied to control the number of returned records."
        },
        {
            "sample_id": 6959,
            "vt": "SELECT playerinfo.playername FROM playerinfo INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id ORDER BY weight_info.weight_in_kg LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of players from the 'playerinfo' table who have their corresponding weight information in the 'weight_info' table. The results are ordered by the weight in kilograms, and a limit is applied to restrict the number of returned player names."
        },
        {
            "sample_id": 6922,
            "vt": "SELECT playerinfo.playername FROM playerinfo INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE weight_info.weight_in_kg > [placeholder-type:numeric] AND playerinfo.sum_7yr_gp = (SELECT MAX(playerinfo.sum_7yr_gp) FROM PlayerInfo AS T1 INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE T2.weight_in_kg > 90)",
            "ba": "The virtual table describes the names of players from the 'playerinfo' table who have a weight greater than a specified value in kilograms. It joins the 'playerinfo' table with the 'weight_info' table to filter players based on their weight. Additionally, it selects only those players who have played the maximum number of games in their first 7 years of NHL career among those who weigh more than 90 kg."
        },
        {
            "sample_id": 6969,
            "vt": "SELECT CAST(COUNT(CASE WHEN height_info.height_in_cm < [placeholder-type:numeric] AND playerinfo.nation = '[placeholder-type:string]' THEN playerinfo.eliteid ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(playerinfo.eliteid) FROM height_info INNER JOIN PlayerInfo AS T2 ON T1.height_id = T2.height",
            "ba": "The virtual table calculates the percentage of players from a specific nation whose height is below a certain value in centimeters. It does this by counting the number of players who meet the height condition and dividing it by the total number of players, then multiplying by a specified factor."
        },
        {
            "sample_id": 6985,
            "vt": "SELECT seasonstatus.gp FROM playerinfo INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE seasonstatus.season = '[placeholder-type:string]' AND playerinfo.playername = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the number of games played (gp) by a specific player during a specified season from the 'seasonstatus' table. It joins the 'playerinfo' table to link player details with their performance in that season. The placeholders represent the season and the player's name, allowing users to specify which player's game count they want to query for a particular season."
        },
        {
            "sample_id": 6965,
            "vt": "SELECT seasonstatus.p FROM seasonstatus INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE playerinfo.playername = '[placeholder-type:string]' ORDER BY seasonstatus.p LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the points scored by a specific player during their draft year from the 'seasonstatus' table. It joins the 'seasonstatus' table with the 'playerinfo' table to filter results based on the player's name. The results are ordered by points scored, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 6920,
            "vt": "SELECT COUNT(playerinfo.eliteid) FROM playerinfo INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE weight_info.weight_in_kg > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of players from the 'playerinfo' table who have a weight greater than a specified value in kilograms. It joins the 'playerinfo' table with the 'weight_info' table based on the weight ID, allowing for filtering based on the weight in kilograms."
        },
        {
            "sample_id": 6974,
            "vt": "SELECT COUNT(playerinfo.eliteid) FROM height_info INNER JOIN PlayerInfo AS T2 ON T1.height_id = T2.height WHERE playerinfo.overallby = '[placeholder-type:string]' AND height_info.height_in_cm = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of players from the 'playerinfo' table who have a specific height and were drafted by a particular team. It joins the 'height_info' table to access height details and filters based on the team that drafted the players and their height in centimeters."
        },
        {
            "sample_id": 6961,
            "vt": "SELECT DISTINCT seasonstatus.team FROM seasonstatus INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE playerinfo.playername = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of unique teams from the 'seasonstatus' table for a specific player identified by their name. It uses an inner join with the 'playerinfo' table to match the player's elite ID, ensuring that only the relevant team's information for that player is retrieved."
        },
        {
            "sample_id": 6973,
            "vt": "SELECT playerinfo.playername FROM seasonstatus INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE playerinfo.overallby = '[placeholder-type:string]' AND playerinfo.draftyear = [placeholder-type:numeric] ORDER BY seasonstatus.pim LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of players from the 'playerinfo' table who were drafted by a specific team in a given draft year. It joins the 'seasonstatus' table to filter based on the penalty minutes (pim) during the season, allowing for an ordered list of players based on their disciplinary records. The placeholders represent the team identifier, draft year, and the limit on the number of results returned."
        },
        {
            "sample_id": 6960,
            "vt": "SELECT CAST(COUNT(CASE WHEN playerinfo.nation = '[placeholder-type:string]' AND weight_info.weight_in_lbs > [placeholder-type:numeric] THEN playerinfo.eliteid ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(playerinfo.eliteid) FROM playerinfo INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id",
            "ba": "The virtual table calculates the proportion of players from a specific nation who weigh more than a certain amount in pounds. It counts the number of players meeting the criteria and divides it by the total number of players, then multiplies by a specified factor. The placeholders represent the nation, weight threshold, and multiplication factor."
        },
        {
            "sample_id": 6933,
            "vt": "SELECT COUNT(DISTINCT T1.ELITEID) FROM playerinfo INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE playerinfo.overallby = '[placeholder-type:string]' AND playerinfo.draftyear = [placeholder-type:numeric] AND seasonstatus.team = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of players from the 'playerinfo' table who were drafted by a specific team in a given draft year. It joins the 'seasonstatus' table to filter players based on the team they belong to during the season."
        },
        {
            "sample_id": 6975,
            "vt": "SELECT DISTINCT playerinfo.playername FROM seasonstatus INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE seasonstatus.season = '[placeholder-type:string]' AND seasonstatus.team = '[placeholder-type:string]' AND seasonstatus.gametype = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct names of players from the 'playerinfo' table who participated in a specific season, team, and game type. The placeholders in the WHERE clause represent the season, team, and game type for filtering the results."
        },
        {
            "sample_id": 6952,
            "vt": "SELECT COUNT(playerinfo.eliteid) FROM playerinfo WHERE playerinfo.overallby = '[placeholder-type:string]' AND playerinfo.sum_7yr_gp > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of players from the 'playerinfo' table who were drafted by a specific team and have played more than a certain number of games in their first seven years in the NHL. The placeholders represent the team identifier and the minimum number of games played."
        },
        {
            "sample_id": 6939,
            "vt": "SELECT COUNT(playerinfo.eliteid) FROM seasonstatus INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE seasonstatus.gp = [placeholder-type:numeric] AND playerinfo.shoots = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of players from the 'playerinfo' table who have participated in a specific number of games during a season, while also filtering based on their shooting preference. The placeholders represent the number of games played and the shooting preference of the players."
        }
    ],
    "movies_4": [
        {
            "sample_id": 564,
            "vt": "SELECT person.person_name FROM movie INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE movie.title = '[placeholder-type:string]' AND movie_crew.job = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of individuals who worked on a specific movie in a particular job role. It retrieves data from the 'movie' table and joins it with the 'movie_crew' table to find the corresponding crew members, filtering by the movie title and the job title."
        },
        {
            "sample_id": 484,
            "vt": "SELECT CAST(COUNT(CASE WHEN genre.genre_name = '[placeholder-type:string]' THEN movie.movie_id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(movie.movie_id) FROM movie INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN production_COUNTry AS T3 ON T1.movie_id = T3.movie_id INNER JOIN genre AS T4 ON T2.genre_id = T4.genre_id INNER JOIN COUNTry AS T5 ON T3.COUNTry_id = T5.COUNTry_id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage of movies of a specific genre produced in a specific country. It counts the number of movies that match the specified genre and divides it by the total number of movies produced in that country, multiplying the result by a numeric placeholder for scaling purposes."
        },
        {
            "sample_id": 523,
            "vt": "SELECT COUNT(movie_company.movie_id) FROM movie_company INNER JOIN production_company AS T2 ON T1.company_id = T2.company_id WHERE production_company.company_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies produced by a specific production company from the 'movie_company' table. It joins with the 'production_company' table to filter results based on the company's name, represented by a placeholder for string values."
        },
        {
            "sample_id": 517,
            "vt": "SELECT person.person_name FROM person GROUP BY person.person_name ORDER BY COUNT(person.person_name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of persons from the 'person' table, grouped by their names. It orders the results based on the count of occurrences of each name, allowing for the identification of the most common names. The placeholder in the LIMIT clause represents the maximum number of names to return."
        },
        {
            "sample_id": 494,
            "vt": "SELECT genre.genre_name FROM movie INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id WHERE movie.runtime = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of genres associated with movies from the 'movie' table that have a specific runtime. The query uses joins to connect the 'movie' table with the 'movie_genres' table and the 'genre' table, filtering results based on the runtime of the movies."
        },
        {
            "sample_id": 532,
            "vt": "SELECT genre.genre_name, MAX(movie.budget) FROM movie INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id GROUP BY genre.genre_name",
            "ba": "The virtual table displays the maximum budget of movies grouped by their genre names. It combines data from the 'movie' table and the 'genre' table through the 'movie_genres' mapping table, allowing users to see which genre has the highest budget allocated for its movies."
        },
        {
            "sample_id": 502,
            "vt": "SELECT movie.title FROM movie WHERE movie.budget = [placeholder-type:numeric] ORDER BY movie.revenue LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies from the 'movie' table that have a specific budget. The results are ordered by the revenue generated by the movies, and the number of results returned is limited to a specified amount."
        },
        {
            "sample_id": 509,
            "vt": "SELECT movie_languages.language_id FROM movie INNER JOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id ORDER BY movie.popularity LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the language IDs of movies from the 'movie' table, joining with the 'movie_languages' table to associate each movie with its respective languages. The results are ordered by the popularity of the movies, and a limit is applied to control the number of records returned based on a specified numeric value."
        },
        {
            "sample_id": 435,
            "vt": "SELECT CAST(SUM(movie.budget) AS FLOAT) / COUNT(movie.movie_id) FROM movie INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE person.person_name = '[placeholder-type:string]' AND movie_crew.job = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average budget of movies based on the contributions of a specific crew member. It joins the 'movie' table with the 'movie_crew' table to link movies with their respective crew members, and further joins with the 'person' table to filter by the name of the crew member. The placeholders represent the crew member's name and their job title."
        },
        {
            "sample_id": 477,
            "vt": "SELECT genre.genre_name FROM movie INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id WHERE movie.title = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of genres associated with a specific movie title from the 'movie' table. It joins the 'movie_genres' table to link movies with their respective genres and filters the results based on the provided movie title."
        },
        {
            "sample_id": 413,
            "vt": "SELECT movie_crew.job FROM movie INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE movie.title LIKE '[placeholder-type:string]' AND person.person_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the job titles of crew members who worked on a specific movie, identified by its title, and whose names match a specified person's name. The placeholders in the WHERE clause represent the movie title and the person's name."
        },
        {
            "sample_id": 427,
            "vt": "SELECT COUNT(movie_company.movie_id) FROM production_company INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id WHERE production_company.company_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies produced by a specific production company from the 'production_company' table. It joins the 'movie_company' table to link movies with their respective production companies. The placeholder in the WHERE clause represents the name of the production company for which the count of movies is being requested."
        },
        {
            "sample_id": 434,
            "vt": "SELECT department.department_name FROM movie INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id INNER JOIN department AS T4 ON T2.department_id = T4.department_id WHERE person.person_name = '[placeholder-type:string]' AND movie.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of departments involved in a specific movie, based on the crew members who worked on it. The placeholders in the WHERE clause represent the name of the person and the title of the movie."
        },
        {
            "sample_id": 422,
            "vt": "SELECT movie.title FROM movie WHERE movie.revenue = [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies from the 'movie' table that have a specific revenue value. The placeholder in the WHERE clause represents the revenue amount."
        },
        {
            "sample_id": 490,
            "vt": "SELECT movie_genres.genre_id FROM movie INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id WHERE movie.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the genre identifier of a movie from the 'movie_genres' table by joining it with the 'movie' table based on the movie's unique identifier. The query filters the results to find the genre of a specific movie title provided by the user."
        },
        {
            "sample_id": 421,
            "vt": "SELECT CAST(SUM(movie.revenue) AS FLOAT) / COUNT(movie.movie_id) FROM movie INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE person.person_name = '[placeholder-type:string]' AND movie_crew.job = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average revenue of movies based on the contributions of a specific crew member. It sums the revenue of all movies and divides it by the count of those movies, filtering by the crew member's name and job title."
        },
        {
            "sample_id": 473,
            "vt": "SELECT DISTINCT person.person_name FROM person INNER JOIN movie_cast AS T2 ON T1.person_id = T2.person_id WHERE movie_cast.character_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct names of persons who have played a specific character in movies. It retrieves data from the 'person' table and joins it with the 'movie_cast' table to filter based on the character's name provided as a placeholder."
        },
        {
            "sample_id": 445,
            "vt": "SELECT movie.title FROM production_company INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE production_company.company_name = '[placeholder-type:string]' ORDER BY movie.popularity LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies produced by a specific production company. It joins the 'production_company' table with the 'movie_company' table to link companies to their movies, and then further joins with the 'movie' table to access movie details. The query filters results based on the production company's name and orders the movies by their popularity, limiting the number of results returned."
        },
        {
            "sample_id": 466,
            "vt": "SELECT genre.genre_name, movie.popularity FROM movie INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id WHERE movie.revenue > [placeholder-type:numeric] AND movie.release_date BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of movie genres along with their corresponding popularity ratings from the 'movie' table. It filters the results to include only those movies that have a revenue greater than a specified numeric value and were released within a specific date range. The placeholders in the WHERE clause represent the revenue threshold and the start and end dates for the release period."
        },
        {
            "sample_id": 444,
            "vt": "SELECT DISTINCT person.person_name FROM movie INNER JOIN movie_cast AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE movie_cast.character_name = '[placeholder-type:string]' AND movie.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct names of persons who played a specific character in movies that match a certain title pattern. It combines data from the 'movie', 'movie_cast', and 'person' tables, filtering based on the character's name and the movie title."
        },
        {
            "sample_id": 491,
            "vt": "SELECT movie.title FROM movie INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id WHERE genre.genre_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of movies from the 'movie' table that belong to a specific genre. It joins the 'movie' table with the 'movie_genres' table to associate each movie with its genre, and then further joins with the 'genre' table to filter by the specified genre name."
        },
        {
            "sample_id": 412,
            "vt": "SELECT person.person_name FROM movie INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE movie.title LIKE '[placeholder-type:string]' AND movie_crew.job = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of persons who worked on a specific movie in a particular job role. It retrieves data from the 'movie' table and joins it with the 'movie_crew' table to find the relevant crew members, filtering by the movie title and job role specified by placeholders."
        },
        {
            "sample_id": 461,
            "vt": "SELECT person.person_name FROM movie_cast INNER JOIN person AS T2 ON T1.person_id = T2.person_id INNER JOIN gender AS T3 ON T1.gender_id = T3.gender_id WHERE movie_cast.movie_id = [placeholder-type:numeric] AND gender.gender = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of persons from the 'movie_cast' table who are associated with a specific movie and belong to a specified gender. The placeholders in the WHERE clause represent the movie's ID and the gender type."
        },
        {
            "sample_id": 449,
            "vt": "SELECT production_company.company_name FROM production_company INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id GROUP BY production_company.company_id HAVING COUNT(movie_company.movie_id) > [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of production companies that have produced more than a specified number of movies. It retrieves data from the 'production_company' table and joins it with the 'movie_company' table to count the number of movies associated with each company. The placeholder in the HAVING clause represents the minimum count of movies a company must have produced to be included in the results."
        },
        {
            "sample_id": 437,
            "vt": "SELECT movie.title FROM movie ORDER BY movie.budget LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies from the 'movie' table, ordered by their budget in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of movie titles to retrieve."
        },
        {
            "sample_id": 425,
            "vt": "SELECT COUNT(movie_keywords.keyword_id) FROM movie INNER JOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id WHERE movie.title = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of keywords associated with a specific movie title from the 'movie' table. The placeholder in the WHERE clause represents the title of the movie for which the keyword count is being requested."
        },
        {
            "sample_id": 555,
            "vt": "SELECT movie.title FROM production_company INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE production_company.company_name = '[placeholder-type:string]' AND CAST(STRFTIME('%Y', movie.release_date) AS INT) = [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies produced by a specific production company in a given release year. It joins the 'production_company' table with the 'movie_company' table to link companies to their movies, and then further joins with the 'movie' table to access movie details. The placeholders represent the production company's name and the release year of the movies."
        },
        {
            "sample_id": 487,
            "vt": "SELECT movie_keywords.keyword_id FROM movie INNER JOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id WHERE movie.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of keywords associated with a specific movie title from the 'movie_keywords' table, which is linked to the 'movie' table. The placeholder in the WHERE clause represents the title of the movie being queried."
        },
        {
            "sample_id": 515,
            "vt": "SELECT SUM(movie.revenue) FROM production_company INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE production_company.company_name IN ('[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table calculates the total revenue generated by movies produced by specific production companies. It joins the 'production_company' table with the 'movie_company' table to link companies to their respective movies, and then sums the revenue from the 'movie' table for the specified production companies."
        },
        {
            "sample_id": 460,
            "vt": "SELECT movie_cast.movie_id, movie_cast.character_name FROM person INNER JOIN movie_cast AS T2 ON T1.person_id = T2.person_id WHERE person.person_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the movie IDs and character names of cast members from the 'movie_cast' table who are associated with a specific person. The query uses an INNER JOIN to connect the 'person' table with the 'movie_cast' table based on the person's ID, filtering results by the person's name using a placeholder."
        },
        {
            "sample_id": 410,
            "vt": "SELECT movie.title FROM production_company INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE production_company.company_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of movies produced by a specific production company. It retrieves data from the 'production_company' table and joins it with the 'movie_company' table to link production companies with their respective movies. The final join with the 'movie' table allows access to the movie titles. The placeholder in the WHERE clause represents the name of the production company."
        },
        {
            "sample_id": 565,
            "vt": "SELECT AVG(movie.revenue), movie.title FROM movie INNER JOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id INNER JOIN keyword AS T3 ON T2.keyword_id = T3.keyword_id WHERE keyword.keyword_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average revenue of movies from the 'movie' table, displaying the title of each movie. It joins the 'movie_keywords' table to associate movies with their keywords and further joins the 'keyword' table to filter results based on a specific keyword name. The placeholder in the WHERE clause represents the keyword used for filtering."
        },
        {
            "sample_id": 416,
            "vt": "SELECT person.person_name FROM movie INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE movie.title LIKE '[placeholder-type:string]' AND movie_crew.job = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of persons who worked on a specific movie in a particular job role. It retrieves data from the 'movie' table and joins it with the 'movie_crew' table to find the relevant crew members, and then further joins with the 'person' table to get the names of those crew members. The placeholders in the WHERE clause represent the movie title and the job title."
        },
        {
            "sample_id": 452,
            "vt": "SELECT COUNT(movie.movie_id) FROM movie INNER JOIN movie_cast AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE person.person_name = '[placeholder-type:string]' AND CAST(STRFTIME('%Y', movie.release_date) AS INT) = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of movies from the 'movie' table that feature a specific person in the cast, filtered by the person's name and the year of the movie's release. The placeholders represent the person's name and the release year of the movie."
        },
        {
            "sample_id": 428,
            "vt": "SELECT COUNT(*) FROM movie INNER JOIN movie_cast AS T2 ON T1.movie_id = T2.movie_id INNER JOIN gender AS T3 ON T2.gender_id = T3.gender_id WHERE movie.title = '[placeholder-type:string]' AND gender.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cast members in a specific movie filtered by their gender. It joins the 'movie' table with the 'movie_cast' table to link movies with their respective cast members, and further joins the 'gender' table to filter the cast based on gender. The placeholders represent the movie title and the gender of the cast members."
        },
        {
            "sample_id": 432,
            "vt": "SELECT COUNT(movie_keywords.movie_id) FROM keyword INNER JOIN movie_keywords AS T2 ON T1.keyword_id = T2.keyword_id WHERE keyword.keyword_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies associated with a specific keyword from the 'keyword' table. It joins the 'keyword' table with the 'movie_keywords' table to find all movies that have a particular keyword, represented by a placeholder in the WHERE clause."
        },
        {
            "sample_id": 443,
            "vt": "SELECT production_company.company_name FROM production_company INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id GROUP BY production_company.company_id ORDER BY COUNT(movie_company.movie_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of production companies that have produced movies. It joins the 'production_company' table with the 'movie_company' table to associate each company with the movies they have produced. The results are grouped by the unique identifier of the production company, and ordered by the count of movies produced by each company. The query limits the output to a specified number of production companies."
        },
        {
            "sample_id": 528,
            "vt": "SELECT language.language_name FROM movie INNER JOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id INNER JOIN language AS T3 ON T2.language_id = T3.language_id INNER JOIN language_role AS T4 ON T2.language_role_id = T4.role_id WHERE language_role.language_role = '[placeholder-type:string]' AND movie.tagline LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of languages used in movies from the 'movie' table, specifically filtering for movies that have a certain language role and a tagline that matches a specified pattern. The placeholders allow users to specify the desired language role and tagline for their query."
        },
        {
            "sample_id": 418,
            "vt": "SELECT movie.title FROM movie INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE person.person_name = '[placeholder-type:string]' AND movie_crew.job = '[placeholder-type:string]' ORDER BY movie.vote_average LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies from the 'movie' table that have been worked on by a specific person in a specific job role. The query joins the 'movie' table with the 'movie_crew' table to link movies with their crew members, and then further joins with the 'person' table to filter by the person's name. The results are ordered by the movie's average vote and limited to a specified number of results."
        },
        {
            "sample_id": 488,
            "vt": "SELECT movie.title FROM movie INNER JOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id INNER JOIN keyword AS T3 ON T2.keyword_id = T3.keyword_id WHERE keyword.keyword_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of movies from the 'movie' table that are associated with a specific keyword. The query uses inner joins to connect the 'movie' table with the 'movie_keywords' table and the 'keyword' table, filtering results based on a specified keyword name."
        },
        {
            "sample_id": 414,
            "vt": "SELECT person.person_name FROM movie INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE movie.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of persons who worked on a specific movie from the 'movie' table. It retrieves the names by joining the 'movie' table with the 'movie_crew' table to find the crew members associated with that movie, and then joins with the 'person' table to get the actual names of those crew members. The placeholder in the WHERE clause represents the title of the movie being queried."
        },
        {
            "sample_id": 448,
            "vt": "SELECT COUNT(gender.gender) FROM movie INNER JOIN movie_cast AS T2 ON T1.movie_id = T2.movie_id INNER JOIN gender AS T3 ON T2.gender_id = T3.gender_id WHERE movie.title = '[placeholder-type:string]' AND gender.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cast members of a specific gender in a particular movie. It joins the 'movie' table with the 'movie_cast' table to link movies with their cast, and then further joins with the 'gender' table to filter by gender. The placeholders represent the movie title and the gender type."
        },
        {
            "sample_id": 495,
            "vt": "SELECT genre.genre_name FROM movie INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id ORDER BY movie.vote_average, movie.revenue LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of genres associated with movies from the 'movie' table. It joins the 'movie_genres' table to link movies to their respective genres and orders the results based on the movie's average vote and revenue. The placeholder in the LIMIT clause allows for specifying the maximum number of genre names to retrieve."
        },
        {
            "sample_id": 463,
            "vt": "SELECT person.person_name FROM movie_cast INNER JOIN person AS T2 ON T1.person_id = T2.person_id INNER JOIN movie AS T3 ON T1.movie_id = T3.movie_id INNER JOIN movie_crew AS T4 ON T1.movie_id = T4.movie_id WHERE movie_crew.job = '[placeholder-type:string]' AND movie.release_date BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of persons who are part of the movie cast and also worked in a specific job role in the movie crew. It filters the results based on the job title and the release date of the movie."
        },
        {
            "sample_id": 526,
            "vt": "SELECT COUNT(movie_languages.movie_id) FROM movie_languages INNER JOIN language AS T2 ON T1.language_id = T2.language_id WHERE language.language_code = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies that are associated with a specific language code from the 'movie_languages' table. It joins the 'movie_languages' table with the 'language' table to filter the results based on the specified language code. The placeholder in the WHERE clause represents the language code being queried."
        },
        {
            "sample_id": 456,
            "vt": "SELECT COUNT(movie_crew.movie_id) FROM movie_crew WHERE movie_crew.movie_id = [placeholder-type:numeric] AND movie_crew.job = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of crew members associated with a specific movie and job title from the 'movie_crew' table. The placeholders represent the unique identifier of the movie and the job title of the crew member."
        },
        {
            "sample_id": 467,
            "vt": "SELECT COUNT(production_country.movie_id) FROM movie INNER JOIN production_COUNTry AS T2 ON T1.movie_id = T2.movie_id WHERE movie.revenue > [placeholder-type:numeric] AND movie.popularity >= [placeholder-type:numeric] AND movie.release_date BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies produced in a specific country based on certain criteria. It filters movies that have a revenue greater than a specified amount, a popularity rating that meets or exceeds a certain threshold, and a release date that falls within a specified range. The query joins the 'movie' table with the 'production_country' table to achieve this."
        },
        {
            "sample_id": 415,
            "vt": "SELECT COUNT(person.person_id) FROM movie INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE movie.title LIKE '[placeholder-type:string]' AND movie_crew.job = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of crew members associated with a specific movie title and job role. It joins the 'movie' table with the 'movie_crew' table to link movies with their respective crew members, and then further joins with the 'person' table to access the crew member details. The placeholders in the WHERE clause allow users to specify the movie title and job role they are interested in."
        },
        {
            "sample_id": 520,
            "vt": "SELECT MAX(movie.runtime) FROM movie",
            "ba": "The virtual table retrieves the maximum runtime of movies from the 'movie' table. This provides insight into the longest movie available in the dataset."
        },
        {
            "sample_id": 424,
            "vt": "SELECT COUNT(movie_crew.movie_id) FROM person INNER JOIN movie_crew AS T2 ON T1.person_id = T2.person_id WHERE person.person_name = '[placeholder-type:string]' AND movie_crew.job = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies associated with a specific person based on their job title in the movie crew. It joins the 'person' table with the 'movie_crew' table to filter results by the person's name and their job role."
        },
        {
            "sample_id": 498,
            "vt": "SELECT movie.title FROM movie INNER JOIN production_COUNTry AS T2 ON T1.movie_id = T2.movie_id INNER JOIN COUNTry AS T3 ON T2.COUNTry_id = T3.COUNTry_id WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of movies from the 'movie' table that are produced in a specific country. It joins the 'production_country' table to link movies with their respective countries and filters the results based on the country name provided as a placeholder."
        },
        {
            "sample_id": 480,
            "vt": "SELECT movie.title FROM movie INNER JOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id INNER JOIN keyword AS T3 ON T2.keyword_id = T3.keyword_id WHERE keyword.keyword_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of movies from the 'movie' table that are associated with a specific keyword. It joins the 'movie' table with the 'movie_keywords' table to link movies to their keywords, and then further joins with the 'keyword' table to filter based on a specific keyword name provided as a placeholder."
        },
        {
            "sample_id": 481,
            "vt": "SELECT movie.title FROM movie INNER JOIN production_COUNTry AS T2 ON T1.movie_id = T2.movie_id INNER JOIN COUNTry AS T3 ON T2.COUNTry_id = T3.COUNTry_id WHERE country.country_name = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies from the 'movie' table that are produced in a specific country. It joins the 'production_country' table to link movies with their respective countries and filters the results based on the country name provided by the user. The placeholders represent the country name and the limit on the number of results returned."
        },
        {
            "sample_id": 489,
            "vt": "SELECT keyword.keyword_name FROM movie INNER JOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id INNER JOIN keyword AS T3 ON T2.keyword_id = T3.keyword_id ORDER BY movie.popularity LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of keywords associated with movies from the 'movie' table. It joins the 'movie_keywords' table to link movies with their respective keywords and orders the results by the popularity of the movies. The query limits the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 558,
            "vt": "SELECT COUNT(*) FROM (SELECT production_company.company_name FROM production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id GROUP BY T1.company_id HAVING COUNT(T1.company_name) > 150)",
            "ba": "The virtual table counts the number of production companies that have produced more than 150 movies. It does this by selecting the company names from the 'production_company' table, joining it with the 'movie_company' table to associate each company with its movies, and then grouping the results by company ID. The HAVING clause filters the groups to include only those with a count greater than 150."
        },
        {
            "sample_id": 453,
            "vt": "SELECT movie.title FROM movie INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id WHERE genre.genre_name = '[placeholder-type:string]' ORDER BY movie.release_date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies from the 'movie' table that belong to a specific genre. It joins the 'movie' table with the 'movie_genres' table to link movies with their respective genres, and further joins with the 'genre' table to filter by the genre name. The results are ordered by the release date of the movies and limited to a specified number of entries."
        },
        {
            "sample_id": 438,
            "vt": "SELECT COUNT(movie.movie_id) FROM movie WHERE movie.revenue > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of movies from the 'movie' table that have a revenue greater than a specified amount. The placeholder in the WHERE clause represents the revenue threshold."
        },
        {
            "sample_id": 522,
            "vt": "SELECT movie.overview FROM movie WHERE movie.title = '[placeholder-type:string]'",
            "ba": "The virtual table provides an overview of a movie from the 'movie' table based on its title. The placeholder in the WHERE clause represents the specific title of the movie being queried."
        },
        {
            "sample_id": 561,
            "vt": "SELECT movie.title FROM movie INNER JOIN movie_cast AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE person.person_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of movies from the 'movie' table that feature a specific person in the cast. It joins the 'movie_cast' table to link movies with their respective cast members and the 'person' table to filter by the name of the person. The placeholder in the WHERE clause represents the name of the person whose movies are being queried."
        },
        {
            "sample_id": 514,
            "vt": "SELECT SUM(CASE WHEN language.language_name = '[placeholder-type:string]' THEN movie.revenue ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN language.language_name = '[placeholder-type:string]' THEN movie.revenue ELSE [placeholder-type:numeric] END) FROM movie INNER JOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id INNER JOIN language AS T3 ON T2.language_id = T3.language_id",
            "ba": "The virtual table calculates the total revenue of movies based on a specific language. It sums the revenue of movies that match the specified language name and subtracts the sum of revenues for movies that do not match the specified language. The placeholders represent the language name and numeric values for revenue calculations."
        },
        {
            "sample_id": 451,
            "vt": "SELECT movie.title FROM movie INNER JOIN movie_cast AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE person.person_name = '[placeholder-type:string]' ORDER BY movie.release_date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies from the 'movie' table that feature a specific person in the cast. It joins the 'movie_cast' table to link movies with their respective cast members and the 'person' table to filter by the name of the person. The results are ordered by the release date of the movies, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 475,
            "vt": "SELECT production_company.company_name FROM production_company INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE movie.title = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of production companies associated with a specific movie title from the 'production_company' table. It joins the 'movie_company' table to link production companies to movies and filters the results based on the provided movie title."
        },
        {
            "sample_id": 538,
            "vt": "SELECT country.country_id, country.country_iso_code FROM country WHERE country.country_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique identifiers and ISO codes of countries from the 'country' table that match a specific country name. The placeholder in the WHERE clause represents the name of the country being queried."
        },
        {
            "sample_id": 447,
            "vt": "SELECT production_company.company_name FROM production_company INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id GROUP BY production_company.company_id ORDER BY SUM(movie.revenue) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of production companies that have produced movies, ordered by the total revenue generated by those movies. The query joins the 'production_company' table with the 'movie_company' table to link companies to their respective movies, and then further joins with the 'movie' table to access revenue data. The results are grouped by company ID and limited to a specified number of entries."
        },
        {
            "sample_id": 478,
            "vt": "SELECT keyword.keyword_name FROM movie INNER JOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id INNER JOIN keyword AS T3 ON T2.keyword_id = T3.keyword_id WHERE movie.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of keywords associated with a specific movie title from the 'movie' table. It joins the 'movie_keywords' table to link movies with their respective keywords and the 'keyword' table to get the actual keyword names. The placeholder in the WHERE clause represents the title of the movie being queried."
        },
        {
            "sample_id": 472,
            "vt": "SELECT CAST(COUNT(CASE WHEN genre.genre_name = '[placeholder-type:string]' THEN movie.movie_id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(movie.movie_id) FROM movie INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN production_COUNTry AS T3 ON T1.movie_id = T3.movie_id INNER JOIN genre AS T4 ON T2.genre_id = T4.genre_id INNER JOIN COUNTry AS T5 ON T3.COUNTry_id = T5.COUNTry_id WHERE country.country_name = '[placeholder-type:string]' AND movie.release_date BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage of movies of a specific genre produced in a specific country within a given release date range. It counts the number of movies that match the specified genre and divides it by the total number of movies released in that country during the specified time frame, multiplying the result by a numeric placeholder to adjust the final output."
        },
        {
            "sample_id": 482,
            "vt": "SELECT person.person_name FROM movie INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE movie.title = '[placeholder-type:string]' AND movie_crew.job = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of persons who worked on a specific movie in a particular job role. It retrieves data from the 'movie' table and joins it with the 'movie_crew' table to find the relevant crew members, and then joins with the 'person' table to get the names of those crew members. The placeholders in the WHERE clause represent the title of the movie and the job role of the crew member."
        },
        {
            "sample_id": 450,
            "vt": "SELECT COUNT(movie_cast.movie_id) FROM person INNER JOIN movie_cast AS T2 ON T1.person_id = T2.person_id WHERE person.person_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies in which a specific person has acted. It retrieves data from the 'person' table and joins it with the 'movie_cast' table to find the relevant movie IDs associated with that person. The placeholder in the WHERE clause represents the name of the person whose movie count is being queried."
        },
        {
            "sample_id": 518,
            "vt": "SELECT CAST(SUM(subquery_q0.cd) AS FLOAT) / COUNT(movie_crew.movie_id) FROM (SELECT movie_crew.movie_id, COUNT(movie_crew.person_id) FROM movie_crew GROUP BY movie_id)",
            "ba": "The virtual table calculates the average number of crew members per movie from the 'movie_crew' table. It first counts the number of crew members for each movie and then sums these counts to find the total number of crew members across all movies. Finally, it divides this total by the count of distinct movies to get the average."
        },
        {
            "sample_id": 542,
            "vt": "SELECT language.language_name FROM movie INNER JOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id INNER JOIN language AS T3 ON T2.language_id = T3.language_id INNER JOIN language_role AS T4 ON T2.language_role_id = T4.role_id WHERE language_role.language_role = '[placeholder-type:string]' AND movie.title = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of languages used in a specific movie, filtered by the role of the language (e.g., original or spoken) and the title of the movie."
        },
        {
            "sample_id": 479,
            "vt": "SELECT country.country_name FROM movie INNER JOIN production_COUNTry AS T2 ON T1.movie_id = T2.movie_id INNER JOIN COUNTry AS T3 ON T2.COUNTry_id = T3.COUNTry_id WHERE movie.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of countries associated with a specific movie title from the 'movie' table. It uses joins to connect the 'movie' table with the 'production_country' table and the 'country' table, allowing for the retrieval of country names based on the movie title provided in the placeholder."
        },
        {
            "sample_id": 512,
            "vt": "SELECT DISTINCT movie.tagline FROM movie INNER JOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id INNER JOIN language AS T3 ON T2.language_id = T3.language_id WHERE language.language_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct taglines of movies from the 'movie' table that are associated with a specific language. It joins the 'movie_languages' table to link movies with their respective languages and the 'language' table to filter by the language name provided in the placeholder."
        },
        {
            "sample_id": 442,
            "vt": "SELECT person.person_name FROM person WHERE person.person_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of individuals from the 'person' table based on a specific unique identifier. The placeholder in the WHERE clause represents the unique identifier of the person."
        },
        {
            "sample_id": 457,
            "vt": "SELECT COUNT(DISTINCT job) FROM movie_crew WHERE movie_crew.movie_id = [placeholder-type:numeric] AND movie_crew.department_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct job titles from the 'movie_crew' table for a specific movie and department. The placeholders represent the unique identifiers for the movie and the department."
        },
        {
            "sample_id": 419,
            "vt": "SELECT movie.release_date FROM movie INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE person.person_name = '[placeholder-type:string]' ORDER BY movie.release_date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of release dates for movies that a specific person has worked on, by joining the 'movie' table with the 'movie_crew' and 'person' tables. The placeholder in the WHERE clause represents the name of the person, and the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 486,
            "vt": "SELECT movie.title FROM movie WHERE CAST(STRFTIME('%Y', movie.release_date) AS INT) < [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies from the 'movie' table that were released before a specified year. The placeholders represent the year and the limit on the number of results returned."
        },
        {
            "sample_id": 439,
            "vt": "SELECT MIN(movie.release_date) FROM movie WHERE movie.movie_status = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the earliest release date of movies from the 'movie' table that have a specific status. The placeholder in the WHERE clause represents the movie status, which is used to filter the results accordingly."
        },
        {
            "sample_id": 409,
            "vt": "SELECT COUNT(subquery_q0.cname) FROM (SELECT production_company.company_name FROM production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE T3.title = 'Four Rooms')",
            "ba": "The virtual table counts the number of production companies associated with a specific movie title. It retrieves the company names from the 'production_company' table, joins it with the 'movie_company' table to link companies to movies, and further joins with the 'movie' table to filter by the movie title. The placeholder in the WHERE clause represents the title of the movie being queried."
        },
        {
            "sample_id": 431,
            "vt": "SELECT production_company.company_name FROM production_company INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE movie.title = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of production companies associated with a specific movie title from the 'production_company' table. It joins the 'movie_company' table to link production companies to their respective movies, and filters the results based on the provided movie title."
        },
        {
            "sample_id": 505,
            "vt": "SELECT movie.title FROM production_company INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE production_company.company_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of movies produced by a specific production company. It retrieves data from the 'production_company' table and joins it with the 'movie_company' table to link production companies with their respective movies. The final join with the 'movie' table allows access to the movie titles. The placeholder in the WHERE clause represents the name of the production company."
        },
        {
            "sample_id": 411,
            "vt": "SELECT movie.title FROM production_company INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE production_company.company_name = '[placeholder-type:string]' ORDER BY movie.release_date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies produced by a specific production company. It joins the 'production_company' table with the 'movie_company' table to link companies to their movies, and then further joins with the 'movie' table to retrieve the movie titles. The results are filtered by the name of the production company and ordered by the release date of the movies, with a limit on the number of results returned."
        },
        {
            "sample_id": 535,
            "vt": "SELECT CAST(COUNT(CASE WHEN country.country_iso_code = '[placeholder-type:string]' THEN movie.movie_id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(movie.movie_id) FROM movie INNER JOIN production_COUNTry AS T2 ON T1.movie_id = T2.movie_id INNER JOIN COUNTry AS T3 ON T2.COUNTry_id = T3.COUNTry_id",
            "ba": "The virtual table calculates the percentage of movies produced in a specific country, identified by its ISO code, relative to the total number of movies. It does this by counting the number of movies associated with the specified country and dividing it by the total count of movies, then multiplying by a numeric placeholder for scaling purposes."
        },
        {
            "sample_id": 559,
            "vt": "SELECT movie_crew.job FROM person INNER JOIN movie_crew AS T2 ON T1.person_id = T2.person_id WHERE person.person_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the job titles of crew members from the 'movie_crew' table who are associated with a specific person. The query joins the 'person' table to filter based on the person's name, using a placeholder for the name."
        },
        {
            "sample_id": 543,
            "vt": "SELECT movie_cast.character_name FROM movie INNER JOIN movie_cast AS T2 ON T1.movie_id = T2.movie_id WHERE movie.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the character names of cast members from the 'movie' table for a specific movie title. The placeholder in the WHERE clause represents the title of the movie."
        },
        {
            "sample_id": 553,
            "vt": "SELECT genre.genre_name FROM movie INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id WHERE movie.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the genre names of movies from the 'movie' table that match a specific title. The query uses inner joins to connect the 'movie' table with the 'movie_genres' table and the 'genre' table, allowing for the retrieval of genre information based on the movie's title. The placeholder in the WHERE clause represents the title of the movie being queried."
        },
        {
            "sample_id": 539,
            "vt": "SELECT movie_cast.character_name FROM person INNER JOIN movie_cast AS T2 ON T1.person_id = T2.person_id WHERE person.person_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the character names of actors from the 'movie_cast' table who are associated with a specific person. The query joins the 'person' table to filter based on the person's name, represented by a placeholder."
        },
        {
            "sample_id": 563,
            "vt": "SELECT CAST(COUNT(CASE WHEN genre.genre_name = '[placeholder-type:string]' THEN movie.movie_id ELSE NULL END) AS FLOAT) / COUNT(movie.movie_id) FROM movie INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id",
            "ba": "The virtual table calculates the proportion of movies that belong to a specific genre from the 'movie' table. It counts the number of movies that match the specified genre and divides it by the total number of movies. The placeholder in the COUNT function represents the genre name being queried."
        },
        {
            "sample_id": 540,
            "vt": "SELECT movie.title FROM movie INNER JOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id INNER JOIN language AS T3 ON T2.language_id = T3.language_id WHERE language.language_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of movies from the 'movie' table that are associated with a specific language. It joins the 'movie' table with the 'movie_languages' table to link movies with their respective languages, and further joins with the 'language' table to filter by the specified language name."
        },
        {
            "sample_id": 507,
            "vt": "SELECT movie.release_date FROM production_company INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE production_company.company_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the release dates of movies produced by a specific production company. It retrieves data from the 'production_company' table and joins it with the 'movie_company' and 'movie' tables to filter the results based on the company's name."
        },
        {
            "sample_id": 417,
            "vt": "SELECT COUNT(movie_crew.movie_id) FROM person INNER JOIN movie_crew AS T2 ON T1.person_id = T2.person_id WHERE person.person_name = '[placeholder-type:string]' AND movie_crew.job = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies associated with a specific person based on their job title in the movie crew. It joins the 'person' table with the 'movie_crew' table to filter results by the person's name and their job role."
        },
        {
            "sample_id": 547,
            "vt": "SELECT person.person_name, department.department_name FROM movie INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id INNER JOIN department AS T4 ON T2.department_id = T4.department_id WHERE movie.title LIKE '[placeholder-type:string]' AND movie_crew.job = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of persons and their respective department names from the 'movie' table, filtered by a specific movie title and job role. The placeholders in the WHERE clause represent the movie title and job title."
        },
        {
            "sample_id": 440,
            "vt": "SELECT COUNT(person.person_id) FROM person WHERE person.person_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of persons from the 'person' table whose name matches a specified name. The placeholder in the WHERE clause represents the person's name."
        },
        {
            "sample_id": 446,
            "vt": "SELECT COUNT(movie_company.movie_id) FROM production_company INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id WHERE production_company.company_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of movies produced by a specific production company from the 'production_company' table. It joins the 'production_company' table with the 'movie_company' table to link each movie to its respective production company. The placeholder in the WHERE clause represents the name of the production company being queried."
        },
        {
            "sample_id": 492,
            "vt": "SELECT movie.title FROM movie INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id WHERE movie.movie_status = '[placeholder-type:string]' AND genre.genre_name = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of movies from the 'movie' table that are associated with a specific genre and have a particular status. The query uses inner joins to connect the 'movie' table with the 'movie_genres' and 'genre' tables, allowing for filtering based on the movie's status and genre name. The placeholders represent the movie status and genre name, while a limit is applied to restrict the number of results returned."
        }
    ],
    "simpson_episodes": [
        {
            "sample_id": 4309,
            "vt": "SELECT episode.votes FROM episode WHERE episode.rating > [placeholder-type:numeric]",
            "ba": "The virtual table displays the number of votes for episodes from the 'episode' table that have a rating higher than a specified threshold. The placeholder in the WHERE clause represents the minimum rating value to filter the episodes."
        },
        {
            "sample_id": 4202,
            "vt": "SELECT episode.title FROM episode ORDER BY episode.rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of episodes from the 'episode' table, ordered by their ratings. The placeholder in the LIMIT clause allows the user to specify the number of episode titles to retrieve."
        },
        {
            "sample_id": 4194,
            "vt": "SELECT DISTINCT credit.person FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTRING(episode.air_date, [placeholder-type:numeric], [placeholder-type:numeric]) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table retrieves a distinct list of crew members involved in episodes that aired within a specific date range. The placeholders allow users to specify the starting and ending positions for extracting the year from the air date, as well as the actual date range for filtering the episodes."
        },
        {
            "sample_id": 4325,
            "vt": "SELECT person.birth_place FROM person INNER JOIN Award AS T2 ON T1.name = T2.person WHERE award.award = '[placeholder-type:string]' AND award.role = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the birthplaces of crew members from the 'person' table who have received a specific award in a specific role. The placeholders in the WHERE clause represent the award name and the role of the honoree."
        },
        {
            "sample_id": 4217,
            "vt": "SELECT episode.episode, episode.title, episode.rating FROM episode WHERE SUBSTRING(episode.air_date, [placeholder-type:numeric], [placeholder-type:numeric]) LIKE '[placeholder-type:string]'",
            "ba": "The virtual table provides a selection of episode numbers, titles, and ratings from the 'episode' table, filtered by a specific substring of the air date. The placeholders allow users to specify the starting position and length of the substring for the air date, as well as the desired substring to match."
        },
        {
            "sample_id": 4248,
            "vt": "SELECT person.birth_place FROM person WHERE person.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the birth place of a crew member from the 'person' table based on their name. The placeholder in the WHERE clause represents the specific name of the crew member being queried."
        },
        {
            "sample_id": 4178,
            "vt": "SELECT AVG(vote.stars) FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE episode.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average star rating of episodes from the 'episode' table based on the title of the episode. The placeholder in the WHERE clause represents the specific title of the episode for which the average rating is being calculated."
        },
        {
            "sample_id": 4187,
            "vt": "SELECT MAX(vote.votes) - MIN(vote.votes) FROM vote",
            "ba": "The virtual table calculates the difference between the maximum and minimum number of votes received by episodes from the 'vote' table. This provides insight into the range of audience support for the episodes."
        },
        {
            "sample_id": 4218,
            "vt": "SELECT award.award_id, award.award, award.person FROM award INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE character_award.character = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about awards received by characters in episodes. It includes the unique identifier for the award, the name of the award, and the person who received it. The query filters results based on a specific character's name and the result of the award (whether they were a nominee or a winner)."
        },
        {
            "sample_id": 4234,
            "vt": "SELECT AVG(vote.stars), episode.summary FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE episode.episode_id = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average star rating of a specific episode and retrieves its summary from the 'episode' table. The placeholder in the WHERE clause represents the unique identifier of the episode."
        },
        {
            "sample_id": 4228,
            "vt": "SELECT person.name, person.birth_place, credit.role, [placeholder-type:numeric] - CAST(SUBSTRING(person.birthdate, [placeholder-type:numeric], [placeholder-type:numeric]) AS INT) FROM person INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE NOT person.birthdate IS NULL ORDER BY person.birthdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names and birthplaces of crew members along with their roles in episodes, while also calculating their ages based on their birthdates. The query filters out any crew members without a birthdate and orders the results by birthdate, limiting the output to a specified number of entries."
        },
        {
            "sample_id": 4197,
            "vt": "SELECT keyword.keyword FROM episode INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the keywords associated with a specific episode title from the 'episode' table by joining it with the 'keyword' table. The placeholder in the WHERE clause represents the title of the episode for which the keywords are being queried."
        },
        {
            "sample_id": 4334,
            "vt": "SELECT COUNT(award.award_id) FROM award WHERE award.award_category = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of awards from the 'award' table that belong to a specific award category. The placeholder in the WHERE clause represents the category of the award being queried."
        },
        {
            "sample_id": 4277,
            "vt": "SELECT keyword.keyword FROM episode INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves keywords associated with a specific episode title from the 'episode' and 'keyword' tables. The placeholder in the WHERE clause represents the title of the episode being queried."
        },
        {
            "sample_id": 4161,
            "vt": "SELECT person.birth_country FROM person INNER JOIN Award AS T2 ON T1.name = T2.person WHERE award.award = '[placeholder-type:string]' AND award.year = [placeholder-type:numeric] AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the birth country of crew members from the 'person' table who have received a specific award in a given year and with a specified result. The placeholders represent the award name, year, and result status."
        },
        {
            "sample_id": 4316,
            "vt": "SELECT DISTINCT character_award.character FROM award INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE award.award_category = '[placeholder-type:string]' AND award.year = [placeholder-type:numeric] AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct characters that have received awards from the 'award' table, filtered by a specific award category, year, and result status. The placeholders allow users to specify the award category, year of the award, and whether the character was a nominee or winner."
        },
        {
            "sample_id": 4192,
            "vt": "SELECT DISTINCT episode.title FROM episode INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE keyword.keyword IN ('[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table lists the distinct titles of episodes from the 'episode' table that are associated with specific keywords. The query uses an inner join to connect the 'episode' table with the 'keyword' table based on the episode ID, and filters the results to include only those episodes that match the specified keywords."
        },
        {
            "sample_id": 4349,
            "vt": "SELECT COUNT(award.award_id) FROM award WHERE SUBSTRING(award.year, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of awards from the 'award' table based on specific criteria. It filters the awards by a range of years and checks for a specific result status (e.g., nominee or winner). The placeholders represent the year range and the result status."
        },
        {
            "sample_id": 4195,
            "vt": "SELECT credit.person FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]' AND credit.role = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of crew members associated with a specific episode title and their respective roles from the 'episode' and 'credit' tables. The placeholders in the WHERE clause represent the episode title and the role of the crew member."
        },
        {
            "sample_id": 4341,
            "vt": "SELECT character_award.character FROM award INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE award.year = [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of characters that have received awards from the 'award' table, filtered by a specific year. The query joins the 'award' table with the 'character_award' table to retrieve the character names associated with the awards for that year."
        },
        {
            "sample_id": 4191,
            "vt": "SELECT credit.person FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]' AND credit.credited = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of cast and crew members who are credited for a specific episode from the 'episode' table. The placeholders in the WHERE clause represent the title of the episode and the credited status."
        },
        {
            "sample_id": 4168,
            "vt": "SELECT COUNT(*) FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE episode.title = '[placeholder-type:string]' AND vote.stars = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of votes for a specific episode title and star rating from the 'episode' and 'vote' tables. The placeholders represent the episode title and the star rating to filter the results accordingly."
        },
        {
            "sample_id": 4323,
            "vt": "SELECT episode.title FROM award INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE award.award = '[placeholder-type:string]' AND SUBSTRING(award.year, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of episodes from the 'episode' table that have received a specific award. The query joins the 'award' table with the 'episode' table to filter episodes based on the award name and a substring of the award year, which is represented by placeholders for string and numeric values."
        },
        {
            "sample_id": 4317,
            "vt": "SELECT character_award.character FROM award INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE award.award_category = '[placeholder-type:string]' AND award.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND award.result <> '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of characters that have received awards from the 'award' table, filtered by a specific award category, a range of years, and excluding a certain result status."
        },
        {
            "sample_id": 4301,
            "vt": "SELECT CAST(SUM(CASE WHEN award.result = '[placeholder-type:string]' THEN episode.votes ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(episode.votes) FROM award INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id",
            "ba": "The virtual table calculates the weighted average of votes for episodes based on the award results. It sums the votes for episodes that have a specific award result and divides it by the total votes, applying a multiplier for scaling."
        },
        {
            "sample_id": 4366,
            "vt": "SELECT DISTINCT episode.title FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE vote.stars > [placeholder-type:numeric] * (SELECT AVG(vote.stars) FROM Vote)",
            "ba": "The virtual table lists the distinct titles of episodes from the 'episode' table that have received a star rating greater than the average star rating of all episodes. The query uses an inner join with the 'Vote' table to filter episodes based on their star ratings, comparing each episode's rating to the average rating calculated from the 'Vote' table."
        },
        {
            "sample_id": 4354,
            "vt": "SELECT episode.title FROM award INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE award.organization = '[placeholder-type:string]' AND award.year = [placeholder-type:numeric] AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of episodes from the 'episode' table that have received awards from a specific organization in a given year, with a specified result (e.g., winner or nominee). The placeholders represent the organization name, the year of the award, and the result status."
        },
        {
            "sample_id": 4300,
            "vt": "SELECT DISTINCT episode.episode_id FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE vote.stars = [placeholder-type:numeric] AND vote.votes > [placeholder-type:numeric] * (SELECT CAST(COUNT(episode.votes) AS FLOAT) / COUNT(CASE WHEN vote.stars = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM Vote)",
            "ba": "The virtual table identifies distinct episodes from the 'episode' table that have received a specific star rating and have a number of votes exceeding a calculated threshold based on the total votes for all stars. The placeholders represent the star rating and the minimum number of votes required for consideration."
        },
        {
            "sample_id": 4254,
            "vt": "SELECT DISTINCT episode.episode FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE episode.episode BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND vote.votes > [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct episode numbers from the 'episode' table that fall within a specified range. It also filters the results based on the number of votes received for each episode, ensuring that only episodes with a certain level of audience support are included."
        },
        {
            "sample_id": 4182,
            "vt": "SELECT COUNT(episode.episode_id) FROM episode WHERE episode.votes > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of episodes from the 'episode' table that have received a number of votes greater than a specified threshold. The placeholder in the WHERE clause represents the minimum number of votes required for an episode to be included in the count."
        },
        {
            "sample_id": 4264,
            "vt": "SELECT DISTINCT award.award FROM award INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE award.year = [placeholder-type:numeric] AND character_award.character = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct awards from the 'award' table that were given in a specific year to a particular character. The placeholders represent the year of the award and the name of the character."
        },
        {
            "sample_id": 4203,
            "vt": "SELECT award.year FROM award WHERE award.result = '[placeholder-type:string]' AND award.award = '[placeholder-type:string]' ORDER BY award.year LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the years in which specific awards were given based on the award result and award name. The placeholders allow users to specify the desired result (e.g., nominee or winner) and the specific award they are interested in, while also limiting the number of results returned."
        },
        {
            "sample_id": 4312,
            "vt": "SELECT COUNT(*) FROM person INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE STRFTIME(person.birthdate) > '[placeholder-type:string]' AND credit.role = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of crew members from the 'person' table who have a specific role in the credits of episodes, filtered by their birthdate being after a certain date. The placeholders represent the birthdate and the role of the crew member."
        },
        {
            "sample_id": 4276,
            "vt": "SELECT episode.episode_id FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE SUBSTRING(episode.air_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' ORDER BY vote.votes LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of episodes from the 'episode' table, filtering based on a specific year extracted from the air date. It joins with the 'vote' table to ensure that only episodes with associated votes are considered. The results are ordered by the number of votes, and a limit is applied to control the number of returned episodes."
        },
        {
            "sample_id": 4242,
            "vt": "SELECT episode.episode_id FROM episode WHERE episode.air_date LIKE '[placeholder-type:string]' ORDER BY episode.rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers for episodes from the 'episode' table that match a specific air date pattern. The results are ordered by the episode rating, and the number of results returned is limited to a specified numeric value."
        },
        {
            "sample_id": 4243,
            "vt": "SELECT DISTINCT credit.category, credit.role FROM credit WHERE credit.person = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct categories and roles of credits associated with a specific person from the 'credit' table. The placeholder in the WHERE clause represents the name of the person whose credits are being queried."
        },
        {
            "sample_id": 4212,
            "vt": "SELECT COUNT(*) FROM person INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE person.nickname = '[placeholder-type:string]' AND credit.credited = '[placeholder-type:string]' AND credit.episode_id = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of crew members from the 'person' table who have a specific nickname and have been credited for a particular episode. It joins the 'person' table with the 'credit' table to filter based on the nickname, credited status, and episode identifier."
        },
        {
            "sample_id": 4351,
            "vt": "SELECT person.name FROM person WHERE person.birth_region = '[placeholder-type:string]' AND person.birth_country = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of crew members from the 'person' table who were born in a specific region and country. The placeholders in the WHERE clause represent the birth region and birth country of the crew members."
        },
        {
            "sample_id": 4313,
            "vt": "SELECT episode.summary FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE credit.credited = '[placeholder-type:string]'",
            "ba": "The virtual table describes the summaries of episodes from the 'episode' table that have specific credits associated with them. The placeholder in the WHERE clause represents the credited status of the crew members involved in those episodes."
        },
        {
            "sample_id": 4199,
            "vt": "SELECT CAST(SUM(CASE WHEN episode.title = '[placeholder-type:string]' THEN episode.votes ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN episode.title = '[placeholder-type:string]' THEN episode.votes ELSE [placeholder-type:numeric] END) FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE vote.stars = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average votes for a specific episode title based on the star rating given by viewers. It sums the votes for the episode with the specified title and divides it by the total votes for that episode, filtered by a specific star rating."
        },
        {
            "sample_id": 4249,
            "vt": "SELECT COUNT(person.name) FROM person WHERE person.birth_country = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of crew members from the 'person' table who were born in a specific country. The placeholder in the WHERE clause represents the name of the country."
        },
        {
            "sample_id": 4250,
            "vt": "SELECT person.name FROM person WHERE SUBSTRING(person.birthdate, [placeholder-type:numeric], [placeholder-type:numeric]) < '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of crew members from the 'person' table whose birthdate falls before a specified date. The placeholders allow for dynamic input of the year and month to filter the results accordingly."
        },
        {
            "sample_id": 4339,
            "vt": "SELECT vote.stars FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE episode.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the star ratings of episodes from the 'episode' table by joining it with the 'vote' table. The placeholder in the WHERE clause represents the title of the episode for which the star ratings are being queried."
        },
        {
            "sample_id": 4262,
            "vt": "SELECT episode.episode_id FROM award INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTRING(award.year, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND award.person = '[placeholder-type:string]' AND award.award_category = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers for episodes from the 'episode' table that have received awards. It filters the results based on the year of the award, the name of the person who received the award, and the category of the award, using placeholders for these criteria."
        },
        {
            "sample_id": 4314,
            "vt": "SELECT episode.rating FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE credit.person = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the ratings of episodes from the 'episode' table, specifically for those episodes that have a credit associated with a particular person. The query uses an INNER JOIN to connect the 'episode' table with the 'credit' table based on the episode identifier, filtering the results to include only those credits that match the specified person's name."
        },
        {
            "sample_id": 4251,
            "vt": "SELECT person.name FROM person WHERE SUBSTRING(person.birthdate, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND person.birth_place = '[placeholder-type:string]' AND person.birth_country = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of crew members from the 'person' table based on specific birthdate criteria, birth place, and birth country. The placeholders allow users to specify the exact year range for the birthdate and the specific place and country of birth."
        },
        {
            "sample_id": 4293,
            "vt": "SELECT award.episode_id FROM award INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE vote.stars = [placeholder-type:numeric] ORDER BY vote.percent LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the episode IDs from the 'award' table for episodes that have received a specific star rating. It joins the 'vote' table to filter episodes based on the star score, allowing users to see which episodes have been awarded based on their popularity as indicated by the votes. The results are ordered by the percentage of votes for the specified star rating, and the number of results returned can be limited by a placeholder value."
        },
        {
            "sample_id": 4183,
            "vt": "SELECT COUNT(person.name) FROM person WHERE person.birth_place = '[placeholder-type:string]' AND person.birth_country = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of crew members from the 'person' table who were born in a specific place and country. The placeholders represent the birth place and birth country of the crew members."
        },
        {
            "sample_id": 4165,
            "vt": "SELECT keyword.keyword FROM episode INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves keywords associated with a specific episode title from the 'episode' table by joining it with the 'keyword' table. The placeholder in the WHERE clause represents the title of the episode being queried."
        },
        {
            "sample_id": 4198,
            "vt": "SELECT CAST(SUM(CASE WHEN award.award = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(episode.episode_id) FROM award INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE episode.votes > [placeholder-type:numeric] AND award.year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average score of episodes that have received a specific award, filtered by the number of votes and the year of the award. It sums the scores of episodes that match the specified award and divides it by the count of episodes that meet the voting criteria, providing a weighted average based on the total number of votes."
        },
        {
            "sample_id": 4347,
            "vt": "SELECT COUNT(DISTINCT T2.episode_id) FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE STRFTIME('%Y', episode.air_date) = '[placeholder-type:string]' AND vote.stars < [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of episodes from the 'episode' table that have received a certain number of votes below a specified star rating in a given year. The placeholders represent the year and the star rating threshold."
        },
        {
            "sample_id": 4175,
            "vt": "SELECT episode.title FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE credit.person = '[placeholder-type:string]' AND credit.role = '[placeholder-type:string]'",
            "ba": "The virtual table lists the titles of episodes from the 'episode' table that are associated with a specific crew member and their role. The placeholders in the WHERE clause represent the crew member's name and their role in the episode."
        },
        {
            "sample_id": 4181,
            "vt": "SELECT CAST(SUM(CASE WHEN credit.credited = '[placeholder-type:string]' THEN [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(CASE WHEN credit.credited = '[placeholder-type:string]' THEN [placeholder-type:numeric] END), episode.title, credit.person FROM award INNER JOIN Credit AS T2 ON T2.episode_id = T1.episode_id INNER JOIN Episode AS T3 ON T1.episode_id = T3.episode_id WHERE SUBSTRING(award.year, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND award.award_category = '[placeholder-type:string]' AND award.award = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of credits for episodes based on specific award criteria. It retrieves the title of the episode and the name of the credited person, filtering results by the year of the award, the category of the award, the specific award name, and the result of the award (whether it was won or not). The placeholders represent dynamic values that can be modified to generate specific queries."
        },
        {
            "sample_id": 4304,
            "vt": "SELECT AVG(person.height_meters) FROM person WHERE person.birth_country = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average height of crew members from the 'person' table who were born in a specific country. The placeholder in the WHERE clause represents the name of the country."
        },
        {
            "sample_id": 4267,
            "vt": "SELECT award.person FROM award WHERE award.result = '[placeholder-type:string]' AND award.award = '[placeholder-type:string]' AND award.episode_id LIKE '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of individuals who have received a specific award for a particular episode, filtered by the award result and the award name. The placeholders allow users to specify the desired award result, award name, and episode identifier, along with a limit on the number of results returned."
        },
        {
            "sample_id": 4255,
            "vt": "SELECT keyword.keyword FROM award INNER JOIN Keyword AS T2 ON T2.episode_id = T1.episode_id WHERE award.award_category = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves keywords associated with episodes that have received a specific award category from the 'award' table. It uses an inner join to connect the 'award' table with the 'keyword' table based on the episode identifier, allowing for filtering by the award category."
        },
        {
            "sample_id": 4186,
            "vt": "SELECT AVG(person.height_meters) FROM person",
            "ba": "The virtual table calculates the average height of crew members from the 'person' table. The placeholder represents the height in meters, which is a numeric value."
        },
        {
            "sample_id": 4332,
            "vt": "SELECT award.organization FROM award WHERE award.award_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the organization that holds a specific award from the 'award' table based on the unique award identifier. The placeholder in the WHERE clause represents the award's ID."
        },
        {
            "sample_id": 4318,
            "vt": "SELECT SUM(episode.votes) FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE credit.person = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of votes for episodes from the 'episode' table, filtered by a specific crew member's name from the 'credit' table. The placeholder in the WHERE clause represents the name of the crew member whose contributions are being evaluated."
        },
        {
            "sample_id": 4331,
            "vt": "SELECT COUNT(keyword.episode_id) FROM keyword WHERE keyword.keyword = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of episodes from the 'keyword' table that are associated with a specific keyword. The placeholder in the WHERE clause represents the keyword being searched for."
        },
        {
            "sample_id": 4291,
            "vt": "SELECT episode.summary FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE credit.person = '[placeholder-type:string]'",
            "ba": "The virtual table describes the summary of episodes from the 'episode' table that are associated with a specific crew member's credit. The placeholder in the WHERE clause represents the name of the crew member."
        },
        {
            "sample_id": 4263,
            "vt": "SELECT SUM(CASE WHEN episode.episode = [placeholder-type:numeric] THEN vote.votes ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN episode.episode = [placeholder-type:numeric] THEN vote.votes ELSE [placeholder-type:numeric] END) FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id",
            "ba": "The virtual table calculates the difference in total votes for a specific episode number from the 'episode' table by summing the votes from the 'vote' table. It uses placeholders for the episode number and the votes to allow users to specify which episode they are interested in and how to handle the votes."
        },
        {
            "sample_id": 4303,
            "vt": "SELECT person.birth_country FROM person ORDER BY person.height_meters LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the birth countries of crew members from the 'person' table, ordered by their height in meters. The result is limited to a specified number of entries, allowing users to see the birth countries of the tallest crew members up to the defined limit."
        },
        {
            "sample_id": 4302,
            "vt": "SELECT person.name FROM person WHERE NOT person.nickname IS NULL",
            "ba": "The virtual table lists the names of crew members from the 'person' table who have a nickname associated with them. The condition in the WHERE clause filters out those crew members who do not have a nickname, ensuring that only those with a nickname are included in the results."
        },
        {
            "sample_id": 4358,
            "vt": "SELECT episode.episode_id, episode.title FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE credit.credited = '[placeholder-type:string]' AND credit.person = '[placeholder-type:string]' AND credit.role = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique identifiers and titles of episodes from the 'episode' table that are associated with specific credits. The placeholders in the WHERE clause represent the credited status, the name of the person, and their role in the episode."
        },
        {
            "sample_id": 4287,
            "vt": "SELECT credit.episode_id FROM credit WHERE credit.person = '[placeholder-type:string]' AND credit.credited = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers for episodes from the 'credit' table where a specific person is credited for their role in the episode. The placeholders represent the person's name and their credited status."
        },
        {
            "sample_id": 4272,
            "vt": "SELECT episode.title FROM episode WHERE episode.rating BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of episodes from the 'episode' table that have a rating within a specified range. The placeholders represent the minimum and maximum rating values, as well as the limit on the number of results returned."
        },
        {
            "sample_id": 4265,
            "vt": "SELECT SUM(CASE WHEN vote.votes < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END), CAST(SUM(CASE WHEN vote.votes < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM award INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Episode AS T3 ON T1.episode_id = T3.episode_id WHERE award.award = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total votes and the average percentage of votes for episodes that have received a specific award. It uses conditional aggregation to sum the votes based on a threshold and computes the average percentage of those votes. The placeholders represent the threshold for votes, the specific award name, and the numeric values for calculations."
        },
        {
            "sample_id": 4361,
            "vt": "SELECT credit.person FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]' AND credit.role = '[placeholder-type:string]' AND credit.credited = '[placeholder-type:string]' AND credit.category = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of crew members from the 'episode' table who have specific roles in a particular episode. The placeholders represent the title of the episode, the role of the crew member, whether they are credited, and the category of the credit."
        },
        {
            "sample_id": 4367,
            "vt": "SELECT CAST((SUM(CASE WHEN award.result = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN award.result = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END)) AS FLOAT) * [placeholder-type:numeric] / COUNT(award.result) FROM award INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]' AND award.year = [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average of the award results for a specific episode title and year. It sums the results based on whether they match a certain condition, then normalizes this sum by the total count of awards for that episode. The placeholders represent the award result condition, a numeric value for weighting, the episode title, and the award year."
        },
        {
            "sample_id": 4223,
            "vt": "SELECT vote.votes, vote.percent FROM keyword INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE keyword.keyword = '[placeholder-type:string]' AND vote.stars = [placeholder-type:numeric]",
            "ba": "The virtual table provides the number of votes and the percentage of votes for episodes that match a specific keyword and star rating. It combines data from the 'keyword' and 'vote' tables based on the episode identifier."
        },
        {
            "sample_id": 4236,
            "vt": "SELECT DISTINCT person.birth_name, credit.role FROM person INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE person.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of distinct birth names and roles of crew members from the 'person' table who have credits in episodes. The query filters the results based on a specific crew member's name using a placeholder for string values."
        },
        {
            "sample_id": 4295,
            "vt": "SELECT person.birthdate FROM person INNER JOIN Award AS T2 ON T1.name = T2.person WHERE award.result = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the birthdates of crew members from the 'person' table who have received an award, filtered by the award result status. The placeholder in the WHERE clause represents the specific result of the award, such as 'Winner' or 'Nominee'."
        },
        {
            "sample_id": 4207,
            "vt": "SELECT COUNT(award.episode_id) FROM award INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTRING(award.year, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND episode.air_date LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of awards associated with episodes from the 'award' table, joining it with the 'episode' table to filter based on specific year and air date criteria. The placeholders allow users to specify the year range and the air date pattern they are interested in."
        },
        {
            "sample_id": 4362,
            "vt": "SELECT vote.stars FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE SUBSTRING(episode.air_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the star ratings of episodes from the 'episode' table, specifically focusing on episodes that aired in a particular month. The query joins the 'episode' table with the 'vote' table to access the star ratings associated with each episode. The placeholder in the WHERE clause is used to specify the month of the air date, while the other placeholders are for numeric values that define the substring extraction for the air date."
        },
        {
            "sample_id": 4292,
            "vt": "SELECT credit.role FROM person INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE person.nickname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the roles of crew members from the 'person' table who have a specific nickname. The query joins the 'person' table with the 'credit' table to retrieve the roles associated with the crew members identified by their nickname."
        },
        {
            "sample_id": 4290,
            "vt": "SELECT DISTINCT character_award.character FROM award INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE award.award = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct characters that have received a specific award based on the award name and the result of the award (whether they were a nominee or a winner)."
        },
        {
            "sample_id": 4322,
            "vt": "SELECT CASE WHEN keyword.keyword = '[placeholder-type:string]' THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM episode INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]'",
            "ba": "The virtual table provides a conditional selection based on keywords associated with episodes from the 'episode' table. It joins the 'episode' table with the 'keyword' table to filter episodes by their title, allowing for a comparison of keywords to specified values."
        },
        {
            "sample_id": 4299,
            "vt": "SELECT keyword.keyword FROM episode INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE episode.number_in_series = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves keywords associated with episodes from the 'episode' table, specifically filtering for episodes that have a certain number in the series. The placeholder in the WHERE clause represents the specific number in the series for which keywords are being queried."
        },
        {
            "sample_id": 4185,
            "vt": "SELECT COUNT(person.name) FROM person WHERE NOT person.nickname IS NULL",
            "ba": "The virtual table counts the number of crew members from the 'person' table who have a nickname assigned to them. The placeholder in the query indicates that the count is filtered to only include those crew members with a non-null nickname."
        },
        {
            "sample_id": 4260,
            "vt": "SELECT COUNT(*) FROM person INNER JOIN Award AS T2 ON T1.name = T2.person WHERE award.award_category = '[placeholder-type:string]' AND person.birth_country = '[placeholder-type:string]' AND award.year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of crew members from the 'person' table who have received awards in a specific category. It filters the results based on the crew member's birth country and the year range during which the awards were given. The placeholders represent the award category, birth country, and the range of years."
        },
        {
            "sample_id": 4244,
            "vt": "SELECT person.name FROM person WHERE person.birthdate = '[placeholder-type:string]' AND person.birth_place = '[placeholder-type:string]' AND person.birth_region = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of crew members from the 'person' table who were born on a specific date and in a specific place and region. The placeholders in the WHERE clause represent the birth date, birth place, and birth region of the crew members."
        },
        {
            "sample_id": 4326,
            "vt": "SELECT vote.stars, SUM(vote.stars) FROM award INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE award.award_category = '[placeholder-type:string]' AND vote.stars BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] GROUP BY vote.stars",
            "ba": "The virtual table summarizes the total star scores for episodes that have received a specific award category. It retrieves the star ratings and their corresponding sums from the 'vote' table, filtering by the award category and a range of star scores. The results are grouped by the star ratings to show the distribution of votes across different star levels."
        },
        {
            "sample_id": 4346,
            "vt": "SELECT keyword.keyword FROM episode INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTRING(episode.air_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves keywords associated with episodes from the 'episode' table by joining it with the 'keyword' table. It filters the results based on a specific year extracted from the air date of the episode, using placeholders for the year extraction parameters and the year itself."
        },
        {
            "sample_id": 4247,
            "vt": "SELECT episode.title FROM award INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id GROUP BY award.episode_id ORDER BY COUNT(*) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of episodes from the 'episode' table that have received awards. It joins the 'award' table with the 'episode' table based on the episode ID, groups the results by episode ID to count the number of awards each episode has received, and orders the results by the count of awards in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of episode titles to return."
        },
        {
            "sample_id": 4282,
            "vt": "SELECT SUM(CASE WHEN vote.stars = [placeholder-type:numeric] THEN vote.votes ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN vote.stars = [placeholder-type:numeric] THEN vote.votes ELSE [placeholder-type:numeric] END) FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE episode.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between the total votes for a specific star rating and the total votes for another star rating for a given episode title. It uses a conditional sum to determine the votes based on the specified star ratings, and it joins the 'episode' table with the 'vote' table to access the necessary data."
        },
        {
            "sample_id": 4162,
            "vt": "SELECT award.award FROM person INNER JOIN Award AS T2 ON T1.name = T2.person WHERE person.nickname = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of awards received by a specific crew member based on their nickname and the result of the award (whether they won or were nominated). It joins the 'person' table with the 'award' table to filter the results accordingly."
        },
        {
            "sample_id": 4232,
            "vt": "SELECT COUNT(award.award_id) FROM award WHERE award.result = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of awards from the 'award' table based on the specified result status. The placeholder in the WHERE clause represents the award result, which can indicate whether the nominee won or lost the award."
        },
        {
            "sample_id": 4210,
            "vt": "SELECT COUNT(*) FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE episode.title = '[placeholder-type:string]' AND vote.votes < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of episodes from the 'episode' table that have a specific title and a number of votes less than a specified threshold. The placeholders represent the title of the episode and the maximum number of votes allowed."
        },
        {
            "sample_id": 4169,
            "vt": "SELECT vote.stars FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE episode.title = '[placeholder-type:string]' ORDER BY vote.votes LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the star ratings of episodes from the 'episode' table, specifically filtering for a given episode title. The results are ordered by the number of votes each star rating received, and the output is limited to a specified number of results."
        },
        {
            "sample_id": 4343,
            "vt": "SELECT DISTINCT award.award_category FROM award INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE character_award.character = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct award categories from the 'award' table that are associated with a specific character. It joins the 'award' table with the 'character_award' table to filter the results based on the character's name provided as a placeholder."
        },
        {
            "sample_id": 4271,
            "vt": "SELECT COUNT(*) FROM award WHERE award.award = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of awards from the 'award' table that match a specific award name and result status. The placeholders represent the award name and the result status, allowing users to specify which award and whether they are looking for nominees or winners."
        },
        {
            "sample_id": 4239,
            "vt": "SELECT award.award, award.award_category FROM award WHERE award.result = '[placeholder-type:string]' ORDER BY award.year LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the names and categories of awards from the 'award' table that have a specific result status. The placeholders allow users to specify the desired result and limit the number of records returned."
        },
        {
            "sample_id": 4335,
            "vt": "SELECT person.birth_name FROM person INNER JOIN Award AS T2 ON T1.name = T2.person WHERE award.role = '[placeholder-type:string]' AND person.height_meters > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the birth names of crew members from the 'person' table who have received an award for a specific role and have a height greater than a specified value. The placeholders in the WHERE clause represent the role of the award and the height in meters."
        },
        {
            "sample_id": 4286,
            "vt": "SELECT person.name FROM person ORDER BY person.birthdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of crew members from the 'person' table, ordered by their birthdate. The placeholder allows for limiting the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 4356,
            "vt": "SELECT credit.category FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE credit.person = '[placeholder-type:string]' AND credit.credited = '[placeholder-type:string]' ORDER BY episode.votes LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the categories of credits associated with episodes from the 'episode' table for a specific person. The placeholders in the WHERE clause represent the person's name and whether they are credited, while the LIMIT placeholder specifies the maximum number of results to return."
        },
        {
            "sample_id": 4224,
            "vt": "SELECT award.award, episode.air_date, episode.rating FROM award INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE award.organization = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table displays the awards received by episodes along with their air dates and ratings. It combines data from the 'award' and 'episode' tables, filtering results based on the organization that issued the award and the result of the award (whether it was won or not). The placeholders represent the specific organization and result criteria for the query."
        },
        {
            "sample_id": 4213,
            "vt": "SELECT award.award, person.name FROM person INNER JOIN Award AS T2 ON T1.name = T2.person WHERE award.result = '[placeholder-type:string]' ORDER BY award.year LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the awards received by individuals from the 'person' table, filtered by the award result status. The placeholders allow users to specify the desired award result and limit the number of results returned."
        },
        {
            "sample_id": 4294,
            "vt": "SELECT DISTINCT credit.person FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]' AND credit.category = '[placeholder-type:string]' AND credit.credited = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct crew members associated with a specific episode title from the 'episode' table. It filters the results based on the credit category and whether the crew member is credited."
        },
        {
            "sample_id": 4164,
            "vt": "SELECT DISTINCT character_award.character FROM character_award INNER JOIN Award AS T2 ON T1.award_id = T2.award_id WHERE award.award = '[placeholder-type:string]' AND award.year = [placeholder-type:numeric] AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct characters that have received awards from the 'character_award' table. It filters the results based on the specific award name, the year the award was given, and the result of the award (whether they were a nominee or a winner). The placeholders allow users to specify the award name as a string, the year as a number, and the result as a string."
        },
        {
            "sample_id": 4229,
            "vt": "SELECT DISTINCT credit.credited, credit.category, credit.role, person.birth_place FROM person INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE person.birth_country = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of crew members' credited roles, categories, and their birthplaces from the 'person' table, filtered by the specified country of birth. The placeholders in the query allow users to specify the country they are interested in."
        },
        {
            "sample_id": 4338,
            "vt": "SELECT episode.title FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE vote.stars = [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of episodes from the 'episode' table that have received a specific star rating. The placeholder in the WHERE clause represents the star score for filtering the episodes based on their ratings."
        },
        {
            "sample_id": 4321,
            "vt": "SELECT CAST(SUM(CASE WHEN vote.stars = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE episode.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of star ratings for a specific episode based on the votes it received. It sums the stars multiplied by a specified weight and divides by the total number of votes to get the average rating. The placeholder in the WHERE clause represents the title of the episode being queried."
        },
        {
            "sample_id": 4359,
            "vt": "SELECT COUNT(*) FROM award INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE award.organization = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]' AND vote.percent > [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of awards for episodes that meet specific criteria. It joins the 'award' table with the 'vote' table to filter awards based on the organization, the result of the award, and the percentage of votes received for each episode. The placeholders allow users to specify the organization name, the result type (e.g., nominee or winner), and a minimum percentage of votes required for the episodes being counted."
        },
        {
            "sample_id": 4159,
            "vt": "SELECT person.nickname FROM person WHERE person.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the nickname of a crew member from the 'person' table based on their name. The placeholder in the WHERE clause represents the specific name of the crew member whose nickname is being queried."
        },
        {
            "sample_id": 4180,
            "vt": "SELECT DISTINCT person.birth_name FROM person INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE credit.role = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct birth names of crew members from the 'person' table who have a specific role in the credits of episodes. The query uses an inner join to connect the 'person' table with the 'credit' table based on the person's name, filtering the results by a placeholder for the role."
        },
        {
            "sample_id": 4201,
            "vt": "SELECT award.person FROM award WHERE award.result = '[placeholder-type:string]' GROUP BY award.person ORDER BY COUNT(award.person) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of individuals who have received awards, filtered by the result of the award (either 'Nominee' or 'Winner'). The results are grouped by the person's name and ordered by the count of awards they have received, allowing for a limit on the number of results returned."
        },
        {
            "sample_id": 4345,
            "vt": "SELECT keyword.keyword FROM episode INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the keywords associated with a specific episode title from the 'episode' table by joining it with the 'keyword' table. The placeholder in the WHERE clause represents the title of the episode being queried."
        },
        {
            "sample_id": 4252,
            "vt": "SELECT vote.episode_id FROM vote WHERE vote.stars = [placeholder-type:numeric] AND vote.votes > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of episodes from the 'vote' table where the star score matches a specified value and the number of votes exceeds a certain threshold. The placeholders represent the star score and the minimum number of votes required for the episodes to be included in the results."
        },
        {
            "sample_id": 4177,
            "vt": "SELECT episode.title, episode.summary FROM episode INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE keyword.keyword = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles and summaries of episodes from the 'episode' table that are associated with a specific keyword. The placeholder in the WHERE clause represents the keyword used to filter the episodes."
        },
        {
            "sample_id": 4246,
            "vt": "SELECT award.year - person.birthdate, person.name FROM award INNER JOIN Person AS T2 ON T1.person = T2.name WHERE award.role = '[placeholder-type:string]' AND award.organization = '[placeholder-type:string]' AND award.award = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]' AND award.year = [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of names and the age of individuals at the time they received a specific award, calculated by subtracting their birthdate from the award year. It retrieves data from the 'award' table and joins it with the 'person' table to get the names of the award recipients. The query filters results based on the role, organization, award name, award result, and the year of the award, all of which are represented by placeholders for user input."
        },
        {
            "sample_id": 4231,
            "vt": "SELECT episode.title FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id ORDER BY vote.stars, vote.votes LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of episodes from the 'episode' table, ordered by their star ratings and the number of votes they received. The query joins the 'episode' table with the 'vote' table to access the voting information, and it limits the results to a specified number of episodes."
        },
        {
            "sample_id": 4348,
            "vt": "SELECT person.birth_name FROM person INNER JOIN Award AS T2 ON T1.name = T2.person WHERE award.role = '[placeholder-type:string]' AND person.birth_country = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the birth names of crew members from the 'person' table who have received an award for a specific role and are from a particular country. The placeholders in the WHERE clause represent the role and the country of the crew members."
        },
        {
            "sample_id": 4281,
            "vt": "SELECT vote.votes FROM keyword INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE vote.stars = [placeholder-type:numeric] AND keyword.keyword = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the number of votes for episodes that match a specific star rating and keyword. It combines data from the 'keyword' and 'vote' tables based on the episode identifier."
        },
        {
            "sample_id": 4353,
            "vt": "SELECT vote.episode_id FROM vote WHERE vote.stars = [placeholder-type:numeric] AND vote.votes = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of episodes from the 'vote' table where the star score and the number of votes meet specific criteria. The placeholders represent the star score and the total votes for filtering the results."
        },
        {
            "sample_id": 4176,
            "vt": "SELECT credit.role, episode.episode, episode.number_in_series FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE credit.person = '[placeholder-type:string]' AND episode.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the roles of crew members in specific episodes from the 'episode' table. It retrieves the episode number and its series number for episodes that match a specific crew member's name and title of the episode. The placeholders in the WHERE clause represent the crew member's name and the episode's title."
        },
        {
            "sample_id": 4256,
            "vt": "SELECT award.person FROM award INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE award.award_category = '[placeholder-type:string]' ORDER BY vote.votes LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the individuals who have received awards from the 'award' table, filtered by a specific award category. It joins the 'vote' table to incorporate voting data, allowing for the selection of award recipients based on their episode's popularity as indicated by the number of votes. The results are ordered by the number of votes and limited to a specified number of entries."
        },
        {
            "sample_id": 4219,
            "vt": "SELECT DISTINCT award.award, award.result, credit.category, credit.credited FROM award INNER JOIN Credit AS T2 ON T2.episode_id = T1.episode_id WHERE credit.person = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of awards, their results, credit categories, and credited individuals from the 'award' and 'credit' tables. It filters the results based on a specific person's name, allowing users to see the awards associated with that person and their credited roles in the episodes."
        },
        {
            "sample_id": 4221,
            "vt": "SELECT person.birth_country, person.height_meters, person.name FROM person INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE credit.category = '[placeholder-type:string]' AND credit.credited = '[placeholder-type:string]'",
            "ba": "The virtual table describes the birth country, height, and name of crew members from the 'person' table who have specific credits in episodes. The placeholders in the WHERE clause represent the category of the credit and whether the person is credited or not."
        },
        {
            "sample_id": 4307,
            "vt": "SELECT episode.title FROM episode WHERE episode.episode_id IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table lists the titles of episodes from the 'episode' table that match specific episode identifiers. The placeholders represent the unique identifiers for the episodes being queried."
        },
        {
            "sample_id": 4170,
            "vt": "SELECT episode.title FROM episode INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE vote.votes > [placeholder-type:numeric] AND vote.stars = [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of episodes from the 'episode' table that have received a certain number of votes and a specific star rating. The placeholders in the WHERE clause represent the minimum number of votes and the exact star rating to filter the results."
        },
        {
            "sample_id": 4330,
            "vt": "SELECT vote.episode_id FROM vote ORDER BY vote.votes LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers for episodes from the 'vote' table, ordering them by the number of votes received. The placeholder allows for limiting the number of results returned based on user input."
        },
        {
            "sample_id": 4315,
            "vt": "SELECT AVG(person.height_meters) FROM person INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE credit.category = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average height of crew members from the 'person' table who are credited in a specific category of the 'credit' table. The placeholder in the WHERE clause represents the category of credit."
        },
        {
            "sample_id": 4237,
            "vt": "SELECT COUNT(award.award_id) FROM award WHERE award.person = '[placeholder-type:string]' AND SUBSTRING(award.year, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of awards received by a specific person in a given year and for a specific result status. The placeholders allow for dynamic input of the person's name, the year range, and the result type (e.g., nominee or winner)."
        },
        {
            "sample_id": 4184,
            "vt": "SELECT award.award_id, award.award_category FROM award WHERE award.person = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique identifiers and categories of awards from the 'award' table that are associated with a specific person. The placeholder in the WHERE clause represents the name of the person who received the awards."
        },
        {
            "sample_id": 4226,
            "vt": "SELECT episode.title, episode.episode_image, award.award, award.person FROM award INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE episode.rating BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND SUBSTRING(episode.air_date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles and images of episodes from the 'episode' table that have received specific awards. It includes the name of the award and the person who received it, filtered by the episode's rating range, a specific part of the air date, and the result of the award (whether it was won or not). The placeholders represent the numeric values for ratings and the string values for the air date and award result."
        }
    ],
    "chicago_crime": [
        {
            "sample_id": 8645,
            "vt": "SELECT iucr.secondary_description, crime.latitude, crime.longitude FROM iucr INNER JOIN Crime AS T2 ON T1.iucr_no = T2.iucr_no WHERE crime.iucr_no = [placeholder-type:numeric]",
            "ba": "The virtual table describes the secondary descriptions of incidents from the 'iucr' table along with their geographical coordinates (latitude and longitude) from the 'crime' table. The placeholder in the WHERE clause represents the specific incident classification code."
        },
        {
            "sample_id": 8685,
            "vt": "SELECT crime.case_number, crime.latitude, crime.longitude FROM crime INNER JOIN IUCR AS T2 ON T2.iucr_no = T1.iucr_no WHERE iucr.secondary_description = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about crime incidents, specifically the case number and geographical coordinates (latitude and longitude) of each incident. It filters the results based on a specific secondary description of the incident classification, allowing users to focus on particular types of crimes as defined in the IUCR table."
        },
        {
            "sample_id": 8726,
            "vt": "SELECT CAST(COUNT(fbi_code.fbi_code_no) AS FLOAT) / [placeholder-type:numeric] FROM fbi_code INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no WHERE SUBSTRING(crime.date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND SUBSTRING(crime.date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the ratio of the number of crime reports associated with specific FBI codes to a specified numeric value. It joins the 'fbi_code' table with the 'crime' table based on the FBI code identifier. The query filters the results based on specific parts of the crime date, which are extracted using substring functions, allowing for flexible date filtering."
        },
        {
            "sample_id": 8758,
            "vt": "SELECT COUNT(*) FROM iucr WHERE iucr.index_code = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of incident classifications from the 'iucr' table that fall under a specific index code, which indicates whether the crime is indexed or non-indexed."
        },
        {
            "sample_id": 8678,
            "vt": "SELECT fbi_code.fbi_code_no, fbi_code.description FROM fbi_code WHERE fbi_code.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique FBI code and its detailed description for a specific type of crime from the 'fbi_code' table. The placeholder in the WHERE clause represents the title of the crime being queried."
        },
        {
            "sample_id": 8748,
            "vt": "SELECT ward.ward_office_address FROM community_area INNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no INNER JOIN Ward AS T3 ON T2.ward_no = T3.ward_no WHERE community_area.community_area_name = '[placeholder-type:string]' GROUP BY ward.ward_office_address LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the addresses of ward offices associated with a specific community area. It retrieves this information by joining the 'community_area' table with the 'crime' table to filter by community area, and then further joins with the 'ward' table to access the ward office addresses. The query groups the results by ward office address and limits the output based on a specified numeric value."
        },
        {
            "sample_id": 8670,
            "vt": "SELECT district.address FROM district INNER JOIN Crime AS T2 ON T2.district_no = T1.district_no WHERE crime.case_number = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the street address of the police district building associated with a specific crime case number. It joins the 'district' table with the 'crime' table to link the district information to the crime report based on the district number."
        },
        {
            "sample_id": 8675,
            "vt": "SELECT community_area.community_area_name, community_area.side FROM community_area WHERE community_area.side = '[placeholder-type:string]' AND community_area.population BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table describes the names and sides of community areas from the 'community_area' table that belong to a specific district and have a population within a specified range. The placeholders in the WHERE clause represent the district side and the population limits."
        },
        {
            "sample_id": 8649,
            "vt": "SELECT SUM(CASE WHEN fbi_code.title = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM fbi_code INNER JOIN Crime AS T2 ON T2.fbi_code_no = T1.fbi_code_no",
            "ba": "The virtual table calculates the total number of crimes classified under a specific FBI code from the 'fbi_code' table by summing the occurrences of that code in the 'crime' table. The placeholder in the SELECT statement represents the title of the FBI code, while the numeric placeholders represent the counts of crimes that match or do not match the specified code."
        },
        {
            "sample_id": 8674,
            "vt": "SELECT COUNT(crime.report_no) FROM crime INNER JOIN Ward AS T2 ON T1.ward_no = T2.ward_no WHERE ward.population < [placeholder-type:numeric] AND crime.beat > (SELECT AVG(crime.beat) * [placeholder-type:numeric] FROM Crime AS T1 INNER JOIN Ward AS T2 ON T1.ward_no = T2.ward_no WHERE T2.Population < 52000)",
            "ba": "The virtual table counts the number of crime reports from the 'crime' table, filtering based on the population of the wards and the average beat value. It joins the 'crime' table with the 'ward' table to access ward population data and applies conditions to ensure that only wards with a population below a specified threshold are considered. Additionally, it compares the crime beat value against an average calculated from other wards with populations below a certain limit, allowing for a focused analysis of crime in less populated areas."
        },
        {
            "sample_id": 8620,
            "vt": "SELECT CAST(SUM(CASE WHEN fbi_code.title = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(crime.case_number) FROM community_area INNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no INNER JOIN FBI_Code AS T3 ON T2.fbi_code_no = T3.fbi_code_no WHERE community_area.community_area_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of a specific crime type's occurrence in a given community area. It sums the occurrences of crimes classified under a specific FBI code title, adjusts this sum by a specified weight, and divides it by the total number of reported crimes in that community area. The placeholders represent the crime title, weight, and community area name."
        },
        {
            "sample_id": 8672,
            "vt": "SELECT crime.case_number FROM fbi_code INNER JOIN Crime AS T2 ON T2.fbi_code_no = T1.fbi_code_no WHERE crime.date LIKE '[placeholder-type:string]' AND fbi_code.crime_against = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the case numbers of crimes from the 'crime' table that match a specific date and are classified under a certain category of crime against a specified group, as defined in the 'fbi_code' table."
        },
        {
            "sample_id": 8640,
            "vt": "SELECT iucr.index_code FROM iucr WHERE iucr.primary_description = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the index code from the 'iucr' table based on a specific primary description of an incident classification. The index code indicates whether the crime is severe or less severe."
        },
        {
            "sample_id": 8646,
            "vt": "SELECT SUM(CASE WHEN ward.alderman_last_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM crime INNER JOIN Ward AS T2 ON T1.ward_no = T2.ward_no WHERE ward.alderman_name_suffix IS NULL AND ward.alderman_first_name = '[placeholder-type:string]' AND crime.date LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of crimes reported in a specific ward, filtered by the first name of the alderman and the date of the incident. It uses a conditional sum to differentiate between cases based on the alderman's last name, while also ensuring that the alderman's name suffix is null."
        },
        {
            "sample_id": 8734,
            "vt": "SELECT neighborhood.neighborhood_name FROM community_area INNER JOIN Neighborhood AS T2 ON T1.community_area_no = T2.community_area_no WHERE community_area.community_area_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of neighborhoods from the 'neighborhood' table that are associated with a specific community area. The query uses an INNER JOIN to connect the 'community_area' and 'neighborhood' tables based on the community area number, filtering results by the name of the community area provided as a placeholder."
        },
        {
            "sample_id": 8679,
            "vt": "SELECT CAST(COUNT(CASE WHEN iucr.index_code = '[placeholder-type:string]' THEN iucr.iucr_no ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(iucr.iucr_no) FROM iucr",
            "ba": "The virtual table calculates the proportion of incidents classified under a specific index code from the 'iucr' table. It counts the number of incidents that match the specified index code and divides it by the total number of incidents, then multiplies the result by a numeric placeholder to adjust the final value."
        },
        {
            "sample_id": 8727,
            "vt": "SELECT community_area.community_area_name FROM community_area WHERE community_area.population > [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of community areas from the 'community_area' table that have a population greater than a specified number. The placeholders in the WHERE clause represent the population threshold and the limit on the number of results returned."
        },
        {
            "sample_id": 8700,
            "vt": "SELECT SUM(CASE WHEN crime.domestic = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM district INNER JOIN Crime AS T2 ON T2.district_no = T1.district_no WHERE district.commander = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of domestic incidents reported in a specific district, based on the commander's name. It uses a conditional sum to differentiate between domestic and non-domestic incidents."
        },
        {
            "sample_id": 8729,
            "vt": "SELECT SUM(CASE WHEN community_area.side = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN community_area.side = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM community_area WHERE community_area.population > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the difference in the sum of a certain numeric value based on the 'side' of the community area from the 'community_area' table, filtered by a minimum population threshold. The placeholders represent specific values for the side of the community area and the numeric values to be summed."
        },
        {
            "sample_id": 8638,
            "vt": "SELECT SUM(CASE WHEN ward.alderman_last_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM ward INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no INNER JOIN FBI_Code AS T3 ON T2.fbi_code_no = T3.fbi_code_no WHERE fbi_code.title = '[placeholder-type:string]' AND crime.arrest = '[placeholder-type:string]' AND ward.alderman_first_name = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total number of crimes reported in a specific ward, filtered by the alderman's last name and first name, as well as the title of the crime according to the FBI classification. The placeholders represent the specific values for the alderman's names and the crime title, while the SUM function aggregates the results based on these criteria."
        },
        {
            "sample_id": 8702,
            "vt": "SELECT district.phone FROM ward INNER JOIN Crime AS T2 ON T2.ward_no = T1.ward_no INNER JOIN District AS T3 ON T3.district_no = T2.district_no WHERE ward.alderman_first_name = '[placeholder-type:string]' AND ward.alderman_last_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the phone number of the district associated with a specific ward, identified by the first and last name of the alderman. It joins the 'ward' table with the 'crime' table to link the ward to its corresponding crime reports, and then further joins with the 'district' table to access the district's contact information."
        },
        {
            "sample_id": 8591,
            "vt": "SELECT community_area.community_area_name FROM neighborhood INNER JOIN Community_Area AS T2 ON T1.community_area_no = T2.community_area_no WHERE neighborhood.neighborhood_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of community areas associated with a specific neighborhood. It retrieves the community area name from the 'community_area' table by joining it with the 'neighborhood' table based on the community area number. The placeholder in the WHERE clause represents the neighborhood's name."
        },
        {
            "sample_id": 8692,
            "vt": "SELECT ROUND(CAST(COUNT(CASE WHEN iucr.secondary_description = '[placeholder-type:string]' THEN iucr.iucr_no END) AS FLOAT) / CAST(COUNT(DISTINCT CASE WHEN T1.secondary_description = 'VEHICULAR HIJACKING' THEN T3.district_name END) AS FLOAT) - CAST(COUNT(CASE WHEN iucr.secondary_description = '[placeholder-type:string]' THEN iucr.iucr_no END) AS FLOAT) / CAST(COUNT(DISTINCT CASE WHEN T1.secondary_description = 'AGGRAVATED VEHICULAR HIJACKING' THEN T3.district_name END) AS FLOAT), [placeholder-type:numeric]) FROM iucr INNER JOIN Crime AS T2 ON T2.iucr_no = T1.iucr_no INNER JOIN District AS T3 ON T3.district_no = T2.district_no",
            "ba": "The virtual table calculates the ratio of specific crime incidents to the total number of distinct districts where certain types of vehicular hijacking crimes occurred. It uses placeholders for the secondary description of the crime and a numeric value for rounding the result."
        },
        {
            "sample_id": 8751,
            "vt": "SELECT neighborhood.neighborhood_name FROM community_area INNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no INNER JOIN Neighborhood AS T3 ON T2.community_area_no = T3.community_area_no WHERE crime.report_no = [placeholder-type:numeric]",
            "ba": "The virtual table describes the neighborhood names associated with a specific crime report from the 'crime' table. It joins the 'community_area' table to link community areas with crimes and the 'neighborhood' table to retrieve the neighborhood names. The placeholder in the WHERE clause represents the unique identifier of the crime report."
        },
        {
            "sample_id": 8762,
            "vt": "SELECT crime.latitude, crime.longitude FROM ward INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE ward.alderman_first_name = '[placeholder-type:string]' AND ward.alderman_last_name = '[placeholder-type:string]' AND NOT crime.latitude IS NULL AND NOT crime.longitude IS NULL",
            "ba": "The virtual table provides the latitude and longitude of crime incidents that occurred in specific wards, filtered by the first and last names of the alderman responsible for those wards. It ensures that only records with valid geographic coordinates are included."
        },
        {
            "sample_id": 8768,
            "vt": "SELECT SUM(CASE WHEN SUBSTRING(crime.date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM district INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no WHERE district.commander = '[placeholder-type:string]' AND SUBSTRING(crime.date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of crimes reported in a specific district for a given date. It joins the 'district' table with the 'crime' table based on the district number, filtering results by the district commander's name and the specified date. The placeholders represent the specific date, the commander's name, and the positions for extracting the year and month from the date string."
        },
        {
            "sample_id": 8715,
            "vt": "SELECT SUM(CASE WHEN crime.longitude = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM crime INNER JOIN IUCR AS T2 ON T1.report_no = T2.iucr_no WHERE iucr.index_code = '[placeholder-type:string]' AND crime.latitude = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of crimes based on specific geographic coordinates (longitude and latitude) and the index code of the crime classification. It joins the 'crime' table with the 'iucr' table to filter the results according to the index code, which indicates whether the crime is indexed or non-indexed. The placeholders represent the longitude, latitude, and index code values that can be modified by the user to generate specific queries."
        },
        {
            "sample_id": 8722,
            "vt": "SELECT SUM(CASE WHEN fbi_code.description LIKE '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM fbi_code INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no WHERE crime.arrest = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of crimes based on a specific description from the 'fbi_code' table, while also filtering the results based on whether an arrest was made or not. The placeholders represent the crime description and the arrest status."
        },
        {
            "sample_id": 8612,
            "vt": "SELECT iucr.iucr_no FROM crime INNER JOIN IUCR AS T2 ON T1.iucr_no = T2.iucr_no WHERE crime.case_number = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier for the incident classification from the 'iucr' table based on a specific case number from the 'crime' table. The placeholder in the WHERE clause represents the case number of the reported crime."
        },
        {
            "sample_id": 8588,
            "vt": "SELECT community_area.community_area_name FROM community_area ORDER BY community_area.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of community areas from the 'community_area' table, ordered by their population. The placeholder in the LIMIT clause allows the user to specify how many community area names they want to retrieve."
        },
        {
            "sample_id": 8665,
            "vt": "SELECT crime.case_number FROM crime INNER JOIN Ward AS T2 ON T2.ward_no = T1.ward_no WHERE crime.location_description = '[placeholder-type:string]' AND ward.ward_office_address = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the case numbers of crimes from the 'crime' table based on specific conditions related to the location description and the ward office address. The placeholders represent the values for filtering the results."
        },
        {
            "sample_id": 8711,
            "vt": "SELECT COUNT(*) FROM fbi_code WHERE fbi_code.crime_against = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of crime classifications from the 'fbi_code' table that specify who the crime is against. The placeholder in the WHERE clause represents the type of victim, which can be Persons, Property, Society, or Persons and Society."
        },
        {
            "sample_id": 8713,
            "vt": "SELECT fbi_code.crime_against FROM fbi_code WHERE fbi_code.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the type of crime against whom it is classified in the 'fbi_code' table based on a specific crime title. The placeholder in the WHERE clause represents the title of the crime being queried."
        },
        {
            "sample_id": 8752,
            "vt": "SELECT fbi_code.description FROM fbi_code INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no WHERE crime.report_no = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves detailed descriptions of crimes from the 'fbi_code' table based on a specific crime report number. It uses an inner join to connect the 'fbi_code' table with the 'crime' table, ensuring that only the relevant descriptions for the specified report number are returned."
        },
        {
            "sample_id": 8664,
            "vt": "SELECT crime.case_number FROM community_area INNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no WHERE community_area.community_area_name = '[placeholder-type:string]' AND crime.domestic = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the case numbers of crimes that occurred in a specific community area, filtered by whether the incident was classified as domestic violence. The query joins the 'community_area' table with the 'crime' table based on the community area number, allowing for the selection of case numbers associated with a given community area name and a specified domestic violence status."
        },
        {
            "sample_id": 8628,
            "vt": "SELECT fbi_code.title FROM crime INNER JOIN FBI_Code AS T2 ON T1.fbi_code_no = T2.fbi_code_no ORDER BY fbi_code.fbi_code_no LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of crime classifications from the 'FBI_Code' table based on the associated crime reports in the 'crime' table. The results are ordered by the FBI code number and limited to a specified number of entries."
        },
        {
            "sample_id": 8605,
            "vt": "SELECT COUNT(*) FROM community_area WHERE community_area.side = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of community areas from the 'community_area' table that belong to a specific side (district). The placeholder in the WHERE clause represents the side of the community area."
        },
        {
            "sample_id": 8746,
            "vt": "SELECT crime.beat, crime.location_description FROM crime WHERE crime.case_number = '[placeholder-type:string]'",
            "ba": "The virtual table describes the beat and location description of a crime from the 'crime' table based on a specific case number. The placeholder in the WHERE clause represents the case number of the reported crime."
        },
        {
            "sample_id": 8637,
            "vt": "SELECT community_area.community_area_name FROM crime INNER JOIN IUCR AS T2 ON T1.iucr_no = T2.iucr_no INNER JOIN Community_Area AS T3 ON T1.community_area_no = T3.community_area_no WHERE iucr.primary_description = '[placeholder-type:string]' GROUP BY crime.iucr_no ORDER BY crime.case_number LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of community area names from the 'community_area' table that are associated with specific crime incidents. It filters the results based on the primary description of the incident classification from the 'iucr' table, allowing users to focus on a particular type of crime. The results are grouped by the unique incident classification code and ordered by the case number, with a limit on the number of results returned."
        },
        {
            "sample_id": 8694,
            "vt": "SELECT iucr.secondary_description FROM iucr WHERE iucr.primary_description = '[placeholder-type:string]' GROUP BY iucr.secondary_description",
            "ba": "The virtual table retrieves the specific descriptions of incident classifications from the 'iucr' table based on a given primary description. The placeholder in the WHERE clause represents the general description of the incident classification, allowing users to filter results accordingly."
        },
        {
            "sample_id": 8728,
            "vt": "SELECT community_area.community_area_name FROM community_area WHERE community_area.side = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of community areas from the 'community_area' table that are located on a specific side of the district. The placeholder in the WHERE clause represents the side of the district being queried."
        },
        {
            "sample_id": 8650,
            "vt": "SELECT neighborhood.neighborhood_name FROM community_area INNER JOIN Neighborhood AS T2 ON T2.community_area_no = T1.community_area_no WHERE community_area.community_area_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of neighborhoods from the 'neighborhood' table that are associated with a specific community area. The query uses an INNER JOIN to connect the 'community_area' and 'neighborhood' tables based on the community area number, filtering results by the specified community area name."
        },
        {
            "sample_id": 8631,
            "vt": "SELECT SUM(CASE WHEN crime.arrest = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM community_area INNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no INNER JOIN IUCR AS T3 ON T2.iucr_no = T3.iucr_no WHERE community_area.community_area_name = '[placeholder-type:string]' AND iucr.secondary_description = '[placeholder-type:string]' AND iucr.primary_description = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total number of arrests made in a specific community area for a particular type of crime, based on the primary and secondary descriptions of the incident classification. It joins the 'community_area' table with the 'crime' table and the 'iucr' table to filter the results according to the specified community area name and crime descriptions."
        },
        {
            "sample_id": 8668,
            "vt": "SELECT SUM(CASE WHEN fbi_code.crime_against = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM fbi_code INNER JOIN Crime AS T2 ON T2.fbi_code_no = T1.fbi_code_no INNER JOIN Community_Area AS T3 ON T3.community_area_no = T2.community_area_no WHERE community_area.community_area_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of crimes against a specific group (e.g., Persons, Property, Society) in a given community area. It uses the FBI code to classify the type of crime and sums the occurrences based on the specified criteria."
        },
        {
            "sample_id": 8721,
            "vt": "SELECT crime.location_description FROM community_area INNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no WHERE community_area.population = (SELECT MIN(community_area.population) FROM Community_Area) AND NOT crime.location_description IS NULL GROUP BY crime.location_description",
            "ba": "The virtual table retrieves the location descriptions of crimes that occurred in the community area with the smallest population. It filters out any null values for location descriptions and groups the results to ensure unique entries."
        },
        {
            "sample_id": 8770,
            "vt": "SELECT crime.block FROM district INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no WHERE district.commander = '[placeholder-type:string]'",
            "ba": "The virtual table describes the blocks where crimes occurred, filtered by the district commander. It retrieves data from the 'district' table and joins it with the 'crime' table based on the district number. The placeholder in the WHERE clause represents the name of the district's commanding officer."
        },
        {
            "sample_id": 8771,
            "vt": "SELECT COUNT(ward.ward_no) / [placeholder-type:numeric] FROM ward INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE crime.date LIKE '[placeholder-type:string]' AND ward.population = (SELECT MAX(ward.population) FROM Ward AS T1 INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE T2.date LIKE '%2018%')",
            "ba": "The virtual table calculates the ratio of the number of wards to a specified numeric value, filtering the results based on the date of crime incidents and the maximum population of wards that have reported crimes in a specific year."
        },
        {
            "sample_id": 8772,
            "vt": "SELECT CAST(SUM(CASE WHEN iucr.primary_description = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM iucr INNER JOIN Crime AS T2 ON T1.iucr_no = T2.iucr_no WHERE crime.arrest = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of a specific incident classification from the 'iucr' table based on the number of arrests made in the 'crime' table. It sums the values of a specified primary description and divides it by the total count of incidents, applying a multiplier for further adjustment. The placeholders represent the primary description of the incident, a numeric value for weighting, and a string indicating whether an arrest was made."
        },
        {
            "sample_id": 8750,
            "vt": "SELECT neighborhood.neighborhood_name FROM community_area INNER JOIN Neighborhood AS T2 ON T1.community_area_no = T2.community_area_no WHERE community_area.community_area_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of neighborhoods from the 'neighborhood' table that are associated with a specific community area. The query uses an INNER JOIN to connect the 'community_area' and 'neighborhood' tables based on the community area number, filtering results by the name of the community area provided as a placeholder."
        },
        {
            "sample_id": 8754,
            "vt": "SELECT CAST(SUM(CASE WHEN crime.location_description = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(crime.location_description) FROM community_area INNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no INNER JOIN Neighborhood AS T3 ON T2.community_area_no = T3.community_area_no WHERE neighborhood.neighborhood_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of a specific numeric value from the 'crime' table based on the location description of incidents that occurred in a specified neighborhood. It joins the 'community_area', 'crime', and 'neighborhood' tables to filter the data according to the neighborhood name provided."
        },
        {
            "sample_id": 8703,
            "vt": "SELECT SUM(CASE WHEN community_area.community_area_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM fbi_code INNER JOIN Crime AS T2 ON T2.fbi_code_no = T1.fbi_code_no INNER JOIN Community_Area AS T3 ON T3.community_area_no = T2.community_area_no WHERE fbi_code.description = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of crimes reported in a specific community area based on the FBI classification of the crime. It uses a conditional sum to differentiate between crimes that occurred in the specified community area and those that did not, allowing for a comprehensive overview of crime statistics in relation to community demographics."
        },
        {
            "sample_id": 8615,
            "vt": "SELECT neighborhood.neighborhood_name FROM neighborhood INNER JOIN Community_Area AS T2 ON T1.community_area_no = T2.community_area_no WHERE community_area.community_area_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of neighborhoods from the 'neighborhood' table that are associated with a specific community area. The query uses an INNER JOIN to connect the 'neighborhood' table with the 'community_area' table based on the community area number, filtering results to only include neighborhoods that belong to a specified community area name."
        },
        {
            "sample_id": 8622,
            "vt": "SELECT community_area.community_area_name FROM community_area ORDER BY community_area.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of community areas from the 'community_area' table, ordered by their population. The placeholder in the LIMIT clause allows the user to specify how many community area names they want to retrieve."
        },
        {
            "sample_id": 8766,
            "vt": "SELECT crime.case_number FROM fbi_code INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no WHERE fbi_code.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the case numbers of crimes from the 'Crime' table that are classified under a specific FBI code. It joins the 'fbi_code' table to filter the results based on the title of the crime, which is provided as a placeholder."
        },
        {
            "sample_id": 8705,
            "vt": "SELECT crime.domestic FROM community_area INNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no WHERE community_area.community_area_name = '[placeholder-type:string]' AND crime.domestic = '[placeholder-type:string]' GROUP BY crime.domestic ORDER BY COUNT(crime.domestic) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the domestic violence incidents reported in a specific community area. It retrieves the domestic violence status from the 'crime' table, joining it with the 'community_area' table to filter by the community area name. The results are grouped by the domestic violence status and ordered by the count of incidents, with a limit on the number of results returned."
        },
        {
            "sample_id": 8716,
            "vt": "SELECT district.commander FROM crime INNER JOIN District AS T2 ON T1.district_no = T2.district_no WHERE crime.arrest = '[placeholder-type:string]' GROUP BY district.commander ORDER BY COUNT(crime.report_no) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of district commanders from the 'district' table based on the number of crime reports where an arrest has been made or not. It uses a join between the 'crime' and 'district' tables, filtering results based on the arrest status and grouping by the commander's name to count the number of reports associated with each commander. The results are ordered by the count of reports and limited to a specified number."
        },
        {
            "sample_id": 8662,
            "vt": "SELECT SUM(CASE WHEN crime.location_description = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM fbi_code INNER JOIN Crime AS T2 ON T2.fbi_code_no = T1.fbi_code_no WHERE fbi_code.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of crimes that occurred in a specific location description, based on the classification of the crime as defined by the FBI. It joins the 'fbi_code' table with the 'crime' table to filter the results by a specific crime title, using placeholders for both the location description and the numeric values to be summed."
        },
        {
            "sample_id": 8687,
            "vt": "SELECT community_area.community_area_no FROM crime INNER JOIN Community_Area AS T2 ON T2.community_area_no = T1.community_area_no WHERE crime.domestic = '[placeholder-type:string]' GROUP BY community_area.community_area_no ORDER BY COUNT(community_area.community_area_no) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of unique community area numbers from the 'community_area' table that are associated with reported crimes classified as domestic violence. The query joins the 'crime' table with the 'community_area' table based on the community area number, filters the results to include only those incidents marked as domestic, groups the results by community area number, and orders them by the count of incidents in each area. The placeholders allow for specifying the type of domestic violence and limiting the number of results returned."
        },
        {
            "sample_id": 8616,
            "vt": "SELECT SUM(CASE WHEN community_area.community_area_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM community_area INNER JOIN Neighborhood AS T2 ON T1.community_area_no = T2.community_area_no",
            "ba": "The virtual table calculates the total population of a specified community area by summing the population values from the 'community_area' table. It joins the 'community_area' table with the 'neighborhood' table to ensure that the community area is correctly identified based on its unique number. The placeholder in the WHERE clause represents the name of the community area, while the numeric placeholders represent the population values being summed."
        },
        {
            "sample_id": 8633,
            "vt": "SELECT SUM(CASE WHEN community_area.community_area_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM community_area INNER JOIN Neighborhood AS T2 ON T1.community_area_no = T2.community_area_no",
            "ba": "The virtual table calculates the total population of a specified community area by summing the population values from the 'community_area' table. It joins the 'community_area' table with the 'neighborhood' table to ensure that the community area is correctly identified based on its unique number. The placeholder in the WHERE clause represents the name of the community area, while the numeric placeholders represent the population values being summed."
        },
        {
            "sample_id": 8696,
            "vt": "SELECT crime.report_no FROM fbi_code INNER JOIN Crime AS T2 ON T2.fbi_code_no = T1.fbi_code_no WHERE fbi_code.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the unique report numbers of crimes from the 'crime' table that are classified under a specific FBI code. The query joins the 'fbi_code' table with the 'crime' table based on the FBI code identifier, filtering results to only include those crimes that match a specified title."
        },
        {
            "sample_id": 8745,
            "vt": "SELECT ward.ward_no FROM ward ORDER BY ward.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique identifiers for legislative districts (wards) from the 'ward' table, ordered by the population of each ward. The placeholder in the LIMIT clause allows the user to specify how many wards to retrieve based on their population size."
        },
        {
            "sample_id": 8627,
            "vt": "SELECT district.commander FROM district INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no INNER JOIN FBI_Code AS T3 ON T2.fbi_code_no = T3.fbi_code_no WHERE fbi_code.title = '[placeholder-type:string]' AND crime.fbi_code_no = [placeholder-type:numeric] GROUP BY crime.fbi_code_no ORDER BY COUNT(district.district_no) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of district commanders from the 'district' table, based on the crimes reported in the 'crime' table. It joins the 'district' table with the 'crime' table using the district number, and further joins with the 'fbi_code' table to filter crimes by their title and FBI code. The results are grouped by the FBI code number and ordered by the count of occurrences in each district, with a limit on the number of results returned."
        },
        {
            "sample_id": 8693,
            "vt": "SELECT COUNT(*) FROM crime WHERE crime.longitude = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of crime incidents recorded in the 'crime' table that occurred at a specific longitude. The placeholder in the WHERE clause represents the longitude value for filtering the results."
        },
        {
            "sample_id": 8626,
            "vt": "SELECT fbi_code.description FROM fbi_code WHERE fbi_code.crime_against = '[placeholder-type:string]'",
            "ba": "The virtual table describes the detailed descriptions of crimes from the 'fbi_code' table that are classified as being against a specific group. The placeholder in the WHERE clause represents the category of individuals or entities that the crime is directed against."
        },
        {
            "sample_id": 8644,
            "vt": "SELECT fbi_code.title, fbi_code.description FROM fbi_code WHERE fbi_code.crime_against = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles and detailed descriptions of crimes from the 'fbi_code' table that are classified as being against a specific group. The placeholder in the WHERE clause represents the category of individuals or entities that the crime is directed against."
        },
        {
            "sample_id": 8599,
            "vt": "SELECT COUNT(crime.report_no) FROM community_area INNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no GROUP BY community_area.community_area_name ORDER BY community_area.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a count of reported crimes grouped by community area name from the 'community_area' table. It joins with the 'crime' table to associate each crime with its respective community area. The results are ordered by the population of each community area, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 8684,
            "vt": "SELECT ward.ward_office_address, ward.ward_office_phone FROM crime INNER JOIN Ward AS T2 ON T2.ward_no = T1.ward_no WHERE crime.arrest = '[placeholder-type:string]' GROUP BY ward.ward_office_address, ward.ward_office_phone ORDER BY COUNT(crime.arrest) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the addresses and phone numbers of ward offices associated with crime reports where an arrest has been made or not made, depending on the specified condition. The results are grouped by the ward office address and phone number, and ordered by the count of arrests, allowing for a limit on the number of results returned."
        },
        {
            "sample_id": 8676,
            "vt": "SELECT crime.latitude, crime.longitude FROM crime WHERE crime.location_description = '[placeholder-type:string]' AND crime.arrest = '[placeholder-type:string]' GROUP BY crime.latitude, crime.longitude",
            "ba": "The virtual table provides the latitude and longitude coordinates of crime incidents from the 'crime' table, filtered by a specific location description and whether an arrest was made. The placeholders in the WHERE clause allow users to specify the desired location and arrest status."
        },
        {
            "sample_id": 8720,
            "vt": "SELECT district.district_name FROM crime INNER JOIN District AS T2 ON T1.district_no = T2.district_no WHERE crime.domestic = '[placeholder-type:string]' GROUP BY district.district_name ORDER BY COUNT(crime.district_no) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of district names from the 'District' table that are associated with reported crimes classified as domestic violence. The query filters the results based on whether the crime is marked as domestic, using a placeholder for the true/false value. Additionally, it groups the results by district name and orders them by the count of crimes in each district, limiting the output to a specified number of districts."
        },
        {
            "sample_id": 8686,
            "vt": "SELECT iucr.secondary_description FROM community_area INNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no INNER JOIN IUCR AS T3 ON T3.iucr_no = T2.iucr_no WHERE community_area.side = '[placeholder-type:string]' GROUP BY iucr.secondary_description ORDER BY COUNT(*) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of secondary descriptions of incidents from the 'IUCR' table that occurred in community areas belonging to a specific side. It filters the community areas based on the specified side and groups the results by secondary description, ordering them by the count of occurrences, and limiting the results to a specified number."
        },
        {
            "sample_id": 8671,
            "vt": "SELECT [placeholder-type:numeric] * SUM(CASE WHEN community_area.population > [placeholder-type:numeric] THEN crime.beat ELSE [placeholder-type:numeric] END) FROM community_area INNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no WHERE community_area.side = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of crimes reported in community areas that have a population greater than a specified number. It joins the 'community_area' table with the 'crime' table based on the community area number. The result is filtered by the district side, which is specified by a placeholder. The query uses a conditional sum to count the beats of crimes only in those community areas that meet the population criteria."
        },
        {
            "sample_id": 8707,
            "vt": "SELECT district.commander FROM iucr INNER JOIN Crime AS T2 ON T2.iucr_no = T1.iucr_no INNER JOIN District AS T3 ON T3.district_no = T2.district_no WHERE iucr.secondary_description = '[placeholder-type:string]' GROUP BY district.commander ORDER BY COUNT(iucr.secondary_description) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of district commanders from the 'district' table based on the secondary description of incidents from the 'iucr' table. It joins the 'crime' table to filter incidents by their unique classification and groups the results by the commander's name, ordering them by the count of incidents associated with each commander. The placeholders allow for specifying a particular secondary description of crime and limiting the number of results returned."
        },
        {
            "sample_id": 8608,
            "vt": "SELECT district.district_name FROM crime INNER JOIN District AS T2 ON T1.district_no = T2.district_no WHERE crime.longitude = '[placeholder-type:string]' AND crime.latitude = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of districts from the 'district' table based on the geographic coordinates (longitude and latitude) of reported crimes. The placeholders in the WHERE clause represent the specific longitude and latitude values for filtering the results."
        },
        {
            "sample_id": 8749,
            "vt": "SELECT district.address, district.commander FROM crime INNER JOIN District AS T2 ON T1.district_no = T2.district_no WHERE crime.location_description = '[placeholder-type:string]' AND crime.beat = [placeholder-type:numeric]",
            "ba": "The virtual table provides the address and commander's name of the police district associated with specific crime incidents. It filters the results based on the location description of the crime and the beat number, allowing users to focus on particular areas and their corresponding police district information."
        },
        {
            "sample_id": 8629,
            "vt": "SELECT SUM(CASE WHEN fbi_code.title = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM district INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no INNER JOIN FBI_Code AS T3 ON T2.fbi_code_no = T3.fbi_code_no WHERE district.district_name = '[placeholder-type:string]' AND crime.arrest = '[placeholder-type:string]' AND crime.location_description = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total number of crimes from the 'Crime' table that match a specific FBI code title, filtered by the district name, whether an arrest was made, and the location description. The placeholders represent the FBI code title, the district name, the arrest status, and the location description respectively."
        },
        {
            "sample_id": 8621,
            "vt": "SELECT SUM(CASE WHEN crime.date LIKE '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM crime WHERE crime.block = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total number of crimes reported on a specific date and block from the 'crime' table. The placeholders represent the date and block for which the crime data is being aggregated."
        },
        {
            "sample_id": 8731,
            "vt": "SELECT district.commander FROM district WHERE district.district_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the name of the commanding officer for a specific district from the 'district' table. The placeholder in the WHERE clause represents the name of the district being queried."
        },
        {
            "sample_id": 8625,
            "vt": "SELECT SUM(CASE WHEN crime.arrest = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM crime WHERE crime.date LIKE '[placeholder-type:string]' AND crime.location_description = '[placeholder-type:string]' AND crime.fbi_code_no = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total number of arrests made for crimes that occurred on a specific date, in a specific location, and classified under a specific FBI code. The placeholders represent the criteria for filtering the data, including the arrest status, date of the crime, location description, and the FBI code associated with the crime."
        },
        {
            "sample_id": 8661,
            "vt": "SELECT crime.report_no FROM ward INNER JOIN Crime AS T2 ON T2.ward_no = T1.ward_no INNER JOIN Community_Area AS T3 ON T3.community_area_no = T2.community_area_no WHERE ward.alderman_first_name = '[placeholder-type:string]' AND ward.alderman_last_name = '[placeholder-type:string]' ORDER BY crime.beat, community_area.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the report numbers of crimes that occurred in specific wards represented by the alderman's first and last names. It joins the 'ward' table with the 'crime' table to filter crimes based on the ward number, and further joins with the 'community_area' table to access community area details. The results are ordered by the crime beat and the population of the community area, with a limit on the number of results returned."
        },
        {
            "sample_id": 8710,
            "vt": "SELECT ward.alderman_first_name, ward.alderman_last_name FROM ward ORDER BY ward.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of aldermen from the 'ward' table, ordered by the population of each ward. The placeholder in the LIMIT clause represents the maximum number of records to return."
        },
        {
            "sample_id": 8613,
            "vt": "SELECT community_area.community_area_name FROM iucr INNER JOIN Crime AS T2 ON T1.iucr_no = T2.iucr_no INNER JOIN Community_Area AS T3 ON T2.community_area_no = T3.community_area_no WHERE iucr.primary_description = '[placeholder-type:string]' AND iucr.secondary_description = '[placeholder-type:string]' GROUP BY crime.community_area_no ORDER BY crime.case_number LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of community area names from the 'community_area' table based on specific incident classifications. It filters the results by the primary and secondary descriptions of the incidents from the 'iucr' table, ensuring that only relevant community areas are included. The results are grouped by community area number and ordered by case number, with a limit on the number of results returned."
        },
        {
            "sample_id": 8647,
            "vt": "SELECT SUM(CASE WHEN crime.arrest = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM crime INNER JOIN District AS T2 ON T1.district_no = T2.district_no WHERE district.district_name = '[placeholder-type:string]' AND crime.location_description = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total number of arrests made in a specific district for crimes that occurred in a particular location. It uses a conditional sum to count arrests based on whether an arrest was made or not, and it filters the results by the district name and the location description."
        },
        {
            "sample_id": 8585,
            "vt": "SELECT COUNT(*) FROM community_area WHERE community_area.side = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of community areas from the 'community_area' table that belong to a specific side (district). The placeholder in the WHERE clause represents the side of the community area."
        },
        {
            "sample_id": 8653,
            "vt": "SELECT crime.location_description, ward.alderman_first_name, ward.alderman_last_name, ward.alderman_name_suffix FROM ward INNER JOIN Crime AS T2 ON T2.ward_no = T1.ward_no INNER JOIN IUCR AS T3 ON T3.iucr_no = T2.iucr_no WHERE iucr.primary_description = '[placeholder-type:string]' AND iucr.secondary_description = '[placeholder-type:string]'",
            "ba": "The virtual table describes the location of crimes along with the names and suffixes of the aldermen representing the wards where these crimes occurred. It combines data from the 'crime' and 'ward' tables, filtering based on specific primary and secondary descriptions of incidents using placeholders for user-defined values."
        },
        {
            "sample_id": 8652,
            "vt": "SELECT CAST(COUNT(CASE WHEN fbi_code.title = '[placeholder-type:string]' THEN crime.report_no END) AS FLOAT) * [placeholder-type:numeric] / COUNT(crime.report_no) FROM community_area INNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no INNER JOIN FBI_Code AS T3 ON T3.fbi_code_no = T2.fbi_code_no WHERE community_area.side = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of specific crime reports in a given community area, adjusted by a numeric factor. It counts the number of reports that match a specified FBI crime title and divides it by the total number of crime reports in that community area, then multiplies the result by a numeric placeholder. The query filters the results based on the district side of the community area."
        },
        {
            "sample_id": 8595,
            "vt": "SELECT crime.latitude, crime.longitude FROM district INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no WHERE district.district_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides the latitude and longitude of crimes that occurred in a specific district. It retrieves this information by joining the 'district' table with the 'crime' table based on the district number, allowing users to filter results by the district's name."
        },
        {
            "sample_id": 8677,
            "vt": "SELECT district.commander, district.email, district.phone FROM district WHERE district.district_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the district's commander and contact details from the 'district' table for a specific district name. The placeholders represent the district name that the user can specify."
        },
        {
            "sample_id": 8759,
            "vt": "SELECT SUM(CASE WHEN ward.alderman_last_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM ward INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE crime.arrest = '[placeholder-type:string]' AND ward.alderman_first_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of crimes reported in a specific ward, filtered by the alderman's last name and whether an arrest was made. The placeholders allow users to specify the alderman's last name and the arrest status."
        },
        {
            "sample_id": 8660,
            "vt": "SELECT AVG(community_area.population) FROM community_area WHERE community_area.side = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average population of community areas from the 'community_area' table that belong to a specific district side. The placeholder in the WHERE clause represents the side of the district."
        },
        {
            "sample_id": 8764,
            "vt": "SELECT crime.case_number FROM iucr INNER JOIN Crime AS T2 ON T1.iucr_no = T2.iucr_no WHERE iucr.primary_description = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the case numbers of crimes from the 'Crime' table that are classified under a specific primary description from the 'iucr' table. The placeholder in the WHERE clause represents the primary description of the crime incident."
        },
        {
            "sample_id": 8666,
            "vt": "SELECT SUM(CASE WHEN crime.beat < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM community_area INNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no WHERE community_area.community_area_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of crimes reported in a specific community area, based on a condition related to the crime beat. It sums up values depending on whether the beat number is less than a specified threshold, allowing for analysis of crime distribution in relation to the beat classification."
        },
        {
            "sample_id": 8651,
            "vt": "SELECT CAST(COUNT(crime.report_no) AS FLOAT) / [placeholder-type:numeric] FROM community_area INNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no GROUP BY community_area.community_area_no HAVING COUNT(community_area.population) ORDER BY COUNT(community_area.population) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of crime reports per population for each community area. It joins the 'community_area' table with the 'crime' table based on the community area number, counts the number of crime reports, and divides this count by a specified numeric placeholder to get the average. The results are grouped by community area and ordered by the population count, limiting the output to a specified number of results."
        },
        {
            "sample_id": 8760,
            "vt": "SELECT ward.ward_no, ward.alderman_first_name, ward.alderman_last_name, ward.alderman_name_suffix FROM ward INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE SUBSTRING(crime.date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND SUBSTRING(crime.date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' GROUP BY ward.ward_no ORDER BY COUNT(ward.ward_no) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the ward information including the ward number, alderman's first name, last name, and name suffix from the 'ward' table. It joins with the 'crime' table to filter records based on specific date criteria, allowing users to analyze crime data by ward. The placeholders in the WHERE clause represent the start and end positions for substring extraction of the date, as well as the specific date values to filter on. Additionally, it groups the results by ward number and orders them based on the count of occurrences, limiting the results to a specified number."
        },
        {
            "sample_id": 8648,
            "vt": "SELECT crime.case_number, ward.alderman_first_name, ward.alderman_last_name, district.district_name FROM district INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no INNER JOIN Ward AS T3 ON T2.ward_no = T3.ward_no WHERE crime.block = '[placeholder-type:string]' GROUP BY crime.case_number, ward.alderman_first_name, ward.alderman_last_name, district.district_name",
            "ba": "The virtual table provides a summary of crime cases by displaying the case number, the first and last names of the alderman associated with the ward, and the name of the district where the crime occurred. It filters the results based on a specific block location, allowing users to see relevant information for that area."
        },
        {
            "sample_id": 8704,
            "vt": "SELECT district.district_name FROM iucr INNER JOIN Crime AS T2 ON T2.iucr_no = T1.iucr_no INNER JOIN District AS T3 ON T3.district_no = T2.district_no WHERE iucr.primary_description = '[placeholder-type:string]' GROUP BY district.district_name ORDER BY COUNT(iucr.primary_description) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of district names from the 'district' table based on the classification of crimes recorded in the 'iucr' table. It filters the results by a specific primary description of the crime, allowing users to see which districts have reported incidents of that type. The results are grouped by district name and ordered by the count of incidents, with a limit on the number of districts returned."
        },
        {
            "sample_id": 8723,
            "vt": "SELECT crime.latitude, crime.longitude FROM fbi_code INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no INNER JOIN Community_Area AS T3 ON T2.community_area_no = T3.community_area_no WHERE fbi_code.title = '[placeholder-type:string]' AND community_area.community_area_name = '[placeholder-type:string]' AND community_area.community_area_no = [placeholder-type:numeric] ORDER BY crime.latitude, crime.longitude LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the latitude and longitude of crime incidents filtered by specific criteria related to the FBI crime classification and community area. The placeholders allow users to specify the title of the crime, the name of the community area, and the unique community area number, as well as limit the number of results returned."
        },
        {
            "sample_id": 8643,
            "vt": "SELECT community_area.community_area_name FROM community_area WHERE community_area.side = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of community areas from the 'community_area' table that are located on a specific side of the district. The placeholder in the WHERE clause represents the side of the district being queried."
        },
        {
            "sample_id": 8587,
            "vt": "SELECT community_area.side FROM community_area GROUP BY community_area.side ORDER BY COUNT(community_area.side) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the different sides (districts) of community areas, grouping them to count how many community areas belong to each side. The result is ordered by the count of community areas in each side, and the number of results returned is limited by a placeholder for numeric values."
        },
        {
            "sample_id": 8619,
            "vt": "SELECT CAST(SUM(CASE WHEN iucr.secondary_description = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(crime.case_number) FROM crime INNER JOIN IUCR AS T2 ON T1.iucr_no = T2.iucr_no INNER JOIN Community_Area AS T3 ON T1.community_area_no = T3.community_area_no WHERE iucr.primary_description = '[placeholder-type:string]' AND community_area.community_area_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of a specific secondary crime description from the 'crime' table, based on the total number of cases reported. It joins the 'crime' table with the 'iucr' and 'community_area' tables to filter results by primary crime description and community area name. The placeholders represent the specific secondary description, a numeric value for weighting, and the primary description and community area name for filtering."
        },
        {
            "sample_id": 8618,
            "vt": "SELECT SUM(CASE WHEN community_area.community_area_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM community_area INNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no WHERE crime.arrest = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of crimes in a specific community area, based on whether an arrest was made or not. It uses a conditional sum to differentiate between the two scenarios, allowing for a clear understanding of crime statistics in that area."
        },
        {
            "sample_id": 8642,
            "vt": "SELECT ward.alderman_name_suffix, ward.alderman_first_name, ward.alderman_last_name FROM ward ORDER BY ward.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of aldermen's names, including their first names, last names, and any suffixes, from the 'ward' table. The results are ordered by the population of each ward, and the number of results returned is limited by a specified numeric value."
        },
        {
            "sample_id": 8706,
            "vt": "SELECT ward.ward_no FROM iucr INNER JOIN Crime AS T2 ON T2.iucr_no = T1.iucr_no INNER JOIN Ward AS T3 ON T3.ward_no = T2.ward_no WHERE iucr.primary_description = '[placeholder-type:string]' AND iucr.secondary_description = '[placeholder-type:string]' AND ward.population > [placeholder-type:numeric] GROUP BY ward.ward_no ORDER BY COUNT(ward.ward_no) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique ward numbers from the 'ward' table based on specific incident classifications from the 'iucr' table. It filters the results by matching the primary and secondary descriptions of the incidents, while also ensuring that the population of the ward exceeds a specified numeric value. The results are grouped by ward number and ordered by the count of occurrences, with a limit on the number of results returned."
        },
        {
            "sample_id": 8767,
            "vt": "SELECT SUM(CASE WHEN SUBSTRING(crime.date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM fbi_code INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no WHERE fbi_code.crime_against = '[placeholder-type:string]' AND SUBSTRING(crime.date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total number of crimes reported against a specific category of victims within a specified date range. It utilizes the 'fbi_code' table to filter crimes based on the type of victim and the 'crime' table to aggregate the data based on the occurrence date."
        },
        {
            "sample_id": 8763,
            "vt": "SELECT ward.alderman_first_name, ward.alderman_last_name, COUNT(ward.ward_no) FROM ward INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE (SUBSTRING(crime.date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND SUBSTRING(crime.date, [placeholder-type:numeric], [placeholder-type:numeric]) = '[placeholder-type:string]' AND ward.alderman_first_name = '[placeholder-type:string]' AND ward.alderman_last_name = '[placeholder-type:string]') OR (ward.alderman_first_name = '[placeholder-type:string]' AND ward.alderman_last_name = '[placeholder-type:string]') GROUP BY ward.ward_no",
            "ba": "The virtual table provides a summary of crime reports associated with specific wards, detailing the first and last names of the aldermen responsible for those wards. It counts the number of occurrences of crimes reported in each ward, filtered by specific date ranges and alderman names. The placeholders in the WHERE clause allow users to specify the date range and alderman names for their queries."
        },
        {
            "sample_id": 8761,
            "vt": "SELECT COUNT(ward.ward_no) FROM ward INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE crime.domestic = '[placeholder-type:string]' ORDER BY ward.population = (SELECT ward.population FROM Ward ORDER BY Population DESC LIMIT 1)",
            "ba": "The virtual table counts the number of wards from the 'ward' table that are associated with crimes marked as domestic violence. It joins the 'ward' table with the 'crime' table based on the ward number, applying a filter to only include records where the crime is classified as domestic. The results are ordered by the population of the wards, specifically focusing on the ward with the highest population."
        },
        {
            "sample_id": 8586,
            "vt": "SELECT community_area.side FROM community_area WHERE community_area.community_area_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the district side of a specific community area from the 'community_area' table based on the community area name provided."
        },
        {
            "sample_id": 8636,
            "vt": "SELECT ward.ward_office_address FROM ward INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE crime.block = '[placeholder-type:string]' GROUP BY ward.ward_office_address",
            "ba": "The virtual table provides the addresses of ward offices from the 'ward' table for crimes that occurred in a specific block. It uses an inner join to connect the 'ward' and 'crime' tables based on the ward number, ensuring that only relevant ward office addresses are selected for the specified block."
        },
        {
            "sample_id": 8663,
            "vt": "SELECT ward.alderman_first_name, ward.alderman_last_name FROM crime INNER JOIN Ward AS T2 ON T2.ward_no = T1.ward_no WHERE crime.report_no = [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of the alderman associated with a specific crime report from the 'crime' table. The query joins the 'crime' table with the 'ward' table to retrieve the alderman's details based on the ward number linked to the crime report. The placeholder in the WHERE clause represents the unique identifier of the crime report."
        },
        {
            "sample_id": 8593,
            "vt": "SELECT neighborhood.neighborhood_name FROM neighborhood INNER JOIN Community_Area AS T2 ON T2.community_area_no = T2.community_area_no ORDER BY community_area.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of neighborhoods from the 'neighborhood' table, joining with the 'community_area' table to filter neighborhoods based on their associated community area. The results are ordered by the population of the community area, and a limit is applied to restrict the number of neighborhoods returned."
        },
        {
            "sample_id": 8639,
            "vt": "SELECT COUNT(*) FROM crime WHERE crime.date LIKE '[placeholder-type:string]' AND crime.domestic = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of crime incidents recorded in the 'crime' table that occurred on a specific date and indicates whether they were domestic violence cases. The placeholders represent the date of the incident and a true/false value for domestic violence."
        },
        {
            "sample_id": 8594,
            "vt": "SELECT neighborhood.neighborhood_name FROM community_area INNER JOIN Neighborhood AS T2 ON T1.community_area_no = T2.community_area_no WHERE community_area.side = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of neighborhoods from the 'neighborhood' table that are associated with a specific community area. The query joins the 'community_area' table to filter neighborhoods based on the district side, represented by a placeholder for string values."
        }
    ],
    "donor": [
        {
            "sample_id": 3178,
            "vt": "SELECT essays.title, donations.donor_acctid, CAST(donations.donation_to_project AS FLOAT) / projects.total_price_excluding_optional_support FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid INNER JOIN donations AS T3 ON T2.projectid = T3.projectid ORDER BY donations.donation_to_project LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of project titles from the 'essays' table, along with the donor account IDs from the 'donations' table and the ratio of the donation amount to the total project cost (excluding optional support) from the 'projects' table. This is achieved by joining the 'essays', 'projects', and 'donations' tables based on their project identifiers. The results are ordered by the donation amount, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 3302,
            "vt": "SELECT resources.item_name, essays.short_description FROM resources INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE resources.project_resource_type = '[placeholder-type:string]' ORDER BY resources.item_unit_price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the item names and short descriptions of projects from the 'resources' and 'essays' tables. It filters the resources based on a specific resource type and limits the results to a specified number."
        },
        {
            "sample_id": 3204,
            "vt": "SELECT donations.donor_acctid FROM projects INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE projects.primary_focus_area = '[placeholder-type:string]' ORDER BY donations.donation_total LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique donor account identifiers from the 'donations' table for projects that have a specific primary focus area. It joins the 'projects' table with the 'donations' table based on the project identifier, allowing for filtering based on the primary focus area of the projects. The results are ordered by the total donation amount and limited to a specified number of entries."
        },
        {
            "sample_id": 3300,
            "vt": "SELECT projects.school_longitude, projects.school_latitude FROM projects INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE essays.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the longitude and latitude of schools associated with projects that have a specific title. It joins the 'projects' table with the 'essays' table based on the project identifier, allowing for filtering by the title of the essay."
        },
        {
            "sample_id": 3287,
            "vt": "SELECT COUNT(DISTINCT T1.teacher_acctid) FROM projects INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE projects.school_city = '[placeholder-type:string]' AND donations.is_teacher_acct = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of teachers who have created projects in a specific city, filtering for donations made by teachers."
        },
        {
            "sample_id": 3254,
            "vt": "SELECT COUNT(donations.projectid) FROM donations INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE donations.payment_method = '[placeholder-type:string]' AND projects.school_district = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of donations made to projects within a specific school district, filtered by the payment method used for the donations. It joins the 'donations' table with the 'projects' table based on the project identifier to ensure that only relevant donations are considered."
        },
        {
            "sample_id": 3282,
            "vt": "SELECT essays.title FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE projects.school_latitude = [placeholder-type:numeric] AND projects.school_longitude = -[placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of essays from the 'essays' table that are associated with projects located at a specific latitude and longitude. The placeholders in the WHERE clause represent the geographical coordinates of the school where the project is based."
        },
        {
            "sample_id": 3156,
            "vt": "SELECT donations.donation_message, essays.title FROM essays INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE donations.donor_city = '[placeholder-type:string]'",
            "ba": "The virtual table describes the donation messages and project titles from the 'essays' and 'donations' tables. It retrieves the donation messages associated with projects, filtering by the donor's city. The placeholder in the WHERE clause represents the specific city of the donor."
        },
        {
            "sample_id": 3281,
            "vt": "SELECT projects.school_city FROM donations INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE donations.dollar_amount = '[placeholder-type:string]' GROUP BY projects.school_city ORDER BY COUNT(projects.schoolid) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of school cities from the 'projects' table where donations have been made. It joins the 'donations' table with the 'projects' table based on the project identifier. The results are filtered based on the total dollar amount of donations, and the cities are grouped to count the number of projects per city. The output is ordered by the count of projects and limited to a specified number of results."
        },
        {
            "sample_id": 3151,
            "vt": "SELECT essays.title FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE projects.primary_focus_subject = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of essays from the 'essays' table that are associated with projects in the 'projects' table, filtered by a specific primary focus subject. The placeholder in the WHERE clause represents the subject of interest."
        },
        {
            "sample_id": 3253,
            "vt": "SELECT donations.payment_method FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid INNER JOIN donations AS T3 ON T2.projectid = T3.projectid WHERE essays.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the payment methods used for donations associated with essays that have a specific title. It combines data from the 'essays', 'projects', and 'donations' tables, linking them through their project identifiers. The placeholder in the WHERE clause represents the title of the essay being queried."
        },
        {
            "sample_id": 3275,
            "vt": "SELECT CAST(SUM(CASE WHEN donations.payment_included_campaign_gift_card = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(donations.donationid) FROM donations WHERE donations.payment_method = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average donation amount for projects based on specific payment methods and whether a corporate sponsored gift card was included in the donation. It sums the total donations while considering the inclusion of gift cards and divides by the total number of donations to get the average."
        },
        {
            "sample_id": 3258,
            "vt": "SELECT projects.school_latitude, projects.school_longitude, projects.resource_type FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE essays.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table provides the latitude and longitude of schools along with the type of resources requested for projects. It combines data from the 'essays' and 'projects' tables based on the project identifier, filtering results to include only those essays that match a specific title."
        },
        {
            "sample_id": 3149,
            "vt": "SELECT SUM(donations.donation_total) FROM donations WHERE donations.donation_timestamp LIKE '[placeholder-type:string]' AND donations.via_giving_page = '[placeholder-type:string]' AND donations.for_honoree = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total donations received for projects based on specific criteria. It calculates the sum of the total donation amounts from the 'donations' table, filtering by the donation timestamp, whether the donation was made via a giving page, and if it was made for an honoree. The placeholders represent the specific values for these criteria."
        },
        {
            "sample_id": 3205,
            "vt": "SELECT resources.item_name FROM resources INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE projects.primary_focus_area = '[placeholder-type:string]' AND resources.project_resource_type = '[placeholder-type:string]' ORDER BY resources.item_quantity LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of resources requested for projects that focus on a specific subject area and resource type. It joins the 'resources' table with the 'projects' table to filter based on the primary focus area and the type of resource requested. The results are ordered by the quantity of items requested, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 3285,
            "vt": "SELECT DISTINCT resources.vendor_name FROM resources INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE projects.grade_level = '[placeholder-type:string]'",
            "ba": "The virtual table lists the unique vendor names from the 'resources' table that supply resources for projects filtered by a specific grade level from the 'projects' table. The placeholder in the WHERE clause represents the grade level of interest."
        },
        {
            "sample_id": 3263,
            "vt": "SELECT projects.school_city FROM resources INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE projects.school_district = '[placeholder-type:string]' AND resources.vendor_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of cities where schools are located, based on specific project resources requested. It filters the results by the school district and the vendor name associated with the resources."
        },
        {
            "sample_id": 3296,
            "vt": "SELECT SUM(donations.donation_total) FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid INNER JOIN donations AS T3 ON T2.projectid = T3.projectid WHERE essays.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total amount of donations received for a specific project based on its title. It combines data from the 'essays', 'projects', and 'donations' tables, linking them through the 'projectid' to ensure that only donations related to the specified project are summed up."
        },
        {
            "sample_id": 3220,
            "vt": "SELECT projects.school_city FROM projects INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE essays.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of cities where projects are located, specifically filtering for projects that have a title matching a specified pattern. It combines data from the 'projects' table and the 'essays' table based on the project identifier, ensuring that only relevant projects are included in the results."
        },
        {
            "sample_id": 3276,
            "vt": "SELECT CAST(SUM(CASE WHEN projects.school_metro = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(projects.projectid) FROM projects WHERE projects.school_city = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average funding amount for projects located in a specific city and metro area. It sums the total donations for projects in the specified metro area and divides it by the count of projects in that city, adjusting the result by a specified multiplier."
        },
        {
            "sample_id": 3185,
            "vt": "SELECT projects.students_reached FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE essays.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table provides the number of students reached by projects associated with specific essays. It retrieves this information by joining the 'essays' table with the 'projects' table based on the project identifier, filtering the results to include only those essays that match a given title."
        },
        {
            "sample_id": 3177,
            "vt": "SELECT AVG(donations.donation_to_project) FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid INNER JOIN donations AS T3 ON T2.projectid = T3.projectid WHERE essays.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average amount donated to projects based on the title of the essays. It joins the 'essays', 'projects', and 'donations' tables to correlate the donations with specific projects that have a matching essay title."
        },
        {
            "sample_id": 3236,
            "vt": "SELECT SUM(donations.donation_total) FROM essays INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE essays.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total donations received for projects based on a specific essay title. It combines data from the 'essays' and 'donations' tables, filtering donations that correspond to essays with a matching title."
        },
        {
            "sample_id": 3298,
            "vt": "SELECT resources.vendor_name FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid INNER JOIN resources AS T3 ON T2.projectid = T3.projectid WHERE essays.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the vendor names of resources requested for projects that have a specific title. It combines data from the 'essays', 'projects', and 'resources' tables, linking them through the 'projectid' to filter based on the title of the essay."
        },
        {
            "sample_id": 3189,
            "vt": "SELECT essays.title FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE projects.projectid = (SELECT essays.projectid FROM resources ORDER BY item_unit_price * item_quantity DESC LIMIT 1)",
            "ba": "The virtual table retrieves the title of the essay associated with the project that has the highest total cost of resources requested. It joins the 'essays' and 'projects' tables on the project identifier, filtering for the project that has the maximum cost calculated as the product of item unit price and quantity from the 'resources' table."
        },
        {
            "sample_id": 3286,
            "vt": "SELECT COUNT(DISTINCT T2.teacher_acctid) FROM donations INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE donations.is_teacher_acct = '[placeholder-type:string]' AND projects.school_city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of teachers who have made donations to projects located in a specific city. It joins the 'donations' table with the 'projects' table based on the project identifier, filtering for donations made by teachers and projects that are situated in a specified city."
        },
        {
            "sample_id": 3182,
            "vt": "SELECT projects.schoolid FROM resources INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE resources.vendor_name LIKE '[placeholder-type:string]' GROUP BY projects.schoolid ORDER BY COUNT(resources.vendor_name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique school identifiers from the 'projects' table based on the resources provided by a specific vendor. It joins the 'resources' table with the 'projects' table using the project identifier, filters the results to include only those resources from a vendor whose name matches a specified pattern, groups the results by school identifier, and orders them by the count of resources from that vendor. The limit on the number of results is also specified."
        },
        {
            "sample_id": 3169,
            "vt": "SELECT DISTINCT resources.item_name, resources.item_quantity, projects.teacher_prefix FROM resources INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE resources.projectid = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of resource names and their quantities requested for a specific project, along with the teacher's prefix associated with that project. The data is sourced from the 'resources' table and is joined with the 'projects' table to link resources to their respective projects."
        },
        {
            "sample_id": 3153,
            "vt": "SELECT projects.primary_focus_subject FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE essays.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the primary focus subject of projects from the 'projects' table that are associated with a specific essay title from the 'essays' table. The placeholder in the WHERE clause represents the title of the essay."
        },
        {
            "sample_id": 3202,
            "vt": "SELECT COUNT(projects.projectid) FROM projects INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE donations.payment_included_acct_credit = '[placeholder-type:string]' AND projects.school_year_round = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of projects from the 'projects' table that have received donations, specifically filtering for those donations that included account credits and projects that operate year-round. The placeholders in the WHERE clause represent the conditions for account credit inclusion and the school year-round status."
        },
        {
            "sample_id": 3238,
            "vt": "SELECT donations.donation_optional_support FROM essays INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE essays.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the optional support amount from donations associated with essays that match a specific title. It combines data from the 'essays' and 'donations' tables based on the project identifier, allowing users to see how much optional support was included in donations for projects with a given title."
        },
        {
            "sample_id": 3183,
            "vt": "SELECT COUNT(projects.schoolid) FROM donations INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE donations.donor_city = '[placeholder-type:string]' AND NOT projects.school_city LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of projects associated with donations made from a specific city, while excluding projects located in a different specified city. It utilizes an inner join between the 'donations' and 'projects' tables based on the project identifier, ensuring that only relevant records are considered for the count."
        },
        {
            "sample_id": 3264,
            "vt": "SELECT resources.item_unit_price * resources.item_quantity, projects.school_latitude, projects.school_longitude FROM projects INNER JOIN resources AS T2 ON T1.projectid = T2.projectid WHERE resources.vendor_name = '[placeholder-type:string]' AND resources.project_resource_type = '[placeholder-type:string]' AND projects.school_district = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total cost of resources requested for projects, along with the geographical coordinates of the schools where these projects are located. It filters the results based on the vendor name, the type of resource requested, and the school district."
        },
        {
            "sample_id": 3206,
            "vt": "SELECT resources.item_name FROM resources INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE projects.primary_focus_area = '[placeholder-type:string]' ORDER BY resources.item_unit_price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of resources requested for projects that focus on a specific subject area. It retrieves the resource names from the 'resources' table and joins it with the 'projects' table to filter based on the primary focus area of the projects. The results are ordered by the unit price of the resources, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 3170,
            "vt": "SELECT SUM(projects.total_price_including_optional_support) FROM projects INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE essays.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total funding amount, including optional support, for projects that have a specific title. It combines data from the 'projects' and 'essays' tables based on the project identifier, allowing users to see the total financial support for a project with a given title."
        },
        {
            "sample_id": 3252,
            "vt": "SELECT projects.school_district FROM projects INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE essays.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the school district information from the 'projects' table for projects that have a specific title in the 'essays' table. The join operation connects the two tables based on the project identifier, allowing for filtering based on the essay title."
        },
        {
            "sample_id": 3229,
            "vt": "SELECT COUNT(projects.teacher_acctid) FROM projects WHERE projects.school_county = '[placeholder-type:string]' AND projects.primary_focus_area = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of projects created by teachers in a specific county and focusing on a particular subject area. The placeholders represent the county and the primary focus area of the projects."
        },
        {
            "sample_id": 3203,
            "vt": "SELECT SUM(donations.dollar_amount) FROM projects INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE projects.primary_focus_area = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total dollar amount of donations received for projects that focus on a specific primary subject area. It combines data from the 'projects' and 'donations' tables, filtering the results based on the primary focus area of the projects."
        },
        {
            "sample_id": 3255,
            "vt": "SELECT projects.school_district FROM resources INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE resources.vendor_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the school district of projects that have requested resources from a specific vendor. The placeholder in the WHERE clause represents the name of the vendor providing the resources."
        },
        {
            "sample_id": 3299,
            "vt": "SELECT projects.school_zip, resources.item_name FROM resources INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE resources.vendor_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the school zip codes and item names of resources requested for projects from the 'resources' and 'projects' tables. The placeholder in the WHERE clause represents the vendor's name from which the resources are supplied."
        },
        {
            "sample_id": 3216,
            "vt": "SELECT CAST(SUM(CASE WHEN resources.project_resource_type = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(resources.projectid) FROM resources INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE projects.school_magnet = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average cost of resources requested for projects in magnet schools, based on the type of resource specified. It sums the total cost of the specified resource type and divides it by the number of projects that requested resources, applying a multiplier to adjust the final result. The placeholders represent the resource type, a numeric multiplier, and the magnet school status."
        },
        {
            "sample_id": 3245,
            "vt": "SELECT CAST(SUM(CASE WHEN donations.payment_method LIKE '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(donations.donationid) FROM essays INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE essays.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average donation amount for projects with a specific title, considering only donations made through a specified payment method. It sums the donation amounts based on the payment method and divides by the total number of donations for that project title."
        },
        {
            "sample_id": 3159,
            "vt": "SELECT essays.title, essays.short_description FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE projects.teacher_ny_teaching_fellow = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles and short descriptions of essays from the 'essays' table that are associated with projects created by teachers who are New York teaching fellows. The placeholder in the WHERE clause represents the status of the teacher's fellowship."
        },
        {
            "sample_id": 3226,
            "vt": "SELECT COUNT(projects.schoolid) FROM projects WHERE projects.school_city = '[placeholder-type:string]' AND projects.school_metro = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of projects from the 'projects' table that are located in a specific city and metro area. The placeholders in the WHERE clause represent the city and metro area names."
        },
        {
            "sample_id": 3260,
            "vt": "SELECT projects.date_posted FROM projects INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE essays.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table displays the dates when projects were posted from the 'projects' table, specifically for those projects that have essays with titles matching a specified pattern. The placeholder in the WHERE clause represents the title of the essay being searched for."
        },
        {
            "sample_id": 3160,
            "vt": "SELECT DISTINCT essays.title, projects.total_price_excluding_optional_support FROM projects INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE projects.students_reached >= [placeholder-type:numeric] AND projects.poverty_level LIKE '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of project titles along with their total price excluding optional support from the 'projects' table. It filters the results based on the number of students reached by the projects and the poverty level of the schools associated with those projects. The placeholders allow users to specify the minimum number of students impacted and the poverty level criteria for the projects they are interested in."
        },
        {
            "sample_id": 3240,
            "vt": "SELECT donations.donation_included_optional_support FROM essays INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE essays.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table provides information about whether optional support (tip) was included in donations for projects associated with specific essays. It retrieves this information from the 'donations' table, which is linked to the 'essays' table through the project identifier. The placeholder in the WHERE clause allows users to specify the title of the essay they are interested in."
        },
        {
            "sample_id": 3250,
            "vt": "SELECT DISTINCT resources.project_resource_type FROM resources WHERE resources.vendor_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct types of resources requested for projects from the 'resources' table, filtered by a specific vendor's name. The placeholder in the WHERE clause represents the vendor's name."
        },
        {
            "sample_id": 3195,
            "vt": "SELECT COUNT(projects.projectid) FROM projects INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE projects.teacher_ny_teaching_fellow = '[placeholder-type:string]' AND donations.donor_city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of projects from the 'projects' table that have been donated to, specifically filtering for projects created by teachers who are New York teaching fellows and donations made from a specific city. The placeholders in the WHERE clause represent the teacher's status as a New York teaching fellow and the donor's city."
        },
        {
            "sample_id": 3221,
            "vt": "SELECT donations.payment_method FROM projects INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE projects.teacher_acctid = '[placeholder-type:string]'",
            "ba": "The virtual table describes the payment methods used for donations made to projects created by a specific teacher. The placeholder in the WHERE clause represents the teacher's account ID."
        },
        {
            "sample_id": 3225,
            "vt": "SELECT CAST(SUM(CASE WHEN projects.students_reached > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(projects.projectid) FROM projects INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE donations.is_teacher_acct = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average donation amount for projects that have reached a certain number of students, filtered by whether the donor is a teacher or not. It sums the donations based on the condition of students reached and divides it by the total number of projects to get the average. The placeholders represent the threshold for students reached, the donation amount, and the filter for teacher accounts."
        },
        {
            "sample_id": 3261,
            "vt": "SELECT donations.donation_message FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid INNER JOIN donations AS T3 ON T2.projectid = T3.projectid WHERE essays.title = '[placeholder-type:string]' AND donations.payment_method = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves donation messages from the 'donations' table for projects that have a specific title in the 'essays' table. It joins the 'essays', 'projects', and 'donations' tables based on their project identifiers. The query filters results based on a specified project title and payment method."
        },
        {
            "sample_id": 3188,
            "vt": "SELECT DISTINCT resources.vendor_name FROM resources INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE projects.primary_focus_subject LIKE '[placeholder-type:string]'",
            "ba": "The virtual table lists unique vendor names from the 'resources' table that supply resources for projects with a specific primary focus subject. The placeholder in the WHERE clause represents the subject of interest."
        },
        {
            "sample_id": 3246,
            "vt": "SELECT essays.short_description FROM essays WHERE essays.title = '[placeholder-type:string]'",
            "ba": "The virtual table provides a short description of a project from the 'essays' table based on a specific project title. The placeholder in the WHERE clause represents the title of the project being queried."
        },
        {
            "sample_id": 3248,
            "vt": "SELECT COUNT(projects.projectid) FROM projects WHERE projects.school_district = '[placeholder-type:string]' AND projects.school_metro = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of projects from the 'projects' table that belong to a specific school district and metro area. The placeholders in the WHERE clause represent the school district and metro area names."
        },
        {
            "sample_id": 3173,
            "vt": "SELECT resources.project_resource_type FROM (SELECT donations.donor_acctid, resources.project_resource_type FROM donations AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid INNER JOIN resources AS T3 ON T2.projectid = T3.projectid ORDER BY T1.donation_total DESC LIMIT 10) GROUP BY resources.project_resource_type ORDER BY COUNT(resources.project_resource_type) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the most frequently requested types of resources from projects that received donations. It retrieves the resource types from the 'resources' table, filtering through donations and projects to focus on the top donors. The results are grouped by resource type and ordered by the count of each type, allowing users to see which resources are most commonly requested based on donation activity. The placeholder in the LIMIT clause allows users to specify how many resource types they want to retrieve."
        },
        {
            "sample_id": 3278,
            "vt": "SELECT SUM(resources.item_unit_price) / SUM(resources.item_quantity) FROM resources WHERE resources.vendor_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average unit price of resources requested for projects from a specific vendor. It sums the total unit prices of the resources and divides it by the total quantity of items requested, filtered by the vendor's name."
        },
        {
            "sample_id": 3306,
            "vt": "SELECT CAST(SUM(CASE WHEN T1.vendor_name = 'Best Buy for Business' THEN 1 ELSE 0 END) AS FLOAT) * 100 / COUNT(T1.projectid) FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.project_resource_type = 'Technology' UNION ALL SELECT DISTINCT T1.date_posted FROM projects AS T1 INNER JOIN resources AS T2 ON T1.projectid = T2.projectid WHERE T2.vendor_name = 'Best Buy for Business' AND T2.project_resource_type = 'Technology'",
            "ba": "The virtual table calculates the percentage of projects that requested technology resources from a specific vendor, 'Best Buy for Business', and lists the distinct dates when these projects were posted."
        },
        {
            "sample_id": 3269,
            "vt": "SELECT COUNT(donations.donationid) FROM donations WHERE donations.dollar_amount = '[placeholder-type:string]' AND donations.for_honoree = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of donations made for a specific honoree from the 'donations' table, filtered by the amount donated. The placeholders represent the dollar amount of the donation and whether the donation was made for an honoree."
        },
        {
            "sample_id": 3163,
            "vt": "SELECT COUNT(projects.poverty_level) FROM projects WHERE projects.school_district = '[placeholder-type:string]' AND projects.poverty_level = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of projects from the 'projects' table that belong to a specific school district and have a specified poverty level. The placeholders in the WHERE clause represent the school district and the poverty level criteria."
        },
        {
            "sample_id": 3164,
            "vt": "SELECT COUNT(donations.donationid) FROM donations WHERE donations.is_teacher_acct = '[placeholder-type:string]' AND donations.donor_state = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of donations made by either teachers or non-teachers from a specific state. The placeholders represent the type of donor account and the state from which the donation was made."
        },
        {
            "sample_id": 3171,
            "vt": "SELECT projects.school_latitude, projects.school_longitude FROM projects INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE essays.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the latitude and longitude of schools associated with projects that have a specific title. It combines data from the 'projects' and 'essays' tables based on the project identifier, allowing users to find geographical information related to a particular project title."
        },
        {
            "sample_id": 3218,
            "vt": "SELECT COUNT(projects.schoolid) FROM projects INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE projects.poverty_level = '[placeholder-type:string]' AND donations.donor_acctid = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of projects from the 'projects' table that are associated with donations from a specific donor. It filters the results based on the school's poverty level and the donor's account ID."
        },
        {
            "sample_id": 3152,
            "vt": "SELECT essays.title FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE projects.poverty_level LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of essays from the 'essays' table that are associated with projects having a specific poverty level. The query uses an INNER JOIN to connect the 'essays' and 'projects' tables based on the project identifier, filtering the results based on the poverty level of the projects."
        },
        {
            "sample_id": 3249,
            "vt": "SELECT DISTINCT resources.vendor_name FROM resources WHERE resources.item_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists unique vendor names from the 'resources' table that supply a specific resource item requested for a project. The placeholder in the WHERE clause represents the name of the resource item."
        },
        {
            "sample_id": 3147,
            "vt": "SELECT SUM(donations.donation_total) FROM donations WHERE donations.donation_timestamp LIKE '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total amount of donations received for projects on a specific date. It aggregates the total donation amounts from the 'donations' table, filtered by the timestamp of the donations to match a specified date."
        },
        {
            "sample_id": 3237,
            "vt": "SELECT SUM(donations.donation_to_project) + SUM(donations.donation_optional_support) FROM essays INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE essays.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total amount of donations received for projects based on their titles. It sums up both the direct donations and any optional support (tips) associated with those donations. The query joins the 'essays' table, which contains project titles, with the 'donations' table to link donations to their respective projects. The placeholder in the WHERE clause allows users to specify a project title to filter the results accordingly."
        },
        {
            "sample_id": 3180,
            "vt": "SELECT resources.projectid, resources.item_name FROM resources INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE projects.school_city LIKE '[placeholder-type:string]' GROUP BY resources.item_name ORDER BY COUNT(resources.item_name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the project identifiers and item names of resources requested for projects located in a specific city. The query joins the 'resources' table with the 'projects' table to filter resources based on the school city, grouping the results by item name and ordering them by the count of each item. The placeholders represent the city name and the limit on the number of results returned."
        },
        {
            "sample_id": 3212,
            "vt": "SELECT essays.title FROM projects INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE projects.school_city LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of essays associated with projects located in a specific city. It retrieves data from the 'projects' table and joins it with the 'essays' table based on the project identifier. The placeholder in the WHERE clause represents the city name where the projects are situated."
        },
        {
            "sample_id": 3257,
            "vt": "SELECT donations.payment_method FROM donations INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE projects.school_state = '[placeholder-type:string]' GROUP BY projects.school_state ORDER BY COUNT(donations.payment_method) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the payment methods used for donations from the 'donations' table, specifically for projects located in a certain state. It joins the 'donations' table with the 'projects' table based on the project identifier, filtering results by the state of the school associated with each project. The results are grouped by school state and ordered by the count of payment methods used, allowing for a limit on the number of results returned."
        },
        {
            "sample_id": 3243,
            "vt": "SELECT essays.title FROM essays INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE donations.donation_total = (SELECT MAX(donations.donation_total) FROM donations)",
            "ba": "The virtual table displays the titles of essays from the 'essays' table that are associated with the project which received the highest total donation amount. It uses an inner join to connect the 'essays' and 'donations' tables based on the project identifier, and includes a subquery to find the maximum donation total."
        },
        {
            "sample_id": 3230,
            "vt": "SELECT COUNT(projects.teacher_acctid) FROM projects WHERE projects.teacher_prefix = '[placeholder-type:string]' AND projects.primary_focus_subject = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of projects created by teachers with a specific prefix (indicating their title or degree) and a specific primary focus subject. The placeholders in the WHERE clause represent the teacher's title and the subject of focus for the projects."
        },
        {
            "sample_id": 3223,
            "vt": "SELECT donations.is_teacher_acct FROM projects INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE projects.schoolid = '[placeholder-type:string]'",
            "ba": "The virtual table identifies whether the donors of projects from a specific school are teachers or not. It retrieves the 'is_teacher_acct' field from the 'donations' table, which indicates if the donor is a teacher account, by joining the 'projects' table on the 'projectid'. The placeholder in the WHERE clause represents the school's identifier."
        },
        {
            "sample_id": 3304,
            "vt": "SELECT SUM(projects.students_reached) FROM donations INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE donations.donor_zip = [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total number of students reached by projects funded through donations, filtered by the donor's zip code. It combines data from the 'donations' and 'projects' tables, specifically summing the 'students_reached' column from the 'projects' table for donations that match a specific zip code."
        },
        {
            "sample_id": 3303,
            "vt": "SELECT projects.grade_level FROM projects INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE essays.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the grade level of projects from the 'projects' table that are associated with essays having a specific title. The join operation connects the 'projects' and 'essays' tables based on the project identifier, allowing for filtering based on the essay title."
        },
        {
            "sample_id": 3201,
            "vt": "SELECT donations.donation_message FROM projects INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE projects.school_city = '[placeholder-type:string]' AND projects.school_magnet = '[placeholder-type:string]'",
            "ba": "The virtual table describes the donation messages from the 'donations' table for projects located in a specific city and that are categorized as magnet schools. The placeholders in the WHERE clause represent the city name and the magnet school status."
        },
        {
            "sample_id": 3150,
            "vt": "SELECT donations.donor_acctid, donations.donation_optional_support / donations.donation_total FROM donations WHERE donations.is_teacher_acct = '[placeholder-type:string]'",
            "ba": "The virtual table provides a summary of donations made to projects, specifically focusing on the donor's account ID and the ratio of optional support to the total donation amount. The query filters the results based on whether the donor is a teacher or not, using a placeholder for the boolean value."
        },
        {
            "sample_id": 3228,
            "vt": "SELECT COUNT(projects.schoolid) FROM projects WHERE projects.school_county = '[placeholder-type:string]' AND projects.school_magnet = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of projects from the 'projects' table that are located in a specific county and are categorized as magnet schools. The placeholders in the WHERE clause represent the county name and the magnet school status."
        },
        {
            "sample_id": 3175,
            "vt": "SELECT DISTINCT resources.vendor_name FROM resources INNER JOIN essays AS T3 ON T1.projectid = T3.projectid WHERE essays.title = '[placeholder-type:string]'",
            "ba": "The virtual table lists distinct vendor names from the 'resources' table that are associated with projects having a specific essay title. The query joins the 'resources' table with the 'essays' table based on the project identifier, filtering for essays with a specified title."
        },
        {
            "sample_id": 3272,
            "vt": "SELECT projects.schoolid FROM projects WHERE projects.school_district = '[placeholder-type:string]' AND projects.teacher_ny_teaching_fellow = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the school identifiers from the 'projects' table for projects that are associated with a specific school district and where the teacher is a New York teaching fellow. The placeholders in the WHERE clause represent the school district and the teaching fellow status."
        },
        {
            "sample_id": 3184,
            "vt": "SELECT projects.teacher_prefix FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE essays.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the teacher's prefix from the 'projects' table for projects that have a specific title in the 'essays' table. The placeholder in the LIKE clause represents the title of the project being searched for."
        },
        {
            "sample_id": 3197,
            "vt": "SELECT resources.vendor_name FROM resources INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE projects.poverty_level = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of vendors that supply resources for projects in schools with a specific poverty level. The query joins the 'resources' table with the 'projects' table based on the project identifier, allowing us to filter the results based on the poverty level of the school associated with each project."
        },
        {
            "sample_id": 3262,
            "vt": "SELECT resources.project_resource_type FROM resources INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE projects.school_district = '[placeholder-type:string]' GROUP BY projects.school_district ORDER BY COUNT(resources.project_resource_type) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of resource types requested for projects grouped by school district. It retrieves data from the 'resources' table and joins it with the 'projects' table to filter results based on the specified school district. The results are then grouped by the school district and ordered by the count of resource types, with a limit on the number of results returned."
        },
        {
            "sample_id": 3168,
            "vt": "SELECT resources.projectid, resources.item_name FROM resources INNER JOIN projects AS T2 ON T1.projectid = T2.projectid ORDER BY projects.total_price_including_optional_support - projects.total_price_excluding_optional_support LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table displays the project identifiers and item names of resources requested for projects. It joins the 'resources' table with the 'projects' table to associate each resource with its corresponding project. The results are ordered by the difference between the total price including optional support and the total price excluding optional support, which indicates the amount of optional support given. The query limits the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 3289,
            "vt": "SELECT SUM(resources.item_quantity) FROM resources INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE projects.school_metro = '[placeholder-type:string]' AND projects.school_district = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total quantity of resources requested for projects located in a specific metro area and school district. The placeholders in the WHERE clause represent the metro area and school district names."
        },
        {
            "sample_id": 3172,
            "vt": "SELECT donations.donation_total, essays.title FROM essays INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE donations.donation_total = (SELECT MAX(donations.donation_total) FROM donations)",
            "ba": "The virtual table displays the total donation amount and the title of the essay for the project that received the highest total donation. It combines data from the 'essays' and 'donations' tables, linking them through the project identifier. The query filters to find the maximum donation total, ensuring that only the project with the highest funding is shown."
        },
        {
            "sample_id": 3297,
            "vt": "SELECT DISTINCT projects.poverty_level FROM donations INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE donations.donor_zip = [placeholder-type:numeric]",
            "ba": "The virtual table provides a distinct list of poverty levels for projects based on donations made from a specific donor's zip code. It combines data from the 'donations' and 'projects' tables, linking them through the project identifier."
        },
        {
            "sample_id": 3161,
            "vt": "SELECT CAST(SUM(CASE WHEN projects.school_metro = '[placeholder-type:string]' THEN donations.donation_to_project ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / SUM(donations.donation_to_project) FROM donations INNER JOIN projects AS T2 ON T1.projectid = T2.projectid",
            "ba": "The virtual table calculates the total amount of donations received for projects located in a specific metro area, adjusted by a specified multiplier. It sums the donations for projects that match the given metro area and divides this sum by the total donations to provide a proportionate value. The placeholders represent the metro area and the multiplier for the calculation."
        },
        {
            "sample_id": 3241,
            "vt": "SELECT essays.teacher_acctid FROM essays INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE donations.donation_timestamp LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the teacher account IDs from the 'essays' table for projects that received donations on a specific date. The query joins the 'essays' table with the 'donations' table based on the project ID, allowing us to filter the results by the donation timestamp."
        },
        {
            "sample_id": 3192,
            "vt": "SELECT donations.donation_message FROM donations WHERE donations.donationid = '[placeholder-type:string]'",
            "ba": "The virtual table displays the donation messages from the 'donations' table for a specific donation identified by its unique donation identifier. The placeholder in the WHERE clause represents the unique identifier of the donation."
        },
        {
            "sample_id": 3274,
            "vt": "SELECT DISTINCT resources.vendorid, resources.projectid FROM resources WHERE resources.project_resource_type = '[placeholder-type:string]'",
            "ba": "The virtual table provides a distinct list of vendor IDs and project IDs from the 'resources' table, filtered by a specific type of resource requested for projects. The placeholder in the WHERE clause represents the type of resource being queried."
        },
        {
            "sample_id": 3200,
            "vt": "SELECT SUM(donations.donation_total) FROM projects INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE projects.school_city = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total donations received for projects located in a specific city. It aggregates the total donation amounts from the 'donations' table, joining it with the 'projects' table to filter by the city where the projects are based. The placeholder in the WHERE clause represents the city name."
        },
        {
            "sample_id": 3222,
            "vt": "SELECT donations.donation_total FROM projects INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE projects.teacher_acctid = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total donations received for projects created by a specific teacher. It retrieves the total donation amount from the 'donations' table, joining it with the 'projects' table to filter by the teacher's account ID."
        },
        {
            "sample_id": 3186,
            "vt": "SELECT essays.title, donations.donor_acctid FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid INNER JOIN donations AS T3 ON T2.projectid = T3.projectid WHERE projects.school_city LIKE '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of essays and the donor account IDs from the 'essays' and 'donations' tables, respectively. It retrieves this information by joining the 'essays' table with the 'projects' table on the project ID, and then joining the 'projects' table with the 'donations' table on the same project ID. The results are filtered to include only those projects located in a specific city, represented by a placeholder in the WHERE clause."
        },
        {
            "sample_id": 3193,
            "vt": "SELECT DISTINCT resources.project_resource_type FROM resources WHERE resources.vendor_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct types of resources requested for projects from the 'resources' table, filtered by a specific vendor's name. The placeholder in the WHERE clause represents the vendor's name."
        },
        {
            "sample_id": 3233,
            "vt": "SELECT projects.teacher_prefix FROM essays INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE essays.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the teacher's prefix from the 'projects' table for projects that have a corresponding essay title matching a specified pattern. The join between the 'essays' and 'projects' tables is established using the 'projectid' column, ensuring that only relevant projects related to the essays are considered."
        }
    ],
    "superhero": [
        {
            "sample_id": 10180,
            "vt": "SELECT DISTINCT colour.colour FROM superhero INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE superhero.height_cm = [placeholder-type:numeric] AND race.race = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct colors associated with superheroes based on their hair color and race. It filters the results to include only those superheroes whose height matches a specified value and whose race corresponds to a given name."
        },
        {
            "sample_id": 10261,
            "vt": "SELECT superhero.full_name FROM superhero INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE superhero.weight_kg < [placeholder-type:numeric] AND colour.colour = '[placeholder-type:string]'",
            "ba": "The virtual table describes the full names of superheroes from the 'superhero' table who have a specific eye color and weigh less than a certain amount. The placeholders in the WHERE clause represent the weight limit and the eye color."
        },
        {
            "sample_id": 10215,
            "vt": "SELECT COUNT(*) FROM superhero INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN gender AS T3 ON T3.id = T1.gender_id WHERE superhero.race_id = [placeholder-type:numeric] AND superhero.gender_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of superheroes from the 'superhero' table, filtering based on their race and gender. It joins the 'race' and 'gender' tables to obtain the relevant identifiers for these attributes. The placeholders represent specific race and gender IDs that can be modified to retrieve counts for different combinations."
        },
        {
            "sample_id": 10241,
            "vt": "SELECT SUM(CASE WHEN colour.id = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN colour.id = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM superhero INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE superhero.weight_kg = [placeholder-type:numeric] OR superhero.weight_kg IS NULL",
            "ba": "The virtual table calculates the difference between two sums based on the conditions applied to the superhero's eye color and weight. It uses a conditional aggregation to sum values based on specific color IDs, while also considering superheroes with missing weight information."
        },
        {
            "sample_id": 10258,
            "vt": "SELECT COUNT(superhero.id) FROM superhero WHERE superhero.full_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of superheroes from the 'superhero' table whose full name matches a specified pattern. The placeholder in the LIKE clause allows for flexible searching of superhero names based on user input."
        },
        {
            "sample_id": 10226,
            "vt": "SELECT superhero.superhero_name FROM superhero WHERE superhero.id = [placeholder-type:numeric]",
            "ba": "The virtual table provides the name of a superhero from the 'superhero' table based on a specific superhero identifier. The placeholder in the WHERE clause represents the unique identifier of the superhero."
        },
        {
            "sample_id": 10198,
            "vt": "SELECT superhero.superhero_name, race.race FROM superhero INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE superhero.full_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the superhero's name and their race from the 'superhero' table, filtered by the superhero's full name. The placeholder in the WHERE clause represents the specific full name of the superhero being queried."
        },
        {
            "sample_id": 10206,
            "vt": "SELECT superhero.full_name FROM superhero INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE race.race = '[placeholder-type:string]'",
            "ba": "The virtual table describes the full names of superheroes from the 'superhero' table who belong to a specific race. The query uses an INNER JOIN to connect the 'superhero' table with the 'race' table based on the race identifier, filtering the results by a specified race name."
        },
        {
            "sample_id": 10166,
            "vt": "SELECT SUM(CASE WHEN publisher.publisher_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN publisher.publisher_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM superhero INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
            "ba": "The virtual table calculates the difference between two sums based on the publisher's name from the 'superhero' and 'publisher' tables. It uses conditional aggregation to sum numeric values depending on whether the publisher's name matches a specified placeholder. This allows for a comparison of values associated with different publishers."
        },
        {
            "sample_id": 10162,
            "vt": "SELECT COUNT(superhero.id) FROM superhero INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE attribute.attribute_name = '[placeholder-type:string]' AND hero_attribute.attribute_value = [placeholder-type:numeric] AND gender.gender = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of superheroes from the 'superhero' table who possess a specific attribute with a defined value and belong to a specified gender. It joins the 'hero_attribute' table to link superheroes with their attributes, the 'attribute' table to filter by attribute name, and the 'gender' table to filter by gender."
        },
        {
            "sample_id": 10267,
            "vt": "SELECT superpower.power_name FROM superhero INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE superhero.height_cm * [placeholder-type:numeric] > (SELECT AVG(superhero.height_cm) FROM superhero) * [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of superpowers from the 'superpower' table for superheroes whose height is above a certain threshold. This threshold is determined by comparing the superhero's height to the average height of all superheroes, scaled by a specified numeric factor."
        },
        {
            "sample_id": 10225,
            "vt": "SELECT superpower.id FROM superpower WHERE superpower.power_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier of a superpower from the 'superpower' table based on a specified power name. The placeholder in the WHERE clause represents the name of the superpower being queried."
        },
        {
            "sample_id": 10250,
            "vt": "SELECT COUNT(superhero.superhero_name) FROM hero_attribute INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id INNER JOIN superhero AS T3 ON T1.hero_id = T3.id WHERE attribute.attribute_name = '[placeholder-type:string]' AND hero_attribute.attribute_value = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of superheroes that possess a specific attribute with a defined value. It joins the 'hero_attribute' table with the 'attribute' table to filter by the attribute name and checks the corresponding attribute value for each superhero in the 'superhero' table."
        },
        {
            "sample_id": 10169,
            "vt": "SELECT COUNT(superhero.id) FROM superhero WHERE superhero.full_name IS NULL",
            "ba": "The virtual table counts the number of superheroes from the 'superhero' table where the full name of the superhero is not provided. This helps identify superheroes with missing full name information."
        },
        {
            "sample_id": 10238,
            "vt": "SELECT superhero.superhero_name FROM superhero INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE hero_attribute.attribute_value BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of superheroes from the 'superhero' table who have attribute values within a specified range. The query joins the 'superhero' table with the 'hero_attribute' table to filter superheroes based on their attributes, using placeholders for numeric values to define the range of attribute values."
        },
        {
            "sample_id": 10239,
            "vt": "SELECT race.race FROM superhero INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE colour.colour = '[placeholder-type:string]' AND gender.gender = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the race of superheroes based on their hair color and gender. It joins the 'superhero' table with the 'colour', 'race', and 'gender' tables to filter results according to specified hair color and gender values."
        },
        {
            "sample_id": 10172,
            "vt": "SELECT AVG(superhero.weight_kg) FROM superhero INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE gender.gender = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average weight of superheroes from the 'superhero' table, filtered by a specific gender. It joins the 'superhero' table with the 'gender' table to access the gender information of each superhero. The placeholder in the WHERE clause represents the gender to filter the results accordingly."
        },
        {
            "sample_id": 10265,
            "vt": "SELECT hero_power.hero_id FROM hero_power INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE superpower.power_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of superheroes who possess a specific superpower from the 'hero_power' table. It joins the 'hero_power' table with the 'superpower' table to filter results based on the name of the superpower, represented by a placeholder for string values."
        },
        {
            "sample_id": 10243,
            "vt": "SELECT superpower.power_name FROM superhero INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE superhero.superhero_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of superpowers associated with a specific superhero from the 'superhero' table. It uses inner joins to connect the 'superhero' table with the 'hero_power' table and the 'superpower' table, allowing for the retrieval of power names based on the superhero's name provided as a placeholder."
        },
        {
            "sample_id": 10188,
            "vt": "SELECT superhero.full_name FROM superhero INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE attribute.attribute_name = '[placeholder-type:string]' ORDER BY hero_attribute.attribute_value LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the full names of superheroes from the 'superhero' table who possess a specific attribute. It joins the 'superhero' table with the 'hero_attribute' table to link each superhero with their attributes, and further joins with the 'attribute' table to filter based on the attribute name provided. The results are ordered by the attribute value, allowing for a limit on the number of superheroes returned."
        },
        {
            "sample_id": 10142,
            "vt": "SELECT DISTINCT superhero.full_name FROM superhero INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY superhero.full_name HAVING COUNT(hero_power.power_id) > [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct full names of superheroes who possess more than a specified number of superpowers. It combines data from the 'superhero' table and the 'hero_power' table, ensuring that only those superheroes with a count of superpowers exceeding the given threshold are included in the results."
        },
        {
            "sample_id": 10144,
            "vt": "SELECT colour.colour FROM superhero INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id WHERE superhero.superhero_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the skin color of a superhero based on their name. It retrieves the color from the 'colour' table by joining it with the 'superhero' table using the skin color identifier. The placeholder in the WHERE clause represents the superhero's name."
        },
        {
            "sample_id": 10155,
            "vt": "SELECT COUNT(superhero.id) FROM superhero INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN colour AS T3 ON T1.eye_colour_id = T3.id WHERE publisher.publisher_name = '[placeholder-type:string]' AND colour.colour = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of superheroes from the 'superhero' table who are published by a specific publisher and have a specific eye color. It joins the 'superhero' table with the 'publisher' and 'colour' tables to filter the results based on the publisher's name and the eye color of the superheroes."
        },
        {
            "sample_id": 10178,
            "vt": "SELECT COUNT(superhero.id) FROM superhero INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE alignment.alignment = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of superheroes from the 'superhero' table who belong to a specific alignment. It joins the 'superhero' table with the 'alignment' table to filter superheroes based on their moral and ethical stance, represented by the alignment type."
        },
        {
            "sample_id": 10229,
            "vt": "SELECT superpower.power_name FROM superhero INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE superhero.full_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of superpowers associated with a specific superhero from the 'superhero' table. It uses inner joins to connect the 'superhero' table with the 'hero_power' table and the 'superpower' table, allowing for the retrieval of power names based on the superhero's full name provided as a placeholder."
        },
        {
            "sample_id": 10151,
            "vt": "SELECT AVG(superhero.height_cm) FROM superhero INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average height of superheroes from the 'superhero' table, filtered by a specific publisher's name. The query joins the 'superhero' table with the 'publisher' table to access the publisher's name, using a placeholder for the publisher's name in the WHERE clause."
        },
        {
            "sample_id": 10228,
            "vt": "SELECT colour.colour FROM superhero INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE superhero.full_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the eye color of a superhero based on their full name. It retrieves the color information from the 'colour' table by joining it with the 'superhero' table using the eye color ID. The placeholder in the WHERE clause represents the superhero's full name."
        },
        {
            "sample_id": 10208,
            "vt": "SELECT COUNT(hero_attribute.hero_id) FROM hero_attribute INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id WHERE attribute.attribute_name = '[placeholder-type:string]' AND hero_attribute.attribute_value = (SELECT MAX(hero_attribute.attribute_value) FROM hero_attribute)",
            "ba": "The virtual table counts the number of superheroes that possess the highest value for a specific attribute. It joins the 'hero_attribute' table with the 'attribute' table to filter by the attribute name provided. The subquery retrieves the maximum attribute value from the 'hero_attribute' table, ensuring that only superheroes with the highest attribute value are counted."
        },
        {
            "sample_id": 10159,
            "vt": "SELECT race.race FROM superhero INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE superhero.superhero_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides the race of a specific superhero by joining the 'superhero' table with the 'race' table. It filters the results based on the superhero's name, allowing users to retrieve the race information for any given superhero."
        },
        {
            "sample_id": 10207,
            "vt": "SELECT superhero.superhero_name FROM superhero INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE alignment.alignment = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of superheroes from the 'superhero' table who belong to a specific alignment. The query uses an INNER JOIN to connect the 'superhero' table with the 'alignment' table based on the alignment ID. The placeholder in the WHERE clause represents the alignment type of the superhero."
        },
        {
            "sample_id": 10170,
            "vt": "SELECT colour.colour FROM superhero INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE superhero.id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the eye color of a specific superhero from the 'superhero' table. It retrieves the color information by joining the 'superhero' table with the 'colour' table based on the eye color ID. The placeholder in the WHERE clause represents the unique identifier of the superhero."
        },
        {
            "sample_id": 10242,
            "vt": "SELECT hero_attribute.attribute_value FROM superhero INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE superhero.superhero_name = '[placeholder-type:string]' AND attribute.attribute_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the attribute value of a specific superhero based on their name and a specified attribute name. It joins the 'superhero' table with the 'hero_attribute' table to link each superhero with their attributes, and then further joins the 'attribute' table to filter by the desired attribute name."
        },
        {
            "sample_id": 10140,
            "vt": "SELECT COUNT(hero_power.hero_id) FROM hero_power INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE superpower.power_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of superheroes that possess a specific superpower from the 'hero_power' table. It joins the 'hero_power' table with the 'superpower' table to filter the results based on the name of the superpower, which is represented by a placeholder for string values."
        },
        {
            "sample_id": 10164,
            "vt": "SELECT COUNT(superhero.superhero_name) FROM superhero INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE race.race = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of superheroes from the 'superhero' table who belong to a specific race. It joins the 'superhero' table with the 'race' table to filter the results based on the race specified by the placeholder."
        },
        {
            "sample_id": 10147,
            "vt": "SELECT COUNT(superhero.id) FROM superhero INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of superheroes from the 'superhero' table who are published by a specific publisher. It joins the 'superhero' table with the 'publisher' table to filter the results based on the publisher's name provided as a placeholder."
        },
        {
            "sample_id": 10246,
            "vt": "SELECT superhero.superhero_name FROM superhero INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE superpower.power_name = '[placeholder-type:string]' ORDER BY superhero.superhero_name",
            "ba": "The virtual table lists the names of superheroes who possess a specific superpower. It retrieves data from the 'superhero' table and joins it with the 'hero_power' and 'superpower' tables to filter superheroes based on the name of the superpower. The placeholder in the WHERE clause represents the name of the superpower being queried."
        },
        {
            "sample_id": 10219,
            "vt": "SELECT superhero.superhero_name FROM superhero INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE colour.colour = '[placeholder-type:string]' AND colour.colour = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of superheroes from the 'superhero' table who have specific eye and hair colors. The query uses inner joins to connect the 'superhero' table with the 'colour' table twice, once for eye color and once for hair color. The placeholders in the WHERE clause represent the colors being filtered for both eye and hair attributes."
        },
        {
            "sample_id": 10248,
            "vt": "SELECT superhero.superhero_name FROM superhero INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE publisher.publisher_name = '[placeholder-type:string]' ORDER BY superhero.weight_kg LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of superheroes from the 'superhero' table who are published by a specific publisher. It joins the 'superhero' table with the 'publisher' table to filter superheroes based on the publisher's name. The results are ordered by the weight of the superheroes, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 10262,
            "vt": "SELECT hero_attribute.attribute_value FROM superhero INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE superhero.superhero_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the attribute value of a specific superhero from the 'superhero' table by joining it with the 'hero_attribute' table. The query filters the results based on the superhero's name, which is provided as a placeholder."
        },
        {
            "sample_id": 10175,
            "vt": "SELECT DISTINCT superhero.superhero_name FROM superhero INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE superhero.height_cm BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND colour.colour = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct names of superheroes from the 'superhero' table who have a specific eye color and fall within a specified height range. The placeholders represent the height limits and the eye color to filter the results accordingly."
        },
        {
            "sample_id": 10173,
            "vt": "SELECT superpower.power_name FROM superhero INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN gender AS T4 ON T4.id = T1.gender_id WHERE gender.gender = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of superpowers associated with superheroes of a specific gender. It retrieves data from the 'superhero' table and joins it with the 'hero_power' table to link superheroes with their powers. Additionally, it joins the 'gender' table to filter superheroes based on their gender. The placeholders allow users to specify the desired gender and limit the number of results returned."
        },
        {
            "sample_id": 10205,
            "vt": "SELECT colour.colour FROM superhero INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE colour.colour = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the colors associated with a superhero's eye and skin from the 'superhero' table, filtering based on a specific color value. The query uses inner joins to connect the 'superhero' table with the 'colour' table for both eye and skin colors, allowing for a comprehensive view of the superhero's appearance based on color attributes."
        },
        {
            "sample_id": 10227,
            "vt": "SELECT DISTINCT superhero.full_name FROM superhero WHERE NOT superhero.full_name IS NULL AND (superhero.weight_kg IS NULL OR superhero.weight_kg = [placeholder-type:numeric])",
            "ba": "The virtual table lists the distinct full names of superheroes from the 'superhero' table where the full name is not null and the weight of the superhero is either missing or equal to a specified numeric value. This allows users to identify superheroes based on their weight characteristics."
        },
        {
            "sample_id": 10157,
            "vt": "SELECT COUNT(superhero.id) FROM superhero INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id WHERE colour.colour = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of superheroes from the 'superhero' table who have a specific hair color. It joins the 'superhero' table with the 'colour' table to filter based on the hair color specified by the user."
        },
        {
            "sample_id": 10145,
            "vt": "SELECT COUNT(superhero.id) FROM superhero INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN colour AS T4 ON T1.eye_colour_id = T4.id WHERE superpower.power_name = '[placeholder-type:string]' AND colour.colour = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of superheroes who possess a specific superpower and have a specific eye color. It joins the 'superhero' table with the 'hero_power' table to link superheroes to their powers, and then further joins with the 'superpower' table to filter by the desired power name. Additionally, it joins with the 'colour' table to filter by the desired eye color. The placeholders represent the superpower name and the eye color."
        },
        {
            "sample_id": 10212,
            "vt": "SELECT (SELECT superhero.weight_kg FROM superhero WHERE full_name LIKE 'Emil Blonsky') - (SELECT superhero.weight_kg FROM superhero WHERE full_name LIKE 'Charles Chandler')",
            "ba": "The virtual table calculates the weight difference between two superheroes, Emil Blonsky and Charles Chandler, by selecting their respective weights from the 'superhero' table. The query uses subqueries to retrieve the weight of each superhero based on their full names."
        },
        {
            "sample_id": 10149,
            "vt": "SELECT publisher.publisher_name FROM superhero INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE superhero.superhero_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of publishers associated with a specific superhero from the 'superhero' table. The query uses an INNER JOIN to connect the 'superhero' table with the 'publisher' table based on the publisher's ID. The placeholder in the WHERE clause represents the name of the superhero for which the publisher's name is being queried."
        },
        {
            "sample_id": 10191,
            "vt": "SELECT superhero.superhero_name FROM superhero INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T3.id = T2.attribute_id INNER JOIN publisher AS T4 ON T4.id = T1.publisher_id WHERE publisher.publisher_name = '[placeholder-type:string]' AND attribute.attribute_name = '[placeholder-type:string]' ORDER BY hero_attribute.attribute_value LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of superheroes from the 'superhero' table who possess a specific attribute and are published by a certain publisher. The query joins multiple tables to filter superheroes based on the publisher's name and the attribute's name, while also ordering the results by the attribute value and limiting the number of results returned."
        },
        {
            "sample_id": 10165,
            "vt": "SELECT (CAST(COUNT(*) AS FLOAT) * [placeholder-type:numeric] / (SELECT COUNT(*) FROM superhero)), CAST(SUM(CASE WHEN publisher.publisher_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) FROM superhero INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T3.id = T1.alignment_id WHERE alignment.alignment = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of superheroes from a specific publisher who have a certain alignment. It counts the total number of superheroes and multiplies it by a placeholder numeric value to get a weighted count. It also sums up a conditional count based on the publisher's name and alignment, providing insights into the distribution of superhero alignments across different publishers."
        },
        {
            "sample_id": 10139,
            "vt": "SELECT superpower.power_name FROM superhero INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE superhero.superhero_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of superpowers associated with a specific superhero from the 'superhero' table. It uses inner joins to connect the 'superhero' table with the 'hero_power' table and the 'superpower' table, allowing for the retrieval of power names based on the superhero's name provided as a placeholder."
        },
        {
            "sample_id": 10196,
            "vt": "SELECT race.race FROM superhero INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE superhero.superhero_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the race of a superhero based on their name. It retrieves the race information from the 'race' table by joining it with the 'superhero' table, using the superhero's name as a filter."
        },
        {
            "sample_id": 10177,
            "vt": "SELECT superhero.full_name FROM superhero INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE race.race = '[placeholder-type:string]'",
            "ba": "The virtual table describes the full names of superheroes from the 'superhero' table who belong to a specific race. The query uses an INNER JOIN to connect the 'superhero' table with the 'race' table based on the race identifier. The placeholder in the WHERE clause represents the specific race of the superhero."
        },
        {
            "sample_id": 10251,
            "vt": "SELECT SUM(CASE WHEN publisher.publisher_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN publisher.publisher_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM superhero INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
            "ba": "The virtual table calculates the difference between two sums based on the publisher's name from the 'superhero' and 'publisher' tables. It uses conditional aggregation to sum numeric values depending on whether the publisher's name matches a specified placeholder. This allows for a comparison of values associated with different publishers."
        },
        {
            "sample_id": 10148,
            "vt": "SELECT superhero.superhero_name, superhero.height_cm, RANK() OVER (ORDER BY superhero.height_cm) FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a ranked list of superhero names along with their heights from the 'superhero' table, filtered by a specific publisher's name. The ranking is based on the height of the superheroes, allowing users to see which superheroes are the tallest within the specified publisher's catalog."
        },
        {
            "sample_id": 10240,
            "vt": "SELECT CAST(COUNT(CASE WHEN gender.gender = '[placeholder-type:string]' THEN superhero.id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(superhero.id) FROM superhero INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE alignment.alignment = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the percentage of superheroes of a specific gender within a certain alignment. It counts the number of superheroes that match the specified gender and divides it by the total number of superheroes in the specified alignment, multiplying the result by a numeric placeholder for scaling purposes."
        },
        {
            "sample_id": 10247,
            "vt": "SELECT gender.gender FROM superhero INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE superpower.power_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the genders of superheroes who possess a specific superpower. It retrieves the gender information from the 'gender' table by joining it with the 'superhero' table and the 'hero_power' table, which links superheroes to their respective powers. The placeholder in the WHERE clause represents the name of the superpower being queried."
        },
        {
            "sample_id": 10179,
            "vt": "SELECT race.race FROM superhero INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE superhero.weight_kg = [placeholder-type:numeric]",
            "ba": "The virtual table describes the races of superheroes from the 'superhero' table who have a specific weight. The query uses an INNER JOIN to connect the 'superhero' table with the 'race' table based on the race_id, allowing us to filter superheroes by their weight using a numeric placeholder."
        },
        {
            "sample_id": 10185,
            "vt": "SELECT hero_attribute.attribute_value FROM superhero INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE superhero.superhero_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the attribute values of a specific superhero from the 'superhero' table by joining it with the 'hero_attribute' table. The query filters the results based on the superhero's name, which is provided as a placeholder."
        },
        {
            "sample_id": 10156,
            "vt": "SELECT publisher.publisher_name FROM superhero INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE superhero.superhero_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the publisher's name of a specific superhero from the 'superhero' table. The query uses an INNER JOIN to connect the 'superhero' table with the 'publisher' table based on the publisher's ID. The placeholder in the WHERE clause represents the superhero's name."
        },
        {
            "sample_id": 10174,
            "vt": "SELECT superhero.superhero_name FROM superhero INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE race.race = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of superheroes from the 'superhero' table who belong to a specific race. The query uses an INNER JOIN to connect the 'superhero' table with the 'race' table based on the race identifier. The placeholder in the WHERE clause represents the specific race being queried."
        },
        {
            "sample_id": 10152,
            "vt": "SELECT superhero.superhero_name FROM superhero WHERE EXISTS(SELECT [placeholder-type:numeric] FROM hero_power INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE superpower.power_name = '[placeholder-type:string]' AND superhero.id = hero_power.hero_id) AND EXISTS(SELECT [placeholder-type:numeric] FROM publisher WHERE publisher.publisher_name = '[placeholder-type:string]' AND superhero.publisher_id = publisher.id)",
            "ba": "The virtual table lists the names of superheroes from the 'superhero' table who possess a specific superpower and are published by a particular publisher. The query uses subqueries to check for the existence of the specified superpower and publisher, ensuring that only relevant superheroes are included in the results."
        },
        {
            "sample_id": 10224,
            "vt": "SELECT superhero.superhero_name FROM superhero ORDER BY superhero.height_cm LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of superheroes from the 'superhero' table, ordered by their height in centimeters. The placeholder in the LIMIT clause allows the user to specify how many superhero names they want to retrieve."
        },
        {
            "sample_id": 10176,
            "vt": "SELECT superpower.power_name FROM hero_power INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE hero_power.hero_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the superpowers associated with a specific superhero from the 'superpower' table. The query retrieves the names of the superpowers by joining the 'hero_power' table with the 'superpower' table based on the power ID. The placeholder in the WHERE clause represents the unique identifier of the superhero whose superpowers are being queried."
        },
        {
            "sample_id": 10264,
            "vt": "SELECT AVG(superhero.height_cm) FROM superhero INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE alignment.alignment = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average height of superheroes from the 'superhero' table who belong to a specific alignment. The alignment is determined by joining the 'superhero' table with the 'alignment' table based on the alignment ID. The placeholder in the WHERE clause represents the alignment type, such as 'Good', 'Neutral', or 'Bad'."
        },
        {
            "sample_id": 10244,
            "vt": "SELECT COUNT(superhero.id) FROM superhero INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE alignment.alignment = '[placeholder-type:string]' AND colour.colour = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of superheroes from the 'superhero' table who have a specific alignment and skin color. It joins the 'alignment' table to filter by the superhero's alignment and the 'colour' table to filter by the superhero's skin color. The placeholders represent the alignment type and skin color that the user wants to query."
        },
        {
            "sample_id": 10203,
            "vt": "SELECT superhero.height_cm FROM superhero INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE colour.colour = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the height of superheroes from the 'superhero' table, specifically filtering by the color of their eyes. The query joins the 'superhero' table with the 'colour' table to access the eye color information, using a placeholder for the specific color being queried."
        },
        {
            "sample_id": 10234,
            "vt": "SELECT superhero.superhero_name FROM superhero INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE colour.colour = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of superheroes from the 'superhero' table who have a specific eye color. The query joins the 'superhero' table with the 'colour' table to filter superheroes based on their eye color, represented by a placeholder in the WHERE clause. Additionally, a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 10236,
            "vt": "SELECT DISTINCT colour.colour FROM superhero INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id WHERE hero_attribute.attribute_value = [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct colors associated with superheroes based on their skin color. It retrieves this information by joining the 'superhero' table with the 'colour' table to get the skin color and the 'hero_attribute' table to filter superheroes based on a specific attribute value. The placeholder in the WHERE clause represents the attribute value that is being queried."
        },
        {
            "sample_id": 10186,
            "vt": "SELECT DISTINCT superpower.power_name FROM hero_power INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE hero_power.hero_id = [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct names of superpowers associated with a specific superhero. It retrieves data from the 'hero_power' table, which links superheroes to their powers, and joins it with the 'superpower' table to get the names of those powers. The placeholder in the WHERE clause represents the unique identifier of the superhero whose powers are being queried."
        },
        {
            "sample_id": 10260,
            "vt": "SELECT superhero.full_name FROM superhero WHERE superhero.superhero_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the full names of superheroes from the 'superhero' table based on a specific superhero name. The placeholder in the WHERE clause represents the superhero's name."
        },
        {
            "sample_id": 10266,
            "vt": "SELECT colour.colour FROM superhero INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE superhero.superhero_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the eye color of a specific superhero from the 'superhero' table by joining it with the 'colour' table. The placeholder in the WHERE clause represents the name of the superhero for which the eye color is being queried."
        },
        {
            "sample_id": 10199,
            "vt": "SELECT gender.gender FROM superhero INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE superhero.superhero_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the gender of a superhero based on their name. It retrieves the gender information from the 'gender' table by joining it with the 'superhero' table using the superhero's gender ID. The placeholder in the WHERE clause represents the specific superhero's name."
        },
        {
            "sample_id": 10193,
            "vt": "SELECT superhero.superhero_name FROM superhero INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE superpower.power_name = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of superheroes from the 'superhero' table who possess a specific superpower. It joins the 'superhero' table with the 'hero_power' table to link superheroes with their powers, and then further joins with the 'superpower' table to filter based on the name of the superpower."
        },
        {
            "sample_id": 10143,
            "vt": "SELECT COUNT(superhero.id) FROM superhero INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE colour.colour = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of superheroes from the 'superhero' table who have a specific eye color. It joins the 'superhero' table with the 'colour' table to filter based on the eye color specified by the placeholder."
        },
        {
            "sample_id": 10223,
            "vt": "SELECT CAST(COUNT(CASE WHEN gender.gender = '[placeholder-type:string]' THEN superhero.id ELSE NULL END) AS FLOAT) / COUNT(CASE WHEN gender.gender = '[placeholder-type:string]' THEN superhero.id ELSE NULL END) FROM superhero INNER JOIN gender AS T2 ON T1.gender_id = T2.id",
            "ba": "The virtual table calculates the proportion of superheroes of a specific gender from the 'superhero' table. It uses a join with the 'gender' table to filter superheroes based on their gender. The placeholders represent the gender type being queried."
        },
        {
            "sample_id": 10211,
            "vt": "SELECT CAST(SUM(superhero.weight_kg) AS FLOAT) / COUNT(superhero.id) FROM superhero INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE race.race = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average weight of superheroes from a specific race by summing their weights and dividing by the total number of superheroes in that race. The query joins the 'superhero' table with the 'race' table to filter superheroes based on their race."
        },
        {
            "sample_id": 10231,
            "vt": "SELECT publisher.publisher_name FROM superhero INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE superhero.id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the publisher's name of a superhero from the 'superhero' table based on a specific superhero's unique identifier. The query uses an INNER JOIN to connect the 'superhero' table with the 'publisher' table, allowing access to the publisher's name associated with that superhero. The placeholder in the WHERE clause represents the superhero's unique identifier."
        }
    ],
    "restaurant": [
        {
            "sample_id": 1746,
            "vt": "SELECT generalinfo.review FROM generalinfo INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE location.street_name = '[placeholder-type:string]' AND location.street_num = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the review ratings of restaurants based on their street name and street number. It combines data from the 'generalinfo' table, which contains restaurant reviews, and the 'location' table, which provides the street details of each restaurant. The placeholders in the WHERE clause allow users to specify the street name and street number for filtering the results."
        },
        {
            "sample_id": 1692,
            "vt": "SELECT generalinfo.label FROM location INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE location.street_name = '[placeholder-type:string]' AND generalinfo.city = '[placeholder-type:string]' ORDER BY generalinfo.review LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the labels of restaurants based on their street name and city. It joins the 'location' table with the 'generalinfo' table using the unique restaurant ID to ensure that the correct restaurant information is associated with its location. The query filters results by a specific street name and city, and it orders the results by review rating, limiting the number of results returned."
        },
        {
            "sample_id": 1767,
            "vt": "SELECT COUNT(generalinfo.food_type = '[placeholder-type:string]') FROM location INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE location.city = '[placeholder-type:string]' AND location.street_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of restaurants of a specific food type located in a particular city and street name. It combines data from the 'location' and 'generalinfo' tables using an inner join on the restaurant ID, ensuring that only restaurants in the specified city and street are considered."
        },
        {
            "sample_id": 1740,
            "vt": "SELECT location.street_name FROM location WHERE location.city = '[placeholder-type:string]'",
            "ba": "The virtual table describes the street names of restaurants located in a specific city from the 'location' table. The placeholder in the WHERE clause represents the name of the city."
        },
        {
            "sample_id": 1743,
            "vt": "SELECT COUNT(generalinfo.label) FROM generalinfo INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE geographic.county = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of restaurants from the 'generalinfo' table that are located in cities belonging to a specific county. It joins the 'generalinfo' table with the 'geographic' table based on the city, allowing for filtering by county."
        },
        {
            "sample_id": 1768,
            "vt": "SELECT location.id_restaurant FROM location INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE generalinfo.food_type = '[placeholder-type:string]' AND location.street_num > [placeholder-type:numeric] GROUP BY location.id_restaurant ORDER BY AVG(generalinfo.review) * [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of restaurants from the 'location' table that serve a specific type of food and are located on streets with a number greater than a specified value. The results are grouped by restaurant ID and ordered by the average review rating multiplied by a specified factor, indicating the popularity of the restaurants based on their reviews."
        },
        {
            "sample_id": 1756,
            "vt": "SELECT generalinfo.review FROM location INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE generalinfo.city = '[placeholder-type:string]' AND location.street_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the review ratings of restaurants based on their location in a specific city and street name. It combines data from the 'location' and 'generalinfo' tables using an inner join on the restaurant's unique identifier, ensuring that only relevant reviews for the specified city and street are selected."
        },
        {
            "sample_id": 1717,
            "vt": "SELECT DISTINCT geographic.county, geographic.region FROM location INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE location.street_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct counties and regions from the 'geographic' table based on the street name of restaurants located in a specific city. The query joins the 'location' table with the 'geographic' table to filter results according to the specified street name."
        },
        {
            "sample_id": 1710,
            "vt": "SELECT generalinfo.id_restaurant FROM generalinfo INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE generalinfo.city = '[placeholder-type:string]' AND location.street_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of restaurants from the 'generalinfo' table that are located in a specific city and on a specific street name. It uses an inner join with the 'location' table to ensure that the restaurant's location matches the specified criteria."
        },
        {
            "sample_id": 1785,
            "vt": "SELECT geographic.region FROM geographic INNER JOIN location AS T2 ON T1.city = T2.city GROUP BY geographic.region ORDER BY COUNT(location.id_restaurant) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the regions from the 'geographic' table based on the number of restaurants located in each region. It joins the 'geographic' table with the 'location' table to correlate cities and counts the number of restaurants in each region. The results are grouped by region and ordered by the count of restaurants, limiting the output to a specified number of regions."
        },
        {
            "sample_id": 1741,
            "vt": "SELECT location.id_restaurant FROM location WHERE location.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of restaurants from the 'location' table based on a specified city. The placeholder in the WHERE clause represents the name of the city."
        },
        {
            "sample_id": 1725,
            "vt": "SELECT COUNT(location.id_restaurant) FROM location WHERE location.street_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of restaurants located on a specific street name from the 'location' table. The placeholder in the WHERE clause represents the street name being queried."
        },
        {
            "sample_id": 1764,
            "vt": "SELECT generalinfo.label, location.id_restaurant FROM location INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE location.city = '[placeholder-type:string]' AND location.street_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the labels and unique identifiers of restaurants located in a specific city and street name. It combines data from the 'location' and 'generalinfo' tables using an inner join on the restaurant ID, ensuring that only restaurants in the specified city and street are included."
        },
        {
            "sample_id": 1700,
            "vt": "SELECT generalinfo.label FROM generalinfo WHERE generalinfo.food_type = '[placeholder-type:string]'",
            "ba": "The virtual table describes the labels of restaurants from the 'generalinfo' table that serve a specific type of food. The placeholder in the WHERE clause represents the food type being queried."
        },
        {
            "sample_id": 1678,
            "vt": "SELECT location.id_restaurant FROM location WHERE location.city = '[placeholder-type:string]' AND location.street_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique restaurant identifiers from the 'location' table based on the specified city and street name. The placeholders represent the city and street name that the user can modify to filter the results accordingly."
        },
        {
            "sample_id": 1723,
            "vt": "SELECT generalinfo.label FROM generalinfo WHERE generalinfo.food_type = '[placeholder-type:string]' ORDER BY generalinfo.review LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the labels of restaurants from the 'generalinfo' table that serve a specific type of food. The results are ordered by the review rating, and the number of results returned is limited by a placeholder for numeric values."
        },
        {
            "sample_id": 1712,
            "vt": "SELECT generalinfo.label FROM location INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant INNER JOIN geographic AS T3 ON T2.city = T3.city WHERE geographic.region = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the labels of restaurants located in cities that belong to a specific region. It combines data from three tables: 'location', 'generalinfo', and 'geographic'. The query filters the results based on the region of the city, using a placeholder for the region name, and limits the number of results returned using a numeric placeholder."
        },
        {
            "sample_id": 1730,
            "vt": "SELECT location.street_name FROM geographic INNER JOIN location AS T2 ON T1.city = T2.city WHERE geographic.region = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the street names of restaurants located in cities that belong to a specific region. It combines data from the 'geographic' and 'location' tables based on the city, ensuring that only those cities within the specified region are included."
        },
        {
            "sample_id": 1783,
            "vt": "SELECT location.street_name, location.street_num, location.city FROM generalinfo INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant ORDER BY generalinfo.review LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the street name, street number, and city of restaurants from the 'generalinfo' and 'location' tables. It joins these tables based on the unique restaurant ID and orders the results by the review rating, limiting the output to a specified number of entries."
        },
        {
            "sample_id": 1714,
            "vt": "SELECT COUNT(generalinfo.id_restaurant) FROM generalinfo INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE generalinfo.food_type = '[placeholder-type:string]' AND generalinfo.city = '[placeholder-type:string]' AND location.street_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of restaurants from the 'generalinfo' table that match specific criteria. It joins the 'generalinfo' table with the 'location' table to ensure that the restaurant's location is accurately represented. The placeholders in the WHERE clause allow users to specify the food type, city, and street name to filter the results accordingly."
        },
        {
            "sample_id": 1754,
            "vt": "SELECT COUNT(location.city) FROM location WHERE location.street_name = '[placeholder-type:string]' AND location.street_num < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of restaurants located on a specific street in a city, where the street number is less than a specified value. The placeholders represent the street name and the numeric threshold for the street number."
        },
        {
            "sample_id": 1718,
            "vt": "SELECT generalinfo.id_restaurant FROM generalinfo INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE generalinfo.city = '[placeholder-type:string]' AND location.street_name = '[placeholder-type:string]' AND generalinfo.food_type = '[placeholder-type:string]' ORDER BY generalinfo.review LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique restaurant IDs from the 'generalinfo' table based on specific criteria. It filters the results by the city where the restaurant is located, the street name of the restaurant, and the type of food served. The results are ordered by the review rating, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 1757,
            "vt": "SELECT location.street_num FROM generalinfo INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE generalinfo.review = [placeholder-type:numeric] AND location.city = '[placeholder-type:string]' AND generalinfo.food_type = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the street number of restaurants based on specific criteria. It joins the 'generalinfo' and 'location' tables using the restaurant's unique ID, ensuring that the data is related. The query filters results by the restaurant's review rating, the city where the restaurant is located, and the type of food served, all represented by placeholders for user input."
        },
        {
            "sample_id": 1699,
            "vt": "SELECT CAST(SUM(CASE WHEN location.street_name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(location.id_restaurant) FROM location INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE geographic.county = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average based on the street names of restaurants located in a specific county. It sums up a conditional value based on whether the street name matches a specified placeholder, and then multiplies this sum by another placeholder value. Finally, it divides this product by the count of restaurants in that location, providing insight into the average rating or score of restaurants based on their street names within a given county."
        },
        {
            "sample_id": 1709,
            "vt": "SELECT location.street_num, location.street_name, generalinfo.city FROM generalinfo INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE generalinfo.label = '[placeholder-type:string]'",
            "ba": "The virtual table provides the street number and street name of a restaurant along with the city it is located in. It combines data from the 'generalinfo' and 'location' tables using an inner join on the restaurant's unique identifier. The query filters results based on a specific restaurant label, represented by a placeholder."
        },
        {
            "sample_id": 1735,
            "vt": "SELECT geographic.county FROM generalinfo INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE generalinfo.label = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the county of a restaurant based on its label from the 'generalinfo' table. It joins the 'generalinfo' table with the 'geographic' table to access the corresponding county for the city where the restaurant is located. The placeholder in the WHERE clause represents the specific label of the restaurant being queried."
        },
        {
            "sample_id": 1722,
            "vt": "SELECT location.street_name FROM location GROUP BY location.street_name ORDER BY COUNT(location.street_name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists unique street names from the 'location' table, grouping them to count occurrences and ordering them by the frequency of each street name. The placeholder allows for limiting the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 1726,
            "vt": "SELECT generalinfo.label FROM generalinfo INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE geographic.county = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the labels of restaurants from the 'generalinfo' table that are located in cities belonging to a specific county. It uses an inner join with the 'geographic' table to filter the results based on the county associated with the city."
        },
        {
            "sample_id": 1739,
            "vt": "SELECT AVG(generalinfo.review) FROM generalinfo INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE generalinfo.food_type = '[placeholder-type:string]' GROUP BY generalinfo.id_restaurant ORDER BY AVG(generalinfo.review)",
            "ba": "The virtual table calculates the average review rating of restaurants based on their food type. It joins the 'generalinfo' table with the 'geographic' table to ensure that the city information is consistent. The results are grouped by each restaurant's unique identifier, allowing for an average rating to be computed for each restaurant that matches the specified food type. The final output is ordered by the average review rating, providing a ranking of restaurants based on their popularity as indicated by customer reviews."
        },
        {
            "sample_id": 1732,
            "vt": "SELECT generalinfo.food_type FROM geographic INNER JOIN generalinfo AS T2 ON T1.city = T2.city WHERE geographic.county = '[placeholder-type:string]' GROUP BY generalinfo.food_type ORDER BY COUNT(generalinfo.food_type) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the different types of food available in restaurants located in a specific county. It retrieves the food types from the 'generalinfo' table, joining it with the 'geographic' table to filter by the county. The results are grouped by food type and ordered by the count of each type, allowing users to see the most common food types in that county, limited to a specified number of results."
        },
        {
            "sample_id": 1724,
            "vt": "SELECT geographic.county FROM geographic WHERE geographic.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the county information from the 'geographic' table based on a specified city. The placeholder in the WHERE clause represents the name of the city for which the county is being queried."
        },
        {
            "sample_id": 1677,
            "vt": "SELECT COUNT(location.id_restaurant) FROM location WHERE location.street_num = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of restaurants located on a specific street number from the 'location' table. The placeholder in the WHERE clause represents the street number being queried."
        },
        {
            "sample_id": 1728,
            "vt": "SELECT location.street_name FROM geographic INNER JOIN location AS T2 ON T1.city = T2.city WHERE geographic.county = '[placeholder-type:string]' GROUP BY location.street_name HAVING COUNT(location.id_restaurant) > [placeholder-type:numeric]",
            "ba": "The virtual table describes the street names of restaurants located in cities that belong to a specific county. It filters the results based on the county and groups the street names, only including those streets that have more than a specified number of restaurants."
        },
        {
            "sample_id": 1747,
            "vt": "SELECT location.street_num, location.street_name FROM generalinfo INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant ORDER BY generalinfo.review LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the street number and street name of restaurants from the 'location' table, joining it with the 'generalinfo' table to filter based on restaurant information. The results are ordered by the review rating of the restaurants, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 1711,
            "vt": "SELECT generalinfo.food_type FROM generalinfo INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE location.street_num = [placeholder-type:numeric] AND location.street_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the food type of restaurants based on their street number and street name. It combines data from the 'generalinfo' and 'location' tables using an inner join on the restaurant ID, ensuring that only the relevant restaurants located at the specified address are included in the results."
        },
        {
            "sample_id": 1687,
            "vt": "SELECT generalinfo.review FROM generalinfo INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE location.street_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the review ratings of restaurants based on their street name. It combines data from the 'generalinfo' table, which contains restaurant reviews, and the 'location' table, which provides the street information for each restaurant. The placeholder in the WHERE clause allows users to specify a particular street name to filter the results accordingly."
        },
        {
            "sample_id": 1771,
            "vt": "SELECT COUNT(DISTINCT city) FROM geographic WHERE geographic.region = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct cities from the 'geographic' table that belong to a specific region. The placeholder in the WHERE clause represents the region name."
        },
        {
            "sample_id": 1693,
            "vt": "SELECT location.street_name FROM location INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant INNER JOIN geographic AS T3 ON T2.city = T3.city WHERE generalinfo.label = '[placeholder-type:string]' AND geographic.county = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the street names of restaurants based on their labels and the county they are located in. It joins the 'location' table with the 'generalinfo' table to match restaurants by their unique IDs, and also joins with the 'geographic' table to filter by the county associated with the city where the restaurant is located. The placeholders in the WHERE clause represent the restaurant's label and the county name."
        },
        {
            "sample_id": 1694,
            "vt": "SELECT DISTINCT location.street_num FROM location INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE generalinfo.label = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct street numbers of restaurants based on their labels from the 'location' and 'generalinfo' tables. It uses an inner join to connect the two tables through the unique restaurant ID, ensuring that only relevant street numbers for the specified restaurant label are selected."
        },
        {
            "sample_id": 1704,
            "vt": "SELECT geographic.county, geographic.region FROM geographic WHERE geographic.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the county and region information from the 'geographic' table for a specified city. The placeholder in the WHERE clause represents the name of the city being queried."
        },
        {
            "sample_id": 1703,
            "vt": "SELECT geographic.city FROM geographic WHERE geographic.county = '[placeholder-type:string]' AND geographic.region = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a list of cities from the 'geographic' table that belong to a specific county and region. The placeholders in the WHERE clause represent the county and region names, while the LIMIT clause allows for controlling the number of results returned."
        },
        {
            "sample_id": 1738,
            "vt": "SELECT CAST(SUM(CASE WHEN geographic.region = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(location.id_restaurant) FROM geographic INNER JOIN location AS T2 ON T1.city = T2.city",
            "ba": "The virtual table calculates a weighted average of restaurant ratings based on their geographical region. It sums up the ratings of restaurants located in a specific region and normalizes this sum by the total number of restaurants in that region. The placeholders represent the region name, the rating values, and a multiplier for scaling the result."
        },
        {
            "sample_id": 1707,
            "vt": "SELECT COUNT(generalinfo.id_restaurant) FROM generalinfo WHERE generalinfo.food_type = '[placeholder-type:string]' AND generalinfo.city = '[placeholder-type:string]' AND generalinfo.review = (SELECT MIN(generalinfo.review) FROM generalinfo WHERE food_type = 'american' AND city = 'carmel')",
            "ba": "The virtual table counts the number of restaurants from the 'generalinfo' table that match a specific food type and city, while also filtering for those that have the lowest review rating among American restaurants in a specified city. The placeholders represent the food type and city names."
        },
        {
            "sample_id": 1670,
            "vt": "SELECT COUNT(generalinfo.id_restaurant) FROM generalinfo WHERE generalinfo.review < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of restaurants from the 'generalinfo' table that have a review rating below a specified threshold. The placeholder in the WHERE clause represents the review rating limit."
        },
        {
            "sample_id": 1755,
            "vt": "SELECT generalinfo.label FROM generalinfo WHERE generalinfo.food_type = '[placeholder-type:string]' AND generalinfo.city = '[placeholder-type:string]'",
            "ba": "The virtual table lists the labels of restaurants from the 'generalinfo' table that serve a specific type of food and are located in a specified city. The placeholders in the WHERE clause represent the food type and city name."
        },
        {
            "sample_id": 1674,
            "vt": "SELECT DISTINCT geographic.county FROM geographic WHERE geographic.region <> '[placeholder-type:string]'",
            "ba": "The virtual table retrieves a distinct list of counties from the 'geographic' table, filtering out those that belong to a specific region. The placeholder in the WHERE clause represents the region to be excluded."
        },
        {
            "sample_id": 1688,
            "vt": "SELECT location.id_restaurant FROM location INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE geographic.county = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique restaurant IDs from the 'location' table, filtering based on the county of the city where the restaurant is located. It uses an inner join with the 'geographic' table to ensure that only restaurants in the specified county are included in the results."
        },
        {
            "sample_id": 1750,
            "vt": "SELECT COUNT(geographic.city) FROM geographic WHERE geographic.region = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cities from the 'geographic' table that belong to a specific region. The placeholder in the WHERE clause represents the region name."
        },
        {
            "sample_id": 1731,
            "vt": "SELECT generalinfo.review FROM location INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE location.street_name = '[placeholder-type:string]' AND location.street_num = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the review ratings of restaurants based on their street address. It combines data from the 'location' and 'generalinfo' tables, filtering for a specific street name and street number. The placeholder in the WHERE clause allows users to specify the street name as a string and the street number as a numeric value."
        },
        {
            "sample_id": 1782,
            "vt": "SELECT COUNT(generalinfo.food_type) FROM geographic INNER JOIN generalinfo AS T2 ON T1.city = T2.city WHERE geographic.region = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of different food types available in restaurants located in cities that belong to a specific region. It combines data from the 'geographic' table, which provides information about the region of each city, and the 'generalinfo' table, which contains details about the restaurants and their food types. The placeholder in the WHERE clause represents the region being queried."
        },
        {
            "sample_id": 1685,
            "vt": "SELECT DISTINCT geographic.county FROM generalinfo INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE generalinfo.label <> '[placeholder-type:string]'",
            "ba": "The virtual table retrieves a distinct list of counties from the 'geographic' table based on the cities associated with restaurants in the 'generalinfo' table, excluding a specific restaurant label."
        },
        {
            "sample_id": 1761,
            "vt": "SELECT COUNT(location.id_restaurant) FROM location INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE location.street_name = '[placeholder-type:string]' AND location.city = '[placeholder-type:string]' AND generalinfo.food_type = '[placeholder-type:string]' AND generalinfo.label LIKE '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of restaurants based on specific criteria such as street name, city, food type, and a partial match on the restaurant label."
        },
        {
            "sample_id": 1690,
            "vt": "SELECT generalinfo.label FROM generalinfo INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE location.street_name = '[placeholder-type:string]' AND generalinfo.food_type <> '[placeholder-type:string]' AND location.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the labels of restaurants from the 'generalinfo' table that are located on a specific street and in a specific city, while excluding a certain type of food. The query uses an inner join with the 'location' table to match restaurants based on their unique identifiers."
        },
        {
            "sample_id": 1736,
            "vt": "SELECT COUNT(geographic.city) FROM geographic INNER JOIN location AS T2 ON T1.city = T2.city WHERE geographic.region = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cities from the 'geographic' table that are associated with restaurants located in those cities. It filters the results based on a specific region, using a placeholder for the region name."
        },
        {
            "sample_id": 1786,
            "vt": "SELECT location.street_num, location.street_name, location.city FROM location INNER JOIN generalinfo AS T2 ON T1.city = T2.city WHERE generalinfo.review >= [placeholder-type:numeric]",
            "ba": "The virtual table describes the street number, street name, and city of restaurants that have a review rating above a certain threshold. It combines data from the 'location' and 'generalinfo' tables based on the city, ensuring that only restaurants with higher review ratings are included."
        },
        {
            "sample_id": 1713,
            "vt": "SELECT generalinfo.label FROM generalinfo INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE location.street_num = [placeholder-type:numeric] AND generalinfo.city = '[placeholder-type:string]' AND location.street_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the labels of restaurants from the 'generalinfo' table that are located on a specific street number and street name in a specified city. The query uses an inner join with the 'location' table to match the restaurant IDs and filter based on the street number and street name, while also ensuring the city matches."
        },
        {
            "sample_id": 1776,
            "vt": "SELECT COUNT(generalinfo.id_restaurant) FROM generalinfo INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE generalinfo.city = '[placeholder-type:string]' AND generalinfo.food_type = '[placeholder-type:string]' AND location.street_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of restaurants from the 'generalinfo' table that match specific criteria. It joins the 'generalinfo' table with the 'location' table to ensure that the restaurant's location is accurately represented. The placeholders in the WHERE clause allow users to specify the city, food type, and street name to filter the results accordingly."
        },
        {
            "sample_id": 1672,
            "vt": "SELECT COUNT(generalinfo.id_restaurant) FROM generalinfo WHERE generalinfo.food_type = '[placeholder-type:string]' AND generalinfo.city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of restaurants from the 'generalinfo' table that serve a specific type of food and are located in a specified city. The placeholders in the WHERE clause represent the food type and the city name."
        },
        {
            "sample_id": 1696,
            "vt": "SELECT DISTINCT geographic.region FROM generalinfo INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE generalinfo.food_type = '[placeholder-type:string]' AND geographic.region <> '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct regions from the 'geographic' table based on the food type of restaurants listed in the 'generalinfo' table. It filters out regions that match a specified region, allowing users to find regions with restaurants of a certain food type that are not in a specific region."
        },
        {
            "sample_id": 1752,
            "vt": "SELECT geographic.city FROM geographic WHERE geographic.region = '[placeholder-type:string]' AND geographic.county = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the cities from the 'geographic' table that belong to a specific region and county. The placeholders in the WHERE clause represent the region and county names."
        },
        {
            "sample_id": 1766,
            "vt": "SELECT generalinfo.food_type FROM location INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE location.street_num = [placeholder-type:numeric] AND location.street_name = '[placeholder-type:string]' AND generalinfo.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the food type of restaurants based on their street number, street name, and city. It combines data from the 'location' and 'generalinfo' tables using an inner join on the restaurant ID, ensuring that only restaurants located at the specified street address in the specified city are considered."
        },
        {
            "sample_id": 1778,
            "vt": "SELECT generalinfo.food_type FROM geographic INNER JOIN generalinfo AS T2 ON T1.city = T2.city WHERE geographic.region = '[placeholder-type:string]' GROUP BY generalinfo.food_type ORDER BY COUNT(generalinfo.food_type) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the types of food offered by restaurants located in cities that belong to a specific region. It joins the 'geographic' table with the 'generalinfo' table based on the city, filtering the results by the specified region. The results are grouped by food type and ordered by the count of each food type, limiting the output to a specified number of results."
        },
        {
            "sample_id": 1781,
            "vt": "SELECT location.street_name FROM location INNER JOIN generalinfo AS T2 ON T1.city = T2.city WHERE generalinfo.food_type = '[placeholder-type:string]' AND location.city = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the street names of restaurants from the 'location' table that serve a specific type of food and are located in a specified city. It uses an inner join to connect the 'location' and 'generalinfo' tables based on the city, ensuring that only relevant restaurants are considered based on their food type and location."
        },
        {
            "sample_id": 1774,
            "vt": "SELECT COUNT(location.id_restaurant) FROM location WHERE location.city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of restaurants located in a specific city from the 'location' table. The placeholder in the WHERE clause represents the name of the city."
        },
        {
            "sample_id": 1671,
            "vt": "SELECT generalinfo.food_type FROM generalinfo WHERE generalinfo.review = (SELECT MAX(generalinfo.review) FROM generalinfo) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the food types of restaurants from the 'generalinfo' table that have the highest review rating. The query uses a subquery to find the maximum review rating and limits the results based on a specified number of entries."
        },
        {
            "sample_id": 1749,
            "vt": "SELECT CAST(SUM(CASE WHEN geographic.region = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(geographic.region) FROM geographic",
            "ba": "The virtual table calculates a weighted average of restaurant reviews based on the region specified. It sums the reviews for restaurants located in a particular region and normalizes this sum by the count of regions, allowing for an analysis of restaurant popularity in that region."
        },
        {
            "sample_id": 1775,
            "vt": "SELECT geographic.region FROM generalinfo INNER JOIN geographic AS T2 ON T1.city = T2.city ORDER BY generalinfo.review LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the regions corresponding to restaurants based on their city from the 'geographic' and 'generalinfo' tables. It uses an inner join to connect the two tables through the city column, ensuring that only restaurants located in cities present in the geographic data are considered. The results are ordered by the review rating of the restaurants, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 1742,
            "vt": "SELECT COUNT(geographic.city) FROM geographic WHERE geographic.region = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cities from the 'geographic' table that belong to a specific region. The placeholder in the WHERE clause represents the region name."
        },
        {
            "sample_id": 1684,
            "vt": "SELECT location.street_name FROM location INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE location.city = '[placeholder-type:string]' AND generalinfo.food_type = '[placeholder-type:string]' AND NOT location.street_name IS NULL",
            "ba": "The virtual table retrieves the street names of restaurants located in a specific city that serve a particular type of food. It combines data from the 'location' and 'generalinfo' tables, ensuring that only non-null street names are included in the results."
        },
        {
            "sample_id": 1708,
            "vt": "SELECT CAST(SUM(CASE WHEN generalinfo.food_type = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(generalinfo.id_restaurant) FROM generalinfo WHERE generalinfo.city = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rating of restaurants based on their food type in a specific city. It sums up the ratings of restaurants that match the specified food type and divides it by the total number of restaurants in that city, providing a weighted average rating."
        }
    ],
    "language_corpus": [
        {
            "sample_id": 5706,
            "vt": "SELECT pages.revision FROM pages WHERE pages.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the revision number of a specific Wikipedia page based on its title from the 'pages' table. The placeholder in the WHERE clause represents the title of the page being queried."
        },
        {
            "sample_id": 5686,
            "vt": "SELECT pages.page FROM pages WHERE pages.title LIKE '[placeholder-type:string]' OR pages.title LIKE '[placeholder-type:string]' OR pages.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the page IDs from the 'pages' table where the title of the page matches any of the specified patterns. The placeholders represent different title patterns that can be used to filter the results."
        },
        {
            "sample_id": 5782,
            "vt": "SELECT words.occurrences FROM biwords WHERE biwords.w1st = (SELECT words.wid FROM words WHERE word = '\u00e0bac') AND biwords.w2nd = (SELECT words.wid FROM words WHERE word = 'xin\u00e8s')",
            "ba": "The virtual table retrieves the occurrences of a specific biword pair from the 'biwords' table, where the first word is '\u00e0bac' and the second word is 'xin\u00e8s'. The occurrences are filtered based on the unique word IDs of these words obtained from the 'words' table."
        },
        {
            "sample_id": 5798,
            "vt": "SELECT SUM(pages_words.occurrences) FROM pages INNER JOIN pages_words AS T2 ON T1.pid = T2.pid WHERE pages.title = '[placeholder-type:string]' AND pages_words.wid = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total occurrences of a specific word on a Wikipedia page with a given title. It joins the 'pages' table with the 'pages_words' table to access the occurrences of words associated with each page. The placeholders represent the title of the page and the word ID for which the occurrences are being summed."
        },
        {
            "sample_id": 5784,
            "vt": "SELECT words.occurrences - (SELECT words.occurrences FROM biwords WHERE w1st = (SELECT wid FROM words WHERE word = '\u00e0bac') AND w2nd = (SELECT wid FROM words WHERE word = 'xin\u00e8s')) FROM words WHERE words.word = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between the occurrences of a specific word and the occurrences of a biword pair consisting of that word and another specified word. It retrieves the occurrences of the specified word from the 'words' table and subtracts the occurrences of the biword pair from the 'biwords' table, where the first word is identified by its unique word id and the second word is also identified by its unique word id."
        },
        {
            "sample_id": 5787,
            "vt": "SELECT COUNT(langs.pages) FROM langs INNER JOIN biwords AS T2 ON T1.lid = T2.lid WHERE biwords.w1st = (SELECT words.wid FROM words WHERE word = '\u00e0bac') AND biwords.w2nd = (SELECT words.wid FROM words WHERE word = 'xin\u00e8s')",
            "ba": "The virtual table counts the total number of Wikipedia pages in a specific language that contain a particular pair of words. It joins the 'langs' table with the 'biwords' table to filter based on the language id and checks for occurrences of the specified word pair. The placeholders represent the words being searched for in the database."
        },
        {
            "sample_id": 5689,
            "vt": "SELECT COUNT(pages.pid) FROM pages WHERE pages.words BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of Wikipedia pages in the 'pages' table that have a word count within a specified range. The placeholders represent the minimum and maximum word counts for filtering the pages."
        },
        {
            "sample_id": 5701,
            "vt": "SELECT pages.title FROM pages INNER JOIN pages_words AS T2 ON T1.pid = T2.pid ORDER BY pages.words LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of Wikipedia pages related to a specific language, ordered by the number of words on each page. The query joins the 'pages' table with the 'pages_words' table to access the relevant data, and it limits the results based on a specified number of pages."
        },
        {
            "sample_id": 5746,
            "vt": "SELECT langs.lang FROM biwords INNER JOIN langs AS T2 ON T1.lid = T2.lid WHERE biwords.w1st = [placeholder-type:numeric] AND biwords.w2nd = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of languages from the 'langs' table that correspond to specific biword pairs identified by their word IDs. The query uses an inner join to connect the 'biwords' table with the 'langs' table based on the language ID, filtering for specific word IDs for the first and second words in the biword pair."
        },
        {
            "sample_id": 5788,
            "vt": "SELECT CAST((SUM(CASE WHEN pages.title = '[placeholder-type:string]' THEN pages_words.occurrences END) - SUM(CASE WHEN pages.title = '[placeholder-type:string]' THEN pages_words.occurrences END)) AS FLOAT) * [placeholder-type:numeric] / SUM(CASE WHEN pages.title = '[placeholder-type:string]' THEN pages_words.occurrences END) FROM words INNER JOIN pages_words AS T2 ON T1.wid = T2.wid INNER JOIN pages AS T3 ON T2.pid = T3.pid WHERE words.word = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a specific metric related to word occurrences in Wikipedia pages for a given language. It sums the occurrences of a specified word across pages with a specific title, applies a mathematical operation involving a placeholder for numeric values, and normalizes this by the total occurrences of the word in those pages. The placeholders represent the title of the page and the word being analyzed, allowing users to customize the query for different words and titles."
        },
        {
            "sample_id": 5691,
            "vt": "SELECT words.word FROM words INNER JOIN pages_words AS T2 ON T1.wid = T2.wid WHERE pages_words.occurrences = (SELECT MAX(words.occurrences) FROM pages_words)",
            "ba": "The virtual table retrieves the most frequently occurring word from the 'words' table based on its occurrences in the 'pages_words' table. It uses an inner join to connect the two tables on the word ID, filtering for the maximum occurrences found in the 'pages_words' table."
        },
        {
            "sample_id": 5712,
            "vt": "SELECT pages_words.wid FROM pages INNER JOIN pages_words AS T2 ON T1.pid = T2.pid WHERE pages.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the word IDs from the 'pages_words' table that are associated with a specific Wikipedia page title. It joins the 'pages' table with the 'pages_words' table based on the page ID, allowing for the extraction of word IDs related to that particular page title."
        },
        {
            "sample_id": 5704,
            "vt": "SELECT biwords.w1st, biwords.w2nd, biwords.occurrences FROM pages INNER JOIN pages_words AS T2 ON T1.pid = T2.pid INNER JOIN biwords AS T3 ON T2.wid = T3.w1st OR T2.wid = T3.w2nd WHERE pages.title = '[placeholder-type:string]' ORDER BY biwords.occurrences LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the first and second words of biword pairs along with their occurrences from the 'biwords' table. It joins the 'pages' table to filter results based on a specific Wikipedia page title and uses the 'pages_words' table to connect words to their respective pages. The results are ordered by the number of occurrences and limited to a specified number."
        },
        {
            "sample_id": 5816,
            "vt": "SELECT COUNT(biwords.w1st) FROM words INNER JOIN biwords AS T2 ON T1.wid = T2.w2nd WHERE words.word = '[placeholder-type:string]'",
            "ba": "The virtual table counts the occurrences of the first word in biword pairs from the 'biwords' table, where the second word matches a specific word from the 'words' table. The placeholder represents the specific word being queried."
        },
        {
            "sample_id": 5688,
            "vt": "SELECT pages.title FROM pages WHERE pages.revision BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of Wikipedia pages from the 'pages' table that fall within a specified range of revisions. The placeholders represent the lower and upper bounds of the revision numbers."
        },
        {
            "sample_id": 5747,
            "vt": "SELECT langs_words.occurrences FROM langs_words INNER JOIN words AS T2 ON T1.wid = T2.wid WHERE words.word = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the occurrences of a specific word in the Catalan language from the 'langs_words' table. It joins with the 'words' table to filter based on the word provided by the user."
        },
        {
            "sample_id": 5698,
            "vt": "SELECT pages.title FROM pages WHERE pages.words = (SELECT MAX(pages.words) FROM pages)",
            "ba": "The virtual table retrieves the titles of Wikipedia pages that have the highest number of different words in the 'pages' table. The inner query identifies the maximum count of words across all pages, and the outer query selects the titles of those pages that match this maximum count."
        },
        {
            "sample_id": 5783,
            "vt": "SELECT CASE WHEN (SELECT words.occurrences FROM biwords WHERE w1st = (SELECT wid FROM words WHERE word = '\u00e0bac') AND w2nd = (SELECT wid FROM words WHERE word = 'xin\u00e8s')) > (SELECT words.occurrences FROM biwords WHERE w1st = (SELECT wid FROM words WHERE word = '\u00e0bac') AND w2nd = (SELECT wid FROM words WHERE word = 'grec')) THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM words LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table compares the occurrences of two biword pairs involving the word '\u00e0bac' and two other words: 'xin\u00e8s' and 'grec'. It uses subqueries to retrieve the occurrences of each biword pair from the 'biwords' table. The result is a conditional statement that returns one of two string placeholders based on which biword pair has a higher occurrence count. The query limits the results to a specified number using a numeric placeholder."
        },
        {
            "sample_id": 5697,
            "vt": "SELECT langs_words.wid FROM langs_words WHERE langs_words.occurrences <= [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the word IDs from the 'langs_words' table where the occurrences of each word in a specific language are less than or equal to a specified number. The placeholder in the WHERE clause represents the maximum number of occurrences allowed for the words."
        },
        {
            "sample_id": 5765,
            "vt": "SELECT COUNT(langs.pages) FROM langs INNER JOIN langs_words AS T2 ON T1.lid = T2.lid WHERE langs_words.occurrences = [placeholder-type:numeric]",
            "ba": "The virtual table counts the total number of pages in the 'langs' table that are associated with languages having a specific number of occurrences of words. It joins the 'langs' table with the 'langs_words' table to filter based on the occurrences of words in each language."
        },
        {
            "sample_id": 5772,
            "vt": "SELECT langs.pages FROM langs WHERE langs.lang = '[placeholder-type:string]'",
            "ba": "The virtual table describes the total number of pages available in Wikipedia for a specific language from the 'langs' table. The placeholder in the WHERE clause represents the name of the language being queried."
        },
        {
            "sample_id": 5763,
            "vt": "SELECT langs.locale FROM langs INNER JOIN pages AS T2 ON T1.lid = T2.lid WHERE pages.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the locale of languages from the 'langs' table by joining it with the 'pages' table. It filters the results based on the title of a specific Wikipedia page, using a placeholder for the title."
        },
        {
            "sample_id": 5780,
            "vt": "SELECT pages.title FROM words INNER JOIN pages_words AS T2 ON T1.wid = T2.wid INNER JOIN pages AS T3 ON T2.pid = T3.pid WHERE words.word = '[placeholder-type:string]' AND pages_words.occurrences > [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles of Wikipedia pages that contain a specific word and have a certain number of occurrences. It retrieves data from the 'words' table and joins it with the 'pages_words' table to link words to their respective pages, and then further joins with the 'pages' table to get the titles of those pages. The placeholders represent the specific word to search for and the minimum number of occurrences required."
        },
        {
            "sample_id": 5770,
            "vt": "SELECT langs.pages FROM langs INNER JOIN langs_words AS T2 ON T1.lid = T2.lid WHERE langs_words.occurrences > [placeholder-type:numeric] GROUP BY langs.pages",
            "ba": "The virtual table retrieves the total number of Wikipedia pages in different languages from the 'langs' table, specifically focusing on languages that have a certain number of word occurrences. The query joins the 'langs' table with the 'langs_words' table to filter languages based on the occurrences of words associated with them. The placeholder in the WHERE clause represents the minimum number of occurrences required for the language to be included in the results."
        },
        {
            "sample_id": 5810,
            "vt": "SELECT words.word FROM words WHERE words.occurrences = (SELECT MAX(words.occurrences) FROM words)",
            "ba": "The virtual table retrieves the word from the 'words' table that has the highest number of occurrences. The subquery identifies the maximum occurrences of any word in the 'words' table, and the main query selects the word that matches this maximum occurrence value."
        },
        {
            "sample_id": 5759,
            "vt": "SELECT pages.title FROM pages WHERE pages.revision = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of Wikipedia pages from the 'pages' table that correspond to a specific revision number. The placeholder in the WHERE clause represents the revision number being queried."
        },
        {
            "sample_id": 5734,
            "vt": "SELECT CAST(SUM(pages_words.occurrences) AS FLOAT) / COUNT(pages.page) FROM pages INNER JOIN pages_words AS T2 ON T1.pid = T2.pid WHERE pages.words = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average occurrences of words across Wikipedia pages in a specific language. It sums the occurrences of words from the 'pages_words' table and divides it by the total number of pages from the 'pages' table, filtered by the total number of words in those pages using a numeric placeholder."
        },
        {
            "sample_id": 5719,
            "vt": "SELECT words.word, words.word FROM words LEFT JOIN biwords AS T2 ON T1.wid = T2.w1st LEFT JOIN words AS T3 ON T3.wid = T2.w2nd WHERE words.wid <= [placeholder-type:numeric] GROUP BY words.wid",
            "ba": "The virtual table retrieves pairs of words from the 'words' table that are part of biword combinations. It uses a LEFT JOIN to connect the 'words' table with the 'biwords' table, allowing for the selection of words that may or may not have a corresponding biword. The query filters the results based on a numeric placeholder for the word ID, ensuring that only words with IDs less than or equal to the specified value are included. The results are grouped by the word ID to avoid duplicates."
        },
        {
            "sample_id": 5809,
            "vt": "SELECT pages.title FROM pages WHERE pages.lid = [placeholder-type:numeric] AND pages.words = [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles of Wikipedia pages from the 'pages' table that are associated with a specific language and have a certain number of words. The placeholders represent the language ID and the word count, allowing users to specify their desired criteria."
        },
        {
            "sample_id": 5803,
            "vt": "SELECT COUNT(biwords.w1st) FROM biwords WHERE biwords.w2nd = (SELECT words.wid FROM words WHERE word = 'base')",
            "ba": "The virtual table counts the occurrences of the first word in biword pairs from the 'biwords' table where the second word matches a specific word from the 'words' table. The placeholder in the subquery represents the specific word being searched for."
        },
        {
            "sample_id": 5738,
            "vt": "SELECT words.word, words.wid FROM words ORDER BY words.occurrences LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the words and their unique identifiers from the 'words' table, ordered by the number of occurrences. The placeholder allows for limiting the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 5801,
            "vt": "SELECT pages.pid FROM pages_words WHERE pages.pid = (SELECT pages.pid FROM pages WHERE revision = 28278070) ORDER BY pages_words.occurrences LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the page IDs from the 'pages_words' table that correspond to a specific Wikipedia page revision. The query filters the results based on a subquery that identifies the page ID for the given revision number. Additionally, it orders the results by the number of occurrences of words on those pages and limits the output to a specified number of results."
        },
        {
            "sample_id": 5804,
            "vt": "SELECT langs_words.occurrences FROM words INNER JOIN langs_words AS T2 ON T1.wid = T2.wid WHERE words.word = '[placeholder-type:string]' AND langs_words.lid = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the occurrences of a specific word in a particular language from the 'langs_words' table by joining it with the 'words' table. The placeholders represent the word to search for and the language id."
        },
        {
            "sample_id": 5692,
            "vt": "SELECT words.word FROM words INNER JOIN biwords AS T2 ON T1.wid = T2.w1st WHERE biwords.w2nd = (SELECT words.wid FROM words WHERE word = 'antic')",
            "ba": "The virtual table retrieves words from the 'words' table that are associated with a specific biword pair where the second word is 'antic'. It uses an inner join to connect the 'words' table with the 'biwords' table based on the first word's ID, and filters the results to include only those pairs where the second word matches a specific word ID."
        },
        {
            "sample_id": 5756,
            "vt": "SELECT langs.pages FROM langs",
            "ba": "The virtual table provides the total number of pages available in Wikipedia for each language from the 'langs' table. The placeholder in the SELECT clause represents the total pages for a specific language."
        },
        {
            "sample_id": 5752,
            "vt": "SELECT CAST(COUNT(CASE WHEN langs_words.occurrences < [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(langs.lid) FROM langs INNER JOIN langs_words AS T2 ON T1.lid = T2.lid WHERE langs.lang = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of occurrences of words in a specific language from the 'langs' table. It counts the number of occurrences that are below a specified threshold and multiplies this count by a given factor, then divides by the total number of languages. The placeholder in the WHERE clause represents the language name, while the numeric placeholders represent thresholds and factors for calculations."
        },
        {
            "sample_id": 5794,
            "vt": "SELECT words.wid FROM words WHERE words.word = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier of a word from the 'words' table based on a specific word provided by the user. The placeholder in the WHERE clause represents the word being searched for."
        },
        {
            "sample_id": 5762,
            "vt": "SELECT words.word FROM words INNER JOIN langs_words AS T2 ON T1.wid = T2.wid WHERE langs_words.occurrences = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves words from the 'words' table that have a specific number of occurrences in the 'langs_words' table. The placeholder in the WHERE clause represents the number of occurrences to filter by."
        },
        {
            "sample_id": 5741,
            "vt": "SELECT CAST(COUNT(CASE WHEN langs_words.occurrences > [placeholder-type:numeric] THEN langs_words.lid ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(langs_words.lid) FROM langs_words",
            "ba": "The virtual table calculates the proportion of languages in the 'langs_words' table that have occurrences greater than a specified threshold. It multiplies this count by a placeholder numeric value and divides it by the total count of language IDs in the same table."
        },
        {
            "sample_id": 5815,
            "vt": "SELECT COUNT(pages_words.pid) FROM words INNER JOIN pages_words AS T2 ON T1.wid = T2.wid WHERE words.word = '[placeholder-type:string]' AND pages_words.occurrences > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of Wikipedia pages that contain a specific word and have a certain number of occurrences. It joins the 'words' table with the 'pages_words' table to filter based on the word and its occurrences."
        },
        {
            "sample_id": 5731,
            "vt": "SELECT pages.page FROM words INNER JOIN pages_words AS T2 ON T1.wid = T2.wid INNER JOIN pages AS T3 ON T2.pid = T3.pid WHERE words.word = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the page IDs of Wikipedia pages that contain a specific word from the 'words' table. It joins the 'words' table with the 'pages_words' table to find the corresponding page IDs, and then further joins with the 'pages' table to ensure the correct association between words and their respective pages."
        },
        {
            "sample_id": 5735,
            "vt": "SELECT pages.page FROM pages WHERE pages.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the page IDs from the 'pages' table where the title matches a specified value. The placeholder in the WHERE clause represents the title of the Wikipedia page being queried."
        },
        {
            "sample_id": 5767,
            "vt": "SELECT COUNT(pages_words.wid) FROM pages INNER JOIN pages_words AS T2 ON T1.pid = T2.pid WHERE pages.words = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of unique words associated with Wikipedia pages in a specific language. It joins the 'pages' table with the 'pages_words' table to filter the results based on the total number of words in the pages. The placeholder in the WHERE clause represents the total word count to filter the pages accordingly."
        },
        {
            "sample_id": 5761,
            "vt": "SELECT langs.locale FROM langs INNER JOIN pages AS T2 ON T1.lid = T2.lid WHERE pages.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the locale of languages from the 'langs' table that are associated with specific Wikipedia pages. It uses an inner join to connect the 'langs' table with the 'pages' table based on the language ID. The placeholder in the WHERE clause represents the title of the Wikipedia page being queried."
        },
        {
            "sample_id": 5745,
            "vt": "SELECT pages.title, pages.revision FROM pages WHERE pages.lid = [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the titles and revision numbers of Wikipedia pages associated with a specific language identified by its language id. The placeholders allow users to specify the language id and the limit on the number of results returned."
        },
        {
            "sample_id": 5818,
            "vt": "SELECT COUNT(biwords.w2nd) FROM words INNER JOIN biwords AS T2 ON T1.wid = T2.w1st WHERE words.word = '[placeholder-type:string]' AND biwords.occurrences > [placeholder-type:numeric]",
            "ba": "The virtual table counts the occurrences of a specific second word in biword pairs from the 'biwords' table, where the first word matches a given word from the 'words' table. The query filters based on the specified word and ensures that the occurrences of the biword pair exceed a certain numeric threshold."
        },
        {
            "sample_id": 5728,
            "vt": "SELECT CAST(COUNT(CASE WHEN pages.words = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(pages.page) FROM pages WHERE pages.words > [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average of the number of words in Wikipedia pages for a specific language. It counts the number of pages that have a certain number of words, multiplies this count by a specified weight, and divides it by the total number of pages that exceed a certain word count. The placeholders represent the numeric values for the word count threshold, weight, and limit on the number of pages to consider."
        },
        {
            "sample_id": 5755,
            "vt": "SELECT COUNT(biwords.w1st) FROM biwords WHERE biwords.occurrences > [placeholder-type:numeric]",
            "ba": "The virtual table counts the occurrences of the first word in biword pairs from the 'biwords' table where the number of occurrences exceeds a specified threshold. The placeholder in the WHERE clause represents the minimum number of occurrences to filter the results."
        },
        {
            "sample_id": 5720,
            "vt": "SELECT words.word, words.occurrences FROM words INNER JOIN pages_words AS T2 ON T1.wid = T2.wid WHERE pages_words.pid = (SELECT pages.pid FROM pages WHERE title = 'Atomium') LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the words and their occurrences from the 'words' table that are associated with a specific Wikipedia page title. It uses an inner join with the 'pages_words' table to link words to their respective pages, filtering by the page ID of the page with the title 'Atomium'. The result is limited to a specified number of entries."
        },
        {
            "sample_id": 5769,
            "vt": "SELECT CAST(SUM(pages.words) AS FLOAT) * [placeholder-type:numeric] / SUM(pages_words.occurrences) FROM pages INNER JOIN pages_words AS T2 ON T1.pid = T2.pid WHERE pages.revision < [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average of the total number of words across Wikipedia pages in a specific language, adjusted by the occurrences of words on those pages. It sums the total words from the 'pages' table and multiplies it by a placeholder for a numeric value, then divides this by the total occurrences of words from the 'pages_words' table. The query also filters the results to include only those pages with a revision number less than a specified numeric placeholder."
        },
        {
            "sample_id": 5739,
            "vt": "SELECT biwords.occurrences FROM biwords WHERE biwords.w1st = [placeholder-type:numeric] AND biwords.w2nd = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the occurrences of biword pairs from the 'biwords' table based on specific word IDs. The placeholders represent the unique identifiers for the first and second words in the biword pair."
        },
        {
            "sample_id": 5724,
            "vt": "SELECT biwords.w1st, biwords.w2nd FROM biwords WHERE biwords.occurrences = (SELECT MAX(biwords.occurrences) FROM biwords)",
            "ba": "The virtual table retrieves the first and second words from the 'biwords' table that form the most frequently occurring pair in a specific language. The query uses a subquery to find the maximum occurrences of any biword pair, ensuring that only the pair with the highest count is selected."
        },
        {
            "sample_id": 5696,
            "vt": "SELECT biwords.w1st, biwords.w2nd FROM biwords WHERE biwords.occurrences = (SELECT MAX(biwords.occurrences) FROM biwords)",
            "ba": "The virtual table retrieves the first and second words from the 'biwords' table that form the most frequently occurring pair in a specific language. The query uses a subquery to find the maximum occurrences of any biword pair, ensuring that only the most common pairs are selected."
        },
        {
            "sample_id": 5716,
            "vt": "SELECT SUM(biwords.occurrences) FROM words INNER JOIN biwords AS T2 ON T1.wid = T2.w1st OR T1.wid = T2.w2nd WHERE biwords.w1st IN ((SELECT words.wid FROM words WHERE word = 'nombre') OR biwords.w2nd IN (SELECT words.wid FROM words WHERE word = 'nombre'))",
            "ba": "The virtual table calculates the total occurrences of biword pairs that include a specific word from the 'words' table. It does this by joining the 'words' table with the 'biwords' table, checking for occurrences where the first or second word in the biword pair matches the specified word. The result is a sum of all occurrences of these biword pairs."
        },
        {
            "sample_id": 5814,
            "vt": "SELECT pages_words.pid FROM words INNER JOIN pages_words AS T2 ON T1.wid = T2.wid WHERE words.word = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the page IDs from the 'pages_words' table that correspond to a specific word in the 'words' table. The placeholder in the WHERE clause represents the word being searched for."
        },
        {
            "sample_id": 5813,
            "vt": "SELECT COUNT(pages.lid) FROM pages WHERE pages.lid = [placeholder-type:numeric] AND pages.words > [placeholder-type:numeric] AND pages.revision > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of Wikipedia pages in a specific language that have a certain number of words and revisions. The placeholders represent the language ID, the minimum number of words, and the minimum revision number respectively."
        },
        {
            "sample_id": 5793,
            "vt": "SELECT words.word FROM words WHERE words.occurrences = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves words from the 'words' table that have a specific number of occurrences. The placeholder in the WHERE clause represents the number of times a word appears."
        },
        {
            "sample_id": 5796,
            "vt": "SELECT COUNT(words.wid) FROM words INNER JOIN biwords AS T2 ON T1.wid = T2.w1st INNER JOIN words AS T3 ON T3.wid = T2.w2nd WHERE words.word = '[placeholder-type:string]'",
            "ba": "The virtual table counts the occurrences of a specific word in the 'words' table by joining it with the 'biwords' table to find pairs of words that include the specified word. The placeholder represents the word being queried."
        },
        {
            "sample_id": 5708,
            "vt": "SELECT CAST(SUM(CASE WHEN pages.words >= [placeholder-type:numeric] THEN pages.words ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN pages.words >= [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM pages",
            "ba": "The virtual table calculates the average number of words per Wikipedia page in a specific language, considering only those pages that have a word count greater than or equal to a specified threshold. The placeholders represent numeric values for the word count threshold."
        },
        {
            "sample_id": 5711,
            "vt": "SELECT pages.title FROM pages INNER JOIN pages_words AS T2 ON T1.pid = T2.pid INNER JOIN words AS T3 ON T2.wid = T3.wid WHERE words.word = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the titles of Wikipedia pages that contain a specific word. It joins the 'pages' table with the 'pages_words' table to link pages with their corresponding words, and then further joins with the 'words' table to filter based on the specified word. The placeholder in the WHERE clause represents the word being searched for."
        },
        {
            "sample_id": 5721,
            "vt": "SELECT words.word FROM words WHERE words.occurrences = (SELECT MAX(words.occurrences) FROM words)",
            "ba": "The virtual table retrieves the word from the 'words' table that has the highest number of occurrences. The subquery identifies the maximum occurrences of any word in the 'words' table, and the main query selects the word that matches this maximum occurrence value."
        },
        {
            "sample_id": 5703,
            "vt": "SELECT words.word, words.word FROM words INNER JOIN biwords AS T2 ON T1.wid = T2.w1st INNER JOIN words AS T3 ON T3.wid = T2.w2nd WHERE biwords.occurrences = [placeholder-type:numeric]",
            "ba": "The virtual table describes the words that form biword pairs in a specific language, along with their occurrences. It retrieves the words from the 'words' table and joins it with the 'biwords' table to find pairs of words that appear together. The placeholder in the WHERE clause represents the number of times these biword pairs occur."
        },
        {
            "sample_id": 5713,
            "vt": "SELECT CASE WHEN COUNT(pages.pid) > [placeholder-type:numeric] THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END FROM pages INNER JOIN pages_words AS T2 ON T1.pid = T2.pid WHERE pages_words.wid = [placeholder-type:numeric] AND pages.title = '[placeholder-type:string]'",
            "ba": "The virtual table provides a conditional count of Wikipedia pages based on the number of occurrences of a specific word in the title of the page. It checks if the count of pages exceeds a specified numeric threshold and returns different string values based on this condition. The placeholders represent the numeric threshold, the word ID, and the title of the page."
        },
        {
            "sample_id": 5753,
            "vt": "SELECT CAST(COUNT(CASE WHEN pages.words > [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(pages.page) FROM langs INNER JOIN pages AS T2 ON T1.lid = T2.lid WHERE langs.lang = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of the number of pages in a specific language that contain more than a certain number of words. It does this by counting the pages that meet the criteria and multiplying by a specified factor, then dividing by the total number of pages in that language. The query joins the 'langs' and 'pages' tables to filter by the language name."
        },
        {
            "sample_id": 5790,
            "vt": "SELECT langs_words.wid FROM langs_words WHERE langs_words.occurrences = (SELECT MAX(langs_words.occurrences) FROM langs_words)",
            "ba": "The virtual table retrieves the word id from the 'langs_words' table that has the highest number of occurrences in a specific language. The subquery identifies the maximum occurrences of any word in the 'langs_words' table, and the main query selects the word id corresponding to that maximum occurrence."
        },
        {
            "sample_id": 5799,
            "vt": "SELECT pages.title FROM pages WHERE pages.pid = (SELECT pages.pid FROM pages_words WHERE wid = 174 ORDER BY occurrences DESC LIMIT 1)",
            "ba": "The virtual table retrieves the titles of Wikipedia pages from the 'pages' table that correspond to a specific page id. This page id is determined by a subquery that selects the page id from the 'pages_words' table, filtering for a specific word id and ordering the results by the number of occurrences in descending order, limiting the result to the top entry."
        },
        {
            "sample_id": 5785,
            "vt": "SELECT words.word, words.word FROM words INNER JOIN biwords AS T2 ON T1.wid = T2.w1st INNER JOIN words AS T3 ON T3.wid = T2.w2nd WHERE words.word = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves pairs of words that are biwords in a specific language, where the first word matches a given word. The query joins the 'words' table with the 'biwords' table to find the second word in each biword pair, filtering based on the specified first word."
        },
        {
            "sample_id": 5732,
            "vt": "SELECT pages_words.occurrences FROM pages_words WHERE pages.pid = (SELECT pages.pid FROM pages WHERE title = 'Llista de conflictes armats')",
            "ba": "The virtual table retrieves the occurrences of specific words from Wikipedia pages related to the Catalan language. It filters the results based on the page title, specifically looking for the page titled 'Llista de conflictes armats'. The inner query identifies the page ID associated with this title, which is then used to find the occurrences of words on that page."
        },
        {
            "sample_id": 5791,
            "vt": "SELECT biwords.w2nd FROM biwords WHERE biwords.occurrences = (SELECT MAX(biwords.occurrences) FROM biwords)",
            "ba": "The virtual table retrieves the second word from the biwords table that appears most frequently in the specified language. The query uses a subquery to find the maximum occurrences of any biword pair, ensuring that only the most common second word is selected."
        },
        {
            "sample_id": 5737,
            "vt": "SELECT words.occurrences FROM words WHERE words.wid = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the occurrences of a specific word from the 'words' table based on its unique word id. The placeholder in the WHERE clause represents the word id for which the occurrences are being queried."
        },
        {
            "sample_id": 5710,
            "vt": "SELECT pages.pid FROM pages WHERE pages.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the page IDs from the 'pages' table where the title of the Wikipedia page matches a specific pattern. The placeholder in the LIKE clause allows for flexible searching of titles based on user input."
        },
        {
            "sample_id": 5757,
            "vt": "SELECT COUNT(langs_words.wid) FROM langs_words WHERE langs_words.occurrences BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of unique word IDs from the 'langs_words' table where the occurrences of those words fall within a specified range. The placeholders represent the lower and upper limits of occurrences to filter the results accordingly."
        },
        {
            "sample_id": 5773,
            "vt": "SELECT pages.title FROM pages WHERE pages.lid = [placeholder-type:numeric] AND pages.words > [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of Wikipedia pages from the 'pages' table that are in a specific language and have a word count exceeding a certain number. The placeholders represent the language ID and the minimum word count required for the pages."
        },
        {
            "sample_id": 5750,
            "vt": "SELECT pages_words.occurrences FROM words INNER JOIN pages_words AS T2 ON T1.wid = T2.wid WHERE words.word = '[placeholder-type:string]' AND pages_words.pid = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the occurrences of a specific word on a particular Wikipedia page. It joins the 'words' table with the 'pages_words' table to access the occurrences of the word in the context of the specified page."
        },
        {
            "sample_id": 5726,
            "vt": "SELECT AVG(pages.words) FROM pages WHERE pages.title LIKE '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of words across Wikipedia pages that have titles matching a specific pattern. The placeholder in the LIKE clause represents the title pattern to be searched."
        },
        {
            "sample_id": 5774,
            "vt": "SELECT pages.words FROM pages WHERE pages.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the total number of different words from Wikipedia pages that have a specific title. The placeholder in the WHERE clause represents the title of the page being queried."
        },
        {
            "sample_id": 5723,
            "vt": "SELECT pages.title FROM pages WHERE pages.title = (SELECT MIN(pages.words) FROM pages)",
            "ba": "The virtual table retrieves the title of the Wikipedia page with the minimum number of words from the 'pages' table. The subquery identifies the minimum word count across all pages, and the main query selects the title corresponding to that minimum word count."
        },
        {
            "sample_id": 5781,
            "vt": "SELECT SUM(pages.words) FROM words INNER JOIN pages_words AS T2 ON T1.wid = T2.wid INNER JOIN pages AS T3 ON T2.pid = T3.pid WHERE words.word = '[placeholder-type:string]' AND pages_words.occurrences = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total number of words from the 'pages' table that are associated with a specific word from the 'words' table. It uses inner joins to connect the 'words', 'pages_words', and 'pages' tables, filtering results based on a specific word and the occurrences of that word in the pages."
        },
        {
            "sample_id": 5775,
            "vt": "SELECT CASE WHEN (SELECT pages.words FROM pages WHERE title = 'Asclepi') > (SELECT pages.words FROM pages WHERE title = 'Afluent') THEN '[placeholder-type:string]' ELSE '[placeholder-type:string]' END",
            "ba": "The virtual table compares the total number of different words in two specific Wikipedia pages, identified by their titles. It uses a CASE statement to determine which page has more words, returning a placeholder for the title of the page with the greater word count and another placeholder for the title of the page with the lesser word count."
        },
        {
            "sample_id": 5808,
            "vt": "SELECT COUNT(pages.lid) FROM pages WHERE pages.lid = [placeholder-type:numeric] AND pages.words > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of Wikipedia pages in a specific language that have a word count exceeding a certain threshold. The placeholders represent the language ID and the minimum word count required for the pages."
        },
        {
            "sample_id": 5806,
            "vt": "SELECT CAST(words.occurrences AS FLOAT) / (SELECT words.occurrences FROM biwords WHERE w1st = (SELECT wid FROM words WHERE word = 'a') AND w2nd = (SELECT wid FROM words WHERE word = 'decimal')) FROM biwords WHERE biwords.w1st = (SELECT words.wid FROM words WHERE word = 'a') AND biwords.w2nd = (SELECT words.wid FROM words WHERE word = 'base')",
            "ba": "The virtual table calculates the ratio of occurrences of a specific word to the occurrences of a biword pair in the context of a language. It retrieves the occurrences of the word 'a' and compares it to the occurrences of the biword pair 'a' and 'decimal', as well as 'a' and 'base'."
        }
    ],
    "world": [
        {
            "sample_id": 7876,
            "vt": "SELECT country.name FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE countrylanguage.language = '[placeholder-type:string]' AND countrylanguage.isofficial = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of countries from the 'country' table that have a specific official language. It uses an inner join with the 'countrylanguage' table to filter countries based on the specified language and whether it is an official language."
        },
        {
            "sample_id": 7908,
            "vt": "SELECT country.localname FROM city INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE city.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the local name of a country based on the name of a specific city. It joins the 'city' table with the 'country' table using the country code to ensure that the correct country is associated with the specified city. The placeholder in the WHERE clause represents the name of the city for which the local country name is being queried."
        },
        {
            "sample_id": 7902,
            "vt": "SELECT countrylanguage.language FROM city INNER JOIN CountryLanguage AS T2 ON T1.CountryCode = T2.CountryCode WHERE countrylanguage.isofficial = '[placeholder-type:string]' ORDER BY city.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the languages spoken in cities, specifically focusing on official languages. It joins the 'city' and 'countrylanguage' tables based on the country code, filtering for languages that are marked as official. The results are ordered by the population of the cities, allowing users to see which official languages are prevalent in more populated areas, with a limit on the number of results returned."
        },
        {
            "sample_id": 7841,
            "vt": "SELECT city.name FROM country INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE country.lifeexpectancy = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of cities from the 'city' table that are located in countries with a specific life expectancy. The query joins the 'country' table with the 'city' table based on the country code, filtering the results to only include cities from countries where the life expectancy matches a specified numeric value."
        },
        {
            "sample_id": 7868,
            "vt": "SELECT countrylanguage.language, countrylanguage.isofficial FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE country.indepyear = [placeholder-type:numeric] GROUP BY countrylanguage.language, countrylanguage.isofficial",
            "ba": "The virtual table provides a list of languages spoken in countries that gained independence in a specific year, along with information on whether each language is official. It combines data from the 'country' and 'countrylanguage' tables, filtering by the year of independence and grouping the results by language and its official status."
        },
        {
            "sample_id": 7897,
            "vt": "SELECT COUNT(DISTINCT T2.Language) FROM city INNER JOIN CountryLanguage AS T2 ON T1.CountryCode = T2.CountryCode WHERE city.district = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct languages spoken in cities located in a specific district. It joins the 'city' table with the 'countrylanguage' table based on the country code, filtering the results to only include cities from the specified district."
        },
        {
            "sample_id": 7849,
            "vt": "SELECT city.district FROM country INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE country.headofstate = '[placeholder-type:string]'",
            "ba": "The virtual table describes the districts of cities from the 'city' table that are associated with countries where the head of state matches a specified name. The placeholder in the WHERE clause represents the head of state's name."
        },
        {
            "sample_id": 7880,
            "vt": "SELECT country.name FROM country INNER JOIN City AS T2 ON T1.Code = T2.CountryCode ORDER BY city.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table that are associated with cities in the 'city' table. The results are ordered by the population of the cities, and the number of results returned is limited by a placeholder for numeric values."
        },
        {
            "sample_id": 7852,
            "vt": "SELECT COUNT(country.governmentform = '[placeholder-type:string]') - COUNT(country.governmentform = '[placeholder-type:string]') FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE countrylanguage.language = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of countries with a specific government form and language. It uses a join between the 'country' and 'countrylanguage' tables to filter countries based on the specified language and government form. The placeholders represent the government form and language to be queried."
        },
        {
            "sample_id": 7850,
            "vt": "SELECT country.headofstate FROM country INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE city.district = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the head of state for countries that have cities located in a specific district. It joins the 'country' table with the 'city' table based on the country code, filtering the results to only include cities that belong to the specified district."
        },
        {
            "sample_id": 7824,
            "vt": "SELECT COUNT(city.id) FROM city WHERE city.district = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cities located in a specific district from the 'city' table. The placeholder in the WHERE clause represents the name of the district."
        },
        {
            "sample_id": 7840,
            "vt": "SELECT country.code FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE countrylanguage.language = '[placeholder-type:string]' AND countrylanguage.isofficial = '[placeholder-type:string]' ORDER BY country.capital LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique country codes from the 'country' table by joining it with the 'countrylanguage' table. It filters the results based on a specific language and whether that language is official in the country. The results are ordered by the capital of the country and limited to a specified number of entries."
        },
        {
            "sample_id": 7831,
            "vt": "SELECT countrylanguage.language FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE country.region = '[placeholder-type:string]' AND countrylanguage.percentage > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the languages spoken in countries that belong to a specific region and have a certain percentage of language use. It joins the 'country' table with the 'countrylanguage' table to filter the results based on the region and the percentage of language usage."
        },
        {
            "sample_id": 7834,
            "vt": "SELECT country.capital, countrylanguage.language FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode INNER JOIN City AS T3 ON T1.Code = T3.CountryCode ORDER BY country.lifeexpectancy LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of country capitals along with their official languages. It combines data from the 'country', 'countrylanguage', and 'city' tables, ensuring that the results are ordered by the life expectancy of the countries. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return."
        },
        {
            "sample_id": 7826,
            "vt": "SELECT country.capital, city.population FROM country INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about the capital city and its population for a specific country. It combines data from the 'country' and 'city' tables, linking them through the country code. The placeholder in the WHERE clause represents the name of the country being queried."
        },
        {
            "sample_id": 7844,
            "vt": "SELECT countrylanguage.language FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE country.population < [placeholder-type:numeric]",
            "ba": "The virtual table describes the languages spoken in countries with a population less than a specified number. It retrieves the language information from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the population threshold for filtering countries."
        },
        {
            "sample_id": 7887,
            "vt": "SELECT AVG(country.lifeexpectancy) FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE countrylanguage.language = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average life expectancy of countries that speak a specific language. It joins the 'country' table with the 'countrylanguage' table to filter countries based on the specified language, using a placeholder for the language name."
        },
        {
            "sample_id": 7853,
            "vt": "SELECT country.name FROM country WHERE country.indepyear = [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table that declared independence in a specific year. The placeholder in the WHERE clause represents the year of independence."
        },
        {
            "sample_id": 7833,
            "vt": "SELECT city.name, country.code, country.lifeexpectancy FROM country INNER JOIN City AS T2 ON T1.Code = T2.CountryCode ORDER BY city.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of cities, their corresponding country codes, and the life expectancy of those countries. It retrieves this information by joining the 'country' and 'city' tables based on the country code, ensuring that only cities belonging to the specified countries are included. The results are ordered by the population of the cities, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 7819,
            "vt": "SELECT country.name FROM country ORDER BY country.lifeexpectancy LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table, ordered by their life expectancy. The placeholder in the LIMIT clause allows the user to specify how many country names they want to retrieve."
        },
        {
            "sample_id": 7851,
            "vt": "SELECT CAST(SUM(CASE WHEN countrylanguage.language = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(country.code) FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE country.gnp > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the weighted average of a specific language's usage in countries with a GNP greater than a specified value. It sums the percentage of the language used in those countries, adjusting it by a given factor, and divides by the count of countries to find the average."
        },
        {
            "sample_id": 7899,
            "vt": "SELECT COUNT(DISTINCT T1.Name) FROM city INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE country.headofstate = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct names of cities from the 'city' table that are associated with a specific country, where the head of state of that country matches a given name. The placeholder in the WHERE clause represents the head of state's name."
        },
        {
            "sample_id": 7829,
            "vt": "SELECT country.name, countrylanguage.language FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE country.continent = '[placeholder-type:string]' AND countrylanguage.isofficial = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of countries and their official languages from the 'country' and 'countrylanguage' tables. It filters the results based on a specific continent and whether the language is official, using placeholders for both criteria."
        },
        {
            "sample_id": 7867,
            "vt": "SELECT city.name FROM country INNER JOIN City AS T2 ON T1.Code = T2.CountryCode ORDER BY country.lifeexpectancy LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of cities from the 'city' table that are associated with countries in the 'country' table. The results are ordered by the life expectancy of the countries, and the number of cities returned is limited by a specified numeric placeholder."
        },
        {
            "sample_id": 7864,
            "vt": "SELECT country.headofstate FROM country INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE city.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the head of state for a specific country based on the city's name. It joins the 'country' table with the 'city' table using the country code to filter the results."
        },
        {
            "sample_id": 7866,
            "vt": "SELECT city.name FROM country INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE country.name = '[placeholder-type:string]' ORDER BY city.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of cities from the 'city' table that belong to a specific country. It joins the 'country' table to filter cities based on the country's name and orders them by population, allowing the user to limit the number of results returned."
        },
        {
            "sample_id": 7889,
            "vt": "SELECT city.district FROM city WHERE city.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the districts of cities from the 'city' table based on a specific city name. The placeholder in the WHERE clause represents the name of the city being queried."
        },
        {
            "sample_id": 7882,
            "vt": "SELECT country.gnp FROM city INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code ORDER BY city.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the Gross National Product (GNP) of countries based on the population of their cities. It joins the 'city' table with the 'country' table using the country code to associate each city with its respective country. The results are ordered by the population of the cities, allowing users to see the GNP of countries with the most populous cities, limited to a specified number of results."
        },
        {
            "sample_id": 7828,
            "vt": "SELECT country.name, country.capital, countrylanguage.language FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode INNER JOIN City AS T3 ON T1.Code = T3.CountryCode WHERE countrylanguage.isofficial = '[placeholder-type:string]' ORDER BY country.lifeexpectancy LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of countries along with their capital cities and official languages. It combines data from the 'country', 'countrylanguage', and 'city' tables. The query filters for countries where the specified language is official and orders the results by life expectancy, limiting the number of results based on a numeric placeholder."
        },
        {
            "sample_id": 7869,
            "vt": "SELECT country.capital FROM country INNER JOIN City AS T2 ON T1.Code = T2.CountryCode ORDER BY country.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the capital cities of countries from the 'country' table, joining it with the 'city' table to match the country codes. The results are ordered by the population of the countries, and a limit is applied to restrict the number of returned records based on a specified numeric value."
        },
        {
            "sample_id": 7859,
            "vt": "SELECT countrylanguage.language FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE country.name = '[placeholder-type:string]' AND countrylanguage.isofficial = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the languages spoken in a specific country, focusing on those that are officially recognized. It joins the 'country' table with the 'countrylanguage' table to filter results based on the country's name and the official status of the language."
        },
        {
            "sample_id": 7832,
            "vt": "SELECT countrylanguage.language FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE country.region = '[placeholder-type:string]' AND countrylanguage.percentage > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the languages spoken in countries that belong to a specific region and have a certain percentage of language use. It joins the 'country' table with the 'countrylanguage' table to filter the results based on the region and the percentage of language usage."
        },
        {
            "sample_id": 7855,
            "vt": "SELECT country.name FROM country WHERE country.continent = '[placeholder-type:string]' ORDER BY country.gnp LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table that are located in a specific continent. The results are ordered by the Gross National Product (GNP) of each country, and the number of results returned is limited by a placeholder for numeric values."
        },
        {
            "sample_id": 7861,
            "vt": "SELECT country.governmentform FROM country INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE city.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the government form of a country based on the name of a specific city. It joins the 'country' table with the 'city' table using the country code to filter the results according to the specified city name."
        },
        {
            "sample_id": 7879,
            "vt": "SELECT countrylanguage.language FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the languages spoken in a specific country by retrieving data from the 'country' and 'countrylanguage' tables. The placeholder in the WHERE clause represents the name of the country for which the languages are being queried."
        },
        {
            "sample_id": 7847,
            "vt": "SELECT SUM(CASE WHEN country.name = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode",
            "ba": "The virtual table calculates the total population of a specific country by summing the population of its cities and considering the official languages spoken in that country. The placeholders represent the country name and the population values."
        },
        {
            "sample_id": 7842,
            "vt": "SELECT country.headofstate FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE countrylanguage.language = '[placeholder-type:string]' ORDER BY countrylanguage.percentage LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the head of state for countries where a specific language is spoken. It joins the 'country' table with the 'countrylanguage' table to filter countries based on the language specified. The results are ordered by the percentage of language use, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 7891,
            "vt": "SELECT city.district FROM city WHERE city.population = [placeholder-type:numeric]",
            "ba": "The virtual table describes the districts of cities from the 'city' table that have a specific population size. The placeholder in the WHERE clause represents the population number."
        },
        {
            "sample_id": 7830,
            "vt": "SELECT country.name FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE countrylanguage.language = '[placeholder-type:string]' AND countrylanguage.isofficial = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of countries from the 'country' table that have a specific official language. It joins the 'country' table with the 'countrylanguage' table to filter based on the language and its official status. The placeholders represent the language name and whether it is official, along with a limit on the number of results returned."
        },
        {
            "sample_id": 7848,
            "vt": "SELECT countrylanguage.language FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the languages spoken in a specific country by retrieving data from the 'country' and 'countrylanguage' tables. The placeholder in the WHERE clause represents the name of the country for which the languages are being queried."
        },
        {
            "sample_id": 7871,
            "vt": "SELECT AVG(country.gnp) FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE countrylanguage.language = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average Gross National Product (GNP) of countries that speak a specific language. It joins the 'country' table with the 'countrylanguage' table to filter countries based on the specified language, using a placeholder for the language name."
        },
        {
            "sample_id": 7894,
            "vt": "SELECT country.indepyear FROM country WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the year a specific country declared its independence from the 'country' table. The placeholder in the WHERE clause represents the name of the country for which the independence year is being queried."
        },
        {
            "sample_id": 7856,
            "vt": "SELECT COUNT(city.id) FROM city WHERE city.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of cities from the 'city' table that match a specific city name. The placeholder in the WHERE clause represents the name of the city being queried."
        },
        {
            "sample_id": 7822,
            "vt": "SELECT countrylanguage.language FROM countrylanguage WHERE countrylanguage.countrycode = '[placeholder-type:string]'",
            "ba": "The virtual table describes the languages spoken in a specific country from the 'countrylanguage' table. The placeholder in the WHERE clause represents the unique country code for which the languages are being queried."
        },
        {
            "sample_id": 7863,
            "vt": "SELECT countrylanguage.language FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE country.continent = '[placeholder-type:string]'",
            "ba": "The virtual table describes the languages spoken in countries that are located in a specific continent. The query retrieves the language information from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the continent's name."
        },
        {
            "sample_id": 7896,
            "vt": "SELECT AVG(country.surfacearea) FROM country",
            "ba": "The virtual table calculates the average surface area of all countries from the 'country' table. This provides insight into the general size of countries within the dataset."
        },
        {
            "sample_id": 7890,
            "vt": "SELECT city.name FROM city ORDER BY city.population LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of cities from the 'city' table, ordered by their population in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of city names to retrieve."
        },
        {
            "sample_id": 7892,
            "vt": "SELECT country.name FROM country ORDER BY country.surfacearea LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries from the 'country' table, ordered by their surface area. The placeholder in the LIMIT clause allows the user to specify how many country names they want to retrieve."
        },
        {
            "sample_id": 7915,
            "vt": "SELECT CAST(SUM(CASE WHEN city.district = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM city INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE country.governmentform = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted average of the population of cities in a specific district, filtered by the government form of the country. It sums the populations of cities in the specified district and divides it by the total number of cities, adjusting the result by a specified multiplier. The placeholders represent the district name, a numeric value for the population, and the government form of the country."
        },
        {
            "sample_id": 7895,
            "vt": "SELECT COUNT(*) FROM country WHERE country.gnp = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of countries from the 'country' table that have a specific Gross National Product (GNP). The placeholder in the query represents the GNP value to filter the results accordingly."
        },
        {
            "sample_id": 7912,
            "vt": "SELECT country.name, countrylanguage.language FROM countrylanguage INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE country.indepyear BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of countries and their corresponding languages from the 'country' and 'countrylanguage' tables. It filters the results to include only those countries that gained independence within a specified range of years, represented by placeholders for numeric values."
        },
        {
            "sample_id": 7857,
            "vt": "SELECT country.localname FROM country WHERE country.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the local name of a country from the 'country' table based on the specified country name. The placeholder in the WHERE clause represents the name of the country being queried."
        },
        {
            "sample_id": 7907,
            "vt": "SELECT country.gnp FROM city INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE city.district = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the Gross National Product (GNP) of countries based on the district of cities. It joins the 'city' table with the 'country' table using the country code to filter results according to a specified district. The placeholders allow users to specify the district name and limit the number of results returned."
        },
        {
            "sample_id": 7878,
            "vt": "SELECT countrylanguage.percentage FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE country.name = '[placeholder-type:string]' AND countrylanguage.language = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the percentage of language use from the 'countrylanguage' table for a specific country and language. It joins the 'country' table to filter by the country's name and the 'countrylanguage' table to filter by the specified language."
        },
        {
            "sample_id": 7886,
            "vt": "SELECT city.name FROM city INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE country.localname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of cities from the 'city' table that are located in a specific country, identified by its local name. The query uses an INNER JOIN to connect the 'city' table with the 'country' table based on the country code, ensuring that only cities from the specified country are selected."
        },
        {
            "sample_id": 7854,
            "vt": "SELECT country.name FROM country WHERE country.continent = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of countries from the 'country' table that are located in a specific continent. The placeholder in the WHERE clause represents the continent's name."
        },
        {
            "sample_id": 7820,
            "vt": "SELECT country.name FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE countrylanguage.language = '[placeholder-type:string]' AND countrylanguage.isofficial = '[placeholder-type:string]' LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of countries that have a specific official language. It retrieves data from the 'country' table and joins it with the 'countrylanguage' table to filter based on the language and its official status. The placeholders represent the language name and whether it is official, along with a limit on the number of results returned."
        },
        {
            "sample_id": 7904,
            "vt": "SELECT country.name FROM countrylanguage INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE countrylanguage.isofficial = '[placeholder-type:string]' AND countrylanguage.language = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of countries from the 'country' table that have a specific official language, as indicated by the 'countrylanguage' table. The placeholders in the WHERE clause represent whether the language is official and the specific language being queried."
        },
        {
            "sample_id": 7845,
            "vt": "SELECT countrylanguage.language FROM country INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE country.name = '[placeholder-type:string]' AND countrylanguage.isofficial = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the languages spoken in a specific country, focusing on those that are officially recognized. It joins the 'country' table with the 'countrylanguage' table to filter results based on the country's name and the official status of the language."
        }
    ],
    "video_games": [
        {
            "sample_id": 3465,
            "vt": "SELECT DISTINCT game_platform.platform_id FROM game_platform WHERE game_platform.release_year = [placeholder-type:numeric]",
            "ba": "The virtual table lists unique identifiers of game platforms from the 'game_platform' table that were released in a specific year. The placeholder in the WHERE clause represents the release year of the games."
        },
        {
            "sample_id": 3417,
            "vt": "SELECT publisher.publisher_name FROM game_platform INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id WHERE game_platform.release_year = [placeholder-type:numeric] GROUP BY publisher.publisher_name ORDER BY COUNT(DISTINCT T2.game_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of publishers from the 'publisher' table who have published games on specific platforms in a given release year. The query joins the 'game_platform' and 'game_publisher' tables to connect games with their publishers, filtering by the release year and grouping the results by publisher name. The placeholders represent the release year and the limit on the number of publishers to display."
        },
        {
            "sample_id": 3492,
            "vt": "SELECT game.game_name FROM game_platform INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id INNER JOIN game AS T3 ON T2.game_id = T3.id INNER JOIN publisher AS T4 ON T2.publisher_id = T4.id WHERE publisher.publisher_name = '[placeholder-type:string]' AND game_platform.release_year = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of games from the 'game' table that were published by a specific publisher and released in a particular year. The query joins multiple tables to connect games with their publishers and platforms, filtering results based on the publisher's name and the release year."
        },
        {
            "sample_id": 3478,
            "vt": "SELECT DISTINCT genre.genre_name FROM game INNER JOIN genre AS T2 ON T1.genre_id = T2.id INNER JOIN game_publisher AS T3 ON T1.id = T3.game_id WHERE game_publisher.publisher_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct game genres from the 'genre' table that are associated with games published by a specific publisher. The placeholder in the WHERE clause represents the unique identifier of the publisher."
        },
        {
            "sample_id": 3386,
            "vt": "SELECT SUM(region_sales.num_sales * [placeholder-type:numeric]) FROM region_sales INNER JOIN region AS T2 ON T1.region_id = T2.id INNER JOIN game_platform AS T3 ON T1.game_platform_id = T3.id INNER JOIN platform AS T4 ON T3.platform_id = T4.id WHERE region.region_name = '[placeholder-type:string]' AND platform.platform_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of game sales in a specific region for a specific platform. It aggregates the sales data by summing the number of sales multiplied by a factor, which can be adjusted using a placeholder for numeric values. The query joins multiple tables to connect region information with game platform details, ensuring that the results are filtered based on the specified region and platform names, both represented by string placeholders."
        },
        {
            "sample_id": 3378,
            "vt": "SELECT publisher.id FROM publisher WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier of a publisher from the 'publisher' table based on the specified publisher's name. The placeholder in the WHERE clause represents the name of the publisher being queried."
        },
        {
            "sample_id": 3360,
            "vt": "SELECT region_sales.num_sales * [placeholder-type:numeric] FROM region_sales WHERE region_sales.region_id = [placeholder-type:numeric] AND region_sales.game_platform_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total number of sales for a specific game platform in a specific region. The number of sales is derived from the 'num_sales' column in the 'region_sales' table, which is multiplied by a placeholder to represent the scaling factor for sales. The placeholders in the WHERE clause represent the unique identifiers for the region and the game platform."
        },
        {
            "sample_id": 3395,
            "vt": "SELECT COUNT(game_platform.id) FROM game_platform WHERE game_platform.release_year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of game platform records from the 'game_platform' table that were released in a specific year. The placeholder in the WHERE clause represents the release year of the games."
        },
        {
            "sample_id": 3322,
            "vt": "SELECT SUM(region_sales.num_sales) * [placeholder-type:numeric] / [placeholder-type:numeric] FROM region_sales INNER JOIN game_platform AS T2 ON T1.game_platform_id = T2.id INNER JOIN platform AS T3 ON T2.platform_id = T3.id WHERE platform.platform_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of sales for a specific game platform by summing the sales figures from the 'region_sales' table. It joins the 'region_sales' table with the 'game_platform' table to link sales data with the corresponding game platform, and further joins with the 'platform' table to filter results based on the platform's name. The placeholders in the query allow for dynamic input of numeric values for scaling the sales figures and for specifying the platform name."
        },
        {
            "sample_id": 3491,
            "vt": "SELECT region_sales.game_platform_id, region.region_name FROM region INNER JOIN region_sales AS T2 ON T1.id = T2.region_id WHERE region_sales.num_sales * [placeholder-type:numeric] <= [placeholder-type:numeric]",
            "ba": "The virtual table provides a view of the game platforms and their corresponding regions where the sales data is filtered based on a specified sales threshold. The placeholders represent the numeric values for the sales multiplier and the sales limit."
        },
        {
            "sample_id": 3502,
            "vt": "SELECT COUNT(game_publisher.game_id) FROM platform INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN game_publisher AS T3 ON T2.game_publisher_id = T3.id WHERE platform.platform_name = '[placeholder-type:string]' AND game_platform.release_year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of games published on a specific platform in a given release year. It joins the 'platform', 'game_platform', and 'game_publisher' tables to filter the results based on the platform name and the release year of the games."
        },
        {
            "sample_id": 3358,
            "vt": "SELECT game_platform.game_publisher_id FROM game_platform WHERE game_platform.platform_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifier of the game publisher associated with a specific game platform from the 'game_platform' table. The placeholder in the WHERE clause represents the platform's ID."
        },
        {
            "sample_id": 3331,
            "vt": "SELECT T.game_platform_id FROM (SELECT region_sales.game_platform_id, MAX(region_sales.num_sales) FROM region AS T1 INNER JOIN region_sales AS T2 ON T1.id = T2.region_id WHERE T1.region_name = 'Japan') AS t",
            "ba": "The virtual table identifies the game platform ID that has the highest number of sales in a specific region, which in this case is Japan. It does this by first selecting the game platform IDs and their corresponding maximum sales from the region_sales table, filtered by the region name. The result is a list of game platform IDs that represent the most popular platforms in Japan based on sales data."
        },
        {
            "sample_id": 3342,
            "vt": "SELECT CAST(COUNT(CASE WHEN publisher.publisher_name = '[placeholder-type:string]' THEN game_publisher.game_id ELSE NULL END) AS FLOAT) / COUNT(CASE WHEN publisher.publisher_name = '[placeholder-type:string]' THEN game_publisher.game_id ELSE NULL END) FROM publisher INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id",
            "ba": "The virtual table calculates the proportion of games published by a specific publisher from the 'publisher' and 'game_publisher' tables. It counts the number of games associated with the specified publisher and divides it by the total count of games published by that publisher. The placeholders in the query represent the publisher's name, allowing users to specify which publisher they are interested in."
        },
        {
            "sample_id": 3469,
            "vt": "SELECT SUM(CASE WHEN region.region_name = '[placeholder-type:string]' THEN region_sales.num_sales ELSE [placeholder-type:numeric] END) FROM region_sales INNER JOIN region AS T2 ON T1.region_id = T2.id",
            "ba": "The virtual table calculates the total number of sales for a specific region by summing the sales figures from the 'region_sales' table. It uses a conditional statement to check if the region name matches a specified value, and if it does, it includes the sales number; otherwise, it substitutes a placeholder for numeric values. This allows users to analyze sales performance in different regions based on their preferences."
        },
        {
            "sample_id": 3495,
            "vt": "SELECT DISTINCT region.region_name FROM region INNER JOIN region_sales AS T2 ON T1.id = T2.region_id ORDER BY region_sales.num_sales LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct region names from the 'region' table, filtered by their sales data in the 'region_sales' table. It joins these two tables on the region ID and orders the results based on the number of sales, limiting the output to a specified number of regions."
        },
        {
            "sample_id": 3445,
            "vt": "SELECT SUM(region_sales.num_sales * [placeholder-type:numeric]) / COUNT(platform.id) FROM platform INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN region_sales AS T3 ON T2.id = T3.game_platform_id WHERE platform.platform_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average number of sales for a specific game platform by summing the total sales from the 'region_sales' table and dividing it by the count of platforms. The placeholder in the WHERE clause represents the name of the platform being queried."
        },
        {
            "sample_id": 3392,
            "vt": "SELECT platform.platform_name FROM game INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN game_platform AS T3 ON T2.id = T3.game_publisher_id INNER JOIN platform AS T4 ON T3.platform_id = T4.id WHERE game.game_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of platforms on which a specific game is available. It retrieves the platform names by joining the 'game', 'game_publisher', 'game_platform', and 'platform' tables. The placeholder in the WHERE clause represents the name of the game being queried."
        },
        {
            "sample_id": 3307,
            "vt": "SELECT (SUM(CASE WHEN region_sales.game_platform_id = [placeholder-type:numeric] THEN region_sales.num_sales ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN region_sales.game_platform_id = [placeholder-type:numeric] THEN region_sales.num_sales ELSE [placeholder-type:numeric] END)) * [placeholder-type:numeric] FROM region_sales WHERE region_sales.region_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the difference in total sales for a specific game platform in a given region. It uses conditional aggregation to sum the number of sales based on the game platform ID and applies a multiplier to the result. The placeholders represent the game platform ID, the region ID, and the numeric values for calculations."
        },
        {
            "sample_id": 3389,
            "vt": "SELECT COUNT(game_platform.id) FROM game_platform INNER JOIN platform AS T2 ON T1.platform_id = T2.id WHERE platform.platform_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of game platforms associated with a specific platform name from the 'game_platform' table. It joins the 'game_platform' table with the 'platform' table to filter the results based on the platform name provided by the user."
        },
        {
            "sample_id": 3455,
            "vt": "SELECT game.game_name FROM game_platform INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id INNER JOIN game AS T3 ON T2.game_id = T3.id WHERE game_platform.release_year = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of games released in a specific year. It retrieves data from the 'game' table, which contains the game names, and joins it with the 'game_platform' and 'game_publisher' tables to filter the results based on the release year. The placeholder in the WHERE clause represents the year of release."
        },
        {
            "sample_id": 3418,
            "vt": "SELECT COUNT(game_publisher.publisher_id) FROM game INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id WHERE game.game_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of publishers associated with a specific game from the 'game' table. It uses an inner join with the 'game_publisher' table to link games to their respective publishers based on the game's unique identifier. The placeholder in the WHERE clause represents the name of the game for which the publisher count is being queried."
        },
        {
            "sample_id": 3463,
            "vt": "SELECT region_sales.game_platform_id FROM region_sales WHERE region_sales.region_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the game platform identifiers from the 'region_sales' table for a specific region. The placeholder in the WHERE clause represents the unique identifier of the region."
        },
        {
            "sample_id": 3436,
            "vt": "SELECT game.game_name FROM game INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN game_platform AS T3 ON T2.id = T3.game_publisher_id INNER JOIN region_sales AS T4 ON T3.id = T4.game_platform_id INNER JOIN region AS T5 ON T4.region_id = T5.id WHERE region.region_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of games from the 'game' table that are associated with a specific region. It joins multiple tables to gather relevant information, including the game publisher and platform details, as well as the sales data in that region. The placeholder in the WHERE clause represents the name of the region being queried."
        },
        {
            "sample_id": 3420,
            "vt": "SELECT COUNT(game.id) FROM publisher INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id INNER JOIN game AS T3 ON T2.game_id = T3.id INNER JOIN genre AS T4 ON T3.genre_id = T4.id WHERE genre.genre_name = '[placeholder-type:string]' AND publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of games published by a specific publisher within a specific genre. It joins the 'publisher', 'game_publisher', 'game', and 'genre' tables to filter the results based on the genre name and publisher name provided as placeholders."
        },
        {
            "sample_id": 3459,
            "vt": "SELECT T.publisher_name FROM (SELECT publisher.publisher_name, COUNT(DISTINCT T1.game_id) FROM game_publisher AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id GROUP BY T2.publisher_name ORDER BY COUNT(DISTINCT T1.game_id) DESC LIMIT 1) AS t",
            "ba": "The virtual table identifies the publisher that has published the highest number of distinct games. It does this by joining the 'game_publisher' table with the 'publisher' table to count the unique games associated with each publisher. The result is ordered in descending order based on the count of distinct games, and only the top publisher is selected."
        },
        {
            "sample_id": 3320,
            "vt": "SELECT COUNT(T.publisher_name) FROM (SELECT publisher.publisher_name, COUNT(DISTINCT T1.id) FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id INNER JOIN genre AS T4 ON T1.genre_id = T4.id WHERE T4.genre_name = 'Puzzle' GROUP BY T3.publisher_name HAVING COUNT(DISTINCT T1.id) > 3) AS t",
            "ba": "The virtual table counts the number of publishers that have published more than three distinct games in the 'Puzzle' genre. It does this by first joining the 'game', 'game_publisher', 'publisher', and 'genre' tables to filter for games in the specified genre. Then, it groups the results by publisher name and counts the distinct games for each publisher. Finally, it counts how many publishers meet the criteria of having published more than three games."
        },
        {
            "sample_id": 3477,
            "vt": "SELECT COUNT(game.id) FROM game INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE genre.genre_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of games from the 'game' table that belong to a specific genre. It joins the 'game' table with the 'genre' table to filter the results based on the genre name provided by the user."
        },
        {
            "sample_id": 3377,
            "vt": "SELECT SUM(region_sales.num_sales) * [placeholder-type:numeric] FROM region_sales WHERE region_sales.game_platform_id = [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total number of sales for a specific game platform in a particular region. The placeholder in the SUM function allows for scaling the sales figure, while the WHERE clause filters the results based on the unique identifier of the game platform."
        },
        {
            "sample_id": 3444,
            "vt": "SELECT game.game_name FROM game INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN game_platform AS T3 ON T2.id = T3.game_publisher_id WHERE game_platform.release_year = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of games from the 'game' table that were released in a specific year. It joins the 'game' table with the 'game_publisher' table to associate each game with its publisher, and then further joins with the 'game_platform' table to filter the results based on the release year. The placeholder in the WHERE clause represents the release year of the games."
        },
        {
            "sample_id": 3434,
            "vt": "SELECT game.game_name FROM publisher INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id INNER JOIN game AS T3 ON T2.game_id = T3.id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of games published by a specific publisher. It retrieves the game names from the 'game' table, joining it with the 'game_publisher' table to link games to their publishers, and filtering the results based on the publisher's name provided as a placeholder."
        },
        {
            "sample_id": 3468,
            "vt": "SELECT game_platform.id FROM region_sales INNER JOIN game_platform AS T2 ON T1.game_platform_id = T2.id WHERE region_sales.region_id = [placeholder-type:numeric]",
            "ba": "The virtual table identifies the unique identifiers of game platforms from the 'region_sales' table, which records sales data for different regions. It joins with the 'game_platform' table to access additional details about the platforms associated with the sales. The placeholder in the WHERE clause represents a specific region's identifier, allowing users to filter results based on the region of interest."
        },
        {
            "sample_id": 3350,
            "vt": "SELECT COUNT(game_platform.game_publisher_id) FROM region INNER JOIN region_sales AS T2 ON T1.id = T2.region_id INNER JOIN game_platform AS T3 ON T2.game_platform_id = T3.id INNER JOIN platform AS T4 ON T3.platform_id = T4.id WHERE platform.platform_name = '[placeholder-type:string]' AND game_platform.release_year = [placeholder-type:numeric] AND region.region_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of game publishers associated with a specific platform in a given region for a particular release year. It combines data from multiple tables including region, region_sales, game_platform, and platform to filter results based on the platform name, release year, and region name."
        },
        {
            "sample_id": 3446,
            "vt": "SELECT CAST(COUNT(CASE WHEN publisher.publisher_name = '[placeholder-type:string]' THEN game_publisher.game_id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(game_publisher.game_id) FROM publisher INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id",
            "ba": "The virtual table calculates the proportion of games published by a specific publisher relative to the total number of games published, adjusted by a specified factor. It uses a conditional count to determine how many games belong to the specified publisher and divides this by the total count of games published, multiplying the result by a numeric placeholder for scaling purposes."
        },
        {
            "sample_id": 3471,
            "vt": "SELECT DISTINCT platform.platform_name FROM game_platform INNER JOIN platform AS T2 ON T1.platform_id = T2.id WHERE game_platform.release_year = [placeholder-type:numeric]",
            "ba": "The virtual table lists the distinct names of platforms from the 'platform' table that have games released in a specific year. The placeholder in the WHERE clause represents the release year of the games."
        },
        {
            "sample_id": 3457,
            "vt": "SELECT DISTINCT game_platform.release_year FROM region INNER JOIN region_sales AS T2 ON T1.id = T2.region_id INNER JOIN game_platform AS T3 ON T2.game_platform_id = T3.id WHERE region_sales.num_sales * [placeholder-type:numeric] > [placeholder-type:numeric] AND region.region_name = '[placeholder-type:string]'",
            "ba": "The virtual table provides a list of distinct release years for games based on their sales performance in a specific region. It combines data from the 'region', 'region_sales', and 'game_platform' tables to filter the results according to the number of sales and the specified region name."
        },
        {
            "sample_id": 3403,
            "vt": "SELECT game.game_name FROM game_platform INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id INNER JOIN game AS T3 ON T2.game_id = T3.id WHERE game_platform.release_year = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of games released in a specific year. It retrieves data from the 'game' table, which contains the game names, and joins it with the 'game_platform' and 'game_publisher' tables to filter the results based on the release year. The placeholder in the WHERE clause represents the year of release."
        },
        {
            "sample_id": 3394,
            "vt": "SELECT game.game_name FROM game ORDER BY LENGTH(game.game_name) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of games from the 'game' table, ordered by the length of their names. The placeholder in the LIMIT clause allows the user to specify how many game names they want to retrieve."
        },
        {
            "sample_id": 3506,
            "vt": "SELECT CAST(COUNT(CASE WHEN game_platform.release_year = [placeholder-type:numeric] THEN game_publisher.game_id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(game_publisher.game_id) FROM platform INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN game_publisher AS T3 ON T2.game_publisher_id = T3.id WHERE platform.platform_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of games released in a specific year on a given platform, adjusted by a sales multiplier. It counts the number of games published in that year and divides it by the total number of games published on that platform, then multiplies the result by a specified numeric value. The placeholders represent the release year, the sales multiplier, and the platform name."
        },
        {
            "sample_id": 3430,
            "vt": "SELECT region_sales.game_platform_id, SUM(region_sales.num_sales) * [placeholder-type:numeric] FROM region_sales GROUP BY region_sales.game_platform_id ORDER BY SUM(region_sales.num_sales) * [placeholder-type:numeric] LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table summarizes the total sales of games by platform in different regions. It calculates the total number of sales for each game platform by summing the sales figures from the 'region_sales' table, multiplying the result by a placeholder for numeric values to adjust the sales figures, and then orders the platforms by their total sales in descending order. The query also limits the results to a specified number of platforms using another placeholder for numeric values."
        },
        {
            "sample_id": 3311,
            "vt": "SELECT publisher.publisher_name FROM game INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id WHERE game.game_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of publishers for a specific game from the 'game' table. It joins the 'game' table with the 'game_publisher' table to link games with their respective publishers, and then it further joins with the 'publisher' table to retrieve the publisher's name. The placeholder in the WHERE clause represents the name of the game being queried."
        },
        {
            "sample_id": 3376,
            "vt": "SELECT game.genre_id FROM game WHERE game.game_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the genre identifier of a specific game from the 'game' table based on the game's name. The placeholder in the WHERE clause represents the name of the game being queried."
        },
        {
            "sample_id": 3328,
            "vt": "SELECT game.genre_id FROM game WHERE game.game_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the genre identifier of a specific game from the 'game' table based on the game's name. The placeholder in the WHERE clause represents the name of the game being queried."
        },
        {
            "sample_id": 3431,
            "vt": "SELECT game_platform.release_year FROM game_platform ORDER BY game_platform.release_year LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the release years of games from the 'game_platform' table, allowing users to see the years in which games were released. The placeholder in the LIMIT clause represents the maximum number of release years to display."
        },
        {
            "sample_id": 3391,
            "vt": "SELECT genre.id FROM game INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE game.game_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier of the game genre from the 'genre' table based on the name of a specific game. It uses an inner join to connect the 'game' table with the 'genre' table, allowing for filtering by the game's name."
        },
        {
            "sample_id": 3323,
            "vt": "SELECT DISTINCT game_publisher.game_id FROM game_publisher WHERE game_publisher.publisher_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a distinct list of game IDs from the 'game_publisher' table based on a specific publisher's ID. This allows users to identify all games associated with a particular publisher."
        },
        {
            "sample_id": 3412,
            "vt": "SELECT SUM(CASE WHEN region.region_name = '[placeholder-type:string]' THEN region_sales.num_sales ELSE [placeholder-type:numeric] END) / SUM(CASE WHEN region.region_name = '[placeholder-type:string]' THEN region_sales.num_sales ELSE [placeholder-type:numeric] END) FROM region_sales INNER JOIN region AS T2 ON T1.region_id = T2.id",
            "ba": "The virtual table calculates the ratio of sales for a specific region compared to total sales across all regions for a particular game platform. It uses a conditional sum to determine the sales in the specified region and divides it by the total sales, allowing users to analyze the performance of a game in a specific market."
        },
        {
            "sample_id": 3319,
            "vt": "SELECT T.publisher_name FROM (SELECT publisher.publisher_name, COUNT(DISTINCT T1.id) FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id INNER JOIN genre AS T4 ON T1.genre_id = T4.id WHERE T4.genre_name = 'Puzzle' GROUP BY T3.publisher_name ORDER BY COUNT(DISTINCT T1.id) DESC LIMIT 1) AS t",
            "ba": "The virtual table identifies the publisher that has published the most distinct games in the 'Puzzle' genre. It retrieves the publisher's name from the 'publisher' table, counting the number of unique games associated with each publisher through the 'game' and 'game_publisher' tables. The results are filtered to include only those games that belong to the 'Puzzle' genre, and the output is ordered by the count of distinct games in descending order, limiting the result to the top publisher."
        },
        {
            "sample_id": 3409,
            "vt": "SELECT game.game_name FROM publisher INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id INNER JOIN game AS T3 ON T2.game_id = T3.id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of games published by a specific publisher. It retrieves the game names from the 'game' table, joining it with the 'game_publisher' table to link games with their respective publishers, and filtering the results based on the publisher's name provided as a placeholder."
        },
        {
            "sample_id": 3466,
            "vt": "SELECT game_platform.game_publisher_id FROM game_platform WHERE game_platform.platform_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of game publishers associated with a specific game platform from the 'game_platform' table. The placeholder in the WHERE clause represents the platform's ID."
        },
        {
            "sample_id": 3315,
            "vt": "SELECT T.publisher_name FROM (SELECT publisher.publisher_name, COUNT(DISTINCT T2.id) FROM game_publisher AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id GROUP BY T1.publisher_id ORDER BY COUNT(T2.id) DESC LIMIT 1) AS t",
            "ba": "The virtual table identifies the publisher with the highest number of distinct games published. It does this by joining the 'game_publisher' table with the 'publisher' table, counting the distinct game IDs for each publisher, and ordering the results to find the top publisher."
        },
        {
            "sample_id": 3426,
            "vt": "SELECT genre.genre_name FROM game INNER JOIN genre AS T2 ON T2.id = T1.genre_id GROUP BY genre.genre_name ORDER BY COUNT(game.genre_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique game genres from the 'genre' table, counting how many games belong to each genre. It uses an inner join to connect the 'game' table with the 'genre' table based on the genre ID. The results are grouped by genre name and ordered by the count of games in each genre, limiting the output to a specified number of genres."
        },
        {
            "sample_id": 3408,
            "vt": "SELECT game.game_name FROM region INNER JOIN region_sales AS T2 ON T1.id = T2.region_id INNER JOIN game_platform AS T3 ON T2.game_platform_id = T3.id INNER JOIN game_publisher AS T4 ON T3.game_publisher_id = T4.id INNER JOIN game AS T5 ON T4.game_id = T5.id WHERE region.region_name = '[placeholder-type:string]' ORDER BY region_sales.num_sales LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of games sold in a specific region, filtered by the region's name. It joins multiple tables to gather the necessary information, including the region, sales data, game platforms, publishers, and the games themselves. The placeholders represent the region's name and the limit on the number of results to return."
        },
        {
            "sample_id": 3383,
            "vt": "SELECT game.game_name FROM game_platform INNER JOIN platform AS T2 ON T1.platform_id = T2.id INNER JOIN game_publisher AS T3 ON T1.game_publisher_id = T3.id INNER JOIN game AS T4 ON T3.game_id = T4.id WHERE platform.platform_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of games from the 'game' table that are available on a specific platform. It joins multiple tables to filter the results based on the platform's name, allowing users to see which games can be played on their chosen platform."
        },
        {
            "sample_id": 3435,
            "vt": "SELECT game.game_name FROM game INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN game_platform AS T3 ON T2.id = T3.game_publisher_id INNER JOIN platform AS T4 ON T3.platform_id = T4.id WHERE platform.platform_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of games from the 'game' table that are available on a specific platform. It joins multiple tables to filter the results based on the platform's name, allowing users to find games associated with a particular gaming platform."
        },
        {
            "sample_id": 3440,
            "vt": "SELECT T.publisher_name FROM (SELECT publisher.publisher_name, COUNT(game.id) FROM publisher AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id INNER JOIN game AS T3 ON T2.game_id = T3.id INNER JOIN genre AS T4 ON T3.genre_id = T4.id WHERE T4.genre_name = 'Puzzle' GROUP BY T1.publisher_name ORDER BY COUNT(T3.id) DESC LIMIT 1) AS t",
            "ba": "The virtual table identifies the publisher that has published the highest number of games in the 'Puzzle' genre. It retrieves the publisher's name from the 'publisher' table, counting the number of games associated with each publisher through the 'game_publisher' and 'game' tables, while filtering for the 'Puzzle' genre from the 'genre' table. The results are grouped by publisher name and ordered by the count of games in descending order, limiting the output to the top publisher."
        },
        {
            "sample_id": 3372,
            "vt": "SELECT T.game_name FROM (SELECT game.game_name FROM region AS T1 INNER JOIN region_sales AS T2 ON T1.id = T2.region_id INNER JOIN game_platform AS T3 ON T2.game_platform_id = T3.id INNER JOIN game_publisher AS T4 ON T3.game_publisher_id = T4.id INNER JOIN game AS T5 ON T4.game_id = T5.id WHERE T1.region_name = 'Japan' ORDER BY T2.num_sales DESC LIMIT 1) AS t",
            "ba": "The virtual table retrieves the name of the most popular game sold in a specific region, which in this case is Japan. It does this by joining multiple tables: 'region', 'region_sales', 'game_platform', 'game_publisher', and 'game'. The query filters the results based on the region name and orders the games by their sales numbers in descending order, limiting the output to the top-selling game."
        },
        {
            "sample_id": 3454,
            "vt": "SELECT SUM(region_sales.num_sales * [placeholder-type:numeric]) FROM region_sales INNER JOIN region AS T2 ON T1.region_id = T2.id INNER JOIN game_platform AS T3 ON T1.game_platform_id = T3.id INNER JOIN platform AS T4 ON T3.platform_id = T4.id WHERE region.region_name = '[placeholder-type:string]' AND platform.platform_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of sales for games in a specific region and on a specific platform. It aggregates the sales data from the 'region_sales' table, joining it with the 'region', 'game_platform', and 'platform' tables to filter results based on the specified region name and platform name. The placeholder in the SUM function represents a multiplier for the number of sales, while the placeholders in the WHERE clause represent the specific region and platform names."
        },
        {
            "sample_id": 3367,
            "vt": "SELECT DISTINCT region.region_name FROM region INNER JOIN region_sales AS T2 ON T1.id = T2.region_id WHERE region_sales.num_sales * [placeholder-type:numeric] > [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct region names from the 'region' table where the number of sales in that region exceeds a specified threshold. The sales are calculated by multiplying the 'num_sales' from the 'region_sales' table by a placeholder value, allowing users to specify their own multiplier for sales calculations."
        },
        {
            "sample_id": 3364,
            "vt": "SELECT DISTINCT genre.genre_name FROM game_platform INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id INNER JOIN game AS T3 ON T2.game_id = T3.id INNER JOIN genre AS T4 ON T3.genre_id = T4.id WHERE game_platform.release_year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct game genres from the 'genre' table based on the release years of games associated with various platforms and publishers. The placeholders in the WHERE clause represent the range of release years to filter the results."
        },
        {
            "sample_id": 3416,
            "vt": "SELECT COUNT(DISTINCT T2.game_id) FROM publisher INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id INNER JOIN game_platform AS T3 ON T2.id = T3.game_publisher_id WHERE game_platform.release_year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of games published by a specific publisher that were released in a particular year. It joins the 'publisher' table with the 'game_publisher' table to link publishers to their games, and then further joins with the 'game_platform' table to filter the results based on the release year of the games."
        },
        {
            "sample_id": 3348,
            "vt": "SELECT COUNT(DISTINCT T3.game_id) FROM platform INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN game_publisher AS T3 ON T2.game_publisher_id = T3.id WHERE platform.platform_name = '[placeholder-type:string]' AND game_platform.release_year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of games associated with a specific platform and release year. It joins the 'platform', 'game_platform', and 'game_publisher' tables to filter the results based on the platform name and the release year of the games."
        },
        {
            "sample_id": 3438,
            "vt": "SELECT COUNT(game.id) FROM genre INNER JOIN game AS T2 ON T1.id = T2.genre_id WHERE NOT genre.genre_name IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table counts the number of games from the 'game' table that belong to genres not specified in the placeholder list. It joins the 'genre' table with the 'game' table based on the genre ID, filtering out specific genres using placeholders for string values."
        },
        {
            "sample_id": 3359,
            "vt": "SELECT game_platform.id FROM game_platform WHERE game_platform.release_year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of game platforms from the 'game_platform' table that were released within a specified range of years. The placeholders represent the start and end years for filtering the results."
        },
        {
            "sample_id": 3321,
            "vt": "SELECT CAST(COUNT(CASE WHEN genre.genre_name = '[placeholder-type:string]' THEN game.id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(game.id) FROM game INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id INNER JOIN genre AS T4 ON T1.genre_id = T4.id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of games of a specific genre published by a certain publisher. It counts the total number of games in that genre and divides it by the total number of games published by the specified publisher, adjusting the result by a numeric factor. The placeholders represent the genre name and the publisher's name, allowing users to specify their interests."
        },
        {
            "sample_id": 3384,
            "vt": "SELECT COUNT(DISTINCT T1.game_id) FROM game_publisher INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of games published by a specific publisher from the 'game_publisher' table. It joins the 'publisher' table to filter the results based on the publisher's name provided as a placeholder."
        },
        {
            "sample_id": 3312,
            "vt": "SELECT game.game_name FROM game INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of games from the 'game' table that are published by a specific publisher. It uses inner joins to connect the 'game' table with the 'game_publisher' table and the 'publisher' table, filtering the results based on the publisher's name provided as a placeholder."
        },
        {
            "sample_id": 3460,
            "vt": "SELECT COUNT(game.id) FROM game INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE genre.genre_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of games from the 'game' table that belong to a specific genre. It joins the 'game' table with the 'genre' table to filter games based on the genre name provided in the placeholder."
        },
        {
            "sample_id": 3476,
            "vt": "SELECT game.game_name FROM game INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE genre.genre_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of games from the 'game' table that belong to a specific genre. It uses an inner join with the 'genre' table to filter the results based on the genre name provided in the placeholder."
        },
        {
            "sample_id": 3402,
            "vt": "SELECT COUNT(*) FROM region_sales INNER JOIN region AS T2 ON T1.region_id = T2.id WHERE region.region_name = '[placeholder-type:string]' AND region_sales.num_sales = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of sales for games in a specific region based on the region's name and the number of sales. It joins the 'region_sales' table with the 'region' table to filter results according to the specified region and sales figures."
        },
        {
            "sample_id": 3352,
            "vt": "SELECT T.release_year FROM (SELECT game_platform.release_year, COUNT(DISTINCT T3.game_id) FROM platform AS T1 INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN game_publisher AS T3 ON T2.game_publisher_id = T3.id WHERE T1.platform_name = 'PC' GROUP BY T2.release_year ORDER BY COUNT(DISTINCT T3.game_id) DESC LIMIT 1) AS t",
            "ba": "The virtual table retrieves the release year of the game platform that has the highest number of distinct games published for the 'PC' platform. It does this by joining the 'platform', 'game_platform', and 'game_publisher' tables to count the distinct games for each release year, filtering for the 'PC' platform, and ordering the results to find the year with the most games."
        },
        {
            "sample_id": 3333,
            "vt": "SELECT COUNT(game.id) FROM game INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE genre.genre_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of games from the 'game' table that belong to a specific genre. It joins the 'game' table with the 'genre' table to filter the results based on the genre name provided by the user."
        },
        {
            "sample_id": 3332,
            "vt": "SELECT COUNT(platform.id) FROM game_platform INNER JOIN platform AS T2 ON T1.platform_id = T2.id INNER JOIN game_publisher AS T3 ON T1.game_publisher_id = T3.id INNER JOIN game AS T4 ON T3.game_id = T4.id WHERE game.game_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of platforms associated with a specific game. It joins multiple tables: 'game_platform' to link games with their platforms, 'platform' to get platform details, and 'game_publisher' to connect games with their publishers. The query filters results based on the game's name, represented by a placeholder for string values."
        },
        {
            "sample_id": 3494,
            "vt": "SELECT game_publisher.game_id FROM game_publisher INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifiers of games from the 'game_publisher' table that are associated with a specific publisher. It uses an inner join to connect the 'game_publisher' table with the 'publisher' table based on the publisher's ID. The placeholder in the WHERE clause represents the name of the publisher, allowing users to filter results based on a specific publisher's name."
        },
        {
            "sample_id": 3456,
            "vt": "SELECT COUNT(DISTINCT T3.id) FROM game_publisher INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN game AS T3 ON T1.game_id = T3.id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct number of games published by a specific publisher from the 'game_publisher' table. It joins the 'publisher' table to filter by the publisher's name and the 'game' table to ensure that only games associated with that publisher are counted. The placeholder in the WHERE clause represents the name of the publisher."
        },
        {
            "sample_id": 3499,
            "vt": "SELECT SUM(region_sales.num_sales) * [placeholder-type:numeric] FROM region INNER JOIN region_sales AS T2 ON T1.id = T2.region_id WHERE region.region_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of game sales in a specific region by summing the sales figures from the 'region_sales' table. The placeholder in the SELECT statement allows for scaling the total sales by a specified numeric factor, while the WHERE clause filters the results to include only the sales from a particular region identified by its name."
        },
        {
            "sample_id": 3373,
            "vt": "SELECT DISTINCT publisher.publisher_name FROM region INNER JOIN region_sales AS T2 ON T1.id = T2.region_id INNER JOIN game_platform AS T3 ON T2.game_platform_id = T3.id INNER JOIN game_publisher AS T4 ON T3.game_publisher_id = T4.id INNER JOIN publisher AS T5 ON T4.publisher_id = T5.id WHERE region_sales.num_sales * [placeholder-type:numeric] > (SELECT AVG(region_sales.num_sales) * [placeholder-type:numeric] * [placeholder-type:numeric] FROM region AS T1 INNER JOIN region_sales AS T2 ON T1.id = T2.region_id WHERE T1.region_name = 'Japan')",
            "ba": "The virtual table lists distinct publisher names from the 'publisher' table based on sales data from different regions. It filters publishers whose games have sales exceeding a certain threshold, which is calculated as a multiple of the average sales in Japan. The query involves multiple joins across the 'region', 'region_sales', 'game_platform', 'game_publisher', and 'publisher' tables to gather the necessary data for this comparison."
        },
        {
            "sample_id": 3365,
            "vt": "SELECT game.game_name FROM game INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of games from the 'game' table that are published by a specific publisher. It uses inner joins to connect the 'game' table with the 'game_publisher' table and the 'publisher' table, filtering the results based on the publisher's name provided as a placeholder."
        },
        {
            "sample_id": 3442,
            "vt": "SELECT publisher.publisher_name FROM publisher INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id INNER JOIN game AS T3 ON T2.game_id = T3.id WHERE game.game_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of publishers from the 'publisher' table who have published a specific game. The query joins the 'publisher' table with the 'game_publisher' table to link publishers to their respective games, and then further joins with the 'game' table to filter by a specific game's name. The placeholder in the WHERE clause represents the name of the game for which we want to find the publisher."
        },
        {
            "sample_id": 3396,
            "vt": "SELECT SUM(T.num_sales) * [placeholder-type:numeric] FROM region_sales",
            "ba": "The virtual table calculates the total number of sales for games in a specific region by summing the sales figures from the 'region_sales' table and multiplying by a factor to convert the sales count into actual sales numbers."
        },
        {
            "sample_id": 3356,
            "vt": "SELECT game.id FROM game WHERE game.genre_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of games from the 'game' table that belong to a specific genre. The placeholder in the WHERE clause represents the genre's ID, allowing users to filter games based on their genre."
        },
        {
            "sample_id": 3310,
            "vt": "SELECT genre.genre_name FROM game INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE game.game_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the game genres associated with a specific game from the 'game' table. The placeholder in the WHERE clause represents the name of the game for which the genre is being queried."
        },
        {
            "sample_id": 3337,
            "vt": "SELECT genre.genre_name FROM game INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE game.game_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the game genres associated with a specific game from the 'game' table. It retrieves the genre name by joining the 'game' table with the 'genre' table based on the genre ID. The placeholder in the WHERE clause represents the name of the game for which the genre is being queried."
        },
        {
            "sample_id": 3447,
            "vt": "SELECT SUM(region_sales.num_sales * [placeholder-type:numeric]) FROM region_sales WHERE region_sales.region_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total number of game sales in a specific region by summing the sales figures from the 'region_sales' table. The placeholder in the SUM function represents a multiplier for the sales count, while the WHERE clause filters the results to include only those sales associated with a specified region."
        },
        {
            "sample_id": 3488,
            "vt": "SELECT game.game_name FROM game_platform INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id INNER JOIN game AS T3 ON T2.game_id = T3.id WHERE game_platform.release_year = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of games released in a specific year. It retrieves data from the 'game' table, which contains the game names, and joins it with the 'game_platform' and 'game_publisher' tables to filter the results based on the release year. The placeholder in the WHERE clause represents the year of release."
        },
        {
            "sample_id": 3415,
            "vt": "SELECT platform.platform_name FROM region INNER JOIN region_sales AS T2 ON T1.id = T2.region_id INNER JOIN game_platform AS T3 ON T2.game_platform_id = T3.id INNER JOIN platform AS T4 ON T3.platform_id = T4.id WHERE region.region_name = '[placeholder-type:string]' ORDER BY region_sales.num_sales LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of game platforms from the 'platform' table that are associated with a specific region. It joins multiple tables to filter the platforms based on the sales data in that region, allowing users to see which platforms are most popular in a given area."
        },
        {
            "sample_id": 3432,
            "vt": "SELECT publisher.publisher_name FROM publisher WHERE publisher.publisher_name LIKE '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of publishers from the 'publisher' table that match a specific pattern provided by the user. The placeholder in the WHERE clause allows for filtering based on a partial or full name of the publisher."
        },
        {
            "sample_id": 3422,
            "vt": "SELECT COUNT(DISTINCT T2.id) FROM platform INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN region_sales AS T3 ON T1.id = T3.game_platform_id INNER JOIN region AS T4 ON T3.region_id = T4.id WHERE platform.platform_name = '[placeholder-type:string]' AND region.region_name = '[placeholder-type:string]' AND region_sales.num_sales > [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct platforms that have games sold in a specific region, filtering by the platform name and region name, and only including those with sales exceeding a certain number."
        },
        {
            "sample_id": 3314,
            "vt": "SELECT game.game_name FROM game INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id INNER JOIN genre AS T4 ON T1.genre_id = T4.id WHERE publisher.publisher_name = '[placeholder-type:string]' AND genre.genre_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of games from the 'game' table that are associated with a specific publisher and genre. The query uses inner joins to connect the 'game' table with the 'game_publisher' table to find the relevant publisher, and then with the 'genre' table to filter by the specified genre. The placeholders in the WHERE clause represent the publisher's name and the genre's name."
        },
        {
            "sample_id": 3375,
            "vt": "SELECT COUNT(game_platform.id) FROM game_platform WHERE game_platform.release_year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of game platform records from the 'game_platform' table that were released in a specific year. The placeholder in the WHERE clause represents the release year of the games."
        },
        {
            "sample_id": 3370,
            "vt": "SELECT platform.platform_name FROM platform INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN game_publisher AS T3 ON T2.game_publisher_id = T3.id INNER JOIN game AS T4 ON T3.game_id = T4.id WHERE game.game_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of platforms on which a specific game is available. It retrieves the platform names by joining the 'platform', 'game_platform', 'game_publisher', and 'game' tables. The placeholder in the WHERE clause represents the name of the game for which the platform information is being queried."
        },
        {
            "sample_id": 3505,
            "vt": "SELECT COUNT(CASE WHEN platform.platform_name = '[placeholder-type:string]' THEN game_publisher.game_id ELSE NULL END) - COUNT(CASE WHEN platform.platform_name = '[placeholder-type:string]' THEN game_publisher.game_id ELSE NULL END) FROM platform INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN game_publisher AS T3 ON T2.game_publisher_id = T3.id INNER JOIN publisher AS T4 ON T3.publisher_id = T4.id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference in the count of games published by a specific publisher on a specified platform. It uses joins to connect the 'platform', 'game_platform', 'game_publisher', and 'publisher' tables, filtering by the publisher's name and the platform's name."
        },
        {
            "sample_id": 3493,
            "vt": "SELECT genre.genre_name FROM game INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE game.id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the game genre of a specific game identified by its unique ID. It retrieves the genre name from the 'genre' table by joining it with the 'game' table based on the genre ID. The placeholder in the WHERE clause represents the unique identifier of the game."
        },
        {
            "sample_id": 3317,
            "vt": "SELECT game_platform.release_year FROM game_publisher INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN game AS T3 ON T1.game_id = T3.id INNER JOIN game_platform AS T4 ON T1.id = T4.game_publisher_id INNER JOIN platform AS T5 ON T4.platform_id = T5.id WHERE game.game_name = '[placeholder-type:string]' AND platform.platform_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the release year of a game from the 'game_platform' table based on the game's name and the platform's name. It joins multiple tables to connect the game with its publisher and platform, ensuring that the correct release year is fetched for the specified game and platform."
        },
        {
            "sample_id": 3397,
            "vt": "SELECT CAST(COUNT(game_publisher.game_id) AS FLOAT) / COUNT(DISTINCT T.publisher_id) FROM game_publisher",
            "ba": "The virtual table calculates the average number of games published per publisher by dividing the total count of games published by the distinct count of publishers. This provides insight into the publishing activity relative to the number of publishers."
        },
        {
            "sample_id": 3401,
            "vt": "SELECT platform.platform_name FROM platform INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN game_publisher AS T3 ON T2.game_publisher_id = T3.id GROUP BY game_platform.release_year, platform.platform_name ORDER BY COUNT(DISTINCT T3.game_id)",
            "ba": "The virtual table lists the names of game platforms from the 'platform' table. It joins the 'game_platform' table to associate platforms with their respective game publishers, and groups the results by the release year and platform name. The results are ordered by the count of distinct games published on each platform, allowing users to see which platforms have the most unique games released in each year."
        },
        {
            "sample_id": 3349,
            "vt": "SELECT DISTINCT publisher.publisher_name FROM game_platform INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id ORDER BY game_platform.release_year LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists distinct publisher names from the 'publisher' table, which are associated with games released on various platforms. It joins the 'game_platform' and 'game_publisher' tables to link publishers to their respective games, filtering the results based on the release year of the games. The output is limited to a specified number of publishers."
        },
        {
            "sample_id": 3341,
            "vt": "SELECT CAST(COUNT(CASE WHEN genre.genre_name = '[placeholder-type:string]' THEN game.id ELSE NULL END) AS FLOAT) * [placeholder-type:numeric] / COUNT(game.id) FROM game INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id INNER JOIN genre AS T4 ON T1.genre_id = T4.id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the proportion of games of a specific genre published by a certain publisher. It counts the total number of games in that genre and divides it by the total number of games published by the specified publisher, adjusting the result by a numeric factor. The placeholders represent the genre name and publisher name for filtering the results, as well as a numeric value for scaling the proportion."
        },
        {
            "sample_id": 3398,
            "vt": "SELECT MIN(T.release_year) FROM game_platform",
            "ba": "The virtual table retrieves the earliest release year of games from the 'game_platform' table. This table links games to their respective platforms and includes the release year for each game-platform combination."
        },
        {
            "sample_id": 3324,
            "vt": "SELECT game.genre_id FROM game WHERE game.game_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the genre identifier of a specific game from the 'game' table based on the game's name. The placeholder in the WHERE clause represents the name of the game being queried."
        },
        {
            "sample_id": 3366,
            "vt": "SELECT COUNT(game.id) FROM game INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE genre.genre_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of games from the 'game' table that belong to a specific genre. It joins the 'game' table with the 'genre' table to filter games based on the genre name provided in the placeholder."
        },
        {
            "sample_id": 3380,
            "vt": "SELECT game_platform.id FROM game_platform WHERE game_platform.release_year = [placeholder-type:numeric]",
            "ba": "The virtual table identifies the unique identifiers of game platforms from the 'game_platform' table that were released in a specific year. The placeholder in the WHERE clause represents the release year of the game platforms."
        },
        {
            "sample_id": 3482,
            "vt": "SELECT DISTINCT game_platform.platform_id FROM game_platform WHERE game_platform.release_year = [placeholder-type:numeric]",
            "ba": "The virtual table lists unique platform identifiers from the 'game_platform' table for games released in a specific year. The placeholder in the WHERE clause represents the release year of the games."
        },
        {
            "sample_id": 3325,
            "vt": "SELECT region.id FROM region WHERE region.region_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier of a region from the 'region' table based on a specified region name. The placeholder in the WHERE clause represents the name of the region being queried."
        },
        {
            "sample_id": 3326,
            "vt": "SELECT (SELECT T.game_platform_id, SUM(T.num_sales) FROM region_sales AS T WHERE T.region_id = 2 GROUP BY T.game_platform_id ORDER BY SUM(T.num_sales) DESC LIMIT 1).game_platform_id FROM (SELECT region_sales.game_platform_id, SUM(region_sales.num_sales) FROM region_sales AS T WHERE T.region_id = 2 GROUP BY T.game_platform_id ORDER BY SUM(T.num_sales) DESC LIMIT 1) AS t1",
            "ba": "The virtual table identifies the game platform that has achieved the highest number of sales in a specific region. It does this by aggregating the sales data from the 'region_sales' table, filtering for a particular region, and ordering the results to find the platform with the maximum sales. The placeholder in the query represents the region's identifier."
        },
        {
            "sample_id": 3353,
            "vt": "SELECT T.publisher_name FROM (SELECT publisher.publisher_name, COUNT(DISTINCT T1.game_id) FROM game_publisher AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id GROUP BY T2.publisher_name HAVING COUNT(DISTINCT T1.game_id) = 1) AS t",
            "ba": "The virtual table lists the names of publishers who have published exactly one game. It does this by first joining the 'game_publisher' table with the 'publisher' table to associate each game with its publisher. Then, it groups the results by publisher name and counts the distinct game IDs for each publisher. The HAVING clause filters the results to include only those publishers that have published exactly one game."
        },
        {
            "sample_id": 3441,
            "vt": "SELECT T.game_name FROM (SELECT game.game_name FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN game_platform AS T3 ON T2.id = T3.game_publisher_id INNER JOIN region_sales AS T4 ON T3.id = T4.game_platform_id ORDER BY T4.num_sales LIMIT 1) AS t",
            "ba": "The virtual table lists the name of the game that has the highest number of sales in a specific region. It retrieves this information by joining multiple tables: 'game', 'game_publisher', 'game_platform', and 'region_sales'. The query first identifies the games along with their publishers and platforms, then filters and orders them based on the number of sales in the region, limiting the result to the top-selling game."
        },
        {
            "sample_id": 3458,
            "vt": "SELECT COUNT(game_publisher.game_id) FROM platform INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN game_publisher AS T3 ON T2.game_publisher_id = T3.id WHERE platform.platform_name = '[placeholder-type:string]' AND game_platform.release_year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of games published on a specific platform in a given release year. It joins the 'platform', 'game_platform', and 'game_publisher' tables to filter results based on the platform name and the release year of the games."
        },
        {
            "sample_id": 3421,
            "vt": "SELECT genre.genre_name FROM game INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE game.game_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the game genres associated with a specific game from the 'game' table. It retrieves the genre name by joining the 'game' table with the 'genre' table based on the genre ID. The placeholder in the WHERE clause represents the name of the game for which the genre is being queried."
        },
        {
            "sample_id": 3489,
            "vt": "SELECT COUNT(DISTINCT T3.id) FROM game_platform INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id INNER JOIN game AS T3 ON T2.game_id = T3.id INNER JOIN genre AS T4 ON T3.genre_id = T4.id WHERE genre.genre_name = '[placeholder-type:string]' AND game_platform.release_year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the distinct number of games from the 'game' table that belong to a specific genre and were released in a particular year. It joins multiple tables: 'game_platform' to link games with their platforms, 'game_publisher' to associate games with their publishers, and 'genre' to filter by the genre name. The placeholders represent the genre name and the release year of the games."
        },
        {
            "sample_id": 3498,
            "vt": "SELECT genre.genre_name FROM game INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE game.game_name IN ('[placeholder-type:string]', '[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table retrieves the names of game genres from the 'genre' table based on the names of specific games provided in the query. It uses an INNER JOIN to connect the 'game' table with the 'genre' table, ensuring that only genres corresponding to the specified games are selected."
        },
        {
            "sample_id": 3313,
            "vt": "SELECT COUNT(game.id) FROM game INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id INNER JOIN genre AS T4 ON T1.genre_id = T4.id WHERE genre.genre_name = '[placeholder-type:string]' AND publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of games from the 'game' table that belong to a specific genre and are published by a specific publisher. It joins the 'game' table with the 'game_publisher' table to link games with their publishers, and then further joins with the 'publisher' and 'genre' tables to filter based on the genre name and publisher name provided as placeholders."
        },
        {
            "sample_id": 3343,
            "vt": "SELECT COUNT(DISTINCT T2.game_id) FROM publisher INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of distinct games published by a specific publisher. It joins the 'publisher' table with the 'game_publisher' table to filter the results based on the publisher's name, which is provided as a placeholder."
        },
        {
            "sample_id": 3486,
            "vt": "SELECT game.game_name FROM game WHERE game.id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the name of a game from the 'game' table based on a specific game identifier. The placeholder in the WHERE clause represents the unique identifier of the game."
        },
        {
            "sample_id": 3362,
            "vt": "SELECT game_platform.release_year FROM game_platform INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id INNER JOIN game AS T3 ON T2.game_id = T3.id WHERE game.game_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the release year of a game from the 'game_platform' table, which is linked to the 'game_publisher' and 'game' tables. The query filters results based on the name of the game provided as a placeholder."
        },
        {
            "sample_id": 3340,
            "vt": "SELECT platform.platform_name FROM game_platform INNER JOIN platform AS T2 ON T1.platform_id = T2.id ORDER BY game_platform.release_year LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of game platforms from the 'platform' table, which are associated with games released in a specific year. The query joins the 'game_platform' table with the 'platform' table to retrieve the platform names, ordering them by the release year of the games. The result is limited to a specified number of platforms."
        },
        {
            "sample_id": 3484,
            "vt": "SELECT game_platform.release_year FROM game_platform WHERE game_platform.game_publisher_id = [placeholder-type:numeric] AND game_platform.id = [placeholder-type:numeric]",
            "ba": "The virtual table provides the release year of a game from the 'game_platform' table based on a specific game publisher and a unique identifier for the game platform. The placeholders represent the numeric values for the game publisher's ID and the game platform's ID."
        },
        {
            "sample_id": 3330,
            "vt": "SELECT publisher.publisher_name FROM publisher INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id INNER JOIN game AS T3 ON T2.game_id = T3.id WHERE game.game_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the names of publishers from the 'publisher' table for games that match a specific game name. It uses inner joins to connect the 'publisher' table with the 'game_publisher' table and then with the 'game' table, ensuring that only the relevant publishers for the specified game are selected."
        },
        {
            "sample_id": 3339,
            "vt": "SELECT COUNT(game_publisher.game_id) FROM publisher INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id WHERE publisher.publisher_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of games published by a specific publisher from the 'publisher' table. It uses an inner join with the 'game_publisher' table to link publishers to their respective games. The placeholder in the WHERE clause represents the name of the publisher for which the count of published games is being requested."
        },
        {
            "sample_id": 3406,
            "vt": "SELECT game.game_name FROM genre INNER JOIN game AS T2 ON T1.id = T2.genre_id WHERE genre.genre_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of games from the 'game' table that belong to a specific genre. It uses an inner join between the 'genre' and 'game' tables to filter games based on the genre name provided as a placeholder."
        }
    ],
    "image_and_language": [
        {
            "sample_id": 7588,
            "vt": "SELECT img_obj.x, img_obj.y FROM att_classes INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID INNER JOIN IMG_OBJ AS T3 ON T2.IMG_ID = T3.IMG_ID INNER JOIN OBJ_CLASSES AS T4 ON T3.OBJ_CLASS_ID = T4.OBJ_CLASS_ID WHERE att_classes.att_class = '[placeholder-type:string]' AND obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the x and y coordinates of objects from the 'img_obj' table that are associated with specific attribute classes and object classes. It uses inner joins to connect the 'att_classes', 'img_obj_att', and 'obj_classes' tables based on their respective IDs, filtering the results based on the specified attribute class and object class."
        },
        {
            "sample_id": 7569,
            "vt": "SELECT att_classes.att_class FROM att_classes INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID INNER JOIN IMG_OBJ AS T3 ON T2.IMG_ID = T3.IMG_ID INNER JOIN OBJ_CLASSES AS T4 ON T3.OBJ_CLASS_ID = T4.OBJ_CLASS_ID WHERE img_obj.img_id = [placeholder-type:numeric] AND obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table describes the attribute classes associated with a specific image and object class. It retrieves the attribute class names from the 'att_classes' table by joining it with the 'img_obj_att', 'img_obj', and 'obj_classes' tables. The placeholders in the WHERE clause represent the image ID and the object class name that the user wants to filter by."
        },
        {
            "sample_id": 7535,
            "vt": "SELECT DISTINCT obj_classes.obj_class, att_classes.att_class, pred_classes.pred_class FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID INNER JOIN IMG_OBJ_ATT AS T3 ON T1.IMG_ID = T3.IMG_ID INNER JOIN ATT_CLASSES AS T4 ON T3.ATT_CLASS_ID = T4.ATT_CLASS_ID INNER JOIN IMG_REL AS T5 ON T1.IMG_ID = T5.IMG_ID INNER JOIN PRED_CLASSES AS T6 ON T5.PRED_CLASS_ID = T6.PRED_CLASS_ID WHERE img_obj.img_id = [placeholder-type:numeric] AND img_obj.x = [placeholder-type:numeric] AND img_obj.y = [placeholder-type:numeric] AND img_obj.w = [placeholder-type:numeric] AND img_obj.h = [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct object classes, attribute classes, and prediction classes associated with a specific image based on its ID and bounding box coordinates. The placeholders in the WHERE clause represent the image ID and the bounding box parameters (x, y, width, height)."
        },
        {
            "sample_id": 7583,
            "vt": "SELECT DISTINCT img_rel.img_id FROM img_rel INNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE pred_classes.pred_class = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct image IDs from the 'img_rel' table, which contains relationships between objects in images. It joins with the 'pred_classes' table to filter these relationships based on a specific prediction class. The placeholder in the WHERE clause represents the name of the prediction class being queried."
        },
        {
            "sample_id": 7594,
            "vt": "SELECT AVG(img_obj.img_id) FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average of image IDs from the 'img_obj' table, joining it with the 'obj_classes' table to filter based on a specific object class. The placeholder in the WHERE clause represents the name of the object class being queried."
        },
        {
            "sample_id": 7570,
            "vt": "SELECT DISTINCT pred_classes.pred_class FROM img_rel INNER JOIN PRED_CLASSES AS T2 ON T2.PRED_CLASS_ID = T1.PRED_CLASS_ID INNER JOIN IMG_OBJ AS T3 ON T1.IMG_ID = T3.IMG_ID AND T1.OBJ1_SAMPLE_ID = T3.OBJ_SAMPLE_ID INNER JOIN OBJ_CLASSES AS T4 ON T3.OBJ_CLASS_ID = T4.OBJ_CLASS_ID WHERE img_rel.img_id = [placeholder-type:numeric] AND img_rel.obj1_sample_id = [placeholder-type:numeric] OR img_rel.obj2_sample_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the distinct prediction classes associated with a specific image and object sample from the 'img_rel' table. It joins multiple tables to gather relevant information about the relationships between objects and their predicted classes. The placeholders in the WHERE clause represent the image ID and object sample IDs for filtering the results."
        },
        {
            "sample_id": 7518,
            "vt": "SELECT img_obj.x, img_obj.y FROM img_rel INNER JOIN IMG_OBJ AS T2 ON T1.IMG_ID = T2.IMG_ID WHERE img_rel.pred_class_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the x and y coordinates of objects from the 'img_obj' table that are related through a specific prediction class in the 'img_rel' table. The placeholder in the WHERE clause represents the prediction class ID used to filter the results."
        },
        {
            "sample_id": 7592,
            "vt": "SELECT COUNT(img_obj_att.img_id) FROM att_classes INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID INNER JOIN IMG_OBJ AS T3 ON T2.IMG_ID = T3.IMG_ID INNER JOIN OBJ_CLASSES AS T4 ON T3.OBJ_CLASS_ID = T4.OBJ_CLASS_ID WHERE att_classes.att_class = '[placeholder-type:string]' AND obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of images that have specific attribute classes and object classes. It joins the 'att_classes' table with the 'img_obj_att' table to find images associated with certain attributes, then further joins with the 'img_obj' table to link those images to their corresponding object classes. The placeholders in the WHERE clause represent the specific attribute class and object class names that the user wants to filter by."
        },
        {
            "sample_id": 7607,
            "vt": "SELECT pred_classes.pred_class FROM img_rel INNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE img_rel.img_id = [placeholder-type:numeric] ORDER BY pred_classes.pred_class LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the prediction classes associated with a specific image from the 'img_rel' table by joining it with the 'pred_classes' table. The placeholders represent the image ID and the limit for the number of results to return."
        },
        {
            "sample_id": 7582,
            "vt": "SELECT COUNT(img_obj.img_id) FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE obj_classes.obj_class = '[placeholder-type:string]' OR obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of images from the 'img_obj' table that belong to specific object classes. It uses an inner join with the 'obj_classes' table to filter images based on the specified object class names. The placeholders in the WHERE clause represent the names of the object classes being queried."
        },
        {
            "sample_id": 7597,
            "vt": "SELECT img_obj.w, img_obj.h FROM img_obj WHERE img_obj.obj_sample_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the width and height of objects from the 'img_obj' table based on a specific object sample ID. The placeholder in the WHERE clause represents the object sample ID for which the dimensions are being queried."
        },
        {
            "sample_id": 7541,
            "vt": "SELECT CAST(SUM(CASE WHEN att_classes.att_class = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(img_obj_att.obj_sample_id) FROM img_obj_att INNER JOIN ATT_CLASSES AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE img_obj_att.img_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average of a specific attribute class for a given image. It sums the values associated with a specified attribute class and normalizes this sum by the count of object samples related to that image. The placeholders represent the attribute class name, a numeric value for weighting, and the image ID."
        },
        {
            "sample_id": 7563,
            "vt": "SELECT img_obj.obj_sample_id FROM img_obj WHERE img_obj.img_id = [placeholder-type:numeric] AND img_obj.x = [placeholder-type:numeric] AND img_obj.y = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the object sample IDs from the 'img_obj' table based on specific image ID and coordinates (x, y). The placeholders represent the image ID and the x and y coordinates of the bounding box for the object."
        },
        {
            "sample_id": 7604,
            "vt": "SELECT img_obj.w, img_obj.h, obj_classes.obj_class FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE img_obj.img_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the width and height of objects along with their corresponding class from the 'img_obj' and 'obj_classes' tables. The placeholder in the WHERE clause represents the specific image id for which the dimensions and class are being queried."
        },
        {
            "sample_id": 7576,
            "vt": "SELECT CAST(SUM(CASE WHEN obj_classes.obj_class = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(img_obj.obj_sample_id) FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID",
            "ba": "The virtual table calculates a weighted average of a specific object class from the 'img_obj' table. It sums up values based on a condition that checks if the object class matches a specified string, and then divides this sum by the count of object samples. The result is multiplied by a numeric placeholder to adjust the final output. The query involves joining the 'img_obj' table with the 'obj_classes' table to access the object class descriptions."
        },
        {
            "sample_id": 7605,
            "vt": "SELECT pred_classes.pred_class FROM img_rel INNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE img_rel.img_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the prediction classes associated with a specific image from the 'img_rel' table. It retrieves the prediction class captions by joining the 'img_rel' table with the 'pred_classes' table based on the prediction class ID. The placeholder in the WHERE clause represents the image ID for which the prediction classes are being queried."
        },
        {
            "sample_id": 7487,
            "vt": "SELECT pred_classes.pred_class FROM pred_classes INNER JOIN IMG_REL AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE img_rel.img_id = [placeholder-type:numeric] AND img_rel.obj1_sample_id = img_rel.obj2_sample_id",
            "ba": "The virtual table describes the prediction classes associated with images that have self-relations between objects. It retrieves the prediction class captions from the 'pred_classes' table by joining it with the 'img_rel' table, filtering for a specific image ID and ensuring that the object sample IDs are the same, indicating a self-relation."
        },
        {
            "sample_id": 7481,
            "vt": "SELECT obj_classes.obj_class FROM obj_classes INNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE img_obj.img_id = [placeholder-type:numeric] GROUP BY obj_classes.obj_class",
            "ba": "The virtual table describes the object classes associated with a specific image from the 'img_obj' table. It retrieves the object class names by joining the 'obj_classes' table with the 'img_obj' table based on the object class ID. The placeholder in the WHERE clause represents the image ID for which the object classes are being queried."
        },
        {
            "sample_id": 7554,
            "vt": "SELECT COUNT(DISTINCT T1.IMG_ID) FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct images from the 'img_obj' table that belong to a specific object class. It joins the 'img_obj' table with the 'obj_classes' table to filter images based on the object class name provided in the placeholder."
        },
        {
            "sample_id": 7539,
            "vt": "SELECT img_obj_att.att_class_id FROM img_obj_att WHERE img_obj_att.img_id = [placeholder-type:numeric] GROUP BY img_obj_att.att_class_id ORDER BY COUNT(img_obj_att.att_class_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the attribute class IDs associated with a specific image from the 'img_obj_att' table. It groups the results by attribute class ID and orders them based on the count of occurrences, limiting the results to a specified number."
        },
        {
            "sample_id": 7537,
            "vt": "SELECT COUNT(img_obj_att.att_class_id) FROM img_obj_att WHERE img_obj_att.img_id = [placeholder-type:numeric] AND img_obj_att.obj_sample_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of attribute class IDs associated with a specific image and object sample from the 'img_obj_att' table. The placeholders represent the image ID and object sample ID for which the count is being calculated."
        },
        {
            "sample_id": 7479,
            "vt": "SELECT SUM(CASE WHEN obj_classes.obj_class = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM obj_classes INNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE img_obj.img_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the total count of object classes from the 'obj_classes' table based on a specific condition. It uses a conditional SUM to differentiate between object classes and aggregates the results accordingly. The query joins the 'obj_classes' table with the 'img_obj' table to filter results based on a specific image ID, represented by a placeholder for numeric values."
        },
        {
            "sample_id": 7567,
            "vt": "SELECT DISTINCT img_obj_att.img_id FROM att_classes INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE att_classes.att_class = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct image IDs from the 'img_obj_att' table that are associated with a specific attribute class from the 'att_classes' table. The placeholder in the WHERE clause represents the name of the attribute class being queried."
        },
        {
            "sample_id": 7593,
            "vt": "SELECT att_classes.att_class FROM att_classes INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID INNER JOIN IMG_OBJ AS T3 ON T2.IMG_ID = T3.IMG_ID WHERE img_obj.x = [placeholder-type:numeric] AND img_obj.y = [placeholder-type:numeric]",
            "ba": "The virtual table describes the attribute classes associated with images that have specific x and y coordinates. It retrieves the attribute class names from the 'att_classes' table by joining it with the 'img_obj_att' table to link attributes to images, and then further joining with the 'img_obj' table to filter based on the x and y coordinates of the objects in the images."
        },
        {
            "sample_id": 7556,
            "vt": "SELECT CAST(SUM(CASE WHEN obj_classes.obj_class = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(obj_classes.obj_class) FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID",
            "ba": "The virtual table calculates a weighted average of a specific object class from the 'img_obj' table. It sums up values based on a condition that checks if the object class matches a specified string, and then divides this sum by the count of the object classes. The result is multiplied by a numeric placeholder to adjust the final output. The query involves joining the 'img_obj' table with the 'obj_classes' table to access the relevant object class information."
        },
        {
            "sample_id": 7494,
            "vt": "SELECT img_obj.x, img_obj.y, img_obj.w, img_obj.h FROM obj_classes INNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE img_obj.img_id = [placeholder-type:numeric] AND obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table describes the coordinates and dimensions of bounding boxes for objects in images, filtered by a specific image ID and object class. The placeholders represent the image ID and the object class name."
        },
        {
            "sample_id": 7574,
            "vt": "SELECT img_obj.h, img_obj.w FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE img_obj.img_id = [placeholder-type:numeric] AND obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the height and width of objects from the 'img_obj' table, specifically for a given image ID and object class. The placeholders allow users to specify the image ID and the object class they are interested in."
        },
        {
            "sample_id": 7579,
            "vt": "SELECT COUNT(img_obj.img_id) FROM img_obj WHERE img_obj.obj_sample_id < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of images in the 'img_obj' table that have an object sample ID less than a specified numeric value. The placeholder in the WHERE clause represents the threshold for the object sample ID."
        },
        {
            "sample_id": 7515,
            "vt": "SELECT COUNT(subquery_t3.imgid) FROM (SELECT img_obj_att.img_id FROM IMG_OBJ_att AS T1 INNER JOIN ATT_CLASSES AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE T2.ATT_CLASS = 'black' GROUP BY T1.IMG_ID HAVING COUNT(T1.ATT_CLASS_ID) >= 5) AS t3",
            "ba": "The virtual table counts the number of images from the 'img_obj_att' table that have at least five attributes classified as 'black'. It does this by first joining the 'img_obj_att' table with the 'att_classes' table to filter for the specific attribute class, then grouping the results by image ID and applying a condition to count the attributes."
        },
        {
            "sample_id": 7500,
            "vt": "SELECT COUNT((SELECT T2.IMG_ID FROM OBJ_CLASSES AS T1 INNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T1.OBJ_CLASS = 'suit' GROUP BY T2.IMG_ID).img_id) FROM (SELECT img_obj.img_id FROM OBJ_CLASSES AS T1 INNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T1.OBJ_CLASS = 'suit' GROUP BY T2.IMG_ID) AS t",
            "ba": "The virtual table counts the number of unique images from the 'img_obj' table that contain objects classified as 'suit' based on the 'obj_classes' table. It uses a subquery to first select the image IDs associated with the 'suit' class, and then counts these unique image IDs."
        },
        {
            "sample_id": 7517,
            "vt": "SELECT img_obj_att.img_id FROM img_obj_att INNER JOIN ATT_CLASSES AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE att_classes.att_class = '[placeholder-type:string]' GROUP BY img_obj_att.img_id ORDER BY COUNT(img_obj_att.att_class_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves image IDs from the 'img_obj_att' table that are associated with a specific attribute class. It joins the 'img_obj_att' table with the 'att_classes' table to filter results based on the attribute class name. The results are grouped by image ID and ordered by the count of attribute classes associated with each image, limiting the output to a specified number of results."
        },
        {
            "sample_id": 7538,
            "vt": "SELECT COUNT(img_obj.obj_class_id) FROM img_obj WHERE img_obj.img_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of object classes associated with a specific image identified by its image ID. The placeholder in the WHERE clause represents the unique identifier for the image."
        },
        {
            "sample_id": 7552,
            "vt": "SELECT img_obj.x, img_obj.y, img_obj.w, img_obj.h FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE img_obj.img_id = [placeholder-type:numeric] AND obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table describes the x, y coordinates, width, and height of bounding boxes for objects in images from the 'img_obj' table. It filters the results based on a specific image ID and the corresponding object class name."
        },
        {
            "sample_id": 7599,
            "vt": "SELECT att_classes.att_class FROM att_classes INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE img_obj_att.img_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the attribute classes associated with a specific image from the 'att_classes' table. The query retrieves the attribute class names by joining the 'att_classes' table with the 'img_obj_att' table based on the attribute class ID, filtering for a specific image ID using a placeholder for numeric values."
        },
        {
            "sample_id": 7513,
            "vt": "SELECT att_classes.att_class FROM img_obj_att INNER JOIN ATT_CLASSES AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE img_obj_att.img_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the attribute classes associated with a specific image from the 'img_obj_att' table. The query retrieves the attribute class names by joining the 'img_obj_att' table with the 'att_classes' table based on the attribute class ID. The placeholder in the WHERE clause represents the image ID for which the attribute classes are being queried."
        },
        {
            "sample_id": 7475,
            "vt": "SELECT img_obj.img_id FROM img_obj GROUP BY img_obj.img_id ORDER BY COUNT(img_obj.obj_sample_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves unique image IDs from the 'img_obj' table, grouping them by image ID and ordering the results based on the count of associated object samples. The query limits the output to a specified number of image IDs."
        },
        {
            "sample_id": 7501,
            "vt": "SELECT pred_classes.pred_class FROM pred_classes INNER JOIN IMG_REL AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID INNER JOIN IMG_OBJ AS T3 ON T2.OBJ1_SAMPLE_ID = T3.OBJ_SAMPLE_ID INNER JOIN OBJ_CLASSES AS T4 ON T3.OBJ_CLASS_ID = T4.OBJ_CLASS_ID WHERE (obj_classes.obj_class = '[placeholder-type:string]' OR obj_classes.obj_class = '[placeholder-type:string]') AND img_rel.img_id = [placeholder-type:numeric] GROUP BY pred_classes.pred_class",
            "ba": "The virtual table describes the prediction classes associated with specific object classes and images. It retrieves the prediction class names from the 'pred_classes' table by joining it with the 'img_rel', 'img_obj', and 'obj_classes' tables. The query filters results based on specified object class names and a specific image ID, grouping the results by prediction class names."
        },
        {
            "sample_id": 7608,
            "vt": "SELECT img_obj.x, img_obj.y FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE img_obj.img_id = [placeholder-type:numeric] AND obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table describes the x and y coordinates of objects from the 'img_obj' table that belong to a specific object class. The query joins the 'img_obj' table with the 'obj_classes' table to filter the results based on the image ID and the object class name provided as placeholders."
        },
        {
            "sample_id": 7532,
            "vt": "SELECT COUNT(DISTINCT T1.IMG_ID) FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct images from the 'img_obj' table that belong to a specific object class. It joins the 'img_obj' table with the 'obj_classes' table to filter images based on the object class description provided by the user."
        },
        {
            "sample_id": 7540,
            "vt": "SELECT img_obj.x, img_obj.y, img_obj.w, img_obj.h FROM img_obj WHERE img_obj.img_id = [placeholder-type:numeric] AND img_obj.obj_sample_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the x and y coordinates, width, and height of bounding boxes for objects in images from the 'img_obj' table. The placeholders in the WHERE clause represent the specific image ID and object sample ID for which the bounding box details are being queried."
        },
        {
            "sample_id": 7555,
            "vt": "SELECT obj_classes.obj_class FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID ORDER BY img_obj.h LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the object classes associated with images from the 'img_obj' table. It retrieves the 'obj_class' from the 'obj_classes' table by joining it with the 'img_obj' table based on the matching 'obj_class_id'. The results are ordered by the height of the bounding box ('h') of the objects, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 7477,
            "vt": "SELECT SUM(CASE WHEN img_rel.img_id = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM img_rel WHERE img_rel.obj1_sample_id = img_rel.obj2_sample_id",
            "ba": "The virtual table calculates the sum of a conditional expression based on the relationships between objects in images. It checks if the image ID matches a specified value and sums up the corresponding values based on the condition. The query focuses on self-relations where the sample IDs of two objects are the same, indicating that the relationship is between the same object."
        },
        {
            "sample_id": 7526,
            "vt": "SELECT img_obj.x, img_obj.y FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE img_obj.img_id = [placeholder-type:numeric] AND obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table describes the x and y coordinates of objects from the 'img_obj' table that belong to a specific object class. The query joins the 'img_obj' table with the 'obj_classes' table to filter the results based on the image ID and the object class name, using placeholders for both numeric and string values."
        },
        {
            "sample_id": 7610,
            "vt": "SELECT COUNT(att_classes.att_class) FROM att_classes INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE img_obj_att.img_id = [placeholder-type:numeric] AND att_classes.att_class = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of attribute classes associated with a specific image in the 'att_classes' table. It joins the 'att_classes' table with the 'img_obj_att' table to filter the results based on a specific image ID and a specific attribute class name."
        },
        {
            "sample_id": 7506,
            "vt": "SELECT CAST(COUNT(CASE WHEN obj_classes.obj_class = '[placeholder-type:string]' THEN img_obj.obj_sample_id ELSE NULL END) AS FLOAT) / COUNT(CASE WHEN obj_classes.obj_class = '[placeholder-type:string]' THEN img_obj.obj_sample_id ELSE NULL END) FROM obj_classes INNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID",
            "ba": "The virtual table calculates the ratio of object samples belonging to a specific object class from the 'obj_classes' and 'img_obj' tables. It counts the number of object samples that match the specified object class and divides it by the total count of object samples for that class. The placeholders represent the object class name to filter the results accordingly."
        },
        {
            "sample_id": 7587,
            "vt": "SELECT img_obj_att.img_id FROM att_classes INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE att_classes.att_class = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the image IDs from the 'img_obj_att' table that are associated with a specific attribute class from the 'att_classes' table. The placeholder in the WHERE clause represents the name of the attribute class being queried."
        },
        {
            "sample_id": 7484,
            "vt": "SELECT pred_classes.pred_class FROM pred_classes INNER JOIN IMG_REL AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE img_rel.obj1_sample_id = [placeholder-type:numeric] AND img_rel.obj2_sample_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the prediction classes associated with relationships between two objects in images. It retrieves the prediction class captions from the 'pred_classes' table by joining it with the 'img_rel' table, filtering based on the sample IDs of the two objects involved in the relationship. The placeholders represent the sample IDs of the objects being compared."
        },
        {
            "sample_id": 7473,
            "vt": "SELECT COUNT(img_obj.obj_sample_id) FROM img_obj WHERE img_obj.img_id = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of object samples associated with a specific image in the 'img_obj' table. The placeholder in the WHERE clause represents the unique identifier for the image."
        },
        {
            "sample_id": 7488,
            "vt": "SELECT img_obj.x, img_obj.y, img_obj.w, img_obj.h FROM pred_classes INNER JOIN IMG_REL AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID INNER JOIN IMG_OBJ AS T3 ON T2.OBJ1_SAMPLE_ID = T3.OBJ_CLASS_ID WHERE img_rel.img_id = [placeholder-type:numeric] AND pred_classes.pred_class = '[placeholder-type:string]'",
            "ba": "The virtual table describes the x and y coordinates, width, and height of bounding boxes for objects in images based on specific prediction classes. The query joins the 'pred_classes' table with the 'img_rel' table to establish relationships between objects and then further joins with the 'img_obj' table to retrieve the bounding box details for those objects. The placeholders represent the image ID and the prediction class name."
        },
        {
            "sample_id": 7603,
            "vt": "SELECT obj_classes.obj_class FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE img_obj.img_id = [placeholder-type:numeric] GROUP BY obj_classes.obj_class ORDER BY COUNT(obj_classes.obj_class_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the object classes associated with a specific image from the 'img_obj' table. It retrieves the object class names by joining the 'img_obj' table with the 'obj_classes' table based on the object class ID. The results are grouped by object class and ordered by the count of occurrences, allowing for a limit on the number of results returned."
        },
        {
            "sample_id": 7527,
            "vt": "SELECT img_obj.x, img_obj.y, img_obj.w, img_obj.h FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE img_obj.img_id = [placeholder-type:numeric] AND obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table describes the x, y coordinates, width, and height of bounding boxes for objects in images from the 'img_obj' table. It filters the results based on a specific image ID and the corresponding object class name."
        },
        {
            "sample_id": 7545,
            "vt": "SELECT pred_classes.pred_class FROM pred_classes WHERE pred_classes.pred_class_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the prediction classes from the 'pred_classes' table based on a specific prediction class ID. The placeholder in the WHERE clause represents the unique identifier for the prediction class."
        },
        {
            "sample_id": 7509,
            "vt": "SELECT COUNT(img_obj_att.att_class_id) FROM img_obj_att GROUP BY img_obj_att.img_id ORDER BY COUNT(img_obj_att.att_class_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of attribute classes associated with each image in the 'img_obj_att' table. It groups the results by image ID and orders them by the count of attribute classes, allowing for a limit on the number of results returned."
        },
        {
            "sample_id": 7566,
            "vt": "SELECT CAST(COUNT(img_obj.obj_sample_id) AS FLOAT) / COUNT(DISTINCT IMG_ID) FROM img_obj",
            "ba": "The virtual table calculates the average number of object samples per image from the 'img_obj' table. It does this by counting the total number of object samples and dividing it by the count of distinct image IDs."
        },
        {
            "sample_id": 7491,
            "vt": "SELECT COUNT(att_classes.att_class_id) FROM att_classes",
            "ba": "The virtual table counts the number of unique attribute classes from the 'att_classes' table."
        },
        {
            "sample_id": 7573,
            "vt": "SELECT obj_classes.obj_class FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID GROUP BY obj_classes.obj_class ORDER BY COUNT(img_obj.obj_class_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the unique object classes from the 'obj_classes' table that are associated with images in the 'img_obj' table. It retrieves the object class names by joining the two tables on their respective object class IDs, grouping the results by object class, and ordering them based on the count of occurrences in the 'img_obj' table. The placeholder in the LIMIT clause represents the maximum number of unique object classes to return."
        },
        {
            "sample_id": 7476,
            "vt": "SELECT img_obj.obj_sample_id FROM img_obj WHERE img_obj.img_id = [placeholder-type:numeric] AND img_obj.obj_class_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the object sample IDs from the 'img_obj' table for a specific image ID and object class ID. The placeholders represent the image ID and object class ID that the user can specify to filter the results accordingly."
        },
        {
            "sample_id": 7561,
            "vt": "SELECT img_obj.img_id FROM img_obj GROUP BY img_obj.img_id HAVING COUNT(img_obj.img_id) > [placeholder-type:numeric]",
            "ba": "The virtual table lists the unique image IDs from the 'img_obj' table that have more than a specified number of occurrences. This indicates that the images are associated with multiple object samples."
        },
        {
            "sample_id": 7512,
            "vt": "SELECT obj_classes.obj_class_id FROM obj_classes WHERE obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier for object classes from the 'obj_classes' table based on a specified class name. The placeholder in the WHERE clause represents the name of the object class being queried."
        },
        {
            "sample_id": 7485,
            "vt": "SELECT SUM(CASE WHEN pred_classes.pred_class = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM pred_classes INNER JOIN IMG_REL AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE img_rel.obj1_sample_id <> img_rel.obj2_sample_id",
            "ba": "The virtual table calculates the sum of a conditional expression based on the prediction class from the 'pred_classes' table. It joins the 'pred_classes' table with the 'img_rel' table to filter relationships between different object samples, ensuring that the two object samples are not the same. The placeholders represent the prediction class to check against and the numeric values to sum based on the condition."
        },
        {
            "sample_id": 7550,
            "vt": "SELECT SUM(CASE WHEN img_obj.img_id = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the sum of a specific numeric value based on a condition related to image IDs from the 'img_obj' table. It joins with the 'obj_classes' table to filter results based on the object class description. The placeholders represent the image ID and the numeric values to be summed, as well as the object class description."
        },
        {
            "sample_id": 7549,
            "vt": "SELECT COUNT(DISTINCT T1.IMG_ID) FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct images from the 'img_obj' table that belong to a specific object class. It joins the 'img_obj' table with the 'obj_classes' table to filter images based on the object class description provided by the user."
        },
        {
            "sample_id": 7609,
            "vt": "SELECT img_obj.obj_sample_id, img_obj.x, img_obj.y FROM att_classes INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID INNER JOIN IMG_OBJ AS T3 ON T2.IMG_ID = T3.IMG_ID WHERE img_obj.img_id = [placeholder-type:numeric] AND att_classes.att_class = '[placeholder-type:string]'",
            "ba": "The virtual table describes the object sample IDs along with their x and y coordinates from the 'img_obj' table, filtered by a specific image ID and attribute class. The query joins the 'att_classes' table to access the attribute class information and the 'img_obj_att' table to link images with their attributes."
        },
        {
            "sample_id": 7562,
            "vt": "SELECT img_obj.obj_sample_id FROM img_obj WHERE img_obj.img_id = [placeholder-type:numeric] ORDER BY img_obj.w LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the object sample IDs from the 'img_obj' table for a specific image ID. The results are ordered by the width of the bounding box and limited to a specified number of entries."
        },
        {
            "sample_id": 7530,
            "vt": "SELECT att_classes.att_class FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID INNER JOIN IMG_OBJ_ATT AS T3 ON T1.IMG_ID = T3.IMG_ID INNER JOIN ATT_CLASSES AS T4 ON T3.ATT_CLASS_ID = T4.ATT_CLASS_ID WHERE obj_classes.obj_class = '[placeholder-type:string]' AND img_obj.img_id = [placeholder-type:numeric] GROUP BY att_classes.att_class",
            "ba": "The virtual table describes the attribute classes associated with a specific object class and image ID. It retrieves the attribute class names from the 'att_classes' table by joining it with the 'img_obj', 'obj_classes', and 'img_obj_att' tables. The placeholders represent the object class name and the image ID for filtering the results accordingly."
        },
        {
            "sample_id": 7483,
            "vt": "SELECT SUM(CASE WHEN pred_classes.pred_class = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM pred_classes INNER JOIN IMG_REL AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE img_rel.img_id = [placeholder-type:numeric] AND img_rel.obj1_sample_id <> img_rel.obj2_sample_id",
            "ba": "The virtual table calculates the sum of a conditional expression based on the prediction class from the 'pred_classes' table. It joins the 'pred_classes' table with the 'img_rel' table to filter relationships between objects in a specific image, identified by its image ID. The condition checks if the prediction class matches a specified value, and it ensures that the two objects being compared are not the same by checking that their sample IDs are different."
        },
        {
            "sample_id": 7521,
            "vt": "SELECT pred_classes.pred_class FROM img_rel INNER JOIN pred_classes AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE img_rel.obj1_sample_id = img_rel.obj2_sample_id GROUP BY pred_classes.pred_class",
            "ba": "The virtual table describes the prediction classes associated with images that have self-relations between objects. It retrieves the prediction class captions from the 'pred_classes' table by joining it with the 'img_rel' table, filtering for cases where the sample IDs of the two objects are the same, indicating a self-relation. The results are grouped by the prediction class to avoid duplicates."
        },
        {
            "sample_id": 7581,
            "vt": "SELECT img_rel.img_id FROM img_rel GROUP BY img_rel.pred_class_id HAVING COUNT(DISTINCT OBJ1_SAMPLE_ID) <> [placeholder-type:numeric] AND COUNT(DISTINCT OBJ2_SAMPLE_ID) <> [placeholder-type:numeric]",
            "ba": "The virtual table retrieves image IDs from the 'img_rel' table, grouping the results by prediction class ID. It filters the results to include only those groups where the count of distinct sample IDs for both objects in the relationship is not equal to a specified numeric value."
        },
        {
            "sample_id": 7585,
            "vt": "SELECT COUNT(img_obj.img_id) FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of images from the 'img_obj' table that belong to a specific object class. It joins the 'img_obj' table with the 'obj_classes' table to filter images based on the class name provided in the placeholder."
        },
        {
            "sample_id": 7525,
            "vt": "SELECT img_obj.w, img_obj.h FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE img_obj.img_id = [placeholder-type:numeric] AND obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table describes the width and height of objects from the 'img_obj' table that belong to a specific object class. The placeholders in the WHERE clause represent the image ID and the object class name."
        },
        {
            "sample_id": 7596,
            "vt": "SELECT img_obj.obj_sample_id FROM img_obj WHERE img_obj.img_id = [placeholder-type:numeric] AND img_obj.x = [placeholder-type:numeric] AND img_obj.y = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the object sample IDs from the 'img_obj' table based on specific image ID and coordinates (x, y). The placeholders represent the image ID and the x and y coordinates of the bounding box for the object."
        },
        {
            "sample_id": 7502,
            "vt": "SELECT att_classes.att_class FROM img_obj_att INNER JOIN ATT_CLASSES AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID INNER JOIN IMG_OBJ AS T3 ON T1.IMG_ID = T3.IMG_ID INNER JOIN OBJ_CLASSES AS T4 ON T3.OBJ_CLASS_ID = T4.OBJ_CLASS_ID WHERE obj_classes.obj_class = '[placeholder-type:string]' AND img_obj_att.img_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the attribute classes associated with images from the 'img_obj_att' table, which links images to their attributes. It joins with the 'att_classes' table to retrieve the attribute class names, and also connects to the 'img_obj' table to access object details. The query filters results based on a specific object class and a particular image ID, represented by placeholders for user input."
        },
        {
            "sample_id": 7611,
            "vt": "SELECT obj_classes.obj_class, AVG(img_obj.w), AVG(img_obj.h) FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE img_obj.img_id = [placeholder-type:numeric] GROUP BY obj_classes.obj_class",
            "ba": "The virtual table provides the average width and height of objects from the 'img_obj' table, grouped by their corresponding class names from the 'obj_classes' table. The placeholder in the WHERE clause represents the specific image ID for which the averages are calculated."
        },
        {
            "sample_id": 7551,
            "vt": "SELECT obj_classes.obj_class_id FROM obj_classes WHERE obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the unique identifier for object classes from the 'obj_classes' table based on a specified class name. The placeholder in the WHERE clause represents the name of the object class being queried."
        },
        {
            "sample_id": 7589,
            "vt": "SELECT att_classes.att_class FROM att_classes INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE img_obj_att.img_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the attribute classes associated with a specific image from the 'att_classes' table. The query joins the 'att_classes' table with the 'img_obj_att' table to filter the results based on a specific image ID, represented by a placeholder for numeric values."
        },
        {
            "sample_id": 7507,
            "vt": "SELECT COUNT(*) FROM (SELECT img_obj_att.img_id FROM IMG_OBJ_att GROUP BY IMG_ID HAVING COUNT(ATT_CLASS_ID) > 25) AS t1",
            "ba": "The virtual table counts the number of images from the 'img_obj_att' table that have more than 25 associated attribute classes. It does this by grouping the records by 'img_id' and applying a filter to only include those groups where the count of 'att_class_id' exceeds 25."
        },
        {
            "sample_id": 7553,
            "vt": "SELECT CAST(SUM(CASE WHEN obj_classes.obj_class = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(img_obj.obj_class_id) FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE img_obj.img_id = [placeholder-type:numeric]",
            "ba": "The virtual table calculates a weighted average of a specific object class from the 'img_obj' table based on the provided image ID. It sums up values conditionally based on the object class and normalizes this sum by the count of object class IDs associated with the image. The placeholders represent the object class name, numeric values for calculations, and the image ID."
        },
        {
            "sample_id": 7519,
            "vt": "SELECT COUNT(pred_classes.pred_class_id) FROM img_rel INNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE img_rel.img_id = [placeholder-type:numeric] AND pred_classes.pred_class = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of prediction classes associated with a specific image ID from the 'img_rel' table. It joins with the 'pred_classes' table to filter based on a specific prediction class caption. The placeholders represent the image ID and the prediction class caption."
        },
        {
            "sample_id": 7575,
            "vt": "SELECT img_obj.obj_sample_id, img_obj.x, img_obj.y FROM att_classes INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID INNER JOIN IMG_OBJ AS T3 ON T2.IMG_ID = T3.IMG_ID WHERE img_obj.img_id = [placeholder-type:numeric] AND att_classes.att_class = '[placeholder-type:string]'",
            "ba": "The virtual table describes the object sample IDs along with their x and y coordinates from the 'img_obj' table, filtered by a specific image ID and attribute class. The query utilizes inner joins to connect the 'att_classes' and 'img_obj_att' tables, ensuring that only relevant attributes for the specified image are included."
        },
        {
            "sample_id": 7474,
            "vt": "SELECT COUNT((SELECT IMG_ID FROM IMG_OBJ GROUP BY IMG_ID HAVING COUNT(OBJ_SAMPLE_ID) > 20).img_id) FROM (SELECT img_obj.img_id FROM IMG_OBJ GROUP BY IMG_ID HAVING COUNT(OBJ_SAMPLE_ID) > 20) AS t1",
            "ba": "The virtual table counts the number of images from the 'img_obj' table that have more than 20 associated object samples. It first identifies the image IDs that meet this criterion by grouping the image IDs and counting the object sample IDs, then it counts how many such image IDs exist."
        },
        {
            "sample_id": 7577,
            "vt": "SELECT CAST(COUNT(img_obj.obj_sample_id) AS FLOAT) * [placeholder-type:numeric] / COUNT(CASE WHEN img_obj.img_id = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM img_obj INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE obj_classes.obj_class = '[placeholder-type:string]'",
            "ba": "The virtual table calculates a weighted count of object samples from the 'img_obj' table based on a specific object class. It uses a placeholder for a numeric value to scale the count and another placeholder for a numeric value to filter the count based on a specific image ID. Additionally, it joins with the 'obj_classes' table to ensure that only object samples belonging to a specified class are considered in the calculation."
        },
        {
            "sample_id": 7543,
            "vt": "SELECT obj_classes.obj_class FROM obj_classes WHERE obj_classes.obj_class_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the object class description from the 'obj_classes' table based on a specific object class ID. The placeholder in the WHERE clause represents the unique identifier for the object class."
        },
        {
            "sample_id": 7536,
            "vt": "SELECT pred_classes.pred_class FROM img_rel INNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE img_rel.img_id = [placeholder-type:numeric] AND img_rel.obj1_sample_id = [placeholder-type:numeric] AND img_rel.obj2_sample_id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the prediction class captions for relationships between two objects in a specific image. It joins the 'img_rel' table with the 'pred_classes' table to get the corresponding prediction class for the relationship identified by the given image ID and the two object sample IDs."
        }
    ],
    "book_publishing_company": [
        {
            "sample_id": 195,
            "vt": "SELECT authors.au_fname, authors.au_lname FROM titles INNER JOIN titleauthor AS T2 ON T1.title_id = T2.title_id INNER JOIN authors AS T3 ON T2.au_id = T3.au_id WHERE titles.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of authors associated with a specific title from the 'titles' table. It uses inner joins to connect the 'titles' table with the 'titleauthor' table to find the corresponding authors, and then retrieves their first and last names based on a specified title."
        },
        {
            "sample_id": 180,
            "vt": "SELECT publishers.pub_name, AVG(titles.ytd_sales) FROM titles INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE titles.pub_id = '[placeholder-type:string]' GROUP BY publishers.pub_name",
            "ba": "The virtual table provides the average year-to-date sales of titles grouped by publisher name from the 'titles' and 'publishers' tables. The placeholder in the WHERE clause represents the specific publisher's ID for which the average sales are being calculated."
        },
        {
            "sample_id": 184,
            "vt": "SELECT employee.fname, employee.lname FROM employee INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id WHERE employee.job_lvl = jobs.max_lvl",
            "ba": "The virtual table describes the first and last names of employees from the 'employee' table who hold the highest job level available for their respective jobs. The query joins the 'employee' table with the 'jobs' table to compare the job level of each employee with the maximum job level defined in the jobs table."
        },
        {
            "sample_id": 176,
            "vt": "SELECT titles.title, sales.qty FROM titles INNER JOIN sales AS T2 ON T1.title_id = T2.title_id INNER JOIN stores AS T3 ON T2.stor_id = T3.stor_id WHERE sales.qty > [placeholder-type:numeric] AND stores.state = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of books and their corresponding sales quantities from the 'titles' and 'sales' tables. It filters the results to show only those titles that have sales quantities exceeding a specified number and are located in a specific state. The placeholders represent the minimum sales quantity and the state name."
        },
        {
            "sample_id": 173,
            "vt": "SELECT titles.title, publishers.pub_name FROM titles INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE publishers.country = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of publications along with their corresponding publisher names from the 'titles' and 'publishers' tables. The query filters the results based on the specified country of the publisher, represented by a placeholder for string values."
        },
        {
            "sample_id": 227,
            "vt": "SELECT COUNT(sales.ord_num) FROM sales INNER JOIN stores AS T2 ON T1.stor_id = T2.stor_id WHERE stores.city = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of orders from the 'sales' table for stores located in a specific city. It joins the 'sales' table with the 'stores' table to filter the results based on the city of the stores."
        },
        {
            "sample_id": 222,
            "vt": "SELECT titles.notes FROM titles INNER JOIN sales AS T2 ON T1.title_id = T2.title_id WHERE STRFTIME('%Y-%m-%d', sales.ord_date) = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves notes associated with titles from the 'titles' table, specifically for those titles that have sales recorded on a particular order date. The query uses an inner join to connect the 'titles' table with the 'sales' table based on the title ID, ensuring that only titles with corresponding sales are considered. The placeholder in the WHERE clause represents the specific order date for which the notes are being queried."
        },
        {
            "sample_id": 215,
            "vt": "SELECT titles.royalty FROM titles ORDER BY titles.ytd_sales LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the royalty information from the 'titles' table, sorted by year-to-date sales in descending order. The placeholder in the LIMIT clause allows the user to specify the number of records to return, enabling them to focus on the top-selling titles based on their sales performance."
        },
        {
            "sample_id": 209,
            "vt": "SELECT titles.notes FROM titles INNER JOIN sales AS T2 ON T1.title_id = T2.title_id ORDER BY sales.qty LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves notes associated with titles from the 'titles' table, joining it with the 'sales' table to filter based on sales quantity. The results are ordered by the quantity of sales and limited to a specified number of entries."
        },
        {
            "sample_id": 182,
            "vt": "SELECT employee.fname, employee.lname, employee.hire_date FROM employee ORDER BY employee.job_lvl LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first names, last names, and hire dates of employees from the 'employee' table, ordered by their job level. The placeholder in the LIMIT clause represents the maximum number of records to return."
        },
        {
            "sample_id": 213,
            "vt": "SELECT titles.title FROM titles WHERE titles.type = '[placeholder-type:string]' ORDER BY titles.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles from the 'titles' table that match a specific type. The results are ordered by price, and the number of titles returned is limited by a placeholder for numeric values."
        },
        {
            "sample_id": 192,
            "vt": "SELECT authors.au_fname, authors.au_lname FROM titles INNER JOIN titleauthor AS T2 ON T1.title_id = T2.title_id INNER JOIN authors AS T3 ON T2.au_id = T3.au_id WHERE titles.type = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first names and last names of authors from the 'authors' table who have written titles of a specific type. The query joins the 'titles' table with the 'titleauthor' table to link titles to their respective authors, and filters the results based on the specified title type using a placeholder."
        },
        {
            "sample_id": 220,
            "vt": "SELECT jobs.job_desc FROM employee INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id WHERE employee.fname = '[placeholder-type:string]' AND employee.minit = '[placeholder-type:string]' AND employee.lname = '[placeholder-type:string]'",
            "ba": "The virtual table describes the job descriptions of employees from the 'employee' table based on their first name, middle initial, and last name. The placeholders in the WHERE clause represent the employee's first name, middle initial, and last name."
        },
        {
            "sample_id": 235,
            "vt": "SELECT (CAST(SUM(CASE WHEN publishers.country = '[placeholder-type:string]' THEN titles.royalty ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN publishers.country = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END)) - (CAST(SUM(CASE WHEN publishers.country <> '[placeholder-type:string]' THEN titles.royalty ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN publishers.country <> '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END)) FROM titles INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id INNER JOIN roysched AS T3 ON T1.title_id = T3.title_id",
            "ba": "The virtual table calculates the difference in average royalties between titles published in a specific country and those published outside that country. It does this by summing the royalties for titles from publishers in the specified country and dividing by the total number of titles from those publishers, then subtracting the average royalties for titles from publishers outside that country."
        },
        {
            "sample_id": 188,
            "vt": "SELECT DISTINCT publishers.pub_name, titles.type FROM titles INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id ORDER BY publishers.pub_name",
            "ba": "The virtual table displays distinct publisher names along with the types of titles they publish. It retrieves data from the 'titles' table and joins it with the 'publishers' table based on the publisher ID. The results are ordered by the publisher names to provide a clear view of the different types of titles associated with each publisher."
        },
        {
            "sample_id": 221,
            "vt": "SELECT jobs.max_lvl - employee.job_lvl FROM employee INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id WHERE employee.fname = '[placeholder-type:string]' AND employee.minit = '[placeholder-type:string]' AND employee.lname = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the difference between the maximum job level of a job and the job level of a specific employee. It retrieves this information by joining the 'employee' table with the 'jobs' table based on the job ID. The query filters the results to find a specific employee using their first name, middle initial, and last name, which are represented as placeholders."
        },
        {
            "sample_id": 186,
            "vt": "SELECT employee.fname, employee.lname, publishers.pub_name FROM employee INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE publishers.country <> '[placeholder-type:string]'",
            "ba": "The virtual table describes the first names and last names of employees along with the names of publishers they are associated with, filtered by those publishers that are not located in a specific country. The placeholders in the WHERE clause represent the country name."
        },
        {
            "sample_id": 200,
            "vt": "SELECT employee.fname FROM employee INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id WHERE jobs.job_desc = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first names of employees from the 'employee' table who hold a specific job description. The query joins the 'employee' table with the 'jobs' table to filter employees based on their job description, represented by a placeholder for string values."
        },
        {
            "sample_id": 211,
            "vt": "SELECT CAST(SUM(sales.qty) AS FLOAT) / COUNT(titles.title_id) FROM titles INNER JOIN sales AS T2 ON T1.title_id = T2.title_id WHERE titles.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average quantity sold for a specific title from the 'titles' table by summing the quantities from the 'sales' table and dividing by the count of titles. The placeholder in the WHERE clause represents the title's name."
        },
        {
            "sample_id": 191,
            "vt": "SELECT employee.fname, employee.lname, jobs.job_desc FROM employee INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id WHERE employee.job_lvl > [placeholder-type:numeric]",
            "ba": "The virtual table describes the first and last names of employees along with their job descriptions from the 'employee' and 'jobs' tables. It filters the results to include only those employees whose job level exceeds a specified numeric value."
        },
        {
            "sample_id": 204,
            "vt": "SELECT stores.stor_name FROM sales INNER JOIN stores AS T2 ON T1.stor_id = T2.stor_id INNER JOIN titles AS T3 ON T1.title_id = T3.title_id WHERE titles.title = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of stores from the 'stores' table that have made sales of a specific title. The query joins the 'sales' table with the 'stores' table to get the store names and also joins with the 'titles' table to filter based on a specific title name. The placeholder in the WHERE clause represents the title's name."
        },
        {
            "sample_id": 177,
            "vt": "SELECT stores.stor_id, titles.title FROM sales INNER JOIN titles AS T2 ON T1.title_id = T2.title_id INNER JOIN stores AS T3 ON T3.stor_id = T1.stor_id WHERE stores.stor_id = (SELECT stores.stor_id FROM sales GROUP BY stor_id ORDER BY SUM(qty) DESC LIMIT 1) GROUP BY stores.stor_id, titles.title ORDER BY SUM(sales.qty) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a list of store IDs and corresponding titles from the 'sales' and 'titles' tables. It identifies the store with the highest total sales quantity and groups the results by store ID and title. The results are ordered by the total quantity sold, with a limit specified by a placeholder for numeric values."
        },
        {
            "sample_id": 170,
            "vt": "SELECT titles.title FROM titles INNER JOIN roysched AS T2 ON T1.title_id = T2.title_id WHERE roysched.lorange = [placeholder-type:numeric] AND roysched.royalty >= [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles from the 'titles' table that have a corresponding royalty schedule in the 'roysched' table. It filters the results based on a specified low range and a minimum royalty amount, both represented by placeholders for numeric values."
        },
        {
            "sample_id": 230,
            "vt": "SELECT employee.fname, employee.minit, employee.lname FROM employee WHERE STRFTIME('%Y', employee.hire_date) BETWEEN '[placeholder-type:string]' AND '[placeholder-type:string]' ORDER BY employee.job_lvl",
            "ba": "The virtual table describes the first name, middle initial, and last name of employees from the 'employee' table who were hired within a specific date range. The placeholders in the WHERE clause represent the start and end years of the hiring period."
        },
        {
            "sample_id": 229,
            "vt": "SELECT CAST(SUM(CASE WHEN jobs.job_desc = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN jobs.job_desc = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(employee.job_id) FROM employee INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id",
            "ba": "The virtual table calculates a specific metric based on job descriptions from the 'jobs' table and employee job levels from the 'employee' table. It sums up values conditionally based on the job description and applies a formula to derive a result, which is then normalized by the count of employees in the specified job category. The placeholders represent the job description, numeric values for calculations, and a multiplier for the final result."
        },
        {
            "sample_id": 216,
            "vt": "SELECT employee.job_lvl FROM employee WHERE employee.lname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the job level of employees from the 'employee' table based on the last name of the employee. The placeholder in the WHERE clause represents the last name of the employee being queried."
        },
        {
            "sample_id": 187,
            "vt": "SELECT employee.fname, employee.lname, jobs.job_desc FROM employee INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id INNER JOIN jobs AS T3 ON T1.job_id = T3.job_id WHERE publishers.pub_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first and last names of employees along with their job descriptions from the 'employee' table, filtered by a specific publisher's name. The placeholders in the WHERE clause represent the publisher's name."
        },
        {
            "sample_id": 201,
            "vt": "SELECT jobs.max_lvl FROM employee INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id ORDER BY employee.hire_date LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the maximum job level from the 'jobs' table for employees in the 'employee' table. It joins the two tables based on the job ID, ensuring that only relevant job levels for each employee are considered. The results are ordered by the hire date of the employees, and a limit is applied to restrict the number of records returned based on a specified numeric value."
        },
        {
            "sample_id": 185,
            "vt": "SELECT employee.fname, employee.lname, employee.hire_date FROM employee INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id WHERE jobs.job_desc = '[placeholder-type:string]'",
            "ba": "The virtual table describes the first name, last name, and hire date of employees from the 'employee' table who hold a specific job description. The query joins the 'employee' table with the 'jobs' table to filter employees based on their job description, represented by a placeholder for string values."
        },
        {
            "sample_id": 197,
            "vt": "SELECT titles.title FROM titles INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE titles.ytd_sales > (SELECT AVG(titles.ytd_sales) FROM titles)",
            "ba": "The virtual table lists the titles of books from the 'titles' table that have year-to-date sales greater than the average sales of all titles. It joins the 'titles' table with the 'publishers' table to potentially include publisher information, although only the title is selected in the output."
        },
        {
            "sample_id": 232,
            "vt": "SELECT DISTINCT titles.title, titles.type, titles.price FROM titles INNER JOIN sales AS T2 ON T1.title_id = T2.title_id WHERE sales.ord_date LIKE '[placeholder-type:string]' AND sales.qty < (SELECT CAST(SUM(sales.qty) AS FLOAT) / COUNT(titles.title_id) FROM titles AS T3 INNER JOIN sales AS T4 ON T3.title_id = T4.title_id)",
            "ba": "The virtual table describes the distinct titles, types, and prices of titles from the 'titles' table that have been sold. It filters the results based on a specific order date and ensures that the quantity sold is less than the average quantity sold for all titles. The placeholder in the WHERE clause represents the order date."
        },
        {
            "sample_id": 171,
            "vt": "SELECT titles.title, roysched.royalty FROM titles INNER JOIN roysched AS T2 ON T1.title_id = T2.title_id WHERE roysched.lorange > [placeholder-type:numeric] AND roysched.hirange < [placeholder-type:numeric] AND titles.title_id = '[placeholder-type:string]'",
            "ba": "The virtual table displays the titles and their corresponding royalty rates from the 'titles' and 'roysched' tables. It filters the results based on a specified range of royalty values, ensuring that the low range is greater than a certain numeric value and the high range is less than another numeric value. Additionally, it restricts the results to a specific title identified by its title ID."
        },
        {
            "sample_id": 189,
            "vt": "SELECT publishers.pub_name FROM titles INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE STRFTIME('%Y', titles.pubdate) = '[placeholder-type:string]' GROUP BY titles.pub_id, publishers.pub_name ORDER BY COUNT(titles.title_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of publishers from the 'publishers' table who have published titles in a specific year. The query joins the 'titles' table with the 'publishers' table based on the publisher ID, filters the results by the publication year using a placeholder, groups the results by publisher name, and orders them by the count of titles published, limiting the output to a specified number of publishers."
        },
        {
            "sample_id": 237,
            "vt": "SELECT titles.title, publishers.pub_name, titles.price FROM titles INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE titles.notes = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of publications along with their corresponding publisher names and prices from the 'titles' and 'publishers' tables. The query filters the results based on specific notes associated with the titles, using a placeholder for the notes value."
        },
        {
            "sample_id": 202,
            "vt": "SELECT stores.city FROM sales INNER JOIN stores AS T2 ON T1.stor_id = T2.stor_id GROUP BY stores.city ORDER BY SUM(sales.qty) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the cities of stores from the 'stores' table, which are associated with sales records. It aggregates the sales quantities for each city and orders them by the total quantity sold, limiting the results to a specified number of cities."
        },
        {
            "sample_id": 206,
            "vt": "SELECT publishers.country FROM titles INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE titles.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the country of publishers associated with a specific title from the 'titles' table. It uses an inner join to connect the 'titles' table with the 'publishers' table based on the publisher ID. The placeholder in the WHERE clause represents the title of the work being queried."
        },
        {
            "sample_id": 183,
            "vt": "SELECT STRFTIME('%Y', employee.hire_date) FROM employee GROUP BY STRFTIME('%Y', employee.hire_date) ORDER BY COUNT(employee.emp_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of the number of employees hired each year from the 'employee' table. It groups the results by the year extracted from the 'hire_date' column and orders them by the count of employees hired in each year. The placeholder in the LIMIT clause allows for specifying the maximum number of years to display."
        },
        {
            "sample_id": 219,
            "vt": "SELECT employee.fname, employee.minit, employee.lname FROM employee INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id ORDER BY employee.job_lvl LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the first name, middle initial, and last name of employees from the 'employee' table who are associated with their respective job descriptions from the 'jobs' table. The results are ordered by the job level of the employees, and a limit is applied to control the number of records returned."
        },
        {
            "sample_id": 225,
            "vt": "SELECT publishers.pub_name FROM titles INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE titles.title = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of publishers from the 'publishers' table that are associated with a specific title from the 'titles' table. The placeholder in the WHERE clause represents the title of the book or publication."
        },
        {
            "sample_id": 168,
            "vt": "SELECT titles.title FROM sales INNER JOIN titles AS T2 ON T1.title_id = T2.title_id WHERE STRFTIME('%Y', sales.ord_date) = '[placeholder-type:string]' ORDER BY sales.qty LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table presents the titles of books sold from the 'sales' table, filtered by the year of the order date. It joins the 'sales' table with the 'titles' table to retrieve the corresponding book titles. The placeholders allow users to specify the year for filtering and the limit on the number of results returned."
        },
        {
            "sample_id": 224,
            "vt": "SELECT pub_info.pr_info FROM pub_info INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE publishers.country = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the publisher's information from the 'pub_info' table for publishers located in a specific country. The query uses an INNER JOIN to connect the 'pub_info' table with the 'publishers' table based on the publisher ID, ensuring that only relevant records are selected based on the specified country."
        },
        {
            "sample_id": 178,
            "vt": "SELECT titles.title, publishers.pub_name, roysched.lorange, roysched.hirange, roysched.royalty FROM titles INNER JOIN roysched AS T2 ON T1.title_id = T2.title_id INNER JOIN publishers AS T3 ON T1.pub_id = T3.pub_id WHERE titles.title_id = '[placeholder-type:string]'",
            "ba": "The virtual table provides information about titles, their associated publishers, and the royalty schedule for each title. It includes the title name, publisher name, low and high royalty ranges, and the royalty percentage. The query filters results based on a specific title ID."
        },
        {
            "sample_id": 226,
            "vt": "SELECT publishers.city FROM employee INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE employee.fname = '[placeholder-type:string]' AND employee.minit = '[placeholder-type:string]' AND employee.lname = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the city of publishers associated with employees based on their first name, middle initial, and last name. It joins the 'employee' table with the 'publishers' table using the publisher ID to establish the relationship between employees and their respective publishers."
        }
    ],
    "cars": [
        {
            "sample_id": 3072,
            "vt": "SELECT COUNT(*) FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID WHERE data.acceleration > [placeholder-type:numeric] AND price.price BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of cars from the 'data' table that have an acceleration greater than a specified value and whose price falls within a specified range. It joins the 'data' table with the 'price' table on the car ID to access both acceleration and price information."
        },
        {
            "sample_id": 3144,
            "vt": "SELECT COUNT(production.model_year) FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID WHERE data.horsepower > [placeholder-type:numeric] AND production.model_year = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of car models produced in a specific year that have a horsepower greater than a specified value. It combines data from the 'data' and 'production' tables using their common ID, filtering based on horsepower and model year."
        },
        {
            "sample_id": 3093,
            "vt": "SELECT price.price FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID ORDER BY data.displacement / data.cylinders LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the prices of cars from the 'price' table, while joining with the 'data' table to access additional car attributes. The results are ordered by the calculated sweep volume, which is derived from the engine displacement divided by the number of cylinders, and limited to a specified number of entries."
        },
        {
            "sample_id": 3116,
            "vt": "SELECT DISTINCT price.price, country.country FROM price INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country INNER JOIN data AS T4 ON T4.ID = T1.ID WHERE data.car_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the distinct prices of cars along with their origin countries from the 'price' and 'country' tables. It joins the 'production' and 'data' tables to filter results based on a specific car name, represented by a placeholder."
        },
        {
            "sample_id": 3088,
            "vt": "SELECT country.country FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country ORDER BY data.horsepower LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of countries associated with cars from the 'data' table, joining it with the 'production' table to link car IDs and model years, and further joining with the 'country' table to get the country names. The results are ordered by the horsepower of the cars, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 3111,
            "vt": "SELECT production.model_year FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID ORDER BY data.weight LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the model years of cars from the 'production' table, which are joined with the 'data' table based on their unique IDs. The results are ordered by the weight of the cars, and a limit is applied to restrict the number of results returned."
        },
        {
            "sample_id": 3086,
            "vt": "SELECT data.cylinders FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID ORDER BY price.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the number of cylinders for cars from the 'data' table, joining it with the 'price' table to access the price information. The results are ordered by the car price in ascending order, and a limit is applied to restrict the number of records returned based on a specified numeric value."
        },
        {
            "sample_id": 3130,
            "vt": "SELECT COUNT(DISTINCT T2.model_year) FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID WHERE data.car_name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the distinct model years of cars from the 'data' table that match a specific car name. It joins the 'data' table with the 'production' table to ensure that only relevant records are considered based on the car's ID. The placeholder in the WHERE clause represents the name of the car being queried."
        },
        {
            "sample_id": 3127,
            "vt": "SELECT data.id, data.car_name, country.country FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE production.model_year = [placeholder-type:numeric] ORDER BY data.cylinders LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the unique identifiers and names of cars along with their origin countries from the 'data', 'production', and 'country' tables. It filters the results based on the model year of the cars and orders them by the number of cylinders, with a limit on the number of results returned."
        },
        {
            "sample_id": 3094,
            "vt": "SELECT data.car_name FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE country.country = '[placeholder-type:string]' ORDER BY data.horsepower LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of cars from the 'data' table that are produced in a specific country. It joins the 'data' table with the 'production' table to link car IDs and then further joins with the 'country' table to filter by the country name. The results are ordered by horsepower and limited to a specified number of entries."
        },
        {
            "sample_id": 3121,
            "vt": "SELECT data.car_name, data.model, data.displacement / data.cylinders, production.model_year FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID ORDER BY data.weight LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the car name, model year, engine displacement per cylinder, and the model year of the car from the 'data' and 'production' tables. The query joins these tables based on the car ID and orders the results by the weight of the car, limiting the output to a specified number of records."
        },
        {
            "sample_id": 3118,
            "vt": "SELECT SUM(CASE WHEN production.model_year = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN production.model_year = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID WHERE data.horsepower = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the difference in sums of certain numeric values based on the model year of cars from the 'production' table. It uses conditional aggregation to sum values for specific model years and filters the results based on the horsepower of the cars from the 'data' table. The placeholders represent the model years and numeric values that can be specified by the user."
        },
        {
            "sample_id": 3091,
            "vt": "SELECT data.car_name FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID ORDER BY price.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of cars from the 'data' table, joining it with the 'price' table to access the price information. The results are ordered by the car price in ascending order, and a limit is applied to restrict the number of car names returned based on a specified numeric value."
        },
        {
            "sample_id": 3099,
            "vt": "SELECT COUNT(*) FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID WHERE data.displacement > [placeholder-type:numeric] AND price.price > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of cars from the 'data' table that have a displacement greater than a specified value and a price greater than a specified value. It joins the 'data' table with the 'price' table on the car ID to filter the results based on both displacement and price criteria."
        },
        {
            "sample_id": 3133,
            "vt": "SELECT AVG(price.price) FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID WHERE data.model = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average price of cars from the 'price' table that have a specific model year. It joins the 'data' and 'price' tables on their unique car ID to ensure that the data corresponds to the correct car prices. The placeholder in the WHERE clause represents the model year of the cars being queried."
        },
        {
            "sample_id": 3123,
            "vt": "SELECT data.car_name, data.model FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID ORDER BY price.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the car names and their model years from the 'data' table, joined with the 'price' table to include the price information. The results are ordered by the price of the cars, and a limit is applied to restrict the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 3100,
            "vt": "SELECT production.model_year FROM production INNER JOIN country AS T2 ON T1.country = T2.origin WHERE country.country = '[placeholder-type:string]' GROUP BY production.model_year ORDER BY COUNT(production.model_year) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the model years of cars produced in a specific country by joining the 'production' table with the 'country' table. It filters the results based on the country name provided as a placeholder, groups the results by model year, and orders them by the count of occurrences, limiting the output to a specified number of results."
        },
        {
            "sample_id": 3105,
            "vt": "SELECT data.car_name FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID WHERE production.model_year = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of cars from the 'data' table that were introduced in a specific model year. The query uses an INNER JOIN to connect the 'data' table with the 'production' table based on the car ID, ensuring that only cars matching the specified model year are selected."
        },
        {
            "sample_id": 3125,
            "vt": "SELECT AVG(price.price) FROM price INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE country.country = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average price of cars from a specific country by joining the 'price', 'production', and 'country' tables. It filters the results based on the country name provided as a placeholder."
        },
        {
            "sample_id": 3132,
            "vt": "SELECT CAST(COUNT(T1.ID) AS FLOAT) / 9 FROM production AS T1 INNER JOIN data AS T2 ON T2.ID = T1.ID WHERE T1.model_year BETWEEN 1971 AND 1980 UNION ALL SELECT DISTINCT T2.car_name FROM production AS T1 INNER JOIN data AS T2 ON T2.ID = T1.ID WHERE T1.model_year BETWEEN 1971 AND 1980 AND T2.weight < 1800",
            "ba": "The virtual table provides two sets of information regarding cars produced between 1971 and 1980. The first part calculates the average number of cars produced during this period by counting the total number of unique car IDs and dividing by 9. The second part retrieves distinct car names from the same period, specifically those that weigh less than 1800 lbs."
        },
        {
            "sample_id": 3112,
            "vt": "SELECT data.horsepower, production.model_year FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID WHERE data.car_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the horsepower and model year of cars from the 'data' and 'production' tables. It retrieves this information by joining the two tables on their unique car ID. The placeholder in the WHERE clause represents the specific name of the car being queried."
        },
        {
            "sample_id": 3107,
            "vt": "SELECT price.price FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID WHERE data.id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the price of a specific car from the 'price' table by joining it with the 'data' table based on the car's unique ID. The placeholder in the WHERE clause represents the unique ID of the car for which the price is being queried."
        },
        {
            "sample_id": 3104,
            "vt": "SELECT CAST(SUM(CASE WHEN country.country = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE data.displacement / data.cylinders > [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average price of cars from a specific country, considering only those cars that have a higher fuel efficiency based on their displacement and number of cylinders. The placeholders represent the country name, price, and fuel efficiency criteria."
        },
        {
            "sample_id": 3081,
            "vt": "SELECT country.country FROM price INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE price.price = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the origin country of cars from the 'country' table based on their price. It joins the 'price' table with the 'production' table to link car IDs and then further joins with the 'country' table to get the corresponding country name. The placeholder in the WHERE clause represents the specific price of the car."
        },
        {
            "sample_id": 3080,
            "vt": "SELECT DISTINCT country.country FROM production INNER JOIN country AS T2 ON T1.country = T2.origin WHERE production.id = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves a distinct list of countries from the 'country' table that are associated with a specific car model in the 'production' table. The placeholder in the WHERE clause represents the unique ID of the car."
        },
        {
            "sample_id": 3098,
            "vt": "SELECT data.car_name FROM price INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country INNER JOIN data AS T4 ON T4.ID = T1.ID WHERE country.country = '[placeholder-type:string]' ORDER BY price.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of cars from the 'data' table that are produced in a specific country, while also considering their prices. It joins multiple tables: 'price' to access car prices, 'production' to link cars to their production details, and 'country' to filter by the origin country. The results are ordered by price and limited to a specified number of entries."
        },
        {
            "sample_id": 3075,
            "vt": "SELECT AVG(price.price) FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID WHERE data.cylinders = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average price of cars from the 'price' table that have a specific number of cylinders, by joining it with the 'data' table to filter based on the cylinder count."
        },
        {
            "sample_id": 3131,
            "vt": "SELECT CAST(SUM(CASE WHEN country.country = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(*) FROM production INNER JOIN country AS T2 ON T1.country = T2.origin",
            "ba": "The virtual table calculates the average price of cars from a specific country by summing the prices of cars that belong to that country and dividing by the total count of cars. The placeholders represent the country name, the price of the car, and a numeric value for scaling the result."
        },
        {
            "sample_id": 3108,
            "vt": "SELECT COUNT(*) FROM price INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country INNER JOIN data AS T4 ON T4.ID = T1.ID WHERE country.country = '[placeholder-type:string]' AND data.weight < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of cars from a specific country that weigh less than a specified weight. It combines data from multiple tables: 'price', 'production', 'country', and 'data'. The query filters results based on the country name and the weight of the cars."
        },
        {
            "sample_id": 3122,
            "vt": "SELECT data.car_name, data.horsepower FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE production.model_year = [placeholder-type:numeric] AND country.country = '[placeholder-type:string]'",
            "ba": "The virtual table describes the car names and their associated horsepower from the 'data' table, filtered by the model year and the country of origin. The placeholders in the WHERE clause represent the specific model year and country name."
        },
        {
            "sample_id": 3069,
            "vt": "SELECT DISTINCT data.car_name FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T2.country = T3.origin WHERE country.country = '[placeholder-type:string]'",
            "ba": "The virtual table lists the distinct names of cars from the 'data' table that are produced in a specific country. It joins the 'data' table with the 'production' table to link car IDs and then joins with the 'country' table to filter by the specified country name."
        },
        {
            "sample_id": 3142,
            "vt": "SELECT production.model_year FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID WHERE data.car_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the model year of cars from the 'production' table by joining it with the 'data' table based on their unique car IDs. The query filters the results to include only those cars that match a specific car name provided as a placeholder."
        },
        {
            "sample_id": 3074,
            "vt": "SELECT MAX(data.acceleration) FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID WHERE price.price > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the maximum acceleration of cars from the 'data' table, filtering for those cars that have a price greater than a specified value. The query joins the 'data' table with the 'price' table to access the price information associated with each car."
        },
        {
            "sample_id": 3076,
            "vt": "SELECT MAX(data.displacement / data.cylinders) FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID WHERE price.price < [placeholder-type:numeric]",
            "ba": "The virtual table calculates the maximum engine sweep volume of cars from the 'data' table, which is derived by dividing the engine displacement by the number of cylinders. It filters the results to include only those cars whose price is below a specified threshold. The query joins the 'data' table with the 'price' table to access the price information for each car."
        },
        {
            "sample_id": 3140,
            "vt": "SELECT COUNT(*) FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE country.country = '[placeholder-type:string]' AND data.weight > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of cars from the 'data' table that are produced in a specific country and have a weight greater than a specified value. It joins the 'data', 'production', and 'country' tables to filter the results based on the country name and the weight of the cars."
        },
        {
            "sample_id": 3129,
            "vt": "SELECT data.car_name, price.price FROM price INNER JOIN data AS T2 ON T1.ID = T2.ID WHERE data.model = [placeholder-type:numeric] AND data.mpg > [placeholder-type:numeric]",
            "ba": "The virtual table describes the names and prices of cars from the 'price' and 'data' tables. It filters the results based on the model year of the car and ensures that only cars with a mileage greater than a specified value are included. The placeholders in the WHERE clause represent the model year and the minimum mileage required."
        },
        {
            "sample_id": 3087,
            "vt": "SELECT data.id, price.price FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID ORDER BY data.weight LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique ID and price of cars from the 'data' and 'price' tables. It joins these tables on their ID columns to combine relevant information about each car. The results are ordered by the weight of the cars, and a limit is applied to restrict the number of records returned based on a specified numeric value."
        },
        {
            "sample_id": 3066,
            "vt": "SELECT price.price FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID WHERE data.car_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the price of a specific car from the 'price' table by joining it with the 'data' table based on the car's unique ID. The placeholder in the WHERE clause represents the name of the car for which the price is being queried."
        },
        {
            "sample_id": 3143,
            "vt": "SELECT country.country FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country INNER JOIN price AS T4 ON T4.ID = T1.ID WHERE production.model_year = [placeholder-type:numeric] ORDER BY price.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the names of countries associated with cars from the 'data' table, filtered by the model year of the car and ordered by the price of the cars. The placeholders represent the model year and the limit for the number of results returned."
        },
        {
            "sample_id": 3146,
            "vt": "SELECT AVG(data.weight) FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE production.model_year BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric] AND data.cylinders = [placeholder-type:numeric] AND country.country = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average weight of cars from the 'data' table, filtered by a specific model year range and the number of cylinders. It joins the 'production' table to access the model year and the 'country' table to filter by the country of origin. The placeholders represent the model year range, the number of cylinders, and the country name."
        },
        {
            "sample_id": 3070,
            "vt": "SELECT data.car_name FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID ORDER BY price.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of cars from the 'data' table, which are joined with the 'price' table to access their corresponding prices. The results are ordered by the price of the cars in ascending order, and a limit is applied to restrict the number of results returned based on a specified numeric value."
        },
        {
            "sample_id": 3063,
            "vt": "SELECT data.car_name FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID WHERE data.cylinders = [placeholder-type:numeric] ORDER BY price.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of cars from the 'data' table that have a specific number of cylinders. It joins the 'data' table with the 'price' table to filter the results based on the number of cylinders and orders them by price, limiting the number of results returned."
        },
        {
            "sample_id": 3115,
            "vt": "SELECT COUNT(*) FROM price INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE country.country = '[placeholder-type:string]' AND price.price > [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of cars from a specific country that have a price above a certain threshold. It joins the 'price', 'production', and 'country' tables to filter the results based on the country name and the car price."
        },
        {
            "sample_id": 3071,
            "vt": "SELECT DISTINCT production.model_year FROM production INNER JOIN data AS T2 ON T1.ID = T2.ID WHERE data.car_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct model years of cars from the 'production' table, joining it with the 'data' table to filter results based on a specific car name. The placeholder in the WHERE clause represents the name of the car being queried."
        },
        {
            "sample_id": 3068,
            "vt": "SELECT COUNT(*) FROM production INNER JOIN country AS T2 ON T1.country = T2.origin WHERE production.model_year = [placeholder-type:numeric] AND country.country = '[placeholder-type:string]'",
            "ba": "The virtual table provides a count of cars produced in a specific model year from a specific country. It joins the 'production' table with the 'country' table to filter the results based on the model year and the country of origin."
        },
        {
            "sample_id": 3101,
            "vt": "SELECT price.price FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID WHERE data.car_name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the price of a specific car from the 'price' table by joining it with the 'data' table based on the car's unique ID. The placeholder in the WHERE clause represents the name of the car for which the price is being queried."
        },
        {
            "sample_id": 3139,
            "vt": "SELECT COUNT(*) FROM data INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE country.country = '[placeholder-type:string]' AND data.acceleration < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of cars from the 'data' table that meet specific criteria based on their country of origin and acceleration. It joins the 'data', 'production', and 'country' tables to filter cars from a specified country and with an acceleration value below a certain threshold."
        },
        {
            "sample_id": 3102,
            "vt": "SELECT data.acceleration FROM price INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country INNER JOIN data AS T4 ON T4.ID = T1.ID WHERE country.country = '[placeholder-type:string]' ORDER BY price.price LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the acceleration of cars from the 'data' table, filtered by the country of origin from the 'country' table. It joins multiple tables: 'price' to get the car prices, 'production' to link the car models with their respective countries, and 'data' to access specific car attributes. The results are ordered by price and limited to a specified number of entries."
        },
        {
            "sample_id": 3117,
            "vt": "SELECT data.car_name FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID WHERE price.price * [placeholder-type:numeric] > (SELECT AVG(price.price) * [placeholder-type:numeric] FROM price)",
            "ba": "The virtual table describes the names of cars from the 'data' table that have a price greater than a specified multiple of the average price of all cars. The query uses an inner join to connect the 'data' and 'price' tables based on the car ID, and it applies a condition to filter the results based on the price comparison."
        },
        {
            "sample_id": 3064,
            "vt": "SELECT COUNT(data.car_name) FROM data INNER JOIN price AS T2 ON T1.ID = T2.ID WHERE data.weight > [placeholder-type:numeric] AND price.price < [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of cars from the 'data' table that meet specific criteria regarding their weight and price. It joins the 'data' table with the 'price' table based on the car ID to access both the weight and price information. The placeholders in the WHERE clause represent the minimum weight and maximum price thresholds for filtering the results."
        }
    ],
    "law_episode": [
        {
            "sample_id": 1247,
            "vt": "SELECT episode.title FROM episode INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE keyword.keyword = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of episodes from the 'episode' table that are associated with a specific keyword. The query uses an inner join with the 'keyword' table to filter episodes based on the provided keyword, represented by a placeholder."
        },
        {
            "sample_id": 1325,
            "vt": "SELECT episode.title, episode.air_date FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Person AS T3 ON T3.person_id = T2.person_id WHERE credit.category = '[placeholder-type:string]' AND credit.role = '[placeholder-type:string]' AND person.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles and air dates of episodes from the 'episode' table that are associated with specific credits. It filters the results based on the credit category, the role of the person in the episode, and the name of the person involved. The placeholders represent the specific values for credit category, role, and person's name."
        },
        {
            "sample_id": 1320,
            "vt": "SELECT award.organization, award.year, award.award, award.award_category FROM person INNER JOIN Award AS T2 ON T1.person_id = T2.person_id WHERE person.name = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table describes the organizations, years, specific awards, and award categories associated with a person based on their name and the result of their award nomination. The placeholders in the WHERE clause represent the person's name and the result of the award nomination (either 'Nominee' or 'Winner')."
        },
        {
            "sample_id": 1294,
            "vt": "SELECT COUNT(episode.episode_id) FROM episode INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE episode.episode = [placeholder-type:numeric] AND vote.stars = [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of episodes from the 'episode' table that have received a specific rating from viewers. It joins the 'episode' table with the 'vote' table to filter episodes based on their sequential number within a season and the number of stars given by viewers. The placeholders represent the specific episode number and the star rating."
        },
        {
            "sample_id": 1351,
            "vt": "SELECT episode.title FROM episode INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id GROUP BY episode.title ORDER BY SUM(episode.votes) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table presents the titles of episodes from the 'episode' table, which are aggregated based on the total number of votes received. The query joins the 'episode' table with the 'vote' table to access the voting data, groups the results by episode title, and orders them by the sum of votes in descending order. A placeholder is included to limit the number of results returned, allowing users to specify how many episode titles they wish to retrieve."
        },
        {
            "sample_id": 1287,
            "vt": "SELECT award.organization FROM person INNER JOIN Award AS T2 ON T1.person_id = T2.person_id WHERE person.name = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]' GROUP BY award.organization ORDER BY COUNT(award.award_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the organizations that have nominated a person for awards, filtered by the person's name and the result of the nomination. The results are grouped by organization and ordered by the count of awards, with a limit on the number of organizations returned."
        },
        {
            "sample_id": 1333,
            "vt": "SELECT person.name FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Person AS T3 ON T3.person_id = T2.person_id WHERE episode.episode = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of persons who have credits in a specific episode of a series. It retrieves data from the 'episode' table and joins it with the 'credit' table to find the relevant credits associated with that episode. The placeholder in the WHERE clause represents the specific episode number within a season."
        },
        {
            "sample_id": 1315,
            "vt": "SELECT CAST(SUM(vote.stars) AS FLOAT) / COUNT(credit.episode_id) FROM person INNER JOIN Credit AS T2 ON T1.person_id = T2.person_id INNER JOIN Vote AS T3 ON T2.episode_id = T3.episode_id WHERE vote.stars = [placeholder-type:numeric] AND person.name = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the average rating of episodes based on viewer votes for a specific person. It joins the 'person' table with the 'credit' table to find the episodes in which the person has credits, and then it joins with the 'vote' table to get the stars given by viewers for those episodes. The result is filtered by a specific number of stars and the person's name."
        },
        {
            "sample_id": 1259,
            "vt": "SELECT episode.title FROM vote INNER JOIN Episode AS T2 ON T2.episode_id = T1.episode_id WHERE vote.stars = [placeholder-type:numeric] ORDER BY vote.votes LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table presents the titles of episodes from the 'episode' table that have received a specific number of stars from viewers. The query joins the 'vote' table to filter episodes based on viewer ratings, using placeholders for the number of stars and the limit on the number of results returned."
        },
        {
            "sample_id": 1321,
            "vt": "SELECT t3.years, t3.episode_id FROM (SELECT DISTINCT award.year, award.episode_id, ROW_NUMBER() OVER (PARTITION BY award.episode_id ORDER BY award.year) FROM Person AS T1 INNER JOIN Award AS T2 ON T1.person_id = T2.person_id WHERE T2.award = 'Television' AND T2.award_category = 'Silver Gavel Award' AND T1.name = 'Constantine Makris' AND T2.result = 'Winner' AND T2.organization = 'American Bar Association Silver Gavel Awards for Media and the Arts') AS t3 GROUP BY t3.episode_id HAVING COUNT(t3.years - t3.rm) >= [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the years and episode IDs of episodes that have won the 'Silver Gavel Award' for 'Television' by the person named 'Constantine Makris'. It filters the awards based on the specified criteria and groups the results by episode ID, ensuring that only episodes with a certain number of awards are included."
        },
        {
            "sample_id": 1319,
            "vt": "SELECT person.name, award.role FROM person INNER JOIN Award AS T2 ON T1.person_id = T2.person_id WHERE award.year = [placeholder-type:numeric] AND award.award_category = '[placeholder-type:string]' AND award.award = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of persons and their roles from the 'person' table who have received nominations for a specific award in a given year and category. The placeholders in the WHERE clause represent the year, award category, and specific award name."
        },
        {
            "sample_id": 1330,
            "vt": "SELECT CAST(SUM(CASE WHEN credit.category = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) * [placeholder-type:numeric] / COUNT(credit.category), award.role FROM award INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Episode AS T3 ON T2.episode_id = T3.episode_id INNER JOIN Person AS T4 ON T2.person_id = T4.person_id WHERE episode.episode = [placeholder-type:numeric] AND person.birth_country = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the weighted average of credits for a specific category of roles in episodes of a series, filtered by the episode number and the birth country of the person associated with the credits. The placeholders represent the category of credit, the episode number, and the birth country of the person."
        },
        {
            "sample_id": 1300,
            "vt": "SELECT episode.title FROM episode ORDER BY episode.rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the titles of episodes from the 'episode' table, ordered by their ratings in descending order. The placeholder in the LIMIT clause indicates the maximum number of episode titles to return."
        },
        {
            "sample_id": 1272,
            "vt": "SELECT COUNT(person.person_id) FROM person INNER JOIN Award AS T2 ON T1.person_id = T2.person_id WHERE award.result = '[placeholder-type:string]' GROUP BY person.person_id HAVING COUNT(award.award_id) >= [placeholder-type:numeric]",
            "ba": "The virtual table counts the number of unique persons who have received a specific award result from the 'award' table. It joins the 'person' table with the 'award' table based on the person ID, filters the results based on the award result using a placeholder for string values, and groups the results by person ID. Additionally, it only includes persons who have received a certain number of awards, specified by a numeric placeholder."
        },
        {
            "sample_id": 1257,
            "vt": "SELECT credit.credited FROM credit INNER JOIN Person AS T2 ON T2.person_id = T1.person_id WHERE person.name = '[placeholder-type:string]' AND credit.episode_id = '[placeholder-type:string]'",
            "ba": "The virtual table displays whether a specific person's credit was shown in the episode credits for a given episode. It retrieves this information by joining the 'credit' table with the 'person' table based on the person's ID, filtering by the person's name and the episode ID."
        },
        {
            "sample_id": 1289,
            "vt": "SELECT COUNT(credit.person_id) FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]' AND credit.credited = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of credited individuals for a specific episode title from the 'episode' table. It filters the results based on whether the credit was displayed in the episode's credits, using placeholders for both the episode title and the credited status."
        },
        {
            "sample_id": 1310,
            "vt": "SELECT award.role FROM person INNER JOIN Award AS T2 ON T1.person_id = T2.person_id WHERE award.result = '[placeholder-type:string]' AND person.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the roles of individuals who have been nominated for awards in relation to their participation in episodes. It filters the results based on the nomination result (e.g., whether they were a nominee or winner) and the name of the person."
        },
        {
            "sample_id": 1349,
            "vt": "SELECT person.birthdate FROM award INNER JOIN Person AS T2 ON T1.person_id = T2.person_id WHERE award.role = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the birthdates of individuals who have been nominated for an award in a specific role. It joins the 'award' table with the 'person' table to link the award nominations to the corresponding individuals, filtering the results based on the specified role."
        },
        {
            "sample_id": 1305,
            "vt": "SELECT SUM(vote.votes) FROM episode INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total number of votes received for a specific episode from the 'episode' table. It joins the 'episode' table with the 'vote' table to aggregate the votes based on the episode's title, which is specified by a placeholder."
        },
        {
            "sample_id": 1307,
            "vt": "SELECT DISTINCT award.year FROM award INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves distinct years of award nominations for episodes of a series based on the episode title and the result of the award nomination. The placeholders represent the specific title of the episode and the result status (Nominee or Winner)."
        },
        {
            "sample_id": 1275,
            "vt": "SELECT person.name FROM credit INNER JOIN Person AS T2 ON T2.person_id = T1.person_id WHERE credit.role = '[placeholder-type:string]' ORDER BY person.height_meters LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of persons who have been credited for a specific role in episodes from the 'credit' table. The query joins the 'credit' table with the 'person' table to retrieve the names of individuals based on their role, which is specified by a placeholder. Additionally, the results are ordered by the height of the persons, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 1314,
            "vt": "SELECT person.name FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Person AS T3 ON T3.person_id = T2.person_id WHERE episode.episode = [placeholder-type:numeric] AND episode.season = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of persons who have credits in specific episodes of a series. It retrieves data from the 'episode' table and joins it with the 'credit' table to find the relevant persons based on the episode's sequential number and season. The placeholders in the WHERE clause represent the specific episode number and season number."
        },
        {
            "sample_id": 1271,
            "vt": "SELECT person.name FROM credit INNER JOIN Person AS T2 ON T2.person_id = T1.person_id WHERE credit.credited = '[placeholder-type:string]' AND credit.episode_id = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of persons who have received credit for their roles in a specific episode of a series. The query filters the results based on whether the credit was displayed and the specific episode's ID."
        },
        {
            "sample_id": 1346,
            "vt": "SELECT person.birth_country FROM person WHERE person.name = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the birth country of a person from the 'person' table based on their name. The placeholder in the WHERE clause represents the specific name of the person being queried."
        },
        {
            "sample_id": 1334,
            "vt": "SELECT award.award FROM episode INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id WHERE episode.episode = [placeholder-type:numeric] AND award.result IN ('[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table retrieves the specific awards associated with episodes from the 'episode' table, filtered by the episode number and the result of the award nomination. The placeholders represent the episode number and the possible results of the award (e.g., Nominee or Winner)."
        },
        {
            "sample_id": 1301,
            "vt": "SELECT person.birth_place, person.birth_region FROM person WHERE person.birth_name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the birth place and birth region of individuals from the 'person' table who have a specific birth name. The placeholder in the WHERE clause represents the birth name of the person."
        },
        {
            "sample_id": 1337,
            "vt": "SELECT episode.episode FROM episode INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id WHERE award.result = '[placeholder-type:string]'",
            "ba": "The virtual table describes the sequential number of episodes from the 'episode' table that have received a specific award result. The query joins the 'episode' table with the 'award' table to filter episodes based on their award results, using a placeholder for the result type."
        },
        {
            "sample_id": 1285,
            "vt": "SELECT COUNT(award.award) FROM episode INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of awards associated with a specific episode title from the 'episode' table, filtering by the award result (either 'Nominee' or 'Winner'). The placeholders represent the episode title and the result status."
        },
        {
            "sample_id": 1286,
            "vt": "SELECT person.name FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Person AS T3 ON T3.person_id = T2.person_id WHERE episode.title = '[placeholder-type:string]' AND credit.role = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of persons who have a specific role in a particular episode of a series. It retrieves data from the 'episode' table and joins it with the 'credit' and 'person' tables to filter based on the episode title and the role of the person."
        },
        {
            "sample_id": 1338,
            "vt": "SELECT SUM(episode.rating) / COUNT(episode.episode_id) FROM episode WHERE episode.season = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average rating of episodes from a specific season of a series. It sums up the ratings of all episodes in that season and divides by the total number of episodes to find the average rating."
        },
        {
            "sample_id": 1265,
            "vt": "SELECT episode.air_date FROM vote INNER JOIN Episode AS T2 ON T2.episode_id = T1.episode_id GROUP BY episode.episode_id ORDER BY SUM(vote.votes) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table provides the air dates of episodes from the 'episode' table, filtered by the total number of votes received for each episode. It uses an inner join with the 'vote' table to aggregate the votes for each episode, grouping the results by episode ID and ordering them by the sum of votes in descending order. The placeholder in the LIMIT clause allows users to specify how many episodes they want to retrieve based on their popularity as indicated by the total votes."
        },
        {
            "sample_id": 1262,
            "vt": "SELECT episode.summary FROM episode INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id WHERE award.award_id = [placeholder-type:numeric]",
            "ba": "The virtual table provides a summary of an episode from the 'episode' table that has been nominated for a specific award. It retrieves the summary by joining the 'episode' table with the 'award' table based on the episode ID, filtering for a specific award using a placeholder for numeric values."
        },
        {
            "sample_id": 1250,
            "vt": "SELECT SUM(vote.votes) FROM episode INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]'",
            "ba": "The virtual table calculates the total number of votes received for a specific episode from the 'episode' table. It joins the 'episode' table with the 'vote' table based on the episode ID, and filters the results to include only the episode with a specified title."
        },
        {
            "sample_id": 1317,
            "vt": "SELECT episode.title, episode.summary, episode.air_date FROM vote INNER JOIN Episode AS T2 ON T2.episode_id = T1.episode_id WHERE vote.stars = [placeholder-type:numeric] AND vote.votes = [placeholder-type:numeric]",
            "ba": "The virtual table describes the titles, summaries, and air dates of episodes from the 'episode' table that have received a specific number of stars and votes. The placeholders in the WHERE clause represent the number of stars and the total votes for the episodes."
        },
        {
            "sample_id": 1352,
            "vt": "SELECT person.name FROM person INNER JOIN Credit AS T2 ON T1.person_id = T2.person_id WHERE credit.role = '[placeholder-type:string]' AND credit.credited = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of persons from the 'person' table who have a specific role in the credits of an episode, filtered by whether they were credited or not. The placeholders in the WHERE clause represent the role and credited status."
        },
        {
            "sample_id": 1308,
            "vt": "SELECT person.birth_region FROM credit INNER JOIN Person AS T2 ON T2.person_id = T1.person_id WHERE credit.role = '[placeholder-type:string]'",
            "ba": "The virtual table describes the birth region of persons who have been credited for a specific role in episodes. It retrieves data from the 'credit' table and joins it with the 'person' table to access the birth region information. The placeholder in the WHERE clause represents the specific role for which the credit is being recognized."
        },
        {
            "sample_id": 1324,
            "vt": "SELECT episode.episode_id, award.role FROM person INNER JOIN Award AS T2 ON T1.person_id = T2.person_id INNER JOIN Episode AS T3 ON T2.episode_id = T3.episode_id WHERE award.year = [placeholder-type:numeric] AND award.award = '[placeholder-type:string]' AND award.organization = '[placeholder-type:string]' AND person.name = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table displays the unique identifiers of episodes along with the roles for which individuals have been nominated for awards. It combines data from the 'person', 'award', and 'episode' tables to filter results based on specific criteria such as the year of the award, the name of the award, the organization granting the award, the name of the person, and the result of the nomination."
        },
        {
            "sample_id": 1270,
            "vt": "SELECT CAST(COUNT(credit.episode_id) AS FLOAT) / ([placeholder-type:numeric] - [placeholder-type:numeric] + [placeholder-type:numeric]) FROM credit INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE credit.category = '[placeholder-type:string]' AND credit.credited = '[placeholder-type:string]' AND episode.number_in_series BETWEEN [placeholder-type:numeric] AND [placeholder-type:numeric]",
            "ba": "The virtual table calculates the average number of credits for episodes in a specific range of the series. It counts the number of credits from the 'credit' table, filtering by the credit category and whether the credit was displayed. The result is divided by a formula involving three numeric placeholders, which likely represent different counts or limits relevant to the calculation. The episodes considered are those whose overall sequence number falls within a specified range."
        },
        {
            "sample_id": 1248,
            "vt": "SELECT keyword.keyword FROM episode INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE episode.rating > [placeholder-type:numeric]",
            "ba": "The virtual table retrieves keywords associated with episodes from the 'episode' table that have a rating higher than a specified value. The query uses an inner join to connect the 'episode' table with the 'keyword' table based on the episode ID, ensuring that only keywords for episodes meeting the rating condition are selected."
        },
        {
            "sample_id": 1357,
            "vt": "SELECT episode.episode_id FROM award INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE award.award = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]' ORDER BY episode.rating LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of episodes from the 'episode' table that have received a specific award and have a particular nomination result. The query joins the 'award' table with the 'episode' table to filter episodes based on the award type and result, while also ordering the results by the episode's rating and limiting the number of results returned."
        },
        {
            "sample_id": 1323,
            "vt": "SELECT COUNT(award.award_id) FROM episode INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id WHERE award.year = [placeholder-type:numeric] AND award.result = '[placeholder-type:string]' AND episode.episode = [placeholder-type:numeric] AND award.organization = '[placeholder-type:string]' AND episode.series = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of awards associated with specific episodes of a series based on various criteria such as the year of the award, the result of the nomination, the episode number, and the organization granting the award."
        },
        {
            "sample_id": 1283,
            "vt": "SELECT SUM(CASE WHEN episode.season = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END), CAST(SUM(CASE WHEN episode.season = [placeholder-type:numeric] THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / COUNT(credit.episode_id) FROM credit INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE credit.category = '[placeholder-type:string]' AND episode.series = '[placeholder-type:string]'",
            "ba": "The virtual table summarizes the total credits and average credits for episodes in a specific season of a series, based on the credit category. It calculates the sum of credits for episodes in the specified season and divides it by the count of episodes to get the average, using placeholders for season number, credit category, and series name."
        },
        {
            "sample_id": 1269,
            "vt": "SELECT CAST(SUM(CASE WHEN episode.title = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) AS FLOAT) / SUM(CASE WHEN episode.title = '[placeholder-type:string]' THEN [placeholder-type:numeric] ELSE [placeholder-type:numeric] END) FROM episode INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id",
            "ba": "The virtual table calculates the average rating of a specific episode based on its title. It sums the total votes and ratings for the episode with the specified title and divides it by the total number of votes for that episode. The placeholders represent the episode title and numeric values for ratings and votes."
        },
        {
            "sample_id": 1356,
            "vt": "SELECT episode.title FROM episode INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE keyword.keyword IN ('[placeholder-type:string]', '[placeholder-type:string]')",
            "ba": "The virtual table lists the titles of episodes from the 'episode' table that are associated with specific keywords. The query uses an INNER JOIN to connect the 'episode' table with the 'keyword' table based on the episode ID, and filters the results to include only those episodes that match the specified keywords."
        },
        {
            "sample_id": 1284,
            "vt": "SELECT keyword.keyword FROM episode INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE NOT episode.votes IN (SELECT MAX(episode.votes) FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id) ORDER BY episode.votes LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves keywords associated with episodes that do not have the maximum number of votes. It joins the 'episode' table with the 'keyword' table to filter out episodes with the highest votes, ensuring that only those with fewer votes are selected. The results are ordered by the number of votes in ascending order, and a limit is applied to control the number of returned keywords."
        },
        {
            "sample_id": 1309,
            "vt": "SELECT COUNT(person.person_id) FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Person AS T3 ON T3.person_id = T2.person_id WHERE person.name = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of unique persons associated with episodes in the 'episode' table, where the person's name matches a specified value. It joins the 'episode' table with the 'credit' table to link episodes to the individuals credited for their work, and then further joins with the 'person' table to filter based on the person's name."
        },
        {
            "sample_id": 1350,
            "vt": "SELECT episode.title FROM award INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE award.award = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of episodes from the 'episode' table that have received a specific award. The query uses an inner join between the 'award' and 'episode' tables to link episodes with their corresponding awards, filtering by the specific award type using a placeholder."
        },
        {
            "sample_id": 1293,
            "vt": "SELECT person.name FROM credit INNER JOIN Person AS T2 ON T2.person_id = T1.person_id WHERE credit.role = '[placeholder-type:string]' AND NOT person.birthdate IS NULL ORDER BY person.birthdate LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of individuals who have a specific role in an episode, ensuring that only those with a known birthdate are included. The results are ordered by birthdate and limited to a specified number of entries."
        },
        {
            "sample_id": 1335,
            "vt": "SELECT person.name FROM person INNER JOIN Award AS T2 ON T1.person_id = T2.person_id GROUP BY award.role HAVING COUNT(award.award_id) > [placeholder-type:numeric]",
            "ba": "The virtual table lists the names of persons who have received more than a specified number of awards for their roles. It retrieves data from the 'person' table and joins it with the 'award' table to filter and group the results based on the role associated with the awards."
        },
        {
            "sample_id": 1343,
            "vt": "SELECT award.person_id FROM vote INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id ORDER BY vote.percent LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the unique identifiers of persons who have been nominated for awards related to episodes, based on viewer ratings. It joins the 'vote' table, which contains viewer ratings for episodes, with the 'award' table to filter the results. The results are ordered by the percentage of viewers who rated the episode, and a limit is applied to control the number of results returned."
        },
        {
            "sample_id": 1328,
            "vt": "SELECT person.name FROM credit INNER JOIN Person AS T2 ON T2.person_id = T1.person_id INNER JOIN Episode AS T3 ON T1.episode_id = T3.episode_id WHERE episode.episode = [placeholder-type:numeric] AND credit.role = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of persons who have been credited for a specific role in a particular episode of a series. The placeholders in the WHERE clause represent the episode number and the role title."
        },
        {
            "sample_id": 1342,
            "vt": "SELECT episode.episode FROM episode INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE keyword.keyword = '[placeholder-type:string]'",
            "ba": "The virtual table describes the sequential number of episodes from the 'episode' table that are associated with a specific keyword. The query joins the 'episode' table with the 'keyword' table to filter episodes based on the provided keyword, allowing users to find episodes that match their interests."
        },
        {
            "sample_id": 1274,
            "vt": "SELECT COUNT(award.award_id) FROM person INNER JOIN Award AS T2 ON T1.person_id = T2.person_id WHERE person.name = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of awards received by a specific person based on their name and the result of the award nomination. It joins the 'person' table with the 'award' table to filter the results accordingly."
        },
        {
            "sample_id": 1254,
            "vt": "SELECT person.name FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Person AS T3 ON T3.person_id = T2.person_id WHERE episode.title = '[placeholder-type:string]' AND credit.credited = '[placeholder-type:string]' AND credit.role = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of persons associated with a specific episode from the 'episode' table. It filters the results based on the episode's title, whether the credit was displayed, and the specific role of the person in that episode. The placeholders represent the title of the episode, the credited status, and the role of the person."
        },
        {
            "sample_id": 1261,
            "vt": "SELECT COUNT(credit.role) FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE episode.series = '[placeholder-type:string]' AND episode.season = [placeholder-type:numeric] AND episode.episode = [placeholder-type:numeric] AND credit.credited = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of credits for a specific episode in a series, season, and episode number, filtering by whether the credit was displayed in the episode's credits."
        },
        {
            "sample_id": 1268,
            "vt": "SELECT vote.votes FROM episode INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE vote.stars = [placeholder-type:numeric] AND episode.title = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves the total number of votes for a specific episode from the 'episode' table, filtered by the number of stars given by viewers and the title of the episode. The placeholders represent the star rating and the episode title."
        },
        {
            "sample_id": 1306,
            "vt": "SELECT episode.title FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Person AS T3 ON T3.person_id = T2.person_id WHERE credit.credited = '[placeholder-type:string]' AND person.name = '[placeholder-type:string]'",
            "ba": "The virtual table describes the titles of episodes from the 'episode' table that are associated with specific credits and persons. It filters the results based on whether the credit was displayed and the name of the person involved."
        },
        {
            "sample_id": 1266,
            "vt": "SELECT person.name FROM person INNER JOIN Award AS T2 ON T1.person_id = T2.person_id WHERE award.award_id = [placeholder-type:numeric]",
            "ba": "The virtual table describes the names of persons who have been nominated for a specific award from the 'Award' table. The placeholder in the WHERE clause represents the unique identifier of the award."
        },
        {
            "sample_id": 1302,
            "vt": "SELECT person.name FROM person WHERE person.birth_country = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of individuals from the 'person' table who were born in a specific country. The placeholder in the WHERE clause represents the name of the country."
        },
        {
            "sample_id": 1296,
            "vt": "SELECT person.person_id, CAST(COUNT(person.person_id) AS FLOAT) * [placeholder-type:numeric] / (SELECT COUNT(person.person_id) FROM Credit AS T1 INNER JOIN Person AS T2 ON T2.person_id = T1.person_id) FROM credit INNER JOIN Person AS T2 ON T2.person_id = T1.person_id GROUP BY person.person_id ORDER BY COUNT(person.person_id) LIMIT [placeholder-type:numeric]",
            "ba": "The virtual table calculates the contribution of each person in terms of credits they have received, expressed as a percentage of the total credits across all persons. It selects the unique identifier of each person and computes the count of their credits, scaling it by a specified factor. The results are grouped by person and ordered by the count of credits, with a limit on the number of results returned."
        },
        {
            "sample_id": 1347,
            "vt": "SELECT person.name FROM award INNER JOIN Person AS T2 ON T1.person_id = T2.person_id WHERE award.result = '[placeholder-type:string]' AND award.role = '[placeholder-type:string]' AND award.series = '[placeholder-type:string]'",
            "ba": "The virtual table lists the names of individuals who have received nominations for awards in a specific series, filtered by the result of the nomination and the role they were nominated for. The placeholders represent the nomination result, the role, and the series name."
        },
        {
            "sample_id": 1288,
            "vt": "SELECT person.name FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Person AS T3 ON T3.person_id = T2.person_id WHERE episode.episode = [placeholder-type:numeric] AND credit.role = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of persons associated with a specific episode and role from the 'episode' and 'credit' tables. The placeholders represent the episode number and the role of the person."
        },
        {
            "sample_id": 1297,
            "vt": "SELECT DISTINCT award.episode_id FROM award WHERE award.award_category = '[placeholder-type:string]'",
            "ba": "The virtual table retrieves unique episode identifiers from the 'award' table for episodes that have been nominated in a specific award category. The placeholder in the WHERE clause represents the award category being queried."
        },
        {
            "sample_id": 1348,
            "vt": "SELECT person.name FROM award INNER JOIN Person AS T2 ON T1.person_id = T2.person_id WHERE award.result = '[placeholder-type:string]' AND award.award = '[placeholder-type:string]'",
            "ba": "The virtual table describes the names of persons who have received or been nominated for a specific award in a particular result category from the 'award' table. The placeholders in the WHERE clause represent the award result status and the specific award identifier."
        },
        {
            "sample_id": 1253,
            "vt": "SELECT COUNT(episode.episode_id) FROM episode INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]' AND credit.credited = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of episodes from the 'episode' table that have a specific title and checks if the credit for those episodes was displayed in the credits. The placeholders represent the episode title and whether the credit was displayed or not."
        },
        {
            "sample_id": 1282,
            "vt": "SELECT COUNT(award.award_id) FROM episode INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]' AND award.result = '[placeholder-type:string]'",
            "ba": "The virtual table counts the number of awards associated with a specific episode title and its nomination result from the 'episode' and 'award' tables. The placeholders represent the episode title and the result of the award nomination (either 'Nominee' or 'Winner')."
        },
        {
            "sample_id": 1339,
            "vt": "SELECT SUM(CASE WHEN episode.episode = [placeholder-type:numeric] THEN vote.votes ELSE [placeholder-type:numeric] END) - SUM(CASE WHEN episode.episode = [placeholder-type:numeric] THEN vote.votes ELSE [placeholder-type:numeric] END) FROM vote INNER JOIN Episode AS T2 ON T2.episode_id = T1.episode_id WHERE vote.stars = [placeholder-type:numeric]",
            "ba": "The virtual table calculates the difference between the total votes for episodes with a specific sequential number and the total votes for episodes with another specific sequential number, filtered by the star rating given by viewers. It uses a conditional sum to achieve this, joining the 'vote' table with the 'episode' table to access the necessary episode details."
        },
        {
            "sample_id": 1249,
            "vt": "SELECT vote.votes FROM episode INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE episode.title = '[placeholder-type:string]' AND vote.stars = [placeholder-type:numeric]",
            "ba": "The virtual table retrieves the total number of votes for a specific episode based on its title and the star rating given by viewers. It combines data from the 'episode' table and the 'vote' table using an inner join on the episode ID, ensuring that only votes corresponding to the specified episode title and star rating are included."
        }
    ]
}