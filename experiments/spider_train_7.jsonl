{"sample_id": 3500, "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["Identify the requirement to fetch full names and hire dates of employees.", "Determine that we need to join the employees table with itself to find the department of the employee named Clara.", "Use a subquery to find the DEPARTMENT_ID of the employee with the first name Clara.", "Select the full name (concatenation of FIRST_NAME and LAST_NAME) and HIRE_DATE from the employees table where the DEPARTMENT_ID matches that of Clara's."], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE \nFROM employees e \nWHERE e.DEPARTMENT_ID = (SELECT e2.DEPARTMENT_ID \n                         FROM employees e2 \n                         WHERE e2.FIRST_NAME = 'Clara')", "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"]}
{"sample_id": 3501, "db_id": "hr_1", "question": "display the employee name ( first name and last name ) and hire date for all employees in the same department as Clara excluding Clara.", "rationale": ["Identify the columns needed: first name, last name, and hire date of employees.", "We need to filter employees based on their department, specifically the department of an employee named Clara.", "To find Clara's department, we will join the employees table with itself (self-join) on the DEPARTMENT_ID.", "The condition for the join will be that the department ID of the employee (e) matches the department ID of Clara (c).", "We also need to ensure that we exclude Clara from the results, which can be done by checking that the last name of Clara does not match the last name of the other employees in the same department.", "Finally, we will select the required columns from the result."], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, e.HIRE_DATE \nFROM employees e \nJOIN employees c ON e.DEPARTMENT_ID = c.DEPARTMENT_ID \nWHERE c.FIRST_NAME = 'Clara' AND c.LAST_NAME != e.LAST_NAME;", "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"]}
{"sample_id": 3502, "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the requirement to find employees in the same department as Clara.", "Use a self-join on the employees table to compare departments.", "Select the full names of employees by concatenating FIRST_NAME and LAST_NAME.", "Include the HIRE_DATE of the employees in the result.", "Filter the results to exclude Clara by checking that the FIRST_NAME is not 'Clara'.", "Construct the SQL query using the SELECT statement with the appropriate JOIN and WHERE clauses."], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE \nFROM employees e \nJOIN employees c ON e.DEPARTMENT_ID = c.DEPARTMENT_ID \nWHERE c.FIRST_NAME = 'Clara' AND e.FIRST_NAME != 'Clara';", "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"]}
{"sample_id": 3503, "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["Identify the main requirement: We need to display the employee number and name (first name and last name) for employees who work in a department with any employee whose name contains a 'T'.", "To achieve this, we will need to join the 'employees' table with the 'departments' table to get the department information for each employee.", "Next, we need to find departments that have at least one employee whose name contains 'T'. This requires a subquery that selects department IDs from the 'employees' table where either the first name or last name contains 'T'.", "The subquery will return a list of department IDs that meet the criteria, and we will use this list in the main query to filter employees accordingly.", "Finally, we will select the EMPLOYEE_ID, FIRST_NAME, and LAST_NAME from the employees who belong to the departments identified in the subquery."], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nWHERE d.DEPARTMENT_ID IN (\n    SELECT d2.DEPARTMENT_ID \n    FROM employees e2 \n    JOIN departments d2 ON e2.DEPARTMENT_ID = d2.DEPARTMENT_ID \n    WHERE e2.FIRST_NAME LIKE '%T%' OR e2.LAST_NAME LIKE '%T%'\n)", "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"]}
{"sample_id": 3504, "db_id": "hr_1", "question": "What are the ids and full names for employees who work in a department that has someone with a first name that contains the letter T?", "rationale": ["Identify the main entities involved: employees and departments.", "We need to find employees who work in departments where at least one employee has a first name containing the letter 'T'.", "To achieve this, we will use a subquery to first find the department IDs of departments that have employees with a first name containing 'T'.", "The subquery will select distinct department IDs from the employees table where the first name matches the condition.", "The outer query will then select the employee IDs and their full names (concatenation of first and last names) from the employees table, joining it with the departments table to filter by the department IDs obtained from the subquery."], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nWHERE d.DEPARTMENT_ID IN (\n    SELECT DISTINCT d2.DEPARTMENT_ID\n    FROM employees e2\n    JOIN departments d2 ON e2.DEPARTMENT_ID = d2.DEPARTMENT_ID\n    WHERE e2.FIRST_NAME LIKE '%T%'\n);", "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"]}
{"sample_id": 3505, "db_id": "hr_1", "question": "display the employee number, name( first name and last name ), and salary for all employees who earn more than the average salary and who work in a department with any employee with a 'J' in their first name.", "rationale": ["Identify the columns needed: employee number (EMPLOYEE_ID), first name (FIRST_NAME), last name (LAST_NAME), and salary (SALARY).", "Filter employees whose salary is greater than the average salary. This requires a subquery to calculate the average salary from the employees table.", "Additionally, filter employees based on their department. We need to find departments that have at least one employee with a first name starting with 'J'. This requires another subquery that selects distinct department IDs from employees where the first name matches the criteria.", "Combine these conditions using the WHERE clause to ensure both conditions are satisfied."], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY > (SELECT AVG(SALARY) FROM employees) \nAND e.DEPARTMENT_ID IN (SELECT DISTINCT d.DEPARTMENT_ID \n                         FROM employees d \n                         WHERE d.FIRST_NAME LIKE 'J%');", "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%')", "source_tables": ["employees"]}
{"sample_id": 3506, "db_id": "hr_1", "question": "What are the ids, full names, and salaries for employees making more than average and who work in a department with employees who have the letter J in their first name?", "rationale": ["Identify the required fields: employee IDs, full names (first and last), and salaries.", "To get the full name, concatenate the first and last names of employees.", "Filter employees whose salary is greater than the average salary of all employees. This requires a subquery to calculate the average salary.", "Additionally, filter employees based on their department. We need to find departments that have employees with 'J' in their first name. This requires another subquery that selects distinct department IDs from the employees table where the first name contains 'J'.", "Combine these conditions in the main query to get the desired results."], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY > (SELECT AVG(SALARY) FROM employees) \nAND e.DEPARTMENT_ID IN (SELECT DISTINCT d.DEPARTMENT_ID \n                         FROM employees emp \n                         JOIN departments d ON emp.DEPARTMENT_ID = d.DEPARTMENT_ID \n                         WHERE emp.FIRST_NAME LIKE '%J%');", "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%')", "source_tables": ["employees"]}
{"sample_id": 3507, "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main requirement: We need to display the EMPLOYEE_ID and JOB_ID for employees whose salary is less than any salary of employees with the job title 'MK_MAN'.", "To achieve this, we will use a subquery to find the minimum salary of employees with the job title 'MK_MAN'.", "The subquery will join the employees table with the jobs table to filter by job title.", "The main query will select EMPLOYEE_ID and JOB_ID from the employees table where the salary is less than the result of the subquery."], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID FROM employees WHERE SALARY < (SELECT MIN(SALARY) FROM employees JOIN jobs ON employees.JOB_ID = jobs.JOB_ID WHERE JOB_TITLE = 'MK_MAN')", "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"]}
{"sample_id": 3508, "db_id": "hr_1", "question": "What are the employee ids and job ids for employees who make less than the lowest earning employee with title MK_MAN?", "rationale": ["Identify the relevant tables: We need to work with the 'employees' table to get employee IDs and job IDs, and we also need to reference the 'jobs' table to find the minimum salary for the job title 'MK_MAN'.", "Determine the condition: We need to find employees whose salary is less than the minimum salary of those with the job title 'MK_MAN'.", "Construct a subquery: Create a subquery that selects the minimum salary from the 'employees' table, joining it with the 'jobs' table to filter by the job title 'MK_MAN'.", "Combine the main query and the subquery: The main query selects EMPLOYEE_ID and JOB_ID from the 'employees' table where the salary is less than the result of the subquery."], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID FROM employees WHERE SALARY < (SELECT MIN(SALARY) FROM employees JOIN jobs ON employees.JOB_ID = jobs.JOB_ID WHERE JOB_TITLE = 'MK_MAN')", "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"]}
{"sample_id": 3509, "db_id": "hr_1", "question": "display the employee number, name( first name and last name ) and job title for all employees whose salary is more than any salary of those employees whose job title is PU_MAN.", "rationale": ["Identify the columns needed: employee number (EMPLOYEE_ID), first name (FIRST_NAME), last name (LAST_NAME), and job title (JOB_TITLE).", "Determine the main table to query from, which is the 'employees' table.", "Join the 'jobs' table to get the job title associated with each employee.", "Use a subquery to find the maximum salary of employees whose job title is 'PU_MAN'.", "Filter the main query to include only those employees whose salary is greater than the maximum salary found in the subquery."], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME, j.JOB_TITLE \nFROM employees e \nJOIN jobs j ON e.JOB_ID = j.JOB_ID \nWHERE e.SALARY > (SELECT MAX(e2.SALARY) \n                   FROM employees e2 \n                   JOIN jobs j2 ON e2.JOB_ID = j2.JOB_ID \n                   WHERE j2.JOB_TITLE = 'PU_MAN');", "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"]}
{"sample_id": 3510, "db_id": "hr_1", "question": "What are the employee ids, full names, and job ids for employees who make more than the highest earning employee with title PU_MAN?", "rationale": ["Identify the columns needed: EMPLOYEE_ID, FULL_NAME (which is a combination of FIRST_NAME and LAST_NAME), and JOB_ID.", "Determine the condition: we need employees whose salary is greater than the highest salary of employees with the job title 'PU_MAN'.", "To find the highest salary for 'PU_MAN', we need to first find the JOB_ID for 'PU_MAN' from the jobs table.", "Then, we can use this JOB_ID to find the maximum salary from the employees table.", "Finally, we will select the required columns from the employees table where the salary is greater than the maximum salary found."], "pred_sql": "SELECT EMPLOYEE_ID, FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, JOB_ID \nFROM employees \nWHERE SALARY > (SELECT MAX(SALARY) \n                 FROM employees \n                 WHERE JOB_ID = (SELECT JOB_ID \n                                 FROM jobs \n                                 WHERE JOB_TITLE = 'PU_MAN'))", "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"]}
{"sample_id": 3511, "db_id": "hr_1", "question": "display the department id and the total salary for those departments which contains at least two employees.", "rationale": ["We need to display the department ID and the total salary for departments with at least two employees.", "To get the total salary, we will use the SUM function on the SALARY column from the employees table.", "We will join the departments table with the employees table on the DEPARTMENT_ID column to link employees to their respective departments.", "We will group the results by DEPARTMENT_ID to calculate the total salary for each department.", "To filter departments that have at least two employees, we will use the HAVING clause with COUNT(EMPLOYEE_ID) >= 2."], "pred_sql": "SELECT d.DEPARTMENT_ID, SUM(e.SALARY) AS total_salary\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_ID\nHAVING COUNT(e.EMPLOYEE_ID) >= 2;", "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"]}
{"sample_id": 3512, "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To do this, we will join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' column.", "We will use the SUM function to calculate the total salaries for each department.", "We will group the results by 'DEPARTMENT_ID' to get the total salaries for each department.", "To filter the departments that have more than 2 employees, we will use the HAVING clause with COUNT to count the number of employees in each department."], "pred_sql": "SELECT d.DEPARTMENT_ID, SUM(e.SALARY) AS total_salaries \nFROM departments d \nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_ID \nHAVING COUNT(e.EMPLOYEE_ID) > 2;", "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"]}
{"sample_id": 3513, "db_id": "hr_1", "question": "display all the information of those employees who did not have any job in the past.", "rationale": ["Identify the main requirement: to display all information of employees without any job history.", "Understand the structure of the employees table, which contains all employee details.", "Recognize that job history is recorded in the job_history table, which links employees to their past jobs.", "To find employees without any job history, we can use a subquery to select EMPLOYEE_IDs from the job_history table.", "The main query will select all columns from the employees table where the EMPLOYEE_ID is not in the list of IDs returned by the subquery."], "pred_sql": "SELECT * FROM employees WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM job_history)", "gold_sql": "SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)", "source_tables": ["job_history", "employees"]}
{"sample_id": 3514, "db_id": "hr_1", "question": "What is all the information about employees who have never had a job in the past?", "rationale": ["Identify the main table to query: 'employees' to get all information about employees.", "Determine the condition: employees who have never had a job in the past, which means they should not exist in the 'job_history' table.", "Use a subquery to find all EMPLOYEE_IDs from the 'job_history' table.", "Use the NOT IN clause to filter out those employees from the main query."], "pred_sql": "SELECT * FROM employees WHERE EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM job_history)", "gold_sql": "SELECT * FROM employees WHERE employee_id NOT IN (SELECT employee_id FROM job_history)", "source_tables": ["job_history", "employees"]}
{"sample_id": 3515, "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To get the full name, we can concatenate the first name and last name of the employee using the '||' operator.", "We will join the 'employees' table with the 'departments' table on the DEPARTMENT_ID to get the department information.", "To find the highest salary in each department, we can use a subquery that selects the maximum salary from the 'employees' table, filtered by the department ID.", "The main query will select the department ID, the concatenated full name, and the salary from the joined tables, where the salary matches the maximum salary from the subquery."], "pred_sql": "SELECT d.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                   FROM employees \n                   WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"]}
{"sample_id": 3516, "db_id": "hr_1", "question": "What are the department ids, full names, and salaries for employees who make the most in their departments?", "rationale": ["Identify the required fields: department ids, full names, and salaries of employees.", "To get the full names, concatenate the FIRST_NAME and LAST_NAME fields from the employees table.", "To find the highest salary in each department, use a subquery that selects the maximum salary from the employees table, grouped by DEPARTMENT_ID.", "The main query selects the DEPARTMENT_ID, the concatenated full name, and the salary from the employees table where the salary matches the maximum salary for that department."], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                   FROM employees \n                   WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"]}
{"sample_id": 3517, "db_id": "hr_1", "question": "display the first and last name, department, city, and state province for each employee.", "rationale": ["Identify the required fields: first name, last name, department, city, and state province.", "Determine the tables needed: employees, departments, and locations.", "Establish relationships between the tables: employees are linked to departments via DEPARTMENT_ID, and departments are linked to locations via LOCATION_ID.", "Construct the SQL SELECT statement to retrieve the specified fields from the joined tables."], "pred_sql": "SELECT employees.FIRST_NAME, employees.LAST_NAME, departments.DEPARTMENT_NAME, locations.CITY, locations.STATE_PROVINCE \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID;", "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id", "source_tables": ["employees", "departments", "locations"]}
{"sample_id": 3518, "db_id": "hr_1", "question": "What are the full names, departments, cities, and state provinces for each employee?", "rationale": ["Identify the required fields: full names (first and last), department names, cities, and state provinces.", "To get the full name, concatenate the FIRST_NAME and LAST_NAME from the employees table.", "The department name can be obtained from the departments table.", "Cities and state provinces are available in the locations table.", "Establish relationships between the tables: employees are linked to departments via DEPARTMENT_ID, and departments are linked to locations via LOCATION_ID.", "Construct the SQL query using JOINs to combine the necessary tables and select the required fields."], "pred_sql": "SELECT employees.FIRST_NAME || ' ' || employees.LAST_NAME AS FULL_NAME, departments.DEPARTMENT_NAME, locations.CITY, locations.STATE_PROVINCE\nFROM employees\nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID\nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID;", "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id", "source_tables": ["employees", "departments", "locations"]}
{"sample_id": 3519, "db_id": "hr_1", "question": "display those employees who contain a letter z to their first name and also display their last name, city.", "rationale": ["Identify the relevant tables: employees, departments, and locations are needed to get the required information.", "We need to select the first name, last name, and city of employees.", "To get the city, we need to join the employees table with the departments table on DEPARTMENT_ID, and then join the departments table with the locations table on LOCATION_ID.", "The condition specifies that the first name must contain the letter 'z', which can be checked using the LIKE operator with a wildcard.", "Construct the SQL query using SELECT to get the desired columns and JOIN to connect the tables, along with the WHERE clause for the filtering condition."], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, l.CITY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE e.FIRST_NAME LIKE '%z%';", "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"]}
{"sample_id": 3520, "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the required fields: full names (first and last) and cities.", "To get the full names, we need to concatenate the FIRST_NAME and LAST_NAME fields.", "We need to filter employees based on the condition that their FIRST_NAME contains the letter 'Z'.", "To get the city, we need to join the employees table with the locations table, which requires joining through the departments table since employees are linked to departments and departments are linked to locations.", "Construct the SQL query using SELECT to retrieve the concatenated full names and cities, applying the necessary JOINs and WHERE clause for filtering."], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, CITY FROM employees JOIN locations ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID JOIN countries ON departments.LOCATION_ID = locations.LOCATION_ID WHERE FIRST_NAME LIKE '%Z%';", "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"]}
{"sample_id": 3521, "db_id": "hr_1", "question": "display the department name, city, and state province for each department.", "rationale": ["Identify the required columns: DEPARTMENT_NAME from departments, CITY and STATE_PROVINCE from locations.", "Determine the relationship between the tables: departments are linked to locations through LOCATION_ID.", "Construct the SQL SELECT statement to retrieve the specified columns from the appropriate tables.", "Use JOIN to combine the departments and locations tables based on the LOCATION_ID key."], "pred_sql": "SELECT departments.DEPARTMENT_NAME, locations.CITY, locations.STATE_PROVINCE \nFROM departments \nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID;", "gold_sql": "SELECT T1.department_name ,  T2.city ,  T2.state_province FROM departments AS T1 JOIN locations AS T2 ON T2.location_id  =  T1.location_id", "source_tables": ["departments", "locations"]}
{"sample_id": 3522, "db_id": "hr_1", "question": "What are the department names, cities, and state provinces for each department?", "rationale": ["Identify the required columns: department names, cities, and state provinces.", "The department names are in the 'departments' table under the column 'DEPARTMENT_NAME'.", "The cities and state provinces are in the 'locations' table under the columns 'CITY' and 'STATE_PROVINCE'.", "To get the cities and state provinces associated with each department, we need to join the 'departments' table with the 'locations' table using the 'LOCATION_ID' as the common key.", "Construct the SQL query using a SELECT statement to retrieve the required columns from the joined tables."], "pred_sql": "SELECT departments.DEPARTMENT_NAME, locations.CITY, locations.STATE_PROVINCE \nFROM departments \nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID;", "gold_sql": "SELECT T1.department_name ,  T2.city ,  T2.state_province FROM departments AS T1 JOIN locations AS T2 ON T2.location_id  =  T1.location_id", "source_tables": ["departments", "locations"]}
{"sample_id": 3523, "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the required fields: full name of the employee (first and last name) and the name of the country.", "To get the full name, concatenate the FIRST_NAME and LAST_NAME from the employees table.", "The country name is in the countries table, which is linked to the employees through the departments and locations tables.", "Join the employees table with the departments table on DEPARTMENT_ID to get department information.", "Join the departments table with the locations table on LOCATION_ID to get location information.", "Join the locations table with the countries table on COUNTRY_ID to get the country name.", "Construct the SQL query to select the concatenated full name and the country name from the appropriate tables."], "pred_sql": "SELECT employees.FIRST_NAME || ' ' || employees.LAST_NAME AS FULL_NAME, countries.COUNTRY_NAME\nFROM employees\nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID\nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID\nJOIN countries ON locations.COUNTRY_ID = countries.COUNTRY_ID;", "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"]}
{"sample_id": 3524, "db_id": "hr_1", "question": "What the full names, ids of each employee and the name of the country they are in?", "rationale": ["Identify the required fields: full names (first and last), employee IDs, and country names.", "To get the full name of each employee, concatenate the FIRST_NAME and LAST_NAME fields from the employees table.", "The employee ID is directly available from the employees table.", "The country name is available from the countries table, which is linked to the employees through the departments and locations tables.", "Join the employees table with the departments table on DEPARTMENT_ID to get department information.", "Join the departments table with the locations table on LOCATION_ID to get location information.", "Join the locations table with the countries table on COUNTRY_ID to get the country name.", "Construct the SQL SELECT statement to retrieve the required fields from the joined tables."], "pred_sql": "SELECT employees.FIRST_NAME || ' ' || employees.LAST_NAME AS FULL_NAME, employees.EMPLOYEE_ID, countries.COUNTRY_NAME \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID \nJOIN countries ON locations.COUNTRY_ID = countries.COUNTRY_ID;", "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"]}
{"sample_id": 3525, "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["Identify the tables needed: We need the 'departments' table for department names and the 'employees' table to count the number of employees.", "We will use a LEFT JOIN to connect the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' column, ensuring we include departments even if they have no employees.", "We will use the COUNT function to count the number of employees in each department.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count of employees for each department."], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"]}
{"sample_id": 3526, "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["Identify the tables needed: We need the 'departments' table for department names and the 'employees' table to count the number of employees in each department.", "Determine the relationship: The 'departments' table is linked to the 'employees' table through the 'DEPARTMENT_ID' column.", "Use a LEFT JOIN: This will allow us to include departments even if they have no employees, ensuring all department names are listed.", "Count employees: Use the COUNT function to count the number of employees for each department.", "Group the results: Use GROUP BY to aggregate the results by department name."], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS EMPLOYEE_COUNT\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"]}
{"sample_id": 3527, "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["Identify the required fields: full name (first and last) and salary of employees.", "To get the full name, concatenate the FIRST_NAME and LAST_NAME fields from the employees table.", "We need to filter employees based on their department's location, so we will join the employees table with the departments table using DEPARTMENT_ID.", "Next, we need to join the departments table with the locations table using LOCATION_ID to access the city information.", "Finally, we will filter the results to include only those employees whose department is located in London."], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE l.CITY = 'London';", "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"]}
{"sample_id": 3528, "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the required information: full names and salaries of employees.", "Full names can be constructed by concatenating the FIRST_NAME and LAST_NAME fields from the employees table.", "Salaries are directly available from the SALARY field in the employees table.", "To find employees in a specific city, we need to join the employees table with the departments table to access the LOCATION_ID.", "Next, we join the departments table with the locations table to filter by city.", "Finally, we need to ensure that we are looking at the city of London specifically in our WHERE clause."], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE l.CITY = 'London';", "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"]}
{"sample_id": 3529, "db_id": "music_1", "question": "What is the name of the song that was released in the most recent year?", "rationale": ["Identify the relevant table: The 'song' table contains the 'releasedate' and 'song_name' columns.", "Determine the requirement: We need to find the song that was released in the most recent year.", "Use the ORDER BY clause to sort the songs by 'releasedate' in descending order, so the most recent song comes first.", "Limit the results to 1 to get only the most recent song.", "Construct the SQL query to select the 'song_name' from the 'song' table, ordered by 'releasedate' in descending order, and limit the result to 1."], "pred_sql": "SELECT song_name FROM song ORDER BY releasedate DESC LIMIT 1;", "gold_sql": "SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT 1", "source_tables": ["song"]}
{"sample_id": 3530, "db_id": "music_1", "question": "What is the name of the song that was released most recently?", "rationale": ["Identify the table that contains the song information, which is the 'song' table.", "To find the most recently released song, we need to sort the songs by the 'releasedate' column in descending order.", "Using 'ORDER BY releasedate DESC' will arrange the songs from the most recent to the oldest.", "To get only the most recent song, we will limit the results to 1 using 'LIMIT 1'.", "Finally, we select the 'song_name' column to get the name of the song."], "pred_sql": "SELECT song_name FROM song ORDER BY releasedate DESC LIMIT 1;", "gold_sql": "SELECT song_name ,  releasedate FROM song ORDER BY releasedate DESC LIMIT 1", "source_tables": ["song"]}
{"sample_id": 3531, "db_id": "music_1", "question": "What is the id of the longest song?", "rationale": ["Identify the table that contains the song information, which is the 'song' table.", "To find the longest song, we need to sort the songs by their duration in descending order.", "We will select the 'f_id' of the song, which is the unique identifier for the file associated with the song.", "To get only the longest song, we will limit the results to 1 after sorting."], "pred_sql": "SELECT f_id FROM song ORDER BY duration DESC LIMIT 1;", "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"]}
{"sample_id": 3532, "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["Identify the table that contains the duration of the songs, which is the 'song' table.", "To find the song that lasts the longest, we need to sort the songs by their duration in descending order.", "We will select the 'f_id' of the song, which is the unique identifier for the file associated with the song.", "To get only the longest song, we will limit the results to 1 after sorting."], "pred_sql": "SELECT f_id FROM song ORDER BY duration DESC LIMIT 1;", "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"]}
{"sample_id": 3533, "db_id": "music_1", "question": "Find the names of all English songs.", "rationale": ["Identify the relevant table: The 'song' table contains the information about songs, including their names and languages.", "Determine the condition: We need to filter songs that are in English, which is specified in the 'languages' column.", "Construct the SQL query: Use a SELECT statement to retrieve the 'song_name' from the 'song' table where the 'languages' column contains 'English'."], "pred_sql": "SELECT song_name FROM song WHERE languages LIKE '%English%';", "gold_sql": "SELECT song_name FROM song WHERE languages  =  'english'", "source_tables": ["song"]}
{"sample_id": 3534, "db_id": "music_1", "question": "What are the names of all songs in English?", "rationale": ["Identify the table that contains song information, which is the 'song' table.", "Determine the relevant column that contains the song names, which is 'song_name'.", "Identify the column that indicates the languages in which the song is available, which is 'languages'.", "Formulate a SQL query to select 'song_name' from the 'song' table where 'languages' contains 'English'."], "pred_sql": "SELECT song_name FROM song WHERE languages LIKE '%English%';", "gold_sql": "SELECT song_name FROM song WHERE languages  =  'english'", "source_tables": ["song"]}
{"sample_id": 3535, "db_id": "music_1", "question": "What are the id of songs whose format is mp3.", "rationale": ["Identify the relevant table: The query is asking for song IDs based on file formats, so we need to look at the 'files' table.", "Determine the specific column: We need the 'f_id' column from the 'files' table, as it contains the unique identifiers for the files.", "Filter the results: The query specifies that we are only interested in files where the format includes 'mp3'. We can use a WHERE clause with a LIKE operator to filter for this condition.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE condition to form the complete SQL query."], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp3%';", "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp3'", "source_tables": ["files"]}
{"sample_id": 3536, "db_id": "music_1", "question": "What are the id of all the files in mp3 format?", "rationale": ["Identify the table that contains the file information, which is the 'files' table.", "Determine the column that contains the file formats, which is 'formats'.", "To find files in mp3 format, use a SQL query that selects the 'f_id' from the 'files' table where the 'formats' column contains 'mp3'.", "Use the LIKE operator with wildcards to match any occurrence of 'mp3' in the 'formats' column."], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp3%';", "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp3'", "source_tables": ["files"]}
{"sample_id": 3537, "db_id": "music_1", "question": "List the name and country of origin for all singers who have produced songs with rating above 9.", "rationale": ["Identify the tables needed: We need information from the 'artist' table for singer details and the 'song' table for song ratings.", "Determine the columns to select: We need 'artist_name' and 'country' from the 'artist' table.", "Establish the relationship between tables: The 'artist' table can be joined with the 'song' table on 'artist_name'.", "Set the condition for filtering: We need to filter songs with a rating greater than 9.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "pred_sql": "SELECT DISTINCT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE song.rating > '9';", "gold_sql": "SELECT DISTINCT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.rating  >  9", "source_tables": ["artist", "song"]}
{"sample_id": 3538, "db_id": "music_1", "question": "What are the different names and countries of origins for all artists whose song ratings are above 9?", "rationale": ["Identify the tables needed: We need data from the 'artist' and 'song' tables.", "Determine the columns to select: We want the artist's name and their country of origin.", "Establish the condition: We need to filter artists based on the song ratings being above 9.", "Join the tables: Since artist names are present in both tables, we will join 'artist' and 'song' on 'artist_name'.", "Use DISTINCT to ensure we get unique artist names and countries, as an artist may have multiple songs."], "pred_sql": "SELECT DISTINCT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE song.rating > '9';", "gold_sql": "SELECT DISTINCT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.rating  >  9", "source_tables": ["artist", "song"]}
{"sample_id": 3539, "db_id": "music_1", "question": "List the file size and format for all songs that have resolution lower than 800.", "rationale": ["Identify the tables involved: We need information from the 'files' table for file size and format, and the 'song' table to filter by resolution.", "Determine the relationship between the tables: The 'files' table is linked to the 'song' table through the 'f_id' column.", "Construct the SELECT statement: We want to select 'file_size' and 'formats' from the 'files' table.", "Add the JOIN clause: We need to join the 'files' table with the 'song' table on the 'f_id' column.", "Add the WHERE clause: We need to filter the results to include only those songs with a resolution lower than 800."], "pred_sql": "SELECT files.file_size, files.formats FROM files JOIN song ON files.f_id = song.f_id WHERE song.resolution < 800;", "gold_sql": "SELECT DISTINCT T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.resolution  <  800", "source_tables": ["files", "song"]}
{"sample_id": 3540, "db_id": "music_1", "question": "What are the file sizes and formats for all songs with a resolution lower than 800?", "rationale": ["Identify the relevant tables: 'files' and 'song' are needed to get file sizes and formats.", "Determine the columns needed: 'file_size' and 'formats' from the 'files' table.", "Establish the relationship between the tables: 'files' is linked to 'song' through the 'f_id' column.", "Apply the condition: filter songs based on the resolution being lower than 800.", "Construct the SQL query using SELECT to retrieve the desired columns, JOIN to connect the tables, and WHERE to apply the filter."], "pred_sql": "SELECT files.file_size, files.formats FROM files JOIN song ON files.f_id = song.f_id WHERE song.resolution < 800;", "gold_sql": "SELECT DISTINCT T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.resolution  <  800", "source_tables": ["files", "song"]}
{"sample_id": 3541, "db_id": "music_1", "question": "What is the name of the artist who produced the shortest song?", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their duration and the artist's name.", "To find the shortest song, we need to sort the songs by their duration in ascending order.", "We will use the ORDER BY clause to sort the songs by the 'duration' column.", "To get only the artist who produced the shortest song, we will limit the results to 1 using the LIMIT clause."], "pred_sql": "SELECT artist_name FROM song ORDER BY duration ASC LIMIT 1;", "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"]}
{"sample_id": 3542, "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their duration and the artist's name.", "Determine the requirement: We need to find the names of artists who sang the shortest song.", "Use an aggregate function: To find the shortest song, we can use the MIN() function on the 'duration' column.", "Create a subquery: We will create a subquery to find the minimum duration from the 'song' table.", "Filter the results: We will filter the main query to select artist names where the duration matches the minimum duration found in the subquery."], "pred_sql": "SELECT artist_name FROM song WHERE duration = (SELECT MIN(duration) FROM song);", "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"]}
{"sample_id": 3543, "db_id": "music_1", "question": "What are the names and countries of origin for the artists who produced the top three highly rated songs.", "rationale": ["Identify the relevant tables: We need information from the 'artist' and 'song' tables.", "Determine the required fields: We need 'artist_name' and 'country' from the 'artist' table.", "We need to find the top three highly rated songs, so we will focus on the 'rating' field in the 'song' table.", "To get the top three ratings, we can use a subquery that selects distinct ratings from the 'song' table, orders them in descending order, and limits the results to three.", "We will join the 'artist' table with the 'song' table on the 'artist_name' field to link artists with their songs.", "Finally, we will select the distinct artist names and their countries of origin for those artists who produced the top three highly rated songs."], "pred_sql": "SELECT DISTINCT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE song.rating IN (SELECT DISTINCT rating FROM song ORDER BY rating DESC LIMIT 3)", "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT 3", "source_tables": ["artist", "song"]}
{"sample_id": 3544, "db_id": "music_1", "question": "What are the names of the singers who sang the top 3 most highly rated songs and what countries do they hail from?", "rationale": ["Identify the relevant tables: 'song' for song details and 'artist' for artist details.", "We need to find the top 3 most highly rated songs, so we will order the 'song' table by the 'rating' column in descending order.", "To get the names of the singers, we will join the 'song' table with the 'artist' table on the 'artist_name' column.", "We will select the 'artist_name' from the 'artist' table and the 'country' from the 'song' table.", "Finally, we will limit the results to the top 3 entries."], "pred_sql": "SELECT artist.artist_name, song.country FROM song JOIN artist ON song.artist_name = artist.artist_name ORDER BY song.rating DESC LIMIT 3;", "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.rating DESC LIMIT 3", "source_tables": ["artist", "song"]}
{"sample_id": 3545, "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["Identify the table that contains the duration of songs, which is the 'song' table.", "Determine the specific column that holds the duration information, which is 'duration'.", "Formulate a query to count the number of entries in the 'song' table where the duration is exactly 4 minutes, represented as '4:00'.", "Use the COUNT() function to get the total number of songs that meet this criterion."], "pred_sql": "SELECT COUNT(*) AS song_count FROM song WHERE duration = '4:00'", "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"]}
{"sample_id": 3546, "db_id": "music_1", "question": "What is the count of the songs that last approximately 4 minutes?", "rationale": ["Identify the table that contains the song duration, which is the 'song' table.", "To find songs that last approximately 4 minutes, we need to consider durations that are around 4 minutes, such as 4:00, 3:59, and 4:01.", "Construct a SQL query that counts the number of songs where the duration matches these criteria.", "Use the COUNT() function to get the total number of songs that meet the duration condition."], "pred_sql": "SELECT COUNT(*) AS song_count FROM song WHERE duration LIKE '4:%' OR duration LIKE '3:59%' OR duration LIKE '4:01%';", "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"]}
{"sample_id": 3547, "db_id": "music_1", "question": "How many artists are from Bangladesh?", "rationale": ["Identify the table that contains information about artists, which is the 'artist' table.", "Determine the relevant column that specifies the country of the artist, which is the 'country' column.", "Formulate a query to count the number of artists where the 'country' is 'Bangladesh'.", "Use the COUNT() function to get the total number of artists from Bangladesh."], "pred_sql": "SELECT COUNT(*) FROM artist WHERE country = 'Bangladesh';", "gold_sql": "SELECT count(*) FROM artist WHERE country  =  'Bangladesh'", "source_tables": ["artist"]}
{"sample_id": 3548, "db_id": "music_1", "question": "How many Bangladeshi artists are listed?", "rationale": ["Identify the table that contains information about artists, which is the 'artist' table.", "Determine the relevant column that specifies the country of the artists, which is the 'country' column.", "Formulate a query to count the number of entries in the 'artist' table where the 'country' is 'Bangladesh'.", "Use the COUNT() function to get the total number of Bangladeshi artists."], "pred_sql": "SELECT COUNT(*) FROM artist WHERE country = 'Bangladesh';", "gold_sql": "SELECT count(*) FROM artist WHERE country  =  'Bangladesh'", "source_tables": ["artist"]}
{"sample_id": 3549, "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["Identify the relevant table for song ratings, which is the 'song' table.", "We need to calculate the average rating, so we will use the AVG() function.", "To find songs produced by female artists, we need to filter the 'song' table based on the 'artist' table.", "We will create a subquery to select artist names from the 'artist' table where the gender is 'female'.", "Finally, we will combine these elements into a single SQL query that calculates the average rating of songs by female artists."], "pred_sql": "SELECT AVG(rating) AS average_rating FROM song WHERE artist_name IN (SELECT artist_name FROM artist WHERE gender = 'female')", "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"]}
{"sample_id": 3550, "db_id": "music_1", "question": "How many songs, on average, are sung by a female artist?", "rationale": ["Identify the relevant tables: We need to use the 'song' and 'artist' tables to find the number of songs sung by female artists.", "Filter the artists: We will filter the 'artist' table to include only female artists by using the condition 'artist.gender = 'female' '.", "Count the songs: For each female artist, we will count the number of songs they have sung. This can be done using 'COUNT(*)' and grouping by 'song.artist_name'.", "Calculate the average: Finally, we will calculate the average number of songs per female artist using 'AVG(song_count)' on the results of the previous step."], "pred_sql": "SELECT AVG(song_count) AS average_songs FROM (SELECT COUNT(*) AS song_count FROM song JOIN artist ON song.artist_name = artist.artist_name WHERE artist.gender = 'female' GROUP BY song.artist_name) AS song_counts;", "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"]}
{"sample_id": 3551, "db_id": "music_1", "question": "What is the most popular file format?", "rationale": ["The user is asking for the most popular file format.", "To find the most popular file format, we need to look at the 'formats' column in the 'files' table.", "Using SELECT DISTINCT will help us get unique file formats from the 'formats' column."], "pred_sql": "SELECT DISTINCT formats FROM files;", "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"]}
{"sample_id": 3552, "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["Identify the table that contains the file formats, which is the 'files' table.", "We need to count how many files exist for each format, so we will use the COUNT() function.", "To group the results by file format, we will use the GROUP BY clause on the 'formats' column.", "To find the most used file format, we will order the results in descending order based on the count of files.", "Finally, we will limit the results to only the top entry using LIMIT 1."], "pred_sql": "SELECT formats, COUNT(*) as file_count FROM files GROUP BY formats ORDER BY file_count DESC LIMIT 1;", "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"]}
{"sample_id": 3553, "db_id": "music_1", "question": "Find the names of the artists who are from UK and have produced English songs.", "rationale": ["Identify the relevant tables: We need information from the 'artist' table for artist names and their countries, and from the 'song' table for the languages of the songs.", "Determine the conditions: We want artists from the UK and songs that are in English.", "Join the tables: We will join the 'artist' table with the 'song' table on the artist's name to correlate artists with their songs.", "Select the distinct artist names: We will select the artist names that meet the conditions specified."], "pred_sql": "SELECT DISTINCT artist.artist_name FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE artist.country = 'UK' AND song.languages LIKE '%English%';", "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' INTERSECT SELECT artist_name FROM song WHERE languages  =  'english'", "source_tables": ["artist", "song"]}
{"sample_id": 3554, "db_id": "music_1", "question": "What are the names of the artists that are from the UK and sang songs in English?", "rationale": ["Identify the relevant tables: We need to retrieve artist names, so we will use the 'artist' table and the 'song' table to find songs sung in English.", "Determine the conditions: We need artists from the UK and songs that are in English. This means we will filter the 'artist' table by country and the 'song' table by language.", "Join the tables: Since the artist's name is present in both tables, we will perform a JOIN operation on the 'artist' and 'song' tables using the artist's name as the key.", "Select distinct artist names: To avoid duplicates, we will use DISTINCT to get unique artist names that meet the criteria."], "pred_sql": "SELECT DISTINCT artist.artist_name FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE artist.country = 'UK' AND song.languages LIKE '%English%';", "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' INTERSECT SELECT artist_name FROM song WHERE languages  =  'english'", "source_tables": ["artist", "song"]}
{"sample_id": 3555, "db_id": "music_1", "question": "Find the id of songs that are available in mp4 format and have resolution lower than 1000.", "rationale": ["Identify the relevant tables: 'song' and 'files' are needed to get the song IDs and their formats.", "Determine the relationship between the tables: 'song' and 'files' are linked by the 'f_id' column.", "Specify the conditions: we need songs that are in mp4 format and have a resolution lower than 1000.", "Construct the SQL query: use a SELECT statement to get 'f_id' from 'song', join with 'files' on 'f_id', and apply the WHERE clause for the specified conditions."], "pred_sql": "SELECT song.f_id FROM song JOIN files ON song.f_id = files.f_id WHERE files.formats LIKE '%mp4%' AND song.resolution < '1000';", "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"]}
{"sample_id": 3556, "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["Identify the table that contains the file information, which is the 'files' table.", "Determine the columns needed for the query: 'f_id' for the file ID, 'formats' to check for the mp4 format, and 'resolution' to check for the size condition.", "Use the WHERE clause to filter records where 'formats' contains 'mp4'.", "Add another condition in the WHERE clause to filter records where 'resolution' is less than 1000. Since resolution is stored as text, it needs to be cast to an integer for comparison.", "Combine these conditions to form the complete SQL query."], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp4%' AND CAST(resolution AS INTEGER) < 1000;", "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"]}
{"sample_id": 3557, "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the relevant tables: We need information from the 'artist' table for the country of origin and the 'song' table to check the language of the song.", "Determine the conditions: We are looking for female artists and songs that are in Bangla.", "Join the tables: We need to join the 'artist' and 'song' tables on the 'artist_name' column to correlate artists with their songs.", "Construct the SQL query: Use a SELECT statement to retrieve the country from the 'artist' table where the gender is 'female' and the song's languages include 'Bangla'."], "pred_sql": "SELECT artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE artist.gender = 'female' AND song.languages LIKE '%Bangla%';", "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"]}
{"sample_id": 3558, "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant tables: We need information about artists and their songs, so we will use the 'artist' and 'song' tables.", "Filter for female artists: We will add a condition to filter artists by gender, specifically looking for 'female'.", "Filter for songs in Bangla: We will also filter songs based on the language, looking for those that include 'Bangla'.", "Join the tables: Since we need to connect artists with their songs, we will perform a JOIN operation between the 'artist' and 'song' tables on the artist's name.", "Select distinct countries: Finally, we will select the distinct countries of the filtered female artists."], "pred_sql": "SELECT DISTINCT artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE artist.gender = 'female' AND song.languages LIKE '%Bangla%';", "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"]}
{"sample_id": 3559, "db_id": "music_1", "question": "What is the average duration of songs that have mp3 format and resolution below 800?", "rationale": ["Identify the relevant tables: 'song' and 'files' are needed to get the duration and filter by format and resolution.", "Determine the columns needed: We need the 'duration' from the 'song' table and the 'formats' and 'resolution' from the 'files' table.", "Join the 'song' and 'files' tables on the foreign key 'f_id' to access the necessary columns together.", "Apply the filter for the 'formats' column to include only those that contain 'mp3'.", "Apply the filter for the 'resolution' column to include only those below 800.", "Use the AVG() function to calculate the average duration of the filtered songs."], "pred_sql": "SELECT AVG(duration) AS average_duration FROM song JOIN files ON song.f_id = files.f_id WHERE formats LIKE '%mp3%' AND resolution < '800';", "gold_sql": "SELECT avg(T1.duration) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.formats  =  'mp3' AND T2.resolution   <  800", "source_tables": ["files", "song"]}
{"sample_id": 3560, "db_id": "music_1", "question": "What is the average song duration for the songs that are in mp3 format and whose resolution below 800?", "rationale": ["Identify the relevant tables: 'song' and 'files' are needed to get song duration and file format.", "Join the 'song' table with the 'files' table on the foreign key 'f_id' to access both song duration and file format.", "Filter the results to include only songs that are in mp3 format by using the condition 'files.formats LIKE '%mp3%'.", "Also, filter the songs to include only those with a resolution below 800 by using the condition 'song.resolution < '800'.", "Finally, calculate the average duration of the filtered songs using the AVG() function."], "pred_sql": "SELECT AVG(duration) AS average_duration FROM song JOIN files ON song.f_id = files.f_id WHERE files.formats LIKE '%mp3%' AND song.resolution < '800';", "gold_sql": "SELECT avg(T1.duration) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.formats  =  'mp3' AND T2.resolution   <  800", "source_tables": ["files", "song"]}
{"sample_id": 3561, "db_id": "music_1", "question": "What is the number of artists for each gender?", "rationale": ["Identify the table that contains the information about artists, which is the 'artist' table.", "Determine the relevant column for gender, which is 'gender' in the 'artist' table.", "To count the number of artists for each gender, use the COUNT() function.", "Group the results by gender to get the count for each distinct gender.", "Construct the SQL query using SELECT to retrieve the gender and the count of artists, and use GROUP BY to aggregate the results."], "pred_sql": "SELECT gender, COUNT(*) AS number_of_artists FROM artist GROUP BY gender;", "gold_sql": "SELECT count(*) ,  gender FROM artist GROUP BY gender", "source_tables": ["artist"]}
{"sample_id": 3562, "db_id": "music_1", "question": "How many artists are male and how many are female?", "rationale": ["Identify the relevant table: The 'artist' table contains the information about artists including their gender.", "Determine the columns needed: We need the 'gender' column to differentiate between male and female artists and a count of how many there are of each.", "Use the COUNT() function to count the number of artists for each gender.", "Group the results by gender to get the count for each category (male and female).", "Construct the SQL query using SELECT, COUNT(), and GROUP BY clauses."], "pred_sql": "SELECT gender, COUNT(*) as count FROM artist GROUP BY gender;", "gold_sql": "SELECT count(*) ,  gender FROM artist GROUP BY gender", "source_tables": ["artist"]}
{"sample_id": 3563, "db_id": "music_1", "question": "What is the average rating of songs for each language?", "rationale": ["Identify the relevant table: The 'song' table contains the 'rating' and 'languages' columns needed for this query.", "Determine the aggregation needed: We need to calculate the average rating, which requires the use of the AVG() function.", "Group the results: Since we want the average rating for each language, we will use the GROUP BY clause on the 'languages' column.", "Construct the SQL query: Combine the SELECT statement with the AVG() function and the GROUP BY clause to form the complete SQL query."], "pred_sql": "SELECT languages, AVG(rating) AS average_rating FROM song GROUP BY languages;", "gold_sql": "SELECT avg(rating) ,  languages FROM song GROUP BY languages", "source_tables": ["song"]}
{"sample_id": 3564, "db_id": "music_1", "question": "What is the average song rating for each language?", "rationale": ["Identify the relevant table: The 'song' table contains the 'rating' and 'languages' columns needed for this query.", "Determine the aggregation needed: We need to calculate the average rating, which requires the use of the AVG() function.", "Group the results: Since we want the average rating for each language, we will use the GROUP BY clause on the 'languages' column.", "Construct the SQL query: Combine the SELECT statement with the AVG() function and the GROUP BY clause to form the complete SQL query."], "pred_sql": "SELECT languages, AVG(rating) AS average_rating FROM song GROUP BY languages;", "gold_sql": "SELECT avg(rating) ,  languages FROM song GROUP BY languages", "source_tables": ["song"]}
{"sample_id": 3565, "db_id": "music_1", "question": "Return the gender and name of artist who produced the song with the lowest resolution.", "rationale": ["Identify the relevant tables: artist, song, and files.", "We need to find the song with the lowest resolution, so we will focus on the files table to get the resolution information.", "We will use a subquery to find the minimum resolution from the files table.", "Next, we will join the artist table with the song table on the artist_name to get the artist's gender and name.", "We will also join the song table with the files table on f_id to access the resolution of the song.", "Finally, we will select the gender and artist_name from the artist table where the resolution matches the minimum resolution found in the subquery."], "pred_sql": "SELECT artist.gender, artist.artist_name FROM artist JOIN song ON artist.artist_name = song.artist_name JOIN files ON song.f_id = files.f_id WHERE files.resolution = (SELECT MIN(resolution) FROM files);", "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"]}
{"sample_id": 3566, "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the relevant tables: artist, song, and files are needed to get the artist's gender and name based on the song's resolution.", "Determine the relationship between the tables: artist is linked to song through artist_name, and song is linked to files through f_id.", "Find the smallest resolution: use a subquery to select the minimum resolution from the files table.", "Join the tables: join artist, song, and files to get the artist's gender and name for the song with the smallest resolution.", "Select the required columns: choose the gender and artist_name from the artist table."], "pred_sql": "SELECT artist.gender, artist.artist_name FROM artist JOIN song ON artist.artist_name = song.artist_name JOIN files ON song.f_id = files.f_id WHERE files.resolution = (SELECT MIN(resolution) FROM files);", "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"]}
{"sample_id": 3567, "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["Identify the relevant tables: We need to use the 'files' table to get the file formats and the 'song' table to link songs to their respective artists.", "Join the 'files' table with the 'song' table on the 'f_id' column to associate each file format with the songs that use that format.", "Use the COUNT function to count the distinct artists for each file format, ensuring that we only count each artist once per format.", "Group the results by the 'formats' column to get the count of artists for each unique file format."], "pred_sql": "SELECT formats, COUNT(DISTINCT artist_name) AS artist_count \nFROM files \nJOIN song ON files.f_id = song.f_id \nGROUP BY formats;", "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"]}
{"sample_id": 3568, "db_id": "music_1", "question": "How many songs were released for each format?", "rationale": ["Identify the relevant tables: We need to count songs based on their formats, so we will use the 'files' and 'song' tables.", "Determine the relationship: The 'files' table has a foreign key 'f_id' that links to the 'song' table, allowing us to join these tables.", "Select the necessary columns: We need the 'formats' from the 'files' table and the count of 'song_name' from the 'song' table.", "Group the results: To get the count of songs for each format, we will use the GROUP BY clause on the 'formats' column."], "pred_sql": "SELECT formats, COUNT(song_name) AS song_count FROM files JOIN song ON files.f_id = song.f_id GROUP BY formats;", "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"]}
{"sample_id": 3569, "db_id": "music_1", "question": "Find the distinct names of all songs that have a higher resolution than some songs in English.", "rationale": ["Identify the main requirement: to find distinct song names with a higher resolution than some English songs.", "Determine the relevant table: the 'song' table contains the necessary information about songs, including their resolution and languages.", "Use a subquery to find the maximum resolution of songs that are in English. This is done by selecting from the 'song' table where the 'languages' column contains 'English'.", "In the main query, select distinct song names from the 'song' table where the resolution is greater than the maximum resolution found in the subquery."], "pred_sql": "SELECT DISTINCT s.song_name FROM song s WHERE s.resolution > (SELECT MAX(s2.resolution) FROM song s2 WHERE s2.languages LIKE '%English%');", "gold_sql": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  'english')", "source_tables": ["song"]}
{"sample_id": 3570, "db_id": "music_1", "question": "What are the different names for all songs that have a higher resolution than English songs?", "rationale": ["Identify the requirement to find song names with a higher resolution than English songs.", "Determine that we need to compare the resolution of songs, specifically those that are in English.", "Use a subquery to find the maximum resolution of songs that are in English.", "Select distinct song names from the song table where the resolution is greater than the maximum resolution found in the subquery."], "pred_sql": "SELECT DISTINCT song_name FROM song WHERE resolution > (SELECT MAX(resolution) FROM song WHERE languages LIKE '%English%');", "gold_sql": "SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  'english')", "source_tables": ["song"]}
{"sample_id": 3571, "db_id": "music_1", "question": "What are the names of all songs that have a lower rating than some song of blues genre?", "rationale": ["Identify the requirement: We need to find song names with a rating lower than some song in the blues genre.", "Determine the relevant table: The 'song' table contains the song names and their ratings.", "Formulate a subquery to find the maximum rating of songs in the blues genre: This will help us compare other songs' ratings against it.", "Construct the main query to select song names from the 'song' table where their rating is less than the maximum rating obtained from the subquery."], "pred_sql": "SELECT song_name FROM song WHERE rating < (SELECT MAX(rating) FROM song WHERE genre_is = 'blues')", "gold_sql": "SELECT song_name FROM song WHERE rating  <  (SELECT max(rating) FROM song WHERE genre_is  =  'blues')", "source_tables": ["song"]}
{"sample_id": 3572, "db_id": "music_1", "question": "What are the names of the songs that have a lower rating than at least one blues song?", "rationale": ["Identify the songs that have a rating lower than at least one blues song.", "To do this, we need to find the minimum rating of songs in the blues genre.", "We will use a subquery to select the minimum rating from the song table where the genre is 'blues'.", "Then, we will select the song names from the song table where the rating is less than this minimum rating."], "pred_sql": "SELECT song_name FROM song WHERE rating < (SELECT MIN(rating) FROM song WHERE genre_is = 'blues')", "gold_sql": "SELECT song_name FROM song WHERE rating  <  (SELECT max(rating) FROM song WHERE genre_is  =  'blues')", "source_tables": ["song"]}
{"sample_id": 3573, "db_id": "music_1", "question": "What is the name and country of origin of the artist who released a song that has \"love\" in its title?", "rationale": ["Identify the relevant tables: We need information from the 'artist' table for the artist's name and country, and from the 'song' table for the song title.", "Determine the relationship between the tables: The 'artist' table is related to the 'song' table through the 'artist_name' column.", "Formulate the query: We need to select the artist's name and country from the 'artist' table where the song title in the 'song' table contains the word 'love'.", "Use the SQL JOIN clause to combine the 'artist' and 'song' tables based on the artist's name.", "Use the LIKE operator to filter song titles that contain 'love'."], "pred_sql": "SELECT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE song.song_name LIKE '%love%';", "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.song_name LIKE '%love%'", "source_tables": ["artist", "song"]}
{"sample_id": 3574, "db_id": "music_1", "question": "What are the names of the artists who released a song that has the word love in its title, and where are the artists from?", "rationale": ["Identify the tables needed: We need information from the 'artist' table for artist names and countries, and from the 'song' table for song titles.", "Determine the relationship between the tables: The 'artist' table is related to the 'song' table through the 'artist_name' column.", "Formulate the condition: We need to filter songs that have 'love' in their title, which can be done using the LIKE operator with wildcards.", "Construct the SELECT statement: We want to select the artist's name and country from the 'artist' table.", "Join the tables: Use an INNER JOIN to combine 'artist' and 'song' based on the artist's name.", "Combine all parts into a complete SQL query."], "pred_sql": "SELECT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE song.song_name LIKE '%love%';", "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.song_name LIKE '%love%'", "source_tables": ["artist", "song"]}
{"sample_id": 3575, "db_id": "music_1", "question": "List the name and gender for all artists who released songs in March.", "rationale": ["Identify the tables needed: We need information from the 'artist' table for artist names and genders, and from the 'song' table to check the release dates of the songs.", "Determine the relationship between the tables: The 'artist' table is related to the 'song' table through the 'artist_name' column.", "Filter the songs released in March: We can use the 'releasedate' column in the 'song' table and apply the strftime function to extract the month and check if it equals '03'.", "Select the required columns: We need to select 'artist_name' and 'gender' from the 'artist' table."], "pred_sql": "SELECT artist.artist_name, artist.gender FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE strftime('%m', song.releasedate) = '03';", "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"]}
{"sample_id": 3576, "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["Identify the relevant tables: We need information from the 'artist' table for artist names and genders, and from the 'song' table to filter songs released in March.", "Determine the relationship between the tables: The 'artist' table is related to the 'song' table through the 'artist_name' column.", "Select the required columns: We need to select 'artist_name' and 'gender' from the 'artist' table.", "Filter the results: We need to filter songs that were released in March. In SQLite, we can use the strftime function to extract the month from the 'releasedate' column of the 'song' table.", "Use DISTINCT to avoid duplicate entries: Since an artist may have released multiple songs in March, we use DISTINCT to get unique artist names and genders."], "pred_sql": "SELECT DISTINCT artist.artist_name, artist.gender \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE strftime('%m', song.releasedate) = '03';", "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"]}
{"sample_id": 3577, "db_id": "music_1", "question": "List the names of all genres in alphabetical oder, together with its ratings.", "rationale": ["Identify the table that contains the genre names and ratings, which is the 'genre' table.", "Select the columns 'g_name' and 'rating' from the 'genre' table.", "Use the ORDER BY clause to sort the results by 'g_name' in ascending order."], "pred_sql": "SELECT g_name, rating FROM genre ORDER BY g_name ASC;", "gold_sql": "SELECT g_name ,  rating FROM genre ORDER BY g_name", "source_tables": ["genre"]}
{"sample_id": 3578, "db_id": "music_1", "question": "What are the names of all genres in alphabetical order, combined with its ratings?", "rationale": ["Identify the table that contains the genre names and ratings, which is the 'genre' table.", "Select the columns 'g_name' and 'rating' from the 'genre' table.", "To get the genres in alphabetical order, use the ORDER BY clause on the 'g_name' column in ascending order."], "pred_sql": "SELECT g_name, rating FROM genre ORDER BY g_name ASC;", "gold_sql": "SELECT g_name ,  rating FROM genre ORDER BY g_name", "source_tables": ["genre"]}
{"sample_id": 3579, "db_id": "music_1", "question": "Give me a list of the names of all songs ordered by their resolution.", "rationale": ["Identify the table that contains the song names, which is the 'song' table.", "Select the 'song_name' column from the 'song' table to get the names of the songs.", "Use the ORDER BY clause to sort the results by the 'resolution' column in ascending order."], "pred_sql": "SELECT song_name FROM song ORDER BY resolution;", "gold_sql": "SELECT song_name FROM song ORDER BY resolution", "source_tables": ["song"]}
{"sample_id": 3580, "db_id": "music_1", "question": "What are the names of all songs that are ordered by their resolution numbers?", "rationale": ["Identify the table that contains the song names, which is the 'song' table.", "Select the 'song_name' column from the 'song' table to get the names of the songs.", "Use the ORDER BY clause to sort the results based on the 'resolution' column in ascending order."], "pred_sql": "SELECT song_name FROM song ORDER BY resolution;", "gold_sql": "SELECT song_name FROM song ORDER BY resolution", "source_tables": ["song"]}
{"sample_id": 3581, "db_id": "music_1", "question": "What are the ids of songs that are available in either mp4 format or have resolution above 720?", "rationale": ["Identify the relevant tables: 'song' and 'files' are needed since we are interested in song IDs and their formats/resolution.", "Determine the relationship between the tables: 'song' has a foreign key 'f_id' that links to 'files'.", "Specify the conditions: We need songs that are either in mp4 format or have a resolution greater than 720.", "Use the SQL SELECT statement to retrieve the distinct 'f_id' from the 'song' table.", "Join the 'song' and 'files' tables on 'f_id' to access the formats of the files associated with each song.", "Use the WHERE clause to filter results based on the specified conditions regarding formats and resolution."], "pred_sql": "SELECT DISTINCT song.f_id FROM song JOIN files ON song.f_id = files.f_id WHERE files.formats LIKE '%mp4%' OR song.resolution > '720';", "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' UNION SELECT f_id FROM song WHERE resolution  >  720", "source_tables": ["files", "song"]}
{"sample_id": 3582, "db_id": "music_1", "question": "What are the ids of all songs that are available on mp4 or have a higher resolution than 720?", "rationale": ["Identify the requirement to find song IDs based on file formats and resolution.", "The query needs to select the 'f_id' from the 'song' table.", "We need to check if the song's file is in mp4 format or has a resolution higher than 720.", "To check for mp4 format, we will use a subquery on the 'files' table to find 'f_id' where formats contain 'mp4'.", "For the resolution check, we will directly filter the 'song' table for records where resolution is greater than 720.", "Combine both conditions using an OR operator to get the final result."], "pred_sql": "SELECT f_id FROM song WHERE f_id IN (SELECT f_id FROM files WHERE formats LIKE '%mp4%') OR resolution > '720';", "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' UNION SELECT f_id FROM song WHERE resolution  >  720", "source_tables": ["files", "song"]}
{"sample_id": 3583, "db_id": "music_1", "question": "List the names of all songs that have 4 minute duration or are in English.", "rationale": ["Identify the table that contains the song names, which is the 'song' table.", "Determine the conditions for filtering the songs: they should either have a duration of 4 minutes or be in English.", "The duration is stored in the 'duration' column, and the languages are stored in the 'languages' column.", "Construct the SQL query to select the 'song_name' from the 'song' table where the duration is '4:00' or the languages include 'English'."], "pred_sql": "SELECT song_name FROM song WHERE duration = '4:00' OR languages LIKE '%English%';", "gold_sql": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '4:%' UNION SELECT song_name FROM song WHERE languages  =  'english'", "source_tables": ["files", "song"]}
{"sample_id": 3584, "db_id": "music_1", "question": "What are the names of all songs that are approximately 4 minutes long or are in English?", "rationale": ["Identify the relevant table: The 'song' table contains the information about songs, including their names and duration.", "Determine the conditions: We need songs that are approximately 4 minutes long or are in English. The duration can be checked using a pattern match (e.g., '4:%' for 4 minutes), and the languages can be checked for the presence of 'English'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'song_name' from the 'song' table where the duration matches the 4-minute pattern or the languages include 'English'."], "pred_sql": "SELECT song_name FROM song WHERE duration LIKE '4:%' OR languages LIKE '%English%';", "gold_sql": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '4:%' UNION SELECT song_name FROM song WHERE languages  =  'english'", "source_tables": ["files", "song"]}
{"sample_id": 3585, "db_id": "music_1", "question": "What is the language used most often in the songs?", "rationale": ["Identify the relevant table: The 'song' table contains a column for 'languages'.", "Count the occurrences of each language: Use COUNT(*) to count how many times each language appears in the 'languages' column.", "Group the results by language: Use GROUP BY languages to aggregate the counts for each unique language.", "Order the results: Use ORDER BY language_count DESC to sort the languages by their count in descending order.", "Limit the results to the top one: Use LIMIT 1 to get the language that is used most often."], "pred_sql": "SELECT languages, COUNT(*) as language_count FROM song GROUP BY languages ORDER BY language_count DESC LIMIT 1;", "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"]}
{"sample_id": 3586, "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["Identify the relevant table: The 'song' table contains a column for 'languages'.", "Determine the goal: We want to find out which languages are used most often in songs.", "Use the COUNT function: To count the occurrences of each language, we will use COUNT(*) and group the results by the 'languages' column.", "Group the results: Use GROUP BY to aggregate the results based on the 'languages' column.", "Order the results: To find the most frequently used languages, we will order the results in descending order based on the count of occurrences."], "pred_sql": "SELECT languages, COUNT(*) as language_count FROM song GROUP BY languages ORDER BY language_count DESC;", "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"]}
{"sample_id": 3587, "db_id": "music_1", "question": "What is the language that was used most often in songs with resolution above 500?", "rationale": ["Identify the relevant table: The 'song' table contains the 'languages' and 'resolution' columns.", "Filter the songs based on the resolution: We need to select songs where the resolution is greater than 500.", "Group the results by language: We want to count how many times each language appears in the filtered results.", "Count the occurrences of each language: Use COUNT() to get the number of songs for each language.", "Order the results: Sort the results in descending order based on the count of languages to find the most frequently used language.", "Limit the results to one: We only need the language that was used most often, so we limit the output to 1."], "pred_sql": "SELECT languages, COUNT(languages) as language_count \nFROM song \nWHERE resolution > 500 \nGROUP BY languages \nORDER BY language_count DESC \nLIMIT 1;", "gold_sql": "SELECT artist_name FROM song WHERE resolution  >  500 GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"]}
{"sample_id": 3588, "db_id": "music_1", "question": "What is the name of the artist, for each language, that has the most songs with a higher resolution than 500?", "rationale": ["Identify the relevant tables: artist, song, and files.", "We need to find artists and their songs, so we will join the artist table with the song table on artist_name.", "We also need to check the resolution of the songs, so we will join the song table with the files table on f_id.", "We need to filter songs with a resolution greater than 500, so we will use a WHERE clause for this condition.", "We want to group the results by artist name and language, so we will use GROUP BY artist.artist_name and song.languages.", "To count the number of songs for each artist and language, we will use COUNT(song.song_name) and alias it as song_count.", "Finally, we will order the results by song_count in descending order to get the artists with the most songs first."], "pred_sql": "SELECT artist.artist_name, song.languages, COUNT(song.song_name) AS song_count\nFROM artist\nJOIN song ON artist.artist_name = song.artist_name\nJOIN files ON song.f_id = files.f_id\nWHERE files.resolution > 500\nGROUP BY artist.artist_name, song.languages\nORDER BY song_count DESC;", "gold_sql": "SELECT artist_name FROM song WHERE resolution  >  500 GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"]}
{"sample_id": 3589, "db_id": "music_1", "question": "What are the names of artists who are Male and are from UK?", "rationale": ["Identify the relevant table: The 'artist' table contains information about artists, including their gender and country.", "Determine the conditions: We need to filter artists based on gender (Male) and country (UK).", "Construct the SQL SELECT statement: We will select the 'artist_name' column from the 'artist' table where the specified conditions are met.", "Combine the conditions using the WHERE clause to filter the results accordingly."], "pred_sql": "SELECT artist_name FROM artist WHERE gender = 'Male' AND country = 'UK';", "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"]}
{"sample_id": 3590, "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["Identify the table that contains information about artists, which is the 'artist' table.", "Determine the columns needed: 'artist_name' for the names of the artists, and 'country' and 'gender' to filter the results.", "Set the conditions for the query: the country must be 'British' and the gender must be 'male'.", "Construct the SQL SELECT statement to retrieve the 'artist_name' from the 'artist' table with the specified conditions."], "pred_sql": "SELECT artist_name FROM artist WHERE country = 'British' AND gender = 'male';", "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"]}
{"sample_id": 3591, "db_id": "music_1", "question": "Find the names of songs whose genre is modern or language is English.", "rationale": ["Identify the relevant table: The 'song' table contains the information about songs, including their genre and languages.", "Determine the columns needed: We need the 'song_name' column to get the names of the songs.", "Define the conditions: We want songs where the genre is 'modern' or the language is 'English'.", "Construct the SQL query using the SELECT statement to retrieve 'song_name' from the 'song' table with the specified conditions using the WHERE clause."], "pred_sql": "SELECT song_name FROM song WHERE genre_is = 'modern' OR languages = 'English';", "gold_sql": "SELECT song_name FROM song WHERE genre_is  =  'modern' OR languages  =  'english'", "source_tables": ["song"]}
{"sample_id": 3592, "db_id": "music_1", "question": "What are the names of the songs that are modern or sung in English?", "rationale": ["Identify the relevant table: The 'song' table contains the information about songs, including their names and genres.", "Determine the criteria for selection: The user wants songs that are either of the genre 'modern' or sung in English.", "Construct the SQL query: Use a SELECT statement to retrieve the 'song_name' from the 'song' table where the 'genre_is' is 'modern' or the 'languages' column contains 'English'.", "Use the OR operator to combine the two conditions in the WHERE clause."], "pred_sql": "SELECT song_name FROM song WHERE genre_is = 'modern' OR languages LIKE '%English%';", "gold_sql": "SELECT song_name FROM song WHERE genre_is  =  'modern' OR languages  =  'english'", "source_tables": ["song"]}
{"sample_id": 3593, "db_id": "music_1", "question": "Return the names of songs for which format is mp3 and resolution is below 1000.", "rationale": ["Identify the relevant tables: We need to retrieve song names, which are in the 'song' table, and we need to filter based on file formats and resolution, which are in the 'files' table.", "Determine the join condition: The 'song' table has a foreign key 'f_id' that links to the 'files' table's 'f_id'. We will join these two tables on this key.", "Select the required columns: We need to select 'song_name' from the 'song' table.", "Apply the filters: We need to filter the results where the 'formats' column in the 'files' table contains 'mp3' and the 'resolution' column is below 1000. We will use the LIKE operator for the format and a simple comparison for the resolution."], "pred_sql": "SELECT song_name FROM song JOIN files ON song.f_id = files.f_id WHERE formats LIKE '%mp3%' AND resolution < '1000';", "gold_sql": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.formats  =  'mp3' INTERSECT SELECT song_name FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"]}
{"sample_id": 3594, "db_id": "music_1", "question": "What are the names of all songs that are in mp3 format and have a resolution lower than 1000?", "rationale": ["Identify the relevant tables: 'song' and 'files' are needed to get song names and file formats.", "Determine the conditions: we need songs that are in mp3 format and have a resolution lower than 1000.", "Join the 'song' and 'files' tables on the foreign key 'f_id' to access both song names and file formats.", "Use the WHERE clause to filter songs that are in mp3 format (using LIKE '%mp3%') and have a resolution less than 1000.", "Select the 'song_name' from the resulting dataset."], "pred_sql": "SELECT song.song_name FROM song JOIN files ON song.f_id = files.f_id WHERE files.formats LIKE '%mp3%' AND song.resolution < '1000';", "gold_sql": "SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.formats  =  'mp3' INTERSECT SELECT song_name FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"]}
{"sample_id": 3595, "db_id": "music_1", "question": "Return the names of singers who are from UK and released an English song.", "rationale": ["Identify the relevant tables: 'artist' for singer information and 'song' for song details.", "We need to find singers from the UK, so we will filter the 'artist' table by the 'country' column.", "We also need to check for songs that are in English, which requires filtering the 'song' table by the 'languages' column.", "To get the names of singers who meet both criteria, we will perform a JOIN operation between the 'artist' and 'song' tables on the 'artist_name' column.", "Finally, we will select the distinct names of artists to avoid duplicates."], "pred_sql": "SELECT DISTINCT artist.artist_name \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE artist.country = 'UK' AND song.languages LIKE '%English%';", "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' INTERSECT SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'english'", "source_tables": ["artist", "song"]}
{"sample_id": 3596, "db_id": "music_1", "question": "What are the names of all singers that are from the UK and released a song in English?", "rationale": ["Identify the relevant tables: 'artist' and 'song' are needed to find singers and their songs.", "We need to select the 'artist_name' from the 'artist' table.", "We need to join the 'artist' table with the 'song' table on the 'artist_name' column to link artists with their songs.", "We need to filter the results to include only artists from the UK, which is done using the condition 'artist.country = 'UK'',' and also ensure that the song is in English, which is done using 'song.languages LIKE '%English%'.", "Use DISTINCT to ensure that each artist's name is listed only once, even if they have released multiple songs in English."], "pred_sql": "SELECT DISTINCT artist.artist_name \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE artist.country = 'UK' AND song.languages LIKE '%English%';", "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' INTERSECT SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'english'", "source_tables": ["artist", "song"]}
{"sample_id": 3597, "db_id": "music_1", "question": "What are the average rating and resolution of songs that are in Bangla?", "rationale": ["Identify the relevant table: The 'song' table contains the information about songs, including their ratings and resolutions.", "Determine the columns needed: We need the average rating and resolution of songs, so we will use the 'rating' and 'resolution' columns from the 'song' table.", "Filter the songs: We need to filter the songs that are in Bangla, which can be done using the 'languages' column in the 'song' table.", "Use the AVG function: To calculate the average rating and resolution, we will use the AVG() function in SQL.", "Construct the SQL query: Combine all the elements into a complete SQL query that selects the average rating and resolution from the 'song' table where the languages include 'Bangla'."], "pred_sql": "SELECT AVG(song.rating) AS average_rating, AVG(song.resolution) AS average_resolution FROM song WHERE song.languages LIKE '%Bangla%';", "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"]}
{"sample_id": 3598, "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["Identify the relevant table: The 'song' table contains the information about songs, including their ratings and resolutions.", "Determine the columns needed: We need the average rating and resolution of songs, so we will use the 'rating' and 'resolution' columns.", "Filter the songs: We are specifically interested in Bangla songs, which can be filtered using the 'genre_is' column.", "Calculate the averages: Use the AVG() function to calculate the average rating and resolution for the filtered songs."], "pred_sql": "SELECT AVG(song.rating) AS average_rating, AVG(resolution) AS average_resolution FROM song WHERE genre_is = 'Bangla';", "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"]}
{"sample_id": 3599, "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["Identify the relevant table: The 'song' table contains the resolution and duration of songs.", "Determine the conditions: We need to filter songs based on their duration being exactly 3 minutes, which is represented as '3:00'.", "Select the required fields: We need to find the maximum and minimum resolution, so we will use the MAX() and MIN() functions on the 'resolution' column.", "Construct the SQL query: Combine the SELECT statement with the appropriate functions and the WHERE clause to filter by duration."], "pred_sql": "SELECT MAX(resolution) AS max_resolution, MIN(resolution) AS min_resolution FROM song WHERE duration = '3:00';", "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"]}
{"sample_id": 3600, "db_id": "music_1", "question": "What is the maximum and minimum resolution of all songs that are approximately 3 minutes long?", "rationale": ["Identify the relevant table: The 'song' table contains the resolution and duration of songs.", "Determine the condition: We need songs that are approximately 3 minutes long, which can be represented as a specific duration (e.g., '3:00').", "Select the required fields: We need to find the maximum and minimum resolution, so we will use the MAX() and MIN() functions on the 'resolution' column.", "Construct the SQL query: Combine the SELECT statement with the appropriate conditions to filter the songs based on their duration."], "pred_sql": "SELECT MAX(resolution) AS max_resolution, MIN(resolution) AS min_resolution FROM song WHERE duration = '3:00'", "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"]}
{"sample_id": 3601, "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["Identify the relevant table: The 'song' table contains the necessary columns for duration and resolution, as well as languages.", "Select the columns needed: We need to select 'languages', the maximum 'duration', and the maximum 'resolution'.", "Use aggregate functions: To find the maximum values, we will use the MAX() function for both 'duration' and 'resolution'.", "Group the results: We need to group the results by 'languages' to get the maximum duration and resolution for each language.", "Order the results: Finally, we will order the results by 'languages' to have a structured output."], "pred_sql": "SELECT languages, MAX(duration) AS max_duration, MAX(resolution) AS max_resolution FROM song GROUP BY languages ORDER BY languages;", "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"]}
{"sample_id": 3602, "db_id": "music_1", "question": "What are the maximum duration and resolution of all songs, for each language, ordered alphabetically by language?", "rationale": ["Identify the relevant table: The 'song' table contains the necessary columns for duration and resolution, as well as the language of the songs.", "Select the columns needed: We need to select 'languages', the maximum 'duration', and the maximum 'resolution'.", "Use aggregate functions: To find the maximum duration and resolution, we will use the MAX() function for both 'duration' and 'resolution'.", "Group the results: Since we want the maximum values for each language, we will use GROUP BY on the 'languages' column.", "Order the results: Finally, we will order the results alphabetically by the 'languages' column."], "pred_sql": "SELECT languages, MAX(duration) AS max_duration, MAX(resolution) AS max_resolution FROM song GROUP BY languages ORDER BY languages;", "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"]}
{"sample_id": 3603, "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the relevant tables: 'song' and 'genre' are needed to get the song details and their corresponding genres.", "We need to find the shortest duration and lowest rating of songs, which requires using aggregate functions: MIN() for both duration and rating.", "Join the 'song' table with the 'genre' table on the genre column to associate songs with their genres.", "Group the results by genre to get the shortest duration and lowest rating for each genre.", "Order the results by genre name for better readability."], "pred_sql": "SELECT genre.g_name, MIN(song.duration) AS shortest_duration, MIN(song.rating) AS lowest_rating \nFROM song \nJOIN genre ON song.genre_is = genre.g_name \nGROUP BY genre.g_name \nORDER BY genre.g_name;", "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"]}
{"sample_id": 3604, "db_id": "music_1", "question": "What is the shortest and most poorly rated song for each genre, ordered alphabetically by genre?", "rationale": ["Identify the relevant tables: 'song' and 'genre' are needed to get song details and their genres.", "We need to find the shortest song, which requires using the MIN function on the 'duration' column in the 'song' table.", "We also need to find the poorly rated song, which requires using the MIN function on the 'rating' column in the 'song' table.", "Join the 'song' table with the 'genre' table on the genre name to get the genre details for each song.", "Group the results by genre to get the shortest and lowest rated song for each genre.", "Order the final results alphabetically by genre name."], "pred_sql": "SELECT genre.g_name, song.song_name, MIN(song.duration) AS shortest_duration, MIN(song.rating) AS lowest_rating \nFROM song \nJOIN genre ON song.genre_is = genre.g_name \nGROUP BY genre.g_name \nORDER BY genre.g_name;", "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"]}
{"sample_id": 3605, "db_id": "music_1", "question": "Find the names and number of works of all artists who have at least one English songs.", "rationale": ["Identify the tables involved: We need data from the 'artist' and 'song' tables.", "Determine the columns to select: We need the artist's name and the count of their works (songs).", "Establish the relationship between tables: The 'artist' table can be joined with the 'song' table on the 'artist_name' column.", "Filter the results: We only want artists who have at least one song in English, so we will use a WHERE clause to check if the 'languages' column in the 'song' table contains 'English'.", "Group the results by artist name to count the number of works for each artist."], "pred_sql": "SELECT artist.artist_name, COUNT(song.song_name) AS number_of_works \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.languages LIKE '%English%' \nGROUP BY artist.artist_name;", "gold_sql": "SELECT T1.artist_name ,  count(*) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'english' GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"]}
{"sample_id": 3606, "db_id": "music_1", "question": "What are the names and number of works for all artists who have sung at least one song in English?", "rationale": ["Identify the relevant tables: We need information from the 'artist' and 'song' tables.", "Determine the columns needed: We need the artist's name and the count of their works (songs).", "Establish the relationship: Artists are linked to songs through the 'artist_name' column.", "Filter the songs: We only want songs that are in English, which can be checked using the 'languages' column in the 'song' table.", "Group the results: Since we want the number of works per artist, we will group the results by artist name.", "Count the number of works: Use the COUNT function to count the number of songs for each artist."], "pred_sql": "SELECT artist.artist_name, COUNT(song.song_name) AS number_of_works\nFROM artist\nJOIN song ON artist.artist_name = song.artist_name\nWHERE song.languages LIKE '%English%'\nGROUP BY artist.artist_name;", "gold_sql": "SELECT T1.artist_name ,  count(*) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'english' GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"]}
{"sample_id": 3607, "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["Identify the tables involved: We need information from the 'artist' table for artist names and countries, the 'song' table to link artists to their songs, and the 'files' table to check the resolution of the songs.", "Determine the relationships: The 'artist' table is linked to the 'song' table through 'artist_name', and the 'song' table is linked to the 'files' table through 'f_id'.", "Select the required columns: We need to select 'artist_name' and 'country' from the 'artist' table.", "Apply the condition: We need to filter the results to include only those songs where the resolution is greater than 900, which is found in the 'files' table.", "Use DISTINCT to avoid duplicate entries: Since an artist may have multiple songs that meet the criteria, we use DISTINCT to ensure each artist is listed only once."], "pred_sql": "SELECT DISTINCT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name JOIN files ON song.f_id = files.f_id WHERE files.resolution > 900;", "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"]}
{"sample_id": 3608, "db_id": "music_1", "question": "What is the name and country of origin for each artist who has released a song with a resolution higher than 900?", "rationale": ["Identify the tables involved: We need information from the 'artist' table and the 'song' table.", "Determine the columns to select: We want the artist's name and their country of origin, which are in the 'artist' table.", "Establish the relationship between tables: The 'artist' table can be joined with the 'song' table on the 'artist_name' column.", "Set the condition for the query: We need to filter songs based on their resolution being higher than 900, which is a condition on the 'song' table.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses to retrieve the desired information."], "pred_sql": "SELECT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE song.resolution > '900';", "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"]}
{"sample_id": 3609, "db_id": "music_1", "question": "Find the names and number of works of the three artists who have produced the most songs.", "rationale": ["Identify the relevant table: The 'song' table contains information about songs and their associated artists.", "Select the columns needed: We need the 'artist_name' and the count of songs for each artist.", "Use the COUNT() function to count the number of songs for each artist.", "Group the results by 'artist_name' to aggregate the song counts for each artist.", "Order the results in descending order based on the count of songs to get the artists with the most songs at the top.", "Limit the results to the top 3 artists to meet the requirement of finding the three artists with the most songs."], "pred_sql": "SELECT artist_name, COUNT(song_name) AS number_of_songs \nFROM song \nGROUP BY artist_name \nORDER BY number_of_songs DESC \nLIMIT 3;", "gold_sql": "SELECT T1.artist_name ,  count(*) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"]}
{"sample_id": 3610, "db_id": "music_1", "question": "What are the names of the three artists who have produced the most songs, and how many works did they produce?", "rationale": ["Identify the relevant table: The 'song' table contains information about songs and their associated artists.", "We need to count the number of songs produced by each artist, so we will use the COUNT() function on the 'song_name' column.", "To group the results by artist, we will use the GROUP BY clause on the 'artist_name' column.", "To find the top three artists, we will order the results in descending order based on the count of songs and limit the results to 3 using the ORDER BY and LIMIT clauses."], "pred_sql": "SELECT artist_name, COUNT(song_name) AS song_count \nFROM song \nGROUP BY artist_name \nORDER BY song_count DESC \nLIMIT 3;", "gold_sql": "SELECT T1.artist_name ,  count(*) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"]}
{"sample_id": 3611, "db_id": "music_1", "question": "Find the country of origin for the artist who made the least number of songs?", "rationale": ["We need to find the country of origin for the artist who made the least number of songs.", "To do this, we will join the 'artist' table with the 'song' table on the 'artist_name' column, as this will allow us to associate each artist with their songs.", "Next, we will group the results by 'artist.artist_name' to count the number of songs each artist has made.", "We will use the COUNT() function to count the number of songs for each artist.", "To find the artist with the least number of songs, we will order the results in ascending order based on the count of songs.", "Finally, we will limit the results to 1 to get only the artist with the least number of songs, and select the 'country' from the 'artist' table."], "pred_sql": "SELECT artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name GROUP BY artist.artist_name ORDER BY COUNT(song.song_name) ASC LIMIT 1;", "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name GROUP BY T2.artist_name ORDER BY count(*) LIMIT 1", "source_tables": ["artist", "song"]}
{"sample_id": 3612, "db_id": "music_1", "question": "What country is the artist who made the fewest songs from?", "rationale": ["Identify the artist who has made the fewest songs.", "To do this, we need to count the number of songs for each artist in the 'song' table.", "We will group the results by 'artist_name' and order them by the count of songs in ascending order.", "The artist with the fewest songs will be the first in this ordered list, so we will limit our results to 1.", "Once we have the artist's name, we can then select the corresponding country from the 'artist' table."], "pred_sql": "SELECT country FROM artist WHERE artist_name = (SELECT artist_name FROM song GROUP BY artist_name ORDER BY COUNT(song_name) ASC LIMIT 1);", "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name GROUP BY T2.artist_name ORDER BY count(*) LIMIT 1", "source_tables": ["artist", "song"]}
{"sample_id": 3613, "db_id": "music_1", "question": "What are the names of the songs whose rating is below the rating of all songs in English?", "rationale": ["Identify the main requirement: We need to find the names of songs with a rating below a certain threshold.", "The threshold is defined as the rating of all songs in English, so we need to first find the minimum rating of songs that are in English.", "To do this, we will use a subquery that selects the minimum rating from the song table where the languages column contains 'English'.", "Next, we will select the song names from the song table where the rating is less than the result of the subquery.", "Finally, we will combine these steps into a single SQL query."], "pred_sql": "SELECT song_name FROM song WHERE rating < (SELECT MIN(rating) FROM song WHERE languages LIKE '%English%');", "gold_sql": "SELECT song_name FROM song WHERE rating  <   (SELECT min(rating) FROM song WHERE languages  =  'english')", "source_tables": ["song"]}
{"sample_id": 3614, "db_id": "music_1", "question": "What are the song names for every song whose rating is less than the minimum rating for English songs?", "rationale": ["Identify the main requirement: to find song names with a rating less than the minimum rating for English songs.", "Determine the relevant table: the 'song' table contains the song names and ratings.", "To find the minimum rating for English songs, a subquery is needed that selects the minimum rating from the 'song' table where the languages column includes 'English'.", "Construct the main query to select song names from the 'song' table where the rating is less than the result of the subquery."], "pred_sql": "SELECT song_name FROM song WHERE rating < (SELECT MIN(rating) FROM song WHERE languages LIKE '%English%');", "gold_sql": "SELECT song_name FROM song WHERE rating  <   (SELECT min(rating) FROM song WHERE languages  =  'english')", "source_tables": ["song"]}
{"sample_id": 3615, "db_id": "music_1", "question": "What is ids of the songs whose resolution is higher than the resolution of any songs with rating lower than 8?", "rationale": ["Identify the main requirement: We need to find the IDs of songs with a resolution higher than the maximum resolution of songs that have a rating lower than 8.", "To achieve this, we will use a subquery to first find the maximum resolution of songs with a rating lower than 8.", "The subquery will select the maximum resolution from the song table where the rating is less than 8.", "The outer query will select the distinct file IDs (f_id) from the song table where the resolution is greater than the result of the subquery."], "pred_sql": "SELECT DISTINCT s1.f_id FROM song s1 WHERE s1.resolution > (SELECT MAX(s2.resolution) FROM song s2 WHERE s2.rating < 8);", "gold_sql": "SELECT f_id FROM song WHERE resolution  >  (SELECT max(resolution) FROM song WHERE rating  <  8)", "source_tables": ["song"]}
{"sample_id": 3616, "db_id": "music_1", "question": "What is the id of every song that has a resolution higher than that of a song with a rating below 8?", "rationale": ["Identify the main requirement: We need to find the IDs of songs with a resolution higher than a certain threshold.", "The threshold is defined as the resolution of songs that have a rating below 8.", "To find this threshold, we will use a subquery that selects the maximum resolution from the 'song' table where the rating is below 8.", "The main query will then select the 'f_id' from the 'song' table where the resolution is greater than the result of the subquery."], "pred_sql": "SELECT s1.f_id FROM song s1 WHERE s1.resolution > (SELECT MAX(s2.resolution) FROM song s2 WHERE s2.rating < 8)", "gold_sql": "SELECT f_id FROM song WHERE resolution  >  (SELECT max(resolution) FROM song WHERE rating  <  8)", "source_tables": ["song"]}
{"sample_id": 3617, "db_id": "music_1", "question": "What is ids of the songs whose resolution is higher than the average resolution of songs in modern genre?", "rationale": ["Identify the relevant tables: We need to work with the 'song' table to get song IDs and the 'genre' table to filter by genre.", "Determine the condition: We need to find songs with a resolution higher than the average resolution of songs in the 'modern' genre.", "Calculate the average resolution: We will use a subquery to calculate the average resolution of songs in the 'modern' genre.", "Join the tables: We will join the 'song' table with the 'genre' table to filter songs based on the genre.", "Select the song IDs: Finally, we will select the 'f_id' from the 'song' table where the resolution condition is met."], "pred_sql": "SELECT s.f_id FROM song s JOIN genre g ON s.genre_is = g.g_name WHERE s.resolution > (SELECT AVG(resolution) FROM song WHERE genre_is = 'modern')", "gold_sql": "SELECT f_id FROM song WHERE resolution  >  (SELECT avg(resolution) FROM song WHERE genre_is  =  'modern')", "source_tables": ["song"]}
{"sample_id": 3618, "db_id": "music_1", "question": "What are the ids of all songs that have higher resolution of the average resolution in the modern genre?", "rationale": ["Identify the relevant tables: 'song' for song details and 'genre' for genre information.", "Determine the condition: we need songs from the 'modern' genre and their resolution should be higher than the average resolution of that genre.", "Calculate the average resolution for the 'modern' genre using a subquery: SELECT AVG(resolution) FROM song WHERE genre_is = 'modern'.", "Join the 'song' table with the 'genre' table to filter songs that belong to the 'modern' genre.", "Select the file IDs (f_id) of songs that meet the resolution condition."], "pred_sql": "SELECT s.f_id FROM song s JOIN genre g ON s.genre_is = g.g_name WHERE s.resolution > (SELECT AVG(resolution) FROM song WHERE genre_is = 'modern')", "gold_sql": "SELECT f_id FROM song WHERE resolution  >  (SELECT avg(resolution) FROM song WHERE genre_is  =  'modern')", "source_tables": ["song"]}
{"sample_id": 3619, "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including the artist name and the languages in which the songs are available.", "Filter the songs: We need to filter the songs where the 'languages' column contains 'Bangla'. This can be done using the LIKE operator.", "Group by artist: To find the number of songs per artist, we will group the results by 'artist_name'.", "Count the songs: We will use the COUNT() function to count the number of songs for each artist.", "Order the results: We want the artists with the largest number of songs, so we will order the results in descending order based on the count of songs.", "Limit the results: Finally, we will limit the results to the top 3 artists."], "pred_sql": "SELECT artist_name, COUNT(*) AS song_count \nFROM song \nWHERE languages LIKE '%Bangla%' \nGROUP BY artist_name \nORDER BY song_count DESC \nLIMIT 3;", "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"]}
{"sample_id": 3620, "db_id": "music_1", "question": "What are the top 3 artists with the largest number of songs in the language Bangla?", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including the artist name and the languages in which the songs are available.", "Filter the songs: We need to filter the songs to only include those that are in the language 'Bangla'. This can be done using a WHERE clause with a LIKE condition.", "Group by artist: To find the number of songs per artist, we will use the GROUP BY clause on the 'artist_name' column.", "Count the songs: We will use the COUNT() function to count the number of songs for each artist.", "Order the results: To get the top artists, we will order the results in descending order based on the count of songs.", "Limit the results: Finally, we will limit the results to the top 3 artists using the LIMIT clause."], "pred_sql": "SELECT artist_name, COUNT(song_name) AS song_count \nFROM song \nWHERE languages LIKE '%Bangla%' \nGROUP BY artist_name \nORDER BY song_count DESC \nLIMIT 3;", "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"]}
{"sample_id": 3621, "db_id": "music_1", "question": "List the id, genre and artist name of English songs ordered by rating.", "rationale": ["Identify the columns needed: f_id (from song), genre (from song), and artist_name (from song).", "Filter the songs to include only those that are in English by checking the 'languages' column in the song table.", "Order the results by the 'rating' column in the song table to get the desired order.", "Construct the SQL SELECT statement to retrieve the specified columns from the song table with the appropriate WHERE and ORDER BY clauses."], "pred_sql": "SELECT song.f_id, song.genre_is, song.artist_name FROM song WHERE song.languages LIKE '%English%' ORDER BY song.rating;", "gold_sql": "SELECT f_id ,  genre_is ,  artist_name FROM song WHERE languages  =   'english' ORDER BY rating", "source_tables": ["song"]}
{"sample_id": 3622, "db_id": "music_1", "question": "What is the id, genre, and name of the artist for every English song ordered by ascending rating?", "rationale": ["Identify the columns needed: f_id (from song), genre (from song), and artist_name (from song).", "Filter the songs to include only those that are in English by checking the 'languages' column.", "Order the results by the 'rating' column in ascending order.", "Construct the SQL SELECT statement to retrieve the specified columns from the song table with the appropriate WHERE and ORDER BY clauses."], "pred_sql": "SELECT song.f_id, song.genre_is, song.artist_name FROM song WHERE song.languages LIKE '%English%' ORDER BY song.rating ASC;", "gold_sql": "SELECT f_id ,  genre_is ,  artist_name FROM song WHERE languages  =   'english' ORDER BY rating", "source_tables": ["song"]}
{"sample_id": 3623, "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "Determine the columns needed: 'duration' from 'song', and 'file_size' and 'formats' from 'files'.", "Establish the relationship between the tables: 'song' and 'files' are linked by 'f_id'.", "Filter the results to include only songs where the genre is 'pop'.", "Order the results by the song title, which corresponds to 'song_name' in the 'song' table."], "pred_sql": "SELECT s.duration, f.file_size, f.formats \nFROM song s \nJOIN files f ON s.f_id = f.f_id \nWHERE s.genre_is = 'pop' \nORDER BY s.song_name;", "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"]}
{"sample_id": 3624, "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "Determine the columns needed: 'duration' from 'song', 'file_size' and 'formats' from 'files'.", "Establish the relationship between the tables using the foreign key: 'song.f_id' relates to 'files.f_id'.", "Filter the results to include only pop songs by adding a WHERE clause: 's.genre_is = 'pop''.", "Order the results alphabetically by song title using ORDER BY clause: 'ORDER BY s.song_name ASC'.", "Construct the final SQL query using the SELECT statement with the identified columns and conditions."], "pred_sql": "SELECT s.duration, f.file_size, f.formats FROM song s JOIN files f ON s.f_id = f.f_id WHERE s.genre_is = 'pop' ORDER BY s.song_name ASC;", "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"]}
{"sample_id": 3625, "db_id": "music_1", "question": "Find the names of the artists who have produced English songs but have never received rating higher than 8.", "rationale": ["Identify the relevant tables: We need to use the 'artist' and 'song' tables to find the artists and their songs.", "We need to find artists who have produced English songs. This requires a JOIN between the 'artist' and 'song' tables on the 'artist_name' column.", "We filter the songs to include only those that are in English by using a WHERE clause with the condition 'song.languages LIKE '%English%''.", "Next, we need to ensure that these artists have never received a rating higher than 8. This can be done by using a subquery that selects artist names from the 'song' table where the rating is greater than 8.", "We use the NOT IN clause to exclude any artist names that appear in the subquery from our main query. This ensures we only get artists who have not received a rating higher than 8."], "pred_sql": "SELECT DISTINCT artist.artist_name \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.languages LIKE '%English%' \nAND artist.artist_name NOT IN (\n    SELECT artist_name \n    FROM song \n    WHERE rating > '8'\n)", "gold_sql": "SELECT DISTINCT artist_name FROM song WHERE languages  =  'english' EXCEPT SELECT DISTINCT artist_name FROM song WHERE rating  >  8", "source_tables": ["song"]}
{"sample_id": 3626, "db_id": "music_1", "question": "What are the names of the different artists that have produced a song in English but have never receieved a rating higher than 8?", "rationale": ["Identify the relevant tables: We need to look at the 'artist' and 'song' tables since we are interested in artist names and their songs.", "Join the 'artist' and 'song' tables on the 'artist_name' column to link artists with their songs.", "Filter the results to include only those songs that are in English. This can be done using a WHERE clause with a condition that checks if the 'languages' column contains 'English'.", "Additionally, we need to ensure that the songs have a rating of 8 or lower. This is done by adding another condition in the WHERE clause that checks if the 'rating' column is less than or equal to 8.", "Use DISTINCT to ensure that we only get unique artist names in the final result."], "pred_sql": "SELECT DISTINCT artist.artist_name \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.languages LIKE '%English%' \nAND song.rating <= '8';", "gold_sql": "SELECT DISTINCT artist_name FROM song WHERE languages  =  'english' EXCEPT SELECT DISTINCT artist_name FROM song WHERE rating  >  8", "source_tables": ["song"]}
{"sample_id": 3627, "db_id": "music_1", "question": "Find the names of the artists who are from Bangladesh and have never received rating higher than 7.", "rationale": ["Identify the table that contains artist information, which is the 'artist' table.", "We need to filter artists based on their country, specifically 'Bangladesh'.", "Next, we need to ensure that these artists have never received a rating higher than 7.", "To do this, we can use a subquery that selects artist names from the 'song' table where the rating is greater than 7.", "We will use the NOT IN clause to exclude any artist names that appear in the subquery from our main query.", "Finally, we will select the artist names that meet both conditions."], "pred_sql": "SELECT artist_name FROM artist WHERE country = 'Bangladesh' AND artist_name NOT IN (SELECT artist_name FROM song WHERE rating > '7')", "gold_sql": "SELECT DISTINCT artist_name FROM artist WHERE country  =  'Bangladesh' EXCEPT SELECT DISTINCT artist_name FROM song WHERE rating  >  7", "source_tables": ["artist", "song"]}
{"sample_id": 3628, "db_id": "music_1", "question": "What are the names of the different artists from Bangladesh who never received a rating higher than a 7?", "rationale": ["Identify the table that contains artist information, which is the 'artist' table.", "We need to filter artists based on their country, which is 'Bangladesh'.", "Next, we need to ensure that these artists have never received a rating higher than 7.", "To do this, we can use a subquery that selects artist names from the 'song' table where the rating is greater than 7.", "We will use the NOT IN clause to exclude any artist names that appear in the subquery from our main query.", "Finally, we will select the artist names from the 'artist' table that meet these criteria."], "pred_sql": "SELECT artist_name FROM artist WHERE country = 'Bangladesh' AND artist_name NOT IN (SELECT artist_name FROM song WHERE rating > '7');", "gold_sql": "SELECT DISTINCT artist_name FROM artist WHERE country  =  'Bangladesh' EXCEPT SELECT DISTINCT artist_name FROM song WHERE rating  >  7", "source_tables": ["artist", "song"]}
{"sample_id": 3629, "db_id": "baseball_1", "question": "what is the full name and id of the college with the largest number of baseball players?", "rationale": ["Identify the relevant tables: college and player_college.", "We need to count the number of players associated with each college, so we will join the college table with the player_college table on college_id.", "Group the results by college_id to aggregate the count of players for each college.", "Order the results in descending order based on the count of players to find the college with the largest number of players.", "Limit the results to 1 to get only the college with the highest count."], "pred_sql": "SELECT c.name_full, c.college_id\nFROM college c\nJOIN player_college pc ON c.college_id = pc.college_id\nGROUP BY c.college_id\nORDER BY COUNT(pc.player_id) DESC\nLIMIT 1;", "gold_sql": "SELECT T1.name_full ,  T1.college_id FROM college AS T1 JOIN player_college AS T2 ON T1.college_id  =  T2.college_id GROUP BY T1.college_id ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["player_college", "college"]}
{"sample_id": 3630, "db_id": "baseball_1", "question": "Find the full name and id of the college that has the most baseball players.", "rationale": ["Identify the relevant tables: 'college' for college information and 'player_college' for the relationship between players and colleges.", "Join the 'college' table with the 'player_college' table on 'college_id' to link players to their respective colleges.", "Group the results by 'college_id' and 'name_full' to aggregate the number of players per college.", "Count the number of players for each college using COUNT(pc.player_id).", "Order the results in descending order to get the college with the most players at the top.", "Limit the results to 1 to get only the college with the most baseball players."], "pred_sql": "SELECT c.name_full, c.college_id\nFROM college c\nJOIN player_college pc ON c.college_id = pc.college_id\nGROUP BY c.college_id, c.name_full\nORDER BY COUNT(pc.player_id) DESC\nLIMIT 1;", "gold_sql": "SELECT T1.name_full ,  T1.college_id FROM college AS T1 JOIN player_college AS T2 ON T1.college_id  =  T2.college_id GROUP BY T1.college_id ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["player_college", "college"]}
{"sample_id": 3631, "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the relevant tables: 'salary' for salary information and 'team' for team names.", "Determine the relationship between the tables: 'salary' has a foreign key 'team_id' that links to 'team'.", "Filter the results to only include the team named 'Boston Red Stockings'.", "Calculate the average salary using the AVG() function on the salary column."], "pred_sql": "SELECT AVG(salary.salary) AS average_salary\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nWHERE team.name = 'Boston Red Stockings';", "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"]}
{"sample_id": 3632, "db_id": "baseball_1", "question": "Compute the average salary of the players in the team called 'Boston Red Stockings'.", "rationale": ["Identify the relevant tables: 'salary' for salary information and 'team' for team names.", "Determine the relationship between the tables: 'salary' has a foreign key 'team_id' that links to 'team'.", "Filter the results to only include players from the team named 'Boston Red Stockings'.", "Use the AVG() function to compute the average salary from the 'salary' table for the filtered team."], "pred_sql": "SELECT AVG(salary.salary) AS average_salary\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nWHERE team.name = 'Boston Red Stockings';", "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"]}
{"sample_id": 3633, "db_id": "baseball_1", "question": "What are first and last names of players participating in all star game in 1998?", "rationale": ["Identify the relevant tables: 'all_star' for game participation and 'player' for player names.", "Determine the columns needed: 'name_first' and 'name_last' from the 'player' table.", "Establish the relationship between the tables: 'all_star.player_id' links to 'player.player_id'.", "Filter the results for the year 1998 using a WHERE clause on the 'year' column in the 'all_star' table."], "pred_sql": "SELECT p.name_first, p.name_last \nFROM all_star AS a \nJOIN player AS p ON a.player_id = p.player_id \nWHERE a.year = '1998';", "gold_sql": "SELECT name_first ,  name_last FROM player AS T1 JOIN all_star AS T2 ON T1.player_id  =  T2.player_id WHERE YEAR  =  1998", "source_tables": ["player", "all_star"]}
{"sample_id": 3634, "db_id": "baseball_1", "question": "List the first and last name for players who participated in all star game in 1998.", "rationale": ["Identify the relevant tables: 'all_star' for All-Star game participation and 'player' for player names.", "Determine the columns needed: 'name_first' and 'name_last' from the 'player' table.", "Filter the results to only include players who participated in the All-Star game in the year 1998.", "Join the 'all_star' table with the 'player' table on 'player_id' to get the names of the players who participated in the All-Star game in 1998."], "pred_sql": "SELECT p.name_first, p.name_last \nFROM all_star AS a \nJOIN player AS p ON a.player_id = p.player_id \nWHERE a.year = '1998';", "gold_sql": "SELECT name_first ,  name_last FROM player AS T1 JOIN all_star AS T2 ON T1.player_id  =  T2.player_id WHERE YEAR  =  1998", "source_tables": ["player", "all_star"]}
{"sample_id": 3635, "db_id": "baseball_1", "question": "What are the first name, last name and id of the player with the most all star game experiences? Also list the count.", "rationale": ["Identify the relevant tables: 'all_star' for All-Star game experiences and 'player' for player details.", "We need to select the first name, last name, and player ID from the 'player' table.", "We also need to count the number of All-Star game experiences for each player, which is done by counting the 'year' in the 'all_star' table.", "Join the 'all_star' table with the 'player' table on 'player_id' to get the player's details along with their All-Star experiences.", "Group the results by 'player_id' to aggregate the count of All-Star experiences for each player.", "Order the results by the count of All-Star experiences in descending order to get the player with the most experiences at the top.", "Limit the results to 1 to get only the player with the most All-Star game experiences."], "pred_sql": "SELECT p.name_first, p.name_last, p.player_id, COUNT(a.year) AS all_star_count\nFROM all_star AS a\nJOIN player AS p ON a.player_id = p.player_id\nGROUP BY p.player_id\nORDER BY all_star_count DESC\nLIMIT 1;", "gold_sql": "SELECT T1.name_first , T1.name_last ,  T1.player_id ,   count(*) FROM player AS T1 JOIN all_star AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["player", "all_star"]}
{"sample_id": 3636, "db_id": "baseball_1", "question": "Which player has the most all star game experiences? Give me the first name, last name and id of the player, as well as the number of times the player participated in all star game.", "rationale": ["Identify the relevant tables: 'all_star' for all-star game participation and 'player' for player details.", "Join the 'all_star' table with the 'player' table on 'player_id' to get player names and IDs.", "Count the number of all-star game participations for each player using COUNT(a.year).", "Group the results by player ID to aggregate the counts correctly.", "Order the results by the count of all-star participations in descending order to find the player with the most experiences.", "Limit the results to 1 to get only the top player."], "pred_sql": "SELECT p.name_first, p.name_last, p.player_id, COUNT(a.year) AS all_star_count\nFROM all_star a\nJOIN player p ON a.player_id = p.player_id\nGROUP BY p.player_id\nORDER BY all_star_count DESC\nLIMIT 1;", "gold_sql": "SELECT T1.name_first , T1.name_last ,  T1.player_id ,   count(*) FROM player AS T1 JOIN all_star AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["player", "all_star"]}
{"sample_id": 3637, "db_id": "baseball_1", "question": "How many players enter hall of fame each year?", "rationale": ["Identify the relevant table: The 'hall_of_fame' table contains information about players and their induction years.", "Determine the columns needed: We need the 'yearid' to group by year and 'player_id' to count the number of players inducted each year.", "Use the COUNT function to count the number of players for each year.", "Group the results by 'yearid' to get the count of players inducted per year."], "pred_sql": "SELECT yearid, COUNT(player_id) AS num_players FROM hall_of_fame GROUP BY yearid;", "gold_sql": "SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;", "source_tables": ["hall_of_fame"]}
{"sample_id": 3638, "db_id": "baseball_1", "question": "Count the number of players who enter hall of fame for each year.", "rationale": ["Identify the relevant table: The 'hall_of_fame' table contains information about players and their induction status.", "Determine the columns needed: We need the 'yearid' to group by year and 'player_id' to count the number of players.", "Filter the results: We only want players who were inducted, so we will filter where 'inducted' is 'Y'.", "Group the results by year: Use GROUP BY on 'yearid' to count the number of players inducted each year.", "Count the players: Use COUNT(player_id) to get the number of players inducted for each year.", "Order the results: Finally, order the results by year for better readability."], "pred_sql": "SELECT yearid AS year, COUNT(player_id) AS num_players\nFROM hall_of_fame\nWHERE inducted = 'Y'\nGROUP BY yearid\nORDER BY yearid;", "gold_sql": "SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;", "source_tables": ["hall_of_fame"]}
{"sample_id": 3639, "db_id": "baseball_1", "question": "What is the average number of attendance at home games for each year?", "rationale": ["Identify the relevant table: The 'home_game' table contains the attendance data for home games.", "Determine the required calculation: We need to calculate the average attendance, which can be done using the AVG() function.", "Group the results by year: To get the average attendance for each year, we will use the GROUP BY clause on the 'year' column.", "Construct the SQL query: Combine the SELECT statement with the AVG() function and the GROUP BY clause to form the complete SQL query."], "pred_sql": "SELECT year, AVG(attendance) AS average_attendance FROM home_game GROUP BY year;", "gold_sql": "SELECT YEAR ,  avg(attendance) FROM home_game GROUP BY YEAR;", "source_tables": ["home_game"]}
{"sample_id": 3640, "db_id": "baseball_1", "question": "For each year, return the year and the average number of attendance at home games.", "rationale": ["Identify the relevant table: The 'home_game' table contains the 'year' and 'attendance' columns needed for the query.", "Select the columns needed: We need to select 'year' and the average of 'attendance'.", "Use the AVG() function to calculate the average attendance for each year.", "Group the results by 'year' to get the average attendance for each individual year."], "pred_sql": "SELECT year, AVG(attendance) AS average_attendance\nFROM home_game\nGROUP BY year;", "gold_sql": "SELECT YEAR ,  avg(attendance) FROM home_game GROUP BY YEAR;", "source_tables": ["home_game"]}
{"sample_id": 3641, "db_id": "baseball_1", "question": "In 2014, what are the id and rank of the team that has the largest average number of attendance?", "rationale": ["Identify the relevant table: The 'home_game' table contains information about attendance for each team in a given year.", "Filter the data for the year 2014: We need to focus on the records from the year 2014.", "Sort the results by attendance: To find the team with the largest average attendance, we will sort the records in descending order based on the 'attendance' column.", "Select the team_id and rank: We need to retrieve the 'team_id' and 'rank' of the team with the highest attendance.", "Limit the results to one: Since we only want the team with the largest attendance, we will limit the results to one record."], "pred_sql": "SELECT team_id, rank FROM home_game WHERE year = 2014 ORDER BY attendance DESC LIMIT 1;", "gold_sql": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  2014 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "source_tables": ["team", "home_game"]}
{"sample_id": 3642, "db_id": "baseball_1", "question": "Find the id and rank of the team that has the highest average attendance rate in 2014.", "rationale": ["Identify the relevant table: The 'team' table contains the necessary columns for team_id, rank, and attendance.", "Filter the data for the year 2014: We need to specify the year in the WHERE clause to focus on the correct season.", "Order the results by attendance: To find the team with the highest average attendance, we will order the results in descending order based on the 'attendance' column.", "Limit the results to one: Since we only want the team with the highest attendance, we will use LIMIT 1 to get the top result."], "pred_sql": "SELECT team_id, rank FROM team WHERE year = 2014 ORDER BY attendance DESC LIMIT 1;", "gold_sql": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  2014 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "source_tables": ["team", "home_game"]}
{"sample_id": 3643, "db_id": "baseball_1", "question": "What are the manager's first name, last name and id who won the most manager award?", "rationale": ["Identify the relevant tables: 'manager_award' for awards and 'player' for player details.", "Join 'manager_award' with 'player' on 'player_id' to get player names along with their awards.", "Group the results by 'player_id' to count the number of awards each manager has won.", "Order the results by the count of awards in descending order to find the manager with the most awards.", "Limit the results to 1 to get only the top manager."], "pred_sql": "SELECT p.name_first, p.name_last, p.player_id \nFROM manager_award ma \nJOIN player p ON ma.player_id = p.player_id \nGROUP BY ma.player_id \nORDER BY COUNT(ma.award_id) DESC \nLIMIT 1;", "gold_sql": "SELECT T1.name_first ,  T1.name_last ,  T2.player_id FROM player AS T1 JOIN manager_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T2.player_id ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["player", "manager_award"]}
{"sample_id": 3644, "db_id": "baseball_1", "question": "Which manager won the most manager award? Give me the manager's first name, last name and id.", "rationale": ["Identify the relevant tables: We need the 'manager_award' table to find out which manager won the most awards and the 'player' table to get the manager's first name, last name, and ID.", "Join the 'manager_award' table with the 'player' table on 'player_id' to access the manager's details.", "Group the results by 'player_id' to count the number of awards each manager has won.", "Order the results in descending order based on the count of awards to find the manager with the most awards.", "Limit the results to 1 to get only the top manager."], "pred_sql": "SELECT p.name_first, p.name_last, p.player_id \nFROM manager_award ma \nJOIN player p ON ma.player_id = p.player_id \nGROUP BY ma.player_id \nORDER BY COUNT(ma.award_id) DESC \nLIMIT 1;", "gold_sql": "SELECT T1.name_first ,  T1.name_last ,  T2.player_id FROM player AS T1 JOIN manager_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T2.player_id ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["player", "manager_award"]}
{"sample_id": 3645, "db_id": "baseball_1", "question": "How many parks are there in the state of NY?", "rationale": ["Identify the relevant table: The 'park' table contains information about parks.", "Determine the specific information needed: We need to count the number of parks in a specific state, which is New York (NY).", "Formulate the SQL query: Use the COUNT() function to count the number of entries in the 'park' table where the state is 'NY'."], "pred_sql": "SELECT COUNT(*) AS park_count FROM park WHERE state = 'NY';", "gold_sql": "SELECT count(*) FROM park WHERE state  =  'NY';", "source_tables": ["park"]}
{"sample_id": 3646, "db_id": "baseball_1", "question": "Show me the number of parks the state of NY has.", "rationale": ["Identify the table that contains information about parks, which is the 'park' table.", "Determine the relevant column that indicates the state of the park, which is 'state'.", "Formulate a query to count the number of parks where the state is 'NY'.", "Use the COUNT() function to get the total number of parks in New York."], "pred_sql": "SELECT COUNT(*) AS number_of_parks FROM park WHERE state = 'NY';", "gold_sql": "SELECT count(*) FROM park WHERE state  =  'NY';", "source_tables": ["park"]}
{"sample_id": 3647, "db_id": "baseball_1", "question": "Which 3 players won the most player awards? List their full name and id.", "rationale": ["Identify the relevant tables: 'player' for player details and 'player_award' for awards won by players.", "Join the 'player' table with the 'player_award' table on 'player_id' to associate players with their awards.", "Group the results by 'player_id' to aggregate the number of awards each player has won.", "Count the number of awards for each player using COUNT(pa.award_id).", "Order the results in descending order based on the count of awards to get the players with the most awards at the top.", "Limit the results to the top 3 players to fulfill the request."], "pred_sql": "SELECT p.player_id, p.name_first, p.name_last, COUNT(pa.award_id) AS award_count\nFROM player p\nJOIN player_award pa ON p.player_id = pa.player_id\nGROUP BY p.player_id\nORDER BY award_count DESC\nLIMIT 3;", "gold_sql": "SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT 3;", "source_tables": ["player_award", "player"]}
{"sample_id": 3648, "db_id": "baseball_1", "question": "Find the first name, last name and id for the top three players won the most player awards.", "rationale": ["Identify the relevant tables: We need to get player information and their awards, so we will use the 'player' and 'player_award' tables.", "Select the required fields: We need the first name, last name, and player ID, which are in the 'player' table.", "Join the tables: We will join 'player_award' with 'player' on 'player_id' to get the names along with the awards.", "Group the results: We will group by 'player_id' to count the number of awards each player has won.", "Order the results: We will order the results by the count of awards in descending order to get the top players.", "Limit the results: We will limit the results to the top three players."], "pred_sql": "SELECT p.name_first, p.name_last, p.player_id\nFROM player_award pa\nJOIN player p ON pa.player_id = p.player_id\nGROUP BY p.player_id\nORDER BY COUNT(pa.award_id) DESC\nLIMIT 3;", "gold_sql": "SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT 3;", "source_tables": ["player_award", "player"]}
{"sample_id": 3649, "db_id": "baseball_1", "question": "List three countries which are the origins of the least players.", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their country of birth.", "Select the 'birth_country' column to get the countries of origin.", "Count the number of players for each country using COUNT(player_id).", "Group the results by 'birth_country' to aggregate the counts for each country.", "Order the results in ascending order based on the count of players to find the countries with the least players.", "Limit the results to 3 to get only the top three countries with the least players."], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count \nFROM player \nGROUP BY birth_country \nORDER BY player_count ASC \nLIMIT 3;", "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"]}
{"sample_id": 3650, "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their birth countries.", "Select the 'birth_country' column to group players by their country of origin.", "Count the number of players from each country using COUNT(player_id).", "Group the results by 'birth_country' to aggregate the player counts for each country.", "Order the results in ascending order based on the player count to find the countries with the least players.", "Limit the results to the top 3 countries with the least players."], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count \nFROM player \nGROUP BY birth_country \nORDER BY player_count ASC \nLIMIT 3;", "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"]}
{"sample_id": 3651, "db_id": "baseball_1", "question": "Find all the players' first name and last name who have empty death record.", "rationale": ["Identify the table that contains player names, which is the 'player' table.", "Determine the columns needed: 'name_first' for the first name and 'name_last' for the last name.", "To find players with empty death records, check for NULL values in the 'death_year', 'death_month', and 'death_day' columns.", "Construct the SQL SELECT statement to retrieve the first and last names of players where the death records are empty."], "pred_sql": "SELECT name_first, name_last FROM player WHERE death_year IS NULL AND death_month IS NULL AND death_day IS NULL;", "gold_sql": "SELECT name_first ,  name_last FROM player WHERE death_year = '';", "source_tables": ["player"]}
{"sample_id": 3652, "db_id": "baseball_1", "question": "What are the first name and last name of the players whose death record is empty?", "rationale": ["Identify the table that contains player names and death records, which is the 'player' table.", "Select the columns 'name_first' and 'name_last' to get the first and last names of the players.", "Filter the results to include only those players whose death records are empty, which means the 'death_year', 'death_month', and 'death_day' columns should all be NULL."], "pred_sql": "SELECT name_first, name_last FROM player WHERE death_year IS NULL AND death_month IS NULL AND death_day IS NULL;", "gold_sql": "SELECT name_first ,  name_last FROM player WHERE death_year = '';", "source_tables": ["player"]}
{"sample_id": 3653, "db_id": "baseball_1", "question": "How many players born in USA are right-handed batters? That is, have the batter value 'R'.", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their birth country and batting hand.", "Determine the conditions: We need to filter players who were born in the USA and are right-handed batters (batter value 'R').", "Construct the SQL query: Use a SELECT statement to count the number of players that meet the specified conditions."], "pred_sql": "SELECT COUNT(*) AS player_count \nFROM player \nWHERE birth_country = 'USA' AND bats = 'R';", "gold_sql": "SELECT count(*) FROM player WHERE birth_country = 'USA' AND bats  =  'R';", "source_tables": ["player"]}
{"sample_id": 3654, "db_id": "baseball_1", "question": "Count the number of players who were born in USA and have bats information 'R'.", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant columns needed for the query: 'birth_country' to filter players born in the USA and 'bats' to filter players with batting information 'R'.", "Construct the SQL query to count the number of players that meet both conditions: born in the USA and have 'R' as their batting hand.", "Use the COUNT function to get the total number of players that match the criteria."], "pred_sql": "SELECT COUNT(*) AS player_count FROM player WHERE birth_country = 'USA' AND bats = 'R';", "gold_sql": "SELECT count(*) FROM player WHERE birth_country = 'USA' AND bats  =  'R';", "source_tables": ["player"]}
{"sample_id": 3655, "db_id": "baseball_1", "question": "What is the average height of the players from the college named 'Yale University'?", "rationale": ["Identify the relevant tables: player, player_college, and college.", "To find the average height of players from 'Yale University', we need to join the player table with the player_college table to link players to their colleges.", "Next, we join the college table to filter for 'Yale University'.", "We will use the AVG() function to calculate the average height of the players who attended 'Yale University'.", "The final SQL query will select the average height from the player table, applying the necessary joins and conditions."], "pred_sql": "SELECT AVG(p.height) AS average_height\nFROM player p\nJOIN player_college pc ON p.player_id = pc.player_id\nJOIN college c ON pc.college_id = c.college_id\nWHERE c.name_full = 'Yale University';", "gold_sql": "SELECT avg(T1.height) FROM player AS T1 JOIN player_college AS T2 ON T1.player_id  =  T2.player_id JOIN college AS T3 ON T3.college_id  =  T2.college_id WHERE T3.name_full  =  'Yale University';", "source_tables": ["college", "player", "player_college"]}
{"sample_id": 3656, "db_id": "baseball_1", "question": "Find the average height of the players who belong to the college called 'Yale University'.", "rationale": ["Identify the relevant tables: player, player_college, and college.", "To find the average height of players from 'Yale University', we need to join the player table with the player_college table on player_id, and then join with the college table on college_id.", "Filter the results to include only those players who attended 'Yale University'.", "Use the AVG() function to calculate the average height of the filtered players."], "pred_sql": "SELECT AVG(p.height) AS average_height\nFROM player AS p\nJOIN player_college AS pc ON p.player_id = pc.player_id\nJOIN college AS c ON pc.college_id = c.college_id\nWHERE c.name_full = 'Yale University';", "gold_sql": "SELECT avg(T1.height) FROM player AS T1 JOIN player_college AS T2 ON T1.player_id  =  T2.player_id JOIN college AS T3 ON T3.college_id  =  T2.college_id WHERE T3.name_full  =  'Yale University';", "source_tables": ["college", "player", "player_college"]}
{"sample_id": 3657, "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["Identify the relevant tables: 'salary' for salary information and 'team' for team details.", "We need to find the maximum salary for each team, so we will use the MAX() function on the salary column.", "To get the team name and id, we will join the 'salary' table with the 'team' table on the team_id column.", "We will group the results by team_id and team name to ensure we get the maximum salary for each team."], "pred_sql": "SELECT t.name AS team_name, t.team_id, MAX(s.salary) AS max_salary\nFROM salary s\nJOIN team t ON s.team_id = t.team_id\nGROUP BY t.team_id, t.name;", "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"]}
{"sample_id": 3658, "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["Identify the relevant tables: 'team' for team information and 'salary' for salary details.", "We need to select the team name and team id from the 'team' table.", "We also need to find the maximum salary for each team from the 'salary' table.", "Join the 'team' table with the 'salary' table on the team_id to combine the information.", "Use the MAX() function to get the maximum salary for each team.", "Group the results by team_id and team name to ensure we get one result per team."], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM team\nJOIN salary ON team.team_id = salary.team_id\nGROUP BY team.team_id, team.name;", "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"]}
{"sample_id": 3659, "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["Identify the relevant tables: 'team' for team names and IDs, and 'salary' for salary information.", "Join the 'team' and 'salary' tables on the 'player_id' to associate players with their respective teams.", "Group the results by 'team.team_id' to calculate the average salary for each team.", "Use the AVG() function to compute the average salary for each team.", "Order the results in ascending order based on the average salary to find the lowest.", "Limit the results to 1 to get only the team with the lowest average salary."], "pred_sql": "SELECT team.name, team.team_id FROM team JOIN salary ON team.player_id = salary.player_id GROUP BY team.team_id ORDER BY AVG(salary.salary) ASC LIMIT 1;", "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"]}
{"sample_id": 3660, "db_id": "baseball_1", "question": "Which team offers the lowest average salary? Give me the name and id of the team.", "rationale": ["Identify the relevant tables: 'salary' for salary information and 'team' for team names and IDs.", "Join the 'salary' table with the 'team' table on 'team_id' to associate salaries with team names and IDs.", "Group the results by 'team.team_id' to calculate the average salary for each team.", "Order the results by the average salary in ascending order to find the team with the lowest average salary.", "Limit the results to 1 to get only the team with the lowest average salary."], "pred_sql": "SELECT team.name, team.team_id FROM salary JOIN team ON salary.team_id = team.team_id GROUP BY team.team_id ORDER BY AVG(salary.salary) ASC LIMIT 1;", "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"]}
{"sample_id": 3661, "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["Identify the relevant tables: We need the 'player' table for player names and the 'player_award' table for award information.", "Join the 'player' table with the 'player_award' table twice: one for the year 1960 and another for the year 1961. This allows us to find players who won awards in both years.", "Use the 'WHERE' clause to filter the results to only include players who won awards in both 1960 and 1961."], "pred_sql": "SELECT p.name_first, p.name_last\nFROM player p\nJOIN player_award pa1 ON p.player_id = pa1.player_id\nJOIN player_award pa2 ON p.player_id = pa2.player_id\nWHERE pa1.year = 1960 AND pa2.year = 1961;", "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"]}
{"sample_id": 3662, "db_id": "baseball_1", "question": "Which players won awards in both 1960 and 1961? Return their first names and last names.", "rationale": ["Identify the relevant tables: We need the 'player' table for player names and the 'player_award' table for award information.", "Join the 'player' table with the 'player_award' table on 'player_id' to get access to player names along with their award years.", "Filter the results to include only those players who have awards in the years 1960 and 1961. This can be done using a WHERE clause with the year condition.", "Group the results by player_id to aggregate the awards for each player.", "Use HAVING to ensure that only players who have awards in both years (count of distinct years = 2) are included in the final result."], "pred_sql": "SELECT p.name_first, p.name_last\nFROM player p\nJOIN player_award pa ON p.player_id = pa.player_id\nWHERE pa.year IN ('1960', '1961')\nGROUP BY p.player_id\nHAVING COUNT(DISTINCT pa.year) = 2;", "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"]}
{"sample_id": 3663, "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the columns needed for the output: 'name_given' for the first name and 'name_last' for the last name.", "Specify the conditions for filtering: weight greater than 220 or height shorter than 75.", "Construct the SQL SELECT statement to retrieve the specified columns from the 'player' table with the given conditions."], "pred_sql": "SELECT name_given, name_last FROM player WHERE weight > 220 OR height < 75;", "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"]}
{"sample_id": 3664, "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["Identify the relevant table: The 'player' table contains the columns for player names, weight, and height.", "Select the columns needed: We need 'name_given' for the first name and 'name_last' for the last name of the players.", "Apply the conditions: We want players with a weight greater than 220 or a height less than 75.", "Construct the SQL query using SELECT to retrieve the specified columns from the 'player' table with the appropriate WHERE clause."], "pred_sql": "SELECT name_given, name_last FROM player WHERE weight > 220 OR height < 75;", "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"]}
{"sample_id": 3665, "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant table for postseason results, which is 'postseason'.", "Determine the condition for winning teams, which is indicated by 'team_id_winner'.", "Find the team_id for 'Boston Red Stockings' from the 'team' table using a subquery.", "Use the MAX function to get the maximum scores (wins) for the winning team in the postseason."], "pred_sql": "SELECT MAX(wins) AS max_scores\nFROM postseason\nWHERE team_id_winner = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')", "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"]}
{"sample_id": 3666, "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: 'batting_postseason' for postseason batting statistics and 'team' for team information.", "We need to find the maximum runs scored by the Boston Red Stockings in postseason games where they won.", "Join the 'batting_postseason' table with the 'team' table on 'team_id' to filter for the Boston Red Stockings.", "Use a subquery to find the years in which the Boston Red Stockings won in the postseason by checking the 'postseason' table for 'team_id_winner'.", "Select the maximum runs scored (column 'r') from the 'batting_postseason' table for the filtered results."], "pred_sql": "SELECT MAX(batting.r) AS max_runs\nFROM batting_postseason\nJOIN team ON batting_postseason.team_id = team.team_id\nWHERE team.name = 'Boston Red Stockings' AND batting_postseason.year IN (SELECT year FROM postseason WHERE team_id_winner = team.team_id);", "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"]}
{"sample_id": 3667, "db_id": "baseball_1", "question": "How many times did Boston Red Stockings lose in 2009 postseason?", "rationale": ["Identify the relevant table: postseason, which contains information about postseason results.", "We need to count the number of losses for the Boston Red Stockings in the year 2009.", "To do this, we will filter the postseason table for the year 2009 and for the team_id_loser that corresponds to the Boston Red Stockings.", "To find the team_id for the Boston Red Stockings, we will use a subquery on the team table where the name is 'Boston Red Stockings'.", "Finally, we will count the number of rows that match these criteria to get the total losses."], "pred_sql": "SELECT COUNT(*) AS losses FROM postseason WHERE year = 2009 AND team_id_loser = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')", "gold_sql": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year = 2009;", "source_tables": ["postseason", "team"]}
{"sample_id": 3668, "db_id": "baseball_1", "question": "Count the number of times the team \"Boston Red Stockings\" lost in 2009 postseason.", "rationale": ["Identify the relevant table for postseason results, which is 'postseason'.", "We need to count the number of losses for the team 'Boston Red Stockings' in the year 2009.", "To do this, we will filter the 'postseason' table for records where the year is 2009 and the 'team_id_loser' matches the 'team_id' of 'Boston Red Stockings'.", "We will use a subquery to find the 'team_id' of 'Boston Red Stockings' from the 'team' table.", "Finally, we will count the number of records that match these criteria to get the total losses."], "pred_sql": "SELECT COUNT(*) AS losses_count \nFROM postseason \nWHERE year = 2009 AND team_id_loser = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')", "gold_sql": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year = 2009;", "source_tables": ["postseason", "team"]}
{"sample_id": 3669, "db_id": "baseball_1", "question": "What are the name and id of the team with the most victories in 2008 postseason?", "rationale": ["Identify the relevant tables: 'team' for team details and 'postseason' for postseason results.", "We need to find the team with the most victories in the 2008 postseason, so we will focus on the 'postseason' table's 'team_id_winner' and 'wins' columns.", "Join the 'team' table with the 'postseason' table on the winning team ID to get the team names along with their IDs.", "Filter the results to only include records from the year 2008.", "Order the results by the number of wins in descending order to get the team with the most victories at the top.", "Limit the results to 1 to get only the top team."], "pred_sql": "SELECT team.name, team.team_id FROM team JOIN postseason ON team.team_id = postseason.team_id_winner WHERE postseason.year = 2008 ORDER BY postseason.wins DESC LIMIT 1;", "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"]}
{"sample_id": 3670, "db_id": "baseball_1", "question": "Find the name and id of the team that won the most times in 2008 postseason.", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the team that won the most in the 2008 postseason, so we will focus on the postseason table for the year 2008.", "Join the postseason table with the team table to get the team names and IDs of the winning teams.", "Filter the results to only include the year 2008.", "Order the results by the number of wins in descending order to get the team with the most wins at the top.", "Limit the results to 1 to get only the team with the most wins."], "pred_sql": "SELECT team.name, team.team_id \nFROM postseason \nJOIN team ON postseason.team_id_winner = team.team_id \nWHERE postseason.year = 2008 \nORDER BY postseason.wins DESC \nLIMIT 1;", "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"]}
{"sample_id": 3671, "db_id": "baseball_1", "question": "What is the number of wins the team Boston Red Stockings got in the postseasons each year in history?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the total wins for the team 'Boston Red Stockings' in the postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Group the results by year to get the total wins for each year."], "pred_sql": "SELECT p.year, SUM(p.w) AS total_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings'\nGROUP BY p.year;", "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"]}
{"sample_id": 3672, "db_id": "baseball_1", "question": "For each year, return the year and the number of times the team Boston Red Stockings won in the postseasons.", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team names.", "We need to count the number of wins for the team 'Boston Red Stockings' in each year.", "Join the 'postseason' table with the 'team' table on the winning team ID to filter for the specific team.", "Use a WHERE clause to specify that we are only interested in the 'Boston Red Stockings'.", "Group the results by year to get the count of wins for each year."], "pred_sql": "SELECT p.year, COUNT(p.team_id_winner) AS wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings'\nGROUP BY p.year;", "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"]}
{"sample_id": 3673, "db_id": "baseball_1", "question": "What is the total number of postseason games that team Boston Red Stockings participated in?", "rationale": ["Identify the relevant table for postseason games, which is 'batting_postseason'.", "Determine the column that represents the number of games played in postseason, which is 'g'.", "To find the total number of postseason games for the team 'Boston Red Stockings', we need to filter the records by the team's identifier.", "The team identifier can be found by querying the 'team' table for the team name 'Boston Red Stockings'.", "Use a subquery to get the 'team_id' for 'Boston Red Stockings' and sum the 'g' column from 'batting_postseason' where the 'team_id' matches."], "pred_sql": "SELECT SUM(g) AS total_postseason_games\nFROM batting_postseason\nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')", "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"]}
{"sample_id": 3674, "db_id": "baseball_1", "question": "How many times in total did the team Boston Red Stockings participate in postseason games?", "rationale": ["Identify the relevant tables: 'postseason' for postseason games and 'team' for team information.", "We need to count the total number of postseason games the Boston Red Stockings participated in, which includes both wins and losses.", "Join the 'postseason' table with the 'team' table to filter for the Boston Red Stockings.", "Use a WHERE clause to check if the team name is 'Boston Red Stockings' for both winning and losing teams in the postseason.", "Count the total number of games using COUNT(*) and alias it as 'total_postseason_games'."], "pred_sql": "SELECT COUNT(*) AS total_postseason_games \nFROM postseason \nJOIN team ON postseason.team_id_winner = team.team_id \nWHERE team.name = 'Boston Red Stockings' OR postseason.team_id_loser = team.team_id;", "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"]}
{"sample_id": 3675, "db_id": "baseball_1", "question": "How many games in 1885 postseason resulted in ties (that is, the value of \"ties\" is '1')?", "rationale": ["Identify the relevant table: postseason.", "Determine the columns needed: ties.", "Specify the year of interest: 1885.", "Add a condition to filter for ties, where ties = 1."], "pred_sql": "SELECT ties FROM postseason WHERE year = 1885 AND ties = 1;", "gold_sql": "SELECT count(*) FROM postseason WHERE YEAR  =  1885 AND ties  =  1;", "source_tables": ["postseason"]}
{"sample_id": 3676, "db_id": "baseball_1", "question": "Find the number of tied games (the value of \"ties\" is '1') in 1885 postseason.", "rationale": ["Identify the table that contains the relevant data: the 'postseason' table.", "Determine the columns needed: 'year' to filter for 1885 and 'ties' to check for tied games.", "Construct the SQL query to count the number of rows where 'year' is 1885 and 'ties' equals 1."], "pred_sql": "SELECT COUNT(*) AS tied_games_count FROM postseason WHERE year = 1885 AND ties = 1;", "gold_sql": "SELECT count(*) FROM postseason WHERE YEAR  =  1885 AND ties  =  1;", "source_tables": ["postseason"]}
{"sample_id": 3677, "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant table for salary information, which is the 'salary' table.", "Determine the specific team by querying the 'team' table to find the 'team_id' for 'Boston Red Stockings' in the year 2010.", "Use the 'SUM' function to calculate the total salary from the 'salary' table where the 'team_id' matches the one found in the previous step and the year is 2010."], "pred_sql": "SELECT SUM(salary) AS total_salary \nFROM salary \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings' AND year = 2010) \nAND year = 2010;", "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"]}
{"sample_id": 3678, "db_id": "baseball_1", "question": "What is the total salary expenses of team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant table for salary information, which is the 'salary' table.", "Determine the team ID for the 'Boston Red Stockings' in the year 2010 by querying the 'team' table.", "Use the team ID obtained to filter the salary records for that specific team in the year 2010.", "Sum the salary amounts for the filtered records to get the total salary expenses."], "pred_sql": "SELECT SUM(salary) AS total_salary_expenses \nFROM salary \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings' AND year = 2010) \nAND year = 2010;", "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"]}
{"sample_id": 3679, "db_id": "baseball_1", "question": "How many players were in the team Boston Red Stockings in 2000?", "rationale": ["Identify the team ID for the 'Boston Red Stockings' in the year 2000 by querying the 'team' table.", "Count the distinct player IDs from the 'appearances' table where the team ID matches the one found in the previous step and the year is 2000."], "pred_sql": "SELECT COUNT(DISTINCT player_id) AS player_count \nFROM appearances \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings' AND year = 2000) \nAND year = 2000;", "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"]}
{"sample_id": 3680, "db_id": "baseball_1", "question": "How many players did Boston Red Stockings have in 2000?", "rationale": ["Identify the team ID for the 'Boston Red Stockings' in the year 2000 by querying the 'team' table.", "Count the distinct player IDs from the 'appearances' table where the team ID matches the one found in the previous step and the year is 2000."], "pred_sql": "SELECT COUNT(DISTINCT player_id) AS player_count \nFROM appearances \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings' AND year = 2000) \nAND year = 2000;", "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"]}
{"sample_id": 3681, "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table: The 'salary' table contains the salary information for players.", "Specify the year of interest: We need to filter the records for the year 2001.", "Select the required columns: We want to retrieve the 'player_id' and 'salary' columns.", "Order the results: To find the highest salaries, we will order the results by the 'salary' column in descending order.", "Limit the results: We only need the top 3 highest salaries, so we will limit the results to 3."], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"]}
{"sample_id": 3682, "db_id": "baseball_1", "question": "How much salary did the top 3 well-paid players get in 2001?", "rationale": ["Identify the relevant table: The salary table contains the salary information for players.", "Determine the year of interest: The user is asking for salaries in the year 2001.", "Select the necessary columns: We need the player_id and salary columns to identify the players and their salaries.", "Filter the results for the year 2001: Use a WHERE clause to restrict the results to that year.", "Order the results by salary in descending order: This will allow us to find the highest salaries.", "Limit the results to the top 3 players: Use the LIMIT clause to restrict the output to the top 3 well-paid players."], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"]}
{"sample_id": 3683, "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["Identify the relevant table: The salary table contains the salary information for players.", "Determine the columns needed: We need the player_id and salary columns.", "Specify the years of interest: The years specified in the query are 2010 and 2001.", "Construct the SQL query: Use a SELECT statement to retrieve player_id and salary from the salary table where the year is either 2010 or 2001."], "pred_sql": "SELECT player_id, salary FROM salary WHERE year IN (2010, 2001);", "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"]}
{"sample_id": 3684, "db_id": "baseball_1", "question": "List all the salary values players received in 2010 and 2001.", "rationale": ["Identify the relevant table: The salary table contains the salary information for players.", "Determine the columns needed: We need the player_id and salary columns.", "Specify the years of interest: The years specified are 2010 and 2001.", "Construct the SQL query: Use a SELECT statement to retrieve player_id and salary from the salary table where the year is either 2010 or 2001."], "pred_sql": "SELECT player_id, salary FROM salary WHERE year IN (2010, 2001);", "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"]}
{"sample_id": 3685, "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["Identify the relevant table: The 'hall_of_fame' table contains information about Hall of Fame inductees.", "Focus on the 'yearid' column to determine the year of induction and 'player_id' to count the number of inductees.", "Filter the results to include only those who were actually inducted, indicated by 'inducted = 'Y' '.", "Group the results by 'yearid' to count the number of inductees per year.", "Order the results in ascending order based on the count of inductees to find the year with the least inductees.", "Limit the results to 1 to get only the year with the least number of inductees."], "pred_sql": "SELECT yearid, COUNT(player_id) AS num_inductees \nFROM hall_of_fame \nWHERE inducted = 'Y' \nGROUP BY yearid \nORDER BY num_inductees ASC \nLIMIT 1;", "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"]}
{"sample_id": 3686, "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["Identify the relevant table: The 'hall_of_fame' table contains information about Hall of Fame inductees.", "Focus on the 'yearid' column to determine the year of induction and the 'inducted' column to filter for actual inductees.", "Count the number of inductees for each year using COUNT(*) and group the results by 'yearid'.", "Order the results in ascending order based on the count of inductees to find the year with the least inductees.", "Limit the results to 1 to get only the year with the least number of inductees."], "pred_sql": "SELECT yearid, COUNT(*) AS num_inductees FROM hall_of_fame WHERE inducted = 'Y' GROUP BY yearid ORDER BY num_inductees ASC LIMIT 1;", "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"]}
{"sample_id": 3687, "db_id": "baseball_1", "question": "How many parks are there in Atlanta city?", "rationale": ["Identify the table that contains information about parks, which is the 'park' table.", "Determine the relevant column for the city, which is 'city'.", "Use the COUNT() function to count the number of parks in Atlanta.", "Construct the SQL query to select the count of parks where the city is 'Atlanta'."], "pred_sql": "SELECT COUNT(*) AS total_parks FROM park WHERE city = 'Atlanta';", "gold_sql": "SELECT count(*) FROM park WHERE city = 'Atlanta';", "source_tables": ["park"]}
{"sample_id": 3688, "db_id": "baseball_1", "question": "How many parks does Atlanta city have?", "rationale": ["Identify the relevant table: The 'park' table contains information about parks, including their location.", "Determine the specific city of interest: The user is asking about parks in 'Atlanta'.", "Count the distinct parks in Atlanta: Use the COUNT function to count unique park_id entries where the city is 'Atlanta'."], "pred_sql": "SELECT COUNT(DISTINCT park_id) AS number_of_parks FROM park WHERE city = 'Atlanta';", "gold_sql": "SELECT count(*) FROM park WHERE city = 'Atlanta';", "source_tables": ["park"]}
{"sample_id": 3689, "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: 'home_game' for games played and 'park' for park details.", "We need to find the number of games played in a specific park ('Columbia Park') in a specific year (1907).", "Join the 'home_game' table with the 'park' table on the 'park_id' to access park names.", "Filter the results to only include records where the park name is 'Columbia Park' and the year is 1907.", "Select the 'games' column from the 'home_game' table to get the total number of games played."], "pred_sql": "SELECT hg.games FROM home_game hg JOIN park p ON hg.park_id = p.park_id WHERE p.park_name = 'Columbia Park' AND hg.year = 1907;", "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"]}
{"sample_id": 3690, "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant table: home_game, which contains information about home games including the year and the park where they were played.", "We need to count the total number of games played in a specific park (Columbia Park) in a specific year (1907).", "To do this, we will filter the home_game table by the year 1907.", "We also need to find the park_id for 'Columbia Park' from the park table, as the home_game table references parks by their IDs.", "The final query will sum the games from the home_game table for the specified year and park_id."], "pred_sql": "SELECT SUM(games) AS total_games FROM home_game WHERE year = 1907 AND park_id = (SELECT park_id FROM park WHERE park_name = 'Columbia Park');", "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"]}
{"sample_id": 3691, "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant table for home games, which is 'home_game'.", "We need to sum the total number of games played in the year 2000, so we will use the SUM function on the 'games' column.", "To filter the games played in Atlanta, we need to find the park_id associated with Atlanta from the 'park' table.", "We will then find the team_id from the 'team' table that corresponds to the park_id we found for Atlanta.", "Finally, we will filter the 'home_game' records by the year 2000 and the team_id that corresponds to the Atlanta park."], "pred_sql": "SELECT SUM(games) AS total_games FROM home_game WHERE year = 2000 AND team_id IN (SELECT team_id FROM team WHERE park IN (SELECT park_id FROM park WHERE city = 'Atlanta'));", "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"]}
{"sample_id": 3692, "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant table: home_game, which contains the number of games played.", "We need to filter the records for the year 2000.", "Next, we need to find the teams that played in Atlanta. This requires a subquery to the park table to get the park_id for Atlanta.", "Then, we need to filter the home_game records to only include those teams that played in Atlanta.", "Finally, we sum the number of games for the filtered records to get the total number of games played in Atlanta in 2000."], "pred_sql": "SELECT SUM(games) AS total_games FROM home_game WHERE year = 2000 AND team_id IN (SELECT team_id FROM team WHERE park IN (SELECT park_id FROM park WHERE city = 'Atlanta'));", "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"]}
{"sample_id": 3693, "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'team' for team identification.", "We need to sum the 'attendance' column from the 'home_game' table.", "Join the 'home_game' table with the 'team' table on 'team_id' to filter by team name.", "Filter the results to include only the 'Boston Red Stockings' team.", "Add a condition to restrict the years to between 2000 and 2010."], "pred_sql": "SELECT SUM(attendance) AS total_attendance \nFROM home_game \nJOIN team ON home_game.team_id = team.team_id \nWHERE team.name = 'Boston Red Stockings' \nAND home_game.year BETWEEN 2000 AND 2010;", "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"]}
{"sample_id": 3694, "db_id": "baseball_1", "question": "How many games in total did team Boston Red Stockings attend from 2000 to 2010?", "rationale": ["Identify the relevant table for home games, which is 'home_game'.", "We need to sum the total number of games attended by the team, so we will use the SUM function on the 'games' column.", "To filter the records for the specific team, we need to find the 'team_id' for 'Boston Red Stockings' from the 'team' table.", "We will filter the years from 2000 to 2010 using the 'year' column in the 'home_game' table.", "Combine these conditions to form the SQL query that sums the games for the specified team and year range."], "pred_sql": "SELECT SUM(games) AS total_games FROM home_game WHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings') AND year BETWEEN 2000 AND 2010;", "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"]}
{"sample_id": 3695, "db_id": "baseball_1", "question": "How much did the the player with first name Len and last name Barker earn between 1985 to 1990 in total?", "rationale": ["Identify the relevant tables: We need the 'salary' table to get the salary information and the 'player' table to filter by player name.", "Join the 'salary' table with the 'player' table on 'player_id' to access player names along with their salaries.", "Filter the results to only include the player with the first name 'Len' and last name 'Barker'.", "Limit the salary records to the years between 1985 and 1990 using a WHERE clause.", "Use the SUM function to calculate the total salary earned by the player in the specified years."], "pred_sql": "SELECT SUM(salary) AS total_salary\nFROM salary\nJOIN player ON salary.player_id = player.player_id\nWHERE player.name_first = 'Len' AND player.name_last = 'Barker' AND salary.year BETWEEN 1985 AND 1990;", "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id WHERE T2.name_first  =  'Len' AND T2.name_last = 'Barker' AND T1.year BETWEEN 1985 AND 1990;", "source_tables": ["player", "salary"]}
{"sample_id": 3696, "db_id": "baseball_1", "question": "Compute the total salary that the player with first name Len and last name Barker received between 1985 to 1990.", "rationale": ["Identify the relevant tables: 'salary' for salary records and 'player' for player information.", "We need to sum the salaries, so we will use the SUM() function on the 'salary' column from the 'salary' table.", "To find the specific player, we will join the 'salary' table with the 'player' table on 'player_id'.", "Filter the results to include only the player with first name 'Len' and last name 'Barker'.", "Additionally, we need to restrict the years to between 1985 and 1990, using the WHERE clause with a BETWEEN condition."], "pred_sql": "SELECT SUM(salary.salary) AS total_salary\nFROM salary\nJOIN player ON salary.player_id = player.player_id\nWHERE player.name_first = 'Len' AND player.name_last = 'Barker' AND salary.year BETWEEN 1985 AND 1990;", "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id WHERE T2.name_first  =  'Len' AND T2.name_last = 'Barker' AND T1.year BETWEEN 1985 AND 1990;", "source_tables": ["player", "salary"]}
{"sample_id": 3697, "db_id": "baseball_1", "question": "List players' first name and last name who received salary from team Washington Nationals in both 2005 and 2007.", "rationale": ["Identify the relevant tables: player and salary.", "We need to select the first name and last name of players, which are in the player table.", "We need to filter salaries from the salary table for the team 'Washington Nationals' in the years 2005 and 2007.", "To find the team_id for 'Washington Nationals', we can use a subquery on the team table.", "We will use a JOIN between player and salary tables on player_id to get the necessary information.", "We need to ensure that the players received salaries in both years, so we will use a GROUP BY clause on player_id and a HAVING clause to count distinct years, ensuring it equals 2."], "pred_sql": "SELECT p.name_first, p.name_last \nFROM player p \nJOIN salary s ON p.player_id = s.player_id \nWHERE s.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals') \nAND s.year IN (2005, 2007) \nGROUP BY p.player_id \nHAVING COUNT(DISTINCT s.year) = 2;", "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"]}
{"sample_id": 3698, "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["Identify the team ID for the Washington Nationals from the team table.", "Select the first name and last name of players from the player table.", "Join the salary table with the player table on player_id to get player details along with their salary records.", "Filter the records to include only those from the salary table where the team ID matches that of the Washington Nationals and the year is either 2005 or 2007.", "Group the results by player ID to aggregate the salary records for each player.", "Use the HAVING clause to ensure that only players who have salary records for both years (2005 and 2007) are included in the final result."], "pred_sql": "SELECT p.name_first, p.name_last \nFROM salary s \nJOIN player p ON s.player_id = p.player_id \nWHERE s.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals') \nAND s.year IN (2005, 2007) \nGROUP BY p.player_id \nHAVING COUNT(DISTINCT s.year) = 2;", "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"]}
{"sample_id": 3699, "db_id": "baseball_1", "question": "How many home games did the team Boston Red Stockings play from 1990 to 2000 in total?", "rationale": ["Identify the relevant table: 'home_game' contains the data about home games played by teams.", "Determine the columns needed: We need to sum the 'games' column to get the total number of home games.", "Filter the results: We need to filter by 'team_id' for the 'Boston Red Stockings' and the 'year' range from 1990 to 2000.", "Use a subquery to find the 'team_id' for 'Boston Red Stockings' from the 'team' table.", "Construct the SQL query to sum the 'games' for the specified team and year range."], "pred_sql": "SELECT SUM(games) AS total_home_games FROM home_game WHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings') AND year BETWEEN 1990 AND 2000;", "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"]}
{"sample_id": 3700, "db_id": "baseball_1", "question": "Count the total number of games the team Boston Red Stockings attended from 1990 to 2000.", "rationale": ["Identify the relevant table: 'home_game' contains the information about home games attended by teams.", "We need to sum the total number of games, so we will use the SUM() function on the 'games' column.", "To filter for the team 'Boston Red Stockings', we need to find its 'team_id' from the 'team' table.", "We will use a subquery to select the 'team_id' for 'Boston Red Stockings'.", "We also need to filter the results for the years between 1990 and 2000, using the 'year' column in the 'home_game' table."], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')\nAND year BETWEEN 1990 AND 2000;", "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"]}
{"sample_id": 3701, "db_id": "baseball_1", "question": "Which team had the least number of attendances in home games in 1980?", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games, including attendance.", "Determine the specific year of interest: The query specifies the year 1980.", "Select the necessary columns: We need the 'team_id' and 'attendance' columns to identify the team and its attendance.", "Filter the results for the year 1980: Use a WHERE clause to restrict the results to that year.", "Order the results by attendance in ascending order: This will allow us to find the team with the least attendance.", "Limit the results to 1: Since we only want the team with the least attendance, we use LIMIT 1."], "pred_sql": "SELECT team_id, attendance FROM home_game WHERE year = 1980 ORDER BY attendance ASC LIMIT 1;", "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"]}
{"sample_id": 3702, "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games played by teams.", "Determine the specific year of interest: The query specifies the year 1980.", "Select the team_id and the minimum number of games played: We need to find the team that had the least number of home games in that year.", "Group the results by team_id: This allows us to aggregate the number of games played for each team.", "Order the results by the number of games in ascending order: This will help us find the team with the least number of home games easily.", "Limit the results to 1: Since we only want the team with the least number of home games, we limit the output to one result."], "pred_sql": "SELECT team_id, MIN(games) AS least_home_games FROM home_game WHERE year = 1980 GROUP BY team_id ORDER BY least_home_games ASC LIMIT 1;", "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"]}
{"sample_id": 3703, "db_id": "baseball_1", "question": "List the names of states that have more than 2 parks.", "rationale": ["Identify the relevant table: The 'park' table contains information about parks, including their state.", "Select the 'state' column: We want to list the names of states, so we will select the 'state' column from the 'park' table.", "Group by state: To count the number of parks in each state, we will group the results by the 'state' column.", "Count parks in each state: We will use the COUNT function to count the number of parks (using 'park_id') for each state.", "Filter states with more than 2 parks: We will use the HAVING clause to filter the grouped results to only include states that have more than 2 parks."], "pred_sql": "SELECT DISTINCT state FROM park GROUP BY state HAVING COUNT(park_id) > 2;", "gold_sql": "SELECT state FROM park GROUP BY state HAVING count(*)  >  2;", "source_tables": ["park"]}
{"sample_id": 3704, "db_id": "baseball_1", "question": "Which states have more than 2 parks?", "rationale": ["Identify the relevant table: The 'park' table contains information about parks, including their state.", "Determine the required information: We need to find states that have more than 2 parks.", "Group the results by state: Use GROUP BY to aggregate parks by their state.", "Count the number of parks in each state: Use COUNT(park_id) to count the number of parks for each state.", "Filter the results: Use HAVING to filter states where the count of parks is greater than 2."], "pred_sql": "SELECT state FROM park GROUP BY state HAVING COUNT(park_id) > 2;", "gold_sql": "SELECT state FROM park GROUP BY state HAVING count(*)  >  2;", "source_tables": ["park"]}
{"sample_id": 3705, "db_id": "baseball_1", "question": "How many team franchises are active, with active value 'Y'?", "rationale": ["Identify the table that contains information about team franchises, which is 'team_franchise'.", "Determine the relevant column that indicates whether a franchise is active, which is 'active'.", "Formulate a SQL query to count the number of rows in 'team_franchise' where 'active' is equal to 'Y'."], "pred_sql": "SELECT COUNT(*) AS active_franchise_count FROM team_franchise WHERE active = 'Y';", "gold_sql": "SELECT count(*) FROM team_franchise WHERE active = 'Y';", "source_tables": ["team_franchise"]}
{"sample_id": 3706, "db_id": "baseball_1", "question": "Find the number of team franchises that are active (have 'Y' as \"active\" information).", "rationale": ["Identify the table that contains information about team franchises, which is 'team_franchise'.", "Determine the relevant column that indicates if a franchise is active, which is 'active'.", "Formulate a SQL query to count the number of rows in 'team_franchise' where 'active' is equal to 'Y'.", "Use the COUNT() function to get the total number of active franchises."], "pred_sql": "SELECT COUNT(*) AS active_franchise_count FROM team_franchise WHERE active = 'Y';", "gold_sql": "SELECT count(*) FROM team_franchise WHERE active = 'Y';", "source_tables": ["team_franchise"]}
{"sample_id": 3707, "db_id": "baseball_1", "question": "Which cities have 2 to 4 parks?", "rationale": ["Identify the relevant table: The 'park' table contains information about parks, including their locations (cities).", "Determine the required information: We need to find cities that have between 2 and 4 parks.", "Use the COUNT function: To count the number of parks in each city, we will use the COUNT function.", "Group the results: We will group the results by city to aggregate the park counts for each city.", "Filter the results: We will use the HAVING clause to filter cities that have a park count between 2 and 4."], "pred_sql": "SELECT city, COUNT(park_id) AS park_count \nFROM park \nGROUP BY city \nHAVING park_count BETWEEN 2 AND 4;", "gold_sql": "SELECT city FROM park GROUP BY city HAVING count(*) BETWEEN 2 AND 4;", "source_tables": ["park"]}
{"sample_id": 3708, "db_id": "baseball_1", "question": "Find all the cities that have 2 to 4 parks.", "rationale": ["Identify the table that contains park information, which is the 'park' table.", "We need to find cities that have a certain number of parks, so we will group the results by the 'city' column.", "To count the number of parks in each city, we will use the COUNT function on 'park_id'.", "We want to filter the results to only include cities with between 2 and 4 parks, so we will use the HAVING clause with the condition COUNT(park_id) BETWEEN 2 AND 4."], "pred_sql": "SELECT city FROM park GROUP BY city HAVING COUNT(park_id) BETWEEN 2 AND 4;", "gold_sql": "SELECT city FROM park GROUP BY city HAVING count(*) BETWEEN 2 AND 4;", "source_tables": ["park"]}
{"sample_id": 3709, "db_id": "baseball_1", "question": "Which park had most attendances in 2008?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'park' for park names.", "We need to find the park with the highest attendance in the year 2008.", "Join the 'home_game' table with the 'park' table on 'park_id' to get park names along with attendance.", "Filter the results to only include records from the year 2008.", "Order the results by attendance in descending order to get the highest attendance first.", "Limit the results to 1 to get only the park with the most attendance."], "pred_sql": "SELECT park.park_name, home_game.attendance\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE home_game.year = 2008\nORDER BY home_game.attendance DESC\nLIMIT 1;", "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"]}
{"sample_id": 3710, "db_id": "baseball_1", "question": "Which park did the most people attend in 2008?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'park' for park names.", "We need to find the park with the highest attendance in the year 2008.", "Join the 'home_game' table with the 'park' table on 'park_id' to get the park names along with attendance.", "Filter the results to only include records from the year 2008.", "Order the results by attendance in descending order to get the highest attendance first.", "Limit the results to 1 to get only the park with the most attendance."], "pred_sql": "SELECT park.park_name, home_game.attendance \nFROM home_game \nJOIN park ON home_game.park_id = park.park_id \nWHERE home_game.year = 2008 \nORDER BY home_game.attendance DESC \nLIMIT 1;", "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"]}
{"sample_id": 3711, "db_id": "mountain_photos", "question": "How many camera lenses have a focal length longer than 15 mm?", "rationale": ["Identify the table relevant to the query, which is 'camera_lens'.", "Determine the condition specified in the query, which is to find camera lenses with a focal length greater than 15 mm.", "Use the COUNT() function to count the number of records that meet the specified condition.", "Construct the SQL query using the SELECT statement to count the records from the 'camera_lens' table where the focal_length_mm is greater than 15."], "pred_sql": "SELECT COUNT(*) FROM camera_lens WHERE focal_length_mm > 15;", "gold_sql": "SELECT count(*) FROM camera_lens WHERE focal_length_mm  >  15", "source_tables": ["camera_lens"]}
{"sample_id": 3712, "db_id": "mountain_photos", "question": "Find the brand and name for each camera lens, and sort in descending order of maximum aperture.", "rationale": ["Identify the table that contains the required information: the 'camera_lens' table.", "Determine the columns needed: 'brand' and 'name' for the camera lens.", "Specify the sorting requirement: sort the results by 'max_aperture' in descending order.", "Construct the SQL SELECT statement to retrieve the 'brand' and 'name' from the 'camera_lens' table, applying the ORDER BY clause for 'max_aperture' in descending order."], "pred_sql": "SELECT brand, name FROM camera_lens ORDER BY max_aperture DESC;", "gold_sql": "SELECT brand ,  name FROM camera_lens ORDER BY max_aperture DESC", "source_tables": ["camera_lens"]}
{"sample_id": 3713, "db_id": "mountain_photos", "question": "List the id, color scheme, and name for all the photos.", "rationale": ["Identify the table that contains the required data: The 'photos' table contains the columns we need: id, color, and name.", "Select the specific columns: We need to select 'id', 'color', and 'name' from the 'photos' table.", "Construct the SQL query: Use the SELECT statement to retrieve the specified columns from the 'photos' table."], "pred_sql": "SELECT id, color, name FROM photos;", "gold_sql": "SELECT id ,  color ,  name FROM photos", "source_tables": ["photos"]}
{"sample_id": 3714, "db_id": "mountain_photos", "question": "What are the maximum and average height of the mountains?", "rationale": ["Identify the required calculations: maximum and average height of mountains.", "Determine the relevant table: the 'mountain' table contains the height information.", "Use the SQL aggregate functions MAX() to find the maximum height and AVG() to find the average height.", "Construct the SQL query to select the maximum and average height from the 'mountain' table."], "pred_sql": "SELECT MAX(Height) AS max_height, AVG(Height) AS avg_height FROM mountain;", "gold_sql": "SELECT max(height) ,  avg(height) FROM mountain", "source_tables": ["mountain"]}
{"sample_id": 3715, "db_id": "mountain_photos", "question": "What are the average prominence of the mountains in country 'Morocco'?", "rationale": ["Identify the table that contains the relevant data: the 'mountain' table.", "Determine the column that contains the prominence values: 'Prominence'.", "We need to calculate the average, so we will use the AVG() function.", "We need to filter the results to only include mountains in Morocco, so we will add a WHERE clause to specify Country = 'Morocco'.", "Combine these elements to form the complete SQL query."], "pred_sql": "SELECT AVG(Prominence) AS average_prominence FROM mountain WHERE Country = 'Morocco';", "gold_sql": "SELECT avg(prominence) FROM mountain WHERE country  =  'Morocco'", "source_tables": ["mountain"]}
{"sample_id": 3716, "db_id": "mountain_photos", "question": "What are the name, height and prominence of mountains which do not belong to the range 'Aberdare Range'?", "rationale": ["Identify the columns needed: name, Height, and Prominence from the mountain table.", "Determine the table to query: the mountain table.", "Specify the condition: mountains that do not belong to the range 'Aberdare Range'.", "Construct the SQL SELECT statement to retrieve the specified columns while applying the condition using the WHERE clause."], "pred_sql": "SELECT name, Height, Prominence FROM mountain WHERE Range != 'Aberdare Range';", "gold_sql": "SELECT name ,  height ,  prominence FROM mountain WHERE range != 'Aberdare Range'", "source_tables": ["mountain"]}
{"sample_id": 3717, "db_id": "mountain_photos", "question": "What are the id and name of the photos for mountains?", "rationale": ["Identify the tables involved: 'photos' and 'mountain'.", "Determine the columns needed: 'photos.id' and 'photos.name'.", "Establish the relationship between the tables using the foreign key: 'photos.mountain_id' relates to 'mountain.id'.", "Construct the SQL query to select the required columns from the 'photos' table while joining with the 'mountain' table."], "pred_sql": "SELECT photos.id, photos.name FROM photos JOIN mountain ON photos.mountain_id = mountain.id;", "gold_sql": "SELECT T1.id ,  T1.name FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id WHERE T1.height  >  4000", "source_tables": ["mountain", "photos"]}
{"sample_id": 3718, "db_id": "mountain_photos", "question": "What are the id and name of the mountains that have at least 2 photos?", "rationale": ["Identify the relevant tables: We need data from the 'mountain' and 'photos' tables.", "Determine the relationship: The 'photos' table has a foreign key 'mountain_id' that references 'id' in the 'mountain' table.", "Select the required columns: We need 'id' and 'name' from the 'mountain' table.", "Join the tables: Use an INNER JOIN to combine 'mountain' and 'photos' based on the mountain's id.", "Group the results: We need to group the results by 'mountain.id' to count the number of photos for each mountain.", "Filter the groups: Use HAVING to filter groups that have at least 2 photos."], "pred_sql": "SELECT mountain.id, mountain.name FROM mountain JOIN photos ON mountain.id = photos.mountain_id GROUP BY mountain.id HAVING COUNT(photos.id) >= 2;", "gold_sql": "SELECT T1.id ,  T1.name FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id GROUP BY T1.id HAVING count(*)  >=  2", "source_tables": ["mountain", "photos"]}
{"sample_id": 3719, "db_id": "mountain_photos", "question": "What are the names of the cameras that have taken picture of the most mountains?", "rationale": ["Identify the relevant tables: We need to use the 'camera_lens' and 'photos' tables to find the camera names and the mountains they have photographed.", "Join the tables: We will join 'camera_lens' with 'photos' on the camera_lens_id to associate each photo with its corresponding camera lens.", "Group by camera lens: We will group the results by the camera lens id to count how many distinct mountains each camera has photographed.", "Count distinct mountains: We will use COUNT(DISTINCT p.mountain_id) to count the number of unique mountains for each camera lens.", "Order the results: We will order the results in descending order based on the count of distinct mountains to find the camera that has taken pictures of the most mountains.", "Limit the results: Finally, we will limit the results to 1 to get the camera lens that has taken pictures of the most mountains."], "pred_sql": "SELECT cl.name FROM camera_lens cl JOIN photos p ON cl.id = p.camera_lens_id GROUP BY cl.id ORDER BY COUNT(DISTINCT p.mountain_id) DESC LIMIT 1;", "gold_sql": "SELECT T2.name FROM photos AS T1 JOIN camera_lens AS T2 ON T1.camera_lens_id  =  T2.id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["photos", "camera_lens"]}
{"sample_id": 3720, "db_id": "mountain_photos", "question": "What are the names of photos taken with the lens brand 'Sigma' or 'Olympus'?", "rationale": ["Identify the relevant tables: We need to retrieve photo names, which are stored in the 'photos' table, and we need to filter based on the lens brand, which is in the 'camera_lens' table.", "Determine the relationship between tables: The 'photos' table has a foreign key 'camera_lens_id' that references the 'id' in the 'camera_lens' table. This means we need to join these two tables to access the brand information.", "Formulate the SQL query: We will use a SELECT statement to get the 'name' from the 'photos' table. We will join the 'photos' table with the 'camera_lens' table on the 'camera_lens_id'.", "Add the filtering condition: We need to filter the results where the 'brand' in the 'camera_lens' table is either 'Sigma' or 'Olympus'. This can be done using the IN clause in the WHERE statement."], "pred_sql": "SELECT photos.name FROM photos JOIN camera_lens ON photos.camera_lens_id = camera_lens.id WHERE camera_lens.brand IN ('Sigma', 'Olympus');", "gold_sql": "SELECT T1.name FROM camera_lens AS T1 JOIN photos AS T2 ON T2.camera_lens_id  =  T1.id WHERE T1.brand  =  'Sigma' OR T1.brand  =  'Olympus'", "source_tables": ["photos", "camera_lens"]}
{"sample_id": 3721, "db_id": "mountain_photos", "question": "How many different kinds of lens brands are there?", "rationale": ["Identify the table that contains the lens brand information, which is the 'camera_lens' table.", "To find the number of different kinds of lens brands, we need to count distinct entries in the 'brand' column.", "The SQL function COUNT(DISTINCT column_name) will be used to count unique values in the 'brand' column.", "The final SQL query will select the count of distinct brands from the 'camera_lens' table."], "pred_sql": "SELECT COUNT(DISTINCT brand) AS different_lens_brands FROM camera_lens;", "gold_sql": "SELECT count(DISTINCT brand) FROM camera_lens", "source_tables": ["camera_lens"]}
{"sample_id": 3722, "db_id": "mountain_photos", "question": "How many camera lenses are not used in taking any photos?", "rationale": ["Identify the camera_lens table as the source of camera lens data.", "We need to count the camera lenses that have not been used in any photos.", "To find unused camera lenses, we can use a subquery to select all distinct camera_lens_id from the photos table.", "The main query will count the number of camera lenses whose id is not in the list of used camera_lens_id from the photos table."], "pred_sql": "SELECT COUNT(*) FROM camera_lens WHERE id NOT IN (SELECT DISTINCT camera_lens_id FROM photos);", "gold_sql": "SELECT count(*) FROM camera_lens WHERE id NOT IN ( SELECT camera_lens_id FROM photos )", "source_tables": ["photos", "camera_lens"]}
{"sample_id": 3723, "db_id": "mountain_photos", "question": "How many distinct kinds of camera lenses are used to take photos of mountains in the country 'Ethiopia'?", "rationale": ["Identify the tables involved: We need data from the 'camera_lens', 'photos', and 'mountain' tables.", "Determine the relationship between the tables: 'photos' links 'camera_lens' and 'mountain' through their respective IDs.", "We need to filter the mountains based on the country 'Ethiopia'.", "Count the distinct camera lenses used for the photos of these mountains.", "Construct the SQL query using JOINs to connect the tables and apply the necessary filters."], "pred_sql": "SELECT COUNT(DISTINCT cl.id) AS distinct_lens_count\nFROM camera_lens cl\nJOIN photos p ON cl.id = p.camera_lens_id\nJOIN mountain m ON p.mountain_id = m.id\nWHERE m.Country = 'Ethiopia';", "gold_sql": "SELECT count(DISTINCT T2.camera_lens_id) FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id WHERE T1.country  =  'Ethiopia'", "source_tables": ["mountain", "photos"]}
{"sample_id": 3724, "db_id": "mountain_photos", "question": "List the brands of lenses that took both a picture of mountains with range 'Toubkal Atlas' and a picture of mountains with range 'Lasta Massif'", "rationale": ["Identify the tables involved: We need data from the 'camera_lens', 'photos', and 'mountain' tables.", "Determine the relationships: The 'photos' table links 'camera_lens' and 'mountain' through foreign keys.", "Filter mountains by range: We need to filter mountains that belong to the ranges 'Toubkal Atlas' and 'Lasta Massif'.", "Count distinct ranges: We want to ensure that the camera lens has taken photos of both ranges, so we will count distinct ranges in the HAVING clause.", "Select distinct brands: Finally, we will select distinct brands of the camera lenses that meet the criteria."], "pred_sql": "SELECT DISTINCT cl.brand \nFROM camera_lens cl \nJOIN photos p ON cl.id = p.camera_lens_id \nJOIN mountain m ON p.mountain_id = m.id \nWHERE m.Range IN ('Toubkal Atlas', 'Lasta Massif') \nGROUP BY cl.brand \nHAVING COUNT(DISTINCT m.Range) = 2;", "gold_sql": "SELECT T3.brand FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id JOIN camera_lens AS T3 ON T2.camera_lens_id  =  T3.id WHERE T1.range  =  'Toubkal Atlas' INTERSECT SELECT T3.brand FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id JOIN camera_lens AS T3 ON T2.camera_lens_id  =  T3.id WHERE T1.range  =  'Lasta Massif'", "source_tables": ["mountain", "photos", "camera_lens"]}
{"sample_id": 3725, "db_id": "mountain_photos", "question": "Show the name and prominence of the mountains whose picture is not taken by a lens of brand 'Sigma'.", "rationale": ["Identify the columns needed: 'name' and 'Prominence' from the 'mountain' table.", "Determine the relationship between tables: 'photos' links 'mountain' and 'camera_lens' through foreign keys.", "Use JOIN to combine 'mountain', 'photos', and 'camera_lens' tables based on their relationships.", "Apply a WHERE clause to filter out records where the 'brand' of the camera lens is 'Sigma'.", "Construct the SQL query to select the required columns with the specified conditions."], "pred_sql": "SELECT mountain.name, mountain.Prominence FROM mountain JOIN photos ON mountain.id = photos.mountain_id JOIN camera_lens ON photos.camera_lens_id = camera_lens.id WHERE camera_lens.brand != 'Sigma';", "gold_sql": "SELECT name ,  prominence FROM mountain EXCEPT SELECT T1.name ,  T1.prominence FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id JOIN camera_lens AS T3 ON T2.camera_lens_id  =  T3.id WHERE T3.brand  =  'Sigma'", "source_tables": ["mountain", "photos", "camera_lens"]}
{"sample_id": 3726, "db_id": "mountain_photos", "question": "List the camera lens names containing substring \"Digital\".", "rationale": ["Identify the table that contains the camera lens names, which is the 'camera_lens' table.", "Determine the column that holds the names of the camera lenses, which is the 'name' column.", "To find names containing a specific substring, use the SQL 'LIKE' operator with wildcards. In this case, we want to find names that contain the substring 'Digital'.", "Construct the SQL query to select the 'name' column from the 'camera_lens' table where the 'name' matches the pattern '%Digital%'."], "pred_sql": "SELECT name FROM camera_lens WHERE name LIKE '%Digital%';", "gold_sql": "SELECT name FROM camera_lens WHERE name LIKE '%Digital%'", "source_tables": ["camera_lens"]}
{"sample_id": 3727, "db_id": "mountain_photos", "question": "What is the name of each camera lens and the number of photos taken by it? Order the result by the count of photos.", "rationale": ["Identify the tables involved: We need data from the 'camera_lens' and 'photos' tables.", "Determine the required fields: We need the name of the camera lens and the count of photos taken by each lens.", "Use a JOIN operation: Since the 'photos' table references the 'camera_lens' table through 'camera_lens_id', we will perform a LEFT JOIN to include all camera lenses even if they have no associated photos.", "Group the results: We will group the results by the camera lens ID to count the number of photos for each lens.", "Count the photos: Use COUNT(photos.id) to get the number of photos for each camera lens.", "Order the results: Finally, we will order the results by the count of photos in ascending order."], "pred_sql": "SELECT camera_lens.name, COUNT(photos.id) AS photo_count \nFROM camera_lens \nLEFT JOIN photos ON camera_lens.id = photos.camera_lens_id \nGROUP BY camera_lens.id \nORDER BY photo_count;", "gold_sql": "SELECT T1.name ,  count(*) FROM camera_lens AS T1 JOIN photos AS T2 ON T1.id  =  T2.camera_lens_id GROUP BY T1.id ORDER BY count(*)", "source_tables": ["photos", "camera_lens"]}
{"sample_id": 3728, "db_id": "program_share", "question": "Find the names of channels that are not owned by CCTV.", "rationale": ["Identify the table that contains channel information, which is the 'channel' table.", "Determine the column that contains the channel names, which is 'Name'.", "Identify the column that indicates the owner of the channel, which is 'Owner'.", "Formulate a condition to filter out channels that are owned by CCTV, using the '!=' operator to exclude those records.", "Construct the SQL SELECT statement to retrieve the 'Name' of channels where the 'Owner' is not 'CCTV'."], "pred_sql": "SELECT Name FROM channel WHERE Owner != 'CCTV';", "gold_sql": "SELECT name FROM channel WHERE OWNER != 'CCTV'", "source_tables": ["channel"]}
{"sample_id": 3729, "db_id": "program_share", "question": "Which channels are not owned by CCTV? Give me the channel names.", "rationale": ["Identify the table that contains channel information, which is the 'channel' table.", "Determine the relevant column that contains the owner information, which is the 'Owner' column.", "Formulate a query to select the 'Name' of channels where the 'Owner' is not 'CCTV'.", "Use the SQL syntax for selecting specific columns and applying a condition with the WHERE clause."], "pred_sql": "SELECT Name FROM channel WHERE Owner != 'CCTV';", "gold_sql": "SELECT name FROM channel WHERE OWNER != 'CCTV'", "source_tables": ["channel"]}
{"sample_id": 3730, "db_id": "program_share", "question": "List all channel names ordered by their rating in percent from big to small.", "rationale": ["Identify the table that contains channel information, which is the 'channel' table.", "Determine the column that contains the channel names, which is 'Name'.", "Identify the column that contains the ratings, which is 'Rating_in_percent'.", "Construct the SQL query to select the 'Name' from the 'channel' table.", "Add an ORDER BY clause to sort the results by 'Rating_in_percent' in descending order."], "pred_sql": "SELECT Name FROM channel ORDER BY Rating_in_percent DESC;", "gold_sql": "SELECT name FROM channel ORDER BY rating_in_percent DESC", "source_tables": ["channel"]}
{"sample_id": 3731, "db_id": "program_share", "question": "Give me a list of all the channel names sorted by the channel rating in descending order.", "rationale": ["Identify the table that contains channel information, which is the 'channel' table.", "Determine the column that contains the channel names, which is 'Name'.", "Identify the column that contains the channel ratings, which is 'Rating_in_percent'.", "Construct a SQL query to select the 'Name' from the 'channel' table.", "Add an ORDER BY clause to sort the results by 'Rating_in_percent' in descending order."], "pred_sql": "SELECT Name FROM channel ORDER BY Rating_in_percent DESC;", "gold_sql": "SELECT name FROM channel ORDER BY rating_in_percent DESC", "source_tables": ["channel"]}
{"sample_id": 3732, "db_id": "program_share", "question": "What is the owner of the channel that has the highest rating ratio?", "rationale": ["Identify the table that contains the channel information, which is the 'channel' table.", "Determine the column that holds the rating information, which is 'Rating_in_percent'.", "To find the channel with the highest rating, we need to use the MAX function on the 'Rating_in_percent' column.", "Once we have the maximum rating, we can select the 'Owner' of the channel that has this maximum rating.", "Construct the SQL query to first find the maximum rating and then select the owner of the channel that matches this rating."], "pred_sql": "SELECT Owner FROM channel WHERE Rating_in_percent = (SELECT MAX(Rating_in_percent) FROM channel);", "gold_sql": "SELECT OWNER FROM channel ORDER BY rating_in_percent DESC LIMIT 1", "source_tables": ["channel"]}
{"sample_id": 3733, "db_id": "program_share", "question": "Show me the owner of the channel with the highest rating.", "rationale": ["Identify the table that contains the channel information, which is the 'channel' table.", "Determine the column that holds the channel owner information, which is 'Owner'.", "Identify the column that contains the channel ratings, which is 'Rating_in_percent'.", "To find the owner of the channel with the highest rating, we need to find the maximum value in the 'Rating_in_percent' column.", "Use a subquery to select the maximum rating from the 'channel' table.", "Finally, select the 'Owner' from the 'channel' table where the 'Rating_in_percent' matches the maximum rating found in the subquery."], "pred_sql": "SELECT Owner FROM channel WHERE Rating_in_percent = (SELECT MAX(Rating_in_percent) FROM channel);", "gold_sql": "SELECT OWNER FROM channel ORDER BY rating_in_percent DESC LIMIT 1", "source_tables": ["channel"]}
{"sample_id": 3734, "db_id": "program_share", "question": "how many programs are there?", "rationale": ["Identify the table that contains the information about programs, which is the 'program' table.", "To find out how many programs there are, we need to count the number of entries in the 'program' table.", "Use the COUNT() function to count the total number of rows in the 'program' table.", "Select the count and label it as 'program_count' for clarity."], "pred_sql": "SELECT COUNT(*) AS program_count FROM program;", "gold_sql": "SELECT count(*) FROM program", "source_tables": ["program"]}
{"sample_id": 3735, "db_id": "program_share", "question": "Count the number of programs.", "rationale": ["Identify the table that contains the programs, which is the 'program' table.", "To count the number of programs, we need to use the COUNT() function in SQL.", "The SQL query should select the count of all entries in the 'program' table.", "The final SQL query will be 'SELECT COUNT(*) AS program_count FROM program;' to get the total number of programs."], "pred_sql": "SELECT COUNT(*) AS program_count FROM program;", "gold_sql": "SELECT count(*) FROM program", "source_tables": ["program"]}
{"sample_id": 3736, "db_id": "program_share", "question": "list all the names of programs, ordering by launch time.", "rationale": ["Identify the table that contains the program names, which is the 'program' table.", "Select the 'Name' column from the 'program' table to get the names of the programs.", "Use the 'ORDER BY' clause to sort the results by the 'Launch' column, which indicates the launch time of the programs."], "pred_sql": "SELECT Name FROM program ORDER BY Launch;", "gold_sql": "SELECT name FROM program ORDER BY launch", "source_tables": ["program"]}
{"sample_id": 3737, "db_id": "program_share", "question": "What is the list of program names, sorted by the order of launch date?", "rationale": ["Identify the table that contains the program names, which is the 'program' table.", "Select the 'Name' column from the 'program' table to get the list of program names.", "To sort the program names by their launch date, use the 'ORDER BY' clause on the 'Launch' column.", "Construct the SQL query to select the program names and order them by launch date."], "pred_sql": "SELECT Name FROM program ORDER BY Launch;", "gold_sql": "SELECT name FROM program ORDER BY launch", "source_tables": ["program"]}
{"sample_id": 3738, "db_id": "program_share", "question": "List the name, origin and owner of each program.", "rationale": ["Identify the table that contains the required information, which is the 'program' table.", "Determine the specific columns needed: 'Name', 'Origin', and 'Owner'.", "Construct the SQL SELECT statement to retrieve these columns from the 'program' table."], "pred_sql": "SELECT Name, Origin, Owner FROM program;", "gold_sql": "SELECT name ,  origin ,  OWNER FROM program", "source_tables": ["program"]}
{"sample_id": 3739, "db_id": "program_share", "question": "What are the name, origin and owner of each program?", "rationale": ["Identify the table that contains the required information: The 'program' table has the columns Name, Origin, and Owner.", "Formulate the SQL SELECT statement to retrieve the specified columns from the 'program' table.", "Use the SELECT keyword followed by the column names and the FROM keyword to specify the table."], "pred_sql": "SELECT Name, Origin, Owner FROM program;", "gold_sql": "SELECT name ,  origin ,  OWNER FROM program", "source_tables": ["program"]}
{"sample_id": 3740, "db_id": "program_share", "question": "find the name of the program that was launched most recently.", "rationale": ["Identify the table that contains the program information, which is the 'program' table.", "Determine the relevant column that contains the launch date of the programs, which is 'Launch'.", "To find the most recently launched program, we need to sort the programs by the 'Launch' date in descending order.", "Since we only need the name of the program, we will select the 'Name' column.", "To get only the most recent program, we will limit the results to 1 using 'LIMIT 1'."], "pred_sql": "SELECT Name FROM program ORDER BY Launch DESC LIMIT 1;", "gold_sql": "SELECT name FROM program ORDER BY launch DESC LIMIT 1", "source_tables": ["program"]}
{"sample_id": 3741, "db_id": "program_share", "question": "Which program was launched most recently? Return the program name.", "rationale": ["Identify the table that contains the information about programs, which is the 'program' table.", "Determine the relevant column that indicates the launch date of the programs, which is the 'Launch' column.", "To find the most recently launched program, we need to sort the programs by the 'Launch' date in descending order.", "Since we only need the name of the most recently launched program, we will select the 'Name' column.", "To limit the results to only the most recent program, we will use 'LIMIT 1' in the query."], "pred_sql": "SELECT Name FROM program ORDER BY Launch DESC LIMIT 1;", "gold_sql": "SELECT name FROM program ORDER BY launch DESC LIMIT 1", "source_tables": ["program"]}
{"sample_id": 3742, "db_id": "program_share", "question": "find the total percentage share of all channels owned by CCTV.", "rationale": ["Identify the relevant tables: channel, broadcast, and broadcast_share are needed to find the total percentage share of programs broadcasted by channels owned by CCTV.", "We need to sum the 'Share_in_percent' from the broadcast_share table to get the total share.", "Join the channel table with the broadcast table on 'Channel_ID' to link channels to their broadcasts.", "Join the broadcast table with the broadcast_share table on 'Program_ID' to access the share data for the programs being broadcast.", "Filter the results to include only those channels where the 'Owner' is 'CCTV'.", "Construct the SQL query to select the sum of 'Share_in_percent' from the broadcast_share table, applying the necessary joins and where clause."], "pred_sql": "SELECT SUM(broadcast_share.Share_in_percent) AS Total_Share\nFROM channel\nJOIN broadcast ON channel.Channel_ID = broadcast.Channel_ID\nJOIN broadcast_share ON broadcast.Program_ID = broadcast_share.Program_ID\nWHERE channel.Owner = 'CCTV';", "gold_sql": "SELECT sum(Share_in_percent) FROM channel WHERE OWNER  =  'CCTV'", "source_tables": ["channel"]}
{"sample_id": 3743, "db_id": "program_share", "question": "What is the total share (in percent) of all the channels owned by CCTV?", "rationale": ["Identify the relevant tables: channel, broadcast, and broadcast_share are needed to get the total share of programs owned by CCTV.", "We need to sum the 'Share_in_percent' from the broadcast_share table.", "To link the tables, we will join channel with broadcast on 'Channel_ID' and then join broadcast with broadcast_share on 'Program_ID'.", "We will filter the results to only include channels where the 'Owner' is 'CCTV'.", "The final query will select the sum of the share percentages for the specified owner."], "pred_sql": "SELECT SUM(broadcast_share.Share_in_percent) AS Total_Share\nFROM channel\nJOIN broadcast ON channel.Channel_ID = broadcast.Channel_ID\nJOIN broadcast_share ON broadcast.Program_ID = broadcast_share.Program_ID\nWHERE channel.Owner = 'CCTV';", "gold_sql": "SELECT sum(Share_in_percent) FROM channel WHERE OWNER  =  'CCTV'", "source_tables": ["channel"]}
{"sample_id": 3744, "db_id": "program_share", "question": "Find the names of the channels that are broadcast in the morning.", "rationale": ["Identify the relevant tables: We need to find channel names, so we will use the 'channel' table.", "Determine the relationship: The 'broadcast' table links channels to their broadcast times, so we will join 'channel' and 'broadcast' on 'Channel_ID'.", "Specify the condition: We want to filter broadcasts that occur in the morning, which can be done using a WHERE clause with a LIKE condition on 'Time_of_day'.", "Select the distinct channel names: We will use SELECT DISTINCT to ensure we get unique channel names that broadcast in the morning."], "pred_sql": "SELECT DISTINCT channel.Name FROM channel JOIN broadcast ON channel.Channel_ID = broadcast.Channel_ID WHERE broadcast.Time_of_day LIKE 'morning%';", "gold_sql": "SELECT t1.name FROM channel AS t1 JOIN broadcast AS t2 ON t1.channel_id  =  t2.channel_id WHERE t2.time_of_day  =  'Morning'", "source_tables": ["broadcast", "channel"]}
{"sample_id": 3745, "db_id": "program_share", "question": "Which channels are broadcast in the morning? Give me the channel names.", "rationale": ["Identify the relevant tables: We need to look at the 'channel' and 'broadcast' tables to find the channels that are broadcast in the morning.", "Determine the join condition: The 'broadcast' table has a foreign key 'Channel_ID' that links to the 'channel' table's 'Channel_ID'. We will join these two tables on this key.", "Filter the results: We need to filter the broadcasts to only include those that occur in the morning. Assuming 'morning' refers to any time that starts with 'morning', we can use a LIKE clause to filter the 'Time_of_day' column.", "Select the desired output: We want to retrieve the names of the channels, so we will select 'channel.Name' and use DISTINCT to ensure we only get unique channel names."], "pred_sql": "SELECT DISTINCT channel.Name FROM channel JOIN broadcast ON channel.Channel_ID = broadcast.Channel_ID WHERE broadcast.Time_of_day LIKE 'morning%';", "gold_sql": "SELECT t1.name FROM channel AS t1 JOIN broadcast AS t2 ON t1.channel_id  =  t2.channel_id WHERE t2.time_of_day  =  'Morning'", "source_tables": ["broadcast", "channel"]}
{"sample_id": 3746, "db_id": "program_share", "question": "what are the names of the channels that broadcast in both morning and night?", "rationale": ["We need to find channels that broadcast in both morning and night.", "To do this, we will join the 'channel' table with the 'broadcast' table on 'Channel_ID'.", "We will filter the results to include only those broadcasts that occur in the 'morning' or 'night'.", "Next, we will group the results by 'Channel_ID' to aggregate the broadcasts for each channel.", "To ensure that we only get channels that broadcast in both time slots, we will use the HAVING clause to count distinct 'Time_of_day' values and check that it equals 2."], "pred_sql": "SELECT DISTINCT c.Name\nFROM channel c\nJOIN broadcast b ON c.Channel_ID = b.Channel_ID\nWHERE b.Time_of_day IN ('morning', 'night')\nGROUP BY c.Channel_ID\nHAVING COUNT(DISTINCT b.Time_of_day) = 2;", "gold_sql": "SELECT t1.name FROM channel AS t1 JOIN broadcast AS t2 ON t1.channel_id  =  t2.channel_id WHERE t2.time_of_day  =  'Morning' INTERSECT SELECT t1.name FROM channel AS t1 JOIN broadcast AS t2 ON t1.channel_id  =  t2.channel_id WHERE t2.time_of_day  =  'Night'", "source_tables": ["broadcast", "channel"]}
{"sample_id": 3747, "db_id": "program_share", "question": "Which channels broadcast both in the morning and at night? Give me the channel names.", "rationale": ["Identify the tables involved: We need to look at the 'channel' and 'broadcast' tables.", "We need to find channels that broadcast at two different times: 'morning' and 'night'.", "To achieve this, we can join the 'channel' table with the 'broadcast' table twice: once for morning broadcasts and once for night broadcasts.", "Use a WHERE clause to filter the broadcasts for the specific times of day.", "Select the distinct names of the channels that meet these criteria."], "pred_sql": "SELECT DISTINCT c.Name \nFROM channel c \nJOIN broadcast b1 ON c.Channel_ID = b1.Channel_ID \nJOIN broadcast b2 ON c.Channel_ID = b2.Channel_ID \nWHERE b1.Time_of_day = 'morning' \nAND b2.Time_of_day = 'night';", "gold_sql": "SELECT t1.name FROM channel AS t1 JOIN broadcast AS t2 ON t1.channel_id  =  t2.channel_id WHERE t2.time_of_day  =  'Morning' INTERSECT SELECT t1.name FROM channel AS t1 JOIN broadcast AS t2 ON t1.channel_id  =  t2.channel_id WHERE t2.time_of_day  =  'Night'", "source_tables": ["broadcast", "channel"]}
{"sample_id": 3748, "db_id": "program_share", "question": "how many programs are broadcast in each time section of the day?", "rationale": ["Identify the relevant table: The 'broadcast' table contains the information about programs and their broadcast times.", "Determine the required information: We need to count the number of distinct programs broadcasted at each time of day.", "Use the COUNT function to count distinct Program_IDs for each Time_of_day.", "Group the results by Time_of_day to get the count for each time section."], "pred_sql": "SELECT Time_of_day, COUNT(DISTINCT Program_ID) AS Program_Count FROM broadcast GROUP BY Time_of_day;", "gold_sql": "SELECT count(*) ,  time_of_day FROM broadcast GROUP BY time_of_day", "source_tables": ["broadcast"]}
{"sample_id": 3749, "db_id": "program_share", "question": "Count the number of programs broadcast for each time section of a day.", "rationale": ["Identify the relevant table: The 'broadcast' table contains the information about programs and their broadcast times.", "Determine the required output: We need to count the number of programs for each time section of the day.", "Use the COUNT() function to count the number of Program_IDs for each Time_of_day.", "Group the results by Time_of_day to get the count for each unique time section."], "pred_sql": "SELECT Time_of_day, COUNT(Program_ID) AS Program_Count\nFROM broadcast\nGROUP BY Time_of_day;", "gold_sql": "SELECT count(*) ,  time_of_day FROM broadcast GROUP BY time_of_day", "source_tables": ["broadcast"]}
{"sample_id": 3750, "db_id": "program_share", "question": "find the number of different programs that are broadcast during night time.", "rationale": ["Identify the relevant table: The 'broadcast' table contains information about the programs being broadcast, including the time of day.", "Determine the criteria for 'night time': Assuming 'night time' refers to any time labeled as 'Night' in the 'Time_of_day' column.", "Count distinct programs: We need to count the number of different programs, which requires using COUNT(DISTINCT Program_ID) to ensure each program is only counted once.", "Construct the SQL query: The query will select the count of distinct Program_IDs from the broadcast table where the Time_of_day indicates night."], "pred_sql": "SELECT COUNT(DISTINCT b.Program_ID) AS Number_of_Programs\nFROM broadcast b\nWHERE b.Time_of_day LIKE 'Night%';", "gold_sql": "SELECT count(DISTINCT program_id) FROM broadcast WHERE time_of_day  =  'Night'", "source_tables": ["broadcast"]}
{"sample_id": 3751, "db_id": "program_share", "question": "How many distinct programs are broadcast at \"Night\" time?", "rationale": ["Identify the relevant table: The 'broadcast' table contains information about the programs being broadcast, including the time of day.", "Determine the requirement: We need to count distinct programs that are broadcast at 'Night'.", "Use the COUNT function to count distinct Program_IDs from the broadcast table.", "Add a WHERE clause to filter the results to only include broadcasts that occur at 'Night'.", "Construct the SQL query using the SELECT statement to retrieve the count of distinct programs."], "pred_sql": "SELECT COUNT(DISTINCT b.Program_ID) AS distinct_programs_count\nFROM broadcast b\nWHERE b.Time_of_day = 'Night';", "gold_sql": "SELECT count(DISTINCT program_id) FROM broadcast WHERE time_of_day  =  'Night'", "source_tables": ["broadcast"]}
{"sample_id": 3752, "db_id": "program_share", "question": "Find the names of programs that are never broadcasted in the morning.", "rationale": ["Identify the main table to query from, which is the 'program' table, as we need the names of programs.", "We need to find programs that are never broadcasted in the morning, so we will look for programs whose IDs are not present in the broadcast table for the morning time.", "Construct a subquery that selects Program_IDs from the 'broadcast' table where Time_of_day is 'morning'.", "Use the NOT IN clause to filter out those Program_IDs from the main query on the 'program' table.", "Select the 'Name' column from the 'program' table for the final output."], "pred_sql": "SELECT p.Name FROM program p WHERE p.Program_ID NOT IN (SELECT b.Program_ID FROM broadcast b WHERE b.Time_of_day = 'morning');", "gold_sql": "SELECT name FROM program EXCEPT SELECT t1.name FROM program AS t1 JOIN broadcast AS t2 ON t1.program_id  =  t2.program_id WHERE t2.Time_of_day  =  'Morning'", "source_tables": ["broadcast", "program"]}
{"sample_id": 3753, "db_id": "program_share", "question": "Which programs are never broadcasted in the morning? Give me the names of the programs.", "rationale": ["Identify the main table to query from, which is the 'program' table, as we need the names of the programs.", "We need to find programs that are never broadcasted in the morning, so we will use a subquery to find all programs that are broadcasted in the morning.", "The subquery will select the 'Program_ID' from the 'broadcast' table where 'Time_of_day' is 'morning'.", "We will then use the NOT IN clause to filter out these programs from the main query, ensuring we only get programs that are not in the list of those broadcasted in the morning.", "Finally, we will select the 'Name' of the programs from the 'program' table that meet this condition."], "pred_sql": "SELECT p.Name FROM program p WHERE p.Program_ID NOT IN (SELECT b.Program_ID FROM broadcast b WHERE b.Time_of_day = 'morning');", "gold_sql": "SELECT name FROM program EXCEPT SELECT t1.name FROM program AS t1 JOIN broadcast AS t2 ON t1.program_id  =  t2.program_id WHERE t2.Time_of_day  =  'Morning'", "source_tables": ["broadcast", "program"]}
{"sample_id": 3754, "db_id": "program_share", "question": "find the program owners that have some programs in both morning and night time.", "rationale": ["Identify the relevant tables: We need to look at the 'program' and 'broadcast' tables since we are interested in program owners and their broadcast times.", "Join the 'program' table with the 'broadcast' table on the Program_ID to link programs with their broadcast times.", "Filter the results to include only those broadcasts that occur in the 'morning' and 'night'.", "Group the results by program owner to aggregate the data for each owner.", "Use the HAVING clause to ensure that we only select owners who have programs broadcasted in both 'morning' and 'night', which means we need to count distinct time_of_day values and check that it equals 2."], "pred_sql": "SELECT DISTINCT p.Owner \nFROM program p \nJOIN broadcast b ON p.Program_ID = b.Program_ID \nWHERE b.Time_of_day IN ('morning', 'night') \nGROUP BY p.Owner \nHAVING COUNT(DISTINCT b.Time_of_day) = 2;", "gold_sql": "SELECT t1.owner FROM program AS t1 JOIN broadcast AS t2 ON t1.program_id  =  t2.program_id WHERE t2.Time_of_day  =  'Morning' INTERSECT SELECT t1.owner FROM program AS t1 JOIN broadcast AS t2 ON t1.program_id  =  t2.program_id WHERE t2.Time_of_day  =  'Night'", "source_tables": ["broadcast", "program"]}
{"sample_id": 3755, "db_id": "program_share", "question": "Who are the owners of the programs that broadcast both in the morning and at night?", "rationale": ["Identify the relevant tables: We need to look at the 'program' and 'broadcast' tables to find the owners of the programs that are broadcasted at specific times.", "Determine the conditions: We are interested in programs that are broadcast both in the morning and at night. This means we need to join the 'broadcast' table twice, once for morning and once for night.", "Join the tables: We will join the 'program' table with the 'broadcast' table twice, using the 'Program_ID' to link them, and filter the results based on the 'Time_of_day' for each join.", "Select the distinct owners: Finally, we will select the distinct owners of the programs that meet the criteria."], "pred_sql": "SELECT DISTINCT p.Owner\nFROM program p\nJOIN broadcast b1 ON p.Program_ID = b1.Program_ID AND b1.Time_of_day = 'morning'\nJOIN broadcast b2 ON p.Program_ID = b2.Program_ID AND b2.Time_of_day = 'night';", "gold_sql": "SELECT t1.owner FROM program AS t1 JOIN broadcast AS t2 ON t1.program_id  =  t2.program_id WHERE t2.Time_of_day  =  'Morning' INTERSECT SELECT t1.owner FROM program AS t1 JOIN broadcast AS t2 ON t1.program_id  =  t2.program_id WHERE t2.Time_of_day  =  'Night'", "source_tables": ["broadcast", "program"]}
{"sample_id": 3756, "db_id": "program_share", "question": "List all program origins in the alphabetical order.", "rationale": ["Identify the table that contains the information about program origins, which is the 'program' table.", "To list all unique program origins, use the SELECT DISTINCT statement to avoid duplicates.", "Specify the column 'Origin' to retrieve the origins of the programs.", "To sort the results in alphabetical order, use the ORDER BY clause with 'Origin' and specify ASC for ascending order."], "pred_sql": "SELECT DISTINCT Origin FROM program ORDER BY Origin ASC;", "gold_sql": "SELECT origin FROM program ORDER BY origin", "source_tables": ["program"]}
{"sample_id": 3757, "db_id": "program_share", "question": "What is the list of program origins ordered alphabetically?", "rationale": ["Identify the table that contains the information about program origins, which is the 'program' table.", "To get a list of unique program origins, use the DISTINCT keyword to avoid duplicates.", "The requirement is to order the results alphabetically, so the ORDER BY clause is used with the 'Origin' column in ascending order."], "pred_sql": "SELECT DISTINCT Origin FROM program ORDER BY Origin ASC;", "gold_sql": "SELECT origin FROM program ORDER BY origin", "source_tables": ["program"]}
{"sample_id": 3758, "db_id": "program_share", "question": "what is the number of different channel owners?", "rationale": ["Identify the table that contains information about channel owners, which is the 'channel' table.", "To find the number of different channel owners, we need to count distinct values in the 'Owner' column of the 'channel' table.", "The SQL query will use the COUNT function along with DISTINCT to ensure we only count unique owners."], "pred_sql": "SELECT COUNT(DISTINCT Owner) AS Number_of_Different_Channel_Owners FROM channel;", "gold_sql": "SELECT count(DISTINCT OWNER) FROM channel", "source_tables": ["channel"]}
{"sample_id": 3759, "db_id": "program_share", "question": "Count the number of distinct channel owners.", "rationale": ["Identify the table that contains the information about channel owners, which is the 'channel' table.", "To count the number of distinct owners, we will use the COUNT function along with DISTINCT to ensure we only count unique owners.", "The SQL query will select the count of distinct owners from the 'Owner' column in the 'channel' table."], "pred_sql": "SELECT COUNT(DISTINCT Owner) AS distinct_channel_owners FROM channel;", "gold_sql": "SELECT count(DISTINCT OWNER) FROM channel", "source_tables": ["channel"]}
{"sample_id": 3760, "db_id": "program_share", "question": "find the names of programs whose origin is not in Beijing.", "rationale": ["Identify the table that contains the information about programs, which is the 'program' table.", "Determine the column that contains the origin of the programs, which is the 'Origin' column.", "Formulate a query to select the 'Name' of the programs where the 'Origin' is not equal to 'Beijing'."], "pred_sql": "SELECT Name FROM program WHERE Origin != 'Beijing';", "gold_sql": "SELECT name FROM program WHERE origin != 'Beijing'", "source_tables": ["program"]}
{"sample_id": 3761, "db_id": "program_share", "question": "Which programs' origins are not \"Beijing\"? Give me the program names.", "rationale": ["Identify the table that contains the information about programs, which is the 'program' table.", "Determine the relevant column that contains the origin of the programs, which is the 'Origin' column.", "Specify the condition to filter out programs that have 'Beijing' as their origin, using the '!=' operator.", "Select the 'Name' column to retrieve the names of the programs that meet the condition."], "pred_sql": "SELECT Name FROM program WHERE Origin != 'Beijing';", "gold_sql": "SELECT name FROM program WHERE origin != 'Beijing'", "source_tables": ["program"]}
{"sample_id": 3762, "db_id": "program_share", "question": "What are the names of the channels owned by CCTV or HBS?", "rationale": ["Identify the table that contains channel information, which is the 'channel' table.", "Determine the relevant column that contains the owner information, which is the 'Owner' column.", "Formulate a query to select the 'Name' of channels where the 'Owner' is either 'CCTV' or 'HBS'.", "Use the SQL 'IN' clause to specify multiple owners in the condition."], "pred_sql": "SELECT Name FROM channel WHERE Owner IN ('CCTV', 'HBS');", "gold_sql": "SELECT name FROM channel WHERE OWNER  =  'CCTV' OR OWNER  =  'HBS'", "source_tables": ["channel"]}
{"sample_id": 3763, "db_id": "program_share", "question": "List the names of all the channels owned by either CCTV or HBS", "rationale": ["Identify the table that contains channel information, which is the 'channel' table.", "Determine the relevant column that contains the owner information, which is the 'Owner' column.", "The query needs to filter channels based on the owners 'CCTV' or 'HBS'.", "Use the SQL SELECT statement to retrieve the 'Name' of the channels where the 'Owner' matches either 'CCTV' or 'HBS'.", "Construct the SQL query using the IN clause to specify multiple owners."], "pred_sql": "SELECT Name FROM channel WHERE Owner IN ('CCTV', 'HBS');", "gold_sql": "SELECT name FROM channel WHERE OWNER  =  'CCTV' OR OWNER  =  'HBS'", "source_tables": ["channel"]}
{"sample_id": 3764, "db_id": "program_share", "question": "Find the total rating ratio for each channel owner.", "rationale": ["Identify the relevant table: The query requires information about channel owners and their ratings, so we will use the 'channel' table.", "Select the necessary columns: We need to select the 'Owner' column to group by channel owners and the 'Rating_in_percent' column to calculate the total rating ratio.", "Use the SUM function: To find the total rating ratio for each channel owner, we will use the SUM function on the 'Rating_in_percent' column.", "Group the results: We will group the results by the 'Owner' column to get the total rating ratio for each owner.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "pred_sql": "SELECT channel.Owner, SUM(channel.Rating_in_percent) AS Total_Rating_Ratio\nFROM channel\nGROUP BY channel.Owner;", "gold_sql": "SELECT sum(Rating_in_percent) ,  OWNER FROM channel GROUP BY OWNER", "source_tables": ["channel"]}
{"sample_id": 3765, "db_id": "program_share", "question": "What is the total rating of channel for each channel owner?", "rationale": ["Identify the relevant table: The query requires information about channel ratings, so we will use the 'channel' table.", "Determine the required columns: We need the 'Owner' of the channel and the 'Rating_in_percent' to calculate the total rating.", "Use the SUM function: To get the total rating for each channel owner, we will sum the 'Rating_in_percent' for each owner.", "Group the results: We will group the results by 'Owner' to get the total rating for each channel owner."], "pred_sql": "SELECT Owner, SUM(Rating_in_percent) AS Total_Rating FROM channel GROUP BY Owner;", "gold_sql": "SELECT sum(Rating_in_percent) ,  OWNER FROM channel GROUP BY OWNER", "source_tables": ["channel"]}
{"sample_id": 3766, "db_id": "program_share", "question": "Find the name of the program that is broadcast most frequently.", "rationale": ["Identify the relevant tables: We need to find the program name, which is in the 'program' table, and we need to know how often each program is broadcast, which is in the 'broadcast' table.", "Join the 'program' table with the 'broadcast' table on the 'Program_ID' to link programs with their broadcast occurrences.", "Group the results by 'Program_ID' to count how many times each program is broadcasted.", "Use the COUNT function to count the number of broadcasts for each program.", "Order the results in descending order based on the count of broadcasts to find the most frequently broadcast program.", "Limit the results to 1 to get only the top program."], "pred_sql": "SELECT p.Name\nFROM program p\nJOIN broadcast b ON p.Program_ID = b.Program_ID\nGROUP BY p.Program_ID\nORDER BY COUNT(b.Program_ID) DESC\nLIMIT 1;", "gold_sql": "SELECT t1.name FROM program AS t1 JOIN broadcast AS t2 ON t1.program_id  =  t2.program_id GROUP BY t2.program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["broadcast", "program"]}
{"sample_id": 3767, "db_id": "program_share", "question": "Which program is broadcast most frequently? Give me the program name.", "rationale": ["Identify the relevant tables: We need to look at the 'program' and 'broadcast' tables to find the program names and their broadcast frequency.", "Join the tables: We will join the 'program' table with the 'broadcast' table on the 'Program_ID' to associate each program with its broadcasts.", "Group by program: We will group the results by 'Program_ID' to count how many times each program is broadcasted.", "Count broadcasts: Use COUNT(b.Program_ID) to count the number of broadcasts for each program.", "Order the results: We will order the results in descending order based on the count of broadcasts to find the most frequently broadcast program.", "Limit the results: Finally, we will limit the results to 1 to get only the top program."], "pred_sql": "SELECT p.Name FROM program p JOIN broadcast b ON p.Program_ID = b.Program_ID GROUP BY p.Program_ID ORDER BY COUNT(b.Program_ID) DESC LIMIT 1;", "gold_sql": "SELECT t1.name FROM program AS t1 JOIN broadcast AS t2 ON t1.program_id  =  t2.program_id GROUP BY t2.program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["broadcast", "program"]}
{"sample_id": 3768, "db_id": "e_learning", "question": "How many courses are there in total?", "rationale": ["Identify the table that contains the course information, which is the 'Courses' table.", "To find the total number of courses, we need to count the entries in the 'Courses' table.", "Use the COUNT() function to count all rows in the 'Courses' table.", "Construct the SQL query to select the count of courses from the 'Courses' table."], "pred_sql": "SELECT COUNT(*) AS total_courses FROM Courses;", "gold_sql": "SELECT count(*) FROM COURSES", "source_tables": ["courses"]}
{"sample_id": 3769, "db_id": "e_learning", "question": "Find the total number of courses offered.", "rationale": ["Identify the table that contains information about courses, which is the 'Courses' table.", "To find the total number of courses, we need to count the entries in the 'Courses' table.", "Use the COUNT() function to count all rows in the 'Courses' table.", "Select the count with an alias 'total_courses' for clarity."], "pred_sql": "SELECT COUNT(*) AS total_courses FROM Courses;", "gold_sql": "SELECT count(*) FROM COURSES", "source_tables": ["courses"]}
{"sample_id": 3770, "db_id": "e_learning", "question": "What are the descriptions of the courses with name \"database\"?", "rationale": ["Identify the relevant table: The query is asking for course descriptions, which are found in the 'Courses' table.", "Determine the specific column needed: We need the 'course_description' column from the 'Courses' table.", "Apply the filter condition: The query specifies that we are looking for courses with the name 'database', so we will add a WHERE clause to filter by 'course_name'.", "Construct the SQL query: Combine the SELECT statement with the specified column, the FROM clause with the table name, and the WHERE clause with the condition."], "pred_sql": "SELECT course_description FROM Courses WHERE course_name = 'database';", "gold_sql": "SELECT course_description FROM COURSES WHERE course_name  =  'database'", "source_tables": ["courses"]}
{"sample_id": 3771, "db_id": "e_learning", "question": "Return the description for the courses named \"database\".", "rationale": ["Identify the table that contains course descriptions, which is the 'Courses' table.", "Determine the column that holds the course name, which is 'course_name'.", "Determine the column that holds the course description, which is 'course_description'.", "Construct a SQL SELECT statement to retrieve 'course_description' from 'Courses' where 'course_name' matches 'database'."], "pred_sql": "SELECT course_description FROM Courses WHERE course_name = 'database';", "gold_sql": "SELECT course_description FROM COURSES WHERE course_name  =  'database'", "source_tables": ["courses"]}
{"sample_id": 3772, "db_id": "e_learning", "question": "What are the addresses of the course authors or tutors with personal name \"Cathrine\"", "rationale": ["Identify the table that contains the information about course authors or tutors, which is 'Course_Authors_and_Tutors'.", "Determine the relevant column that contains the addresses, which is 'address_line_1'.", "Identify the condition needed to filter the results, which is the personal name being 'Cathrine'.", "Construct the SQL query to select the 'address_line_1' from 'Course_Authors_and_Tutors' where 'personal_name' equals 'Cathrine'."], "pred_sql": "SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name = 'Cathrine';", "gold_sql": "SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name\t =  'Cathrine'", "source_tables": ["course_authors_and_tutors"]}
{"sample_id": 3773, "db_id": "e_learning", "question": "Return the addresses of the course authors or tutors whose personal name is \"Cathrine\".", "rationale": ["Identify the table that contains the addresses of authors or tutors, which is 'Course_Authors_and_Tutors'.", "Determine the column that holds the address information, which is 'address_line_1'.", "Filter the results based on the condition that the 'personal_name' must be 'Cathrine'.", "Construct the SQL SELECT statement to retrieve the 'address_line_1' for the specified 'personal_name'."], "pred_sql": "SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name = 'Cathrine';", "gold_sql": "SELECT address_line_1 FROM Course_Authors_and_Tutors WHERE personal_name\t =  'Cathrine'", "source_tables": ["course_authors_and_tutors"]}
{"sample_id": 3774, "db_id": "e_learning", "question": "List the addresses of all the course authors or tutors.", "rationale": ["Identify the table that contains the addresses of course authors or tutors, which is 'Course_Authors_and_Tutors'.", "Determine the specific column that holds the address information, which is 'address_line_1'.", "Construct a SQL SELECT statement to retrieve the 'address_line_1' column from the 'Course_Authors_and_Tutors' table."], "pred_sql": "SELECT address_line_1 FROM Course_Authors_and_Tutors;", "gold_sql": "SELECT address_line_1 FROM Course_Authors_and_Tutors", "source_tables": ["course_authors_and_tutors"]}
{"sample_id": 3775, "db_id": "e_learning", "question": "What is the address of each course author or tutor?", "rationale": ["Identify the table that contains the information about course authors and tutors, which is 'Course_Authors_and_Tutors'.", "Determine the specific column that holds the address information, which is 'address_line_1'.", "Construct a SQL SELECT query to retrieve the 'address_line_1' from the 'Course_Authors_and_Tutors' table."], "pred_sql": "SELECT address_line_1 FROM Course_Authors_and_Tutors;", "gold_sql": "SELECT address_line_1 FROM Course_Authors_and_Tutors", "source_tables": ["course_authors_and_tutors"]}
{"sample_id": 3776, "db_id": "e_learning", "question": "List all the login names and family names of course author and tutors.", "rationale": ["Identify the table that contains the required information: Course_Authors_and_Tutors.", "Determine the specific columns needed: login_name and family_name.", "Construct the SQL SELECT statement to retrieve these columns from the identified table."], "pred_sql": "SELECT login_name, family_name FROM Course_Authors_and_Tutors;", "gold_sql": "SELECT login_name ,  family_name FROM Course_Authors_and_Tutors", "source_tables": ["course_authors_and_tutors"]}
{"sample_id": 3777, "db_id": "e_learning", "question": "What are the login names and family names of course author and tutors?", "rationale": ["Identify the relevant table: Course_Authors_and_Tutors contains the information about authors and tutors.", "Determine the required fields: We need the login names and family names of the authors and tutors.", "Construct the SQL SELECT statement: Use SELECT to specify the fields 'login_name' and 'family_name'.", "Specify the source table: Indicate that the data should be retrieved from the Course_Authors_and_Tutors table."], "pred_sql": "SELECT login_name, family_name FROM Course_Authors_and_Tutors;", "gold_sql": "SELECT login_name ,  family_name FROM Course_Authors_and_Tutors", "source_tables": ["course_authors_and_tutors"]}
{"sample_id": 3778, "db_id": "e_learning", "question": "List all the dates of enrollment and completion of students.", "rationale": ["Identify the relevant table: The 'Student_Course_Enrolment' table contains the enrollment and completion dates for students.", "Determine the required columns: We need to retrieve 'date_of_enrolment' and 'date_of_completion' from the 'Student_Course_Enrolment' table.", "Construct the SQL SELECT statement: Use SELECT to specify the columns to retrieve and FROM to specify the table."], "pred_sql": "SELECT date_of_enrolment, date_of_completion FROM Student_Course_Enrolment;", "gold_sql": "SELECT date_of_enrolment ,  date_of_completion FROM Student_Course_Enrolment", "source_tables": ["student_course_enrolment"]}
{"sample_id": 3779, "db_id": "e_learning", "question": "What are all the dates of enrollment and completion in record?", "rationale": ["Identify the relevant table: The query asks for dates of enrollment and completion, which are found in the Student_Course_Enrolment table.", "Select the specific columns: We need to retrieve the 'date_of_enrolment' and 'date_of_completion' columns from the Student_Course_Enrolment table.", "Construct the SQL query: Use the SELECT statement to specify the columns and the FROM clause to indicate the table from which to retrieve the data."], "pred_sql": "SELECT date_of_enrolment, date_of_completion FROM Student_Course_Enrolment;", "gold_sql": "SELECT date_of_enrolment ,  date_of_completion FROM Student_Course_Enrolment", "source_tables": ["student_course_enrolment"]}
{"sample_id": 3780, "db_id": "e_learning", "question": "How many distinct students are enrolled in courses?", "rationale": ["Identify the table that contains information about student enrollments, which is the 'Student_Course_Enrolment' table.", "To find the number of distinct students, we need to count unique 'student_id' values in the 'Student_Course_Enrolment' table.", "Use the COUNT function along with DISTINCT to ensure that each student is only counted once, regardless of how many courses they are enrolled in."], "pred_sql": "SELECT COUNT(DISTINCT student_id) AS distinct_students FROM Student_Course_Enrolment;", "gold_sql": "SELECT count(DISTINCT student_id) FROM Student_Course_Enrolment", "source_tables": ["student_course_enrolment"]}
{"sample_id": 3781, "db_id": "e_learning", "question": "Find the number of distinct students enrolled in courses.", "rationale": ["Identify the relevant table: The 'Student_Course_Enrolment' table contains the records of students enrolled in courses.", "Determine the requirement: We need to find the number of distinct students, which means we need to count unique student IDs.", "Use the COUNT function: To count the distinct student IDs, we will use the COUNT function with the DISTINCT keyword.", "Construct the SQL query: The final SQL query will select the count of distinct student IDs from the 'Student_Course_Enrolment' table."], "pred_sql": "SELECT COUNT(DISTINCT student_id) AS distinct_students_count FROM Student_Course_Enrolment;", "gold_sql": "SELECT count(DISTINCT student_id) FROM Student_Course_Enrolment", "source_tables": ["student_course_enrolment"]}
{"sample_id": 3782, "db_id": "e_learning", "question": "How many distinct courses are enrolled in by students?", "rationale": ["Identify the relevant table: The 'Student_Course_Enrolment' table contains information about course registrations by students.", "Determine the required information: We need to count the distinct courses that students are enrolled in.", "Use the COUNT function with DISTINCT: This will allow us to count only unique course IDs from the 'course_id' column in the 'Student_Course_Enrolment' table.", "Construct the SQL query: The final query selects the count of distinct course IDs from the 'Student_Course_Enrolment' table."], "pred_sql": "SELECT COUNT(DISTINCT course_id) AS distinct_courses_enrolled FROM Student_Course_Enrolment;", "gold_sql": "SELECT count(course_id) FROM Student_Course_Enrolment", "source_tables": ["student_course_enrolment"]}
{"sample_id": 3783, "db_id": "e_learning", "question": "Find the number of distinct courses that have enrolled students.", "rationale": ["Identify the relevant table: The 'Student_Course_Enrolment' table contains information about course registrations.", "Determine the requirement: We need to find the number of distinct courses that have students enrolled.", "Use the COUNT function: To count the distinct courses, we will use COUNT(DISTINCT course_id).", "Construct the SQL query: The query will select the count of distinct course IDs from the 'Student_Course_Enrolment' table."], "pred_sql": "SELECT COUNT(DISTINCT course_id) AS distinct_course_count FROM Student_Course_Enrolment;", "gold_sql": "SELECT count(course_id) FROM Student_Course_Enrolment", "source_tables": ["student_course_enrolment"]}
{"sample_id": 3784, "db_id": "e_learning", "question": "Find the dates of the tests taken with result \"Pass\".", "rationale": ["Identify the relevant table: The query is about tests taken by students, so we will use the 'Student_Tests_Taken' table.", "Determine the required columns: We need the 'date_test_taken' column to find the dates of the tests.", "Apply the condition: We need to filter the results to only include tests where the 'test_result' is 'Pass'.", "Construct the SQL query: Combine the selected columns, table, and condition into a complete SQL statement."], "pred_sql": "SELECT date_test_taken FROM Student_Tests_Taken WHERE test_result = 'Pass';", "gold_sql": "SELECT date_test_taken FROM Student_Tests_Taken WHERE test_result  =  'Pass'", "source_tables": ["student_tests_taken"]}
{"sample_id": 3785, "db_id": "e_learning", "question": "Which tests have \"Pass\" results? Return the dates when the tests were taken.", "rationale": ["Identify the relevant table: The query is asking for test results, which are stored in the 'Student_Tests_Taken' table.", "Determine the required columns: The user wants the dates when tests were taken, so we need the 'date_test_taken' column.", "Filter the results: We need to filter the results to only include tests that have a result of 'Pass'.", "Construct the SQL query: Combine the selected column and the filter condition into a SQL SELECT statement."], "pred_sql": "SELECT date_test_taken FROM Student_Tests_Taken WHERE test_result = 'Pass';", "gold_sql": "SELECT date_test_taken FROM Student_Tests_Taken WHERE test_result  =  'Pass'", "source_tables": ["student_tests_taken"]}
{"sample_id": 3786, "db_id": "e_learning", "question": "How many tests have result \"Fail\"?", "rationale": ["Identify the table that contains the test results, which is 'Student_Tests_Taken'.", "Determine the column that holds the test results, which is 'test_result'.", "Specify the condition to filter the results to only include those that are 'Fail'.", "Use the COUNT() function to count the number of records that meet the condition.", "Construct the SQL query to select the count of failed tests from the 'Student_Tests_Taken' table."], "pred_sql": "SELECT COUNT(*) AS fail_count FROM Student_Tests_Taken WHERE test_result = 'Fail';", "gold_sql": "SELECT count(*) FROM Student_Tests_Taken WHERE test_result  =  'Fail'", "source_tables": ["student_tests_taken"]}
{"sample_id": 3787, "db_id": "e_learning", "question": "Count the number of tests with \"Fail\" result.", "rationale": ["Identify the table that contains the test results, which is 'Student_Tests_Taken'.", "Determine the column that holds the result of the tests, which is 'test_result'.", "Specify the condition to filter the results to only include those with a 'Fail' result.", "Use the COUNT() function to count the number of records that meet the condition.", "Construct the SQL query to select the count of failed tests from the 'Student_Tests_Taken' table."], "pred_sql": "SELECT COUNT(*) AS fail_count FROM Student_Tests_Taken WHERE test_result = 'Fail';", "gold_sql": "SELECT count(*) FROM Student_Tests_Taken WHERE test_result  =  'Fail'", "source_tables": ["student_tests_taken"]}
{"sample_id": 3788, "db_id": "e_learning", "question": "What are the login names of the students with family name \"Ward\"?", "rationale": ["Identify the table that contains student information, which is the 'Students' table.", "Determine the column that holds the family names, which is 'family_name'.", "Specify the condition to filter the results to only include students with the family name 'Ward'.", "Select the 'login_name' column to retrieve the login names of the filtered students."], "pred_sql": "SELECT login_name FROM Students WHERE family_name = 'Ward';", "gold_sql": "SELECT login_name FROM Students WHERE family_name  =  'Ward'", "source_tables": ["students"]}
{"sample_id": 3789, "db_id": "e_learning", "question": "Return the login names of the students whose family name is \"Ward\".", "rationale": ["Identify the table that contains student information, which is the 'Students' table.", "Determine the column that holds the family names, which is 'family_name'.", "Specify the condition to filter the results to only those students whose family name is 'Ward'.", "Select the 'login_name' column to retrieve the login names of the filtered students."], "pred_sql": "SELECT login_name FROM Students WHERE family_name = 'Ward';", "gold_sql": "SELECT login_name FROM Students WHERE family_name  =  'Ward'", "source_tables": ["students"]}
{"sample_id": 3790, "db_id": "e_learning", "question": "What are the dates of the latest logon of the students with family name \"Jaskolski\" or \"Langosh\"?", "rationale": ["Identify the relevant table: The query is asking for information about students, so we will use the 'Students' table.", "Determine the required columns: We need the 'date_of_latest_logon' column to fulfill the request.", "Specify the condition: We need to filter the results to include only those students whose family name is either 'Jaskolski' or 'Langosh'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'date_of_latest_logon' from the 'Students' table with a WHERE clause to filter by family names using the IN operator."], "pred_sql": "SELECT date_of_latest_logon FROM Students WHERE family_name IN ('Jaskolski', 'Langosh');", "gold_sql": "SELECT date_of_latest_logon FROM Students WHERE family_name  =  'Jaskolski' OR family_name  =  'Langosh'", "source_tables": ["students"]}
{"sample_id": 3791, "db_id": "e_learning", "question": "Find the latest logon date of the students whose family name is \"Jaskolski\" or \"Langosh\".", "rationale": ["Identify the table that contains the information about students, which is the 'Students' table.", "Determine the column that holds the family names of the students, which is 'family_name'.", "Specify the condition to filter students whose family name is either 'Jaskolski' or 'Langosh'.", "Identify the column that contains the latest logon date, which is 'date_of_latest_logon'.", "Construct the SQL query to select 'date_of_latest_logon' from 'Students' where 'family_name' matches the specified names."], "pred_sql": "SELECT date_of_latest_logon FROM Students WHERE family_name IN ('Jaskolski', 'Langosh');", "gold_sql": "SELECT date_of_latest_logon FROM Students WHERE family_name  =  'Jaskolski' OR family_name  =  'Langosh'", "source_tables": ["students"]}
{"sample_id": 3792, "db_id": "e_learning", "question": "How many students have personal names that contain the word \"son\"?", "rationale": ["Identify the table that contains student information, which is the 'Students' table.", "Determine the column that holds the personal names of students, which is 'personal_name'.", "Formulate a condition to check if 'personal_name' contains the substring 'son'. This can be done using the SQL LIKE operator with wildcards.", "Count the number of records that meet this condition using the COUNT() function."], "pred_sql": "SELECT COUNT(*) AS student_count FROM Students WHERE personal_name LIKE '%son%';", "gold_sql": "SELECT COUNT(*) FROM Students WHERE personal_name LIKE '%son%'", "source_tables": ["students"]}
{"sample_id": 3793, "db_id": "e_learning", "question": "Find the number of students who have the word \"son\" in their personal names.", "rationale": ["Identify the table that contains student information, which is the 'Students' table.", "Determine the column that contains the personal names of students, which is 'personal_name'.", "Formulate a query to count the number of students whose personal names contain the substring 'son'.", "Use the SQL COUNT function to get the total number of matching records.", "Utilize the LIKE operator with wildcards to search for 'son' within the 'personal_name' column."], "pred_sql": "SELECT COUNT(*) AS number_of_students FROM Students WHERE personal_name LIKE '%son%';", "gold_sql": "SELECT COUNT(*) FROM Students WHERE personal_name LIKE '%son%'", "source_tables": ["students"]}
{"sample_id": 3794, "db_id": "e_learning", "question": "List all the subject names.", "rationale": ["Identify the table that contains the subject names, which is the 'Subjects' table.", "Determine the specific column that holds the subject names, which is 'subject_name'.", "Construct the SQL query to select the 'subject_name' from the 'Subjects' table."], "pred_sql": "SELECT subject_name FROM Subjects;", "gold_sql": "SELECT subject_name FROM SUBJECTS", "source_tables": ["subjects"]}
{"sample_id": 3795, "db_id": "e_learning", "question": "What are the names of all the subjects.", "rationale": ["Identify the table that contains the subject names, which is the 'Subjects' table.", "Determine the specific column that holds the names of the subjects, which is 'subject_name'.", "Construct the SQL query to select all entries from the 'subject_name' column in the 'Subjects' table."], "pred_sql": "SELECT subject_name FROM Subjects;", "gold_sql": "SELECT subject_name FROM SUBJECTS", "source_tables": ["subjects"]}
{"sample_id": 3796, "db_id": "e_learning", "question": "List all the information about course authors and tutors in alphabetical order of the personal name.", "rationale": ["Identify the table that contains information about course authors and tutors, which is 'Course_Authors_and_Tutors'.", "Determine that we need to select all columns from this table, so we will use 'SELECT *'.", "To fulfill the requirement of listing the information in alphabetical order of the personal name, we will use 'ORDER BY personal_name ASC'.", "Combine these elements to form the complete SQL query."], "pred_sql": "SELECT * FROM Course_Authors_and_Tutors ORDER BY personal_name ASC;", "gold_sql": "SELECT * FROM Course_Authors_and_Tutors ORDER BY personal_name", "source_tables": ["course_authors_and_tutors"]}
{"sample_id": 3797, "db_id": "e_learning", "question": "Sort the information about course authors and tutors in alphabetical order of the personal name.", "rationale": ["Identify the table that contains information about course authors and tutors, which is 'Course_Authors_and_Tutors'.", "Determine the requirement to sort the information based on the 'personal_name' column.", "Construct the SQL query to select all columns from the 'Course_Authors_and_Tutors' table.", "Add an ORDER BY clause to sort the results in ascending order based on 'personal_name'."], "pred_sql": "SELECT * FROM Course_Authors_and_Tutors ORDER BY personal_name ASC;", "gold_sql": "SELECT * FROM Course_Authors_and_Tutors ORDER BY personal_name", "source_tables": ["course_authors_and_tutors"]}
{"sample_id": 3798, "db_id": "e_learning", "question": "List the personal names and family names of all the students in alphabetical order of family name.", "rationale": ["Identify the table that contains student information, which is the 'Students' table.", "Determine the columns needed for the output, which are 'personal_name' and 'family_name'.", "Specify the selection of these columns in the SQL query using SELECT.", "To ensure the results are sorted alphabetically by family name, use the ORDER BY clause with 'family_name' and specify ASC for ascending order."], "pred_sql": "SELECT personal_name, family_name FROM Students ORDER BY family_name ASC;", "gold_sql": "SELECT personal_name ,  family_name FROM Students ORDER BY family_name", "source_tables": ["students"]}
{"sample_id": 3799, "db_id": "e_learning", "question": "What are the personal names and family names of the students? Sort the result in alphabetical order of the family name.", "rationale": ["Identify the table that contains student information, which is the 'Students' table.", "Determine the columns needed for the output, which are 'personal_name' and 'family_name'.", "Construct the SELECT statement to retrieve 'personal_name' and 'family_name' from the 'Students' table.", "Add an ORDER BY clause to sort the results by 'family_name' in ascending order."], "pred_sql": "SELECT personal_name, family_name FROM Students ORDER BY family_name ASC;", "gold_sql": "SELECT personal_name ,  family_name FROM Students ORDER BY family_name", "source_tables": ["students"]}
{"sample_id": 3800, "db_id": "e_learning", "question": "List each test result and its count in descending order of count.", "rationale": ["Identify the table that contains the test results, which is 'Student_Tests_Taken'.", "Select the 'test_result' column to get the results of the tests taken by students.", "Use the COUNT function to count the occurrences of each test result.", "Group the results by 'test_result' to aggregate the counts for each unique result.", "Order the results in descending order based on the count of each test result."], "pred_sql": "SELECT test_result, COUNT(test_result) AS result_count \nFROM Student_Tests_Taken \nGROUP BY test_result \nORDER BY result_count DESC;", "gold_sql": "SELECT test_result ,  COUNT(*) FROM Student_Tests_Taken GROUP BY test_result ORDER BY COUNT(*) DESC", "source_tables": ["student_tests_taken"]}
{"sample_id": 3801, "db_id": "e_learning", "question": "For each distinct test result, find the number of students who got the result.", "rationale": ["We need to find distinct test results, so we will select the 'test_result' column from the 'Student_Tests_Taken' table.", "To count the number of students for each distinct test result, we will use the COUNT function on the 'student_id' column, ensuring we count distinct students.", "We will group the results by 'test_result' to get the count of students for each unique test result."], "pred_sql": "SELECT test_result, COUNT(DISTINCT student_id) AS number_of_students\nFROM Student_Tests_Taken\nGROUP BY test_result;", "gold_sql": "SELECT test_result ,  COUNT(*) FROM Student_Tests_Taken GROUP BY test_result ORDER BY COUNT(*) DESC", "source_tables": ["student_tests_taken"]}
{"sample_id": 3802, "db_id": "e_learning", "question": "Find the login name of the course author that teaches the course with name \"advanced database\".", "rationale": ["Identify the relevant tables: We need to find the login name of a course author, which involves the Course_Authors_and_Tutors and Courses tables.", "Determine the relationship: The Courses table has a foreign key that links to the Course_Authors_and_Tutors table via author_id.", "Filter the courses: We need to filter the Courses table to find the course with the name 'advanced database'.", "Select the login name: Finally, we select the login_name from the Course_Authors_and_Tutors table for the author associated with the specified course."], "pred_sql": "SELECT CA.login_name \nFROM Course_Authors_and_Tutors CA \nJOIN Courses C ON CA.author_id = C.author_id \nWHERE C.course_name = 'advanced database';", "gold_sql": "SELECT T1.login_name FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id WHERE T2.course_name  =  'advanced database'", "source_tables": ["courses", "course_authors_and_tutors"]}
{"sample_id": 3803, "db_id": "e_learning", "question": "Which course author teaches the \"advanced database\" course? Give me his or her login name.", "rationale": ["Identify the relevant tables: Courses and Course_Authors_and_Tutors.", "Determine the relationship between the tables: Courses has a foreign key author_id that links to Course_Authors_and_Tutors.", "We need to find the login name of the author who teaches the 'advanced database' course.", "Construct the SQL query to select the login_name from Course_Authors_and_Tutors where the course_name in Courses matches 'advanced database'.", "Use a JOIN to connect Courses and Course_Authors_and_Tutors on author_id."], "pred_sql": "SELECT CA.login_name FROM Courses C JOIN Course_Authors_and_Tutors CA ON C.author_id = CA.author_id WHERE C.course_name = 'advanced database';", "gold_sql": "SELECT T1.login_name FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id WHERE T2.course_name  =  'advanced database'", "source_tables": ["courses", "course_authors_and_tutors"]}
{"sample_id": 3804, "db_id": "e_learning", "question": "Find the addresses of the course authors who teach the course with name \"operating system\" or \"data structure\".", "rationale": ["Identify the relevant tables: We need to find addresses of course authors, so we will use the 'Course_Authors_and_Tutors' table for author details and the 'Courses' table to link authors to courses.", "Determine the relationship: The 'Courses' table has a foreign key 'author_id' that links to 'Course_Authors_and_Tutors'. We will join these two tables on this key.", "Filter the courses: We need to filter the courses to only those with the names 'operating system' or 'data structure'. This can be done using a WHERE clause with the IN operator.", "Select the required field: We only need the 'address_line_1' field from the 'Course_Authors_and_Tutors' table, so we will select that in our query."], "pred_sql": "SELECT ca.address_line_1 \nFROM Course_Authors_and_Tutors ca \nJOIN Courses c ON ca.author_id = c.author_id \nWHERE c.course_name IN ('operating system', 'data structure');", "gold_sql": "SELECT T1.address_line_1 FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id WHERE T2.course_name  =  'operating system' OR T2.course_name  =  'data structure'", "source_tables": ["courses", "course_authors_and_tutors"]}
{"sample_id": 3805, "db_id": "e_learning", "question": "What are the addresses of the course authors who teach either \"operating system\" or \"data structure\" course.", "rationale": ["Identify the relevant tables: Course_Authors_and_Tutors for author details, Courses for course information, and Subjects for subject names.", "We need to find addresses of authors who teach specific courses, so we will join the Course_Authors_and_Tutors table with the Courses table on author_id.", "Next, we join the Courses table with the Subjects table on subject_id to filter by subject names.", "The WHERE clause will specify that we are interested in subjects named 'operating system' or 'data structure'.", "Finally, we select the distinct addresses from the Course_Authors_and_Tutors table to avoid duplicates."], "pred_sql": "SELECT DISTINCT CA.address_line_1 \nFROM Course_Authors_and_Tutors CA \nJOIN Courses C ON CA.author_id = C.author_id \nJOIN Subjects S ON C.subject_id = S.subject_id \nWHERE S.subject_name IN ('operating system', 'data structure');", "gold_sql": "SELECT T1.address_line_1 FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id WHERE T2.course_name  =  'operating system' OR T2.course_name  =  'data structure'", "source_tables": ["courses", "course_authors_and_tutors"]}
{"sample_id": 3806, "db_id": "e_learning", "question": "Find the personal name, family name, and author ID of the course author that teaches the most courses.", "rationale": ["Identify the relevant tables: We need to retrieve information from the Course_Authors_and_Tutors table for author details and the Courses table to count the number of courses each author teaches.", "Join the Course_Authors_and_Tutors table with the Courses table on the author_id to link authors with their courses.", "Group the results by author_id to aggregate the number of courses each author teaches.", "Count the number of courses for each author using COUNT(c.course_id).", "Order the results in descending order based on the count of courses to find the author who teaches the most courses.", "Limit the results to 1 to get only the top author."], "pred_sql": "SELECT ca.personal_name, ca.family_name, ca.author_id\nFROM Course_Authors_and_Tutors ca\nJOIN Courses c ON ca.author_id = c.author_id\nGROUP BY ca.author_id\nORDER BY COUNT(c.course_id) DESC\nLIMIT 1;", "gold_sql": "SELECT T1.personal_name ,  T1.family_name ,  T2.author_id FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id GROUP BY T2.author_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["courses", "course_authors_and_tutors"]}
{"sample_id": 3807, "db_id": "e_learning", "question": "What are the personal name, family name, and author ID of the course author who teaches the most courses?", "rationale": ["Identify the relevant tables: We need information from the Course_Authors_and_Tutors table for author details and the Courses table to count the number of courses each author teaches.", "Join the Course_Authors_and_Tutors table with the Courses table on the author_id to link authors with their courses.", "Group the results by author_id to aggregate the number of courses each author teaches.", "Count the number of courses for each author using COUNT(c.course_id).", "Order the results in descending order based on the count of courses to find the author who teaches the most courses.", "Limit the results to 1 to get only the top author."], "pred_sql": "SELECT ca.personal_name, ca.family_name, ca.author_id\nFROM Course_Authors_and_Tutors ca\nJOIN Courses c ON ca.author_id = c.author_id\nGROUP BY ca.author_id\nORDER BY COUNT(c.course_id) DESC\nLIMIT 1;", "gold_sql": "SELECT T1.personal_name ,  T1.family_name ,  T2.author_id FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id GROUP BY T2.author_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["courses", "course_authors_and_tutors"]}
{"sample_id": 3808, "db_id": "e_learning", "question": "Find the addresses and author IDs of the course authors that teach at least two courses.", "rationale": ["Identify the relevant tables: We need information from the Course_Authors_and_Tutors table for author details and the Courses table to count the number of courses each author teaches.", "Join the Course_Authors_and_Tutors table with the Courses table on the author_id to link authors with their courses.", "Group the results by author_id and address_line_1 to aggregate the courses taught by each author.", "Use the HAVING clause to filter the groups to only include authors who teach at least two courses, which is done by counting the course_id and ensuring it is greater than or equal to 2."], "pred_sql": "SELECT ca.author_id, ca.address_line_1\nFROM Course_Authors_and_Tutors ca\nJOIN Courses c ON ca.author_id = c.author_id\nGROUP BY ca.author_id, ca.address_line_1\nHAVING COUNT(c.course_id) >= 2;", "gold_sql": "SELECT T1.address_line_1 ,  T2.author_id FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id GROUP BY T2.author_id HAVING Count(*)  >=  2", "source_tables": ["courses", "course_authors_and_tutors"]}
{"sample_id": 3809, "db_id": "e_learning", "question": "Which course authors teach two or more courses? Give me their addresses and author IDs.", "rationale": ["Identify the relevant tables: We need to find information from the Course_Authors_and_Tutors and Courses tables.", "Determine the relationship: The Courses table has a foreign key author_id that links to the author_id in the Course_Authors_and_Tutors table.", "Select the required fields: We need the author_id and address_line_1 from the Course_Authors_and_Tutors table.", "Count the number of courses per author: We will group the results by author_id and count the number of courses associated with each author.", "Filter authors who teach two or more courses: We will use the HAVING clause to filter groups with a count of courses greater than or equal to 2."], "pred_sql": "SELECT ca.author_id, ca.address_line_1\nFROM Course_Authors_and_Tutors ca\nJOIN Courses c ON ca.author_id = c.author_id\nGROUP BY ca.author_id\nHAVING COUNT(c.course_id) >= 2;", "gold_sql": "SELECT T1.address_line_1 ,  T2.author_id FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id GROUP BY T2.author_id HAVING Count(*)  >=  2", "source_tables": ["courses", "course_authors_and_tutors"]}
{"sample_id": 3810, "db_id": "e_learning", "question": "Find the names of courses taught by the tutor who has personal name \"Julio\".", "rationale": ["Identify the relevant tables: Courses and Course_Authors_and_Tutors.", "Determine the relationship between the tables: Courses has a foreign key author_id that references author_id in Course_Authors_and_Tutors.", "We need to filter the results based on the personal name of the tutor, which is found in the Course_Authors_and_Tutors table.", "Construct the SQL query to select course names from the Courses table where the corresponding author (tutor) has the personal name 'Julio'.", "Use a JOIN to combine the Courses and Course_Authors_and_Tutors tables on the author_id field."], "pred_sql": "SELECT Courses.course_name FROM Courses JOIN Course_Authors_and_Tutors ON Courses.author_id = Course_Authors_and_Tutors.author_id WHERE Course_Authors_and_Tutors.personal_name = 'Julio';", "gold_sql": "SELECT T2.course_name FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id WHERE T1.personal_name  =  'Julio'", "source_tables": ["courses", "course_authors_and_tutors"]}
{"sample_id": 3811, "db_id": "e_learning", "question": "What are the names of the courses taught by the tutor whose personal name is \"Julio\"?", "rationale": ["Identify the relevant tables: Courses and Course_Authors_and_Tutors.", "Determine the relationship between the tables: Courses has a foreign key author_id that references author_id in Course_Authors_and_Tutors.", "We need to filter the results based on the personal name of the tutor, which is found in the Course_Authors_and_Tutors table.", "Construct the SQL query to select course names from the Courses table where the corresponding author (tutor) has the personal name 'Julio'.", "Use a JOIN to combine the Courses and Course_Authors_and_Tutors tables on the author_id field."], "pred_sql": "SELECT Courses.course_name FROM Courses JOIN Course_Authors_and_Tutors ON Courses.author_id = Course_Authors_and_Tutors.author_id WHERE Course_Authors_and_Tutors.personal_name = 'Julio';", "gold_sql": "SELECT T2.course_name FROM Course_Authors_and_Tutors AS T1 JOIN Courses AS T2 ON T1.author_id  =  T2.author_id WHERE T1.personal_name  =  'Julio'", "source_tables": ["courses", "course_authors_and_tutors"]}
{"sample_id": 3812, "db_id": "e_learning", "question": "Find the names and descriptions of courses that belong to the subject named \"Computer Science\".", "rationale": ["Identify the relevant tables: Courses and Subjects are needed to get course names and descriptions based on the subject.", "Determine the columns to select: We need 'course_name' and 'course_description' from the Courses table.", "Establish the relationship between tables: Courses are linked to Subjects through the 'subject_id' foreign key.", "Formulate the JOIN clause: Use an INNER JOIN to combine Courses and Subjects on 'subject_id'.", "Add the WHERE clause to filter by the subject name: We want only those courses where the subject name is 'Computer Science'."], "pred_sql": "SELECT Courses.course_name, Courses.course_description \nFROM Courses \nJOIN Subjects ON Courses.subject_id = Subjects.subject_id \nWHERE Subjects.subject_name = 'Computer Science';", "gold_sql": "SELECT T1.course_name ,  T1.course_description FROM Courses AS T1 JOIN Subjects AS T2 ON T1.subject_id  =  T2.subject_id WHERE T2.subject_name  =  'Computer Science'", "source_tables": ["courses", "subjects"]}
{"sample_id": 3813, "db_id": "e_learning", "question": "What are the names and descriptions of the all courses under the \"Computer Science\" subject?", "rationale": ["Identify the relevant tables: Courses and Subjects are needed to get course names and descriptions along with the subject name.", "Determine the columns to select: We need 'course_name' and 'course_description' from the Courses table.", "Establish the relationship between tables: Use a JOIN to connect Courses and Subjects on 'subject_id'.", "Filter the results: Use a WHERE clause to specify that we only want courses under the subject 'Computer Science'."], "pred_sql": "SELECT Courses.course_name, Courses.course_description \nFROM Courses \nJOIN Subjects ON Courses.subject_id = Subjects.subject_id \nWHERE Subjects.subject_name = 'Computer Science';", "gold_sql": "SELECT T1.course_name ,  T1.course_description FROM Courses AS T1 JOIN Subjects AS T2 ON T1.subject_id  =  T2.subject_id WHERE T2.subject_name  =  'Computer Science'", "source_tables": ["courses", "subjects"]}
{"sample_id": 3814, "db_id": "e_learning", "question": "Find the subject ID, subject name, and the corresponding number of available courses for each subject.", "rationale": ["Identify the required fields: subject ID, subject name, and the number of available courses.", "The subject ID and subject name are found in the Subjects table.", "The number of available courses can be determined by counting the course IDs in the Courses table that correspond to each subject ID.", "To relate the Subjects table to the Courses table, a LEFT JOIN is used on the subject_id field.", "The COUNT function is used to count the number of courses for each subject, and the results are grouped by subject ID and subject name."], "pred_sql": "SELECT s.subject_id, s.subject_name, COUNT(c.course_id) AS number_of_courses\nFROM Subjects s\nLEFT JOIN Courses c ON s.subject_id = c.subject_id\nGROUP BY s.subject_id, s.subject_name;", "gold_sql": "SELECT T1.subject_id ,  T2.subject_name ,  COUNT(*) FROM Courses AS T1 JOIN Subjects AS T2 ON T1.subject_id  =  T2.subject_id GROUP BY T1.subject_id", "source_tables": ["courses", "subjects"]}
{"sample_id": 3815, "db_id": "e_learning", "question": "What are the subject ID, subject name, and the number of available courses for each subject?", "rationale": ["Identify the required fields: subject ID, subject name, and the count of courses for each subject.", "The subject ID and subject name are found in the Subjects table.", "The number of available courses can be obtained by counting the course IDs from the Courses table.", "To relate subjects to courses, a JOIN operation is necessary between the Subjects and Courses tables on the subject_id field.", "Since some subjects may not have any courses, a LEFT JOIN is appropriate to ensure all subjects are included in the results.", "Finally, use GROUP BY to aggregate the results by subject ID and subject name, and use COUNT to get the number of courses for each subject."], "pred_sql": "SELECT Subjects.subject_id, Subjects.subject_name, COUNT(Courses.course_id) AS number_of_courses\nFROM Subjects\nLEFT JOIN Courses ON Subjects.subject_id = Courses.subject_id\nGROUP BY Subjects.subject_id, Subjects.subject_name;", "gold_sql": "SELECT T1.subject_id ,  T2.subject_name ,  COUNT(*) FROM Courses AS T1 JOIN Subjects AS T2 ON T1.subject_id  =  T2.subject_id GROUP BY T1.subject_id", "source_tables": ["courses", "subjects"]}
{"sample_id": 3816, "db_id": "e_learning", "question": "Find the subject ID, name of subject and the corresponding number of courses for each subject, and sort by the course count in ascending order.", "rationale": ["We need to retrieve the subject ID and name from the Subjects table.", "We also need to count the number of courses associated with each subject, which requires joining the Courses table with the Subjects table.", "To get the count of courses per subject, we will use a LEFT JOIN to ensure we include subjects even if they have no courses.", "We will group the results by subject ID and subject name to aggregate the course counts correctly.", "Finally, we will sort the results by the course count in ascending order."], "pred_sql": "SELECT Subjects.subject_id, Subjects.subject_name, COUNT(Courses.course_id) AS course_count \nFROM Subjects \nLEFT JOIN Courses ON Subjects.subject_id = Courses.subject_id \nGROUP BY Subjects.subject_id, Subjects.subject_name \nORDER BY course_count ASC;", "gold_sql": "SELECT T1.subject_id ,  T2.subject_name ,  COUNT(*) FROM Courses AS T1 JOIN Subjects AS T2 ON T1.subject_id  =  T2.subject_id GROUP BY T1.subject_id ORDER BY COUNT(*) ASC", "source_tables": ["courses", "subjects"]}
{"sample_id": 3817, "db_id": "e_learning", "question": "List the subject ID, name of subject and the number of courses available for each subject in ascending order of the course counts.", "rationale": ["Identify the required columns: subject ID, subject name, and the count of courses.", "The subject ID and subject name are from the Subjects table.", "The count of courses is derived from the Courses table, which is related to the Subjects table via the subject_id.", "Use a LEFT JOIN to include all subjects even if they have no courses.", "Group the results by subject ID and subject name to aggregate the course counts.", "Order the results in ascending order based on the course count."], "pred_sql": "SELECT s.subject_id, s.subject_name, COUNT(c.course_id) AS course_count \nFROM Subjects s \nLEFT JOIN Courses c ON s.subject_id = c.subject_id \nGROUP BY s.subject_id, s.subject_name \nORDER BY course_count ASC;", "gold_sql": "SELECT T1.subject_id ,  T2.subject_name ,  COUNT(*) FROM Courses AS T1 JOIN Subjects AS T2 ON T1.subject_id  =  T2.subject_id GROUP BY T1.subject_id ORDER BY COUNT(*) ASC", "source_tables": ["courses", "subjects"]}
{"sample_id": 3818, "db_id": "e_learning", "question": "What is the date of enrollment of the course named \"Spanish\"?", "rationale": ["Identify the relevant tables: We need to find the date of enrollment for a specific course, which involves the 'Student_Course_Enrolment' and 'Courses' tables.", "Determine the relationship: The 'Student_Course_Enrolment' table contains the enrollment dates and is linked to the 'Courses' table through the 'course_id'.", "Specify the course name: The query needs to filter for the course named 'Spanish'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'date_of_enrolment' from 'Student_Course_Enrolment', joining it with 'Courses' to filter by the course name."], "pred_sql": "SELECT Student_Course_Enrolment.date_of_enrolment \nFROM Student_Course_Enrolment \nJOIN Courses ON Student_Course_Enrolment.course_id = Courses.course_id \nWHERE Courses.course_name = 'Spanish';", "gold_sql": "SELECT T2.date_of_enrolment FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id WHERE T1.course_name  =  'Spanish'", "source_tables": ["courses", "student_course_enrolment"]}
{"sample_id": 3819, "db_id": "e_learning", "question": "Find the the date of enrollment of the \"Spanish\" course.", "rationale": ["Identify the relevant tables: We need to find the date of enrollment for a specific course, which involves the Student_Course_Enrolment and Courses tables, and we also need to filter by the subject name, which requires the Subjects table.", "Determine the necessary columns: We need the 'date_of_enrolment' from the Student_Course_Enrolment table.", "Establish relationships: We need to join the Student_Course_Enrolment table with the Courses table on 'course_id', and then join the Courses table with the Subjects table on 'subject_id' to filter by the subject name.", "Construct the SQL query: Using SELECT to get the 'date_of_enrolment', and using JOINs to connect the tables, followed by a WHERE clause to filter for the 'Spanish' course."], "pred_sql": "SELECT Student_Course_Enrolment.date_of_enrolment \nFROM Student_Course_Enrolment \nJOIN Courses ON Student_Course_Enrolment.course_id = Courses.course_id \nJOIN Subjects ON Courses.subject_id = Subjects.subject_id \nWHERE Subjects.subject_name = 'Spanish';", "gold_sql": "SELECT T2.date_of_enrolment FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id WHERE T1.course_name  =  'Spanish'", "source_tables": ["courses", "student_course_enrolment"]}
{"sample_id": 3820, "db_id": "e_learning", "question": "What is the name of the course that has the most student enrollment?", "rationale": ["Identify the relevant table for courses, which is the 'Courses' table.", "We need to find the course with the most student enrollments, so we will look at the 'Student_Course_Enrolment' table to count the number of enrollments per course.", "We will group the results by 'course_id' in the 'Student_Course_Enrolment' table and count the number of 'student_id' for each course.", "To find the course with the maximum enrollments, we will order the results by the count of 'student_id' in descending order and limit the results to 1.", "Finally, we will select the 'course_name' from the 'Courses' table where the 'course_id' matches the one with the highest count from the previous step."], "pred_sql": "SELECT course_name FROM Courses WHERE course_id = (SELECT course_id FROM Student_Course_Enrolment GROUP BY course_id ORDER BY COUNT(student_id) DESC LIMIT 1)", "gold_sql": "SELECT T1.course_name FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_enrolment"]}
{"sample_id": 3821, "db_id": "e_learning", "question": "Which course is enrolled in by the most students? Give me the course name.", "rationale": ["Identify the relevant tables: Courses and Student_Course_Enrolment are needed to find the course names and the number of students enrolled in each course.", "Join the Courses table with the Student_Course_Enrolment table on the course_id to link courses with their enrollments.", "Group the results by course_id to aggregate the number of students enrolled in each course.", "Count the number of student_id entries for each course to determine how many students are enrolled in each course.", "Order the results in descending order based on the count of students to find the course with the most enrollments.", "Limit the results to 1 to get only the course with the highest number of enrollments."], "pred_sql": "SELECT C.course_name\nFROM Courses C\nJOIN Student_Course_Enrolment SCE ON C.course_id = SCE.course_id\nGROUP BY C.course_id\nORDER BY COUNT(SCE.student_id) DESC\nLIMIT 1;", "gold_sql": "SELECT T1.course_name FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_enrolment"]}
{"sample_id": 3822, "db_id": "e_learning", "question": "What are the names of the courses that have exactly 1 student enrollment?", "rationale": ["Identify the relevant tables: Courses and Student_Course_Enrolment are needed to find course names and their enrollments.", "Join the Courses table with the Student_Course_Enrolment table on the course_id to link courses with their enrollments.", "Group the results by course_id to aggregate the number of students enrolled in each course.", "Use the HAVING clause to filter the groups to only include those with exactly 1 student enrollment."], "pred_sql": "SELECT C.course_name\nFROM Courses C\nJOIN Student_Course_Enrolment SCE ON C.course_id = SCE.course_id\nGROUP BY C.course_id\nHAVING COUNT(SCE.student_id) = 1;", "gold_sql": "SELECT T1.course_name FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name HAVING COUNT(*)  =  1", "source_tables": ["courses", "student_course_enrolment"]}
{"sample_id": 3823, "db_id": "e_learning", "question": "Find the names of the courses that have just one student enrollment.", "rationale": ["Identify the relevant tables: Courses and Student_Course_Enrolment are needed to find course names and their enrollments.", "Join the Courses table with the Student_Course_Enrolment table on the course_id to link courses with their enrollments.", "Group the results by course_id to aggregate the number of students enrolled in each course.", "Use the HAVING clause to filter the groups to only those courses that have exactly one student enrolled."], "pred_sql": "SELECT C.course_name FROM Courses C JOIN Student_Course_Enrolment SCE ON C.course_id = SCE.course_id GROUP BY C.course_id HAVING COUNT(SCE.student_id) = 1;", "gold_sql": "SELECT T1.course_name FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name HAVING COUNT(*)  =  1", "source_tables": ["courses", "student_course_enrolment"]}
{"sample_id": 3824, "db_id": "e_learning", "question": "What are the descriptions and names of the courses that have student enrollment bigger than 2?", "rationale": ["Identify the relevant tables: Courses and Student_Course_Enrolment are needed to get course details and enrollment counts.", "Select the required fields: We need the course name and course description from the Courses table.", "Join the tables: Use an INNER JOIN to connect Courses with Student_Course_Enrolment on the course_id field.", "Group the results: Use GROUP BY on the course_id to aggregate the enrollment counts for each course.", "Filter the results: Use HAVING to filter groups where the count of student_id in Student_Course_Enrolment is greater than 2."], "pred_sql": "SELECT Courses.course_name, Courses.course_description \nFROM Courses \nJOIN Student_Course_Enrolment ON Courses.course_id = Student_Course_Enrolment.course_id \nGROUP BY Courses.course_id \nHAVING COUNT(Student_Course_Enrolment.student_id) > 2;", "gold_sql": "SELECT T1.course_description ,  T1.course_name FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name HAVING COUNT(*)  >  2", "source_tables": ["courses", "student_course_enrolment"]}
{"sample_id": 3825, "db_id": "e_learning", "question": "Return the descriptions and names of the courses that have more than two students enrolled in.", "rationale": ["Identify the relevant tables: Courses and Student_Course_Enrolment are needed to get course details and enrollment information.", "Select the course name and description from the Courses table.", "Join the Courses table with the Student_Course_Enrolment table on the course_id to link courses with their enrolled students.", "Group the results by course_id to aggregate the number of students enrolled in each course.", "Use the HAVING clause to filter the groups, keeping only those courses that have more than two students enrolled."], "pred_sql": "SELECT C.course_name, C.course_description \nFROM Courses C \nJOIN Student_Course_Enrolment SCE ON C.course_id = SCE.course_id \nGROUP BY C.course_id \nHAVING COUNT(SCE.student_id) > 2;", "gold_sql": "SELECT T1.course_description ,  T1.course_name FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name HAVING COUNT(*)  >  2", "source_tables": ["courses", "student_course_enrolment"]}
{"sample_id": 3826, "db_id": "e_learning", "question": "What is the name of each course and the corresponding number of student enrollment?", "rationale": ["Identify the relevant tables: Courses and Student_Course_Enrolment are needed to get course names and enrollment counts.", "Select the course name from the Courses table.", "Count the number of student enrollments from the Student_Course_Enrolment table, which links students to courses.", "Use a LEFT JOIN to ensure that courses with no enrollments are still included in the results.", "Group the results by course name to aggregate the enrollment counts for each course."], "pred_sql": "SELECT Courses.course_name, COUNT(Student_Course_Enrolment.student_id) AS number_of_enrollments \nFROM Courses \nLEFT JOIN Student_Course_Enrolment ON Courses.course_id = Student_Course_Enrolment.course_id \nGROUP BY Courses.course_name;", "gold_sql": "SELECT T1.course_name ,  COUNT(*) FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name", "source_tables": ["courses", "student_course_enrolment"]}
{"sample_id": 3827, "db_id": "e_learning", "question": "List the name and the number of enrolled student for each course.", "rationale": ["Identify the relevant tables: Courses and Student_Course_Enrolment are needed to get course names and the number of enrolled students.", "Select the course name from the Courses table and count the number of student IDs from the Student_Course_Enrolment table to get the number of enrolled students.", "Use a LEFT JOIN to ensure that courses with no enrolled students are still included in the results.", "Group the results by course name to aggregate the count of enrolled students for each course."], "pred_sql": "SELECT Courses.course_name, COUNT(Student_Course_Enrolment.student_id) AS number_of_enrolled_students\nFROM Courses\nLEFT JOIN Student_Course_Enrolment ON Courses.course_id = Student_Course_Enrolment.course_id\nGROUP BY Courses.course_name;", "gold_sql": "SELECT T1.course_name ,  COUNT(*) FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name", "source_tables": ["courses", "student_course_enrolment"]}
{"sample_id": 3828, "db_id": "e_learning", "question": "What are the enrollment dates of all the tests that have result \"Pass\"?", "rationale": ["Identify the relevant tables: We need to look at the Student_Course_Enrolment table for enrollment dates and the Student_Tests_Taken table for test results.", "Determine the relationship between the tables: The Student_Course_Enrolment table is linked to the Student_Tests_Taken table through the registration_id.", "Select the enrollment date: We want to retrieve the date_of_enrolment from the Student_Course_Enrolment table.", "Filter the results: We need to include only those records where the test_result in the Student_Tests_Taken table is 'Pass'.", "Construct the SQL query using JOIN to combine the two tables based on the registration_id and apply the WHERE clause for filtering."], "pred_sql": "SELECT S.date_of_enrolment \nFROM Student_Course_Enrolment SCE \nJOIN Student_Tests_Taken STT ON SCE.registration_id = STT.registration_id \nWHERE STT.test_result = 'Pass';", "gold_sql": "SELECT T1.date_of_enrolment FROM Student_Course_Enrolment AS T1 JOIN Student_Tests_Taken AS T2 ON T1.registration_id  =  T2.registration_id WHERE T2.test_result  =  'Pass'", "source_tables": ["student_tests_taken", "student_course_enrolment"]}
{"sample_id": 3829, "db_id": "e_learning", "question": "Find the enrollment date for all the tests that have \"Pass\" result.", "rationale": ["Identify the relevant tables: We need to find the enrollment date for tests with a 'Pass' result, which involves the Student_Tests_Taken and Student_Course_Enrolment tables.", "Determine the relationship between tables: The Student_Tests_Taken table has a foreign key relationship with the Student_Course_Enrolment table through the registration_id column.", "Select the required columns: We need the date_of_enrolment from the Student_Course_Enrolment table.", "Filter the results: We only want the records where the test_result in the Student_Tests_Taken table is 'Pass'.", "Construct the SQL query: Using a JOIN to connect the two tables and applying the WHERE clause to filter the results."], "pred_sql": "SELECT Student_Course_Enrolment.date_of_enrolment \nFROM Student_Tests_Taken \nJOIN Student_Course_Enrolment ON Student_Tests_Taken.registration_id = Student_Course_Enrolment.registration_id \nWHERE Student_Tests_Taken.test_result = 'Pass';", "gold_sql": "SELECT T1.date_of_enrolment FROM Student_Course_Enrolment AS T1 JOIN Student_Tests_Taken AS T2 ON T1.registration_id  =  T2.registration_id WHERE T2.test_result  =  'Pass'", "source_tables": ["student_tests_taken", "student_course_enrolment"]}
{"sample_id": 3830, "db_id": "e_learning", "question": "What are the completion dates of all the tests that have result \"Fail\"?", "rationale": ["Identify the relevant table: The query is asking for completion dates of tests, which are recorded in the 'Student_Tests_Taken' table.", "Determine the relevant column: The column that contains the test results is 'test_result', and we need to filter for those that are 'Fail'.", "Select the appropriate column: The query requests the completion dates of the tests, which corresponds to the 'date_test_taken' column in the 'Student_Tests_Taken' table.", "Construct the SQL query: Using the SELECT statement to retrieve 'date_test_taken' from 'Student_Tests_Taken' where 'test_result' is 'Fail'."], "pred_sql": "SELECT SCTT.date_test_taken FROM Student_Tests_Taken SCTT WHERE SCTT.test_result = 'Fail';", "gold_sql": "SELECT T1.date_of_completion FROM Student_Course_Enrolment AS T1 JOIN Student_Tests_Taken AS T2 ON T1.registration_id  =  T2.registration_id WHERE T2.test_result  =  'Fail'", "source_tables": ["student_tests_taken", "student_course_enrolment"]}
{"sample_id": 3831, "db_id": "e_learning", "question": "Return the completion date for all the tests that have \"Fail\" result.", "rationale": ["Identify the relevant tables: We need to look at the Student_Tests_Taken table for test results and the Student_Course_Enrolment table for completion dates.", "Determine the columns needed: We need the date when the test was taken (date_test_taken), the test result (test_result), and the completion date (date_of_completion).", "Establish the relationship between tables: The Student_Tests_Taken table is linked to the Student_Course_Enrolment table through the registration_id column.", "Filter the results: We only want the records where the test result is 'Fail'.", "Construct the SQL query using SELECT to retrieve the necessary columns, JOIN to connect the tables, and WHERE to filter the results."], "pred_sql": "SELECT SCTT.date_test_taken, SCTT.test_result, SCE.date_of_completion \nFROM Student_Tests_Taken SCTT \nJOIN Student_Course_Enrolment SCE ON SCTT.registration_id = SCE.registration_id \nWHERE SCTT.test_result = 'Fail';", "gold_sql": "SELECT T1.date_of_completion FROM Student_Course_Enrolment AS T1 JOIN Student_Tests_Taken AS T2 ON T1.registration_id  =  T2.registration_id WHERE T2.test_result  =  'Fail'", "source_tables": ["student_tests_taken", "student_course_enrolment"]}
{"sample_id": 3832, "db_id": "e_learning", "question": "List the dates of enrollment and completion of the student with personal name \"Karson\".", "rationale": ["Identify the relevant tables: We need to retrieve enrollment and completion dates, which are in the Student_Course_Enrolment table, and we need to filter by the student's personal name, which is in the Students table.", "Determine the necessary columns: We need the 'date_of_enrolment' and 'date_of_completion' from the Student_Course_Enrolment table.", "Establish the relationship between tables: We need to join the Student_Course_Enrolment table with the Students table on the 'student_id' column to filter by the student's personal name.", "Construct the SQL query: Use a SELECT statement to get the required columns, a JOIN to connect the two tables, and a WHERE clause to filter by the personal name 'Karson'."], "pred_sql": "SELECT date_of_enrolment, date_of_completion \nFROM Student_Course_Enrolment \nJOIN Students ON Student_Course_Enrolment.student_id = Students.student_id \nWHERE Students.personal_name = 'Karson';", "gold_sql": "SELECT T1.date_of_enrolment ,  T1.date_of_completion FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id WHERE T2.personal_name  =  'Karson'", "source_tables": ["student_course_enrolment", "students"]}
{"sample_id": 3833, "db_id": "e_learning", "question": "On what dates did the student whose personal name is \"Karson\" enroll in and complete the courses?", "rationale": ["Identify the relevant tables: We need to look at the 'Students' table to find the student named 'Karson' and the 'Student_Course_Enrolment' table to find the enrollment and completion dates.", "Determine the relationship between tables: The 'Student_Course_Enrolment' table has a foreign key 'student_id' that links to the 'Students' table's 'student_id'.", "Select the required fields: We need 'date_of_enrolment' and 'date_of_completion' from the 'Student_Course_Enrolment' table.", "Filter the results: We need to filter the results to only include the student whose personal name is 'Karson'.", "Construct the SQL query: Combine the SELECT statement with the JOIN and WHERE clause to form the complete SQL query."], "pred_sql": "SELECT date_of_enrolment, date_of_completion \nFROM Student_Course_Enrolment \nJOIN Students ON Student_Course_Enrolment.student_id = Students.student_id \nWHERE Students.personal_name = 'Karson';", "gold_sql": "SELECT T1.date_of_enrolment ,  T1.date_of_completion FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id WHERE T2.personal_name  =  'Karson'", "source_tables": ["student_course_enrolment", "students"]}
{"sample_id": 3834, "db_id": "e_learning", "question": "List the dates of enrollment and completion of the student with family name \"Zieme\" and personal name \"Bernie\".", "rationale": ["Identify the relevant tables: We need to retrieve enrollment and completion dates, which are in the Student_Course_Enrolment table, and we need to filter by student name, which is in the Students table.", "Determine the necessary columns: We need the 'date_of_enrolment' and 'date_of_completion' from the Student_Course_Enrolment table.", "Establish the relationship between tables: We need to join the Student_Course_Enrolment table with the Students table on the 'student_id' column to filter by the student's name.", "Construct the WHERE clause: We need to filter the results to only include the student with the family name 'Zieme' and personal name 'Bernie'.", "Combine all parts to form the SQL query: SELECT the required columns from the joined tables with the appropriate WHERE clause."], "pred_sql": "SELECT date_of_enrolment, date_of_completion \nFROM Student_Course_Enrolment \nJOIN Students ON Student_Course_Enrolment.student_id = Students.student_id \nWHERE Students.family_name = 'Zieme' AND Students.personal_name = 'Bernie';", "gold_sql": "SELECT T1.date_of_enrolment ,  T1.date_of_completion FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id WHERE T2.family_name  =  'Zieme' AND T2.personal_name  =  'Bernie'", "source_tables": ["student_course_enrolment", "students"]}
{"sample_id": 3835, "db_id": "e_learning", "question": "On what dates did the student with family name \"Zieme\" and personal name \"Bernie\" enroll in and complete the courses?", "rationale": ["Identify the relevant tables: We need to look at the Student_Course_Enrolment table for enrollment and completion dates, and the Students table to filter by the student's name.", "Determine the necessary columns: We need the 'date_of_enrolment' and 'date_of_completion' from the Student_Course_Enrolment table.", "Establish the relationship between tables: We will join the Student_Course_Enrolment table with the Students table on the 'student_id' column to filter the records for the specific student.", "Construct the WHERE clause: We will filter the results to include only the student with the family name 'Zieme' and personal name 'Bernie'.", "Combine all parts to form the SQL query: We will select the required columns from the joined tables with the specified conditions."], "pred_sql": "SELECT date_of_enrolment, date_of_completion \nFROM Student_Course_Enrolment \nJOIN Students ON Student_Course_Enrolment.student_id = Students.student_id \nWHERE Students.family_name = 'Zieme' AND Students.personal_name = 'Bernie';", "gold_sql": "SELECT T1.date_of_enrolment ,  T1.date_of_completion FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id WHERE T2.family_name  =  'Zieme' AND T2.personal_name  =  'Bernie'", "source_tables": ["student_course_enrolment", "students"]}
{"sample_id": 3836, "db_id": "e_learning", "question": "Find the student ID and login name of the student with the most course enrollments", "rationale": ["Identify the relevant tables: Students and Student_Course_Enrolment.", "We need to find the student with the most course enrollments, which means we need to count the number of enrollments for each student.", "Use the Student_Course_Enrolment table to group by student_id and count the number of course_id entries for each student.", "Order the results by the count of enrollments in descending order to get the student with the most enrollments at the top.", "Limit the results to 1 to get only the top student.", "Now, we need to select the student_id and login_name from the Students table where the student_id matches the one with the most enrollments."], "pred_sql": "SELECT student_id, login_name FROM Students WHERE student_id = (SELECT student_id FROM Student_Course_Enrolment GROUP BY student_id ORDER BY COUNT(course_id) DESC LIMIT 1)", "gold_sql": "SELECT T1.student_id ,  T2.login_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["student_course_enrolment", "students"]}
{"sample_id": 3837, "db_id": "e_learning", "question": "What are the student ID and login name of the student who are enrolled in the most courses?", "rationale": ["Identify the relevant tables: Students and Student_Course_Enrolment.", "We need to find the student who is enrolled in the most courses, which requires counting the number of courses each student is enrolled in.", "Use a subquery to count the number of courses for each student by grouping the Student_Course_Enrolment table by student_id and counting course_id.", "Order the results of the subquery by the count of courses in descending order and limit the result to 1 to get the student with the most enrollments.", "Select the student_id and login_name from the Students table where the student_id matches the one found in the subquery."], "pred_sql": "SELECT student_id, login_name FROM Students WHERE student_id IN (SELECT student_id FROM Student_Course_Enrolment GROUP BY student_id ORDER BY COUNT(course_id) DESC LIMIT 1)", "gold_sql": "SELECT T1.student_id ,  T2.login_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["student_course_enrolment", "students"]}
{"sample_id": 3838, "db_id": "e_learning", "question": "Find the student ID and personal name of the student with at least two enrollments.", "rationale": ["Identify the relevant tables: We need to retrieve information from the Students table for student ID and personal name, and we need to check enrollments from the Student_Course_Enrolment table.", "Join the Students table with the Student_Course_Enrolment table on the student_id to link students with their enrollments.", "Group the results by student_id and personal_name to aggregate the enrollments for each student.", "Use the HAVING clause to filter the groups to only include students who have at least two enrollments, which is determined by counting the registration_id in the Student_Course_Enrolment table."], "pred_sql": "SELECT s.student_id, s.personal_name \nFROM Students s \nJOIN Student_Course_Enrolment e ON s.student_id = e.student_id \nGROUP BY s.student_id, s.personal_name \nHAVING COUNT(e.registration_id) >= 2;", "gold_sql": "SELECT T1.student_id ,  T2.personal_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING COUNT(*)  >=  2", "source_tables": ["student_course_enrolment", "students"]}
{"sample_id": 3839, "db_id": "e_learning", "question": "Which student are enrolled in at least two courses? Give me the student ID and personal name.", "rationale": ["Identify the information needed: We need to find students enrolled in at least two courses, which requires us to look at the Students and Student_Course_Enrolment tables.", "Determine the relationship: The Student_Course_Enrolment table links students to their enrolled courses, so we will use this table to count the number of courses each student is enrolled in.", "Use GROUP BY: We will group the results by student_id to count the number of courses each student is enrolled in.", "Use HAVING clause: We will filter the grouped results to only include students who are enrolled in two or more courses using the HAVING clause with COUNT(course_id) >= 2.", "Select required fields: Finally, we will select the student_id and personal_name from the Students table for those students who meet the criteria."], "pred_sql": "SELECT student_id, personal_name FROM Students WHERE student_id IN (SELECT student_id FROM Student_Course_Enrolment GROUP BY student_id HAVING COUNT(course_id) >= 2);", "gold_sql": "SELECT T1.student_id ,  T2.personal_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING COUNT(*)  >=  2", "source_tables": ["student_course_enrolment", "students"]}
{"sample_id": 3840, "db_id": "e_learning", "question": "Find the student ID and middle name for all the students with at most two enrollments.", "rationale": ["Identify the relevant tables: Students and Student_Course_Enrolment.", "We need to retrieve the student ID and middle name, which are in the Students table.", "To find students with at most two enrollments, we need to join the Students table with the Student_Course_Enrolment table on the student_id.", "We will group the results by student_id to count the number of enrollments for each student.", "Using the HAVING clause, we can filter the groups to include only those with a count of enrollments less than or equal to 2."], "pred_sql": "SELECT s.student_id, s.middle_name \nFROM Students s \nJOIN Student_Course_Enrolment e ON s.student_id = e.student_id \nGROUP BY s.student_id \nHAVING COUNT(e.registration_id) <= 2;", "gold_sql": "SELECT T1.student_id ,  T2.middle_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING COUNT(*)  <=  2", "source_tables": ["student_course_enrolment", "students"]}
{"sample_id": 3841, "db_id": "e_learning", "question": "What are the student IDs and middle names of the students enrolled in at most two courses?", "rationale": ["Identify the relevant tables: Students and Student_Course_Enrolment are needed to get student information and their course enrollments.", "Join the Students table with the Student_Course_Enrolment table on the student_id to link students with their enrolled courses.", "Select the student_id and middle_name from the Students table.", "Group the results by student_id and middle_name to aggregate the course enrollments for each student.", "Use the HAVING clause to filter the groups to only include students who are enrolled in at most two courses."], "pred_sql": "SELECT s.student_id, s.middle_name\nFROM Students s\nJOIN Student_Course_Enrolment e ON s.student_id = e.student_id\nGROUP BY s.student_id, s.middle_name\nHAVING COUNT(e.course_id) <= 2;", "gold_sql": "SELECT T1.student_id ,  T2.middle_name FROM Student_Course_Enrolment AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING COUNT(*)  <=  2", "source_tables": ["student_course_enrolment", "students"]}
{"sample_id": 3842, "db_id": "e_learning", "question": "Find the personal names of students not enrolled in any course.", "rationale": ["Identify the table that contains student information, which is the 'Students' table.", "We need to find students who are not enrolled in any course, so we will check against the 'Student_Course_Enrolment' table.", "To find students not enrolled in any course, we can use a subquery that selects all student_ids from the 'Student_Course_Enrolment' table.", "We will use the NOT IN clause to filter out those students from the 'Students' table.", "Finally, we will select the 'personal_name' column from the 'Students' table for the students who are not enrolled in any course."], "pred_sql": "SELECT personal_name FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment)", "gold_sql": "SELECT personal_name FROM Students EXCEPT SELECT T1.personal_name FROM Students AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.student_id  =  T2.student_id", "source_tables": ["student_course_enrolment", "students"]}
{"sample_id": 3843, "db_id": "e_learning", "question": "Which students not enrolled in any course? Find their personal names.", "rationale": ["Identify the Students table to retrieve personal names.", "We need to find students who are not enrolled in any course, which means we need to check against the Student_Course_Enrolment table.", "Use a subquery to select student_ids from the Student_Course_Enrolment table.", "Use the NOT IN clause to filter out students who are present in the Student_Course_Enrolment table from the Students table.", "Select the personal_name, middle_name, and family_name from the Students table for those students who are not enrolled in any course."], "pred_sql": "SELECT personal_name, middle_name, family_name FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment)", "gold_sql": "SELECT personal_name FROM Students EXCEPT SELECT T1.personal_name FROM Students AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.student_id  =  T2.student_id", "source_tables": ["student_course_enrolment", "students"]}
{"sample_id": 3844, "db_id": "e_learning", "question": "How many students did not have any course enrollment?", "rationale": ["Identify the Students table to get the total number of students.", "Use a subquery to find all student_ids that are present in the Student_Course_Enrolment table, which indicates course enrollment.", "Use the NOT IN clause to filter out students who are enrolled in any course from the total list of students.", "Count the remaining students who do not have any course enrollment."], "pred_sql": "SELECT COUNT(*) AS students_without_enrollment FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment);", "gold_sql": "SELECT count(*) FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment)", "source_tables": ["student_course_enrolment", "students"]}
{"sample_id": 3845, "db_id": "e_learning", "question": "Count the number of students who did not enroll in any course.", "rationale": ["Identify the main goal: Count the number of students who did not enroll in any course.", "To find students who did not enroll, we need to look at the Students table and compare it with the Student_Course_Enrolment table.", "We will use a subquery to find all student_ids that are present in the Student_Course_Enrolment table, which indicates they have enrolled in at least one course.", "The main query will count all students whose student_id is not in the list of enrolled students from the subquery."], "pred_sql": "SELECT COUNT(*) AS number_of_students_without_enrollment\nFROM Students\nWHERE student_id NOT IN (\n    SELECT student_id\n    FROM Student_Course_Enrolment\n);", "gold_sql": "SELECT count(*) FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment)", "source_tables": ["student_course_enrolment", "students"]}
{"sample_id": 3846, "db_id": "e_learning", "question": "Find the common login name of course authors and students.", "rationale": ["Identify the tables that contain the 'login_name' column, which are 'Course_Authors_and_Tutors' and 'Students'.", "Use the INTERSECT operator to find common values in the 'login_name' column from both tables.", "Construct the SQL query to select 'login_name' from 'Course_Authors_and_Tutors' and intersect it with 'login_name' from 'Students'."], "pred_sql": "SELECT login_name FROM Course_Authors_and_Tutors INTERSECT SELECT login_name FROM Students;", "gold_sql": "SELECT login_name FROM Course_Authors_and_Tutors INTERSECT SELECT login_name FROM Students", "source_tables": ["students", "course_authors_and_tutors"]}
{"sample_id": 3847, "db_id": "e_learning", "question": "What are the login names used both by some course authors and some students?", "rationale": ["Identify the relevant tables: Course_Authors_and_Tutors and Students, as we need to find common login names between these two groups.", "Determine the common field: The 'login_name' field is present in both tables and will be used to find matches.", "Use a JOIN operation to combine the two tables based on the 'login_name' field, ensuring we only get records where the login names are the same in both tables.", "Select distinct login names to avoid duplicates in the result set."], "pred_sql": "SELECT DISTINCT ca.login_name\nFROM Course_Authors_and_Tutors ca\nJOIN Students s ON ca.login_name = s.login_name;", "gold_sql": "SELECT login_name FROM Course_Authors_and_Tutors INTERSECT SELECT login_name FROM Students", "source_tables": ["students", "course_authors_and_tutors"]}
{"sample_id": 3848, "db_id": "e_learning", "question": "Find the common personal name of course authors and students.", "rationale": ["Identify the tables involved: Course_Authors_and_Tutors and Students.", "Determine the common field to compare: personal_name.", "Use a JOIN operation to find matching personal names between the two tables.", "Select distinct personal names to avoid duplicates in the result."], "pred_sql": "SELECT DISTINCT ca.personal_name\nFROM Course_Authors_and_Tutors ca\nJOIN Students s ON ca.personal_name = s.personal_name;", "gold_sql": "SELECT personal_name FROM Course_Authors_and_Tutors INTERSECT SELECT personal_name FROM Students", "source_tables": ["students", "course_authors_and_tutors"]}
{"sample_id": 3849, "db_id": "e_learning", "question": "What are the personal names used both by some course authors and some students?", "rationale": ["Identify the relevant tables: Course_Authors_and_Tutors and Students, as we need to find personal names from both.", "We need to select the personal_name column from both tables.", "To find names that are used by both course authors and students, we will perform an inner join on the personal_name column of both tables.", "Using DISTINCT ensures that we only get unique personal names that appear in both tables."], "pred_sql": "SELECT DISTINCT ca.personal_name \nFROM Course_Authors_and_Tutors ca \nJOIN Students s ON ca.personal_name = s.personal_name;", "gold_sql": "SELECT personal_name FROM Course_Authors_and_Tutors INTERSECT SELECT personal_name FROM Students", "source_tables": ["students", "course_authors_and_tutors"]}
{"sample_id": 3850, "db_id": "insurance_policies", "question": "Which claims caused more than 2 settlements or have the maximum claim value? List the date the claim was made and the claim id.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find claims that either have more than 2 settlements or have the maximum claim value.", "Join the Claims table with the Settlements table on Claim_ID to relate claims to their settlements.", "Group the results by Claim_ID to count the number of settlements for each claim.", "Use the HAVING clause to filter groups: keep those with more than 2 settlements or those with the maximum claim value.", "Select the required fields: Date_Claim_Made and Claim_ID."], "pred_sql": "SELECT Claims.Date_Claim_Made, Claims.Claim_ID\nFROM Claims\nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID\nGROUP BY Claims.Claim_ID\nHAVING COUNT(Settlements.Settlement_ID) > 2 OR Claims.Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claims);", "gold_sql": "SELECT T1.Date_Claim_Made ,  T1.Claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.Claim_id HAVING count(*)  >  2 UNION SELECT T1.Date_Claim_Made ,  T1.Claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id WHERE T1.Amount_Claimed  =  ( SELECT max(Amount_Claimed) FROM Claims )", "source_tables": ["claims", "settlements"]}
{"sample_id": 3851, "db_id": "insurance_policies", "question": "Find the claims that led to more than two settlements or have the maximum claim value. For each of them, return the date the claim was made and the id of the claim.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find claims that have more than two settlements or have the maximum claim value.", "Join the Claims table with the Settlements table on Claim_ID to access settlement information related to each claim.", "Group the results by Claim_ID to count the number of settlements for each claim.", "Use the HAVING clause to filter claims that either have more than two settlements or have the maximum claim value.", "Select the required fields: Date_Claim_Made and Claim_ID from the Claims table."], "pred_sql": "SELECT Claims.Date_Claim_Made, Claims.Claim_ID\nFROM Claims\nLEFT JOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID\nGROUP BY Claims.Claim_ID\nHAVING COUNT(Settlements.Settlement_ID) > 2 OR Claims.Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claims);", "gold_sql": "SELECT T1.Date_Claim_Made ,  T1.Claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.Claim_id HAVING count(*)  >  2 UNION SELECT T1.Date_Claim_Made ,  T1.Claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id WHERE T1.Amount_Claimed  =  ( SELECT max(Amount_Claimed) FROM Claims )", "source_tables": ["claims", "settlements"]}
{"sample_id": 3852, "db_id": "insurance_policies", "question": "Which customer had at least 2 policies but did not file any claims? List the customer details and id.", "rationale": ["We need to find customers who have at least 2 policies and did not file any claims.", "To do this, we will join the Customers table with the Customer_Policies table on Customer_ID to get the policies for each customer.", "Next, we will perform a LEFT JOIN with the Claims table on Policy_ID to include customers who have no claims.", "We will group the results by Customer_ID to aggregate the number of policies and claims for each customer.", "In the HAVING clause, we will filter for customers who have 2 or more policies (COUNT(cp.Policy_ID) >= 2) and no claims (COUNT(cl.Claim_ID) = 0).", "Finally, we will select the Customer_ID and Customer_Details to display the required information."], "pred_sql": "SELECT c.Customer_ID, c.Customer_Details \nFROM Customers c \nJOIN Customer_Policies cp ON c.Customer_ID = cp.Customer_ID \nLEFT JOIN Claims cl ON cp.Policy_ID = cl.Policy_ID \nGROUP BY c.Customer_ID \nHAVING COUNT(cp.Policy_ID) >= 2 AND COUNT(cl.Claim_ID) = 0;", "gold_sql": "SELECT T1.customer_details ,  T1.customer_id FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.Customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  2 EXCEPT SELECT T1.customer_details ,  T1.customer_id FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.Customer_id  =  T2.customer_id JOIN Claims AS T3 ON T2.policy_id  =  T3.policy_id", "source_tables": ["claims", "customer_policies", "customers"]}
{"sample_id": 3853, "db_id": "insurance_policies", "question": "Give me the the customer details and id for the customers who had two or more policies but did not file any claims.", "rationale": ["We need to select customer details and IDs from the Customers table.", "We will join the Customers table with the Customer_Policies table to get the policies associated with each customer.", "We will use a LEFT JOIN with the Claims table to include customers who have not filed any claims.", "We will group the results by Customer_ID to aggregate the number of policies and claims for each customer.", "We will use the HAVING clause to filter customers who have two or more policies (COUNT(cp.Policy_ID) >= 2) and no claims (COUNT(cl.Claim_ID) = 0)."], "pred_sql": "SELECT c.Customer_ID, c.Customer_Details \nFROM Customers c \nJOIN Customer_Policies cp ON c.Customer_ID = cp.Customer_ID \nLEFT JOIN Claims cl ON cp.Policy_ID = cl.Policy_ID \nGROUP BY c.Customer_ID \nHAVING COUNT(cp.Policy_ID) >= 2 AND COUNT(cl.Claim_ID) = 0;", "gold_sql": "SELECT T1.customer_details ,  T1.customer_id FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.Customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  2 EXCEPT SELECT T1.customer_details ,  T1.customer_id FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.Customer_id  =  T2.customer_id JOIN Claims AS T3 ON T2.policy_id  =  T3.policy_id", "source_tables": ["claims", "customer_policies", "customers"]}
{"sample_id": 3854, "db_id": "insurance_policies", "question": "List the method, date and amount of all the payments, in ascending order of date.", "rationale": ["Identify the relevant table: Payments, as it contains the payment information.", "Select the required columns: Payment_Method_Code, Date_Payment_Made, and Amount_Payment.", "Specify the order of results: Use ORDER BY to sort the results by Date_Payment_Made in ascending order."], "pred_sql": "SELECT Payment_Method_Code, Date_Payment_Made, Amount_Payment FROM Payments ORDER BY Date_Payment_Made ASC;", "gold_sql": "SELECT Payment_Method_Code ,  Date_Payment_Made ,  Amount_Payment FROM Payments ORDER BY Date_Payment_Made ASC", "source_tables": ["payments"]}
{"sample_id": 3855, "db_id": "insurance_policies", "question": "What are the method, date and amount of each payment? Sort the list in ascending order of date.", "rationale": ["Identify the relevant table: The Payments table contains the information about payment transactions.", "Select the required columns: We need to retrieve Payment_Method_Code, Date_Payment_Made, and Amount_Payment.", "Sort the results: The results should be sorted in ascending order based on the Date_Payment_Made column.", "Construct the SQL query: Combine the SELECT statement with the ORDER BY clause to form the complete SQL query."], "pred_sql": "SELECT Payment_Method_Code, Date_Payment_Made, Amount_Payment FROM Payments ORDER BY Date_Payment_Made ASC;", "gold_sql": "SELECT Payment_Method_Code ,  Date_Payment_Made ,  Amount_Payment FROM Payments ORDER BY Date_Payment_Made ASC", "source_tables": ["payments"]}
{"sample_id": 3856, "db_id": "insurance_policies", "question": "Among all the claims, what is the settlement amount of the claim with the largest claim amount? List both the settlement amount and claim amount.", "rationale": ["Identify the relevant tables: Claims and Settlements, since we need information about claims and their corresponding settlements.", "We need to find the claim with the largest claim amount, which requires us to use the MAX function on the Amount_Claimed column in the Claims table.", "To get the settlement amount corresponding to this claim, we will join the Claims table with the Settlements table on the Claim_ID.", "The final query will select the Amount_Settled from the Settlements table and the Amount_Claimed from the Claims table, filtering for the claim with the maximum Amount_Claimed."], "pred_sql": "SELECT s.Amount_Settled, c.Amount_Claimed \nFROM Claims c \nJOIN Settlements s ON c.Claim_ID = s.Claim_ID \nWHERE c.Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claims);", "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"]}
{"sample_id": 3857, "db_id": "insurance_policies", "question": "Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.", "rationale": ["Identify the relevant tables: Claims and Settlements, since we need information about claims and their corresponding settlements.", "We need to find the claim with the largest claim amount, which requires using the MAX function on the Amount_Claimed column in the Claims table.", "To get the settlement amount corresponding to this claim, we will join the Claims table with the Settlements table on the Claim_ID.", "The final query will select the Amount_Settled from the Settlements table and the Amount_Claimed from the Claims table, filtering for the claim with the maximum Amount_Claimed."], "pred_sql": "SELECT s.Amount_Settled, c.Amount_Claimed \nFROM Claims c \nJOIN Settlements s ON c.Claim_ID = s.Claim_ID \nWHERE c.Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claims);", "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"]}
{"sample_id": 3858, "db_id": "insurance_policies", "question": "Among all the claims, what is the amount claimed in the claim with the least amount settled? List both the settlement amount and claim amount.", "rationale": ["Identify the relevant tables: Claims and Settlements, since we need information about claims and their corresponding settlements.", "We need to find the claim with the least amount settled, so we will use a subquery to get the minimum Amount_Settled from the Settlements table.", "Join the Claims table with the Settlements table on Claim_ID to access both the Amount_Claimed from Claims and Amount_Settled from Settlements.", "Select the Amount_Claimed from Claims and Amount_Settled from Settlements where the Amount_Settled matches the minimum amount found in the subquery."], "pred_sql": "SELECT Claims.Amount_Claimed, Settlements.Amount_Settled \nFROM Claims \nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID \nWHERE Settlements.Amount_Settled = (SELECT MIN(Amount_Settled) FROM Settlements)", "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT 1", "source_tables": ["claims"]}
{"sample_id": 3859, "db_id": "insurance_policies", "question": "Find the claimed amount in the claim with the least amount settled. Show both the settlement amount and claim amount.", "rationale": ["Identify the relevant tables: Claims and Settlements, as we need information about claimed amounts and settled amounts.", "We need to join the Claims table with the Settlements table on the Claim_ID to access both the claimed and settled amounts.", "We need to find the settlement with the least amount settled, which requires a subquery to get the minimum settled amount from the Settlements table.", "The final query selects the Amount_Claimed from Claims and Amount_Settled from Settlements where the Amount_Settled matches the minimum settled amount found in the subquery."], "pred_sql": "SELECT Claims.Amount_Claimed, Settlements.Amount_Settled \nFROM Claims \nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID \nWHERE Settlements.Amount_Settled = \n    (SELECT MIN(Amount_Settled) \n     FROM Settlements)", "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT 1", "source_tables": ["claims"]}
{"sample_id": 3860, "db_id": "insurance_policies", "question": "Among all the claims, which claims have a claimed amount larger than the average? List the date the claim was made and the date it was settled.", "rationale": ["Identify the relevant table: Claims, as we need information about claims.", "Determine the columns needed: Date_Claim_Made and Date_Claim_Settled for the output.", "Calculate the average claimed amount: Use a subquery to calculate the average of Amount_Claimed from the Claims table.", "Filter the claims: Use a WHERE clause to select claims where Amount_Claimed is greater than the calculated average.", "Combine the above steps into a single SQL query."], "pred_sql": "SELECT Date_Claim_Made, Date_Claim_Settled FROM Claims WHERE Amount_Claimed > (SELECT AVG(Amount_Claimed) FROM Claims)", "gold_sql": "SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )", "source_tables": ["claims"]}
{"sample_id": 3861, "db_id": "insurance_policies", "question": "Give me the claim date, settlement date for all the claims whose claimed amount is larger than the average.", "rationale": ["Identify the required fields: claim date and settlement date.", "Determine the tables involved: Claims and Settlements.", "Establish the relationship between Claims and Settlements using the Claim_ID foreign key.", "Calculate the average claimed amount from the Settlements table using a subquery.", "Filter the results to include only those claims where the claimed amount is greater than the average."], "pred_sql": "SELECT Claims.Date_Claim_Made, Settlements.Date_Claim_Settled \nFROM Claims \nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID \nWHERE Settlements.Amount_Claimed > (SELECT AVG(Amount_Claimed) FROM Settlements);", "gold_sql": "SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )", "source_tables": ["claims"]}
{"sample_id": 3862, "db_id": "insurance_policies", "question": "Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.", "rationale": ["Identify the relevant tables: Settlements and Claims.", "We need to find settlements where the claimed amount is no more than the average claimed amount.", "To do this, we will calculate the average claimed amount from the Settlements table using a subquery.", "We will join the Settlements table with the Claims table to access the claim start date.", "Select the Date_Claim_Made from the Claims table and Amount_Claimed from the Settlements table where the claimed amount is less than or equal to the average."], "pred_sql": "SELECT s.Date_Claim_Made, s.Amount_Claimed \nFROM Settlements s \nJOIN Claims c ON s.Claim_ID = c.Claim_ID \nWHERE s.Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Settlements)", "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"]}
{"sample_id": 3863, "db_id": "insurance_policies", "question": "Return the claim start date for the claims whose claimed amount is no more than the average", "rationale": ["Identify the relevant table: Claims, since we need information about claims.", "Determine the specific column needed: Date_Claim_Made, which represents the start date of the claims.", "Calculate the average claimed amount: Use a subquery to calculate the average of Amount_Claimed from the Claims table.", "Filter the claims: Use a WHERE clause to select claims where Amount_Claimed is less than or equal to the average claimed amount."], "pred_sql": "SELECT Claims.Date_Claim_Made FROM Claims WHERE Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims);", "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"]}
{"sample_id": 3864, "db_id": "insurance_policies", "question": "How many settlements does each claim correspond to? List the claim id and the number of settlements.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to count the number of settlements for each claim, so we will use a LEFT JOIN to connect Claims with Settlements based on the Claim_ID.", "Use COUNT(Settlements.Settlement_ID) to count the number of settlements for each claim.", "Group the results by Claims.Claim_ID to get the count for each individual claim."], "pred_sql": "SELECT Claims.Claim_ID, COUNT(Settlements.Settlement_ID) AS Number_of_Settlements\nFROM Claims\nLEFT JOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID\nGROUP BY Claims.Claim_ID;", "gold_sql": "SELECT T1.Claim_id ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id", "source_tables": ["claims", "settlements"]}
{"sample_id": 3865, "db_id": "insurance_policies", "question": "Find the number of settlements each claim corresponds to. Show the number together with the claim id.", "rationale": ["Identify the relevant table: The Settlements table contains the information about settlements and their corresponding claims.", "Determine the required output: We need to find the number of settlements for each claim, which means we need to count the Settlement_IDs grouped by Claim_ID.", "Construct the SQL query: Use the SELECT statement to choose Claim_ID and the count of Settlement_ID, and use GROUP BY to aggregate the results by Claim_ID."], "pred_sql": "SELECT Claim_ID, COUNT(Settlement_ID) AS Number_of_Settlements\nFROM Settlements\nGROUP BY Claim_ID;", "gold_sql": "SELECT T1.Claim_id ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id", "source_tables": ["claims", "settlements"]}
{"sample_id": 3866, "db_id": "insurance_policies", "question": "Which claim incurred the most number of settlements? List the claim id, the date the claim was made, and the number.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to count the number of settlements for each claim, so we will join the Claims table with the Settlements table on the Claim_ID.", "Select the Claim_ID and Date_Claim_Made from the Claims table, and count the Settlement_ID from the Settlements table to get the number of settlements.", "Group the results by Claim_ID and Date_Claim_Made to aggregate the count of settlements for each claim.", "Order the results by the count of settlements in descending order to find the claim with the most settlements.", "Limit the results to 1 to get only the claim with the highest number of settlements."], "pred_sql": "SELECT Claims.Claim_ID, Claims.Date_Claim_Made, COUNT(Settlements.Settlement_ID) AS Number_Of_Settlements\nFROM Claims\nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID\nGROUP BY Claims.Claim_ID, Claims.Date_Claim_Made\nORDER BY Number_Of_Settlements DESC\nLIMIT 1;", "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims", "settlements"]}
{"sample_id": 3867, "db_id": "insurance_policies", "question": "Find the claim id and claim date of the claim that incurred the most settlement count. Also tell me the count.", "rationale": ["Identify the relevant tables: Claims and Settlements, since we need to find claims and their associated settlements.", "Join the Claims table with the Settlements table on the Claim_ID to link claims with their settlements.", "Group the results by Claim_ID and Date_Claim_Made to count the number of settlements for each claim.", "Use COUNT(Settlements.Settlement_ID) to count the number of settlements associated with each claim.", "Order the results by the count of settlements in descending order to get the claim with the most settlements at the top.", "Limit the results to 1 to get only the claim with the highest settlement count."], "pred_sql": "SELECT Claims.Claim_ID, Claims.Date_Claim_Made, COUNT(Settlements.Settlement_ID) AS Settlement_Count\nFROM Claims\nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID\nGROUP BY Claims.Claim_ID, Claims.Date_Claim_Made\nORDER BY Settlement_Count DESC\nLIMIT 1;", "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims", "settlements"]}
{"sample_id": 3868, "db_id": "insurance_policies", "question": "How many settlements were made on the claim with the most recent claim settlement date? List the number and the claim id.", "rationale": ["Identify the table that contains the information about settlements, which is the 'Settlements' table.", "Determine that we need to count the number of settlements, so we will use the COUNT() function.", "We need to find the claim with the most recent settlement date, which requires us to look at the 'Claims' table and order by 'Date_Claim_Settled' in descending order.", "We will use a subquery to get the Claim_ID of the most recent claim settlement.", "Finally, we will filter the 'Settlements' table using the Claim_ID obtained from the subquery and count the number of settlements for that claim."], "pred_sql": "SELECT COUNT(*) AS Settlement_Count, Claim_ID FROM Settlements WHERE Claim_ID = (SELECT Claim_ID FROM Claims ORDER BY Date_Claim_Settled DESC LIMIT 1)", "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"]}
{"sample_id": 3869, "db_id": "insurance_policies", "question": "Find the claim id and the number of settlements made for the claim with the most recent settlement date.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find the claim ID and the number of settlements, so we will select Claims.Claim_ID and count the number of settlements from the Settlements table.", "To find the claim with the most recent settlement date, we will use a subquery to get the maximum Date_Claim_Settled from the Settlements table.", "We will join the Claims and Settlements tables on Claim_ID to link claims to their settlements.", "We will group the results by Claims.Claim_ID to count the number of settlements for each claim."], "pred_sql": "SELECT Claims.Claim_ID, COUNT(Settlements.Settlement_ID) AS Number_of_Settlements\nFROM Claims\nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID\nWHERE Settlements.Date_Claim_Settled = (\n    SELECT MAX(Date_Claim_Settled)\n    FROM Settlements\n)\nGROUP BY Claims.Claim_ID;", "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"]}
{"sample_id": 3870, "db_id": "insurance_policies", "question": "Of all the claims, what was the earliest date when any claim was made?", "rationale": ["Identify the relevant table: The query is about claims, so we will use the Claims table.", "Determine the required information: We need the earliest date when any claim was made.", "Use the MIN function: To find the earliest date, we will use the MIN() function on the Date_Claim_Made column.", "Construct the SQL query: We will select the minimum date from the Date_Claim_Made column in the Claims table."], "pred_sql": "SELECT MIN(Date_Claim_Made) AS Earliest_Claim_Date FROM Claims;", "gold_sql": "SELECT Date_Claim_Made FROM Claims ORDER BY Date_Claim_Made ASC LIMIT 1", "source_tables": ["claims"]}
{"sample_id": 3871, "db_id": "insurance_policies", "question": "Tell me the the date when the first claim was made.", "rationale": ["Identify the relevant table: The query is asking about claims, so we will focus on the 'Claims' table.", "Determine the required information: We need the date when the first claim was made, which suggests we need to find the minimum date in the 'Date_Claim_Made' column.", "Construct the SQL query: We will use the MIN() function to get the earliest date from the 'Date_Claim_Made' column in the 'Claims' table."], "pred_sql": "SELECT MIN(Date_Claim_Made) AS First_Claim_Date FROM Claims;", "gold_sql": "SELECT Date_Claim_Made FROM Claims ORDER BY Date_Claim_Made ASC LIMIT 1", "source_tables": ["claims"]}
{"sample_id": 3872, "db_id": "insurance_policies", "question": "What is the total amount of settlement made for all the settlements?", "rationale": ["Identify the table that contains the relevant data: the Settlements table holds information about settlements.", "Determine the specific column that contains the amount settled: the Amount_Settled column is used to track the total amount approved and paid in each settlement.", "To find the total amount of settlements, use the SUM function to aggregate the Amount_Settled values.", "Construct the SQL query to select the sum of Amount_Settled from the Settlements table."], "pred_sql": "SELECT SUM(Amount_Settled) AS Total_Amount_Settled FROM Settlements;", "gold_sql": "SELECT sum(Amount_Settled) FROM Settlements", "source_tables": ["settlements"]}
{"sample_id": 3873, "db_id": "insurance_policies", "question": "Compute the total amount of settlement across all the settlements.", "rationale": ["Identify the table that contains the relevant data for settlements, which is the 'Settlements' table.", "Determine the column that holds the amount settled, which is 'Amount_Settled'.", "Use the SUM() function to calculate the total of the 'Amount_Settled' column across all records in the 'Settlements' table.", "Construct the SQL query to select the sum of 'Amount_Settled' and give it an alias 'Total_Amount_Settled'."], "pred_sql": "SELECT SUM(Amount_Settled) AS Total_Amount_Settled FROM Settlements;", "gold_sql": "SELECT sum(Amount_Settled) FROM Settlements", "source_tables": ["settlements"]}
{"sample_id": 3874, "db_id": "insurance_policies", "question": "Who are the customers that had more than 1 policy? List the customer details and id.", "rationale": ["Identify the tables needed: Customers and Customer_Policies.", "We need to join these two tables on the Customer_ID to link customers with their policies.", "We want to group the results by Customer_ID to count the number of policies each customer has.", "Use the HAVING clause to filter the groups to only include those with more than 1 policy.", "Select the Customer_ID and Customer_Details from the Customers table."], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Customers \nJOIN Customer_Policies ON Customers.Customer_ID = Customer_Policies.Customer_ID \nGROUP BY Customers.Customer_ID \nHAVING COUNT(Customer_Policies.Policy_ID) > 1;", "gold_sql": "SELECT T1.customer_details ,  T1.customer_id FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.Customer_id  =  T2.Customer_id GROUP BY T1.customer_id HAVING count(*)  >  1", "source_tables": ["customer_policies", "customers"]}
{"sample_id": 3875, "db_id": "insurance_policies", "question": "Find the the customer details and id for the customers who had more than one policy.", "rationale": ["Identify the relevant tables: Customers and Customer_Policies.", "We need to retrieve customer details and IDs, so we will select 'Customer_ID' and 'Customer_Details' from the Customers table.", "To find customers with more than one policy, we need to join the Customers table with the Customer_Policies table on 'Customer_ID'.", "We will group the results by 'Customer_ID' to count the number of policies each customer has.", "Using the HAVING clause, we will filter the groups to include only those customers who have more than one policy (COUNT > 1)."], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Customers \nJOIN Customer_Policies ON Customers.Customer_ID = Customer_Policies.Customer_ID \nGROUP BY Customers.Customer_ID \nHAVING COUNT(Customer_Policies.Policy_ID) > 1;", "gold_sql": "SELECT T1.customer_details ,  T1.customer_id FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.Customer_id  =  T2.Customer_id GROUP BY T1.customer_id HAVING count(*)  >  1", "source_tables": ["customer_policies", "customers"]}
{"sample_id": 3876, "db_id": "insurance_policies", "question": "What are the claim dates and settlement dates of all the settlements?", "rationale": ["Identify the relevant table: The query asks for claim dates and settlement dates, which are found in the Settlements table.", "Select the appropriate columns: The columns needed are Date_Claim_Made and Date_Claim_Settled from the Settlements table.", "Construct the SQL query: Use a SELECT statement to retrieve the specified columns from the Settlements table."], "pred_sql": "SELECT s.Date_Claim_Made, s.Date_Claim_Settled FROM Settlements s;", "gold_sql": "SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Settlements", "source_tables": ["settlements"]}
{"sample_id": 3877, "db_id": "insurance_policies", "question": "Tell me the the claim date and settlement date for each settlement case.", "rationale": ["Identify the relevant table: The query is asking for information related to settlements, so we will focus on the 'Settlements' table.", "Determine the required columns: The user wants to know the claim date and settlement date for each settlement case, which corresponds to 'Date_Claim_Made' and 'Date_Claim_Settled' in the 'Settlements' table.", "Construct the SQL SELECT statement: We will select the two columns from the 'Settlements' table."], "pred_sql": "SELECT Settlements.Date_Claim_Made, Settlements.Date_Claim_Settled FROM Settlements;", "gold_sql": "SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Settlements", "source_tables": ["settlements"]}
{"sample_id": 3878, "db_id": "insurance_policies", "question": "What is the most popular payment method?", "rationale": ["Identify the relevant table: The Payments table contains information about payment transactions, including the payment method.", "Determine the required information: We need to find the most popular payment method, which implies counting the occurrences of each payment method.", "Group the results: Use GROUP BY to aggregate the counts of each payment method.", "Count the occurrences: Use COUNT(*) to count how many times each payment method appears in the Payments table.", "Order the results: Use ORDER BY to sort the payment methods by their count in descending order, so the most popular method appears first.", "Limit the results: Use LIMIT 1 to get only the top result, which is the most popular payment method."], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Method_Count FROM Payments GROUP BY Payment_Method_Code ORDER BY Method_Count DESC LIMIT 1;", "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"]}
{"sample_id": 3879, "db_id": "insurance_policies", "question": "Which payment method is used the most often?", "rationale": ["Identify the relevant table: The Payments table contains information about payment transactions, including the payment method used.", "Determine the required information: We need to count how many times each payment method is used.", "Group the results: Use GROUP BY to aggregate the counts of each payment method.", "Sort the results: Use ORDER BY to sort the counts in descending order to find the most used payment method.", "Limit the results: Use LIMIT 1 to get only the top result, which is the most frequently used payment method."], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Method_Usage\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Method_Usage DESC\nLIMIT 1;", "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"]}
{"sample_id": 3880, "db_id": "insurance_policies", "question": "With which kind of payment method were the least number of payments processed?", "rationale": ["Identify the relevant table: The Payments table contains information about payment transactions, including the payment method.", "Determine the required information: We need to find the payment method with the least number of payments processed.", "Group the results: Use GROUP BY to aggregate the payment counts by Payment_Method_Code.", "Count the payments: Use COUNT(*) to count the number of payments for each payment method.", "Order the results: Use ORDER BY to sort the payment counts in ascending order to find the least used payment method.", "Limit the results: Use LIMIT 1 to return only the payment method with the least number of payments."], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Payment_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Payment_Count ASC\nLIMIT 1;", "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"]}
{"sample_id": 3881, "db_id": "insurance_policies", "question": "What is the payment method that were used the least often?", "rationale": ["Identify the relevant table: The Payments table contains information about payment transactions, including the payment method used.", "Determine the required information: We need to find the payment method that was used the least often, which involves counting the occurrences of each payment method.", "Group the results: Use GROUP BY to aggregate the data by Payment_Method_Code to count how many times each method was used.", "Order the results: Use ORDER BY to sort the counts in ascending order so that the least used payment method appears first.", "Limit the results: Use LIMIT 1 to get only the payment method that was used the least often."], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Payment_Count \nFROM Payments \nGROUP BY Payment_Method_Code \nORDER BY Payment_Count ASC \nLIMIT 1;", "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"]}
{"sample_id": 3882, "db_id": "insurance_policies", "question": "What is the total amount of payment?", "rationale": ["Identify the table that contains payment information, which is the Payments table.", "Determine the column that holds the payment amounts, which is Amount_Payment.", "Use the SUM() function to calculate the total of the Amount_Payment column.", "Construct the SQL query to select the sum of Amount_Payment from the Payments table."], "pred_sql": "SELECT SUM(Amount_Payment) AS Total_Amount_Payment FROM Payments;", "gold_sql": "SELECT sum(Amount_Payment) FROM Payments", "source_tables": ["payments"]}
{"sample_id": 3883, "db_id": "insurance_policies", "question": "Compute the total amount of payment processed.", "rationale": ["Identify the table that contains payment information, which is the Payments table.", "Determine the column that holds the payment amounts, which is Amount_Payment.", "Use the SUM() function to calculate the total of the Amount_Payment column.", "Construct the SQL query to select the sum of Amount_Payment from the Payments table."], "pred_sql": "SELECT SUM(Amount_Payment) AS Total_Amount_Paid FROM Payments;", "gold_sql": "SELECT sum(Amount_Payment) FROM Payments", "source_tables": ["payments"]}
{"sample_id": 3884, "db_id": "insurance_policies", "question": "What are all the distinct details of the customers?", "rationale": ["The user wants to retrieve distinct details of customers.", "To achieve this, we will use the SELECT statement to specify the column we want to retrieve, which is 'Customer_Details'.", "We will use the DISTINCT keyword to ensure that we only get unique values from the 'Customer_Details' column.", "The data is being retrieved from the 'Customers' table, so we will specify this table in the FROM clause."], "pred_sql": "SELECT DISTINCT Customer_Details FROM Customers;", "gold_sql": "SELECT DISTINCT customer_details FROM Customers", "source_tables": ["customers"]}
{"sample_id": 3885, "db_id": "insurance_policies", "question": "Return the distinct customer details.", "rationale": ["Identify the table that contains customer details, which is the 'Customers' table.", "Determine the specific column that holds the customer details, which is 'Customer_Details'.", "Since the request is to return distinct customer details, use the DISTINCT keyword to ensure that duplicate entries are not included in the results.", "Construct the SQL query to select distinct customer details from the Customers table."], "pred_sql": "SELECT DISTINCT Customer_Details FROM Customers;", "gold_sql": "SELECT DISTINCT customer_details FROM Customers", "source_tables": ["customers"]}
{"sample_id": 3886, "db_id": "insurance_policies", "question": "Which kind of policy type was chosen by the most customers?", "rationale": ["Identify the relevant table: The query is about policy types and customers, so we will use the 'Customer_Policies' table.", "Count the distinct customers for each policy type: We need to count how many unique customers chose each policy type, which requires a GROUP BY clause on 'Policy_Type_Code'.", "Order the results: To find the policy type chosen by the most customers, we will order the results in descending order based on the count of customers.", "Limit the results: Since we only want the policy type with the highest count, we will limit the results to 1."], "pred_sql": "SELECT Policy_Type_Code, COUNT(DISTINCT Customer_ID) AS Customer_Count\nFROM Customer_Policies\nGROUP BY Policy_Type_Code\nORDER BY Customer_Count DESC\nLIMIT 1;", "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"]}
{"sample_id": 3887, "db_id": "insurance_policies", "question": "Find the policy type the most customers choose.", "rationale": ["Identify the relevant table that contains policy types and customer information, which is the Customer_Policies table.", "We need to count the number of distinct customers for each policy type, so we will use COUNT(DISTINCT Customer_ID).", "Group the results by Policy_Type_Code to aggregate the counts for each policy type.", "Order the results in descending order based on the count of customers to find the most popular policy type.", "Limit the results to 1 to get only the top policy type chosen by the most customers."], "pred_sql": "SELECT Policy_Type_Code, COUNT(DISTINCT Customer_ID) AS Customer_Count\nFROM Customer_Policies\nGROUP BY Policy_Type_Code\nORDER BY Customer_Count DESC\nLIMIT 1;", "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"]}
{"sample_id": 3888, "db_id": "insurance_policies", "question": "How many settlements are there in total?", "rationale": ["Identify the table that contains the information about settlements, which is the 'Settlements' table.", "To find the total number of settlements, we need to count the records in the 'Settlements' table.", "Use the COUNT() function to count all rows in the 'Settlements' table.", "Construct the SQL query to select the count of settlements from the 'Settlements' table."], "pred_sql": "SELECT COUNT(*) AS Total_Settlements FROM Settlements;", "gold_sql": "SELECT count(*) FROM Settlements", "source_tables": ["settlements"]}
{"sample_id": 3889, "db_id": "insurance_policies", "question": "Count the total number of settlements made.", "rationale": ["Identify the table that contains the information about settlements, which is the 'Settlements' table.", "To count the total number of settlements, we can use the COUNT() function in SQL.", "The SQL query will select the count of all records from the 'Settlements' table.", "The final SQL query will be 'SELECT COUNT(*) AS Total_Settlements FROM Settlements;' to get the total number of settlements."], "pred_sql": "SELECT COUNT(*) AS Total_Settlements FROM Settlements;", "gold_sql": "SELECT count(*) FROM Settlements", "source_tables": ["settlements"]}
{"sample_id": 3890, "db_id": "insurance_policies", "question": "Which Payments were processed with Visa? List the payment Id, the date and the amount.", "rationale": ["Identify the relevant table: Payments, as we need information about payments.", "Determine the columns needed: Payment_ID, Date_Payment_Made, and Amount_Payment.", "Filter the results to only include payments processed with Visa, which is indicated by the Payment_Method_Code.", "Construct the SQL SELECT statement to retrieve the specified columns from the Payments table with the appropriate WHERE clause."], "pred_sql": "SELECT Payment_ID, Date_Payment_Made, Amount_Payment FROM Payments WHERE Payment_Method_Code = 'Visa';", "gold_sql": "SELECT Payment_ID ,  Date_Payment_Made ,  Amount_Payment FROM Payments WHERE Payment_Method_Code  =  'Visa'", "source_tables": ["payments"]}
{"sample_id": 3891, "db_id": "insurance_policies", "question": "Give me the payment Id, the date and the amount for all the payments processed with Visa.", "rationale": ["Identify the relevant table: Payments, as it contains payment information.", "Determine the columns needed: Payment_ID, Date_Payment_Made, and Amount_Payment.", "Filter the results based on the payment method: Visa, which corresponds to the Payment_Method_Code column.", "Construct the SQL SELECT statement to retrieve the specified columns from the Payments table with the appropriate WHERE clause."], "pred_sql": "SELECT Payment_ID, Date_Payment_Made, Amount_Payment FROM Payments WHERE Payment_Method_Code = 'Visa';", "gold_sql": "SELECT Payment_ID ,  Date_Payment_Made ,  Amount_Payment FROM Payments WHERE Payment_Method_Code  =  'Visa'", "source_tables": ["payments"]}
{"sample_id": 3892, "db_id": "insurance_policies", "question": "List the details of the customers who do not have any policies.", "rationale": ["Identify the Customers table as the source of customer details.", "Determine that we need to find customers without any policies.", "To find customers without policies, we can use a subquery to select Customer_IDs from the Customer_Policies table.", "The main query will select all columns from the Customers table where the Customer_ID is not in the list of Customer_IDs returned by the subquery."], "pred_sql": "SELECT * FROM Customers WHERE Customer_ID NOT IN (SELECT Customer_ID FROM Customer_Policies)", "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"]}
{"sample_id": 3893, "db_id": "insurance_policies", "question": "Which customers do not have any policies? Find the details of these customers.", "rationale": ["We need to find customers who do not have any policies.", "To do this, we will use a LEFT JOIN between the Customers table and the Customer_Policies table on the Customer_ID column.", "The LEFT JOIN will include all records from the Customers table and the matching records from the Customer_Policies table.", "For customers without policies, the Customer_ID in the Customer_Policies table will be NULL.", "We will filter the results to only include those records where Customer_Policies.Customer_ID is NULL.", "Finally, we will select the Customer_ID and Customer_Details from the Customers table."], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details FROM Customers LEFT JOIN Customer_Policies ON Customers.Customer_ID = Customer_Policies.Customer_ID WHERE Customer_Policies.Customer_ID IS NULL;", "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"]}
{"sample_id": 3894, "db_id": "insurance_policies", "question": "List the date the claim was made, the date it was settled and the amount settled for all the claims which had exactly one settlement.", "rationale": ["We need to select specific columns from the Claims table: Date_Claim_Made, Date_Claim_Settled, and Amount_Settled.", "To get the relevant data, we will join the Claims table with the Settlements table on the Claim_ID column, as each claim can have multiple settlements.", "We want to filter the results to include only those claims that have exactly one settlement. To achieve this, we will group the results by Claim_ID and use the HAVING clause to count the number of settlements for each claim.", "The condition in the HAVING clause will be COUNT(Settlements.Settlement_ID) = 1, ensuring we only get claims with a single settlement."], "pred_sql": "SELECT Claims.Date_Claim_Made, Claims.Date_Claim_Settled, Claims.Amount_Settled \nFROM Claims \nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID \nGROUP BY Claims.Claim_ID \nHAVING COUNT(Settlements.Settlement_ID) = 1;", "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"]}
{"sample_id": 3895, "db_id": "insurance_policies", "question": "Which claims had exactly one settlement? For each, tell me the the date the claim was made, the date it was settled and the amount settled.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find claims that have exactly one settlement, so we will join the Claims table with the Settlements table on the Claim_ID.", "We will select the required fields: Date_Claim_Made, Date_Claim_Settled, and Amount_Settled.", "To ensure we only get claims with exactly one settlement, we will group the results by Claim_ID and use the HAVING clause to filter groups with a count of settlements equal to one."], "pred_sql": "SELECT Claims.Date_Claim_Made, Claims.Date_Claim_Settled, Settlements.Amount_Settled \nFROM Claims \nJOIN Settlements ON Claims.Claim_ID = Settlements.Claim_ID \nGROUP BY Claims.Claim_ID \nHAVING COUNT(Settlements.Settlement_ID) = 1;", "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"]}
{"sample_id": 3896, "db_id": "insurance_policies", "question": "Find the total claimed amount of all the claims.", "rationale": ["Identify the table that contains the information about claims, which is the 'Claims' table.", "Determine the column that holds the total amount requested in each claim, which is 'Amount_Claimed'.", "Use the SUM() function to calculate the total of the 'Amount_Claimed' column.", "Construct the SQL query to select the sum of 'Amount_Claimed' from the 'Claims' table."], "pred_sql": "SELECT SUM(Amount_Claimed) AS Total_Claimed_Amount FROM Claims;", "gold_sql": "SELECT sum(Amount_Claimed) FROM Claims", "source_tables": ["claims"]}
{"sample_id": 3897, "db_id": "insurance_policies", "question": "What is total amount claimed summed across all the claims?", "rationale": ["Identify the table that contains the relevant data: the Claims table holds information about claims, including the amount claimed.", "Determine the specific column needed: the Amount_Claimed column contains the values we want to sum up.", "Use the SUM() function to calculate the total of the Amount_Claimed column.", "Construct the SQL query to select the sum of Amount_Claimed from the Claims table."], "pred_sql": "SELECT SUM(Amount_Claimed) AS Total_Amount_Claimed FROM Claims;", "gold_sql": "SELECT sum(Amount_Claimed) FROM Claims", "source_tables": ["claims"]}
{"sample_id": 3898, "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician, as we need to count employees in each department.", "Use the Affiliated_With table to link physicians to their respective departments.", "Perform a LEFT JOIN between Department and Affiliated_With to get all departments and their associated physicians.", "Perform another LEFT JOIN between Affiliated_With and Physician to get the details of the physicians.", "Group the results by department name to count the number of physicians in each department.", "Order the results by the count of employees in descending order to find the department with the largest number of employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "pred_sql": "SELECT Department.Name, COUNT(Physician.EmployeeID) AS EmployeeCount\nFROM Department\nLEFT JOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nLEFT JOIN Physician ON Affiliated_With.Physician = Physician.EmployeeID\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"]}
{"sample_id": 3899, "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["Identify the relevant tables: Department and Affiliated_With, as we need to count employees in each department.", "Join the Department table with the Affiliated_With table on the DepartmentID to link departments with their physicians.", "Use COUNT() to count the number of physicians (employees) in each department.", "Group the results by department name to get the count per department.", "Order the results by the count of employees in descending order to find the department with the most employees.", "Limit the results to 1 to get only the department with the highest count."], "pred_sql": "SELECT Department.Name, COUNT(Affiliated_With.Physician) AS EmployeeCount\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"]}
{"sample_id": 3900, "db_id": "hospital_1", "question": "What is the employee id of the head whose department has the least number of employees?", "rationale": ["We need to find the head of the department with the least number of employees.", "To do this, we will join the Department table with the Affiliated_With table on the DepartmentID.", "We will group the results by the Head of the department to count the number of physicians affiliated with each department.", "Next, we will order the results by the count of physicians in ascending order to find the department with the least number of employees.", "Finally, we will limit the results to 1 to get the head of the department with the least number of employees."], "pred_sql": "SELECT Department.Head FROM Department JOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department GROUP BY Department.Head ORDER BY COUNT(Affiliated_With.Physician) ASC LIMIT 1;", "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"]}
{"sample_id": 3901, "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["Identify the department with the least number of employees by counting the number of physicians affiliated with each department.", "Join the Department table with the Affiliated_With table on the DepartmentID to get the count of physicians for each department.", "Group the results by DepartmentID to aggregate the count of physicians for each department.", "Order the results in ascending order based on the count of physicians to find the department with the least employees.", "Select the Head of the department from the Department table for the department with the least employees using LIMIT 1."], "pred_sql": "SELECT Department.Head FROM Department JOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department GROUP BY Department.DepartmentID ORDER BY COUNT(Affiliated_With.Physician) ASC LIMIT 1;", "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"]}
{"sample_id": 3902, "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["We need to find the head of the department with the least number of employees.", "First, we will count the number of physicians affiliated with each department using the Affiliated_With table.", "We will group the results by department and order them by the count of physicians in ascending order to find the department with the least number of employees.", "We will limit the results to 1 to get the department ID with the least number of employees.", "Next, we will join the Department table with the Physician table to get the head of that department.", "Finally, we will select the Name and Position of the physician who is the head of the department with the least number of employees."], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Department ON Physician.EmployeeID = Department.Head \nWHERE Department.DepartmentID = \n  (SELECT Affiliated_With.Department \n   FROM Affiliated_With \n   GROUP BY Affiliated_With.Department \n   ORDER BY COUNT(Affiliated_With.Physician) ASC \n   LIMIT 1);", "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"]}
{"sample_id": 3903, "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["Identify the department with the least employees by counting the number of physicians affiliated with each department.", "Use a subquery to select the DepartmentID of the department that has the least number of affiliated physicians, ordering the results by count in ascending order and limiting the result to 1.", "Join the Physician table with the Department table on the condition that the Physician's EmployeeID matches the Department's Head.", "Select the Name and Position of the physician who is the head of the identified department."], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Department ON Physician.EmployeeID = Department.Head \nWHERE Department.DepartmentID = \n(\n    SELECT Affiliated_With.Department \n    FROM Affiliated_With \n    GROUP BY Affiliated_With.Department \n    ORDER BY COUNT(Affiliated_With.Physician) ASC \n    LIMIT 1\n)", "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"]}
{"sample_id": 3904, "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["Identify the relevant tables: Patient and Appointment.", "Determine the relationship between patients and appointments: The Patient table has a SSN that corresponds to the Patient field in the Appointment table.", "Select the Name field from the Patient table to get the names of patients.", "Use a JOIN clause to combine the Patient and Appointment tables based on the SSN and Patient fields.", "Use DISTINCT to ensure that each patient's name is listed only once, even if they have multiple appointments."], "pred_sql": "SELECT DISTINCT Patient.Name FROM Patient JOIN Appointment ON Patient.SSN = Appointment.Patient;", "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"]}
{"sample_id": 3905, "db_id": "hospital_1", "question": "List the names of patients who have made appointments.", "rationale": ["Identify the relevant tables: Patient and Appointment.", "Determine the relationship between patients and appointments: Patient.SSN is linked to Appointment.Patient.", "Select the distinct names of patients to avoid duplicates.", "Construct the SQL query using JOIN to combine Patient and Appointment tables based on the relationship."], "pred_sql": "SELECT DISTINCT Patient.Name FROM Patient JOIN Appointment ON Patient.SSN = Appointment.Patient;", "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"]}
{"sample_id": 3906, "db_id": "hospital_1", "question": "what are name and phone number of patients who had more than one appointment?", "rationale": ["Identify the relevant tables: Patient and Appointment.", "We need to retrieve the names and phone numbers of patients, so we will select Patient.Name and Patient.Phone.", "To find patients with more than one appointment, we will join the Patient table with the Appointment table on the Patient.SSN and Appointment.Patient columns.", "We will group the results by Patient.SSN to aggregate the appointment counts for each patient.", "Using the HAVING clause, we will filter the groups to include only those patients who have more than one appointment (COUNT(Appointment.AppointmentID) > 1)."], "pred_sql": "SELECT Patient.Name, Patient.Phone FROM Patient JOIN Appointment ON Patient.SSN = Appointment.Patient GROUP BY Patient.SSN HAVING COUNT(Appointment.AppointmentID) > 1;", "gold_sql": "SELECT name ,  phone FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn GROUP BY T1.patient HAVING count(*)  >  1", "source_tables": ["patient", "appointment"]}
{"sample_id": 3907, "db_id": "hospital_1", "question": "Which patients made more than one appointment? Tell me the name and phone number of these patients.", "rationale": ["Identify the relevant tables: Patient and Appointment.", "We need to join these tables on the common key, which is Patient.SSN and Appointment.Patient.", "Select the columns we want in the output: Patient.Name and Patient.Phone.", "Group the results by Patient.SSN to aggregate the appointment counts for each patient.", "Use the HAVING clause to filter groups that have more than one appointment."], "pred_sql": "SELECT Patient.Name, Patient.Phone FROM Patient JOIN Appointment ON Patient.SSN = Appointment.Patient GROUP BY Patient.SSN HAVING COUNT(Appointment.AppointmentID) > 1;", "gold_sql": "SELECT name ,  phone FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn GROUP BY T1.patient HAVING count(*)  >  1", "source_tables": ["patient", "appointment"]}
{"sample_id": 3908, "db_id": "hospital_1", "question": "Find the id of the appointment with the most recent start date?", "rationale": ["Identify the table that contains appointment information, which is the 'Appointment' table.", "Determine the relevant column for the appointment ID, which is 'AppointmentID'.", "Identify the column that contains the start date of the appointment, which is 'Start'.", "To find the most recent appointment, we need to order the results by the 'Start' column in descending order.", "Limit the results to only one record to get the most recent appointment.", "Construct the SQL query to select the 'AppointmentID' from the 'Appointment' table, order by 'Start' in descending order, and limit the result to 1."], "pred_sql": "SELECT AppointmentID FROM Appointment ORDER BY Start DESC LIMIT 1;", "gold_sql": "SELECT appointmentid FROM appointment ORDER BY START DESC LIMIT 1", "source_tables": ["appointment"]}
{"sample_id": 3909, "db_id": "hospital_1", "question": "What is the id of the appointment that started most recently?", "rationale": ["Identify the relevant table: The Appointment table contains the AppointmentID and the Start time of each appointment.", "Determine the requirement: We need to find the appointment that started most recently, which implies sorting by the Start time in descending order.", "Construct the SQL query: Use SELECT to get the AppointmentID from the Appointment table, ORDER BY to sort the results by Start in descending order, and LIMIT to restrict the output to the most recent appointment."], "pred_sql": "SELECT AppointmentID FROM Appointment ORDER BY Start DESC LIMIT 1;", "gold_sql": "SELECT appointmentid FROM appointment ORDER BY START DESC LIMIT 1", "source_tables": ["appointment"]}
{"sample_id": 3910, "db_id": "hospital_1", "question": "List the name of physicians who took some appointment.", "rationale": ["Identify the relevant tables: Physician and Appointment.", "Determine the relationship between the tables: Appointment table has a foreign key referencing Physician (Appointment.Physician = Physician.EmployeeID).", "Select the 'Name' column from the Physician table.", "Use a JOIN to combine the Physician and Appointment tables based on the relationship identified.", "Use DISTINCT to ensure that each physician's name is listed only once, even if they have multiple appointments."], "pred_sql": "SELECT DISTINCT Physician.Name FROM Physician JOIN Appointment ON Physician.EmployeeID = Appointment.Physician;", "gold_sql": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID", "source_tables": ["physician", "appointment"]}
{"sample_id": 3911, "db_id": "hospital_1", "question": "What are the names of all the physicians who took appointments.", "rationale": ["Identify the relevant tables: Physician and Appointment.", "We need to find the names of physicians who have taken appointments, which means we need to join the Physician table with the Appointment table on the Physician's identifier.", "Use the JOIN clause to combine the two tables based on the matching EmployeeID in Physician and Physician in Appointment.", "Select the distinct names of physicians to avoid duplicates, as a physician may have multiple appointments."], "pred_sql": "SELECT DISTINCT Physician.Name FROM Physician JOIN Appointment ON Physician.EmployeeID = Appointment.Physician;", "gold_sql": "SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID", "source_tables": ["physician", "appointment"]}
{"sample_id": 3912, "db_id": "hospital_1", "question": "List the name of physicians who never took any appointment.", "rationale": ["Identify the table that contains physician information, which is the 'Physician' table.", "We need to find physicians who have never taken any appointments, so we will look at the 'Appointment' table.", "The 'Appointment' table has a column 'Physician' that references the 'EmployeeID' in the 'Physician' table.", "To find physicians who have never taken an appointment, we can use a subquery to select all 'Physician' IDs from the 'Appointment' table.", "We will then select the 'Name' of physicians from the 'Physician' table where their 'EmployeeID' is not in the list of IDs returned by the subquery."], "pred_sql": "SELECT Name FROM Physician WHERE EmployeeID NOT IN (SELECT Physician FROM Appointment)", "gold_sql": "SELECT name FROM physician EXCEPT SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID", "source_tables": ["physician", "appointment"]}
{"sample_id": 3913, "db_id": "hospital_1", "question": "Which physicians have never taken any appointment? Find their names.", "rationale": ["Identify the table that contains physician information, which is the Physician table.", "We need to find physicians who have never taken any appointment, so we will look at the Appointment table to see which physicians have appointments.", "We will use a subquery to select all EmployeeIDs from the Appointment table.", "The main query will select the names of physicians from the Physician table whose EmployeeID is not in the list of EmployeeIDs returned by the subquery."], "pred_sql": "SELECT Name FROM Physician WHERE EmployeeID NOT IN (SELECT Physician FROM Appointment)", "gold_sql": "SELECT name FROM physician EXCEPT SELECT T2.name FROM appointment AS T1 JOIN physician AS T2 ON T1.Physician  =  T2.EmployeeID", "source_tables": ["physician", "appointment"]}
{"sample_id": 3914, "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables needed: Physician, Affiliated_With, and Department.", "We need to select the names of physicians and their affiliated departments.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns.", "Join the Affiliated_With table with the Department table on the Department column.", "Filter the results to include only primary affiliations by checking the PrimaryAffiliation column."], "pred_sql": "SELECT Physician.Name AS PhysicianName, Department.Name AS DepartmentName\nFROM Physician\nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician\nJOIN Department ON Affiliated_With.Department = Department.DepartmentID\nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"]}
{"sample_id": 3915, "db_id": "hospital_1", "question": "What are the name and primarily affiliated department name of each physician?", "rationale": ["Identify the columns needed: Physician's name and the department name.", "The Physician table contains the physician's name, and the Department table contains the department's name.", "To get the department name associated with each physician, we need to join the Physician table with the Affiliated_With table on the physician's identifier (EmployeeID).", "Next, we join the Affiliated_With table with the Department table on the department identifier (DepartmentID) to get the department name.", "We need to filter the results to include only those affiliations that are marked as primary, which is indicated by the PrimaryAffiliation column in the Affiliated_With table."], "pred_sql": "SELECT Physician.Name, Department.Name AS DepartmentName\nFROM Physician\nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician\nJOIN Department ON Affiliated_With.Department = Department.DepartmentID\nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"]}
{"sample_id": 3916, "db_id": "hospital_1", "question": "What is the name of the patient who made the most recent appointment?", "rationale": ["Identify the relevant tables: Patient and Appointment.", "We need to find the name of the patient, so we will select Patient.Name.", "To find the most recent appointment, we will join the Patient table with the Appointment table on the Patient's SSN and the Appointment's Patient identifier.", "We will order the results by the appointment start time in descending order to get the most recent appointment first.", "Finally, we will limit the results to 1 to get only the most recent patient's name."], "pred_sql": "SELECT Patient.Name FROM Patient JOIN Appointment ON Patient.SSN = Appointment.Patient ORDER BY Appointment.Start DESC LIMIT 1;", "gold_sql": "SELECT T1.name FROM patient AS T1 JOIN appointment AS T2 ON T1.ssn = T2.patient ORDER BY T2.start DESC LIMIT 1", "source_tables": ["patient", "appointment"]}
{"sample_id": 3917, "db_id": "hospital_1", "question": "Find the name of the patient who made the appointment with the most recent start date.", "rationale": ["Identify the relevant tables: Appointment and Patient.", "We need to find the patient associated with the most recent appointment, so we will join the Appointment table with the Patient table on the Patient's SSN.", "We will order the results by the Start date of the appointment in descending order to get the most recent appointment first.", "Finally, we will limit the results to 1 to get only the patient associated with the most recent appointment."], "pred_sql": "SELECT Patient.Name FROM Appointment JOIN Patient ON Appointment.Patient = Patient.SSN ORDER BY Appointment.Start DESC LIMIT 1;", "gold_sql": "SELECT T1.name FROM patient AS T1 JOIN appointment AS T2 ON T1.ssn = T2.patient ORDER BY T2.start DESC LIMIT 1", "source_tables": ["patient", "appointment"]}
{"sample_id": 3918, "db_id": "hospital_1", "question": "How many patients stay in room 112?", "rationale": ["Identify the relevant table: The 'Stay' table contains information about patients and their room assignments.", "Determine the specific information needed: We need to count the number of patients staying in a specific room, which is room 112.", "Construct the SQL query: Use the COUNT() function to count the number of entries in the 'Stay' table where the Room column matches 112."], "pred_sql": "SELECT COUNT(*) AS PatientCount FROM Stay WHERE Room = 112;", "gold_sql": "SELECT count(patient) FROM stay WHERE room  =  112", "source_tables": ["stay"]}
{"sample_id": 3919, "db_id": "hospital_1", "question": "Count the number of patients who stayed in room 112.", "rationale": ["Identify the relevant table: The 'Stay' table contains information about patients' stays in rooms.", "Determine the condition: We need to filter the stays to only those in room 112.", "Count the distinct patients: Use COUNT(DISTINCT Patient) to ensure we count each patient only once, even if they stayed multiple times."], "pred_sql": "SELECT COUNT(DISTINCT Patient) AS NumberOfPatients FROM Stay WHERE Room = 112;", "gold_sql": "SELECT count(patient) FROM stay WHERE room  =  112", "source_tables": ["stay"]}
{"sample_id": 3920, "db_id": "hospital_1", "question": "How many patients' prescriptions are made by physician John Dorian?", "rationale": ["Identify the relevant tables: We need to look at the 'Prescribes' table to find prescriptions and the 'Physician' table to identify the physician by name.", "We need to count the number of distinct patients who have prescriptions made by the physician named 'John Dorian'.", "Join the 'Prescribes' table with the 'Physician' table on the physician's identifier (EmployeeID).", "Filter the results to only include prescriptions made by 'John Dorian'.", "Use the COUNT function to count the distinct patients in the result set."], "pred_sql": "SELECT COUNT(DISTINCT Prescribes.Patient) AS PatientCount\nFROM Prescribes\nJOIN Physician ON Prescribes.Physician = Physician.EmployeeID\nWHERE Physician.Name = 'John Dorian';", "gold_sql": "SELECT count(T1.SSN) FROM patient AS T1 JOIN prescribes AS T2 ON T1.SSN  =  T2.patient JOIN physician AS T3 ON T2.physician  =  T3.employeeid WHERE T3.name = 'John Dorian'", "source_tables": ["physician", "patient", "prescribes"]}
{"sample_id": 3921, "db_id": "hospital_1", "question": "Find the number of patients' prescriptions physician John Dorian made.", "rationale": ["Identify the relevant tables: We need to find information from the 'Prescribes' table to count the prescriptions made by a physician.", "Determine the relationship: The 'Prescribes' table has a foreign key 'Physician' that links to the 'Physician' table's 'EmployeeID'.", "Filter by physician name: We need to filter the results to only include prescriptions made by the physician named 'John Dorian'.", "Count the prescriptions: Use the COUNT() function to count the number of prescriptions made by the specified physician."], "pred_sql": "SELECT COUNT(*) AS PrescriptionCount \nFROM Prescribes \nJOIN Physician ON Prescribes.Physician = Physician.EmployeeID \nWHERE Physician.Name = 'John Dorian';", "gold_sql": "SELECT count(T1.SSN) FROM patient AS T1 JOIN prescribes AS T2 ON T1.SSN  =  T2.patient JOIN physician AS T3 ON T2.physician  =  T3.employeeid WHERE T3.name = 'John Dorian'", "source_tables": ["physician", "patient", "prescribes"]}
{"sample_id": 3922, "db_id": "hospital_1", "question": "Find the name of medication used on the patient who stays in room 111?", "rationale": ["Identify the relevant tables: Medication, Prescribes, and Stay.", "We need to find the medication used on a patient, so we will join the Medication table with the Prescribes table on the medication code.", "Next, we need to link the Prescribes table with the Stay table to find out which patient is staying in room 111.", "The condition to filter the results is that the room number in the Stay table should be 111.", "Finally, we select the name of the medication from the Medication table."], "pred_sql": "SELECT Medication.Name \nFROM Medication \nJOIN Prescribes ON Medication.Code = Prescribes.Medication \nJOIN Stay ON Prescribes.Patient = Stay.Patient \nWHERE Stay.Room = 111;", "gold_sql": "SELECT T4.name FROM stay AS T1 JOIN patient AS T2 ON T1.Patient  =  T2.SSN JOIN Prescribes AS T3 ON T3.Patient  =  T2.SSN JOIN Medication AS T4 ON T3.Medication  =  T4.Code WHERE room  =  111", "source_tables": ["patient", "medication", "prescribes", "stay"]}
{"sample_id": 3923, "db_id": "hospital_1", "question": "What is the name of the medication used for the patient staying in room 111?", "rationale": ["Identify the relevant tables: Medication, Prescribes, and Stay.", "We need to find the name of the medication, so we will select the 'Name' column from the Medication table.", "The Prescribes table links medications to patients, so we will join the Medication table with the Prescribes table on the 'Code' column of Medication and 'Medication' column of Prescribes.", "The Stay table contains information about patients and their room assignments, so we will join the Stay table with the Prescribes table on the 'Patient' column.", "We need to filter the results to only include the patient staying in room 111, so we will add a WHERE clause to check if Stay.Room equals 111."], "pred_sql": "SELECT Medication.Name \nFROM Medication \nJOIN Prescribes ON Medication.Code = Prescribes.Medication \nJOIN Stay ON Prescribes.Patient = Stay.Patient \nWHERE Stay.Room = 111;", "gold_sql": "SELECT T4.name FROM stay AS T1 JOIN patient AS T2 ON T1.Patient  =  T2.SSN JOIN Prescribes AS T3 ON T3.Patient  =  T2.SSN JOIN Medication AS T4 ON T3.Medication  =  T4.Code WHERE room  =  111", "source_tables": ["patient", "medication", "prescribes", "stay"]}
{"sample_id": 3924, "db_id": "hospital_1", "question": "Find the patient who most recently stayed in room 111.", "rationale": ["Identify the relevant tables: Stay and Patient.", "We need to find patients who stayed in a specific room (Room 111), so we will filter the Stay table by Room.", "We need to retrieve patient information, so we will join the Stay table with the Patient table on the Patient identifier (SSN).", "To find the most recent stay, we will order the results by the StayEnd date in descending order.", "Finally, we will limit the results to only the most recent entry by using LIMIT 1."], "pred_sql": "SELECT Patient.SSN, Patient.Name, Stay.StayEnd \nFROM Stay \nJOIN Patient ON Stay.Patient = Patient.SSN \nWHERE Stay.Room = 111 \nORDER BY Stay.StayEnd DESC \nLIMIT 1;", "gold_sql": "SELECT patient FROM stay WHERE room  =  111 ORDER BY staystart DESC LIMIT 1", "source_tables": ["stay"]}
{"sample_id": 3925, "db_id": "hospital_1", "question": "What is the id of the patient who stayed in room 111 most recently?", "rationale": ["Identify the relevant table: The 'Stay' table contains information about patients' stays in rooms.", "Determine the condition: We need to find patients who stayed in room 111.", "Sort the results: To find the most recent stay, we will order the results by 'StayEnd' in descending order.", "Limit the results: We only need the most recent entry, so we will limit the results to 1."], "pred_sql": "SELECT Patient FROM Stay WHERE Room = 111 ORDER BY StayEnd DESC LIMIT 1;", "gold_sql": "SELECT patient FROM stay WHERE room  =  111 ORDER BY staystart DESC LIMIT 1", "source_tables": ["stay"]}
{"sample_id": 3926, "db_id": "hospital_1", "question": "What is the name of the nurse has the most appointments?", "rationale": ["Identify the relevant tables: Nurse and Appointment.", "We need to find the nurse with the most appointments, so we will join the Nurse table with the Appointment table on the nurse's EmployeeID and the PrepNurse field in the Appointment table.", "We will group the results by the nurse's name to count the number of appointments each nurse has.", "To find the nurse with the most appointments, we will order the results by the count of appointments in descending order.", "Finally, we will limit the results to only the top entry to get the nurse with the most appointments."], "pred_sql": "SELECT Nurse.Name\nFROM Nurse\nJOIN Appointment ON Nurse.EmployeeID = Appointment.PrepNurse\nGROUP BY Nurse.Name\nORDER BY COUNT(Appointment.AppointmentID) DESC\nLIMIT 1;", "gold_sql": "SELECT T1.name FROM nurse AS T1 JOIN appointment AS T2 ON T1.employeeid  =  T2.prepnurse GROUP BY T1.employeeid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["appointment", "nurse"]}
{"sample_id": 3927, "db_id": "hospital_1", "question": "Find the name of the nurse who has the largest number of appointments.", "rationale": ["Identify the relevant tables: Nurse and Appointment.", "We need to find the nurse's name, so we will select Nurse.Name.", "To find the nurse with the largest number of appointments, we will join the Nurse table with the Appointment table on the nurse's EmployeeID and the PrepNurse field in the Appointment table.", "We will group the results by Nurse.EmployeeID to count the number of appointments for each nurse.", "We will order the results by the count of appointments in descending order to get the nurse with the most appointments at the top.", "Finally, we will limit the results to 1 to get only the nurse with the largest number of appointments."], "pred_sql": "SELECT Nurse.Name\nFROM Nurse\nJOIN Appointment ON Nurse.EmployeeID = Appointment.PrepNurse\nGROUP BY Nurse.EmployeeID\nORDER BY COUNT(Appointment.AppointmentID) DESC\nLIMIT 1;", "gold_sql": "SELECT T1.name FROM nurse AS T1 JOIN appointment AS T2 ON T1.employeeid  =  T2.prepnurse GROUP BY T1.employeeid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["appointment", "nurse"]}
{"sample_id": 3928, "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["Identify the relevant tables: Physician and Patient.", "We need to count the number of patients each physician takes care of, which means we need to join the Physician table with the Patient table on the primary care physician (PCP) relationship.", "Use a LEFT JOIN to ensure that physicians with no patients are still included in the results.", "Select the physician's name and count the number of patients associated with each physician.", "Group the results by the physician's name to get the count of patients for each physician."], "pred_sql": "SELECT Physician.Name, COUNT(Patient.SSN) AS NumberOfPatients\nFROM Physician\nLEFT JOIN Patient ON Physician.EmployeeID = Patient.PCP\nGROUP BY Physician.Name;", "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"]}
{"sample_id": 3929, "db_id": "hospital_1", "question": "Return the name of each physician and the number of patients he or she treats.", "rationale": ["We need to select the names of physicians and count the number of patients they treat.", "The relevant table for physician names is the 'Physician' table, which contains the 'Name' column.", "To find out how many patients each physician treats, we need to join the 'Physician' table with the 'Appointment' table, as it links physicians to their appointments.", "Next, we join the 'Appointment' table with the 'Patient' table to access patient information.", "We will use a LEFT JOIN to ensure that we include physicians who may not have treated any patients.", "Finally, we will group the results by physician name and count the number of patients associated with each physician using COUNT(Patient.SSN)."], "pred_sql": "SELECT Physician.Name, COUNT(Patient.SSN) AS NumberOfPatients\nFROM Physician\nLEFT JOIN Appointment ON Physician.EmployeeID = Appointment.Physician\nLEFT JOIN Patient ON Appointment.Patient = Patient.SSN\nGROUP BY Physician.Name;", "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"]}
{"sample_id": 3930, "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["Identify the relevant tables: Physician and Appointment are needed to find physicians and their associated patients.", "Join the Physician table with the Appointment table on the Physician's EmployeeID to link physicians to their patients.", "Group the results by Physician's EmployeeID to aggregate the number of patients each physician is in charge of.", "Use the HAVING clause to filter the groups to only include those with more than one patient."], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Appointment ON Physician.EmployeeID = Appointment.Physician\nGROUP BY Physician.EmployeeID\nHAVING COUNT(Appointment.Patient) > 1;", "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"]}
{"sample_id": 3931, "db_id": "hospital_1", "question": "Which physicians are in charge of more than one patient? Give me their names.", "rationale": ["Identify the relevant tables: Physician and Prescribes.", "We need to find physicians who are in charge of patients, which means we will join the Physician table with the Prescribes table on the Physician's identifier.", "We will group the results by the Physician's EmployeeID to count the number of distinct patients each physician is in charge of.", "We will use the HAVING clause to filter the groups to only include those with more than one distinct patient.", "Finally, we will select the names of the physicians who meet this criterion."], "pred_sql": "SELECT Physician.Name FROM Physician JOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician GROUP BY Physician.EmployeeID HAVING COUNT(DISTINCT Prescribes.Patient) > 1;", "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"]}
{"sample_id": 3932, "db_id": "hospital_1", "question": "Find the number of rooms located on each block floor.", "rationale": ["Identify the relevant table: The 'Room' table contains information about rooms and their block floor status.", "Determine the required information: We need to count the number of rooms for each block floor.", "Use the COUNT() function to count the number of rooms, grouping by the 'BlockFloor' column.", "Construct the SQL query to select the block floor and the count of rooms, using GROUP BY to aggregate the results."], "pred_sql": "SELECT Room.BlockFloor, COUNT(Room.RoomNumber) AS NumberOfRooms\nFROM Room\nGROUP BY Room.BlockFloor;", "gold_sql": "SELECT count(*) ,  T1.blockfloor FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockfloor", "source_tables": ["block", "room"]}
{"sample_id": 3933, "db_id": "hospital_1", "question": "How many rooms does each block floor have?", "rationale": ["Identify the relevant table: The 'Room' table contains information about rooms and their block floor status.", "Determine the required information: We need to count the number of rooms for each block floor.", "Use the COUNT() function to count the number of rooms, grouping by the 'BlockFloor' column to get the count for each unique block floor.", "Construct the SQL query to select the block floor and the count of rooms, using GROUP BY to aggregate the results."], "pred_sql": "SELECT Room.BlockFloor, COUNT(Room.RoomNumber) AS RoomCount FROM Room GROUP BY Room.BlockFloor;", "gold_sql": "SELECT count(*) ,  T1.blockfloor FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockfloor", "source_tables": ["block", "room"]}
{"sample_id": 3934, "db_id": "hospital_1", "question": "Find the number of rooms for different block code?", "rationale": ["Identify the relevant table: The 'Room' table contains information about rooms and their block codes.", "Determine the required information: We need to count the number of rooms for each block code.", "Use the COUNT function: This function will help us count the number of rooms for each block code.", "Group the results: We will use GROUP BY to group the results by BlockCode to get the count for each unique block code.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "pred_sql": "SELECT BlockCode, COUNT(RoomNumber) AS NumberOfRooms FROM Room WHERE BlockCode = 1 GROUP BY BlockCode;", "gold_sql": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode", "source_tables": ["block", "room"]}
{"sample_id": 3935, "db_id": "hospital_1", "question": "How many rooms are located for each block code?", "rationale": ["Identify the relevant table: The 'Room' table contains information about rooms and their block codes.", "Determine the required information: We need to count the number of rooms for each block code.", "Use the COUNT() function to count the number of rooms, and GROUP BY to group the results by block code.", "Construct the SQL query to select the block code and the count of rooms, grouping by block code."], "pred_sql": "SELECT Room.BlockCode, COUNT(Room.RoomNumber) AS RoomCount\nFROM Room\nGROUP BY Room.BlockCode;", "gold_sql": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode", "source_tables": ["block", "room"]}
{"sample_id": 3936, "db_id": "hospital_1", "question": "What are the unique block codes that have available rooms?", "rationale": ["Identify the relevant table: The 'Room' table contains information about room availability and block codes.", "Determine the condition for available rooms: A room is considered available if the 'Unavailable' column is 0.", "Select the unique block codes: Use the DISTINCT keyword to ensure that only unique block codes are returned."], "pred_sql": "SELECT DISTINCT Room.BlockCode FROM Room WHERE Room.Unavailable = 0;", "gold_sql": "SELECT DISTINCT blockcode FROM room WHERE unavailable  =  0", "source_tables": ["room"]}
{"sample_id": 3937, "db_id": "hospital_1", "question": "Tell me the distinct block codes where some rooms are available.", "rationale": ["Identify the relevant table: The query is about block codes and room availability, so we will use the Room table.", "Determine the condition for availability: We need to find rooms that are available, which is indicated by the 'Unavailable' column being 0.", "Select distinct block codes: We want to retrieve unique block codes, so we will use the DISTINCT keyword in our SELECT statement."], "pred_sql": "SELECT DISTINCT BlockCode FROM Room WHERE Unavailable = 0;", "gold_sql": "SELECT DISTINCT blockcode FROM room WHERE unavailable  =  0", "source_tables": ["room"]}
{"sample_id": 3938, "db_id": "hospital_1", "question": "How many different types of rooms are there?", "rationale": ["Identify the table that contains information about rooms, which is the 'Room' table.", "Determine the column that specifies the type of room, which is 'RoomType'.", "To find the number of different types of rooms, use the COUNT function along with DISTINCT to count unique room types.", "Construct the SQL query to select the count of distinct room types from the 'Room' table."], "pred_sql": "SELECT COUNT(DISTINCT RoomType) AS DifferentRoomTypes FROM Room;", "gold_sql": "SELECT count(DISTINCT roomtype) FROM room", "source_tables": ["room"]}
{"sample_id": 3939, "db_id": "hospital_1", "question": "Find the number of distinct room types available.", "rationale": ["Identify the table that contains information about room types, which is the 'Room' table.", "Determine the column that specifies the type of room, which is 'RoomType'.", "To find the number of distinct room types, use the COUNT function along with DISTINCT to count unique values in the 'RoomType' column.", "Construct the SQL query to select the count of distinct room types from the 'Room' table."], "pred_sql": "SELECT COUNT(DISTINCT RoomType) AS DistinctRoomTypes FROM Room;", "gold_sql": "SELECT count(DISTINCT roomtype) FROM room", "source_tables": ["room"]}
{"sample_id": 3940, "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication.", "We need to find the names of physicians who prescribe a specific medication, which is 'Thesisin'.", "Join the Physician table with the Prescribes table on the EmployeeID and Physician columns to link physicians with their prescriptions.", "Next, join the Prescribes table with the Medication table on the Medication column to access the medication details.", "Filter the results to only include prescriptions for the medication named 'Thesisin'.", "Select the Name column from the Physician table to get the names of the physicians."], "pred_sql": "SELECT Physician.Name FROM Physician JOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician JOIN Medication ON Prescribes.Medication = Medication.Code WHERE Medication.Name = 'Thesisin';", "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"]}
{"sample_id": 3941, "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication.", "We need to find the names of physicians, so we will select the 'Name' column from the Physician table.", "To link physicians with the medications they prescribe, we will join the Physician table with the Prescribes table on the EmployeeID and Physician columns.", "Next, we need to filter the results to only include those prescriptions where the medication is 'Thesisin'.", "To do this, we will join the Prescribes table with the Medication table on the Medication.Code and filter by the medication name 'Thesisin'.", "Finally, we will construct the SQL query to select the names of the physicians who meet these criteria."], "pred_sql": "SELECT Physician.Name FROM Physician JOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician JOIN Medication ON Prescribes.Medication = Medication.Code WHERE Medication.Name = 'Thesisin';", "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"]}
{"sample_id": 3942, "db_id": "hospital_1", "question": "Find the name and position of physicians who prescribe some medication whose brand is X?", "rationale": ["Identify the tables needed: Physician, Prescribes, and Medication.", "We need to select the Name and Position of physicians, so we will select these columns from the Physician table.", "To find physicians who prescribe medication, we need to join the Physician table with the Prescribes table on the Physician's EmployeeID and the Prescribes' Physician column.", "Next, we need to join the Medication table to filter by the brand of the medication. We will join on the Medication's Code and the Prescribes' Medication column.", "Finally, we will add a WHERE clause to filter the results to only include medications with the brand 'X'."], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician \nJOIN Medication ON Prescribes.Medication = Medication.Code \nWHERE Medication.Brand = 'X';", "gold_sql": "SELECT DISTINCT T1.name ,  T1.position FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.Brand  =  'X'", "source_tables": ["physician", "prescribes", "medication"]}
{"sample_id": 3943, "db_id": "hospital_1", "question": "Which physicians prescribe a medication of brand X? Tell me the name and position of those physicians.", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication.", "We need to find physicians who have prescribed a medication of a specific brand (Brand X).", "Join the Physician table with the Prescribes table on the EmployeeID and Physician columns to link physicians with their prescriptions.", "Next, join the Prescribes table with the Medication table on the Medication code to access medication details.", "Filter the results to include only those records where the medication brand is 'X'.", "Select the Name and Position columns from the Physician table to get the required information."], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician \nJOIN Medication ON Prescribes.Medication = Medication.Code \nWHERE Medication.Brand = 'X';", "gold_sql": "SELECT DISTINCT T1.name ,  T1.position FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.Brand  =  'X'", "source_tables": ["physician", "prescribes", "medication"]}
{"sample_id": 3944, "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["Identify the relevant tables: Medication and Prescribes.", "We need to count the number of medications prescribed, which means we will use the COUNT function.", "Join the Medication table with the Prescribes table on the medication code to link medications with their prescriptions.", "Select the brand from the Medication table and count the number of prescriptions for each brand.", "Group the results by the brand to get the count for each distinct brand."], "pred_sql": "SELECT m.Brand, COUNT(p.Medication) AS NumberOfPrescriptions\nFROM Medication m\nJOIN Prescribes p ON m.Code = p.Medication\nGROUP BY m.Brand;", "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"]}
{"sample_id": 3945, "db_id": "hospital_1", "question": "How many medications are prescribed for each brand?", "rationale": ["Identify the relevant tables: Medication and Prescribes.", "We need to count the number of medications prescribed for each brand, so we will join the Medication table with the Prescribes table on the medication code.", "Select the brand from the Medication table and count the number of prescriptions from the Prescribes table.", "Group the results by the brand to get the count for each brand."], "pred_sql": "SELECT m.Brand, COUNT(p.Medication) AS MedicationCount\nFROM Medication m\nJOIN Prescribes p ON m.Code = p.Medication\nGROUP BY m.Brand;", "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"]}
{"sample_id": 3946, "db_id": "hospital_1", "question": "Find the name of physicians whose position title contains the word 'senior'.", "rationale": ["Identify the table that contains physician information, which is the 'Physician' table.", "Determine the relevant column for physician names, which is 'Name'.", "Identify the column that contains the position titles, which is 'Position'.", "Formulate a query to select the 'Name' from the 'Physician' table where the 'Position' contains the word 'senior'.", "Use the SQL LIKE operator with wildcards to match any position title that includes 'senior'."], "pred_sql": "SELECT Name FROM Physician WHERE Position LIKE '%senior%';", "gold_sql": "SELECT name FROM physician WHERE POSITION LIKE '%senior%'", "source_tables": ["physician"]}
{"sample_id": 3947, "db_id": "hospital_1", "question": "What are the names of the physicians who have 'senior' in their titles.", "rationale": ["Identify the table that contains physician information, which is the 'Physician' table.", "Determine the column that contains the physician's title, which is 'Position'.", "Formulate a query to select the 'Name' of physicians where the 'Position' contains the word 'senior'.", "Use the SQL LIKE operator with wildcards to match any title that includes 'senior'."], "pred_sql": "SELECT Name FROM Physician WHERE Position LIKE '%senior%';", "gold_sql": "SELECT name FROM physician WHERE POSITION LIKE '%senior%'", "source_tables": ["physician"]}
{"sample_id": 3948, "db_id": "hospital_1", "question": "Find the patient who has the most recent undergoing treatment?", "rationale": ["Identify the relevant tables: 'Undergoes' for treatment records and 'Patient' for patient details.", "We need to find the most recent treatment, so we will use the MAX function on the 'DateUndergoes' column in the 'Undergoes' table.", "Join the 'Undergoes' table with the 'Patient' table on the patient identifier (SSN) to get patient details along with treatment dates.", "Group the results by patient SSN and name to aggregate the treatment dates for each patient.", "Order the results by the most recent treatment date in descending order to get the latest treatment at the top.", "Limit the results to 1 to get only the patient with the most recent treatment."], "pred_sql": "SELECT Patient.SSN, Patient.Name, MAX(Undergoes.DateUndergoes) AS MostRecentTreatmentDate\nFROM Undergoes\nJOIN Patient ON Undergoes.Patient = Patient.SSN\nGROUP BY Patient.SSN, Patient.Name\nORDER BY MostRecentTreatmentDate DESC\nLIMIT 1;", "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"]}
{"sample_id": 3949, "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["Identify the relevant tables: We need to find patients and their treatments, so we will use the 'Undergoes' and 'Patient' tables.", "We need to find the most recent treatment, which means we will look for the maximum date in the 'Undergoes' table.", "Join the 'Undergoes' table with the 'Patient' table on the patient identifier to get the patient's name along with their treatment date.", "Group the results by patient name to aggregate the treatment dates for each patient.", "Use the MAX function to find the most recent treatment date for each patient.", "Order the results by the most recent treatment date in descending order to get the latest treatment on top.", "Limit the results to 1 to get only the patient with the most recent treatment."], "pred_sql": "SELECT Patient.Name, MAX(Undergoes.DateUndergoes) AS MostRecentTreatmentDate\nFROM Undergoes\nJOIN Patient ON Undergoes.Patient = Patient.SSN\nGROUP BY Patient.Name\nORDER BY MostRecentTreatmentDate DESC\nLIMIT 1;", "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"]}
{"sample_id": 3950, "db_id": "hospital_1", "question": "Find the names of all patients who have an undergoing treatment and are staying in room 111.", "rationale": ["Identify the relevant tables: Patient, Undergoes, and Stay.", "We need to find patients who are undergoing treatment, so we will join the Patient table with the Undergoes table on the Patient's SSN.", "Next, we need to check if these patients are staying in a specific room (room 111), so we will also join the Stay table on the Patient's SSN.", "The condition for the Stay table will be that the Room is 111.", "Finally, we select the distinct names of the patients who meet these criteria."], "pred_sql": "SELECT DISTINCT Patient.Name \nFROM Patient \nJOIN Undergoes ON Patient.SSN = Undergoes.Patient \nJOIN Stay ON Patient.SSN = Stay.Patient \nWHERE Stay.Room = 111;", "gold_sql": "SELECT DISTINCT T2.name FROM undergoes AS T1 JOIN patient AS T2 ON T1.patient = T2.SSN JOIN stay AS T3 ON T1.Stay  =  T3.StayID WHERE T3.room  =  111", "source_tables": ["patient", "stay", "undergoes"]}
{"sample_id": 3951, "db_id": "hospital_1", "question": "What are the names of patients who are staying in room 111 and have an undergoing treatment?", "rationale": ["Identify the relevant tables: Patient, Stay, and Undergoes are needed to get the names of patients who are staying in a specific room and have undergone treatment.", "Join the Patient table with the Stay table on the Patient's SSN to get the stay information for each patient.", "Join the resulting table with the Undergoes table on the StayID to filter for patients who have undergone treatment.", "Filter the results to only include patients who are staying in room 111 by adding a WHERE clause for Stay.Room."], "pred_sql": "SELECT DISTINCT Patient.Name\nFROM Patient\nJOIN Stay ON Patient.SSN = Stay.Patient\nJOIN Undergoes ON Stay.StayID = Undergoes.Stay\nWHERE Stay.Room = 111;", "gold_sql": "SELECT DISTINCT T2.name FROM undergoes AS T1 JOIN patient AS T2 ON T1.patient = T2.SSN JOIN stay AS T3 ON T1.Stay  =  T3.StayID WHERE T3.room  =  111", "source_tables": ["patient", "stay", "undergoes"]}
{"sample_id": 3952, "db_id": "hospital_1", "question": "List the names of all distinct nurses ordered by alphabetical order?", "rationale": ["Identify the table that contains the information needed: the Nurse table.", "We need to select the names of the nurses, which corresponds to the 'Name' column in the Nurse table.", "To ensure that we get unique names, we will use the DISTINCT keyword.", "Finally, we need to order the results alphabetically, which can be done using the ORDER BY clause with 'Name' and specifying ASC for ascending order."], "pred_sql": "SELECT DISTINCT Name FROM Nurse ORDER BY Name ASC;", "gold_sql": "SELECT DISTINCT name FROM nurse ORDER BY name", "source_tables": ["nurse"]}
{"sample_id": 3953, "db_id": "hospital_1", "question": "What is the alphabetically ordered list of all the distinct names of nurses?", "rationale": ["Identify the table that contains the information about nurses, which is the 'Nurse' table.", "Determine the column that holds the names of the nurses, which is the 'Name' column.", "Use the DISTINCT keyword to ensure that only unique names are selected.", "Order the results alphabetically by using the ORDER BY clause with 'Name' in ascending order."], "pred_sql": "SELECT DISTINCT Name FROM Nurse ORDER BY Name ASC;", "gold_sql": "SELECT DISTINCT name FROM nurse ORDER BY name", "source_tables": ["nurse"]}
{"sample_id": 3954, "db_id": "hospital_1", "question": "Find the names of nurses who are nursing an undergoing treatment.", "rationale": ["Identify the relevant tables: Nurse and Undergoes.", "We need to find nurses who are assisting in procedures that patients are undergoing, which is represented in the Undergoes table.", "Join the Nurse table with the Undergoes table on the condition that the Nurse's EmployeeID matches the AssistingNurse in the Undergoes table.", "Select the distinct names of the nurses from the result to avoid duplicates."], "pred_sql": "SELECT DISTINCT Nurse.Name \nFROM Nurse \nJOIN Undergoes ON Nurse.EmployeeID = Undergoes.AssistingNurse;", "gold_sql": "SELECT DISTINCT T2.name FROM undergoes AS T1 JOIN nurse AS T2 ON T1.AssistingNurse  =  T2.EmployeeID", "source_tables": ["nurse", "undergoes"]}
{"sample_id": 3955, "db_id": "hospital_1", "question": "Which nurses are in charge of patients undergoing treatments?", "rationale": ["Identify the relevant tables: Nurse and Undergoes, as we need to find nurses in charge of patients undergoing treatments.", "The Nurse table contains information about nurses, while the Undergoes table links patients to the procedures they are undergoing and includes the nurse assisting.", "We need to join the Nurse table with the Undergoes table on the nurse's identifier (Nurse.EmployeeID = Undergoes.AssistingNurse).", "Additionally, we can join with the Patient table to ensure we are referencing the correct patients, but it's not strictly necessary for the output.", "Select the distinct names of nurses from the resulting joined table to avoid duplicates."], "pred_sql": "SELECT DISTINCT Nurse.Name \nFROM Nurse \nJOIN Undergoes ON Nurse.EmployeeID = Undergoes.AssistingNurse \nJOIN Patient ON Undergoes.Patient = Patient.SSN;", "gold_sql": "SELECT DISTINCT T2.name FROM undergoes AS T1 JOIN nurse AS T2 ON T1.AssistingNurse  =  T2.EmployeeID", "source_tables": ["nurse", "undergoes"]}
{"sample_id": 3956, "db_id": "hospital_1", "question": "List the names of all distinct medications, ordered in an alphabetical order.", "rationale": ["Identify the table that contains medication information, which is the 'Medication' table.", "Determine the column that holds the names of the medications, which is 'Name'.", "Use the DISTINCT keyword to ensure that only unique medication names are selected.", "Order the results alphabetically by the medication name using the ORDER BY clause."], "pred_sql": "SELECT DISTINCT Name FROM Medication ORDER BY Name;", "gold_sql": "SELECT DISTINCT name FROM medication ORDER BY name", "source_tables": ["medication"]}
{"sample_id": 3957, "db_id": "hospital_1", "question": "What is the alphabetically ordered list of all distinct medications?", "rationale": ["Identify the table that contains medication information, which is the 'Medication' table.", "Determine the column that holds the names of the medications, which is 'Name'.", "Use the DISTINCT keyword to ensure that only unique medication names are selected.", "Order the results alphabetically by the medication name using the ORDER BY clause with ASC for ascending order."], "pred_sql": "SELECT DISTINCT Name FROM Medication ORDER BY Name ASC;", "gold_sql": "SELECT DISTINCT name FROM medication ORDER BY name", "source_tables": ["medication"]}
{"sample_id": 3958, "db_id": "hospital_1", "question": "What are the names of the physician who prescribed the highest dose?", "rationale": ["Identify the relevant tables: We need to look at the 'Prescribes' table to find the doses prescribed by physicians and the 'Physician' table to get the names of the physicians.", "Determine the highest dose: We need to find the maximum dose from the 'Prescribes' table using a subquery.", "Join the tables: We will join the 'Prescribes' table with the 'Physician' table on the physician identifier to get the names of the physicians who prescribed the highest dose.", "Select the physician names: Finally, we will select the names of the physicians where the dose matches the maximum dose found in the subquery."], "pred_sql": "SELECT p.Name\nFROM Prescribes pr\nJOIN Physician p ON pr.Physician = p.EmployeeID\nWHERE pr.Dose = (SELECT MAX(Dose) FROM Prescribes);", "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"]}
{"sample_id": 3959, "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: Prescribes (for prescriptions) and Physician (for physician details).", "We need to find the physician who prescribed the highest dose, so we will use the MAX function on the Dose column in the Prescribes table.", "To get the physician's name, we will join the Prescribes table with the Physician table on the Physician identifier (EmployeeID).", "The final query will select the Name of the physician where the Dose is equal to the maximum dose found in the subquery."], "pred_sql": "SELECT Physician.Name FROM Prescribes JOIN Physician ON Prescribes.Physician = Physician.EmployeeID WHERE Prescribes.Dose = (SELECT MAX(Dose) FROM Prescribes);", "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"]}
{"sample_id": 3960, "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the tables needed: Physician and Affiliated_With.", "We need to select the EmployeeID from the Physician table and the Department from the Affiliated_With table.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns respectively.", "Filter the results to only include primary affiliations by checking the PrimaryAffiliation column in the Affiliated_With table."], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department FROM Physician JOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician WHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"]}
{"sample_id": 3961, "db_id": "hospital_1", "question": "What are each physician's employee id and department id primarily affiliated.", "rationale": ["Identify the relevant tables: Physician and Affiliated_With.", "We need to select the EmployeeID from the Physician table and the Department from the Affiliated_With table.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician fields respectively.", "Filter the results to include only those records where the PrimaryAffiliation is 'Yes' to get the primary affiliations."], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department FROM Physician JOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician WHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"]}
{"sample_id": 3962, "db_id": "hospital_1", "question": "List the names of departments where some physicians are primarily affiliated with.", "rationale": ["We need to list the names of departments where some physicians are primarily affiliated with.", "To do this, we will select the 'Name' column from the 'Department' table.", "We will join the 'Department' table with the 'Affiliated_With' table on the 'DepartmentID' and 'Department' columns respectively.", "We will filter the results to include only those records where 'PrimaryAffiliation' is marked as 'Yes'.", "Using DISTINCT ensures that we only get unique department names in the result."], "pred_sql": "SELECT DISTINCT Department.Name\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "gold_sql": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1", "source_tables": ["department", "affiliated_with"]}
{"sample_id": 3963, "db_id": "hospital_1", "question": "What are the names of departments that have primarily affiliated physicians.", "rationale": ["Identify the relevant tables: Department and Affiliated_With.", "We need to find departments that have physicians affiliated with them as primary.", "Join the Department table with the Affiliated_With table on the DepartmentID.", "Filter the results where the PrimaryAffiliation is marked as 'Yes'.", "Select the distinct names of the departments from the results."], "pred_sql": "SELECT DISTINCT Department.Name\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "gold_sql": "SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  1", "source_tables": ["department", "affiliated_with"]}
{"sample_id": 3964, "db_id": "hospital_1", "question": "What nurses are on call with block floor 1 and block code 1? Tell me their names.", "rationale": ["Identify the relevant tables: Nurse and On_Call.", "We need to retrieve the names of nurses who are on call, so we will select the 'Name' column from the Nurse table.", "To find the nurses on call with specific conditions, we will join the Nurse table with the On_Call table on the EmployeeID of the Nurse and the Nurse identifier in the On_Call table.", "The conditions specified are that the BlockFloor and BlockCode in the On_Call table must both be equal to '1'.", "Construct the SQL query using a SELECT statement to get the names of the nurses that meet these conditions."], "pred_sql": "SELECT Nurse.Name FROM Nurse JOIN On_Call ON Nurse.EmployeeID = On_Call.Nurse WHERE On_Call.BlockFloor = '1' AND On_Call.BlockCode = '1';", "gold_sql": "SELECT nurse FROM on_call WHERE blockfloor  =  1 AND blockcode  =  1", "source_tables": ["on_call"]}
{"sample_id": 3965, "db_id": "hospital_1", "question": "Find the ids of the nurses who are on call in block floor 1 and block code 1.", "rationale": ["Identify the relevant table: The query requires information about nurses who are on call, which is stored in the 'On_Call' table.", "Determine the conditions: The query specifies that we need nurses who are on call in block floor 1 and block code 1.", "Construct the SQL SELECT statement: We need to select the 'Nurse' column from the 'On_Call' table where the conditions for 'BlockFloor' and 'BlockCode' are met.", "Combine the conditions using the WHERE clause: The conditions are combined using AND to ensure both must be true for the records to be selected."], "pred_sql": "SELECT Nurse FROM On_Call WHERE BlockFloor = '1' AND BlockCode = '1';", "gold_sql": "SELECT nurse FROM on_call WHERE blockfloor  =  1 AND blockcode  =  1", "source_tables": ["on_call"]}
{"sample_id": 3966, "db_id": "hospital_1", "question": "What are the highest cost, lowest cost and average cost of procedures?", "rationale": ["Identify the relevant table: Procedures, which contains the cost of medical procedures.", "Determine the required calculations: highest cost, lowest cost, and average cost.", "Use aggregate functions: MAX() for highest cost, MIN() for lowest cost, and AVG() for average cost.", "Construct the SQL query to select these aggregate values from the Procedures table."], "pred_sql": "SELECT MAX(Cost) AS HighestCost, MIN(Cost) AS LowestCost, AVG(Cost) AS AverageCost FROM Procedures;", "gold_sql": "SELECT MAX(cost) ,  MIN(cost) ,  AVG(cost) FROM procedures", "source_tables": ["procedures"]}
{"sample_id": 3967, "db_id": "hospital_1", "question": "Tell me the highest, lowest, and average cost of procedures.", "rationale": ["Identify the table that contains the cost of procedures, which is the Procedures table.", "Determine the required calculations: highest cost, lowest cost, and average cost.", "Use the SQL aggregate functions MAX(), MIN(), and AVG() to compute the respective values from the Cost column in the Procedures table.", "Construct the SQL query to select these computed values with appropriate aliases for clarity."], "pred_sql": "SELECT MAX(Cost) AS HighestCost, MIN(Cost) AS LowestCost, AVG(Cost) AS AverageCost FROM Procedures;", "gold_sql": "SELECT MAX(cost) ,  MIN(cost) ,  AVG(cost) FROM procedures", "source_tables": ["procedures"]}
{"sample_id": 3968, "db_id": "hospital_1", "question": "List the name and cost of all procedures sorted by the cost from the highest to the lowest.", "rationale": ["Identify the table that contains the required information: Procedures table has the Name and Cost of procedures.", "Select the columns needed: We need to select 'Name' and 'Cost'.", "Specify the sorting order: We want to sort the results by 'Cost' in descending order (highest to lowest).", "Construct the SQL query using SELECT, FROM, and ORDER BY clauses."], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC;", "gold_sql": "SELECT name ,  cost FROM procedures ORDER BY cost DESC", "source_tables": ["procedures"]}
{"sample_id": 3969, "db_id": "hospital_1", "question": "Sort the list of names and costs of all procedures in the descending order of cost.", "rationale": ["Identify the table that contains the required information: the Procedures table.", "Select the columns needed: Name and Cost.", "Sort the results by the Cost column in descending order."], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC;", "gold_sql": "SELECT name ,  cost FROM procedures ORDER BY cost DESC", "source_tables": ["procedures"]}
{"sample_id": 3970, "db_id": "hospital_1", "question": "Find the three most expensive procedures.", "rationale": ["Identify the table that contains the procedure information, which is the Procedures table.", "Determine the columns needed: the name of the procedure and its cost, which are 'Name' and 'Cost'.", "To find the most expensive procedures, sort the results by the 'Cost' column in descending order.", "Limit the results to the top three entries to get the three most expensive procedures."], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"]}
{"sample_id": 3971, "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["Identify the relevant table: Procedures, which contains information about medical procedures and their costs.", "Select the columns needed: Name (for the procedure name) and Cost (for the cost of the procedure).", "Order the results by Cost in descending order to get the most costly procedures first.", "Limit the results to 3 to get only the top three most costly procedures."], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"]}
{"sample_id": 3972, "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find physicians who are trained in specific procedures, so we will join the Physician table with the Trained_In table on the Physician's EmployeeID.", "Next, we join the Trained_In table with the Procedures table on the Treatment code to access the cost of the procedures.", "We need to filter the results to only include procedures that cost more than 5000, so we will add a WHERE clause for Procedures.Cost > 5000.", "Finally, we select the distinct names of the physicians who meet these criteria."], "pred_sql": "SELECT DISTINCT Physician.Name \nFROM Physician \nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician \nJOIN Procedures ON Trained_In.Treatment = Procedures.Code \nWHERE Procedures.Cost > 5000;", "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"]}
{"sample_id": 3973, "db_id": "hospital_1", "question": "Which physicians are trained in procedures that are more expensive than 5000?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find physicians who are trained in certain procedures, so we will join the Physician table with the Trained_In table on the Physician's EmployeeID.", "Next, we join the Trained_In table with the Procedures table on the Treatment code to access the cost of the procedures.", "We need to filter the results to only include procedures that have a cost greater than 5000, so we will use a WHERE clause for this condition.", "Finally, we select the distinct names of the physicians who meet this criteria."], "pred_sql": "SELECT DISTINCT Physician.Name \nFROM Physician \nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician \nJOIN Procedures ON Trained_In.Treatment = Procedures.Code \nWHERE Procedures.Cost > '5000';", "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"]}
{"sample_id": 3974, "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find the physician who was trained in the most expensive procedure.", "First, we need to determine which procedure is the most expensive by using a subquery to select the maximum cost from the Procedures table.", "Next, we join the Physician table with the Trained_In table to link physicians with their training.", "Then, we join the Procedures table to get the cost of the procedures they were trained in.", "Finally, we filter the results to only include the physician(s) trained in the procedure with the maximum cost."], "pred_sql": "SELECT p.Name, p.EmployeeID\nFROM Physician p\nJOIN Trained_In t ON p.EmployeeID = t.Physician\nJOIN Procedures pr ON t.Treatment = pr.Code\nWHERE pr.Cost = (SELECT MAX(Cost) FROM Procedures)", "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"]}
{"sample_id": 3975, "db_id": "hospital_1", "question": "Which physician was trained in the procedure that costs the most.", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find the physician who is trained in a procedure with the highest cost.", "Join the Physician table with the Trained_In table on the EmployeeID and Physician identifier.", "Join the resulting table with the Procedures table on the Treatment and Code identifier.", "Use a subquery to find the maximum cost from the Procedures table.", "Filter the results to only include the physician(s) trained in the procedure that has this maximum cost."], "pred_sql": "SELECT p.Name \nFROM Physician p \nJOIN Trained_In t ON p.EmployeeID = t.Physician \nJOIN Procedures pr ON t.Treatment = pr.Code \nWHERE pr.Cost = (SELECT MAX(Cost) FROM Procedures);", "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"]}
{"sample_id": 3976, "db_id": "hospital_1", "question": "What is the average cost of procedures that physician John Wen was trained in?", "rationale": ["Identify the relevant tables: Procedures, Trained_In, and Physician.", "We need to find the average cost of procedures, so we will use the AVG() function on the Cost column from the Procedures table.", "The Trained_In table links physicians to the procedures they are trained in, so we will join Procedures with Trained_In on the Treatment code.", "We also need to link the Physician table to get the specific physician's name, so we will join Trained_In with Physician on the EmployeeID.", "Finally, we will filter the results to only include the physician named 'John Wen' using a WHERE clause."], "pred_sql": "SELECT AVG(Procedures.Cost) AS AverageCost\nFROM Procedures\nJOIN Trained_In ON Procedures.Code = Trained_In.Treatment\nJOIN Physician ON Trained_In.Physician = Physician.EmployeeID\nWHERE Physician.Name = 'John Wen';", "gold_sql": "SELECT avg(T3.cost) FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["physician", "procedures", "trained_in"]}
{"sample_id": 3977, "db_id": "hospital_1", "question": "Compute the mean price of procedures physician John Wen was trained in.", "rationale": ["Identify the relevant tables: Procedures, Trained_In, and Physician.", "We need to compute the mean price of procedures, so we will use the AVG() function on the Cost column from the Procedures table.", "To find the procedures that a specific physician (John Wen) is trained in, we will join the Procedures table with the Trained_In table on the Treatment code.", "Next, we will join the result with the Physician table to filter by the physician's name (John Wen).", "Finally, we will apply the WHERE clause to specify the physician's name and select the average cost of the procedures."], "pred_sql": "SELECT AVG(Procedures.Cost) AS MeanPrice\nFROM Procedures\nJOIN Trained_In ON Procedures.Code = Trained_In.Treatment\nJOIN Physician ON Trained_In.Physician = Physician.EmployeeID\nWHERE Physician.Name = 'John Wen';", "gold_sql": "SELECT avg(T3.cost) FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["physician", "procedures", "trained_in"]}
{"sample_id": 3978, "db_id": "hospital_1", "question": "Find the names of procedures which physician John Wen was trained in.", "rationale": ["Identify the relevant tables: Procedures, Trained_In, and Physician.", "We need to find the names of procedures, so we will select the 'Name' column from the Procedures table.", "To find out which procedures a physician is trained in, we need to join the Procedures table with the Trained_In table on the procedure code.", "Next, we need to join the Trained_In table with the Physician table to filter by the physician's name.", "Finally, we will add a WHERE clause to specify that we are looking for the physician named 'John Wen'."], "pred_sql": "SELECT Procedures.Name \nFROM Procedures \nJOIN Trained_In ON Procedures.Code = Trained_In.Treatment \nJOIN Physician ON Trained_In.Physician = Physician.EmployeeID \nWHERE Physician.Name = 'John Wen';", "gold_sql": "SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["physician", "procedures", "trained_in"]}
{"sample_id": 3979, "db_id": "hospital_1", "question": "What are the names of procedures physician John Wen was trained in?", "rationale": ["Identify the relevant tables: Procedures, Trained_In, and Physician are needed to find the procedures a physician is trained in.", "We need to join the Procedures table with the Trained_In table on the procedure code (Procedures.Code = Trained_In.Treatment).", "Next, we join the Trained_In table with the Physician table to link the training to the specific physician (Trained_In.Physician = Physician.EmployeeID).", "Finally, we filter the results to only include the physician named 'John Wen' using a WHERE clause (WHERE Physician.Name = 'John Wen').", "Select the procedure names from the Procedures table."], "pred_sql": "SELECT Procedures.Name\nFROM Procedures\nJOIN Trained_In ON Procedures.Code = Trained_In.Treatment\nJOIN Physician ON Trained_In.Physician = Physician.EmployeeID\nWHERE Physician.Name = 'John Wen';", "gold_sql": "SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["physician", "procedures", "trained_in"]}
{"sample_id": 3980, "db_id": "hospital_1", "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.", "rationale": ["Identify the relevant tables: Procedures and Trained_In, as well as Physician for the physician's name.", "We need to select the procedure names and costs from the Procedures table.", "We will join the Procedures table with the Trained_In table to find out which physicians are trained in which procedures.", "We will also join the Trained_In table with the Physician table to filter by the physician's name, 'John Wen'.", "The WHERE clause will filter for procedures that either cost more than 1000 or are associated with the physician named 'John Wen'.", "Use DISTINCT to ensure that we do not get duplicate procedure entries in the result."], "pred_sql": "SELECT DISTINCT Procedures.Name, Procedures.Cost \nFROM Procedures \nLEFT JOIN Trained_In ON Procedures.Code = Trained_In.Treatment \nLEFT JOIN Physician ON Trained_In.Physician = Physician.EmployeeID \nWHERE Procedures.Cost > 1000 OR Physician.Name = 'John Wen';", "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"]}
{"sample_id": 3981, "db_id": "hospital_1", "question": "What are the procedures that cost more than 1000 or are specialized in by physician John Wen?", "rationale": ["Identify the relevant table: Procedures, which contains the cost and name of procedures.", "Filter the procedures based on the cost being greater than 1000.", "Additionally, check if the procedure is one that physician John Wen is specialized in.", "To find the procedures specialized by John Wen, join the Physician table with the Trained_In table on the physician's identifier.", "Select the Treatment codes from Trained_In where the physician's name matches 'John Wen'.", "Combine both conditions using an OR clause in the WHERE statement to get the final result."], "pred_sql": "SELECT Procedures.Name, Procedures.Cost \nFROM Procedures \nWHERE Procedures.Cost > 1000 \n   OR Procedures.Code IN (\n       SELECT Trained_In.Treatment \n       FROM Physician \n       JOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician \n       WHERE Physician.Name = 'John Wen'\n   );", "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"]}
{"sample_id": 3982, "db_id": "hospital_1", "question": "Find the names of all procedures which cost more than 1000 but which physician John Wen was not trained in?", "rationale": ["Identify the table that contains the procedure information, which is the Procedures table.", "We need to filter procedures based on their cost, specifically those that cost more than 1000.", "Next, we need to find out which procedures John Wen is trained in. This requires a subquery that joins the Trained_In table with the Physician table to get the treatments associated with John Wen.", "The subquery will return the Treatment codes that John Wen is trained in.", "Finally, we will use the NOT IN clause to exclude those treatments from the main query, ensuring we only get procedures that John Wen is not trained in."], "pred_sql": "SELECT Procedures.Name \nFROM Procedures \nWHERE Procedures.Cost > 1000 \nAND Procedures.Code NOT IN (\n    SELECT Trained_In.Treatment \n    FROM Trained_In \n    JOIN Physician ON Trained_In.Physician = Physician.EmployeeID \n    WHERE Physician.Name = 'John Wen'\n);", "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 EXCEPT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"]}
{"sample_id": 3983, "db_id": "hospital_1", "question": "Among the procedures that cost more than 1000, which were not specialized in by physician John Wen?", "rationale": ["Identify the procedures that have a cost greater than 1000.", "Use a subquery to find the treatments that physician John Wen is specialized in.", "Join the Trained_In table with the Physician table to filter by physician name.", "Use the NOT IN clause to exclude the treatments that John Wen is specialized in from the list of procedures."], "pred_sql": "SELECT Procedures.Name \nFROM Procedures \nWHERE Procedures.Cost > 1000 \nAND Procedures.Code NOT IN (\n    SELECT Trained_In.Treatment \n    FROM Trained_In \n    JOIN Physician ON Trained_In.Physician = Physician.EmployeeID \n    WHERE Physician.Name = 'John Wen'\n);", "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 EXCEPT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"]}
{"sample_id": 3984, "db_id": "hospital_1", "question": "Find the names of all procedures such that the cost is less than 5000 and physician John Wen was trained in.", "rationale": ["We need to find the names of procedures with a cost less than 5000.", "The Procedures table contains the names and costs of the procedures.", "We also need to check if the physician John Wen was trained in these procedures.", "The Trained_In table links physicians to the procedures they are trained in, using the Treatment code.", "We will join the Procedures table with the Trained_In table on the procedure code.", "Next, we will join the result with the Physician table to filter by the physician's name, which is 'John Wen'.", "Finally, we will apply the condition to filter procedures with a cost less than 5000."], "pred_sql": "SELECT Procedures.Name \nFROM Procedures \nJOIN Trained_In ON Procedures.Code = Trained_In.Treatment \nJOIN Physician ON Trained_In.Physician = Physician.EmployeeID \nWHERE Procedures.Cost < 5000 AND Physician.Name = 'John Wen';", "gold_sql": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"]}
{"sample_id": 3985, "db_id": "hospital_1", "question": "What procedures cost less than 5000 and have John Wen as a trained physician?", "rationale": ["Identify the relevant tables: Procedures and Trained_In, as we need to find procedures and check the training of physicians.", "We need to filter procedures based on their cost, so we will use the Procedures table's Cost column.", "We need to check if John Wen is a trained physician for these procedures, so we will join the Trained_In table with the Procedures table on the Treatment code.", "We will also join the Physician table to get the name of the physician and filter for 'John Wen'.", "Finally, we will apply the condition to select only those procedures that cost less than 5000."], "pred_sql": "SELECT Procedures.Name, Procedures.Cost \nFROM Procedures \nJOIN Trained_In ON Procedures.Code = Trained_In.Treatment \nJOIN Physician ON Trained_In.Physician = Physician.EmployeeID \nWHERE Procedures.Cost < 5000 AND Physician.Name = 'John Wen';", "gold_sql": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"]}
{"sample_id": 3986, "db_id": "hospital_1", "question": "Find the name of physicians who are affiliated with both Surgery and Psychiatry departments.", "rationale": ["Identify the relevant tables: Physician, Affiliated_With, and Department.", "We need to find physicians affiliated with both Surgery and Psychiatry departments, so we will join the Affiliated_With table twice to link physicians to both departments.", "Use the Physician table to get the names of the physicians.", "Join the Affiliated_With table to the Physician table to find the departments they are affiliated with.", "Join the Department table to get the names of the departments associated with the affiliations.", "Filter the results to include only those physicians who are affiliated with both 'Surgery' and 'Psychiatry' departments."], "pred_sql": "SELECT DISTINCT p.Name \nFROM Physician p \nJOIN Affiliated_With aw1 ON p.EmployeeID = aw1.Physician \nJOIN Department d1 ON aw1.Department = d1.DepartmentID \nJOIN Affiliated_With aw2 ON p.EmployeeID = aw2.Physician \nJOIN Department d2 ON aw2.Department = d2.DepartmentID \nWHERE d1.Name = 'Surgery' AND d2.Name = 'Psychiatry';", "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T3.name  =  'Surgery' INTERSECT SELECT T1.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T3.name  =  'Psychiatry'", "source_tables": ["physician", "department", "affiliated_with"]}
{"sample_id": 3987, "db_id": "hospital_1", "question": "Which physicians are affiliated with both Surgery and Psychiatry departments? Tell me their names.", "rationale": ["Identify the relevant tables: Physician, Affiliated_With, and Department.", "We need to find physicians affiliated with both Surgery and Psychiatry departments.", "Join the Physician table with the Affiliated_With table to link physicians to their departments.", "Join the Affiliated_With table with the Department table to get the department names.", "Since a physician can be affiliated with multiple departments, we will join the Affiliated_With table twice (A1 and A2) to check for both departments.", "Filter the results where one department is Surgery and the other is Psychiatry.", "Select the names of the physicians that meet these criteria."], "pred_sql": "SELECT Physician.Name FROM Physician \nJOIN Affiliated_With AS A1 ON Physician.EmployeeID = A1.Physician \nJOIN Department AS D1 ON A1.Department = D1.DepartmentID \nJOIN Affiliated_With AS A2 ON Physician.EmployeeID = A2.Physician \nJOIN Department AS D2 ON A2.Department = D2.DepartmentID \nWHERE D1.Name = 'Surgery' AND D2.Name = 'Psychiatry';", "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T3.name  =  'Surgery' INTERSECT SELECT T1.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T3.name  =  'Psychiatry'", "source_tables": ["physician", "department", "affiliated_with"]}
{"sample_id": 3988, "db_id": "hospital_1", "question": "Find the name of physicians who are affiliated with Surgery or Psychiatry department.", "rationale": ["Identify the tables involved: Physician, Affiliated_With, and Department.", "We need to find the names of physicians, so we will select the 'Name' column from the Physician table.", "To find the affiliation, we will join the Affiliated_With table on the Physician's EmployeeID with the Physician column in Affiliated_With.", "Next, we will join the Department table on the DepartmentID in the Affiliated_With table to get the department names.", "We need to filter the results to only include those affiliated with the 'Surgery' or 'Psychiatry' departments, so we will use a WHERE clause with an IN condition."], "pred_sql": "SELECT Physician.Name FROM Physician\nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician\nJOIN Department ON Affiliated_With.Department = Department.DepartmentID\nWHERE Department.Name IN ('Surgery', 'Psychiatry');", "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T3.name  =  'Surgery' OR T3.name  =  'Psychiatry'", "source_tables": ["physician", "department", "affiliated_with"]}
{"sample_id": 3989, "db_id": "hospital_1", "question": "Which physicians are affiliated with either Surgery or Psychiatry department? Give me their names.", "rationale": ["Identify the tables needed: Physician, Affiliated_With, and Department.", "We need to join these tables to get the names of physicians affiliated with specific departments.", "The join condition will be based on the foreign keys: Affiliated_With.Physician = Physician.EmployeeID and Affiliated_With.Department = Department.DepartmentID.", "We are interested in the names of physicians, so we will select Physician.Name.", "The departments of interest are Surgery and Psychiatry, so we will filter the results using a WHERE clause with the condition Department.Name IN ('Surgery', 'Psychiatry')."], "pred_sql": "SELECT Physician.Name FROM Physician \nJOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician \nJOIN Department ON Affiliated_With.Department = Department.DepartmentID \nWHERE Department.Name IN ('Surgery', 'Psychiatry');", "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T3.name  =  'Surgery' OR T3.name  =  'Psychiatry'", "source_tables": ["physician", "department", "affiliated_with"]}
{"sample_id": 3990, "db_id": "hospital_1", "question": "Find the names of patients who are not using the medication of Procrastin-X.", "rationale": ["We need to find patients who are not using a specific medication, 'Procrastin-X'.", "First, we identify the patients who are using 'Procrastin-X' by joining the 'Prescribes' table with the 'Medication' table on the medication code.", "We filter the results to only include prescriptions for 'Procrastin-X'.", "Next, we select the names of all patients from the 'Patient' table.", "To find patients not using 'Procrastin-X', we use a NOT IN clause to exclude those patients identified in the previous step."], "pred_sql": "SELECT DISTINCT Patient.Name \nFROM Patient \nWHERE Patient.SSN NOT IN (\n    SELECT Prescribes.Patient \n    FROM Prescribes \n    JOIN Medication ON Prescribes.Medication = Medication.Code \n    WHERE Medication.Name = 'Procrastin-X'\n);", "gold_sql": "SELECT name FROM patient EXCEPT SELECT T1.name FROM patient AS T1 JOIN Prescribes AS T2 ON T2.Patient  =  T1.SSN JOIN Medication AS T3 ON T2.Medication  =  T3.Code WHERE T3.name  =  'Procrastin-X'", "source_tables": ["patient", "prescribes", "medication"]}
{"sample_id": 3991, "db_id": "hospital_1", "question": "What are the names of patients who are not taking the medication of Procrastin-X.", "rationale": ["Identify the table that contains patient names, which is the Patient table.", "We need to find patients who are not taking a specific medication, so we will use the Prescribes table to find patients who are prescribed 'Procrastin-X'.", "Join the Prescribes table with the Medication table to filter by the medication name 'Procrastin-X'.", "Use a subquery to get the list of patients who are taking 'Procrastin-X'.", "Use the NOT IN clause to select patients from the Patient table whose SSN is not in the list of patients taking 'Procrastin-X'.", "Select the distinct names of these patients to avoid duplicates."], "pred_sql": "SELECT DISTINCT Patient.Name\nFROM Patient\nWHERE Patient.SSN NOT IN (\n    SELECT Prescribes.Patient\n    FROM Prescribes\n    JOIN Medication ON Prescribes.Medication = Medication.Code\n    WHERE Medication.Name = 'Procrastin-X'\n);", "gold_sql": "SELECT name FROM patient EXCEPT SELECT T1.name FROM patient AS T1 JOIN Prescribes AS T2 ON T2.Patient  =  T1.SSN JOIN Medication AS T3 ON T2.Medication  =  T3.Code WHERE T3.name  =  'Procrastin-X'", "source_tables": ["patient", "prescribes", "medication"]}
{"sample_id": 3992, "db_id": "hospital_1", "question": "Find the number of patients who are not using the medication of Procrastin-X.", "rationale": ["We need to find the number of patients who are not using a specific medication, 'Procrastin-X'.", "First, we identify the patients who are using 'Procrastin-X' by joining the 'Prescribes' table with the 'Medication' table on the medication code.", "We filter the results to only include prescriptions for 'Procrastin-X'.", "Next, we need to count the distinct patients from the 'Patient' table whose SSN is not in the list of patients using 'Procrastin-X'.", "We use a subquery to get the list of patients who are using 'Procrastin-X' and then count the patients from the 'Patient' table that are not in this list."], "pred_sql": "SELECT COUNT(DISTINCT Patient.SSN) AS NumberOfPatients\nFROM Patient\nWHERE Patient.SSN NOT IN (\n    SELECT Prescribes.Patient\n    FROM Prescribes\n    JOIN Medication ON Prescribes.Medication = Medication.Code\n    WHERE Medication.Name = 'Procrastin-X'\n);", "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"]}
{"sample_id": 3993, "db_id": "hospital_1", "question": "How many patients are not using Procrastin-X as medication?", "rationale": ["Identify the main goal: Count the number of patients not using a specific medication (Procrastin-X).", "Determine the relevant tables: The 'Patient' table contains patient information, and the 'Prescribes' table links patients to medications.", "To find patients not using Procrastin-X, we need to find all patients who have prescribed medications and exclude those who have Procrastin-X.", "Construct a subquery to select all patients who have been prescribed Procrastin-X from the 'Prescribes' table.", "Use the main query to count all patients from the 'Patient' table whose SSN is not in the list of patients from the subquery."], "pred_sql": "SELECT COUNT(*) AS PatientCount FROM Patient WHERE SSN NOT IN (SELECT Patient FROM Prescribes WHERE Medication = 'Procrastin-X');", "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"]}
{"sample_id": 3994, "db_id": "hospital_1", "question": "How many appointments are there?", "rationale": ["Identify the table that contains appointment data, which is the 'Appointment' table.", "To find the total number of appointments, we need to count the rows in the 'Appointment' table.", "Use the COUNT() function to count all entries in the 'Appointment' table.", "Select the count and label it as 'AppointmentCount' for clarity."], "pred_sql": "SELECT COUNT(*) AS AppointmentCount FROM Appointment;", "gold_sql": "SELECT count(*) FROM appointment", "source_tables": ["appointment"]}
{"sample_id": 3995, "db_id": "hospital_1", "question": "Count how many appointments have been made in total.", "rationale": ["Identify the table that contains appointment data, which is the 'Appointment' table.", "To count the total number of appointments, use the COUNT() function in SQL.", "Select the total count from the 'Appointment' table without any conditions, as we want the total number of appointments."], "pred_sql": "SELECT COUNT(*) AS TotalAppointments FROM Appointment;", "gold_sql": "SELECT count(*) FROM appointment", "source_tables": ["appointment"]}
{"sample_id": 3996, "db_id": "hospital_1", "question": "Find the names of nurses who are on call.", "rationale": ["Identify the table that contains nurse information, which is the 'Nurse' table.", "Determine the relevant column that contains the names of the nurses, which is 'Name'.", "Identify the table that indicates which nurses are on call, which is the 'On_Call' table.", "To find the names of nurses who are on call, we need to select the names from the 'Nurse' table where the 'EmployeeID' matches the 'Nurse' column in the 'On_Call' table.", "Construct the SQL query to select the 'Name' from the 'Nurse' table where the 'EmployeeID' is in the list of 'Nurse' identifiers from the 'On_Call' table."], "pred_sql": "SELECT Name FROM Nurse WHERE EmployeeID IN (SELECT Nurse FROM On_Call)", "gold_sql": "SELECT DISTINCT T1.name FROM nurse AS T1 JOIN on_call AS T2 ON T1.EmployeeID  =  T2.nurse", "source_tables": ["on_call", "nurse"]}
{"sample_id": 3997, "db_id": "hospital_1", "question": "What are the distinct names of nurses on call?", "rationale": ["Identify the table that contains nurse information, which is the Nurse table.", "We need to find distinct names of nurses, so we will use the SELECT DISTINCT statement.", "To find out which nurses are on call, we need to check the On_Call table, which contains the identifiers of nurses who are on call.", "We will use a subquery to select the EmployeeID of nurses from the On_Call table and then filter the Nurse table based on these IDs."], "pred_sql": "SELECT DISTINCT Name FROM Nurse WHERE EmployeeID IN (SELECT Nurse FROM On_Call)", "gold_sql": "SELECT DISTINCT T1.name FROM nurse AS T1 JOIN on_call AS T2 ON T1.EmployeeID  =  T2.nurse", "source_tables": ["on_call", "nurse"]}
{"sample_id": 3998, "db_id": "ship_mission", "question": "How many ships are there?", "rationale": ["Identify the requirement: The user wants to know the total number of ships.", "Determine the relevant table: The 'ship' table contains the information about ships.", "Use the COUNT() function to count the number of entries in the 'ship' table.", "Construct the SQL query to select the count of ships from the 'ship' table."], "pred_sql": "SELECT COUNT(*) AS total_ships FROM ship;", "gold_sql": "SELECT count(*) FROM ship", "source_tables": ["ship"]}
{"sample_id": 3999, "db_id": "ship_mission", "question": "What is the number of ships?", "rationale": ["Identify the requirement: The user wants to know the number of ships.", "Determine the relevant table: The 'ship' table contains the information about ships.", "Use the COUNT() function to count the total number of entries in the 'ship' table.", "Construct the SQL query to select the count from the 'ship' table."], "pred_sql": "SELECT COUNT(*) AS Number_of_Ships FROM ship;", "gold_sql": "SELECT count(*) FROM ship", "source_tables": ["ship"]}
