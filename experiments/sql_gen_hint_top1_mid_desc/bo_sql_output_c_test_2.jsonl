{"sample_id": "train.2612", "db_id": "inn_1", "question": "Find the name of the room with the maximum occupancy.", "rationale": ["Identify the table to query: The 'Rooms' table contains the information about room names and their maximum occupancy.", "Determine the requirement: We need to find the room name with the maximum occupancy.", "Use a subquery to find the maximum occupancy: We can use a subquery to get the maximum value of the 'maxOccupancy' column from the 'Rooms' table.", "Select the room name: Finally, we select the 'roomName' from the 'Rooms' table where the 'maxOccupancy' matches the maximum value found in the subquery."], "gold_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE maxOccupancy = (SELECT MAX(maxOccupancy) FROM Rooms);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\"\n}\n"}
{"sample_id": "train.2621", "db_id": "inn_1", "question": "What is the average minimum and price of the rooms for each different decor.", "rationale": ["Identify the relevant columns needed for the query: 'decor' from the Rooms table and 'basePrice' for calculating average and minimum prices.", "Use the AVG() function to calculate the average price of rooms for each decor type.", "Use the MIN() function to find the minimum price of rooms for each decor type.", "Group the results by the 'decor' column to get the average and minimum prices for each unique decor type.", "Construct the SQL query using the SELECT statement to retrieve the desired information from the Rooms table."], "gold_sql": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;", "source_tables": ["rooms"], "pred_sql": "SELECT decor, AVG(basePrice) AS averagePrice, MIN(basePrice) AS minimumPrice \nFROM Rooms \nGROUP BY decor;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "train.2628", "db_id": "inn_1", "question": "List the name of rooms with king or queen bed.", "rationale": ["Identify the table to query: The 'Rooms' table contains the information about room names and bed types.", "Determine the columns needed: We need the 'roomName' column to list the names of the rooms.", "Specify the condition: We are interested in rooms that have either 'king' or 'queen' beds.", "Use the SQL SELECT statement to retrieve the desired data from the 'Rooms' table, applying the WHERE clause to filter by bed types."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE bedType IN ('king', 'queen');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\"\n}\n"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["We need to find the name of each room and the number of reservations made for each room.", "To achieve this, we will select the 'roomName' from the 'Rooms' table.", "We will also count the number of reservations associated with each room, which can be done using the COUNT function on the 'Code' column from the 'Reservations' table.", "Since a room may not have any reservations, we will use a LEFT JOIN to include all rooms even if they have zero reservations.", "The join condition will be based on the 'RoomId' from the 'Rooms' table matching the 'Room' from the 'Reservations' table.", "Finally, we will group the results by 'roomName' to get the count of reservations for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservation_count\nFROM Rooms\nLEFT JOIN Reservations ON Rooms.RoomId = Reservations.Room\nGROUP BY Rooms.roomName;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\"\n}\n"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["Identify the table needed: The question asks for details of trucks, so we will use the 'Trucks' table.", "Select all columns: We need all details, so we will use SELECT *.", "Order by license number: The question specifies to order the results by the truck's license number, so we will add ORDER BY truck_licence_number."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "pred_sql": "SELECT * FROM Trucks ORDER BY truck_licence_number;", "hint": "\n"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to find customer names, so we will select 'customer_name' from the Customers table.", "To filter customers based on their address, we need to join the Customers table with the Customer_Addresses table using 'customer_id'.", "Next, we join the Customer_Addresses table with the Addresses table using 'address_id' to access the state information.", "Finally, we apply a WHERE clause to filter out customers whose state is 'California'."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT customer_name \nFROM Customers c \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nJOIN Addresses a ON ca.address_id = a.address_id \nWHERE a.state_province_county != 'California';", "hint": "\n"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["Identify the relevant tables: Delivery_Routes, Delivery_Route_Locations, and Order_Deliveries are needed to find the route with the highest number of deliveries.", "Join Delivery_Routes with Delivery_Route_Locations on route_id to link routes with their locations.", "Join the result with Order_Deliveries on location_code to associate deliveries with their respective routes.", "Group the results by route_name to count the number of deliveries for each route.", "Order the results in descending order based on the count of deliveries to find the route with the highest number.", "Limit the results to 1 to get only the top route."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "pred_sql": "SELECT route_name\nFROM Delivery_Routes\nJOIN Delivery_Route_Locations ON Delivery_Routes.route_id = Delivery_Route_Locations.route_id\nJOIN Order_Deliveries ON Delivery_Route_Locations.location_code = Order_Deliveries.location_code\nGROUP BY route_name\nORDER BY COUNT(Order_Deliveries.actual_order_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["Identify the relevant tables: PROFESSOR and CLASS are needed to find professors teaching a specific class.", "We need to count the number of distinct professors, so we will use COUNT(DISTINCT p.EMP_NUM).", "Join the PROFESSOR table with the CLASS table on the condition that the professor's employee number matches the professor number in the CLASS table.", "Filter the results to only include classes with the CLASS_CODE 'ACCT-211'."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS professor_count \nFROM PROFESSOR p \nJOIN CLASS c ON p.EMP_NUM = c.PROF_NUM \nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\"\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: PROFESSOR, DEPARTMENT, and CLASS are needed to find professors teaching a specific class.", "Join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE to get the department information for each professor.", "Join the resulting table with the CLASS table on the CRS_CODE to link professors to the classes they teach.", "Filter the results to only include classes with the CLASS_CODE 'ACCT-211'.", "Count the distinct EMP_NUM from the PROFESSOR table to get the number of unique professors teaching that class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS professor_count\nFROM PROFESSOR p\nJOIN DEPARTMENT d ON p.DEPT_CODE = d.DEPT_CODE\nJOIN CLASS c ON p.DEPT_CODE = c.CRS_CODE\nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\"\n}\n"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the relevant tables: CLASS, PROFESSOR, EMPLOYEE, and COURSE.", "We need to retrieve the first names and date of birth of professors, so we will select EMPLOYEE.EMP_FNAME and EMPLOYEE.EMP_DOB.", "Join the CLASS table with the PROFESSOR table on the condition that CLASS.PROF_NUM matches PROFESSOR.EMP_NUM to get the professors for each class.", "Join the PROFESSOR table with the EMPLOYEE table on PROFESSOR.EMP_NUM to access the first names and date of birth of the professors.", "Join the CLASS table with the COURSE table on CLASS.CRS_CODE to filter the results for the specific course ACCT-211.", "Add a WHERE clause to filter the results to only include the course with CRS_CODE 'ACCT-211'."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, EMPLOYEE.EMP_DOB \nFROM CLASS \nJOIN PROFESSOR ON CLASS.PROF_NUM = PROFESSOR.EMP_NUM \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nWHERE COURSE.CRS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["Identify the relevant table for department information, which is the DEPARTMENT table.", "We need to find the location of the History department, so we will select the DEPT_NAME and DEPT_ADDRESS columns.", "To filter for the History department, we will use a WHERE clause to specify that DEPT_NAME should be 'History'."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "pred_sql": "SELECT DEPT_NAME, DEPT_ADDRESS FROM DEPARTMENT WHERE DEPT_NAME = 'History';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the relevant table: The question asks for locations associated with a specific school code, which is found in the DEPARTMENT table.", "Select the appropriate column: The DEPT_ADDRESS column contains the addresses of the departments, which represent the locations of the school.", "Apply a filter: Use a WHERE clause to filter the results to only include departments that belong to the school with the code 'BUS'.", "Use DISTINCT to ensure that each location is listed only once, even if multiple departments share the same address."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.\"\n}\n"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["We need to find the total credit hours offered by each department.", "The relevant tables for this query are COURSE and DEPARTMENT, as well as CLASS to link courses to classes.", "We will join the COURSE table with the DEPARTMENT table on the DEPT_CODE to get the department information for each course.", "Next, we will join the CLASS table to the COURSE table on the CRS_CODE to link classes to their respective courses.", "We will use the SUM function to aggregate the total credit hours (CRS_CREDIT) for each department.", "Finally, we will group the results by DEPARTMENT.DEPT_CODE to get the total credit hours for each department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(CAST(COURSE.CRS_CREDIT AS INTEGER)) AS TOTAL_CREDIT\nFROM COURSE\nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE\nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\"\n}\n"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["The question asks for the total credits offered by each department.", "To find this information, we need to look at the 'COURSE' table, which contains the 'CRS_CREDIT' column that indicates the number of credit hours for each course.", "We will group the results by 'DEPT_CODE' to aggregate the total credits for each department.", "The SQL query will use the SUM function to calculate the total credits for each department code."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT DEPT_CODE, SUM(CRS_CREDIT) AS TOTAL_CREDITS\nFROM COURSE\nGROUP BY DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\"\n}\n"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["We need to find the school with the smallest number of professors.", "To do this, we will count the number of professors associated with each school.", "Professors are linked to departments, and departments are linked to schools through the SCHOOL_CODE.", "We will join the DEPARTMENT and PROFESSOR tables on the DEPT_CODE to get the count of professors per school.", "We will group the results by SCHOOL_CODE and count the number of professors for each school.", "Finally, we will order the results by the count of professors in ascending order and limit the result to 1 to get the school with the smallest number of professors."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "pred_sql": "SELECT SCHOOL_CODE, COUNT(PROF_NUM) AS PROFESSOR_COUNT \nFROM DEPARTMENT \nJOIN PROFESSOR ON DEPARTMENT.DEPT_CODE = PROFESSOR.DEPT_CODE \nGROUP BY SCHOOL_CODE \nORDER BY PROFESSOR_COUNT ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\"\n}\n"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["We need to find the number of professors with a Ph.D. degree in each department.", "The relevant tables are PROFESSOR and DEPARTMENT, as we need to count professors and group them by department.", "We will join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE column to associate professors with their respective departments.", "We will filter the results to include only those professors whose highest degree is 'Ph.D.' using a WHERE clause.", "Finally, we will group the results by DEPARTMENT.DEPT_CODE and count the number of professors in each group using COUNT()."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, COUNT(PROFESSOR.EMP_NUM) AS PH_D_COUNT\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nWHERE PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D.'\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\"\n}\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["Identify the relevant table: The STUDENT table contains information about students, including their department codes.", "Determine the required output: We need to count the number of students for each department.", "Use the COUNT() function to aggregate the number of students (STU_NUM) for each department (DEPT_CODE).", "Group the results by DEPT_CODE to get the count for each department.", "Construct the SQL query using SELECT, COUNT(), and GROUP BY clauses."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPT_CODE, COUNT(STU_NUM) AS student_count FROM STUDENT GROUP BY DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students grouped by their department codes from the 'student' table. The placeholder in the SELECT statement represents the department code for which the count of students is being aggregated.\"\n}\n"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["We need to find the total number of hours completed by students in each department.", "The relevant table for student credit hours is the STUDENT table, which contains the column STU_HRS for total credit hours.", "We also need to group these results by department, which is represented in the DEPARTMENT table with the DEPT_CODE column.", "To get the total hours per department, we will use the SUM function on the STU_HRS column and group the results by DEPT_CODE.", "We will join the STUDENT table with the DEPARTMENT table on the DEPT_CODE to associate students with their respective departments."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(STUDENT.STU_HRS) AS TOTAL_HOURS\nFROM STUDENT\nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\"\n}\n"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["Identify the relevant tables: COURSE, CLASS, and DEPARTMENT.", "Join the COURSE and CLASS tables on CRS_CODE to link courses with their respective classes.", "Join the resulting table with the DEPARTMENT table on DEPT_CODE to associate courses with their departments.", "Use SUM to calculate the total credit hours for each department by grouping the results by DEPT_CODE.", "Order the results in descending order based on the total credits to find the department with the most credits.", "Limit the results to 1 to get only the department with the highest total credits."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, SUM(COURSE.CRS_CREDIT) AS TOTAL_CREDITS\nFROM COURSE\nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE\nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE\nORDER BY TOTAL_CREDITS DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\"\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the relevant tables: STUDENT, ENROLL, and CLASS are needed to find the first names of students enrolled in a specific class.", "The STUDENT table contains the first names of students (STU_FNAME).", "The ENROLL table links students to classes they are enrolled in via STU_NUM and CLASS_CODE.", "The CLASS table contains the class code (CLASS_CODE) to filter for the specific class 'ACCT-211'.", "Join the ENROLL table with STUDENT on STU_NUM to get student details, and join with CLASS on CLASS_CODE to filter by the class code.", "Select the first names of students from the resulting joined tables where the class code matches 'ACCT-211'."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["Identify the tables needed: STUDENT for student names, ENROLL for enrollment details, and CLASS for class information.", "We need to find students enrolled in a specific class (ACCT-211) and who received a specific grade (C).", "Join the STUDENT table with the ENROLL table on the student number (STU_NUM) to get enrollment details for each student.", "Join the ENROLL table with the CLASS table on the class code (CLASS_CODE) to filter by the specific class (ACCT-211).", "Add a WHERE clause to filter for the class code 'ACCT-211' and the grade 'C'.", "Select the first names of the students from the STUDENT table."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211' AND ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\"\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["We need to find the department with the most students enrolled.", "First, we will create a virtual table that counts the number of students in each department by grouping the 'STUDENT' table by 'DEPT_CODE'.", "Next, we will join this virtual table with the 'DEPARTMENT' table to get the department names corresponding to the department codes.", "We will order the results by the count of students in descending order to get the department with the highest count at the top.", "Finally, we will limit the results to 1 to get only the department with the most students."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME\nFROM DEPARTMENT\nJOIN (\n    SELECT DEPT_CODE, COUNT(STU_NUM) AS student_count\n    FROM STUDENT\n    GROUP BY DEPT_CODE\n) AS dept_student_count ON DEPARTMENT.DEPT_CODE = dept_student_count.DEPT_CODE\nORDER BY student_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of students grouped by their department codes from the 'student' table. The placeholder in the SELECT statement represents the department code for which the count of students is being aggregated.\"\n}\n"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["Identify the relevant table: The CLASS table contains information about class schedules, including the room where classes are held.", "Determine the specific column needed: We need the CRS_CODE column from the CLASS table, which represents the course code.", "Filter the results: We want to find classes that are specifically held in room 'KLR209'.", "Use the SELECT statement to retrieve the distinct course codes from the CLASS table where the CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE\nFROM CLASS\nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\"\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about class locations, including the CLASS_ROOM column.", "Determine the specific condition: We need to filter the results to only include classes held in room 'KLR209'.", "Select the desired output: We want the unique course codes (CRS_CODE) associated with the classes in that room.", "Construct the SQL query: Use SELECT DISTINCT to get unique course codes from the CLASS table where the CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE \nFROM CLASS \nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\"\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed since we want student names and their grades.", "Determine the relationship: STUDENT is related to ENROLL through the STU_NUM column.", "Select the required fields: We need the first name of the students, which is in the STUDENT table (STU_FNAME).", "Filter the results: We want only those students who received a grade of 'C', which is specified in the ENROLL table (ENROLL_GRADE).", "Construct the SQL query using a JOIN to combine STUDENT and ENROLL on the STU_NUM field, and apply the WHERE clause to filter by grade 'C'."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["We need to find the first names of professors who do not teach a class.", "To do this, we will use the EMPLOYEE table to get the first names of professors.", "We will join the PROFESSOR table to link professors with their employee records.", "Next, we will perform a LEFT JOIN with the CLASS table to find any classes taught by the professors.", "By using a LEFT JOIN, we can identify professors who do not have any corresponding entries in the CLASS table.", "Finally, we will filter the results where CLASS.CLASS_CODE is NULL, indicating that the professor does not teach any class."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nLEFT JOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nLEFT JOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CLASS_CODE IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["We need to find the first names of professors who are not teaching any classes.", "To do this, we will use the EMPLOYEE table to get the first names of professors.", "We will perform a LEFT JOIN between the EMPLOYEE table and the PROFESSOR table to include all employees and their corresponding professor details.", "Next, we will perform another LEFT JOIN with the CLASS table to find out if these professors are teaching any classes.", "In the WHERE clause, we will check for NULL values in CLASS.CLASS_CODE, which indicates that the professor is not teaching any classes."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nLEFT JOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nLEFT JOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CLASS_CODE IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors and their highest degrees.", "Determine the criteria: We need to count professors who have either a Ph.D. or a Masters degree.", "Construct the SQL query: Use the COUNT function to count the number of professors meeting the criteria, filtering with a WHERE clause for the degrees."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS NumberOfProfessors\nFROM PROFESSOR\nWHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, and COURSE.", "We need to find the first name of the professor, which is in the EMPLOYEE table.", "The CLASS table contains the class information, including the professor's ID (PROF_NUM).", "The COURSE table contains the course codes (CRS_CODE) we are interested in: 'CIS-220' and 'QM-261'.", "We will join the CLASS table with the EMPLOYEE table on the professor's ID to get the professor's first name.", "We will also join the CLASS table with the COURSE table to filter by the specific course codes.", "Use a WHERE clause to specify that we want courses with the codes 'CIS-220' and 'QM-261'."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM CLASS \nJOIN EMPLOYEE ON CLASS.PROF_NUM = EMPLOYEE.EMP_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nWHERE COURSE.CRS_CODE IN ('CIS-220', 'QM-261');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["We need to find the first names of students enrolled in classes from specific departments: Accounting and Computer Info. Systems.", "To achieve this, we will join several tables: STUDENT, ENROLL, CLASS, COURSE, and DEPARTMENT.", "The STUDENT table contains the first names of students, while the ENROLL table links students to the classes they are taking.", "The CLASS table provides information about the classes, and the COURSE table gives details about the courses associated with those classes.", "The DEPARTMENT table contains the names of the departments, which we will filter to include only 'Accounting' and 'Computer Info. Systems'.", "We will use a SELECT statement to retrieve the distinct first names of students who meet these criteria."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME IN ('Accounting', 'Computer Info. Systems');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["Identify the required information: first names and office locations of professors.", "Determine the relevant tables: PROFESSOR for office details, EMPLOYEE for first names, and DEPARTMENT for department names.", "Join the PROFESSOR table with the EMPLOYEE table to get the first names of professors.", "Join the PROFESSOR table with the DEPARTMENT table to filter for the history department.", "Add a condition to filter professors who have a Ph.D."], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'History' \nAND PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["Identify the tables needed: STUDENT for student names and ENROLL for enrollment details including grades.", "Join the STUDENT table with the ENROLL table on the student identifier (STU_NUM) to link students with their grades.", "Filter the results to include only those students who received either an 'A' or a 'C' grade by using a WHERE clause with the IN operator.", "Select the distinct first and last names of the students to avoid duplicates in the result."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME, S.STU_LNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nWHERE E.ENROLL_GRADE IN ('A', 'C');", "hint": "\n"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, PROFESSOR, COURSE, and DEPARTMENT.", "We need to retrieve the first names of professors and their highest degree, so we will select EMPLOYEE.EMP_FNAME and PROFESSOR.PROF_HIGH_DEGREE.", "Join the CLASS table with the PROFESSOR table on the professor's employee number (PROF_NUM).", "Join the PROFESSOR table with the EMPLOYEE table to get the first names of the professors.", "Join the CLASS table with the COURSE table to link classes to their respective courses.", "Join the COURSE table with the DEPARTMENT table to filter by the Computer Information Systems department.", "Use a WHERE clause to specify that we only want professors from the Computer Information Systems department."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_HIGH_DEGREE \nFROM CLASS \nJOIN PROFESSOR ON CLASS.PROF_NUM = PROFESSOR.EMP_NUM \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'Computer Information Systems';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\"\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: CLASS, COURSE, and DEPARTMENT.", "We need to find the department name, so we will select DEPARTMENT.DEPT_NAME.", "The class description is in the COURSE table, so we will filter based on COURSE.CRS_DESCRIPTION.", "To link the tables, we will join CLASS and COURSE on CLASS.CRS_CODE = COURSE.CRS_CODE.", "Next, we will join COURSE and DEPARTMENT on COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE.", "Finally, we will add a WHERE clause to filter for descriptions that contain the word 'Statistics'."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME \nFROM CLASS \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE COURSE.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\"\n}\n"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["Identify the relevant table: The question asks about competition types and countries, which are found in the 'competition' table.", "Select the required columns: We need to select 'Competition_type' and 'Country' from the 'competition' table.", "Use DISTINCT to avoid duplicate entries: Since we want unique combinations of competition types and countries, we will use the DISTINCT keyword.", "Order the results: Although the hint suggests ordering by occurrences, the question does not specify a particular order, so we will order by 'Competition_type' for clarity."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT Competition_type, Country FROM competition ORDER BY Competition_type;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\"\n}\n"}
{"sample_id": "train.3355", "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["Identify the tables needed: 'club' for club names and 'player' for player names.", "Determine the relationship between the tables: 'player' has a foreign key 'Club_ID' that references 'club'.", "Use a JOIN operation to combine data from both tables based on the 'Club_ID'.", "Select the desired columns: the name of the club and the name of the player."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "pred_sql": "SELECT c.name AS club_name, p.name AS player_name \nFROM club c \nJOIN player p ON c.Club_ID = p.Club_ID;", "hint": "\n"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "We need to find the positions of players, so we will select the 'Position' column from the 'player' table.", "To find the average number of points scored by each position, we will use the AVG() function on the 'Points' column.", "We need to group the results by 'Position' to calculate the average points for each position.", "Finally, we will filter the results to include only those positions where the average points scored is greater than 20 using the HAVING clause."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "pred_sql": "SELECT Position\nFROM player\nGROUP BY Position\nHAVING AVG(Points) > 20;", "hint": "\n"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant column for player positions, which is 'Position'.", "Identify the column that contains the points scored by players, which is 'Points'.", "Formulate the condition to filter players based on their points: greater than 20 or less than 10.", "Construct the SQL SELECT statement to retrieve the 'Position' of players that meet the specified conditions."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player WHERE Points > 20 OR Points < 10;", "hint": "\n"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about different competitions, including their type and country.", "Filter for tournament competitions: We need to focus on competitions of type 'tournament'.", "Group by country: To find out how many tournaments each country participated in, we will group the results by the 'Country' column.", "Count the number of tournaments: We will use the COUNT function to count the number of tournaments for each country.", "Order the results: We will order the results in descending order based on the count of tournaments to find the country with the most tournaments.", "Limit the results: Since we only want the country with the most tournaments, we will limit the results to 1."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) AS Tournament_Count\nFROM competition\nWHERE Competition_type = 'tournament'\nGROUP BY Country\nORDER BY Tournament_Count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\"\n}\n"}
{"sample_id": "train.3384", "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about the competitions, including the type and country.", "Filter for tournament competitions: We need to focus on competitions of type 'tournament'.", "Group by country: To find out how many tournaments each country participated in, we will group the results by the 'Country' column.", "Count the occurrences: We will count the number of tournaments for each country using COUNT(*) in the SELECT statement.", "Order by count in descending order: To find the country with the most tournaments, we will order the results by the count in descending order.", "Limit the results: We only need the top result, so we will use LIMIT 1 to get the country with the most tournaments."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country FROM competition WHERE Competition_type = 'tournament' GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\"\n}\n"}
{"sample_id": "train.3388", "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["We need to find countries that have never participated in friendly-type competitions.", "To do this, we will select distinct countries from the competition table.", "We will perform a LEFT JOIN with the competition_result table to check for any participation in friendly competitions.", "We will filter the results to only include competitions of type 'friendly'.", "To ensure we only get countries that have never participated, we will check that both Club_ID_1 and Club_ID_2 are NULL in the competition_result table."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT c.Country \nFROM competition c \nLEFT JOIN competition_result cr ON c.Competition_ID = cr.Competition_ID \nWHERE c.Competition_type = 'friendly' \nAND cr.Club_ID_1 IS NULL \nAND cr.Club_ID_2 IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\"\n}\n"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["Identify the relevant table: The 'employees' table contains the necessary information about employees' names and salaries.", "Determine the required fields: We need to select the 'FIRST_NAME', 'LAST_NAME', and 'SALARY' columns from the 'employees' table.", "Apply the condition: We need to filter the results to include only those employees whose salary is below 6000, which can be done using a WHERE clause.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME, LAST_NAME, SALARY FROM employees WHERE SALARY < 6000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\"\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department id.", "To get the full name, we can concatenate the first and last names of the employees.", "We need to filter employees whose first name does not contain the letter 'M'.", "The SQL query will select from the 'employees' table and apply the necessary conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT CONCAT(e.FIRST_NAME, ' ', e.LAST_NAME) AS FULL_NAME, e.HIRE_DATE, e.SALARY, e.DEPARTMENT_ID \nFROM employees e \nWHERE e.FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate the FIRST_NAME and LAST_NAME fields from the employees table.", "The hire date and salary are directly taken from the employees table.", "The department number is represented by the DEPARTMENT_ID from the employees table.", "Filter the employees whose first name does not contain the letter 'M' using the NOT LIKE operator.", "Sort the results in ascending order by the department number (DEPARTMENT_ID).", "Construct the SQL query using the SELECT statement with the identified fields, the FROM clause to specify the employees table, the WHERE clause for filtering, and the ORDER BY clause for sorting."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE, e.SALARY, e.DEPARTMENT_ID \nFROM employees e \nWHERE e.FIRST_NAME NOT LIKE '%M%' \nORDER BY e.DEPARTMENT_ID ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department id.", "To create the full name, concatenate the first and last names using '||'.", "Filter employees whose first name does not contain the letter 'M' using the NOT LIKE operator.", "Order the results by department id in ascending order.", "Construct the SQL SELECT statement with the identified fields and conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE, e.SALARY, e.DEPARTMENT_ID\nFROM employees e\nWHERE e.FIRST_NAME NOT LIKE '%M%'\nORDER BY e.DEPARTMENT_ID ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The 'jobs' table contains job titles and salary information.", "Determine the condition: We need to find jobs with salaries over 9000, which refers to the 'MAX_SALARY' column in the 'jobs' table.", "Construct the SQL query: We will select the 'JOB_TITLE' from the 'jobs' table where 'MAX_SALARY' is greater than 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MAX_SALARY > 9000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\"\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question asks for job titles and salary ranges, which are found in the 'jobs' table.", "Select the required columns: We need to select 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY' from the 'jobs' table.", "Apply the filter condition: The question specifies that we need jobs with a maximum salary between 12000 and 18000, so we will use a WHERE clause to filter the results based on 'MAX_SALARY'.", "Construct the SQL query: Combine the selected columns, the table name, and the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY \nFROM jobs \nWHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\"\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["We need to retrieve the employee IDs and the final dates of employment for each employee.", "The relevant table for employment history is 'job_history', which contains the 'EMPLOYEE_ID' and 'END_DATE' columns.", "To get the last job end date for each employee, we can use the MAX function on the 'END_DATE' column.", "We will group the results by 'EMPLOYEE_ID' to ensure we get the latest end date for each employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT EMPLOYEE_ID, MAX(END_DATE) AS LAST_JOB_END_DATE\nFROM job_history\nGROUP BY EMPLOYEE_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.\"\n}\n"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["We need to display the average salary of employees for each department who gets a commission percentage.", "To calculate the average salary, we will use the AVG() function on the SALARY column from the employees table.", "We need to filter employees who have a commission percentage, so we will use a WHERE clause to check if COMMISSION_PCT is not NULL.", "To group the results by department, we will join the employees table with the departments table on the DEPARTMENT_ID column and use GROUP BY on the DEPARTMENT_ID.", "Finally, we will select the DEPARTMENT_ID and the calculated average salary in the SELECT clause."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, AVG(e.SALARY) AS average_salary\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nWHERE e.COMMISSION_PCT IS NOT NULL\nGROUP BY d.DEPARTMENT_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\"\n}\n"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["Identify the table needed: The 'employees' table contains salary and commission percentage information.", "Determine the condition: We need to filter employees whose commission percentage is not null.", "Calculate the average salary: Use the AVG() function to compute the average salary of the filtered employees."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT AVG(SALARY) AS average_salary\nFROM employees\nWHERE COMMISSION_PCT IS NOT NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\"\n}\n"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["Identify the relevant tables: countries and locations.", "Determine the columns needed: COUNTRY_ID from countries and the count of cities from locations.", "Establish the relationship between countries and locations using the COUNTRY_ID foreign key.", "Use a JOIN to combine the countries and locations tables based on the COUNTRY_ID.", "Use COUNT to count the number of cities for each country.", "Group the results by COUNTRY_ID to get the count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT countries.COUNTRY_ID, COUNT(locations.CITY) AS number_of_cities\nFROM countries\nJOIN locations ON countries.COUNTRY_ID = locations.COUNTRY_ID\nGROUP BY countries.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["Identify the tables needed: 'countries' for country information and 'locations' for city information.", "Determine the relationship between the tables: 'locations' has a foreign key 'COUNTRY_ID' that links to 'countries'.", "Use a JOIN to combine 'countries' and 'locations' on 'COUNTRY_ID'.", "Count the number of cities (from 'locations') for each country (from 'countries').", "Group the results by 'COUNTRY_ID' to get the count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT c.COUNTRY_ID, COUNT(l.CITY) AS CITY_COUNT\nFROM countries c\nJOIN locations l ON c.COUNTRY_ID = l.COUNTRY_ID\nGROUP BY c.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["We need to retrieve detailed information about jobs from the 'jobs' table.", "The condition specifies that we are interested in jobs done by employees who currently earn a salary of 12000 or more.", "To find these employees, we will query the 'employees' table for those with a salary >= 12000.", "Next, we need to find the job history of these employees, which is stored in the 'job_history' table.", "We will select the JOB_ID from the 'job_history' table where the EMPLOYEE_ID matches those from the previous step.", "Finally, we will use the JOB_IDs obtained from the job history to filter the 'jobs' table and retrieve the detailed information about those jobs."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "pred_sql": "SELECT j.* FROM jobs j WHERE j.JOB_ID IN (SELECT jh.JOB_ID FROM job_history jh WHERE jh.EMPLOYEE_ID IN (SELECT e.EMPLOYEE_ID FROM employees e WHERE e.SALARY >= 12000));", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\"\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the main requirement: Retrieve all information about employees who are managers.", "To find employees who are managers, we need to check the 'MANAGER_ID' field in the 'employees' table.", "We will use a subquery to get distinct 'MANAGER_ID's from the 'employees' table.", "We need to join the 'employees' table with the 'departments' table to get department names, and with the 'locations' table to get city and state/province information.", "The final query will select all columns from the 'employees' table along with the department name, city, and state/province from the joined tables."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT e.*, d.DEPARTMENT_NAME, l.CITY, l.STATE_PROVINCE \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE e.EMPLOYEE_ID IN (SELECT DISTINCT MANAGER_ID FROM employees WHERE MANAGER_ID IS NOT NULL);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["Identify the departments from the 'departments' table.", "Join the 'departments' table with the 'employees' table on the DEPARTMENT_ID to associate employees with their respective departments.", "Use a subquery to find managers who manage 4 or more employees by grouping the employees by MANAGER_ID and counting the number of EMPLOYEE_IDs for each manager, filtering with HAVING COUNT(EMPLOYEE_ID) >= 4.", "Filter the main query to only include departments where the MANAGER_ID is in the list of managers identified in the subquery.", "Select the unique DEPARTMENT_IDs from the filtered results."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nWHERE e.MANAGER_ID IN (\n    SELECT MANAGER_ID\n    FROM employees\n    GROUP BY MANAGER_ID\n    HAVING COUNT(EMPLOYEE_ID) >= 4\n) \nGROUP BY d.DEPARTMENT_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\"\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department IDs where a manager oversees 4 or more employees.", "To do this, we will join the 'departments' table with the 'employees' table on the DEPARTMENT_ID.", "We will group the results by DEPARTMENT_ID to count the number of employees in each department.", "Using the COUNT function, we will filter the groups to only include those with 4 or more employees using the HAVING clause."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_ID\nHAVING COUNT(e.EMPLOYEE_ID) >= 4;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["Identify the relevant table: The 'employees' table contains the information about employees, including their salaries.", "Determine the conditions: We need to find employees with salaries above the minimum salary and below 2500.", "Use a subquery to find the minimum salary: The minimum salary can be found in the 'jobs' table, so we will use a subquery to get that value.", "Construct the SQL query: We will select all columns from the 'employees' table where the salary is greater than the minimum salary and less than 2500."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "pred_sql": "SELECT * FROM employees WHERE SALARY > (SELECT MIN_SALARY FROM jobs) AND SALARY < 2500;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\"\n}\n"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["Identify the tables needed: employees and departments.", "We need to find employees in the same department as Clara, so we will join the employees table with itself to compare departments.", "The first join will be between the employees table (aliased as e) and the departments table (aliased as d) to get department information.", "The second join will be with the employees table again (aliased as c) to find Clara's department.", "We will select the full name (concatenation of FIRST_NAME and LAST_NAME) and HIRE_DATE of employees in the same department as Clara.", "The WHERE clause will filter the results to only include employees from the same department as the employee with FIRST_NAME 'Clara'."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN employees c ON d.DEPARTMENT_ID = c.DEPARTMENT_ID \nWHERE c.FIRST_NAME = 'Clara';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the tables needed: We need the 'employees' table to get employee names and hire dates, and the 'departments' table to filter employees by department.", "Join the 'employees' table with the 'departments' table to link employees to their respective departments.", "We need to find the department of the employee named Clara. This requires a self-join on the 'employees' table to reference Clara's department while excluding her from the results.", "Select the full names (concatenation of first and last names) and hire dates of employees who are in the same department as Clara, ensuring Clara herself is not included in the results."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.HIRE_DATE\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nJOIN employees c ON d.DEPARTMENT_ID = c.DEPARTMENT_ID\nWHERE c.FIRST_NAME = 'Clara' AND e.EMPLOYEE_ID != c.EMPLOYEE_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["We need to display the employee number and name for employees working in departments with any employee whose name contains 'T'.", "First, we will select the employee ID, first name, and last name from the 'employees' table.", "To find the relevant departments, we will join the 'employees' table with the 'departments' table on the DEPARTMENT_ID.", "Next, we need to filter the departments based on the condition that there exists at least one employee in those departments whose first or last name contains 'T'.", "We can achieve this by using a subquery that selects the DEPARTMENT_ID from the 'employees' table where the first or last name contains 'T'.", "Finally, we will use the IN clause to filter the departments in the main query based on the results of the subquery."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "pred_sql": "SELECT e1.EMPLOYEE_ID, e1.FIRST_NAME, e1.LAST_NAME \nFROM employees e1 \nJOIN departments d ON e1.DEPARTMENT_ID = d.DEPARTMENT_ID \nWHERE d.DEPARTMENT_ID IN (\n    SELECT e2.DEPARTMENT_ID \n    FROM employees e2 \n    WHERE e2.FIRST_NAME LIKE '%T%' OR e2.LAST_NAME LIKE '%T%'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\"\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main table to query: 'employees' for employee details.", "Select the columns needed: 'EMPLOYEE_ID' and 'JOB_ID'.", "Establish the condition for filtering: salary must be less than a certain value.", "Determine the value to compare against: the minimum salary of employees with the job title 'MK_MAN'.", "Use a subquery to find the minimum salary from the 'employees' table joined with the 'jobs' table where the job title is 'MK_MAN'.", "Combine the main query and the subquery to form the complete SQL statement."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID FROM employees WHERE SALARY < (SELECT MIN(SALARY) FROM employees JOIN jobs ON employees.JOB_ID = jobs.JOB_ID WHERE JOB_TITLE = 'MK_MAN')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\"\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department id for each department with more than 2 employees.", "To do this, we will join the 'employees' table with the 'departments' table on the DEPARTMENT_ID.", "We will use the SUM function to calculate the total salaries for each department.", "We will group the results by DEPARTMENT_ID to get the total salaries per department.", "To filter the departments that have more than 2 employees, we will use the HAVING clause with COUNT function."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, SUM(e.SALARY) AS total_salaries\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_ID\nHAVING COUNT(e.EMPLOYEE_ID) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To get the full name, we can concatenate the first name and last name using the '||' operator.", "We will select from the 'employees' table and filter the results to only include those employees whose salary is equal to the maximum salary in their respective department.", "To find the maximum salary for each department, we can use a subquery that selects the maximum salary from the 'employees' table, grouped by department ID. This subquery will be correlated with the outer query using the department ID."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                   FROM employees \n                   WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\"\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the tables needed: employees, departments, and locations.", "We need to retrieve the full names of employees, which requires concatenating their first and last names.", "The city of the employees is located in the locations table, which is linked to the departments table.", "Join the employees table with the departments table on DEPARTMENT_ID to get department information.", "Join the departments table with the locations table on LOCATION_ID to get the city information.", "Filter the results to include only those employees whose first names contain the letter 'Z' using the LIKE operator."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, l.CITY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE e.FIRST_NAME LIKE '%Z%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["We need to display the full name of the employee, which consists of their first and last names. This can be achieved by concatenating the 'FIRST_NAME' and 'LAST_NAME' columns from the 'employees' table.", "We also need to retrieve the name of the country where the employee is currently working. This information is stored in the 'countries' table.", "To get the country name, we need to join the 'employees' table with the 'departments' table using the 'DEPARTMENT_ID' column, as each employee belongs to a department.", "Next, we join the 'departments' table with the 'locations' table using the 'LOCATION_ID' column, since each department is associated with a location.", "Finally, we join the 'locations' table with the 'countries' table using the 'COUNTRY_ID' column to get the country name.", "We will filter the results to only include the employee with the specified 'EMPLOYEE_ID' using a WHERE clause."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT employees.FIRST_NAME || ' ' || employees.LAST_NAME AS full_name, countries.COUNTRY_NAME \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID \nJOIN countries ON locations.COUNTRY_ID = countries.COUNTRY_ID \nWHERE employees.EMPLOYEE_ID = ?;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["Identify the tables needed: 'departments' for department names and 'employees' for employee counts.", "Use a LEFT JOIN to connect 'departments' and 'employees' on the DEPARTMENT_ID column, ensuring all departments are included even if they have no employees.", "Select the department name from the 'departments' table and count the number of employees from the 'employees' table using COUNT function.", "Group the results by department name to get the count of employees per department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["We need to retrieve the department names and the count of employees in each department.", "To do this, we will join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' column.", "We will select the 'DEPARTMENT_NAME' from the 'departments' table and use the COUNT function to count the number of 'EMPLOYEE_ID' from the 'employees' table.", "Since some departments may not have any employees, we will use a LEFT JOIN to ensure all departments are included in the result.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count of employees for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS EMPLOYEE_COUNT\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\"\n}\n"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["We need to display the full name (first and last name) and salary of employees.", "To get the full name, we will concatenate the FIRST_NAME and LAST_NAME from the employees table.", "We need to join the employees table with the departments table to access department information.", "Next, we need to join the departments table with the locations table to filter by city.", "We will filter the results where the city is 'London'.", "Finally, we will select the concatenated full name and salary from the resulting joined tables."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID\nWHERE l.CITY = 'London';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["We need to retrieve the full names and salaries of employees.", "The full name can be constructed by concatenating the first and last names of employees.", "To get the employees' information, we will use the 'employees' table.", "We need to join the 'departments' table to link employees to their respective departments.", "Next, we will join the 'locations' table to filter the results based on the city, which is 'London'.", "The final SQL query will select the concatenated full name and salary from the relevant tables."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\"\n}\n"}
{"sample_id": "train.3532", "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["Identify the table that contains the song information, which is the 'song' table.", "To find the song that lasts the longest, we need to sort the songs by their duration in descending order.", "We will select the 'f_id' of the song, which is the unique identifier for the file associated with the song.", "To get only the longest song, we will limit the results to 1 after ordering them by duration."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT f_id FROM song ORDER BY duration DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their duration and the artist's name.", "Determine the requirement: We need to find the names of artists who sang the shortest song.", "Use a subquery to find the minimum duration: We can use a subquery to find the shortest duration from the 'song' table.", "Filter the results: We will filter the main query to return the artist names where the duration matches the minimum duration found in the subquery."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "pred_sql": "SELECT artist_name FROM song WHERE duration = (SELECT MIN(duration) FROM song);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["Identify the table that contains the relevant data: the 'song' table holds information about songs, including their duration.", "Determine the specific condition needed: we need to count songs with a duration of 4 minutes, which is represented as '4:00'.", "Construct the SQL query to count the number of songs that meet this condition using the COUNT() function and a WHERE clause to filter by duration."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "pred_sql": "SELECT COUNT(*) FROM song WHERE duration = '4:00';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3549", "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["Identify the tables needed: We need the 'song' table to get the ratings and the 'artist' table to filter by gender.", "Join the 'song' table with the 'artist' table on the 'artist_name' column to access the gender of the artists.", "Filter the results to include only female artists by adding a WHERE clause that checks if artist.gender = 'female'.", "Use the AVG() function to calculate the average rating of the songs produced by female artists."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "pred_sql": "SELECT AVG(song.rating) AS average_rating\nFROM song\nJOIN artist ON song.artist_name = artist.artist_name\nWHERE artist.gender = 'female';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["We need to find the file format that is used by the most files.", "To do this, we will select the 'formats' column from the 'files' table.", "We will count the number of occurrences of each format using COUNT(*) and alias it as 'file_count'.", "To get the count for each format, we will group the results by the 'formats' column using GROUP BY.", "To find the most used format, we will order the results in descending order based on 'file_count' using ORDER BY file_count DESC.", "Finally, we will limit the results to only the top entry using LIMIT 1."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(*) as file_count \nFROM files \nGROUP BY formats \nORDER BY file_count DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3556", "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["Identify the table that contains the file information, which is the 'files' table.", "We need to select the 'f_id' column from the 'files' table.", "The condition specifies that the format must be 'mp4', so we will use the LIKE operator to filter formats that contain 'mp4'.", "The resolution must be smaller than 1000, so we will use a condition to check if the resolution is less than 1000. Since resolution is stored as text, we will cast it to an integer for comparison.", "Combine the selected column and conditions to form the complete SQL query."], "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp4%' AND CAST(resolution AS INTEGER) < 1000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the relevant tables: 'artist' and 'song' are needed to find the country of origin of female artists who produced songs in Bangla.", "The 'artist' table contains the 'country' and 'gender' columns, while the 'song' table contains the 'artist_name' and 'languages' columns.", "To find the country of female artists, we need to join the 'artist' table with the 'song' table on the 'artist_name' column.", "We filter the results to include only female artists by using the condition 'artist.gender = 'female'',' and we also filter for songs that have 'Bangla' in their 'languages' column using 'song.languages LIKE '%Bangla%'.", "The final query selects the 'country' from the 'artist' table based on the specified conditions."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.country \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE artist.gender = 'female' AND song.languages LIKE '%Bangla%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant table: The 'artist' table contains information about artists, including their gender and country.", "Filter for female artists: We need to select artists where the gender is 'female'.", "Identify the language criteria: We need to find artists who have sung songs in the Bangla language.", "Use a subquery: To find artists who have sung in Bangla, we can use a subquery on the 'song' table to filter artists based on the 'languages' column.", "Select distinct countries: Finally, we want to select distinct countries from the filtered list of female artists."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT DISTINCT country FROM artist WHERE gender = 'female' AND artist_name IN (SELECT artist_name FROM song WHERE languages LIKE '%Bangla%');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the relevant tables: We need information from the 'artist' table for gender and name, and from the 'song' table for resolution.", "Join the 'artist' and 'song' tables on the common column 'artist_name' to link artists with their songs.", "To find the song with the smallest resolution, we need to use a subquery that selects the minimum resolution from the 'song' table.", "The main query will select the gender and name of the artist where the song's resolution matches the minimum resolution found in the subquery."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.gender, artist.artist_name \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.resolution = (SELECT MIN(resolution) FROM song)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\"\n}\n"}
{"sample_id": "train.3567", "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["We need to count the number of distinct artists for each file format.", "The relevant tables are 'files' and 'song' since we need to access the file formats and the artists associated with the songs.", "We will join the 'files' table with the 'song' table on the 'f_id' column to link songs to their respective files.", "We will group the results by the 'formats' column from the 'files' table to get the count of artists for each format.", "Finally, we will use COUNT(DISTINCT artist_name) to ensure we count each artist only once per format."], "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(DISTINCT artist_name) AS artist_count\nFROM files\nJOIN song ON files.f_id = song.f_id\nGROUP BY formats;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3576", "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["Identify the tables needed: We need information from the 'artist' table for names and genders, and the 'song' table for release dates.", "We will join the 'artist' table with the 'song' table on the common column 'artist_name'.", "We need to filter the results to only include songs released in March. In SQLite, we can extract the month from the 'releasedate' using the strftime function.", "The condition for March is to check if the month extracted from 'releasedate' equals '03'.", "Construct the SQL query to select the artist names and genders from the joined tables with the specified condition."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.gender \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE strftime('%m', song.releasedate) = '03';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["We need to find out the languages used in songs, which is a column in the 'song' table.", "To determine which languages are used most often, we can count the occurrences of each language in the 'song' table.", "We will use the COUNT() function to count the number of songs for each language.", "We will group the results by the 'languages' column to get the count for each distinct language.", "Finally, we will order the results in descending order to show the most frequently used languages at the top."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "pred_sql": "SELECT languages, COUNT(*) as language_count\nFROM song\nGROUP BY languages\nORDER BY language_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3590", "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["Identify the relevant table: The 'artist' table contains information about artists, including their names, countries, and genders.", "Determine the conditions: We need to filter artists based on two conditions: they must be from Britain and they must be male.", "Construct the SQL query: Use a SELECT statement to retrieve the 'artist_name' from the 'artist' table where the 'country' is 'Britain' and the 'gender' is 'male'."], "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"], "pred_sql": "SELECT artist_name FROM artist WHERE country = 'Britain' AND gender = 'male';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\"\n}\n"}
{"sample_id": "train.3598", "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["Identify the relevant table: The 'song' table contains the information about songs, including their ratings and resolutions.", "Determine the specific genre: The question asks for Bangla songs, so we will filter the results based on the genre.", "Calculate the average rating: We will use the AVG() function to calculate the average rating of the Bangla songs.", "Calculate the average resolution: Similarly, we will use the AVG() function to calculate the average resolution of the Bangla songs.", "Construct the SQL query: Combine the above elements into a single SQL query that selects the average rating and resolution for Bangla songs."], "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"], "pred_sql": "SELECT AVG(s.rating) AS average_rating, AVG(s.resolution) AS average_resolution \nFROM song s \nWHERE s.genre_is = 'Bangla';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\"\n}\n"}
{"sample_id": "train.3599", "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["Identify the relevant table: The 'song' table contains the resolution and duration of songs.", "Determine the condition: We need songs with a duration of 3 minutes, which is represented as '3:00'.", "Select the maximum and minimum resolution: Use the MAX() and MIN() functions to get the highest and lowest resolution values respectively.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE condition to filter the results."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "pred_sql": "SELECT MAX(resolution) AS max_resolution, MIN(resolution) AS min_resolution \nFROM song \nWHERE duration = '3:00';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\"\n}\n"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["Identify the relevant table: The 'song' table contains the necessary columns for duration, resolution, and languages.", "Determine the required aggregations: We need to find the maximum duration and resolution for songs, which can be achieved using the MAX() function.", "Group the results by languages: To get the maximum values for each language, we will use the GROUP BY clause on the 'languages' column.", "Order the results: The results should be ordered by languages for better readability, which can be done using the ORDER BY clause."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "pred_sql": "SELECT languages, MAX(duration) AS max_duration, MAX(resolution) AS max_resolution\nFROM song\nGROUP BY languages\nORDER BY languages;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the relevant tables: We need to use the 'song' table to get the duration and rating of songs, and the 'genre' table to group the songs by genre.", "Determine the required fields: We need the genre name, the shortest duration of songs, and the lowest rating of songs.", "Use aggregate functions: To find the shortest duration, we will use MIN(song.duration), and for the lowest rating, we will use MIN(song.rating).", "Join the tables: We need to join the 'song' table with the 'genre' table on the genre name to access the genre information for each song.", "Group the results: We will group the results by genre to get the shortest duration and lowest rating for each genre.", "Order the results: Finally, we will order the results by genre name for better readability."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "pred_sql": "SELECT genre.g_name, MIN(song.duration) AS shortest_duration, MIN(song.rating) AS lowest_rating\nFROM song\nJOIN genre ON song.genre_is = genre.g_name\nGROUP BY genre.g_name\nORDER BY genre.g_name;", "hint": "\n"}
{"sample_id": "train.3607", "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["Identify the tables involved: We need information from the 'artist' table and the 'song' table.", "Determine the columns to select: We want the artist's name and country, which are in the 'artist' table.", "Establish the relationship between tables: The 'artist' table can be joined with the 'song' table on the 'artist_name' column.", "Set the condition for filtering: We need to filter songs based on their resolution being greater than 900, which is a condition on the 'song' table."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.country \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.resolution > 900;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3619", "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their languages and the artist associated with each song.", "Filter songs by language: We need to filter the songs to only include those that have 'Bangla' in the 'languages' column.", "Count the number of songs per artist: We will group the results by 'artist_name' and count the number of songs for each artist using COUNT(song_name).", "Order the results: To find the top artists, we will order the results in descending order based on the count of songs.", "Limit the results: We will limit the output to the top 3 artists using LIMIT 3."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist_name, COUNT(song_name) AS song_count\nFROM song\nWHERE languages LIKE '%Bangla%'\nGROUP BY artist_name\nORDER BY song_count DESC\nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3623", "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["Identify the columns needed: duration, file size, and format of songs.", "Determine the relevant tables: 'song' for song details and 'files' for file details.", "Establish the relationship between the tables: 'song' and 'files' are linked by the 'f_id' column.", "Filter the results to include only songs of the genre 'pop'.", "Order the results by the song title (song_name).", "Construct the SQL query using SELECT, JOIN, WHERE, and ORDER BY clauses."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT song.duration, files.file_size, files.formats \nFROM song \nJOIN files ON song.f_id = files.f_id \nWHERE song.genre_is = 'pop' \nORDER BY song.song_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "Determine the columns needed: 'duration' from 'song', 'file_size' and 'formats' from 'files'.", "Establish the relationship between the tables using the foreign key: 'song.f_id' relates to 'files.f_id'.", "Filter the results to include only pop songs by using the condition 'WHERE song.genre_is = 'pop''.", "Order the results alphabetically by song title using 'ORDER BY song.song_name ASC'."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT song.duration, files.file_size, files.formats \nFROM song \nJOIN files ON song.f_id = files.f_id \nWHERE song.genre_is = 'pop' \nORDER BY song.song_name ASC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\"\n}\n"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the relevant tables: salary and team.", "We need to calculate the average salary, so we will use the AVG() function on the salary column from the salary table.", "To link the salary data to the team, we will join the salary table with the team table using the team_id column.", "We need to filter the results to only include players from the 'Boston Red Stockings' team, so we will add a WHERE clause to specify this condition."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "pred_sql": "SELECT AVG(salary.salary) AS average_salary\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nWHERE team.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\"\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["We need to find the countries with the least number of players.", "To do this, we will select the 'birth_country' from the 'player' table.", "We will count the number of players from each country using COUNT(player_id).", "We will group the results by 'birth_country' to get the count for each country.", "To find the least players, we will order the results in ascending order based on the count of players.", "Finally, we will limit the results to the top 3 countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count \nFROM player \nGROUP BY birth_country \nORDER BY player_count ASC \nLIMIT 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of countries where players were born, grouped by country and ordered by the number of players from each country in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of countries to return.\"\n}\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["We need to find the highest salary for each team, which requires us to group the salary data by team.", "The salary table contains the salary information along with the team_id, which we can use to join with the team table.", "The team table contains the team names and their corresponding IDs.", "We will use a SQL query that selects the team name, team ID, and the maximum salary from the salary table.", "We will join the salary table with the team table on the team_id column to get the team names.", "We will group the results by team ID and team name to ensure we get the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM salary\nJOIN team ON salary.team_id = team.team_id\nGROUP BY team.team_id, team.name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\"\n}\n"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["Identify the tables needed: 'team' for team details and 'salary' for salary information.", "We need to join the 'team' table with the 'salary' table on 'team_id' to associate each team with its salaries.", "We want to select the team name and team id, along with the maximum salary for each team.", "Use the MAX() function to find the maximum salary for each team.", "Group the results by team id and team name to ensure we get one result per team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM team\nJOIN salary ON team.team_id = salary.team_id\nGROUP BY team.team_id, team.name;", "hint": "\n"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["Identify the relevant tables: We need the 'team' table for team names and IDs, and the 'salary' table for salary information.", "Join the 'team' and 'salary' tables on 'team_id' to associate teams with their salaries.", "Group the results by 'team_id' to calculate the average salary for each team.", "Use the AVG() function to compute the average salary for each team.", "Order the results in ascending order based on the average salary to find the lowest.", "Limit the results to 1 to get only the team with the lowest average salary."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id\nFROM team\nJOIN salary ON team.team_id = salary.team_id\nGROUP BY team.team_id\nORDER BY AVG(salary.salary) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["Identify the tables needed: We need the 'player' table for player names and the 'player_award' table to check for awards won in specific years.", "Join the 'player' table with the 'player_award' table twice: one for the year 1960 and another for the year 1961. This allows us to find players who won awards in both years.", "Select the first and last names of the players who meet the criteria."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last\nFROM player p\nJOIN player_award pa1 ON p.player_id = pa1.player_id\nJOIN player_award pa2 ON p.player_id = pa2.player_id\nWHERE pa1.year = 1960 AND pa2.year = 1961;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\"\n}\n"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the columns to select: We need to select 'name_given' for the first name and 'name_last' for the last name.", "Establish the conditions: We want players with a weight greater than 220 or a height shorter than 75.", "Construct the SQL query: Use a SELECT statement to retrieve the specified columns from the 'player' table with the appropriate WHERE clause for the conditions."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_given, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players from the 'player' table who have a specified year of death. The placeholder in the WHERE clause represents the year of death.\"\n}\n"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the columns needed: We need 'name_first' and 'name_last' for the player's names.", "Establish the conditions: We want players with a weight greater than 220 or a height less than 75.", "Construct the SQL query: Use a SELECT statement to retrieve the names from the 'player' table with the specified conditions in the WHERE clause."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\"\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) of the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Select the maximum wins from the filtered results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\"\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) for the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins for the specified team."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason p\nJOIN team t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\"\n}\n"}
