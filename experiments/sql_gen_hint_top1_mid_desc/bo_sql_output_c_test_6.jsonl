{"sample_id": "train.6777", "db_id": "activity_1", "question": "Show the names of all the activities Mark Giuliano participates in.", "rationale": ["Identify the tables involved: Activity, Faculty_Participates_in, and Faculty.", "We need to find activities that a specific faculty member, Mark Giuliano, participates in.", "Join the Activity table with Faculty_Participates_in on actid to link activities with faculty participation.", "Join the Faculty table to get the names of faculty members based on their unique identifier (FacID).", "Filter the results where the first name is 'Mark' and the last name is 'Giuliano' to get the specific faculty member's activities."], "gold_sql": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  'Mark' AND T1.lname  =  'Giuliano'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name \nFROM Activity \nJOIN Faculty_Participates_in ON Activity.actid = Faculty_Participates_in.actid \nJOIN Faculty ON Faculty_Participates_in.FacID = Faculty.FacID \nWHERE Faculty.Fname = 'Mark' AND Faculty.Lname = 'Giuliano';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\"\n}\n"}
{"sample_id": "train.6779", "db_id": "activity_1", "question": "Show the first and last name of all the faculty members who participated in some activity, together with the number of activities they participated in.", "rationale": ["We need to retrieve the first and last names of faculty members who participated in activities.", "The relevant tables for this query are 'Faculty' and 'Faculty_Participates_in'.", "We will join these two tables on the 'FacID' column to link faculty members with their activities.", "To count the number of activities each faculty member participated in, we will use the COUNT() function on the 'actid' from the 'Faculty_Participates_in' table.", "We will group the results by 'FacID', 'Fname', and 'Lname' to ensure we get a count for each faculty member."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname, Faculty.Lname, COUNT(Faculty_Participates_in.actid) AS num_activities\nFROM Faculty\nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID\nGROUP BY Faculty.FacID, Faculty.Fname, Faculty.Lname;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\"\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: We need to find students who participate in activities, so we will use the 'Participates_in' and 'Student' tables.", "Determine the columns needed: We need the student IDs (stuid) from the 'Participates_in' table and we need to filter based on the age of the students from the 'Student' table.", "Join the tables: We will join 'Participates_in' with 'Student' on the student ID to get the necessary information about the students who participate in activities.", "Apply the filter: We will add a WHERE clause to filter students who are under 20 years old."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT p.stuid \nFROM Participates_in p \nJOIN Student s ON p.stuid = s.StuID \nWHERE s.Age < 20;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\"\n}\n"}
{"sample_id": "train.6797", "db_id": "activity_1", "question": "Find the first names of professors who are not playing Canoeing or Kayaking.", "rationale": ["Identify the main table to query from, which is the Faculty table to get the first names of professors.", "We need to filter out professors who are participating in Canoeing or Kayaking activities.", "To do this, we will use a subquery that selects the FacID of faculty members participating in these activities.", "The subquery will join the Faculty_Participates_in table with the Activity table to filter based on the activity names.", "The main query will select distinct first names from the Faculty table where the FacID is not in the results of the subquery."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT DISTINCT Faculty.Fname \nFROM Faculty \nWHERE Faculty.FacID NOT IN (\n    SELECT Faculty_Participates_in.FacID \n    FROM Faculty_Participates_in \n    JOIN Activity ON Faculty_Participates_in.actid = Activity.actid \n    WHERE Activity.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\"\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the main entities involved: Faculty and their activities.", "We need to find faculty members who do not participate in specific activities (Canoeing and Kayaking).", "Use a subquery to find faculty IDs that are associated with Canoeing or Kayaking activities.", "The subquery will join the Faculty_Participates_in table with the Activity table to filter based on activity names.", "The main query will select distinct first names from the Faculty table where the faculty ID is not in the list obtained from the subquery."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT DISTINCT Faculty.Fname \nFROM Faculty \nWHERE Faculty.FacID NOT IN (\n    SELECT Faculty_Participates_in.FacID \n    FROM Faculty_Participates_in \n    JOIN Activity ON Faculty_Participates_in.actid = Activity.actid \n    WHERE Activity.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\"\n}\n"}
{"sample_id": "train.6799", "db_id": "activity_1", "question": "Find the first names of the faculty members who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members who participate in specific activities, which requires joining the Faculty table with the Faculty_Participates_in table on the FacID.", "Next, we join the Activity table to filter the activities by their names (Canoeing and Kayaking).", "The final output should select the first names (Fname) of the faculty members who meet the criteria."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Faculty.Fname \nFROM Faculty \nJOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID \nJOIN Activity ON Faculty_Participates_in.actid = Activity.actid \nWHERE Activity.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\"\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: We need to find student IDs from the Participates_in table and the activity names from the Activity table.", "Determine the relationship: The Participates_in table has a foreign key actid that links to the Activity table's actid.", "Filter the activities: We are specifically looking for students who participate in 'Canoeing' and 'Kayaking'.", "Construct the SQL query: Use a SELECT statement to get the student IDs, join the Participates_in table with the Activity table on actid, and filter the results based on the activity names."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT p.stuid \nFROM Participates_in p \nJOIN Activity a ON p.actid = a.actid \nWHERE a.activity_name IN ('Canoeing', 'Kayaking');", "hint": "\n"}
{"sample_id": "train.6825", "db_id": "flight_4", "question": "Find the number of routes operated by American Airlines.", "rationale": ["Identify the relevant table: The 'routes' table contains information about the routes operated by airlines.", "Determine the condition: We need to find routes operated by 'American Airlines'.", "Use a subquery to find the airline ID (alid) for 'American Airlines' from the 'airlines' table.", "Count the number of routes in the 'routes' table where the airline ID matches the one found in the subquery."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT COUNT(*) AS number_of_routes \nFROM routes \nWHERE alid = (SELECT alid FROM airlines WHERE name = 'American Airlines');", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.6826", "db_id": "flight_4", "question": "How many routes does American Airlines operate?", "rationale": ["Identify the airline of interest: American Airlines.", "Find the unique identifier (alid) for American Airlines from the airlines table.", "Count the number of routes in the routes table where the alid matches that of American Airlines."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT COUNT(*) AS route_count \nFROM routes \nWHERE alid = (SELECT alid FROM airlines WHERE name = 'American Airlines')", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\"\n}\n"}
{"sample_id": "train.6831", "db_id": "flight_4", "question": "Find the name, city, and country of the airport that has the highest latitude.", "rationale": ["To find the airport with the highest latitude, we need to look at the 'y' coordinate in the airports table, as it represents the latitude.", "We will use a subquery to select the 'apid' of the airport with the maximum 'y' value.", "The outer query will then select the 'name', 'city', and 'country' of the airport that corresponds to this 'apid'.", "The final SQL query combines these elements to retrieve the desired information."], "gold_sql": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT 1", "source_tables": ["airports"], "pred_sql": "SELECT name, city, country FROM airports WHERE apid = (SELECT apid FROM airports ORDER BY y DESC LIMIT 1);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\"\n}\n"}
{"sample_id": "train.6834", "db_id": "flight_4", "question": "What is the name and city of the airport that the most routes end at?", "rationale": ["Identify the relevant tables: 'airports' for airport details and 'routes' for route information.", "We need to find the airport that has the most routes ending at it, which means we will focus on the 'dst_apid' in the 'routes' table.", "Join the 'airports' table with the 'routes' table on the destination airport ID ('dst_apid').", "Group the results by the airport ID to count the number of routes for each airport.", "Order the results in descending order based on the count of routes to find the airport with the most routes.", "Limit the results to 1 to get only the airport with the highest count."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, airports.city\nFROM airports\nJOIN routes ON airports.apid = routes.dst_apid\nGROUP BY airports.apid\nORDER BY COUNT(routes.rid) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\"\n}\n"}
{"sample_id": "train.6838", "db_id": "flight_4", "question": "What is the name and city of the airport from most of the routes start?", "rationale": ["We need to find the airport that most routes start from, which means we need to count the number of routes for each source airport.", "To do this, we will join the 'routes' table with the 'airports' table on the source airport ID ('src_apid').", "We will select the airport name and city from the 'airports' table.", "We will group the results by the airport name and city to get the count of routes for each airport.", "We will order the results by the count of routes in descending order to get the airport with the most routes at the top.", "Finally, we will limit the results to 1 to get only the airport with the most routes."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, airports.city\nFROM routes\nJOIN airports ON routes.src_apid = airports.apid\nGROUP BY airports.name, airports.city\nORDER BY COUNT(routes.rid) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\"\n}\n"}
{"sample_id": "train.6841", "db_id": "flight_4", "question": "Which countries has the most number of airlines?", "rationale": ["Identify the table that contains information about airlines, which is the 'airlines' table.", "We need to count the number of airlines for each country, so we will use the COUNT() function.", "To group the results by country, we will use the GROUP BY clause on the 'country' column.", "To get the countries with the most airlines, we will order the results in descending order using ORDER BY airline_count DESC."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country, COUNT(*) AS airline_count\nFROM airlines\nGROUP BY country\nORDER BY airline_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\"\n}\n"}
{"sample_id": "train.6842", "db_id": "flight_4", "question": "What is the name of the country with the most number of home airlines?", "rationale": ["We need to find the country with the most number of home airlines.", "To do this, we will count the number of airlines grouped by their country.", "We will use the COUNT() function to count the number of airlines for each country.", "We will group the results by the 'country' column in the airlines table.", "To get the country with the most airlines, we will order the results in descending order based on the count of airlines.", "Finally, we will limit the results to just one entry to get the country with the highest count."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country, COUNT(*) as airline_count FROM airlines GROUP BY country ORDER BY airline_count DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\"\n}\n"}
{"sample_id": "train.6858", "db_id": "flight_4", "question": "What are the cities that have more than 2 airports sorted by number of airports?", "rationale": ["Identify the relevant table: The 'airports' table contains information about airports, including their cities.", "Count the number of airports in each city: Use the COUNT function to count the number of airport IDs (apid) for each city.", "Group the results by city: Use the GROUP BY clause to group the results based on the city.", "Filter cities with more than 2 airports: Use the HAVING clause to filter out cities that have 2 or fewer airports.", "Sort the results: Use the ORDER BY clause to sort the cities by the number of airports in descending order."], "gold_sql": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)", "source_tables": ["airports"], "pred_sql": "SELECT city, COUNT(apid) AS airport_count \nFROM airports \nGROUP BY city \nHAVING COUNT(apid) > 2 \nORDER BY airport_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\"\n}\n"}
{"sample_id": "train.6862", "db_id": "flight_4", "question": "For each  airport name, how many routes start at that airport, ordered from most to least?", "rationale": ["We need to count the number of routes that start at each airport.", "To do this, we will join the 'airports' table with the 'routes' table on the airport ID, where the airport ID in the 'airports' table matches the source airport ID in the 'routes' table.", "We will select the airport name and the count of routes (using COUNT(routes.rid)) as 'route_count'.", "We will group the results by the airport name to get the count for each airport.", "Finally, we will order the results by 'route_count' in descending order to show the airports with the most routes first."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, COUNT(routes.rid) AS route_count \nFROM airports \nJOIN routes ON airports.apid = routes.src_apid \nGROUP BY airports.name \nORDER BY route_count DESC;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\"\n}\n"}
{"sample_id": "train.6867", "db_id": "flight_4", "question": "For each country and airline name, how many routes are there?", "rationale": ["We need to count the number of routes for each airline grouped by their country.", "To achieve this, we will use a SQL SELECT statement that includes the country and airline name from the airlines table.", "We will join the routes table to the airlines table using the airline ID (alid) as the foreign key.", "We will use a LEFT JOIN to ensure we include all airlines even if they have no routes.", "We will use the COUNT function to count the number of routes (rid) for each airline.", "Finally, we will group the results by both the country and the airline name to get the desired counts."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT airlines.country, airlines.name, COUNT(routes.rid) AS route_count\nFROM airlines\nLEFT JOIN routes ON airlines.alid = routes.alid\nGROUP BY airlines.country, airlines.name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\"\n}\n"}
{"sample_id": "train.6868", "db_id": "flight_4", "question": "What is the total number of routes for each country and airline in that country?", "rationale": ["We need to find the total number of routes for each country and airline.", "To do this, we will join the 'routes' table with the 'airlines' table on the airline ID (alid).", "We will select the country from the airlines table and the airline name from the routes table.", "We will count the number of routes (rid) for each combination of country and airline.", "Finally, we will group the results by country and airline to get the total count for each combination."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT a.country, r.airline, COUNT(r.rid) AS total_routes\nFROM routes r\nJOIN airlines a ON r.alid = a.alid\nGROUP BY a.country, r.airline;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\"\n}\n"}
{"sample_id": "train.6873", "db_id": "flight_4", "question": "Find the number of routes that have destination John F Kennedy International Airport.", "rationale": ["Identify the requirement: We need to find the number of routes that have a specific destination airport, which is John F Kennedy International Airport.", "The relevant table for this query is 'routes', as it contains information about the routes and their destination airports.", "We will use the COUNT() function to count the number of routes that match the specified destination.", "The WHERE clause will filter the results to only include routes where the destination airport name (dst_ap) is 'John F Kennedy International Airport'.", "Finally, we will select the count of these routes."], "gold_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'", "source_tables": ["airports", "routes"], "pred_sql": "SELECT COUNT(*) AS route_count \nFROM routes \nWHERE dst_ap = 'John F Kennedy International Airport';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\"\n}\n"}
{"sample_id": "train.6880", "db_id": "flight_4", "question": "What is the name of the airline with the most routes?", "rationale": ["We need to find the airline with the most routes.", "To do this, we will join the 'airlines' table with the 'routes' table on the airline ID (alid).", "We will group the results by the airline name to count the number of routes each airline has.", "We will order the results in descending order based on the count of routes.", "Finally, we will limit the results to 1 to get the airline with the most routes."], "gold_sql": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT airline FROM airlines JOIN routes ON airlines.alid = routes.alid GROUP BY airline ORDER BY COUNT(routes.rid) DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\"\n}\n"}
{"sample_id": "train.6883", "db_id": "flight_4", "question": "Find the busiest destination airport that runs most number of routes in China.", "rationale": ["Identify the relevant tables: 'routes' for route information and 'airports' for airport details.", "We need to find the busiest destination airport in China, so we will focus on the 'dst_ap' (destination airport name) from the 'routes' table and join it with the 'airports' table to filter by country.", "Use a JOIN operation to connect 'routes' and 'airports' on the destination airport ID ('dst_apid' in 'routes' and 'apid' in 'airports').", "Filter the results to include only those airports located in China by using a WHERE clause on the 'country' column of the 'airports' table.", "Group the results by destination airport name ('dst_ap') and count the number of routes for each airport using COUNT(rid).", "Order the results in descending order based on the count of routes to find the busiest airport.", "Limit the results to 1 to get only the busiest destination airport."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT dst_ap, COUNT(rid) AS route_count\nFROM routes r\nJOIN airports a ON r.dst_apid = a.apid\nWHERE a.country = 'China'\nGROUP BY dst_ap\nORDER BY route_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\"\n}\n"}
{"sample_id": "train.6884", "db_id": "flight_4", "question": "What is the name of the airport that is the destination of the most number of routes that start in China?", "rationale": ["Identify the relevant tables: 'routes' for route information and 'airports' for airport details.", "We need to find the destination airport name ('dst_ap') that has the most routes starting from China.", "Join the 'routes' table with the 'airports' table on the destination airport ID ('dst_apid' = 'apid').", "Filter the results to include only those routes where the source airport is in China (using the country column in the airports table).", "Group the results by destination airport name to count the number of routes for each destination.", "Order the results in descending order based on the count of routes to find the most popular destination.", "Limit the results to 1 to get only the top destination airport."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT dst_ap, COUNT(*) as route_count\nFROM routes r\nJOIN airports a ON r.dst_apid = a.apid\nWHERE a.country = 'China'\nGROUP BY dst_ap\nORDER BY route_count DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\"\n}\n"}
{"sample_id": "train.6980", "db_id": "culture_company", "question": "Show all publishers which do not have a book in 1989.", "rationale": ["We need to find all publishers that do not have a book published in 1989.", "First, we will select distinct publishers from the 'book_club' table.", "Next, we will create a subquery to find all publishers that have published a book in 1989.", "We will use the NOT IN clause to filter out those publishers from the main query, ensuring we only get publishers without books in 1989."], "gold_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989", "source_tables": ["book_club"], "pred_sql": "SELECT DISTINCT Publisher \nFROM book_club \nWHERE Publisher NOT IN (\n    SELECT DISTINCT Publisher \n    FROM book_club \n    WHERE Year = '1989'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of publishers from the 'book_club' table, grouped by the publisher's name. The results are ordered by the number of books published by each publisher in descending order, with a limit on the number of publishers returned based on a specified number.\"\n}\n"}
{"sample_id": "train.6990", "db_id": "culture_company", "question": "Show all director names who have a movie in the year 1999 or 2000.", "rationale": ["Identify the table that contains the director information, which is the 'movie' table.", "Determine the relevant column for the year of the movie, which is 'Year'.", "Specify the years of interest, which are 1999 and 2000.", "Use the SQL 'SELECT' statement to retrieve the 'Director' column from the 'movie' table.", "Use 'DISTINCT' to ensure that each director is listed only once, even if they have multiple movies in those years.", "Use the 'WHERE' clause to filter the results to only include movies from the years 1999 and 2000."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6991", "db_id": "culture_company", "question": "Which directors had a movie in either 1999 or 2000?", "rationale": ["Identify the relevant table: The question pertains to movie directors, so we will focus on the 'movie' table.", "Determine the columns needed: We need the 'Director' column to answer the question.", "Filter the results: We need to filter the movies based on the years 1999 and 2000.", "Use the DISTINCT keyword: Since we want to know which directors had movies in those years, we should use DISTINCT to avoid duplicate entries for directors who may have multiple movies in those years."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6996", "db_id": "culture_company", "question": "Show the movie titles and book titles for all companies in China.", "rationale": ["Identify the tables needed: culture_company, movie, and book_club.", "Determine the columns to select: movie titles and book titles.", "Establish the relationships between the tables using JOINs: culture_company to movie and culture_company to book_club.", "Filter the results to only include companies in China using a WHERE clause."], "gold_sql": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  'China'", "source_tables": ["culture_company", "movie", "book_club"], "pred_sql": "SELECT movie.Title AS Movie_Title, book_club.Book_Title AS Book_Title\nFROM culture_company\nJOIN movie ON culture_company.movie_id = movie.movie_id\nJOIN book_club ON culture_company.book_club_id = book_club.book_club_id\nWHERE culture_company.Company_name = 'China';", "hint": "\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: 'cars_data' for horsepower and 'car_names' for car models.", "Join the 'cars_data' table with the 'car_names' table on the 'Id' and 'MakeId' columns to associate horsepower with car models.", "Select the 'Model' and 'Horsepower' columns from the joined tables.", "Order the results by 'Horsepower' in ascending order to find the minimum.", "Limit the results to 1 to get only the model with the minimum horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId ORDER BY Horsepower ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.103", "db_id": "car_1", "question": "Which distinct car models are the produced after 1980?", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data.", "We need to select distinct car models, so we will use SELECT DISTINCT.", "Join the model_list table with the car_names table on the Model column to get the car names associated with each model.", "Then, join the resulting table with the cars_data table on the MakeId to access the manufacturing year of each car model.", "Filter the results to include only those models manufactured after 1980 using the WHERE clause."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "pred_sql": "SELECT DISTINCT ml.Model \nFROM model_list ml \nJOIN car_names cn ON ml.Model = cn.Model \nJOIN cars_data cd ON cn.MakeId = cd.Id \nWHERE cd.Year > 1980;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.106", "db_id": "car_1", "question": "What is the name of each continent and how many car makers are there in each one?", "rationale": ["Identify the tables needed: continents, countries, and car_makers.", "We need to count the number of car makers for each continent, so we will use the COUNT() function.", "Join the continents table with the countries table on the ContId and Continent columns.", "Then, join the countries table with the car_makers table on the CountryId and Country columns.", "Group the results by continent to get the count of car makers for each continent."], "gold_sql": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;", "source_tables": ["countries", "car_makers", "continents"], "pred_sql": "SELECT c.Continent, COUNT(cm.Id) AS CarMakerCount\nFROM continents c\nJOIN countries co ON c.ContId = co.Continent\nJOIN car_makers cm ON co.CountryId = cm.Country\nGROUP BY c.Continent;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: 'cars_data' for car performance data and 'car_names' for car make and model information.", "We need to find the 'Accelerate' value for a specific car make and model, which is 'amc hornet sportabout'.", "Join the 'cars_data' table with the 'car_names' table on the appropriate foreign key (cars_data.Id = car_names.MakeId).", "Filter the results to only include rows where the 'Model' is 'hornet sportabout' and the 'Make' is 'amc'.", "Select the 'Accelerate' column from the resulting joined table."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT cars_data.Accelerate \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE car_names.Model = 'hornet sportabout' AND car_names.Make = 'amc'", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the relevant tables: car_makers and countries.", "We need to count distinct car makers, so we will use COUNT(DISTINCT car_makers.Id).", "To filter car makers based in France, we need to join the car_makers table with the countries table on the country identifier.", "The WHERE clause will filter the results to only include countries where the CountryName is 'France'."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT car_makers.Id) AS NumberOfCarMakers\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nWHERE countries.CountryName = 'France';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.114", "db_id": "car_1", "question": "What is the number of makers of care in France?", "rationale": ["Identify the relevant tables: We need to find the number of car makers in France, so we will use the 'car_makers' and 'countries' tables.", "Determine the relationship: The 'car_makers' table has a foreign key 'Country' that references 'countries.CountryId'. We will join these two tables on this key.", "Filter for France: We need to filter the results to only include car makers based in France. This will be done using a WHERE clause that checks for 'countries.CountryName = 'France'.", "Count distinct makers: We want the number of unique car makers, so we will use COUNT(DISTINCT car_makers.Id) to get the count of unique car maker IDs."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT car_makers.Id) AS NumberOfMakers\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nWHERE countries.CountryName = 'France';", "hint": "\n"}
{"sample_id": "dev.115", "db_id": "car_1", "question": "How many car models are produced in the usa?", "rationale": ["Identify the relevant tables: model_list, car_makers, and countries.", "We need to count distinct car models, so we will use COUNT(DISTINCT ml.Model).", "Join the model_list table with the car_makers table on the Maker column.", "Join the car_makers table with the countries table on the Country column.", "Filter the results to include only those car makers based in the USA by adding a WHERE clause that checks for 'USA' in the CountryName column."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "pred_sql": "SELECT COUNT(DISTINCT ml.Model) AS NumberOfCarModels\nFROM model_list ml\nJOIN car_makers cm ON ml.Maker = cm.Id\nJOIN countries c ON cm.Country = c.CountryId\nWHERE c.CountryName = 'USA';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the countries in Europe by filtering the 'countries' table where the continent is Europe.", "Join the 'car_makers' table to the 'countries' table to find car manufacturers based in those countries.", "Create a subquery that counts the number of car manufacturers for each country by joining 'model_list' and 'car_makers' tables, grouping by the maker, and filtering to include only those with at least 3 manufacturers.", "Join this subquery back to the main query to filter countries that have at least 3 car manufacturers.", "Select the distinct country names from the resulting joined tables."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName\nFROM countries c\nJOIN car_makers cm ON c.CountryId = cm.Country\nJOIN (SELECT Maker, COUNT(*) as ManufacturerCount\n      FROM model_list ml\n      JOIN car_makers cm ON ml.Maker = cm.Id\n      GROUP BY ml.Maker\n      HAVING COUNT(*) >= 3) as subquery ON cm.Id = subquery.Maker\nWHERE c.Continent = (SELECT ContId FROM continents WHERE Continent = 'Europe')\nGROUP BY c.CountryName;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the relevant tables: 'cars_data' for horsepower and cylinders, and 'car_names' for the make of the car.", "We need to filter the results to only include car models with 3 cylinders, which will be done using a WHERE clause.", "To find the maximum horsepower, we will use the MAX() function on the 'Horsepower' column from the 'cars_data' table.", "We will join 'cars_data' with 'car_names' on the 'Id' and 'MakeId' columns to get the make of the car.", "Finally, we will group the results by the car make to ensure we get the maximum horsepower for each make."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(cars_data.Horsepower) AS MaxHorsepower, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Cylinders = 3 \nGROUP BY car_names.Make;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.133", "db_id": "car_1", "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.", "rationale": ["Identify the relevant tables: 'car_names' for car models and 'cars_data' for MPG.", "Join 'car_names' and 'cars_data' on the MakeId to access both model names and their MPG.", "Order the results by MPG in descending order to find the model with the highest fuel efficiency.", "Limit the results to 1 to get only the top model that saves the most gasoline."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, MPG FROM car_names JOIN cars_data ON car_names.MakeId = cars_data.Id ORDER BY MPG DESC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["Identify the relevant tables: We need to work with the 'car_makers' and 'model_list' tables to find car makers and their models.", "Join the tables: We will join 'car_makers' with 'model_list' on the 'Id' and 'Maker' columns respectively to associate each maker with their models.", "Group the results: We will group the results by the maker's Id and name to aggregate the number of models each maker has.", "Filter the results: We will use the HAVING clause to filter out makers that have more than 3 models."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(ml.ModelId) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.158", "db_id": "car_1", "question": "For a volvo model, how many cylinders does the version with least accelerate have?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car models.", "We need to filter for the model 'volvo' in the 'car_names' table.", "Join 'cars_data' and 'car_names' on the appropriate foreign key (MakeId).", "Select the 'Cylinders' column from the 'cars_data' table.", "Order the results by 'Accelerate' in ascending order to find the version with the least acceleration time.", "Limit the results to 1 to get only the top result."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT Cylinders FROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE car_names.Model = 'volvo' \nORDER BY cars_data.Accelerate ASC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.160", "db_id": "car_1", "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?", "rationale": ["Identify the requirement: We need to count the number of cars with an acceleration time greater than the car with the highest horsepower.", "To find the car with the most horsepower, we can use a subquery that selects the maximum horsepower from the 'cars_data' table.", "We then need to count the number of cars in the 'cars_data' table where the 'Accelerate' value is greater than the result of the subquery.", "The final SQL query combines these elements to count the cars that meet the specified condition."], "gold_sql": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "source_tables": ["cars_data"], "pred_sql": "SELECT COUNT(*) \nFROM cars_data \nWHERE Accelerate > (SELECT MAX(Horsepower) \n                    FROM cars_data)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car models.", "We need to filter the cars based on the number of cylinders, specifically those with 4 cylinders.", "We want to find the model with the largest horsepower, so we will use the MAX function on the 'Horsepower' column.", "We will join 'cars_data' with 'car_names' on the 'Id' and 'MakeId' columns to get the model names associated with the horsepower data.", "We will group the results by car model to apply the MAX function correctly and then order the results by horsepower in descending order to get the highest value first.", "Finally, we will limit the results to 1 to get only the model with the largest horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT car_names.Model, MAX(cars_data.Horsepower) AS MaxHorsepower\nFROM cars_data\nJOIN car_names ON cars_data.Id = car_names.MakeId\nWHERE cars_data.Cylinders = 4\nGROUP BY car_names.Model\nORDER BY MaxHorsepower DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.166", "db_id": "car_1", "question": "For all of the 4 cylinder cars, which model has the most horsepower?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car models.", "We need to filter the cars based on the number of cylinders, specifically looking for 4-cylinder cars.", "We want to find the model with the maximum horsepower, so we will use the MAX() function on the 'Horsepower' column.", "We will join 'cars_data' with 'car_names' on the appropriate foreign key to access the model names.", "We will group the results by car model to apply the MAX() function correctly and then order the results by horsepower in descending order to get the highest value.", "Finally, we will limit the results to 1 to get only the model with the most horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT car_names.Model, MAX(cars_data.Horsepower) AS MaxHorsepower\nFROM cars_data\nJOIN car_names ON cars_data.Id = car_names.MakeId\nWHERE cars_data.Cylinders = 4\nGROUP BY car_names.Model\nORDER BY MaxHorsepower DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.168", "db_id": "car_1", "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car make details.", "We need to select the 'MakeId' and 'Make' from the 'car_names' table.", "Join 'cars_data' with 'car_names' on the 'Id' and 'MakeId' to get the make details for each car.", "Filter the results to include only cars with less than 4 cylinders.", "Additionally, filter out cars that have horsepower equal to or greater than the minimum horsepower found in the 'cars_data' table."], "gold_sql": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT car_names.MakeId, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Cylinders < 4 \nAND cars_data.Horsepower > (SELECT MIN(Horsepower) FROM cars_data);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\"\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the relevant tables: car_makers, model_list, car_names, and cars_data.", "We need to find car makers that produce at least 2 models, so we will join car_makers with model_list on the Maker ID.", "Next, we will join model_list with car_names to get the make information.", "Then, we will join car_names with cars_data to count the number of cars produced by each maker.", "We will group the results by car maker ID and name to aggregate the counts.", "Use the HAVING clause to filter for makers that have at least 2 distinct models and more than 3 cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers cm\nJOIN model_list ml ON cm.Id = ml.Maker\nJOIN car_names cn ON ml.Model = cn.Model\nJOIN cars_data cd ON cn.MakeId = cd.Id\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(DISTINCT ml.Model) >= 2 AND COUNT(cd.Id) > 3;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\"\n}\n"}
{"sample_id": "dev.180", "db_id": "flight_2", "question": "What country is Jetblue Airways affiliated with?", "rationale": ["Identify the relevant table: The 'airlines' table contains information about airlines, including their country affiliation.", "Determine the specific airline: The question asks about 'Jetblue Airways'.", "Construct the SQL query: We need to select the 'Country' column from the 'airlines' table where the 'Airline' column matches 'Jetblue Airways'."], "gold_sql": "SELECT Country FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "pred_sql": "SELECT Country FROM airlines WHERE Airline = 'Jetblue Airways';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.194", "db_id": "flight_2", "question": "Give the airline with abbreviation 'UAL'.", "rationale": ["Identify the relevant table: The 'airlines' table contains the abbreviation information.", "Determine the condition: We need to filter the results to find the airline with the abbreviation 'UAL'.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'airlines' table where the abbreviation matches 'UAL'."], "gold_sql": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  'UAL'", "source_tables": ["airlines"], "pred_sql": "SELECT * FROM airlines WHERE Abbreviation = 'UAL';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.214", "db_id": "flight_2", "question": "Give the number of Jetblue Airways flights.", "rationale": ["Identify the relevant table: The 'flights' table contains information about the flights, including the airline name.", "Determine the specific airline: The user is interested in 'Jetblue Airways'.", "Count the number of flights: Use the COUNT() function to count the number of records in the 'flights' table where the airline is 'Jetblue Airways'.", "Construct the SQL query: Combine the elements into a complete SQL query that counts the flights for Jetblue Airways."], "gold_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'JetBlue Airways'", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT COUNT(*) AS NumberOfFlights FROM flights WHERE Airline = 'Jetblue Airways';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.225", "db_id": "flight_2", "question": "What is the code of airport that has the highest number of flights?", "rationale": ["Identify the relevant tables: 'flights' and 'airports'.", "Determine that we need to count the number of flights associated with each airport code.", "Use the 'SourceAirport' and 'DestAirport' from the 'flights' table to get all airport codes.", "Group the results by airport code to count the number of flights for each code.", "Combine the counts from both source and destination airports using UNION ALL.", "Order the results by the count of flights in descending order to find the airport with the highest number of flights.", "Limit the results to 1 to get only the airport code with the highest number of flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT SourceAirport AS AirportCode, COUNT(*) AS FlightCount\nFROM flights\nGROUP BY SourceAirport\nUNION ALL\nSELECT DestAirport AS AirportCode, COUNT(*) AS FlightCount\nFROM flights\nGROUP BY DestAirport\nORDER BY FlightCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.227", "db_id": "flight_2", "question": "What is the code of airport that has fewest number of flights?", "rationale": ["Identify the relevant tables: 'airports' and 'flights'.", "We need to find the airport code with the fewest number of flights.", "We can use the 'flights' table to count the number of flights for each airport code, both as a source and destination.", "To do this, we will group the results by 'SourceAirport' and 'DestAirport' and count the occurrences.", "We will combine the results from both source and destination using UNION to ensure we consider all flights.", "Finally, we will order the results by the count of flights in ascending order and limit the output to 1 to get the airport code with the fewest flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT AirportCode FROM flights GROUP BY SourceAirport UNION SELECT AirportCode FROM flights GROUP BY DestAirport ORDER BY COUNT(*) ASC LIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.229", "db_id": "flight_2", "question": "Which airline has most number of flights?", "rationale": ["Identify the relevant tables: 'airlines' and 'flights'.", "We need to count the number of flights for each airline, so we will use the COUNT() function on the 'FlightNo' column from the 'flights' table.", "Group the results by the 'Airline' column to aggregate the flight counts for each airline.", "Order the results in descending order based on the count of flights to find the airline with the most flights.", "Limit the results to 1 to get only the airline with the highest number of flights."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT Airline, COUNT(FlightNo) AS NumberOfFlights \nFROM flights \nGROUP BY Airline \nORDER BY NumberOfFlights DESC \nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.232", "db_id": "flight_2", "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?", "rationale": ["Identify the airline with the fewest flights by counting the number of flights for each airline in the 'flights' table.", "Use a subquery to group the flights by airline and count them, ordering the results in ascending order to find the airline with the least number of flights.", "Limit the results of the subquery to 1 to get only the airline with the fewest flights.", "Join the result of the subquery with the 'airlines' table to get the abbreviation and country of that airline."], "gold_sql": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT a.Abbreviation, a.Country\nFROM airlines a\nJOIN (\n    SELECT Airline, COUNT(*) AS FlightCount\n    FROM flights\n    GROUP BY Airline\n    ORDER BY FlightCount ASC\n    LIMIT 1\n) AS f ON a.Airline = f.Airline;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists unique airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.\"\n}\n"}
{"sample_id": "dev.244", "db_id": "flight_2", "question": "Which airlines have less than 200 flights?", "rationale": ["Identify the relevant tables: 'airlines' and 'flights'.", "We need to find airlines with less than 200 flights, so we will join the 'airlines' table with the 'flights' table on the airline name.", "Group the results by airline name to count the number of flights for each airline.", "Use the HAVING clause to filter the grouped results to only include airlines with a count of flights less than 200."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT a.Airline \nFROM airlines a \nJOIN flights f ON a.Airline = f.Airline \nGROUP BY a.Airline \nHAVING COUNT(f.FlightNo) < 200;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.258", "db_id": "flight_2", "question": "Which airports do not have departing or arriving flights?", "rationale": ["Identify the airports from the 'airports' table that do not have any flights departing or arriving.", "To find these airports, we need to check which airport codes are present in the 'flights' table as either SourceAirport or DestAirport.", "We can use a subquery to select all airport codes from the 'flights' table by combining both SourceAirport and DestAirport using UNION.", "The main query will then select airport codes and names from the 'airports' table where the airport code is not in the list obtained from the subquery."], "gold_sql": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)", "source_tables": ["airports", "flights"], "pred_sql": "SELECT AirportCode, AirportName FROM airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM flights UNION SELECT DestAirport FROM flights);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\"\n}\n"}
{"sample_id": "dev.308", "db_id": "cre_Doc_Template_Mgt", "question": "Count the number of documents that use the PPT template type.", "rationale": ["Identify the tables involved: We need to count documents, so we will use the 'Documents' table and join it with the 'Templates' table to filter by template type.", "Determine the relationship: The 'Documents' table has a foreign key 'Template_ID' that links to the 'Templates' table, allowing us to join these tables on 'Template_ID'.", "Filter by template type: We need to count only those documents that are associated with the 'PPT' template type, which is indicated by the 'Template_Type_Code' in the 'Templates' table.", "Count the documents: We will use the COUNT function to count the distinct 'Document_ID's from the 'Documents' table that meet the criteria."], "gold_sql": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'", "source_tables": ["templates", "documents"], "pred_sql": "SELECT COUNT(DISTINCT d.Document_ID) AS Document_Count\nFROM Documents d\nJOIN Templates t ON d.Template_ID = t.Template_ID\nWHERE t.Template_Type_Code = 'PPT';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\"\n}\n"}
{"sample_id": "dev.311", "db_id": "cre_Doc_Template_Mgt", "question": "What is the id and type code for the template used by the most documents?", "rationale": ["We need to find the template ID and type code for the template that is used by the most documents.", "To do this, we will join the 'Templates' table with the 'Documents' table on the 'Template_ID' column.", "We will group the results by 'Template_ID' and 'Template_Type_Code' to count how many documents are associated with each template.", "We will use the COUNT function to count the number of documents for each template.", "To find the template used by the most documents, we will order the results in descending order based on the count of documents.", "Finally, we will limit the results to only the top entry to get the template with the highest document count."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Templates.Template_ID, Templates.Template_Type_Code\nFROM Templates\nJOIN Documents ON Templates.Template_ID = Documents.Template_ID\nGROUP BY Templates.Template_ID, Templates.Template_Type_Code\nORDER BY COUNT(Documents.Document_ID) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\"\n}\n"}
{"sample_id": "dev.312", "db_id": "cre_Doc_Template_Mgt", "question": "Return the id and type code of the template that is used for the greatest number of documents.", "rationale": ["We need to find the template that is used for the greatest number of documents.", "To do this, we will join the 'Templates' table with the 'Documents' table on the 'Template_ID' column.", "We will group the results by 'Template_ID' and 'Template_Type_Code' to count the number of documents associated with each template.", "We will use the COUNT function to count the number of documents for each template.", "Finally, we will order the results in descending order based on the count of documents and limit the result to 1 to get the template with the greatest number of documents."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Templates.Template_ID, Templates.Template_Type_Code\nFROM Templates\nJOIN Documents ON Templates.Template_ID = Documents.Template_ID\nGROUP BY Templates.Template_ID, Templates.Template_Type_Code\nORDER BY COUNT(Documents.Document_ID) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\"\n}\n"}
{"sample_id": "dev.341", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template type codes and the number of documents using each type.", "rationale": ["Identify the tables involved: Templates and Documents.", "Determine the relationship between the tables: Documents are linked to Templates via Template_ID.", "Select the Template_Type_Code from the Templates table and count the Document_ID from the Documents table.", "Use a JOIN to combine the Templates and Documents tables based on the Template_ID.", "Group the results by Template_Type_Code to get the count of documents for each template type."], "gold_sql": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code", "source_tables": ["templates", "documents"], "pred_sql": "SELECT T.Template_Type_Code, COUNT(D.Document_ID) AS Document_Count\nFROM Templates T\nJOIN Documents D ON T.Template_ID = D.Template_ID\nGROUP BY T.Template_Type_Code;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\"\n}\n"}
{"sample_id": "dev.346", "db_id": "cre_Doc_Template_Mgt", "question": "What are the codes of template types that are not used for any document?", "rationale": ["We need to find template types that are not used for any document.", "To do this, we will start from the 'Ref_Template_Types' table, which contains all template types.", "We will perform a LEFT JOIN with the 'Templates' table to include all template types, even those that do not have any associated templates.", "Next, we will perform another LEFT JOIN with the 'Documents' table to check if there are any documents associated with the templates.", "Finally, we will filter the results where 'Documents.Document_ID' is NULL, indicating that there are no documents linked to those template types."], "gold_sql": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Ref_Template_Types.Template_Type_Code \nFROM Ref_Template_Types \nLEFT JOIN Templates ON Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code \nLEFT JOIN Documents ON Templates.Template_ID = Documents.Template_ID \nWHERE Documents.Document_ID IS NULL;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\"\n}\n"}
{"sample_id": "dev.361", "db_id": "cre_Doc_Template_Mgt", "question": "Show paragraph details for paragraph with text 'Korea ' .", "rationale": ["Identify the table that contains paragraph details, which is the 'Paragraphs' table.", "Determine the column that holds the text content of the paragraph, which is 'Paragraph_Text'.", "Formulate a SQL query to select all columns from the 'Paragraphs' table where 'Paragraph_Text' matches the specified text 'Korea '."], "gold_sql": "select other_details from paragraphs where paragraph_text like 'korea'", "source_tables": ["paragraphs"], "pred_sql": "SELECT * FROM Paragraphs WHERE Paragraph_Text = 'Korea ';", "hint": "\n"}
{"sample_id": "dev.367", "db_id": "cre_Doc_Template_Mgt", "question": "Show all document ids and the number of paragraphs in each document. Order by document id.", "rationale": ["We need to retrieve all document IDs and the count of paragraphs associated with each document.", "To achieve this, we will use a LEFT JOIN between the 'Documents' table and the 'Paragraphs' table on the 'Document_ID' field.", "Using COUNT(Paragraphs.Paragraph_ID) will allow us to count the number of paragraphs for each document, even if some documents have no paragraphs (hence the LEFT JOIN).", "We will group the results by 'Documents.Document_ID' to ensure we get a count for each document.", "Finally, we will order the results by 'Documents.Document_ID' to meet the requirement of ordering the output."], "gold_sql": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id", "source_tables": ["paragraphs"], "pred_sql": "SELECT Documents.Document_ID, COUNT(Paragraphs.Paragraph_ID) AS Number_of_Paragraphs\nFROM Documents\nLEFT JOIN Paragraphs ON Documents.Document_ID = Paragraphs.Document_ID\nGROUP BY Documents.Document_ID\nORDER BY Documents.Document_ID;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the number of documents associated with each template from the 'Documents' table. The placeholder in the SELECT clause represents the unique identifier of the template, while the count function aggregates the total number of documents linked to each template.\"\n}\n"}
{"sample_id": "dev.439", "db_id": "wta_1", "question": "Find the highest rank of losers in all matches.", "rationale": ["We need to find the highest rank of losers in all matches.", "The 'loser_id' from the 'matches' table identifies the players who lost in each match.", "We will use a subquery to get all 'loser_id's from the 'matches' table.", "Next, we will look up the rankings of these players in the 'rankings' table using their 'player_id'.", "Finally, we will use the MIN function to find the highest rank among these losers, as a lower ranking number indicates a better rank."], "gold_sql": "SELECT min(loser_rank) FROM matches", "source_tables": ["matches"], "pred_sql": "SELECT MIN(ranking) AS highest_rank FROM rankings WHERE player_id IN (SELECT loser_id FROM matches)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\"\n}\n"}
{"sample_id": "dev.458", "db_id": "wta_1", "question": "What are the full names of all left handed players, in order of birth date?", "rationale": ["Identify the relevant table: The 'players' table contains the information about players, including their names and handedness.", "Determine the condition: We need to filter for left-handed players, which is specified in the 'hand' column.", "Select the required fields: We need the full names of the players, which can be constructed by concatenating 'first_name' and 'last_name'.", "Order the results: The results should be ordered by 'birth_date' to get the players in chronological order of their birth.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date", "source_tables": ["players"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name\nFROM players\nWHERE hand = 'left'\nORDER BY birth_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\"\n}\n"}
{"sample_id": "dev.464", "db_id": "wta_1", "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?", "rationale": ["Identify the relevant tables: matches, players, and rankings.", "We need to find the winner who has won the most matches, so we will focus on the 'matches' table and the 'winner_id' column.", "Join the 'matches' table with the 'players' table to get the names of the winners.", "Join the result with the 'rankings' table to get the rank points of the winners.", "Group the results by the winner's name to count the number of matches won by each player.", "Order the results by the count of matches won in descending order to find the player with the most wins.", "Select the winner's name and their rank points, limiting the result to the top player."], "gold_sql": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["matches"], "pred_sql": "SELECT winner_name, MAX(rank_points) AS rank_points\nFROM matches\nJOIN players ON matches.winner_id = players.player_id\nJOIN rankings ON players.player_id = rankings.player_id\nGROUP BY winner_name\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\"\n}\n"}
{"sample_id": "dev.471", "db_id": "wta_1", "question": "Find the total ranking points for each player and their first name.", "rationale": ["We need to find the total ranking points for each player along with their first name.", "The relevant tables for this query are 'players' and 'rankings'.", "We will join these two tables on the 'player_id' column, which is common to both tables.", "We will select the 'first_name' from the 'players' table and the sum of 'ranking_points' from the 'rankings' table.", "To get the total ranking points for each player, we will use the SUM() function and group the results by 'first_name'."], "gold_sql": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "pred_sql": "SELECT players.first_name, SUM(rankings.ranking_points) AS total_ranking_points\nFROM players\nJOIN rankings ON players.player_id = rankings.player_id\nGROUP BY players.first_name;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\"\n}\n"}
{"sample_id": "dev.479", "db_id": "wta_1", "question": "Find the total number of tours for each ranking date.", "rationale": ["The query needs to find the total number of tours for each ranking date.", "We will select the 'ranking_date' from the 'rankings' table.", "To count the distinct tours for each ranking date, we will use the COUNT function with DISTINCT on the 'tours' column.", "We will group the results by 'ranking_date' to get the total tours for each date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(DISTINCT tours) AS total_tours\nFROM rankings\nGROUP BY ranking_date;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\"\n}\n"}
{"sample_id": "dev.480", "db_id": "wta_1", "question": "How many total tours were there for each ranking date?", "rationale": ["The question asks for the total number of tours for each ranking date.", "We need to select the 'ranking_date' from the 'rankings' table.", "To count the distinct tours for each ranking date, we will use the COUNT function with DISTINCT on the 'tours' column.", "We will group the results by 'ranking_date' to get the count for each date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(DISTINCT tours) AS total_tours\nFROM rankings\nGROUP BY ranking_date;", "hint": "\n"}
{"sample_id": "dev.533", "db_id": "student_transcripts_tracking", "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to join the Students table with the Student_Enrolment table to get student details along with their enrolment information.", "To find students enrolled in 2 degree programs in one semester, we can join the Student_Enrolment table with itself (self-join) on the student_id.", "In the self-join, we ensure that the degree_program_id is different for the two records (indicating enrollment in two different programs) but the semester_id is the same (indicating they are enrolled in the same semester).", "Select the required fields: first_name, middle_name, last_name, and student_id from the Students table."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Student_Enrolment se2 ON s.student_id = se2.student_id\nWHERE se.degree_program_id != se2.degree_program_id\nAND se.semester_id = se2.semester_id;", "hint": "\n"}
{"sample_id": "dev.536", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs.", "We need to retrieve the first, middle, and last names of students, which are in the Students table.", "To find out which students are enrolled in a Bachelors program, we need to join the Students table with the Student_Enrolment table on student_id.", "Next, we join the Student_Enrolment table with the Degree_Programs table on degree_program_id to filter for Bachelors programs.", "The WHERE clause is used to filter the degree_summary_name to include 'Bachelors'.", "Finally, select the first_name, middle_name, and last_name from the resulting joined tables."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name \nFROM Students s \nJOIN Student_Enrolment se ON s.student_id = se.student_id \nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id \nWHERE dp.degree_summary_name LIKE '%Bachelors%';", "hint": "\n"}
{"sample_id": "dev.537", "db_id": "student_transcripts_tracking", "question": "Find the kind of program which most number of students are enrolled in?", "rationale": ["Identify the relevant tables: We need to find the degree programs and the number of students enrolled in each program, so we will use the Student_Enrolment and Degree_Programs tables.", "Join the tables: We will join the Student_Enrolment table with the Degree_Programs table on the degree_program_id to associate each enrolment with its corresponding program.", "Count the number of students: We will use the COUNT function to count the number of student enrolments for each degree program.", "Group the results: We will group the results by the degree program name to get the count of students for each program.", "Order the results: We will order the results in descending order based on the student count to find the program with the most students enrolled.", "Limit the results: We will limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_summary_name, COUNT(se.student_enrolment_id) AS student_count\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nGROUP BY dp.degree_summary_name\nORDER BY student_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["Identify the relevant tables: Degree_Programs and Student_Enrolment.", "We need to find the degree program with the most students enrolled, so we will join Degree_Programs with Student_Enrolment on the degree_program_id.", "Group the results by degree_program_id and degree_summary_name to count the number of students enrolled in each program.", "Use COUNT(se.student_id) to count the number of students for each program.", "Order the results in descending order based on the count of students to get the program with the most enrollments at the top.", "Limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_program_id, dp.degree_summary_name\nFROM Degree_Programs dp\nJOIN Student_Enrolment se ON dp.degree_program_id = se.degree_program_id\nGROUP BY dp.degree_program_id, dp.degree_summary_name\nORDER BY COUNT(se.student_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to count the number of enrollments for each student, so we will join the Students table with the Student_Enrolment table on the student_id.", "Use COUNT() function to count the number of enrollments for each student.", "Group the results by student_id to aggregate the counts for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to 1 to get only the student with the highest number of enrollments."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name, COUNT(se.student_enrolment_id) AS number_of_enrollments\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id\nORDER BY number_of_enrollments DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["Identify the relevant tables: Courses and Student_Enrolment_Courses.", "Join the Courses table with the Student_Enrolment_Courses table on the course_id to link courses with their enrollments.", "Group the results by course name to aggregate the number of enrollments for each course.", "Count the number of enrollments for each course using COUNT on the student_course_id from the Student_Enrolment_Courses table.", "Order the results in descending order based on the count of enrollments to find the most popular course.", "Limit the results to 1 to get only the course with the highest number of enrollments."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT C.course_name\nFROM Courses C\nJOIN Student_Enrolment_Courses SEC ON C.course_id = SEC.course_id\nGROUP BY C.course_name\nORDER BY COUNT(SEC.student_course_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of course names from the 'Courses' table that are associated with student enrolments. The results are grouped by course name and ordered by the number of enrolments in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of course names to return.\"\n}\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant table: We need to retrieve last names of students, so we will focus on the 'Students' table.", "Filter students based on their address: We need to find students who live in North Carolina. This requires a subquery to the 'Addresses' table to get the 'address_id' for addresses in North Carolina.", "Exclude students who are enrolled in any degree programs: We need to ensure that these students have not registered in any degree programs, which requires another subquery to the 'Student_Enrolment' table to filter out those students who have an entry in that table."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT last_name \nFROM Students \nWHERE current_address_id IN (\n    SELECT address_id \n    FROM Addresses \n    WHERE state_province_county = 'North Carolina'\n) \nAND student_id NOT IN (\n    SELECT student_id \n    FROM Student_Enrolment\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\"\n}\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table: The 'Students' table contains the information about students, including their names and mobile phone numbers.", "Determine the columns needed: We need the 'cell_mobile_number' column to get the mobile phone number.", "Formulate the WHERE clause: We need to filter the results to find the student named 'Timmothy Ward'. This requires checking both the 'first_name' and 'last_name' columns.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to retrieve the desired information."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\"\n}\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["Identify the relevant tables: We need to look at the 'Addresses' table for address details and the 'Students' table to find out how many students are associated with each address.", "Join the 'Addresses' table with the 'Students' table on the current address ID to link students to their current addresses.", "Group the results by address ID to count the number of students associated with each address.", "Order the results in descending order based on the count of students to find the address with the most students.", "Limit the results to 1 to get only the address with the highest count of students."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT a.address_id, a.line_1, a.line_2, a.line_3\nFROM Addresses a\nJOIN Students s ON a.address_id = s.current_address_id\nGROUP BY a.address_id\nORDER BY COUNT(s.student_id) DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\"\n}\n"}
{"sample_id": "dev.576", "db_id": "student_transcripts_tracking", "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?", "rationale": ["Identify the relevant tables: Student_Enrolment and Degree_Programs.", "We need to find semesters that had both Masters and Bachelors students enrolled.", "Join the Student_Enrolment table with the Degree_Programs table on the degree_program_id.", "Filter the results to include only those degree programs that are either 'Masters' or 'Bachelors'.", "Group the results by semester_id to aggregate the data for each semester.", "Use HAVING clause to ensure that both degree types (Masters and Bachelors) are present in the results for each semester."], "gold_sql": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT DISTINCT se.semester_id\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name IN ('Masters', 'Bachelors')\nGROUP BY se.semester_id\nHAVING COUNT(DISTINCT dp.degree_summary_name) = 2;", "hint": "\n"}
{"sample_id": "dev.580", "db_id": "student_transcripts_tracking", "question": "What other details can you tell me about students in reverse alphabetical order?", "rationale": ["The question asks for 'other details' about students, which corresponds to the 'other_student_details' column in the Students table.", "To retrieve this information, we will select the 'other_student_details' column from the Students table.", "The question specifies that the results should be in reverse alphabetical order, which means we need to order the results by the last name and first name of the students in descending order.", "Thus, the SQL query will select 'other_student_details' from the Students table and order the results by 'last_name' and 'first_name' in descending order."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "pred_sql": "SELECT other_student_details FROM Students ORDER BY last_name DESC, first_name DESC;", "hint": "\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve information about a section, we need to select all columns from the Sections table.", "We will use a WHERE clause to filter the results to only include the section where the section_name is 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT * FROM Sections WHERE section_name = 'h';", "hint": "\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the table that contains information about countries and their government forms, which is the 'country' table.", "Determine the specific column that indicates the type of government, which is 'GovernmentForm'.", "Formulate a query to count the number of entries in the 'country' table where the 'GovernmentForm' is 'Republic'.", "Use the COUNT() function to get the total number of countries that meet this criterion."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(*) FROM country WHERE GovernmentForm = 'Republic';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.730", "db_id": "world_1", "question": "What is the average GNP and total population in all nations whose government is US territory?", "rationale": ["Identify the required data: average GNP and total population of countries with a specific government form.", "Use the 'country' table since it contains the GNP and population data.", "Apply the AVG() function to calculate the average GNP and SUM() function to calculate the total population.", "Filter the results using a WHERE clause to include only those countries with a government form of 'US territory'."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT AVG(GNP) AS Average_GNP, SUM(Population) AS Total_Population \nFROM country \nWHERE GovernmentForm = 'US territory';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.734", "db_id": "world_1", "question": "How many type of governments are in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and regions.", "Determine the specific region: The question asks about Africa, so we will filter the results to only include countries in the 'Africa' region.", "Select distinct government forms: To find out how many types of governments exist, we will use the DISTINCT keyword to ensure we only get unique government forms."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Region = 'Africa';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and regions.", "Determine the specific region of interest: The question specifies Africa, so we will filter the results to only include countries in the 'Africa' region.", "Select distinct government forms: To find out how many different forms of government exist, we will use the DISTINCT keyword to ensure we only get unique values for the GovernmentForm column."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Region = 'Africa';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.742", "db_id": "world_1", "question": "Which continent has the most diverse languages?", "rationale": ["Identify the tables involved: We need to look at the 'country' and 'countrylanguage' tables to find the continent and the languages spoken in each country.", "Join the tables: We will join 'country' and 'countrylanguage' on the 'Code' and 'CountryCode' fields respectively to associate each language with its corresponding country.", "Group by continent: We will group the results by the continent to count the number of distinct languages spoken in each continent.", "Count distinct languages: Use COUNT(DISTINCT countrylanguage.Language) to get the number of different languages spoken in each continent.", "Order the results: We will order the results in descending order based on the count of languages to find the continent with the most diverse languages.", "Limit the results: Finally, we will limit the results to 1 to get only the continent with the highest diversity of languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT country.Continent, COUNT(DISTINCT countrylanguage.Language) AS LanguageCount\nFROM country\nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode\nGROUP BY country.Continent\nORDER BY LanguageCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\"\n}\n"}
{"sample_id": "dev.743", "db_id": "world_1", "question": "Which continent speaks the most languages?", "rationale": ["We need to find out which continent speaks the most languages.", "To do this, we will join the 'country' table with the 'countrylanguage' table on the 'CountryCode'.", "We will count the distinct languages spoken in each continent using COUNT(DISTINCT countrylanguage.Language).", "We will group the results by continent using GROUP BY country.Continent.", "To find the continent with the most languages, we will order the results in descending order by the count of languages using ORDER BY LanguageCount DESC.", "Finally, we will limit the results to only the top continent using LIMIT 1."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT country.Continent, COUNT(DISTINCT countrylanguage.Language) AS LanguageCount\nFROM country\nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode\nGROUP BY country.Continent\nORDER BY LanguageCount DESC\nLIMIT 1;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\"\n}\n"}
{"sample_id": "dev.746", "db_id": "world_1", "question": "What are the names of nations speak both English and French?", "rationale": ["Identify the languages of interest: English and French.", "Use the countrylanguage table to find countries that speak English and French.", "Filter for countries where English is spoken but not as an official language.", "Use a subquery to find countries that also speak French under the same conditions.", "Join the results with the country table to get the names of the countries."], "gold_sql": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'French'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl1.CountryCode, c.Name \nFROM countrylanguage cl1 \nJOIN country c ON cl1.CountryCode = c.Code \nWHERE cl1.Language = 'English' \nAND cl1.IsOfficial = 'False' \nAND cl1.CountryCode IN (\n    SELECT cl2.CountryCode \n    FROM countrylanguage cl2 \n    WHERE cl2.Language = 'French' \n    AND cl2.IsOfficial = 'False'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["We need to find countries that have either English or Dutch as an official language.", "To do this, we will use the 'country' table to get the country names and the 'countrylanguage' table to filter by language and official status.", "We will perform a JOIN between the 'country' and 'countrylanguage' tables on the 'Code' and 'CountryCode' columns respectively.", "We will use the WHERE clause to filter for languages that are either 'English' or 'Dutch' and check that they are official languages by ensuring 'IsOfficial' is 'T'.", "Finally, we will use DISTINCT to ensure that we only get unique country names in the result."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT country.Name \nFROM country \nJOIN countrylanguage ON country.Code = countrylanguage.CountryCode \nWHERE countrylanguage.Language IN ('English', 'Dutch') AND countrylanguage.IsOfficial = 'T';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the requirement: We need to find the total population of countries that do not use English as an official language.", "Understand the schema: The 'country' table contains population data, and the 'countrylanguage' table indicates which languages are official in which countries.", "To find countries that do not use English, we need to select country codes from the 'countrylanguage' table where English is an official language.", "We will use a subquery to get the country codes where English is the official language.", "The main query will sum the populations of countries whose codes are not in the list obtained from the subquery."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation\nFROM country c\nWHERE c.Code NOT IN (\n    SELECT cl.CountryCode\n    FROM countrylanguage cl\n    WHERE cl.Language = 'English' AND cl.IsOfficial = 'Yes'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.767", "db_id": "world_1", "question": "How many people live in countries that do not speak English?", "rationale": ["Identify the total population of countries that do not speak English.", "To find countries that do not speak English, we need to exclude countries where English is an official language.", "We can achieve this by using a subquery that selects country codes from the countrylanguage table where the language is 'English' and it is marked as official.", "The main query will then sum the populations of countries whose codes are not in the result of the subquery."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation\nFROM country c\nWHERE c.Code NOT IN (\n    SELECT cl.CountryCode\n    FROM countrylanguage cl\n    WHERE cl.Language = 'English' AND cl.IsOfficial = 'Yes'\n)", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.783", "db_id": "world_1", "question": "Return the codes of countries that do not speak English and do not have Republics for governments.", "rationale": ["Identify the countries that do not speak English: This can be done by selecting the country codes from the countrylanguage table where the language is 'English' and it is marked as an official language.", "Use a subquery to get the country codes that speak English officially: This subquery will return the country codes that we want to exclude from our main query.", "Identify the countries that do not have Republics for governments: This can be done by filtering the country table where the GovernmentForm does not contain the word 'Republic'.", "Combine the two conditions: We will select the country codes from the country table that are not in the list of country codes that speak English and also do not have 'Republic' in their government form."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T') AND GovernmentForm NOT LIKE '%Republic%';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.784", "db_id": "world_1", "question": "Which cities are in European countries where English is not the official language?", "rationale": ["Identify the relevant tables: 'city' and 'country' for city information and country details, and 'countrylanguage' for language information.", "We need to find cities in European countries, so we will filter the 'country' table by the 'Continent' column for 'Europe'.", "Next, we need to ensure that the cities are in countries where English is not the official language. This requires a subquery that selects country codes from the 'countrylanguage' table where English is the official language.", "The subquery will be used in the main query's WHERE clause to exclude those country codes from the results.", "Finally, we will select the city names from the 'city' table, joining it with the 'country' table on the 'CountryCode' to get the necessary information."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nWHERE country.Continent = 'Europe' \nAND city.CountryCode NOT IN (\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language = 'English' \n    AND IsOfficial = 'Yes'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.785", "db_id": "world_1", "question": "What are the names of cities in Europe for which English is not the official language?", "rationale": ["Identify the relevant tables: We need to use the 'city' and 'country' tables to get city names and their corresponding countries.", "Filter for cities in Europe: We can do this by checking the 'Continent' column in the 'country' table.", "Exclude cities where English is an official language: We will use a subquery to find countries where English is an official language and exclude those from our main query.", "Join the 'city' and 'country' tables on the 'CountryCode' to get the necessary information about the cities and their countries."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nWHERE country.Continent = 'Europe' \nAND city.CountryCode NOT IN (\n    SELECT CountryCode \n    FROM countrylanguage \n    WHERE Language = 'English' \n    AND IsOfficial = 'Yes'\n);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\"\n}\n"}
{"sample_id": "dev.788", "db_id": "world_1", "question": "What are the name, independence year, and surface area of the country with the smallest population?", "rationale": ["Identify the required columns: Name, IndepYear, and SurfaceArea from the country table.", "Determine the condition to find the country with the smallest population, which involves using the MIN function on the Population column.", "Construct a subquery to find the minimum population from the country table.", "Use the result of the subquery to filter the main query to get the country details that match the minimum population."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\"\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the required fields: Name, year of independence (IndepYear), and surface area (SurfaceArea) from the country table.", "Determine the condition: We need to find the country with the lowest population.", "Use a subquery to find the minimum population from the country table: (SELECT MIN(Population) FROM country).", "Combine the selected fields and the condition in the main query to retrieve the desired information."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\"\n}\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["Identify the relevant tables: We need to use the 'country' table to get country names and the 'countrylanguage' table to count the languages spoken in each country.", "Join the 'country' and 'countrylanguage' tables on the 'Code' and 'CountryCode' columns respectively to associate countries with their languages.", "Use the COUNT function to count the number of languages spoken in each country.", "Group the results by country name to aggregate the language counts for each country.", "Use the HAVING clause to filter the results to only include countries that speak more than 2 languages."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name, COUNT(cl.Language) AS LanguageCount\nFROM country c\nJOIN countrylanguage cl ON c.Code = cl.CountryCode\nGROUP BY c.Name\nHAVING COUNT(cl.Language) > 2;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\"\n}\n"}
{"sample_id": "dev.796", "db_id": "world_1", "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.", "rationale": ["Identify the columns needed: GovernmentForm and Population.", "We need to filter countries based on LifeExpectancy being greater than 72.", "We will group the results by GovernmentForm to get the total population for each form of government.", "Use SUM function to calculate the total population for each government form.", "Construct the SQL query using SELECT, FROM, WHERE, and GROUP BY clauses."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the relevant table: The 'country' table contains the columns for government forms and population.", "Determine the columns needed: We need 'GovernmentForm' and the total population, which can be calculated using SUM(Population).", "Apply the condition: We need to filter for countries with an average life expectancy greater than 72, which is done using the WHERE clause.", "Group the results: To get the total population for each government form, we will use GROUP BY on 'GovernmentForm'."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\"\n}\n"}
{"sample_id": "dev.801", "db_id": "world_1", "question": "Return the names and surface areas of the 5 largest countries.", "rationale": ["Identify the table needed: The 'country' table contains the names and surface areas of countries.", "Determine the required columns: We need 'Name' and 'SurfaceArea' from the 'country' table.", "Sort the results: To find the largest countries, we will order the results by 'SurfaceArea' in descending order.", "Limit the results: We only want the top 5 largest countries, so we will use 'LIMIT 5' to restrict the output."], "gold_sql": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5", "source_tables": ["country"], "pred_sql": "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\"\n}\n"}
{"sample_id": "dev.810", "db_id": "world_1", "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?", "rationale": ["Identify the relevant table: The 'country' table contains the necessary information about countries, including population and surface area.", "Determine the required fields: We need to calculate the total population and average surface area, so we will use SUM(Population) and AVG(SurfaceArea).", "Apply the filtering criteria: We need to filter the countries based on the continent (North America) and the surface area (> 3000).", "Construct the SQL query: Combine the selected fields and filtering criteria into a complete SQL statement."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT SUM(Population) AS TotalPopulation, AVG(SurfaceArea) AS AverageArea FROM country WHERE Continent = 'North America' AND SurfaceArea > 3000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\"\n}\n"}
{"sample_id": "dev.811", "db_id": "world_1", "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .", "rationale": ["Identify the continent of interest, which is North America.", "Determine the conditions for filtering countries: surface area greater than 3000.", "Select the total population and average surface area from the 'country' table.", "Use the SUM function to calculate the total population and the AVG function to calculate the average surface area for the filtered countries."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation, AVG(c.SurfaceArea) AS AverageSurfaceArea\nFROM country c\nWHERE c.Continent = 'North America' AND c.SurfaceArea > 3000;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\"\n}\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the relevant table: The 'city' table contains the population data we need.", "Determine the columns needed: We need the 'Name' of the city and the 'Population'.", "Formulate the condition: We want cities where the population is between 160000 and 900000.", "Construct the SQL query: Use the SELECT statement to get the city names from the 'city' table with the specified population range."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT Name FROM city WHERE Population BETWEEN '160000' AND '900000';", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table provides the names and populations of cities from the 'city' table that have a specific language spoken, as indicated in the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name, while the placeholder in the LIMIT clause specifies the maximum number of results to return.\"\n}\n"}
{"sample_id": "dev.921", "db_id": "dog_kennels", "question": "Find the average age of the dogs who went through treatments.", "rationale": ["Identify the tables involved: Dogs and Treatments.", "We need to find the average age of dogs that have received treatments, so we will join the Dogs table with the Treatments table on the dog_id.", "Use the AVG() function to calculate the average age of the dogs from the Dogs table after the join."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT AVG(D.age) AS average_age\nFROM Dogs D\nJOIN Treatments T ON D.dog_id = T.dog_id;", "hint": "Descriptions:\n{\n    \"0\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\"\n}\n"}
