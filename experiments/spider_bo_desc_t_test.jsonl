{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["The query is identifying the relevant table, which is 'Student_Course_Attendance'.", "Select the column to display, 'student_id'.", "No additional conditions or filters are applied in this query, so it retrieves all student identifiers from the attendance records."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "description": "This virtual table describes the identifiers of students who have attended courses from the 'Student_Course_Attendance' table. The placeholder in the SELECT clause represents the unique student identifiers.", "virtual_table": "SELECT student_id FROM student_course_attendance"}
{"sample_id": "train.68", "db_id": "student_assessment", "question": "What details do we have on the students who registered for courses most recently?", "rationale": ["The query identifies the relevant tables, 'Student_Course_Registrations' and 'Students'.", "It selects the 'student_details' column from the 'Students' table.", "A JOIN operation is performed to link 'Student_Course_Registrations' with 'Students' using the 'student_id'.", "The results are ordered by 'registration_date' in descending order to show the most recent registrations first.", "A placeholder is included to limit the number of records returned."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "This virtual table provides a list of student details from the 'Students' table for students who have registered for courses. The data is retrieved by joining the 'Student_Course_Registrations' table with the 'Students' table based on the student ID. The results are ordered by the registration date in descending order, and a placeholder is included to limit the number of records returned.", "virtual_table": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["The query identifies the relevant table, which is 'Candidate_Assessments'.", "It selects the 'candidate_id' column to display the identifiers of candidates.", "The results are ordered by 'assessment_date' in descending order to show the most recent assessments first.", "A placeholder is used in the LIMIT clause to allow the user to specify how many results they want to retrieve."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "description": "This virtual table provides a list of candidate identifiers from the 'Candidate_Assessments' table, ordered by the date of assessment in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.78", "db_id": "student_assessment", "question": "What are the details of the student who registered for the most number of courses?", "rationale": ["The query identifies the relevant tables, 'Students' and 'Student_Course_Registrations'.", "It selects the 'student_details' column from the 'Students' table.", "A JOIN operation is performed to link students with their course registrations based on the 'student_id'.", "The results are grouped by 'student_id' to avoid duplicates and to count the number of registrations per student.", "The results are ordered by the count of registrations in descending order to prioritize students with the most registrations.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "description": "This virtual table provides a list of student details from the 'Students' table, specifically for those students who have registered for courses. The results are grouped by each student to ensure unique entries and are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to return.", "virtual_table": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["The query identifies the relevant tables: 'Students', 'Student_Course_Registrations', and 'Courses'.", "It selects the 'course_name' from the 'Courses' table and counts the number of students registered for each course.", "The join conditions link students to their course registrations and then to the course details.", "The results are grouped by 'course_id' to aggregate the count of students for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "description": "This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.", "virtual_table": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id"}
{"sample_id": "train.89", "db_id": "student_assessment", "question": "What is the id of the student who most recently registered course 301?", "rationale": ["The query identifies the relevant table, which is 'Student_Course_Attendance'.", "Select the column to display, 'student_id'.", "Add a condition to filter the 'course_id' column for the specified course using a placeholder for numeric values.", "Order the results by 'date_of_attendance' in descending order to show the most recent attendance first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "description": "This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.92", "db_id": "student_assessment", "question": "What are the different cities where people live?", "rationale": ["The query identifies the relevant tables, which are 'Addresses' and 'People_Addresses'.", "It selects distinct cities from the 'Addresses' table to avoid duplicates.", "A JOIN operation is performed between 'Addresses' and 'People_Addresses' on the 'address_id' to link addresses with people."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id", "source_tables": ["addresses", "people_addresses"], "description": "This virtual table provides a list of unique cities from the 'Addresses' table that are associated with people through the 'People_Addresses' table. The placeholder in the JOIN clause represents the relationship between addresses and people.", "virtual_table": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Course_Registrations'.", "It selects the 'student_id' from the 'Student_Course_Registrations' table.", "A JOIN operation is performed between 'Courses' and 'Student_Course_Registrations' on the 'course_id' to link students to their respective courses.", "A condition is added to filter the results based on the specified course name using a placeholder for string values.", "The results are ordered by the 'registration_date' to show the order of student registrations."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "description": "This virtual table lists the identifiers of students who are registered for a specific course from the 'Courses' table. The placeholder in the WHERE clause represents the name of the course, allowing users to filter the results based on their input.", "virtual_table": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = [PLACEHOLDER-TYPE:STRING] ORDER BY T2.registration_date"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Course_Registrations'.", "It selects the 'student_id' from the 'Student_Course_Registrations' table.", "A JOIN operation is performed to link 'Courses' and 'Student_Course_Registrations' based on the 'course_id'.", "A condition is added to filter the results by the specified 'course_name' using a placeholder for string values.", "The results are ordered by the 'registration_date' to show the most recent registrations first."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "description": "This virtual table lists the unique identifiers of students who are registered for a specific course from the 'Courses' table. The placeholder in the WHERE clause represents the name of the course, allowing users to filter the results based on their input.", "virtual_table": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = [PLACEHOLDER-TYPE:STRING] ORDER BY T2.registration_date"}
{"sample_id": "train.387", "db_id": "flight_1", "question": "Show origins of all flights with destination Honolulu.", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "Select the column to display, 'origin'.", "Add a condition to filter the 'destination' column for the specified destination using a placeholder for string values."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "description": "This virtual table provides the starting locations of flights from the 'Flight' table that are headed to a specific destination. The placeholder in the WHERE clause represents the destination's name.", "virtual_table": "SELECT origin FROM Flight WHERE destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "Select the columns to display, 'departure_date' and 'arrival_date'.", "Add conditions to filter the 'origin' and 'destination' columns for the specified locations using placeholders for string values."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "description": "This virtual table provides the scheduled departure and arrival dates of flights from the 'Flight' table that originate from a specific location and are destined for another specific location. The placeholders in the WHERE clause represent the origin and destination of the flight.", "virtual_table": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING] AND destination  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.400", "db_id": "flight_1", "question": "What are the numbers of the shortest flights?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "Select the column to display, 'flno', which represents the flight number.", "Order the results by the 'distance' column in ascending order to show the shortest flights first.", "Limit the number of results returned using a placeholder for numeric values to specify how many flight numbers to retrieve."], "gold_sql": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3", "source_tables": ["flight"], "description": "This virtual table lists the flight numbers from the 'Flight' table, ordered by the distance of each flight in ascending order. The placeholder in the LIMIT clause represents the maximum number of flight numbers to be returned.", "virtual_table": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.408", "db_id": "flight_1", "question": "What place has the most flights coming from there?", "rationale": ["The query identifies the relevant table, which is 'Flight'.", "It selects the 'origin' column to display the starting locations of flights.", "The results are grouped by the 'origin' to aggregate the data based on unique starting locations.", "The query orders the results by the count of flights from each origin in descending order to show the most popular origins first.", "A limit is applied to restrict the number of origins returned, using a placeholder for numeric values."], "gold_sql": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "description": "This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.", "virtual_table": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["The query identifies the relevant tables, which are 'Flight' and 'Aircraft'.", "It selects the 'name' column from the 'Aircraft' table and counts the number of flights associated with each aircraft.", "A JOIN operation is performed on the 'aid' column to link flights with their respective aircraft.", "The results are grouped by the 'aid' to aggregate the flight counts for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "description": "This virtual table provides the names of aircraft along with the count of flights associated with each aircraft from the 'Flight' and 'Aircraft' tables. The placeholder in the SELECT statement allows for dynamic retrieval of aircraft names and their corresponding flight counts.", "virtual_table": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid"}
{"sample_id": "train.429", "db_id": "flight_1", "question": "Show names for all employees who do not have certificate of Boeing 737-800.", "rationale": ["The query identifies the relevant table, which is 'Employee'.", "It selects the 'name' column to display the names of employees.", "The EXCEPT clause is used to exclude employees who hold a certificate for a specific aircraft model.", "A JOIN operation is performed between 'Employee', 'Certificate', and 'Aircraft' to filter out employees based on the aircraft model using a placeholder for string values."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "description": "This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.", "virtual_table": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.433", "db_id": "flight_1", "question": "Show the name and distance of the aircrafts with more than 5000 distance and which at least 5 people have its certificate.", "rationale": ["The query identifies the relevant tables, 'Certificate' and 'Aircraft', and establishes a join between them based on the aircraft ID.", "It selects the 'name' column from the 'Aircraft' table.", "A condition is added to filter aircraft based on their maximum travel distance using a placeholder for numeric values.", "The results are grouped by aircraft ID to aggregate the data appropriately.", "An ordering condition is applied to filter the results based on the count of certifications that meet a specified threshold using another placeholder for numeric values."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "description": "This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.434", "db_id": "flight_1", "question": "What is the name and distance of every aircraft that can cover a distance of more than 5000 and which at least 5 people can fly?", "rationale": ["The query identifies the relevant tables, 'Certificate' and 'Aircraft', and establishes a join between them based on the aircraft ID.", "It selects the 'name' column from the 'Aircraft' table.", "A condition is added to filter aircraft based on their maximum travel distance using a placeholder for numeric values.", "The results are grouped by aircraft ID to aggregate the data appropriately.", "An ordering condition is applied to ensure that only those aircraft with a count of certifications greater than or equal to a specified number are included."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "description": "This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.", "virtual_table": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.437", "db_id": "flight_1", "question": "What is the salary and name of the employee who has the most number of certificates on aircrafts with distance more than 5000?", "rationale": ["The query identifies the relevant tables: 'Employee', 'Certificate', and 'Aircraft'.", "It selects the 'name' column from the 'Employee' table, which is aliased as T1.", "The query joins the 'Certificate' table (aliased as T2) on the employee ID to link employees with their certificates.", "It further joins the 'Aircraft' table (aliased as T3) on the aircraft ID to filter based on the aircraft's distance capability.", "A condition is added to filter aircraft with a distance greater than a specified number using a placeholder for numeric values.", "The results are grouped by employee ID to count the number of certificates each employee holds.", "Finally, the results are ordered by the count of certificates in descending order and limited to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "description": "This virtual table lists the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.", "virtual_table": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "Select the distinct values of the 'allergy' column to avoid duplicates.", "Add a condition to filter the 'allergytype' column for the specified type using a placeholder for string values."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "description": "This virtual table provides a list of distinct allergies from the 'Allergy_Type' table that belong to a specific category of allergy. The placeholder in the WHERE clause represents the type of allergy being queried.", "virtual_table": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.456", "db_id": "allergy_1", "question": "Which allergy type is most common?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects the 'allergytype' column to display the types of allergies.", "The query groups the results by 'allergytype' to aggregate the data.", "It orders the results by the count of occurrences in descending order to show the most common types first.", "The LIMIT clause uses a placeholder for numeric values to specify how many types to return."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "description": "This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.", "virtual_table": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["The query identifies the relevant table, which is 'Allergy_Type'.", "It selects the 'allergytype' column to display the types of allergies.", "The results are grouped by 'allergytype' to aggregate similar types together.", "The results are ordered by the count of occurrences in ascending order to show the least common allergy types first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "description": "This virtual table provides a list of allergy types from the 'Allergy_Type' table, grouped by their category. The results are ordered by the count of occurrences in ascending order, with a limit set by a placeholder for numeric values.", "virtual_table": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["The query is identifying the relevant table, which is 'Student'.", "Select the columns to display, 'Fname' and 'Lname'.", "The query can be expanded to include additional conditions or filters as needed."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "description": "This virtual table describes the first and last names of students from the 'Student' table. The query can be further modified to include conditions or filters based on specific criteria such as age, major, or city code.", "virtual_table": "SELECT Fname ,  Lname FROM Student"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["The query is identifying the relevant table, which is 'Student'.", "Select the column to display, 'StuID'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "description": "This virtual table lists the unique identifiers of students from the 'Student' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the students.", "virtual_table": "SELECT StuID FROM Student WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'major'.", "Group the results by 'major' to aggregate the data.", "Order the results by the count of students in each major in descending order to show the most popular majors first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of academic majors from the 'Student' table, grouped by the major and ordered by the number of students in each major in descending order. The placeholder in the LIMIT clause represents the maximum number of majors to return.", "virtual_table": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.501", "db_id": "allergy_1", "question": "Which advisor has most number of students?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the column to display, 'advisor'.", "Group the results by the 'advisor' column to aggregate the data.", "Order the results by the count of students associated with each advisor in descending order.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "description": "This virtual table provides a list of academic advisors from the 'Student' table, grouped by the advisor's name. The results are ordered by the number of students assigned to each advisor in descending order, with a limit on the number of advisors returned, specified by a placeholder for numeric values.", "virtual_table": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["The query identifies the relevant table, which is 'Has_Allergy'.", "It selects the count of records to determine how many students have a specific allergy.", "A condition is added to filter the 'Allergy' column for the specified allergy using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "description": "This virtual table provides the count of students who have a specific allergy from the 'Has_Allergy' table. The placeholder in the WHERE clause represents the name of the allergy.", "virtual_table": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.508", "db_id": "allergy_1", "question": "Which students are unaffected by allergies?", "rationale": ["The query starts by selecting the 'StuID' from the 'Student' table, which contains all students.", "Then, it uses the EXCEPT clause to remove any 'StuID' that appears in the 'Has_Allergy' table, which lists students with allergies."], "gold_sql": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy", "source_tables": ["has_allergy", "student"], "description": "This virtual table identifies students from the 'Student' table who do not have any allergies recorded in the 'Has_Allergy' table. The query uses the EXCEPT clause to exclude students with allergies from the list of all students.", "virtual_table": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy"}
{"sample_id": "train.509", "db_id": "allergy_1", "question": "How many female students have milk or egg allergies?", "rationale": ["The query identifies the relevant tables, 'Has_Allergy' and 'Student', and uses a JOIN to combine them based on the student ID.", "It selects the count of students who meet the specified criteria.", "The WHERE clause filters the results based on the gender of the students and checks for specific allergies using placeholders for string values."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies being queried.", "virtual_table": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["The query identifies the relevant tables, which are 'Has_Allergy' and 'Student'.", "It uses a JOIN operation to combine records from both tables based on the student ID (StuID).", "The SELECT statement counts the number of records that meet the specified conditions.", "The WHERE clause filters the results based on the gender of the students and checks for specific allergies using placeholders for string values."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies being queried.", "virtual_table": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.513", "db_id": "allergy_1", "question": "Which allergy has most number of students affected?", "rationale": ["The query identifies the relevant table, which is 'Has_Allergy'.", "It selects the 'Allergy' column to display the names of allergies.", "The GROUP BY clause is used to group the results by the 'Allergy' name.", "The ORDER BY clause sorts the results based on the count of occurrences in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many results they want to see."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "description": "This virtual table provides a list of allergies from the 'Has_Allergy' table, grouped by the allergy name and ordered by the frequency of occurrence. The placeholder in the LIMIT clause allows the user to specify the maximum number of allergies to retrieve.", "virtual_table": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.518", "db_id": "allergy_1", "question": "How many students are affected by each allergy type?", "rationale": ["The query identifies the relevant tables, which are 'Has_Allergy' and 'Allergy_Type'.", "It performs a JOIN operation on the 'Allergy' column to combine data from both tables.", "The SELECT statement retrieves the 'allergytype' from the 'Allergy_Type' table and counts the number of occurrences from the 'Has_Allergy' table.", "The GROUP BY clause is used to aggregate the results by 'allergytype', allowing us to see the count of students for each type of allergy."], "gold_sql": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype", "source_tables": ["has_allergy", "allergy_type"], "description": "This virtual table summarizes the count of students with different types of allergies by joining the 'Has_Allergy' and 'Allergy_Type' tables. The placeholder in the SELECT statement represents the allergy type, and the count reflects the number of students associated with each allergy type.", "virtual_table": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'lname' and 'age'.", "Add a condition to filter students based on their allergies by using a subquery that checks for students with both specified allergies using the INTERSECT operator. The placeholders represent the names of the allergies."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the last names and ages of students from the 'Student' table who have two specific allergies. The placeholders in the query represent the names of the allergies that are being checked for each student.", "virtual_table": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.522", "db_id": "allergy_1", "question": "What are the allergies the girl named Lisa has? And what are the types of them? Order the result by allergy names.", "rationale": ["The query identifies the relevant tables: 'Allergy_Type', 'Has_Allergy', and 'Student'.", "It selects the columns 'Allergy' and 'AllergyType' from the 'Allergy_Type' table.", "The JOIN operations link the 'Has_Allergy' table to the 'Allergy_Type' table and the 'Student' table based on the foreign key relationships.", "A condition is added to filter results by the student's first name using a placeholder for string values.", "The results are ordered by the 'Allergy' column."], "gold_sql": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  'Lisa' ORDER BY T1.Allergy", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.", "virtual_table": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["The query identifies the relevant table, which is 'Student', to calculate the average age.", "It uses a subquery to find students who have allergies of a specific type by joining 'Has_Allergy' and 'Allergy_Type'.", "The INTERSECT operator is used to ensure that only students with both specified allergy types are considered.", "Finally, the average age is calculated for the filtered list of students."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.", "virtual_table": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.527", "db_id": "allergy_1", "question": "List the first and last name of the students who do not have any food type allergy.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'fname' and 'lname'.", "Add a condition to filter out students whose IDs are in a subquery.", "The subquery selects student IDs from 'Has_Allergy' joined with 'Allergy_Type' where the allergy type matches the specified placeholder."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.", "virtual_table": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.529", "db_id": "allergy_1", "question": "Find the number of male (sex is 'M') students who have some food type allery.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It counts the total number of students that meet certain criteria.", "The first condition filters students based on their gender using a placeholder for string values.", "The second condition checks if the student's ID is in a subquery that joins 'Has_Allergy' and 'Allergy_Type' to filter by a specific allergy type, using another placeholder for string values."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a specific type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy.", "virtual_table": "SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["The query identifies the relevant tables, which are 'Student' and 'Has_Allergy'.", "It selects distinct values for the 'fname' and 'city_code' columns from the 'Student' table.", "A JOIN operation is performed between 'Student' and 'Has_Allergy' on the 'StuID' column to link students with their allergies.", "The WHERE clause filters the results based on the specified allergies using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides a list of distinct first names and city codes of students who have specific allergies. The placeholders in the WHERE clause represent the names of the allergies being queried.", "virtual_table": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  [PLACEHOLDER-TYPE:STRING] OR T2.Allergy  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.533", "db_id": "allergy_1", "question": "Find the number of students who are older than 18 and do not have allergy to either food or animal.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "It counts the total number of students that meet the specified criteria.", "A condition is added to filter students based on their age using a placeholder for numeric values.", "A subquery is used to exclude students who have allergies of specified types by joining 'Has_Allergy' and 'Allergy_Type' tables, with placeholders for the allergy types."], "gold_sql": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' OR T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "description": "This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age threshold and the allergy types to be excluded.", "virtual_table": "SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.535", "db_id": "allergy_1", "question": "Find the first name and major of the students who are not allegry to soy.", "rationale": ["The query identifies the relevant table, which is 'Student'.", "Select the columns to display, 'Fname' and 'Major'.", "Add a condition to filter out students who have a specific allergy by using a subquery that checks the 'StuID' in the 'Has_Allergy' table for the specified allergy, using a placeholder for string values."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "description": "This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy being checked against the 'Has_Allergy' table.", "virtual_table": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_country' and calculates the average of the 'total' column.", "The results are grouped by 'billing_country' to aggregate the totals for each country.", "The results are ordered by the average total in descending order to show the highest averages first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "description": "This virtual table provides the average total amount of invoices grouped by billing country. The results are ordered in descending order based on the average total, and a placeholder is included to limit the number of results returned.", "virtual_table": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.553", "db_id": "store_1", "question": "List every album ordered by album title in ascending order.", "rationale": ["The query identifies the relevant table, which is 'albums'.", "Select the column to display, 'title'.", "Add an ORDER BY clause to sort the results by the 'title' column in ascending order."], "gold_sql": "SELECT title FROM albums ORDER BY title;", "source_tables": ["albums"], "description": "This virtual table lists the titles of all albums from the 'albums' table, sorted in alphabetical order. The query retrieves the 'title' column and orders the results by the album title.", "virtual_table": "SELECT title FROM albums ORDER BY title;"}
{"sample_id": "train.560", "db_id": "store_1", "question": "What are the total amount of money in the invoices billed from Chicago, Illinois?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the sum of the 'total' column to calculate the total amount of invoices.", "A condition is added to filter the results based on the 'billing_city' and 'billing_state' columns using placeholders for string values."], "gold_sql": "SELECT sum(total) FROM invoices WHERE billing_city  =  'Chicago' AND billing_state  =  'IL';", "source_tables": ["invoices"], "description": "This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.", "virtual_table": "SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' column and counts the number of invoices for each state.", "A condition is added to filter the results based on the 'billing_country' using a placeholder for string values.", "The results are grouped by 'billing_state' to provide a count of invoices per state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "description": "This virtual table summarizes the number of invoices issued in each state within a specific country. The placeholder in the WHERE clause represents the name of the country for which the invoice data is being aggregated.", "virtual_table": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state;"}
{"sample_id": "train.565", "db_id": "store_1", "question": "List the state in the US with the most invoices.", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' and counts the number of invoices for each state.", "A condition is added to filter the results based on the specified 'billing_country' using a placeholder for string values.", "The results are grouped by 'billing_state' to aggregate the counts.", "The results are ordered by the count of invoices in descending order to show the states with the most invoices first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "description": "This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country for which the invoice counts are being aggregated, while the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.", "virtual_table": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' and counts the number of invoices for each state.", "A condition is added to filter the results based on the specified 'billing_country' using a placeholder for string values.", "The results are grouped by 'billing_state' to aggregate the counts.", "The results are ordered by the count of invoices in descending order to show the states with the most invoices first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "description": "This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country name, while the placeholder in the LIMIT clause indicates the maximum number of states to return, sorted by the count of invoices in descending order.", "virtual_table": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.567", "db_id": "store_1", "question": "List the number of invoices and the invoice total from California.", "rationale": ["The query identifies the relevant table, which is 'invoices'.", "It selects the 'billing_state' column along with a count of invoices and the sum of the total amounts.", "A condition is added to filter the results based on the specified 'billing_state' using a placeholder for string values."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "description": "This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.", "virtual_table": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["The query identifies the relevant table, which is 'customers'.", "Select the columns to display, 'email' and 'phone'.", "Add conditions to filter the 'first_name' and 'last_name' columns for the specified customer using placeholders for string values."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "description": "This virtual table describes the email addresses and phone numbers of customers from the 'customers' table who have a specific first and last name. The placeholders in the WHERE clause represent the customer's first and last names.", "virtual_table": "SELECT email ,  phone FROM customers WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'customers'.", "It selects the 'first_name' and 'last_name' columns from the 'employees' table, aliased as T1.", "A JOIN operation is performed between 'employees' (T1) and 'customers' (T2) on the condition that the employee's ID matches the support representative ID in the customers table.", "The results are grouped by the employee's ID to aggregate the number of customers each representative supports.", "The results are ordered in descending order based on the count of customers, and a limit is applied to restrict the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "description": "This virtual table provides a list of support representatives' first and last names from the 'employees' table, who are associated with customers in the 'customers' table. The results are grouped by the representative's ID and ordered by the number of customers they support, with a limit on the number of representatives returned based on a specified number.", "virtual_table": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.594", "db_id": "store_1", "question": "What is the full name of the employee who has the most customers?", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'customers'.", "It selects the 'first_name' and 'last_name' columns from the 'employees' table, aliased as T1.", "A JOIN operation is performed between 'employees' and 'customers' on the condition that the employee's ID matches the support representative ID in the customers table.", "The results are grouped by the employee's ID to aggregate the data based on the number of customers they support.", "The results are ordered in descending order based on the count of customers associated with each employee.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "description": "This virtual table provides the first and last names of employees who serve as support representatives for customers. The data is aggregated by the employee's ID, and the results are ordered by the number of customers they support in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.604", "db_id": "store_1", "question": "How many employees who are IT staff are from each city?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the count of employees and the city they reside in.", "A condition is added to filter employees based on their job title using a placeholder for string values.", "The results are grouped by city to provide a count of employees in each city for the specified job title."], "gold_sql": "SELECT count(*) ,  city FROM employees WHERE title  =  'IT Staff' GROUP BY city", "source_tables": ["employees"], "description": "This virtual table provides a count of employees grouped by their city, specifically for those who hold a certain job title. The placeholder in the WHERE clause represents the job title of the employees.", "virtual_table": "SELECT count(*) ,  city FROM employees WHERE title  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city"}
{"sample_id": "train.624", "db_id": "store_1", "question": "What is the name of the album that has the track Ball to the Wall?", "rationale": ["The query identifies the relevant tables, which are 'albums' and 'tracks'.", "It selects the 'title' column from the 'albums' table.", "A JOIN is performed between 'albums' and 'tracks' on the condition that the album's ID matches the genre ID of the track, which is likely a mistake since it should match the album ID instead.", "A condition is added to filter the tracks by their name using a placeholder for string values."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "description": "This virtual table describes the titles of albums from the 'albums' table that contain tracks of a specific name. The placeholder in the WHERE clause represents the name of the track.", "virtual_table": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["The query identifies the relevant tables: 'genres', 'tracks', and 'media_types'.", "It selects the 'name' column from the 'tracks' table (aliased as T2).", "It joins the 'genres' table (aliased as T1) on the genre ID to filter tracks by genre.", "It also joins the 'media_types' table (aliased as T3) on the media type ID to filter tracks by media type.", "The WHERE clause includes conditions to filter by the specified genre name or media type name using placeholders for string values."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "description": "This virtual table describes the names of tracks from the 'tracks' table that belong to a specific genre or media type. The placeholders in the WHERE clause represent the genre's name and the media type's name.", "virtual_table": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = [PLACEHOLDER-TYPE:STRING] OR T3.name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.946", "db_id": "medicine_enzyme_interaction", "question": "What are the names and trade names of the medcines that are FDA approved?", "rationale": ["The query is identifying the relevant table, which is 'medicine'.", "Select the columns to display, 'name' and 'Trade_Name'.", "Add a condition to filter the 'FDA_approved' column for the specified approval status using a placeholder for string values."], "gold_sql": "SELECT name ,  trade_name FROM medicine WHERE FDA_approved  =  'Yes'", "source_tables": ["medicine"], "description": "This virtual table describes the names and trade names of medicines from the 'medicine' table that have a specific FDA approval status. The placeholder in the WHERE clause represents the FDA approval status of the medicine.", "virtual_table": "SELECT name ,  trade_name FROM medicine WHERE FDA_approved  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.951", "db_id": "medicine_enzyme_interaction", "question": "What are the ids, names and FDA approval status of medicines in descending order of the number of enzymes that it can interact with.", "rationale": ["The query identifies the relevant tables, 'medicine' and 'medicine_enzyme_interaction'.", "It selects the columns 'id', 'name', and 'FDA_approved' from the 'medicine' table, aliased as T1.", "A JOIN operation is performed between 'medicine' (T1) and 'medicine_enzyme_interaction' (T2) on the condition that the medicine IDs match.", "The results are grouped by the medicine ID to aggregate the interaction counts.", "Finally, the results are ordered by the count of interactions in descending order."], "gold_sql": "SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC", "source_tables": ["medicine", "medicine_enzyme_interaction"], "description": "This virtual table provides a list of medicines along with their unique identifiers and FDA approval status, sorted by the number of interactions they have with enzymes. The placeholders in the query allow for dynamic filtering and sorting based on the interaction count.", "virtual_table": "SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC"}
{"sample_id": "train.953", "db_id": "medicine_enzyme_interaction", "question": "What is the id and name of the enzyme with most number of medicines that can interact as 'activator'?", "rationale": ["The query identifies the relevant tables, which are 'enzyme' and 'medicine_enzyme_interaction'.", "It selects the columns 'id' and 'name' from the 'enzyme' table, aliased as T1.", "A JOIN operation is performed between 'enzyme' (T1) and 'medicine_enzyme_interaction' (T2) on the enzyme ID to link the two tables.", "A condition is added to filter the results based on the specified 'interaction_type' using a placeholder for string values.", "The results are grouped by the enzyme ID to aggregate the data, and ordered by the count of interactions in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  'activitor' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["enzyme", "medicine_enzyme_interaction"], "description": "This virtual table provides a list of enzyme identifiers and their names from the 'enzyme' table that are involved in a specific type of interaction with medicines. The interaction type is specified by a placeholder, and the results are grouped by enzyme ID, ordered by the frequency of interactions in descending order, with a limit on the number of results returned.", "virtual_table": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.968", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that can interact as an inhibitor and activitor with enzymes?", "rationale": ["The query identifies the relevant tables, which are 'medicine' and 'medicine_enzyme_interaction'.", "It selects the columns to display, 'name' and 'trade_name' from the 'medicine' table.", "The query uses a JOIN to connect the 'medicine' table with the 'medicine_enzyme_interaction' table based on the medicine's ID.", "It adds a condition to filter the results based on the 'interaction_type' column using placeholders for string values.", "The INTERSECT operator is used to find common medicines that meet the specified interaction types in two separate queries."], "gold_sql": "SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'inhibitor' INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'activitor'", "source_tables": ["medicine", "medicine_enzyme_interaction"], "description": "This virtual table describes the names and trade names of medicines that have specific types of interactions with enzymes. The placeholders in the WHERE clause represent the types of interactions being queried.", "virtual_table": "SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.970", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that cannot interact with the enzyme with the product 'Heme'?", "rationale": ["The query identifies the relevant table, which is 'medicine'.", "Select the columns to display, 'name' and 'trade_name'.", "Use the EXCEPT clause to filter out medicines that interact with a specific enzyme product.", "Join the 'medicine' table with 'medicine_enzyme_interaction' and 'enzyme' tables to find the medicines that have interactions with the specified enzyme product using a placeholder for string values."], "gold_sql": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  'Protoporphyrinogen IX'", "source_tables": ["enzyme", "medicine", "medicine_enzyme_interaction"], "description": "This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product name of the enzyme.", "virtual_table": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1355", "db_id": "college_2", "question": "What is the name of the department with an instructure who has a name like 'Soisalon'?", "rationale": ["The query identifies the relevant table, which is 'instructor'.", "Select the column to display, 'dept_name'.", "Add a condition to filter the 'name' column using a LIKE operator for pattern matching with a placeholder for string values."], "gold_sql": "SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'", "source_tables": ["instructor"], "description": "This virtual table provides the names of academic departments associated with instructors whose names match a specified pattern. The placeholder in the WHERE clause allows for flexible searching of instructor names.", "virtual_table": "SELECT dept_name FROM instructor WHERE name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1365", "db_id": "college_2", "question": "What are the titles of courses that are in the Statistics department but not the Psychology department?", "rationale": ["The query identifies the relevant table, which is 'course'.", "It selects the 'title' column to display the names of the courses.", "The first WHERE clause filters the courses by the first specified department using a placeholder for string values.", "The EXCEPT clause is used to exclude the titles of courses from the second specified department, also using a placeholder for string values."], "gold_sql": "SELECT title FROM course WHERE dept_name  =  'Statistics' EXCEPT SELECT title FROM course WHERE dept_name  =  'Psychology'", "source_tables": ["course"], "description": "This virtual table lists the titles of courses offered by one academic department that are not offered by another academic department. The placeholders in the WHERE clause represent the names of the departments being compared.", "virtual_table": "SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT title FROM course WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1424", "db_id": "college_2", "question": "Find the title of course whose prerequisite is course Differential Geometry.", "rationale": ["The query identifies the relevant table, which is 'course'.", "It selects the 'title' column to display the names of the courses.", "A subquery is used to find the 'course_id' of courses that have prerequisites, joining the 'prereq' table with the 'course' table based on the prerequisite course ID.", "The condition in the subquery filters the courses based on the title of the prerequisite course using a placeholder for string values."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  'Differential Geometry')", "source_tables": ["course", "prereq"], "description": "This virtual table lists the titles of courses from the 'course' table that have prerequisites. The prerequisite courses are identified by their titles, which are specified using a placeholder in the subquery.", "virtual_table": "SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.1426", "db_id": "college_2", "question": "Find the names of students who have taken any course in the fall semester of year 2003.", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the 'name' column to display the names of the students.", "A subquery is used to filter students based on their enrollment in courses during a specified semester and year, using placeholders for these values."], "gold_sql": "SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  'Fall' AND YEAR  =  2003)", "source_tables": ["student", "takes"], "description": "This virtual table describes the names of students who are enrolled in courses during a specific semester and year. The placeholders in the WHERE clause represent the semester and year for which the student enrollment is being queried.", "virtual_table": "SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.1435", "db_id": "college_2", "question": "What are the names of all instructors who advise students in the math depart sorted by total credits of the student.", "rationale": ["The query identifies the relevant tables: 'advisor', 'instructor', and 'student'.", "It selects the 'name' column from the 'instructor' table (aliased as T2).", "The JOIN operations link the 'advisor' table (T1) with the 'instructor' table (T2) based on the instructor's ID, and with the 'student' table (T3) based on the student's ID.", "A condition is added to filter the results based on the department name from the 'student' table using a placeholder for string values.", "Finally, the results are ordered by the total credits earned by the students."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id WHERE T3.dept_name  =  'Math' ORDER BY T3.tot_cred", "source_tables": ["instructor", "student", "advisor"], "description": "This virtual table lists the names of instructors who are advising students from a specific department. The placeholder in the WHERE clause represents the department's name, and the results are ordered by the total credits earned by the students.", "virtual_table": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id WHERE T3.dept_name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T3.tot_cred"}
{"sample_id": "train.1436", "db_id": "college_2", "question": "What is the course title of the prerequisite of course Mobile Computing?", "rationale": ["The query identifies the relevant table, which is 'course'.", "It selects the 'title' column to display the names of the courses.", "The WHERE clause filters the courses based on their IDs, which are obtained from a subquery.", "The subquery joins the 'prereq' table with the 'course' table to find the prerequisite IDs for the specified course title, using a placeholder for the course title."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  'Mobile Computing')", "source_tables": ["course", "prereq"], "description": "This virtual table lists the titles of courses that are prerequisites for a specific course identified by its title. The placeholder in the WHERE clause represents the title of the course for which the prerequisites are being queried.", "virtual_table": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.1439", "db_id": "college_2", "question": "What is the name of the instructor who advises the student with the greatest number of total credits?", "rationale": ["The query identifies the relevant tables: 'advisor', 'instructor', and 'student'.", "It selects the 'name' column from the 'instructor' table (aliased as T2).", "The JOIN operation connects the 'advisor' table (T1) with the 'instructor' table (T2) based on the instructor's ID, and with the 'student' table (T3) based on the student's ID.", "The results are ordered by the 'tot_cred' column from the 'student' table in descending order to prioritize students with the most credits.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT 1", "source_tables": ["instructor", "student", "advisor"], "description": "This virtual table lists the names of instructors who are advising students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.", "virtual_table": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1448", "db_id": "college_2", "question": "Find the number and averaged salary of all instructors who are in the department with the highest budget.", "rationale": ["The query identifies the relevant tables, which are 'instructor' and 'department'.", "It selects the average salary from the 'instructor' table and counts the number of instructors.", "A join is performed on the 'dept_name' column to associate instructors with their departments.", "The results are ordered by the 'budget' column from the 'department' table in descending order.", "A limit is applied to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "description": "This virtual table calculates the average salary of instructors grouped by their respective departments, and counts the number of instructors in each department. The results are ordered by the department's budget in descending order, with a limit on the number of departments returned based on a specified number.", "virtual_table": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1449", "db_id": "college_2", "question": "How many instructors are in the department with the highest budget, and what is their average salary?", "rationale": ["The query identifies the relevant tables, which are 'instructor' and 'department'.", "It selects the average salary from the 'instructor' table and counts the number of instructors.", "A JOIN operation is performed on the 'dept_name' column to associate instructors with their respective departments.", "The results are ordered by the 'budget' column from the 'department' table in descending order.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "description": "This virtual table provides the average salary of instructors along with the count of instructors in each department, sorted by the department's budget in descending order. The placeholder in the LIMIT clause represents the maximum number of departments to be displayed.", "virtual_table": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1452", "db_id": "college_2", "question": "Find the name of students who didn't take any course from Biology department.", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the 'name' column to display the names of students.", "The condition filters out students whose IDs are found in a subquery that checks for enrollment in courses from a specified department, using a placeholder for the department's name."], "gold_sql": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  'Biology')", "source_tables": ["course", "student", "takes"], "description": "This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.", "virtual_table": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.1458", "db_id": "college_2", "question": "Find the name and salary of instructors whose salary is below the average salary of the instructors in the Physics department.", "rationale": ["The query identifies the relevant table, which is 'instructor'.", "Select the columns to display, 'name' and 'salary'.", "Add a condition to filter the instructors based on their salary being less than the average salary of instructors in a specific department.", "The subquery calculates the average salary for instructors in the specified department using a placeholder for string values."], "gold_sql": "SELECT name ,  salary FROM instructor WHERE salary  <  (SELECT avg(salary) FROM instructor WHERE dept_name  =  'Physics')", "source_tables": ["instructor"], "description": "This virtual table provides the names and salaries of instructors from the 'instructor' table who earn less than the average salary of instructors within a specified department. The placeholder in the subquery represents the department's name.", "virtual_table": "SELECT name ,  salary FROM instructor WHERE salary  <  (SELECT avg(salary) FROM instructor WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.1461", "db_id": "college_2", "question": "What are the names of students who have taken Statistics courses?", "rationale": ["The query identifies the relevant tables: 'course', 'takes', and 'student'.", "It selects the 'name' column from the 'student' table.", "The JOIN operations link the 'course' table to the 'takes' table using 'course_id', and the 'takes' table to the 'student' table using 'ID'.", "A condition is added to filter the results based on the 'dept_name' column in the 'course' table, using a placeholder for the department's name."], "gold_sql": "SELECT T3.name FROM course AS T1 JOIN takes AS T2 ON T1.course_id  =  T2.course_id JOIN student AS T3 ON T2.id  =  T3.id WHERE T1.dept_name  =  'Statistics'", "source_tables": ["course", "student", "takes"], "description": "This virtual table lists the names of students who are enrolled in courses offered by a specific academic department. The placeholder in the WHERE clause represents the name of the department.", "virtual_table": "SELECT T3.name FROM course AS T1 JOIN takes AS T2 ON T1.course_id  =  T2.course_id JOIN student AS T3 ON T2.id  =  T3.id WHERE T1.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1464", "db_id": "college_2", "question": "Find the names of all instructors in computer science department", "rationale": ["The query is identifying the relevant table, which is 'instructor'.", "Select the column to display, 'name'.", "Add a condition to filter the 'dept_name' column for the specified department using a placeholder for string values."], "gold_sql": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'", "source_tables": ["instructor"], "description": "This virtual table describes the names of instructors from the 'instructor' table who belong to a specific academic department. The placeholder in the WHERE clause represents the department's name.", "virtual_table": "SELECT name FROM instructor WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1480", "db_id": "college_2", "question": "Find courses that ran in Fall 2009 but not in Spring 2010.", "rationale": ["The query is identifying the relevant table, which is 'SECTION'.", "Select the 'course_id' column to display the course identifiers.", "Add a condition to filter the results based on the specified semester and year using placeholders for string and numeric values.", "Use the EXCEPT clause to exclude course IDs from another specified semester and year."], "gold_sql": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010", "source_tables": ["section"], "description": "This virtual table identifies the course IDs from the 'SECTION' table that are offered in a specific semester and year, excluding those that are offered in another specified semester and year. The placeholders in the query represent the semester and year values for filtering the results.", "virtual_table": "SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT course_id FROM SECTION WHERE semester  =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1489", "db_id": "college_2", "question": "What are the names of instructors who earn more than at least one instructor from the Biology department?", "rationale": ["The query identifies the relevant table, which is 'instructor'.", "Select the column to display, 'name'.", "Add a condition to filter the instructors based on their salary being greater than a subquery result.", "The subquery selects the minimum salary from the 'instructor' table filtered by the specified department using a placeholder for string values."], "gold_sql": "SELECT name FROM instructor WHERE salary  >  (SELECT min(salary) FROM instructor WHERE dept_name  =  'Biology')", "source_tables": ["instructor"], "description": "This virtual table lists the names of instructors from the 'instructor' table who earn a salary greater than the minimum salary of instructors in a specified department. The placeholder in the subquery represents the department's name.", "virtual_table": "SELECT name FROM instructor WHERE salary  >  (SELECT min(salary) FROM instructor WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.1515", "db_id": "insurance_and_eClaims", "question": "Find the total and average amount paid in claim headers.", "rationale": ["The query identifies the relevant table, which is 'Claim_Headers'.", "It selects the sum and average of the 'amount_paid' column to provide a summary of the payments made for claims."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "description": "This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the total and average of the 'amount_paid' column.", "virtual_table": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["The query identifies the relevant table, which is 'Claim_Headers'.", "It selects the sum and average of the 'amount_piad' column to provide a summary of the amounts paid.", "The use of aggregate functions allows for a concise representation of the total and average values."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "description": "This virtual table summarizes the total and average amounts paid for claims from the 'Claim_Headers' table. The placeholders in the SELECT clause represent the aggregated values of the amounts paid.", "virtual_table": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers"}
{"sample_id": "train.1517", "db_id": "insurance_and_eClaims", "question": "Find the total amount claimed in the most recently created document.", "rationale": ["The query identifies the relevant tables, 'Claim_Headers' and 'Claims_Documents'.", "It uses a JOIN to link the claims with their corresponding documents based on the claim ID.", "The SUM function is applied to the 'amount_claimed' column to calculate the total amount for the claims.", "A subquery is used to filter the documents based on their creation date, with a placeholder indicating the limit for the selection."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "description": "This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.", "virtual_table": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["The query identifies the relevant tables: 'Claim_Headers', 'Policies', and 'Customers'.", "It selects the 'customer_details' from the 'Customers' table.", "The join conditions link 'Claim_Headers' to 'Policies' using 'policy_id', and 'Policies' to 'Customers' using 'customer_id'.", "The WHERE clause filters the results to only include the claim with the maximum amount claimed, using a subquery to determine this maximum value."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "description": "This virtual table provides detailed information about the customer associated with the claim that has the highest amount claimed. It retrieves the customer details from the 'Customers' table by joining it with the 'Policies' and 'Claim_Headers' tables based on their relationships. The placeholder in the WHERE clause is used to filter for the maximum claimed amount.", "virtual_table": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)"}
{"sample_id": "train.1527", "db_id": "insurance_and_eClaims", "question": "What is the name of the claim processing stage that most of the claims are on?", "rationale": ["The query identifies the relevant tables, which are 'claims_processing' and 'claims_processing_stages'.", "It selects the 'claim_status_name' from the 'claims_processing_stages' table.", "A JOIN operation is performed on the 'claim_stage_id' to link the two tables together.", "The results are grouped by 'claim_stage_id' to aggregate the data appropriately.", "The results are ordered by the count of occurrences in descending order to prioritize the most common statuses.", "A placeholder is included to allow the user to specify the limit on the number of statuses returned."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "description": "This virtual table provides a summary of the claim statuses from the claims processing stages. It retrieves the names of the claim statuses by joining the 'claims_processing' table with the 'claims_processing_stages' table based on the claim stage identifier. The results are grouped by the claim stage identifier and ordered by the count of occurrences in descending order, allowing the user to specify a limit on the number of statuses returned.", "virtual_table": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.1535", "db_id": "insurance_and_eClaims", "question": "Find the names of all the customers and staff members.", "rationale": ["The query is identifying the relevant tables, which are 'Customers' and 'Staff'.", "It selects the 'Customer_Details' from the 'Customers' table and 'Staff_Details' from the 'Staff' table.", "The UNION operator is used to combine the results from both tables into a single result set."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "description": "This virtual table combines detailed information about customers and staff members from the 'Customers' and 'Staff' tables. The result will include all customer details and staff details in a single unified list.", "virtual_table": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff"}
{"sample_id": "train.1545", "db_id": "insurance_and_eClaims", "question": "Which customer is associated with the latest policy?", "rationale": ["The query identifies the relevant tables, which are 'Policies' and 'Customers'.", "It selects the 'Customer_Details' from the 'Customers' table.", "A JOIN operation is performed on 'Policies' and 'Customers' using the 'Customer_ID' to link them.", "The WHERE clause filters the results to only include the customer details for the policy that has the maximum start date, using a subquery to find this date."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "description": "This virtual table retrieves the detailed information about customers who have the most recently started insurance policy from the 'Policies' table. The placeholder in the WHERE clause represents the condition to find the latest start date of the policy.", "virtual_table": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["The query identifies the relevant tables, which are 'Policies' and 'Customers'.", "It selects the 'Customer_Details' from the 'Customers' table.", "A JOIN operation is performed on 'Policies' and 'Customers' using the 'Customer_ID' to link them.", "The WHERE clause filters the results to only include the customer details for the policy that has the maximum start date, using a subquery to find this date."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "description": "This virtual table retrieves the detailed information about customers who have the most recently started insurance policy from the 'Policies' table. The placeholder in the WHERE clause represents the condition to find the latest start date of the policy.", "virtual_table": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["The query identifies the relevant tables, which are 'Accounts' and 'Customers'.", "It selects the columns to display from the 'Accounts' table: 'account_id', 'date_account_opened', 'account_name', and 'other_account_details'.", "A JOIN operation is performed between 'Accounts' and 'Customers' on the 'customer_id' to link accounts to their respective customers.", "A condition is added to filter the results based on the 'customer_first_name' from the 'Customers' table using a placeholder for string values."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "description": "This virtual table provides details about customer accounts from the 'Accounts' table, including the account ID, the date the account was opened, the account name, and any additional account details. The results are filtered based on the first name of the customer from the 'Customers' table, represented by a placeholder for string values.", "virtual_table": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["The query identifies the relevant tables, which are 'Accounts' and 'Customers'.", "It selects the columns to display, 'account_name' and 'other_account_details' from the 'Accounts' table.", "A JOIN operation is performed to link 'Accounts' with 'Customers' based on the 'customer_id'.", "Conditions are added to filter the results based on the specified first and last names of the customer using placeholders for string values."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "description": "This virtual table describes the account names and additional details of accounts associated with customers from the 'Accounts' table, filtered by the first and last names of the customers. The placeholders in the WHERE clause represent the customer's first and last names.", "virtual_table": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.customer_last_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["The query identifies the relevant tables, which are 'Accounts' and 'Customers'.", "It selects the columns to display, 'customer_first_name' and 'customer_last_name'.", "A JOIN operation is performed on 'customer_id' to link the two tables based on the relationship defined in the schema.", "A condition is added to filter the 'account_name' column for the specified account using a placeholder for string values."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "description": "This virtual table describes the first and last names of customers associated with a specific account from the 'Accounts' and 'Customers' tables. The placeholder in the WHERE clause represents the name of the account.", "virtual_table": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.1569", "db_id": "customers_and_invoices", "question": "Show id, first name and last name for all customers and the number of accounts.", "rationale": ["The query identifies the relevant tables, 'Accounts' and 'Customers'.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' from the 'Customers' table.", "It counts the number of accounts associated with each customer using the COUNT function.", "The JOIN operation links the 'Accounts' table to the 'Customers' table based on the 'customer_id'.", "The GROUP BY clause is used to aggregate the results by 'customer_id', ensuring that the count reflects the number of accounts per customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a summary of customers and their associated accounts. It displays the unique customer identifier, first name, and last name of each customer, along with a count of the number of accounts they hold. The data is aggregated by customer, allowing for insights into customer account distribution.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id"}
{"sample_id": "train.1570", "db_id": "customers_and_invoices", "question": "What are the the full names and ids for all customers, and how many accounts does each have?", "rationale": ["The query identifies the relevant tables, 'Accounts' and 'Customers'.", "It selects the 'customer_id', 'customer_first_name', and 'customer_last_name' from the 'Customers' table.", "It counts the number of accounts for each customer using the COUNT function.", "The JOIN operation links the 'Accounts' table with the 'Customers' table based on the 'customer_id'.", "The GROUP BY clause groups the results by 'customer_id' to aggregate the account counts for each customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "description": "This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.", "virtual_table": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id"}
{"sample_id": "train.1580", "db_id": "customers_and_invoices", "question": "Count the number of financial transactions that correspond to each account id.", "rationale": ["The query identifies the relevant table, which is 'Financial_Transactions'.", "It selects a count of all transactions and groups them by 'account_id'.", "The use of count(*) allows for the aggregation of transaction records associated with each account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "description": "This virtual table provides a count of financial transactions grouped by account ID from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account ID for which the transaction count is being retrieved.", "virtual_table": "SELECT count(*) ,  account_id FROM Financial_transactions"}
{"sample_id": "train.1607", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of invoices for each order.", "rationale": ["The query identifies the relevant table, which is 'Invoices'.", "It selects the 'order_id' to group the results by each order.", "The count function is used to calculate the total number of invoices for each order, and the results are grouped by 'order_id' to provide a summary for each unique order."], "gold_sql": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id", "source_tables": ["invoices"], "description": "This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.", "virtual_table": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["The query identifies the relevant table, which is 'Order_Items'.", "Select the 'order_id' to group the results by each order.", "Use the count function to calculate the total number of items for each order, grouping the results by 'order_id'."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "description": "This virtual table summarizes the total number of items in each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function calculates the total number of items associated with each order.", "virtual_table": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id"}
{"sample_id": "train.1622", "db_id": "customers_and_invoices", "question": "What are teh names of the different products, as well as the number of customers who have ordered each product.", "rationale": ["The query identifies the relevant tables: 'Order_Items', 'Products', and 'Orders'.", "It selects the 'product_name' from the 'Products' table and counts the occurrences of each product ordered.", "The JOIN operations link 'Order_Items' to 'Products' using 'product_id' and to 'Orders' using 'order_id'.", "The GROUP BY clause groups the results by 'product_name' to provide a count for each unique product."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "description": "This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.", "virtual_table": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name"}
{"sample_id": "train.2050", "db_id": "party_people", "question": "Which ministers are not a part of the Progress Party?", "rationale": ["The query identifies the relevant table, which is 'party'.", "Select the column to display, 'minister'.", "Add a condition to filter the 'party_name' column to exclude a specific party using a placeholder for string values."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "description": "This virtual table describes the ministers associated with political parties from the 'party' table, excluding a specific party name. The placeholder in the WHERE clause represents the name of the party to be excluded.", "virtual_table": "SELECT minister FROM party WHERE party_name != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2057", "db_id": "party_people", "question": "Show all party names and the number of members in each party.", "rationale": ["The query identifies the relevant tables, which are 'Member' and 'Party'.", "It selects the 'party_name' from the 'Party' table and counts the number of members from the 'Member' table.", "A JOIN operation is performed on the 'party_id' to link members to their respective parties.", "The results are grouped by 'party_id' to aggregate the count of members for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "description": "This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement allows for the retrieval of the party name and the count of members belonging to that party.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2072", "db_id": "party_people", "question": "How many events are there for each party?", "rationale": ["The query identifies the relevant tables, which are 'party_events' and 'party'.", "It uses a JOIN operation to connect 'party_events' with 'party' based on the 'party_id'.", "The SELECT statement retrieves the 'party_name' from the 'party' table and counts the number of events from the 'party_events' table.", "The GROUP BY clause groups the results by 'party_id' to ensure the count is calculated for each individual party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "description": "This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT statement represents the party names, while the count function aggregates the total number of events for each party.", "virtual_table": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["The query identifies the relevant tables: 'region', 'party', and 'party_events'.", "It uses JOIN operations to connect these tables based on their foreign key relationships: 'region_id' from 'party' and 'party_id' from 'party_events'.", "The SELECT statement counts the number of events that match the specified criteria.", "The WHERE clause filters the results based on the region name and event name using placeholders for string values."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "description": "This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.", "virtual_table": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2167", "db_id": "formula_1", "question": "What is the id and family name of the driver who has the longest laptime?", "rationale": ["The query identifies the relevant tables, which are 'drivers' and 'lapTimes'.", "It selects the 'driverId' and 'surname' from the 'drivers' table.", "A JOIN operation is performed between 'drivers' and 'lapTimes' on the 'driverId' to associate drivers with their lap times.", "The results are ordered by the 'milliseconds' column from the 'lapTimes' table in descending order to show the fastest lap times first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "description": "This virtual table provides a list of drivers along with their surnames from the 'drivers' table, ordered by their lap times recorded in the 'lapTimes' table. The results are limited to a specified number of entries, represented by a placeholder for numeric values.", "virtual_table": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2174", "db_id": "formula_1", "question": "How many drivers did not race in 2009?", "rationale": ["The query identifies the relevant table, which is 'results', to count the distinct drivers.", "It uses a subquery to filter out race IDs from the 'races' table based on the specified year using a placeholder for numeric values.", "The final output is the count of distinct driver IDs from the 'results' table that are not associated with the excluded races."], "gold_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )", "source_tables": ["results", "races"], "description": "This virtual table counts the distinct number of drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.", "virtual_table": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.2179", "db_id": "formula_1", "question": "Find the id and forenames of drivers who participated both the races with name Australian Grand Prix and the races with name Chinese Grand Prix?", "rationale": ["The query identifies the relevant tables: 'races', 'results', and 'drivers'.", "It selects the 'driverId' and 'forename' columns to display the driver's unique identifier and first name.", "The query uses JOIN operations to connect the 'races' table with the 'results' and 'drivers' tables based on their relationships.", "The WHERE clause filters the results based on the names of the races, using placeholders for the race names.", "The INTERSECT operator is used to find drivers who participated in both specified races."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.", "virtual_table": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2180", "db_id": "formula_1", "question": "What is the id and first name of all the drivers who participated in the Australian Grand Prix and the Chinese Grand Prix?", "rationale": ["The query identifies the relevant tables: 'races', 'results', and 'drivers'.", "It selects the 'driverId' and 'forename' columns to display the unique identifiers and first names of the drivers.", "The query uses JOIN operations to connect the 'races' table with the 'results' and 'drivers' tables based on their relationships.", "The WHERE clause filters the results based on the names of the races, using placeholders for the race names.", "The INTERSECT operator is used to find drivers who participated in both specified races."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.", "virtual_table": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["The query identifies the relevant tables: 'races', 'results', and 'drivers'.", "It selects the 'forename' and 'surname' columns from the 'drivers' table.", "The query uses JOINs to connect the 'races' and 'results' tables to the 'drivers' table based on their respective IDs.", "It filters the results to include drivers from a specific race using a placeholder for the race name.", "The EXCEPT clause is used to exclude drivers from another specified race, again using a placeholder for the race name."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "description": "This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.", "virtual_table": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2190", "db_id": "formula_1", "question": "For each constructor id, how many races are there?", "rationale": ["The query identifies the relevant table, which is 'constructorStandings'.", "It selects a count of records and groups them by 'constructorId' to summarize the standings for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "description": "This virtual table provides a count of the total number of constructor standings for each constructor from the 'constructorStandings' table. The placeholder in the SELECT statement represents the constructor's identifier, which is grouped to show the total standings for each constructor.", "virtual_table": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid"}
{"sample_id": "train.2194", "db_id": "formula_1", "question": "What are the names of all races held after 2000 in Spain?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'circuits'.", "It selects distinct race names from the 'races' table.", "A JOIN operation is performed between 'races' and 'circuits' on the circuitId to link races to their respective circuits.", "Conditions are added to filter the results based on the specified country and year using placeholders for string and numeric values."], "gold_sql": "SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = 'Spain' AND T1.year > 2000", "source_tables": ["races", "circuits"], "description": "This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.", "virtual_table": "SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2217", "db_id": "formula_1", "question": "Find the names of Japanese constructors that have once earned more than 5 points?", "rationale": ["The query identifies the relevant tables, which are 'constructors' and 'constructorStandings'.", "It selects the 'name' column from the 'constructors' table.", "A JOIN operation is performed between 'constructors' and 'constructorStandings' on the 'constructorId' to link constructors with their standings.", "Conditions are added to filter constructors based on their nationality using a placeholder for string values and to ensure they have more points than a specified number using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "description": "This virtual table describes the official names of constructors from the 'constructors' table who are from a specific nationality and have scored more points than a specified threshold in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.", "virtual_table": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = [PLACEHOLDER-TYPE:STRING] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["The query identifies the relevant tables, which are 'constructors' and 'constructorStandings'.", "It selects the 'name' column from the 'constructors' table.", "A JOIN operation is performed between 'constructors' and 'constructorStandings' on the 'constructorId' to link constructors with their standings.", "Conditions are added to filter constructors by their nationality using a placeholder for string values and to ensure they have more points than a specified threshold using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "description": "This virtual table lists the names of constructors from the 'constructors' table who have a specific nationality and have scored more than a certain number of points in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.", "virtual_table": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = [PLACEHOLDER-TYPE:STRING] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It joins the 'races' table with the 'results' table on the race ID to correlate race data with results.", "The SELECT statement calculates the average of the 'fastestLapSpeed' from the 'results' table.", "A condition is added to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "This virtual table calculates the average fastest lap speed from the 'results' table for races that occurred in a specific year and have a particular name. The placeholders in the WHERE clause represent the year of the race and the name of the race.", "virtual_table": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["The query identifies the relevant tables, which are 'races' and 'results'.", "It selects the maximum value of 'fastestLapSpeed' from the 'results' table.", "A JOIN operation is performed between 'races' and 'results' on the 'raceId' to correlate race details with their results.", "Conditions are added to filter the results based on the specified year and race name using placeholders for numeric and string values."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "description": "This virtual table provides the maximum fastest lap speed recorded during races held in a specific year and with a specific race name. The placeholders in the WHERE clause represent the year of the race and the name of the race.", "virtual_table": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T1.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2223", "db_id": "formula_1", "question": "What are the maximum fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["The query identifies the relevant tables, 'races' and 'results'.", "It selects the maximum fastest lap speed from the 'results' table, the race name, and the year from the 'races' table.", "A JOIN operation is performed on the raceId to combine data from both tables.", "A condition is added to filter the results for races that occurred after a specified year using a placeholder for numeric values.", "The results are grouped by race name to ensure unique entries and ordered by year."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "description": "This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents a specific year, allowing users to filter races that occurred after that year.", "virtual_table": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["The query identifies the relevant tables, 'races' and 'results', and joins them on the raceId to combine race information with results.", "It selects the maximum fastest lap speed from the results table, the race name, and the year from the races table.", "A condition is added to filter the races based on the specified year using a placeholder for numeric values.", "The results are grouped by the race name to ensure that the maximum speed is calculated for each race, and they are ordered by the year of the race."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "description": "This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The results are filtered to include only races that occurred after a specified year, and the data is grouped by the race name and ordered by the year.", "virtual_table": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year"}
{"sample_id": "train.2325", "db_id": "csu_1", "question": "What campuses are located in the county of Los Angeles?", "rationale": ["The query is identifying the relevant table, which is 'Campuses'.", "Select the column to display, 'Campus'.", "Add a condition to filter the 'county' column for the specified county using a placeholder for string values."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "description": "This virtual table describes the names of campuses from the 'Campuses' table that are located in a specific county. The placeholder in the WHERE clause represents the name of the county.", "virtual_table": "SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2347", "db_id": "csu_1", "question": "In what year was the most degrees conferred?", "rationale": ["The query identifies the relevant table, which is 'degrees'.", "It selects the 'Year' column to display the years when degrees were awarded.", "The results are grouped by 'Year' to aggregate the data.", "The ordering is done based on the sum of degrees awarded in descending order to show the most significant years first.", "A limit is applied to restrict the number of years returned, using a placeholder for numeric values."], "gold_sql": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "description": "This virtual table summarizes the years in which degrees were awarded, grouped by year and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause represents the maximum number of years to return.", "virtual_table": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2348", "db_id": "csu_1", "question": "Which campus has the most degrees conferred in all times?", "rationale": ["The query identifies the relevant table, which is 'degrees'.", "It selects the 'campus' column to display the names of the campuses.", "The results are grouped by the 'campus' to aggregate the data.", "The campuses are ordered by the sum of degrees awarded in descending order to show the campuses with the highest number of degrees first.", "A limit is applied to restrict the number of campuses returned, using a placeholder for numeric values."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "description": "This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name. The campuses are ordered by the total number of degrees awarded, in descending order, and the result is limited to a specified number of campuses. The placeholder in the LIMIT clause represents the maximum number of campuses to return.", "virtual_table": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2349", "db_id": "csu_1", "question": "What campus has the most degrees  conferrred over its entire existence?", "rationale": ["The query identifies the relevant table, which is 'degrees'.", "It selects the 'campus' column to display the campuses.", "The results are grouped by the 'campus' to aggregate the data.", "The campuses are ordered by the sum of degrees awarded in descending order to show the campuses with the highest number of degrees first.", "A limit is applied to restrict the number of campuses returned, using a placeholder for numeric values."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "description": "This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name. The campuses are ordered by the total number of degrees awarded, in descending order, and the result is limited to a specified number of campuses. The placeholder in the LIMIT clause represents the maximum number of campuses to return.", "virtual_table": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2351", "db_id": "csu_1", "question": "What campus has the most faculties in 2003?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'faculty'.", "It selects the 'campus' column from the 'Campuses' table.", "A JOIN operation is performed between 'Campuses' and 'faculty' on the campus identifier to combine data from both tables.", "A condition is added to filter the results based on the specified year using a placeholder for numeric values.", "The results are ordered by the number of faculty members in descending order.", "A LIMIT clause is included to restrict the number of returned campuses based on a specified number."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "description": "This virtual table lists the campuses from the 'Campuses' table that have faculty data for a specific year. The campuses are ordered by the number of faculty members in descending order, and the result is limited to a specified number of campuses. The placeholders in the WHERE clause and LIMIT clause represent the year of the faculty data and the maximum number of campuses to return, respectively.", "virtual_table": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2358", "db_id": "csu_1", "question": "For each Orange county campus, report the number of degrees granted after 2000.", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'campus' from the 'Campuses' table and sums the 'degrees' from the 'degrees' table.", "A JOIN operation is performed on the campus identifiers to link the two tables.", "Conditions are added to filter the results based on the specified county and the year using placeholders for string and numeric values.", "The results are grouped by campus to provide a total count of degrees awarded per campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "description": "This virtual table summarizes the total number of degrees awarded by each campus located in a specific county, filtering for degrees awarded from a certain year onwards. The placeholders in the WHERE clause represent the county's name and the starting year for the degree records.", "virtual_table": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'campus' from the 'Campuses' table and sums the 'degrees' from the 'degrees' table.", "A JOIN operation is performed on the campus identifiers to link the two tables.", "Conditions are added to filter the results based on the specified county and the year using placeholders for string and numeric values.", "The results are grouped by campus to aggregate the total degrees awarded."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "description": "This virtual table summarizes the total number of degrees awarded by each campus located in a specific county, filtering the results for degrees awarded from a certain year onwards. The placeholders in the WHERE clause represent the county name and the year threshold.", "virtual_table": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'enrollments'.", "It selects the 'campus' column from the 'Campuses' table.", "A JOIN operation is performed to link 'Campuses' with 'enrollments' based on the campus identifier.", "Conditions are added to filter results based on the specified year and thresholds for total and full-time equivalent enrollments using placeholders for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "description": "This virtual table identifies campuses from the 'Campuses' table that have a specific number of total enrollments and full-time equivalent enrollments for a given academic year. The placeholders in the WHERE clause represent the year, total enrollment threshold, and full-time equivalent enrollment threshold.", "virtual_table": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] AND totalenrollment_ay  >  [PLACEHOLDER-TYPE:NUMBER] AND FTE_AY  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2367", "db_id": "csu_1", "question": "What campuses are in Los Angeles county?", "rationale": ["The query is identifying the relevant table, which is 'Campuses'.", "Select the column to display, 'Campus'.", "Add a condition to filter the 'county' column for the specified county using a placeholder for string values."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "description": "This virtual table describes the names of campuses from the 'Campuses' table that are located in a specific county. The placeholder in the WHERE clause represents the name of the county.", "virtual_table": "SELECT campus FROM campuses WHERE county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'degrees'.", "It selects the 'Degrees' column from the 'degrees' table.", "A JOIN operation is performed to link 'Campuses' and 'degrees' based on the campus identifier.", "Conditions are added to filter results for a specific campus and year using placeholders for string and numeric values."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "description": "This virtual table describes the types of degrees awarded at a specific campus during a particular year. The placeholders in the WHERE clause represent the campus name and the year of the degrees awarded.", "virtual_table": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  [PLACEHOLDER-TYPE:STRING] AND t2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["The query identifies the relevant tables, which are 'faculty' and 'campuses'.", "It selects the 'faculty' column to display the number of faculty members.", "A JOIN operation is performed to link the 'faculty' table with the 'campuses' table based on the campus identifier.", "Conditions are added to filter the results by the specified year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for a specific campus and year. The placeholders in the WHERE clause represent the year of the faculty data record and the name of the campus.", "virtual_table": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.2378", "db_id": "csu_1", "question": "List the campus that have between 600 and 1000 faculty lines in year 2004.", "rationale": ["The query identifies the relevant tables, 'Campuses' and 'faculty'.", "It selects the 'campus' column from the 'Campuses' table.", "A JOIN operation is performed between 'Campuses' and 'faculty' on the campus identifier.", "Conditions are added to filter the faculty count to be within a specified range using placeholders for numeric values.", "Another condition is added to filter the results based on the specified year using a placeholder for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "description": "This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.", "virtual_table": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2379", "db_id": "csu_1", "question": "What are the campuses that had between 600 and 1000 faculty members in 2004?", "rationale": ["The query identifies the relevant tables, which are 'Campuses' and 'faculty'.", "It selects the 'campus' column from the 'Campuses' table.", "The query joins the 'Campuses' table with the 'faculty' table using the campus identifier.", "Conditions are added to filter the results based on the number of faculty members using placeholders for numeric values.", "Another condition is added to filter the results based on the year using a placeholder for numeric values."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "description": "This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the range of faculty numbers and the specific year.", "virtual_table": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2380", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the most number of degrees in year 2002?", "rationale": ["The query identifies the relevant tables: 'campuses', 'faculty', and 'degrees'.", "It selects the 'faculty' column from the 'faculty' table.", "The query joins the 'campuses' table with the 'faculty' table on the campus identifier to link faculty data to the correct campus.", "It also joins the 'degrees' table to order the results based on the number of degrees awarded for the same year.", "A condition is added to filter the results by a specific year using a placeholder for numeric values.", "Finally, it limits the number of results returned using another placeholder for numeric values."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results to return.", "virtual_table": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["The query identifies the relevant tables: 'campuses', 'faculty', and 'degrees'.", "It selects the 'faculty' column from the 'faculty' table.", "The query joins the 'campuses' table with the 'faculty' table on the campus identifier and also joins with the 'degrees' table to ensure that the faculty data corresponds to the year when degrees were awarded.", "A condition is added to filter the results based on a specific year using a placeholder for numeric values.", "The results are ordered by the 'degrees' column and limited to a specified number of results using a placeholder."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "description": "This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.", "virtual_table": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["The query identifies the relevant tables, 'discipline_enrollments' and 'campuses'.", "It selects the sum of undergraduate enrollments from 'discipline_enrollments'.", "A JOIN operation is performed to link 'discipline_enrollments' with 'campuses' based on the campus identifier.", "Conditions are added to filter the results by a specific year and campus name using placeholders for numeric and string values."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "description": "This virtual table summarizes the total number of undergraduate enrollments from the 'discipline_enrollments' table for a specific campus and year. The placeholders in the WHERE clause represent the year of enrollment and the name of the campus.", "virtual_table": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND t2.campus  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3131", "db_id": "assets_maintenance", "question": "Which engineer has visited the most times? Show the engineer id, first name and last name.", "rationale": ["The query identifies the relevant tables, 'Maintenance_Engineers' and 'Engineer_Visits'.", "It selects the engineer ID, first name, and last name from the 'Maintenance_Engineers' table.", "The JOIN operation connects the 'Maintenance_Engineers' table with the 'Engineer_Visits' table to count the number of visits per engineer.", "The results are grouped by engineer ID to aggregate the visit counts.", "The ORDER BY clause sorts the engineers based on the number of visits in descending order.", "The LIMIT clause restricts the number of results returned, using a placeholder for the maximum number of engineers to display."], "gold_sql": "SELECT T1.engineer_id ,  T1.first_name ,  T1.last_name FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2 GROUP BY T1.engineer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["maintenance_engineers", "engineer_visits"], "description": "This virtual table provides a list of maintenance engineers along with their first and last names from the 'Maintenance_Engineers' table. The results are grouped by engineer ID and ordered by the number of visits they have conducted, allowing users to see which engineers have the most visits. The placeholder in the LIMIT clause represents the maximum number of engineers to display.", "virtual_table": "SELECT T1.engineer_id ,  T1.first_name ,  T1.last_name FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2 GROUP BY T1.engineer_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3139", "db_id": "assets_maintenance", "question": "How many fault status codes are recorded in the fault log parts table?", "rationale": ["The query identifies the relevant table, which is 'Fault_Log_Parts'.", "It selects the 'fault_status' column to display the status of faults related to parts.", "The DISTINCT keyword is used to ensure that only unique fault statuses are returned, eliminating any duplicates."], "gold_sql": "SELECT DISTINCT fault_status FROM Fault_Log_Parts", "source_tables": ["fault_log_parts"], "description": "This virtual table provides a unique list of fault statuses associated with parts from the 'Fault_Log_Parts' table. The query retrieves distinct values from the 'fault_status' column, allowing users to see all the different statuses recorded for faults related to parts.", "virtual_table": "SELECT DISTINCT fault_status FROM Fault_Log_Parts"}
{"sample_id": "train.3143", "db_id": "assets_maintenance", "question": "Which part fault requires the most number of skills to fix? List part id and name.", "rationale": ["The query identifies the relevant tables: 'Parts', 'Part_Faults', and 'Skills_Required_To_Fix'.", "It selects the 'part_id' and 'part_name' from the 'Parts' table.", "The query joins 'Parts' with 'Part_Faults' on 'part_id' to find parts associated with faults.", "It further joins with 'Skills_Required_To_Fix' on 'part_fault_id' to filter parts that require specific skills for fixing.", "The results are grouped by 'part_id' to aggregate the data and ordered by the count of occurrences to prioritize the most common parts.", "The LIMIT clause uses a placeholder to allow users to specify how many results they want."], "gold_sql": "SELECT T1.part_id ,  T1.part_name FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id  =  T2.part_id JOIN Skills_Required_To_Fix AS T3 ON T2.part_fault_id  =  T3.part_fault_id GROUP BY T1.part_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["part_faults", "parts", "skills_required_to_fix"], "description": "This virtual table provides a list of parts along with their identifiers from the 'Parts' table that are associated with faults requiring specific skills. The results are grouped by part identifier and ordered by the frequency of their occurrence in fault records, allowing users to see the most commonly required parts for repairs. The placeholder in the LIMIT clause represents the maximum number of parts to return.", "virtual_table": "SELECT T1.part_id ,  T1.part_name FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id  =  T2.part_id JOIN Skills_Required_To_Fix AS T3 ON T2.part_fault_id  =  T3.part_fault_id GROUP BY T1.part_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["The query identifies the relevant table, which is 'CLASS'.", "It counts the distinct 'PROF_NUM' to determine the number of unique professors.", "A condition is added to filter the results based on the 'CRS_CODE' using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "description": "This virtual table provides the count of distinct professors teaching classes associated with a specific course code from the 'CLASS' table. The placeholder in the WHERE clause represents the course code being queried.", "virtual_table": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3180", "db_id": "college_1", "question": "What are the first names and birthdates of the professors in charge of ACCT-211?", "rationale": ["The query identifies the relevant tables, which are 'employee' and 'CLASS'.", "It selects the columns to display, which are 'EMP_FNAME' and 'EMP_DOB' from the 'employee' table.", "A JOIN operation is performed between 'employee' and 'CLASS' on the condition that 'EMP_NUM' from 'employee' matches 'PROF_NUM' from 'CLASS'.", "A condition is added to filter the results based on the 'CRS_CODE' column from the 'CLASS' table using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "description": "This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.", "virtual_table": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3189", "db_id": "college_1", "question": "How many different locations does the school with code BUS has?", "rationale": ["The query identifies the relevant table, which is 'DEPARTMENT'.", "It selects the count of distinct values in the 'dept_address' column.", "A condition is added to filter the results based on the 'school_code' using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "description": "This virtual table provides the count of distinct department addresses from the 'DEPARTMENT' table for a specific school. The placeholder in the WHERE clause represents the school code being queried.", "virtual_table": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["The query identifies the relevant table, which is 'DEPARTMENT'.", "It selects the count of distinct values in the 'dept_address' column.", "A condition is added to filter the results based on the 'school_code' using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "description": "This virtual table provides the count of distinct department addresses from the 'DEPARTMENT' table for a specific school. The placeholder in the WHERE clause represents the school code being queried.", "virtual_table": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3206", "db_id": "college_1", "question": "How many classes are held in each department?", "rationale": ["The query identifies the relevant tables, which are 'CLASS' and 'COURSE'.", "It selects the count of classes and groups the results by 'dept_code'.", "The JOIN operation connects the 'CLASS' table with the 'COURSE' table based on the 'crs_code' to ensure that the count reflects the correct department associated with each class."], "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"], "description": "This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.", "virtual_table": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code"}
{"sample_id": "train.3209", "db_id": "college_1", "question": "What is the number of professors for different school?", "rationale": ["The query identifies the relevant tables, which are 'Department' and 'Professor'.", "It selects the count of professors and groups the results by the school code from the 'Department' table.", "A JOIN operation is performed between 'Department' and 'Professor' on the department code to associate professors with their respective departments."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "description": "This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.", "virtual_table": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code"}
{"sample_id": "train.3210", "db_id": "college_1", "question": "How many different professors are there for the different schools?", "rationale": ["The query identifies the relevant tables, which are 'Department' and 'Professor'.", "It selects the count of professors and groups the results by the school code from the 'Department' table.", "A JOIN operation is performed between 'Department' and 'Professor' on the department code to associate professors with their respective departments."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "description": "This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT statement represents the count of professors, while the school code is derived from the department associated with each professor.", "virtual_table": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the count of students and groups the results by 'dept_code'.", "The use of count(*) allows for the aggregation of student records based on their department code."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table provides a count of students grouped by their department codes from the 'student' table. The placeholder in the SELECT statement represents the department code for which the count of students is being aggregated.", "virtual_table": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3218", "db_id": "college_1", "question": "How many students are in each department?", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the count of students using count(*) to aggregate the data.", "The GROUP BY clause is used to group the results by 'dept_code', allowing us to see the number of students in each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table provides a count of students grouped by their respective department codes from the 'student' table. The placeholder in the SELECT clause represents the count of students, while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3220", "db_id": "college_1", "question": "How many hours do the students spend studying in each department?", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the sum of 'stu_hrs' to calculate the total credit hours for each department.", "The GROUP BY clause is used to aggregate the results based on 'dept_code', allowing for a summary of credit hours per department."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.", "virtual_table": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3222", "db_id": "college_1", "question": "What is the highest, lowest, and average student GPA for every department?", "rationale": ["The query identifies the relevant table, which is 'student'.", "It selects the maximum, average, and minimum GPA from the 'stu_gpa' column.", "The results are grouped by the 'dept_code' to provide a summary for each department."], "gold_sql": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "description": "This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.", "virtual_table": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code"}
{"sample_id": "train.3234", "db_id": "college_1", "question": "How many courses does the department of Computer Information Systmes offer?", "rationale": ["The query identifies the relevant tables, which are 'DEPARTMENT' and 'COURSE'.", "It uses a JOIN operation to connect the two tables based on the 'dept_code' foreign key relationship.", "The SELECT statement counts the number of courses associated with the specified department.", "A condition is added to filter the results based on the department's name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "department"], "description": "This virtual table provides the count of courses offered by a specific department from the 'DEPARTMENT' and 'COURSE' tables. The placeholder in the WHERE clause represents the name of the department for which the course count is being queried.", "virtual_table": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3238", "db_id": "college_1", "question": "What are the total number of credits offered by each department?", "rationale": ["The query identifies the relevant tables, which are 'COURSE' and 'CLASS'.", "It selects the sum of credit hours from the 'COURSE' table and groups the results by department code.", "The JOIN operation links the 'COURSE' and 'CLASS' tables using the course code, ensuring that only related records are combined."], "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"], "description": "This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables. The placeholder in the SELECT clause represents the total credit hours, while the department code is used for grouping the results.", "virtual_table": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["The query identifies the relevant tables: 'CLASS', 'ENROLL', and 'STUDENT'.", "It selects the 'stu_fname' column from the 'STUDENT' table to display the first names of students.", "The JOIN operations link the 'CLASS' table to the 'ENROLL' table using 'class_code', and the 'ENROLL' table to the 'STUDENT' table using 'stu_num'.", "A condition is added to filter the results based on the 'crs_code' from the 'CLASS' table using a placeholder for string values."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "description": "This virtual table describes the first names of students enrolled in classes associated with a specific course code from the 'CLASS', 'ENROLL', and 'STUDENT' tables. The placeholder in the WHERE clause represents the course code.", "virtual_table": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3253", "db_id": "college_1", "question": "What is the name of the department that has the largest number of students enrolled?", "rationale": ["The query identifies the relevant tables: 'CLASS', 'ENROLL', 'COURSE', and 'DEPARTMENT'.", "It joins these tables based on their foreign key relationships to connect classes with their respective courses and departments.", "The SELECT statement retrieves the 'dept_name' from the 'DEPARTMENT' table.", "The GROUP BY clause groups the results by department code to count the number of classes per department.", "The ORDER BY clause sorts the results in descending order based on the count of classes, allowing the most populated departments to appear first.", "The LIMIT clause restricts the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "description": "This virtual table provides a list of department names from the 'DEPARTMENT' table that are associated with classes in the 'CLASS' table. The query joins multiple tables to aggregate the number of classes per department, allowing users to see which departments have the most classes offered. The placeholder in the LIMIT clause represents the maximum number of department names to return.", "virtual_table": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["The query identifies the relevant tables: 'CLASS', 'ENROLL', 'COURSE', and 'DEPARTMENT'.", "It joins these tables based on their foreign key relationships to gather department names associated with enrolled classes.", "The results are grouped by the department code to aggregate the data and count the number of classes per department.", "The results are ordered in descending order based on the count of classes, and a limit is applied to restrict the number of departments returned using a placeholder for numeric values."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "description": "This virtual table provides a list of department names from the 'DEPARTMENT' table that are associated with classes in which students are enrolled. The query joins multiple tables: 'CLASS', 'ENROLL', 'COURSE', and 'DEPARTMENT' to gather the relevant information. The results are grouped by department code and ordered by the number of classes in descending order, with a limit on the number of departments returned based on a specified placeholder for numeric values.", "virtual_table": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["The query identifies the relevant table, which is 'CLASS'.", "Select the column to display, 'class_code'.", "Add a condition to filter the 'class_room' column for the specified room using a placeholder for string values."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "description": "This virtual table describes the unique class codes from the 'CLASS' table that are held in a specific classroom. The placeholder in the WHERE clause represents the room where the class is conducted.", "virtual_table": "SELECT class_code FROM CLASS WHERE class_room  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["The query identifies the relevant tables, which are 'student' and 'enroll'.", "It selects the distinct first names of students from the 'student' table.", "The JOIN operation is used to connect the 'student' table with the 'enroll' table based on the student number.", "A condition is added to filter the results based on the grade received by the students using a placeholder for string values."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "description": "This virtual table provides a list of distinct first names of students who have received a specific grade in their enrolled classes. The placeholder in the WHERE clause represents the grade that the user wants to filter by.", "virtual_table": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["The query identifies the relevant table, which is 'employee'.", "Select the column to display, 'emp_fname'.", "Add a condition to filter the 'emp_jobcode' column for the specified job code using a placeholder for string values.", "Use the EXCEPT clause to exclude first names of employees who are professors by joining the 'employee' table with the 'CLASS' table on the professor's identifier."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "description": "This virtual table describes the first names of employees from the 'employee' table who hold a specific job code, excluding those who are professors teaching any class. The placeholder in the WHERE clause represents the job code of the employees.", "virtual_table": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["The query identifies the relevant table, which is 'employee'.", "Select the column to display, 'emp_fname'.", "Add a condition to filter the 'emp_jobcode' column for the specified job code using a placeholder for string values.", "Use the EXCEPT clause to exclude first names of employees who are professors by joining the 'employee' table with the 'CLASS' table on the professor's identifier."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "description": "This virtual table describes the first names of employees from the 'employee' table who hold a specific job code, excluding those who are professors teaching any class. The placeholder in the WHERE clause represents the job code of the employees.", "virtual_table": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["The query identifies the relevant table, which is 'professor'.", "It uses the COUNT function to count the number of records that meet the specified criteria.", "The WHERE clause filters the results based on the 'prof_high_degree' column, allowing for two different degree values using placeholders for string values."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "description": "This virtual table counts the number of professors from the 'professor' table who have a specific highest degree. The placeholders in the WHERE clause represent the degrees being queried.", "virtual_table": "SELECT count(*) FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] OR prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["The query identifies the relevant tables: 'student', 'enroll', 'class', 'course', and 'department'.", "It selects the 'stu_fname' column from the 'student' table.", "The JOIN operations link the tables based on their foreign key relationships to ensure the correct associations between students, their enrollments, classes, courses, and departments.", "The WHERE clause filters the results based on the department's name using a placeholder for string values.", "The INTERSECT operation is used to find students who are enrolled in classes from two instances of the same department, ensuring that only those students who meet both conditions are returned."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "description": "This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that only those students who meet both conditions are returned. The placeholder in the WHERE clause represents the department's name.", "virtual_table": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3300", "db_id": "college_1", "question": "What is the name of the department with the student that has the lowest GPA?", "rationale": ["The query identifies the relevant tables, which are 'student' and 'department'.", "It selects the 'dept_name' column from the 'department' table.", "A JOIN operation is performed on the 'dept_code' to link students with their respective departments.", "The results are ordered by the students' GPA to prioritize higher-performing students.", "The LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "description": "This virtual table provides a list of department names from the 'department' table for students, ordered by their GPA. The placeholder in the LIMIT clause allows the user to specify the maximum number of department names to retrieve.", "virtual_table": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3314", "db_id": "college_1", "question": "What are the first names, office locations of all lecturers who have taught some course?", "rationale": ["The query identifies the relevant tables: 'CLASS', 'EMPLOYEE', 'COURSE', and 'PROFESSOR'.", "It selects the 'emp_fname' from the 'EMPLOYEE' table, 'prof_office' from the 'PROFESSOR' table, and 'crs_description' from the 'COURSE' table.", "The joins are established based on the foreign key relationships: 'CLASS.prof_num' with 'EMPLOYEE.emp_num', 'CLASS.crs_code' with 'COURSE.crs_code', and 'PROFESSOR.emp_num' with 'EMPLOYEE.emp_num'."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num", "source_tables": ["course", "employee", "professor", "class"], "description": "This virtual table provides a view of the first names of professors, their office locations, and descriptions of the courses they teach. It combines data from the 'CLASS', 'EMPLOYEE', 'COURSE', and 'PROFESSOR' tables, linking them through their respective identifiers.", "virtual_table": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num"}
{"sample_id": "train.3315", "db_id": "college_1", "question": "Find the first names and offices of all instructors who have taught some course and the course description and the department name.", "rationale": ["The query identifies the relevant tables: CLASS, EMPLOYEE, COURSE, PROFESSOR, and DEPARTMENT.", "It selects the first name of the professor from the EMPLOYEE table, the office location from the PROFESSOR table, the course description from the COURSE table, and the department name from the DEPARTMENT table.", "The JOIN operations link these tables based on their foreign key relationships, ensuring that the data retrieved is related to the same class and professor."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code", "source_tables": ["course", "department", "professor", "class", "employee"], "description": "This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The placeholders in the query represent the relationships between the tables involved, allowing for dynamic querying based on specific criteria.", "virtual_table": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["The query identifies the relevant tables, which are 'course' and 'department'.", "It selects the 'dept_name' column from the 'department' table.", "A JOIN operation is performed on the 'dept_code' to link the 'course' and 'department' tables.", "A condition is added to filter the courses based on their description using a placeholder for string values."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "description": "This virtual table describes the names of departments that offer courses matching a specific description. The placeholder in the WHERE clause represents the course description to filter the results.", "virtual_table": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3417", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Adds a condition to filter out employees whose first names do not match a specified pattern using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "description": "This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern to filter out certain first names.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Adds a condition to filter out employees whose first names do not match a specified pattern using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "description": "This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause represents the pattern to filter out certain first names.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'hire_date', 'salary', and 'department_id'.", "Adds a condition to filter out employees whose first names match a specified pattern using a placeholder for string values.", "Orders the results by 'department_id' to group employees by their respective departments."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "description": "This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY department_id"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["The query identifies the relevant table, which is 'jobs'.", "Select the column to display, 'job_title'.", "Add a condition to filter the 'min_salary' column for values greater than the specified amount using a placeholder for numeric values."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "description": "This virtual table lists the job titles from the 'jobs' table where the minimum salary exceeds a specified amount. The placeholder in the WHERE clause represents the minimum salary threshold.", "virtual_table": "SELECT job_title FROM jobs WHERE min_salary  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["The query identifies the relevant table, which is 'jobs'.", "Select the columns to display, 'job_title' and the calculated difference between 'max_salary' and 'min_salary'.", "Add a condition to filter the 'max_salary' column to be within a specified range using placeholders for numeric values."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "description": "This virtual table provides the job titles along with the salary range (calculated as the difference between maximum and minimum salary) for jobs in the 'jobs' table that fall within a specified maximum salary range. The placeholders in the WHERE clause represent the lower and upper limits of the salary range.", "virtual_table": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["The query identifies the relevant table, which is 'job_history'.", "Select the column 'employee_id' to group the results by each employee.", "Use the MAX function to find the latest 'end_date' for each employee's job history.", "Group the results by 'employee_id' to ensure that we get the most recent end date for each employee."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "description": "This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the unique identifier for each employee, while the MAX function is used to retrieve the latest end date for their job history.", "virtual_table": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id"}
{"sample_id": "train.3451", "db_id": "hr_1", "question": "Find the ids of the departments where any manager is managing 4 or more employees.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects distinct 'department_id' to ensure unique entries.", "The results are grouped by 'department_id' and 'manager_id' to aggregate the data accordingly.", "A HAVING clause is used to filter groups based on the count of 'employee_id', ensuring only departments with a specified minimum number of employees are included, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "description": "This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.", "virtual_table": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3457", "db_id": "hr_1", "question": "display job ID for those jobs that were done by two or more for more than 300 days.", "rationale": ["The query identifies the relevant table, which is 'job_history'.", "It selects the 'job_id' column to display the job identifiers.", "A condition is added to filter the records where the difference between 'end_date' and 'start_date' exceeds a specified number of days using a placeholder for numeric values.", "The results are grouped by 'job_id' to aggregate the data for each job.", "A HAVING clause is included to filter the grouped results to only include jobs that have been held a minimum number of times, using another placeholder for numeric values."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "description": "This virtual table provides a list of job identifiers from the 'job_history' table where the duration of each job (calculated as the difference between the end date and start date) exceeds a specified number of days. Additionally, it groups the results by job identifier and filters to include only those jobs that have been held for a minimum number of times, as indicated by the placeholder in the HAVING clause.", "virtual_table": "SELECT job_id FROM job_history WHERE end_date - start_date  > [PLACEHOLDER-TYPE:NUMBER] GROUP BY job_id HAVING COUNT(*) >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3458", "db_id": "hr_1", "question": "What are the job ids for jobs done more than once for a period of more than 300 days?", "rationale": ["The query identifies the relevant table, which is 'job_history'.", "It selects the 'job_id' column to display the job identifiers.", "A condition is added to filter records where the difference between 'end_date' and 'start_date' exceeds a specified number of days, using a placeholder for numeric values.", "The results are grouped by 'job_id' to aggregate the data.", "A HAVING clause is included to filter groups that have a count of occurrences greater than or equal to a specified number, using another placeholder for numeric values."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "description": "This virtual table provides a list of job identifiers from the 'job_history' table where the duration of the job (calculated as the difference between the end date and start date) exceeds a specified number of days. Additionally, it groups the results by job identifier and filters to include only those jobs that have been held for a minimum number of occurrences, as indicated by the placeholders.", "virtual_table": "SELECT job_id FROM job_history WHERE end_date - start_date  > [PLACEHOLDER-TYPE:NUMBER] GROUP BY job_id HAVING COUNT(*) >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3463", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It uses a JOIN operation to link the two tables based on the 'department_id'.", "The SELECT statement retrieves the 'department_name' from the 'departments' table and counts the number of employees in each department using COUNT(*).", "The GROUP BY clause is used to group the results by 'department_name' to get the count for each department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "description": "This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.", "virtual_table": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name"}
{"sample_id": "train.3470", "db_id": "hr_1", "question": "Provide the full names of employees earning more than the employee with id 163.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display, 'first_name' and 'last_name'.", "Add a condition to filter employees based on their salary being greater than the salary of a specific employee.", "The subquery retrieves the salary of the employee specified by the placeholder for numeric values."], "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = 163 )", "source_tables": ["employees"], "description": "This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.", "virtual_table": "SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.3471", "db_id": "hr_1", "question": "return the smallest salary for every departments.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the minimum salary using the MIN function and includes the department_id to group the results.", "The GROUP BY clause is used to aggregate the minimum salary for each department, allowing for a summary of salaries by department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the minimum salary, while the GROUP BY clause groups the results by department identifier.", "virtual_table": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id"}
{"sample_id": "train.3472", "db_id": "hr_1", "question": "What is the minimum salary in each department?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the minimum salary and groups the results by department_id to show the lowest salary in each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the department_id is used to group the results by each department.", "virtual_table": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It performs a JOIN operation on the 'department_id' to link employees to their departments.", "The WHERE clause filters the results to include only those employees whose 'employee_id' matches the 'manager_id' in the departments table."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "description": "This virtual table provides a list of employees who are also managers in their respective departments. It combines data from the 'employees' and 'departments' tables, ensuring that only those employees whose 'employee_id' matches the 'manager_id' of their department are included. The use of DISTINCT ensures that each employee-manager pair is unique.", "virtual_table": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects distinct 'department_id' to ensure unique entries.", "The results are grouped by 'department_id' and 'manager_id' to aggregate data based on these identifiers.", "A HAVING clause is used to filter groups that have a count of 'employee_id' greater than or equal to a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "description": "This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.", "virtual_table": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3497", "db_id": "hr_1", "question": "Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects all columns from the 'employees' table.", "A condition is added to filter out department IDs that are linked to manager IDs within a specified numeric range using placeholders."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "description": "This virtual table retrieves all employee records from the 'employees' table where the department ID does not fall within a specified range of manager IDs. The placeholders in the query represent numeric values for the range of manager IDs to filter out departments managed by those IDs.", "virtual_table": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'first_name', 'last_name', and 'hire_date'.", "Add a condition to filter the 'department_id' by using a subquery that finds the department of a specified employee's first name.", "Ensure that the selected employees do not include the specified employee by adding a condition to exclude that first name."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "description": "This virtual table provides the first names, last names, and hire dates of employees from the 'employees' table who belong to the same department as a specified employee, while excluding the specified employee's name. The placeholders in the WHERE clause represent the first name of the employee to find the department and the first name of the employee to exclude.", "virtual_table": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  [PLACEHOLDER-TYPE:STRING]) AND first_name != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3506", "db_id": "hr_1", "question": "What are the ids, full names, and salaries for employees making more than average and who work in a department with employees who have the letter J in their first name?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the columns to display: 'employee_id', 'first_name', 'last_name', and 'salary'.", "A condition is added to filter employees whose salary is greater than the average salary calculated from the same table.", "Another condition is included to filter employees based on their department, specifically those departments that have employees with a first name matching a specified pattern using a placeholder for string values."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%')", "source_tables": ["employees"], "description": "This virtual table provides a list of employees, including their unique identifiers, first names, last names, and salaries, from the 'employees' table. It filters the results to show only those employees whose salaries are above the average salary of all employees and belong to departments where at least one employee has a first name matching a specified pattern.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display, 'employee_id' and 'job_id'.", "Add a condition to filter employees whose salary is less than a certain value.", "The subquery retrieves the minimum salary for a specified job using a placeholder for the job identifier."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "description": "This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.", "virtual_table": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3510", "db_id": "hr_1", "question": "What are the employee ids, full names, and job ids for employees who make more than the highest earning employee with title PU_MAN?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Select the columns to display: 'employee_id', 'first_name', 'last_name', and 'job_id'.", "Add a condition to filter employees based on their salary being greater than a maximum salary from a subquery.", "The subquery selects the maximum salary from the 'employees' table where the job identifier matches the specified job, using a placeholder for string values."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "description": "This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.", "virtual_table": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "It selects the 'department_id' and calculates the total salary using SUM(salary).", "The results are grouped by 'department_id' to aggregate the salaries for each department.", "A condition is added in the HAVING clause to filter departments based on the number of employees, using a placeholder for numeric values."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "description": "This virtual table summarizes the total salary of employees grouped by their department. It includes only those departments that have a minimum number of employees, as specified by the placeholder in the HAVING clause.", "virtual_table": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'salary', and 'department_id'.", "Uses the MAX function to find the highest salary within each department.", "Groups the results by 'department_id' to aggregate the data accordingly."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.", "virtual_table": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id"}
{"sample_id": "train.3516", "db_id": "hr_1", "question": "What are the department ids, full names, and salaries for employees who make the most in their departments?", "rationale": ["The query identifies the relevant table, which is 'employees'.", "Selects the columns to display: 'first_name', 'last_name', 'salary', and 'department_id'.", "Uses the MAX function to find the highest salary within each department.", "Groups the results by 'department_id' to aggregate the data accordingly."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "description": "This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.", "virtual_table": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', and 'locations'.", "It selects the 'first_name' and 'last_name' from the 'employees' table and the 'city' from the 'locations' table.", "A JOIN operation is performed between 'employees' and 'departments' on the 'department_id' to link employees to their respective departments.", "Another JOIN is performed between 'departments' and 'locations' on 'location_id' to get the city of the department's location.", "A condition is added to filter the results based on the first name of the employees using a placeholder for string values."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "description": "This virtual table provides the first and last names of employees along with the city of their department's location. The data is sourced from the 'employees', 'departments', and 'locations' tables, with a filter applied to the first name of the employees using a placeholder for string values.", "virtual_table": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', 'locations', and 'countries'.", "It selects the 'first_name', 'last_name', and 'employee_id' from the 'employees' table (aliased as T1).", "It joins the 'departments' table (T2) on the 'department_id' to associate employees with their departments.", "It further joins the 'locations' table (T3) on 'location_id' to link departments to their locations.", "Finally, it joins the 'countries' table (T4) on 'country_id' to retrieve the country names associated with the locations."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "description": "This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.", "virtual_table": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It selects the 'department_name' from the 'departments' table and counts the number of employees from the 'employees' table.", "A JOIN operation is performed on the 'department_id' to link employees to their respective departments.", "The results are grouped by 'department_name' to provide a count of employees per department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "description": "This virtual table provides a summary of the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement allows for the retrieval of the department name along with the count of employees in that department.", "virtual_table": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["The query identifies the relevant tables, which are 'employees' and 'departments'.", "It selects the 'department_name' from the 'departments' table and counts the number of employees in each department.", "The JOIN operation links the 'employees' table to the 'departments' table using the 'department_id' to ensure accurate grouping.", "The GROUP BY clause is used to aggregate the results by 'department_name', allowing for a count of employees in each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "description": "This virtual table provides a count of employees grouped by their respective department names from the 'employees' and 'departments' tables. The placeholder in the COUNT function allows for dynamic counting of employees in each department.", "virtual_table": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["The query identifies the relevant tables: 'employees', 'departments', and 'locations'.", "It selects the columns to display: 'first_name', 'last_name', and 'salary'.", "The JOIN operations link the 'employees' table to the 'departments' table using 'department_id', and then to the 'locations' table using 'location_id'.", "A condition is added to filter the results based on the 'city' column from the 'locations' table, using a placeholder for string values."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "description": "This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.", "virtual_table": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3641", "db_id": "baseball_1", "question": "In 2014, what are the id and rank of the team that has the largest average number of attendance?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the 'team_id' and 'rank' columns from the 'team' table.", "A JOIN operation is performed between 'home_game' and 'team' on the 'team_id' column to combine relevant data.", "A WHERE clause filters the results for a specific year using a placeholder for numeric values.", "The results are grouped by 'team_id' to aggregate attendance data.", "The ORDER BY clause sorts the results based on the average attendance in descending order.", "A LIMIT clause restricts the number of results returned based on a specified maximum."], "gold_sql": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  2014 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "source_tables": ["team", "home_game"], "description": "This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.", "virtual_table": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3647", "db_id": "baseball_1", "question": "Which 3 players won the most player awards? List their full name and id.", "rationale": ["The query identifies the relevant tables, 'player' and 'player_award'.", "It selects the first name, last name, and player ID from the 'player' table.", "A JOIN operation is performed between 'player' and 'player_award' to link players with their awards based on the player ID.", "The results are grouped by player ID to avoid duplicates and to count the number of awards per player.", "The results are ordered by the count of awards in descending order to show the most awarded players first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for the user to specify the desired number."], "gold_sql": "SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT 3;", "source_tables": ["player_award", "player"], "description": "This virtual table provides a list of players along with their first and last names from the 'player' table, who have received awards. The results are grouped by player ID to ensure uniqueness and are ordered by the number of awards received in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of players to return.", "virtual_table": "SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3649", "db_id": "baseball_1", "question": "List three countries which are the origins of the least players.", "rationale": ["The query identifies the relevant table, which is 'player'.", "It selects the 'birth_country' column to display the countries of birth.", "The GROUP BY clause is used to group the results by 'birth_country'.", "The ORDER BY clause sorts the results by the count of players from each country in ascending order.", "The LIMIT clause uses a placeholder to specify the maximum number of countries to return."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "description": "This virtual table provides a list of countries where players were born, grouped by country and ordered by the number of players from each country in ascending order. The placeholder in the LIMIT clause allows for specifying the maximum number of countries to return.", "virtual_table": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["The query identifies the relevant table, which is 'player'.", "It selects the 'birth_country' column to display the countries of birth.", "The GROUP BY clause is used to group the results by 'birth_country'.", "The ORDER BY clause sorts the results by the count of players from each country in ascending order.", "The LIMIT clause restricts the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "description": "This virtual table provides a list of countries where players were born, grouped by country and ordered by the number of players from each country in ascending order. The placeholder in the LIMIT clause allows for specifying the maximum number of countries to return.", "virtual_table": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3651", "db_id": "baseball_1", "question": "Find all the players' first name and last name who have empty death record.", "rationale": ["The query identifies the relevant table, which is 'player'.", "Select the columns to display, 'name_first' and 'name_last'.", "Add a condition to filter the 'death_year' column for the specified year using a placeholder for string values."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE death_year = '';", "source_tables": ["player"], "description": "This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.", "virtual_table": "SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["The query identifies the relevant tables, which are 'team' and 'salary'.", "It selects the 'name' and 'team_id' from the 'team' table and the maximum salary from the 'salary' table.", "A JOIN operation is performed on the 'team_id' to link the two tables based on the team identifier.", "The results are grouped by 'team_id' to ensure that each team appears only once with its maximum salary."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "description": "This virtual table provides the names and identifiers of teams along with their highest recorded salary from the 'salary' table. The data is grouped by team identifiers to ensure that each team is represented only once with its maximum salary.", "virtual_table": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;"}
{"sample_id": "train.3662", "db_id": "baseball_1", "question": "Which players won awards in both 1960 and 1961? Return their first names and last names.", "rationale": ["The query selects the first and last names of players from the 'player' table.", "It joins the 'player' table with the 'player_award' table to filter players based on the year they received awards.", "The INTERSECT operator is used to find players who received awards in both specified years, indicated by placeholders for numeric values."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "description": "This virtual table identifies players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given, allowing users to specify any two years of interest.", "virtual_table": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the maximum wins from the 'postseason' table.", "A JOIN is performed between 'postseason' and 'team' on the winning team identifier to link the team name.", "A condition is added to filter the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "description": "This virtual table calculates the maximum number of wins achieved by any team in the postseason from the 'postseason' table, specifically for the team identified by its name in the 'team' table. The placeholder in the WHERE clause represents the name of the team being queried.", "virtual_table": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the maximum wins from the 'postseason' table.", "A JOIN is performed between 'postseason' and 'team' on the winning team identifier to link the team name.", "A condition is added to filter the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "description": "This virtual table calculates the maximum number of wins achieved by any team in the postseason from the 'postseason' table, specifically for the team identified by its name in the 'team' table. The placeholder in the WHERE clause represents the name of the team being queried.", "virtual_table": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3669", "db_id": "baseball_1", "question": "What are the name and id of the team with the most victories in 2008 postseason?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It selects the team name from the 'team' table and the winning team ID from the 'postseason' table.", "A JOIN operation is performed to link the winning team ID with the corresponding team name using the team ID.", "A condition is added to filter the results for a specific year using a placeholder for numeric values.", "The results are grouped by the winning team ID to aggregate the data and ordered by the count of wins in descending order.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"], "description": "This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.", "virtual_table": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3673", "db_id": "baseball_1", "question": "What is the total number of postseason games that team Boston Red Stockings participated in?", "rationale": ["The query identifies the relevant tables, 'postseason' and 'team'.", "It uses a UNION to combine results from two SELECT statements: one for winning teams and one for losing teams.", "Each SELECT statement joins the 'postseason' table with the 'team' table based on the winning and losing team identifiers.", "The WHERE clause filters the results based on the specified team name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"], "description": "This virtual table counts the total number of postseason appearances for a specific team, including both wins and losses. It combines data from the 'postseason' table and the 'team' table, filtering by the team's name provided as a placeholder.", "virtual_table": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] );"}
{"sample_id": "train.3678", "db_id": "baseball_1", "question": "What is the total salary expenses of team Boston Red Stockings in 2010?", "rationale": ["The query identifies the relevant tables, 'salary' and 'team'.", "It selects the sum of salaries from the 'salary' table.", "A join is performed between 'salary' and 'team' on the team identifier to link salary records to the corresponding team.", "Conditions are added to filter results based on the specified team name and year using placeholders for string and numeric values."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "description": "This virtual table calculates the total salary of players from a specific team for a given year. The placeholders represent the team's name and the year for which the salary data is being queried.", "virtual_table": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3679", "db_id": "baseball_1", "question": "How many players were in the team Boston Red Stockings in 2000?", "rationale": ["The query identifies the relevant tables, 'salary' and 'team'.", "It joins the 'salary' table with the 'team' table on the 'team_id_br' to ensure the correct team is referenced.", "The SELECT statement counts the number of salary records for the specified team name and year, using placeholders for these values."], "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"], "description": "This virtual table provides the total count of salary records for a specific team in a given year. The placeholders represent the team's name and the year for which the salary records are being queried.", "virtual_table": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = [PLACEHOLDER-TYPE:STRING] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["The query identifies the relevant table, which is 'salary'.", "It selects the 'salary' column to display the salary amounts.", "A condition is added to filter the records for a specific year using a placeholder for numeric values.", "The results are ordered by salary in descending order to show the highest salaries first.", "A limit is applied to restrict the number of records returned, using a placeholder for numeric values."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "description": "This virtual table provides the salary records from the 'salary' table for a specific year, sorted in descending order. The placeholders represent the year for which the salary data is requested and the limit on the number of records to return.", "virtual_table": "SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY salary DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3684", "db_id": "baseball_1", "question": "List all the salary values players received in 2010 and 2001.", "rationale": ["The query identifies the relevant table, which is 'salary'.", "It selects the 'salary' column to display the salary amounts.", "The UNION operator is used to combine results from two different years, with placeholders for the specific years in the WHERE clause."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "description": "This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.", "virtual_table": "SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["The query identifies the relevant table, which is 'hall_of_fame'.", "It selects the 'yearid' column to display the years of induction.", "The results are grouped by 'yearid' to aggregate the data by year.", "The results are ordered by the count of inductees in ascending order to show the years with fewer inductees first.", "The LIMIT clause uses a placeholder to allow the user to specify how many years to return."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "description": "This virtual table provides a list of years in which players were inducted into the Hall of Fame, grouped by year and ordered by the number of inductees in ascending order. The placeholder in the LIMIT clause allows for specifying the maximum number of years to retrieve.", "virtual_table": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["The query identifies the relevant table, which is 'hall_of_fame'.", "It selects the 'yearid' column to display the years of induction.", "The results are grouped by 'yearid' to aggregate the data for each year.", "The results are ordered by the count of inductees in ascending order to show the years with fewer inductees first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "description": "This virtual table provides a list of years in which players were inducted into the Hall of Fame, grouped by year. The results are ordered by the number of inductees in ascending order, with a limit set by a placeholder for numeric values.", "virtual_table": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It uses a JOIN operation to connect these tables based on the park identifier.", "The SELECT statement counts the total number of home games.", "The WHERE clause filters the results by the specified year and park name using placeholders for numeric and string values."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "description": "This virtual table provides the total count of home games played in a specific year at a designated park. The placeholders represent the year of the games and the name of the park.", "virtual_table": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T2.park_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It uses a JOIN operation to connect these tables based on the park identifier.", "The SELECT statement counts the total number of home games.", "The WHERE clause filters the results by the specified year and park name using placeholders for numeric and string values."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "description": "This virtual table provides the total count of home games played in a specific year at a designated park. The placeholders represent the year of the games and the name of the park.", "virtual_table": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T2.park_name = [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It selects the count of home games by joining these two tables on the park identifier.", "A condition is added to filter the results based on the specified year and city using placeholders for numeric and string values."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "description": "This virtual table provides the total count of home games played in a specific year at parks located in a specified city. The placeholders represent the year of the home games and the city where the park is situated.", "virtual_table": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.city  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It selects the count of home games by using the count(*) function.", "A JOIN operation is performed between 'home_game' and 'park' on the park_id to link the games to their respective parks.", "A WHERE clause is added to filter the results based on the specified year and city, using placeholders for the year (numeric) and city (string)."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "description": "This virtual table provides the total count of home games played in a specific year at parks located in a specified city. The placeholders represent the year of the home games and the city where the park is situated.", "virtual_table": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] AND T2.city  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "train.3697", "db_id": "baseball_1", "question": "List players' first name and last name who received salary from team Washington Nationals in both 2005 and 2007.", "rationale": ["The query identifies the relevant tables: 'salary', 'player', and 'team'.", "It selects the 'name_first' and 'name_last' columns from the 'player' table.", "The 'salary' table is joined with the 'player' table using the 'player_id' to link salary records to players.", "The 'team' table is joined to associate players with their respective teams using the 'team_id_br'.", "The WHERE clause filters results based on the specified year and team name using placeholders for user input.", "The INTERSECT operator is used to ensure that the results from both queries are the same, which is redundant in this case but indicates a specific requirement for the same year and team."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "description": "This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.", "virtual_table": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.3699", "db_id": "baseball_1", "question": "How many home games did the team Boston Red Stockings play from 1990 to 2000 in total?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the sum of the 'games' column from the 'home_game' table.", "A join is performed between 'home_game' and 'team' on the 'team_id' to link the games to the specific team.", "A condition is added to filter by the team's name using a placeholder for string values.", "Another condition is added to filter the years using placeholders for numeric values."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "description": "This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.", "virtual_table": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["The query identifies the relevant tables, 'home_game' and 'team'.", "It selects the 'name' column from the 'team' table, which contains the names of the teams.", "A JOIN operation is performed between 'home_game' and 'team' on the 'team_id' to link home games with their respective teams.", "A condition is added to filter the results based on the specified year using a placeholder for numeric values.", "The results are ordered by the 'attendance' column in ascending order and limited to a specified number of results using placeholders."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "description": "This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.", "virtual_table": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3710", "db_id": "baseball_1", "question": "Which park did the most people attend in 2008?", "rationale": ["The query identifies the relevant tables, 'home_game' and 'park'.", "It selects the 'park_name' from the 'park' table.", "A join is performed between 'home_game' and 'park' on the 'park_id' to link home games to their respective parks.", "A condition is added to filter the results for a specific year using a placeholder for numeric values.", "The results are ordered by attendance in descending order and limited to a specified number using placeholders."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "description": "This virtual table provides a list of park names where home games were played in a specific year, ordered by the total attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.", "virtual_table": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["The query identifies the relevant table, which is 'Department'.", "It selects the 'name' column to display the names of the departments.", "The results are grouped by 'departmentID' to aggregate the data based on unique department identifiers.", "The results are ordered by the count of 'departmentID' in descending order to show the most common departments first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "description": "The virtual table provides a list of department names from the 'Department' table, grouped by their unique identifiers. It orders the results by the count of each department's occurrences in descending order and limits the output to a specified number of results. The placeholder in the LIMIT clause represents the maximum number of department names to retrieve.", "virtual_table": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["The query identifies the relevant table, which is 'Department'.", "It selects the 'name' column to display the names of the departments.", "The GROUP BY clause is used to group the results by 'departmentID', ensuring that each department name appears only once in the results.", "The ORDER BY clause sorts the results based on the count of 'departmentID' in descending order, highlighting the most referenced departments.", "The LIMIT clause restricts the number of results returned, with a placeholder for the user to specify how many department names they want to see."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "description": "This virtual table provides a list of department names from the 'Department' table, grouped by their unique identifiers. The results are ordered by the count of occurrences of each department ID in descending order, allowing users to see the most frequently referenced departments. The placeholder in the LIMIT clause represents the maximum number of department names to return.", "virtual_table": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["The query identifies the relevant tables, which are 'Department' and 'Physician'.", "It selects the 'name' and 'position' columns from the 'Physician' table (aliased as T2).", "A JOIN operation is performed between 'Department' (aliased as T1) and 'Physician' (T2) on the condition that the head of the department matches the physician's EmployeeID.", "The results are grouped by 'departmentID' to aggregate the data appropriately.", "The results are ordered by the count of 'departmentID' to prioritize departments with more heads, and a limit is applied to control the number of results returned."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "description": "This virtual table provides the names and positions of physicians who are heads of departments. It aggregates the data from the 'Department' and 'Physician' tables, grouping by department ID and ordering the results based on the count of departments, with a limit on the number of results returned as specified by the placeholder.", "virtual_table": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["The query identifies the relevant tables, which are 'Appointment' and 'Patient'.", "It selects the 'name' column from the 'Patient' table.", "A join is performed between the 'Appointment' table and the 'Patient' table using the patient identifier and Social Security Number to associate appointments with patients."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "description": "This virtual table provides the names of patients associated with their appointments from the 'Appointment' and 'Patient' tables. The join condition links the patient identifier in the 'Appointment' table to the Social Security Number in the 'Patient' table.", "virtual_table": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn"}
{"sample_id": "train.3905", "db_id": "hospital_1", "question": "List the names of patients who have made appointments.", "rationale": ["The query identifies the relevant tables, which are 'Appointment' and 'Patient'.", "It selects the 'name' column from the 'Patient' table.", "A join is performed between the 'Appointment' table and the 'Patient' table using the patient identifier to match records, ensuring that only patients with appointments are included."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "description": "This virtual table provides the names of patients associated with their appointments from the 'Appointment' and 'Patient' tables. The join condition links the patient identifier in the 'Appointment' table to the Social Security Number in the 'Patient' table, allowing for the retrieval of patient names based on their scheduled appointments.", "virtual_table": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["The query identifies the relevant tables: 'Physician', 'Affiliated_With', and 'Department'.", "It selects the 'Name' column from the 'Physician' table and the 'Name' column from the 'Department' table.", "A JOIN operation is performed between 'Physician' and 'Affiliated_With' on the 'EmployeeID' and 'Physician' columns respectively.", "Another JOIN operation is performed between 'Affiliated_With' and 'Department' on the 'Department' and 'DepartmentID' columns respectively.", "A condition is added to filter the results based on the 'PrimaryAffiliation' column using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "description": "This virtual table describes the names of physicians along with the names of the departments they are affiliated with, specifically filtering for those whose affiliation is marked as primary. The placeholders in the WHERE clause represent the primary affiliation status.", "virtual_table": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3915", "db_id": "hospital_1", "question": "What are the name and primarily affiliated department name of each physician?", "rationale": ["The query identifies the relevant tables: 'Physician', 'Affiliated_With', and 'Department'.", "It selects the 'Name' column from the 'Physician' table and the 'Name' column from the 'Department' table.", "The JOIN operation connects 'Physician' and 'Affiliated_With' on the 'EmployeeID' and 'Physician' columns, respectively.", "Another JOIN connects 'Affiliated_With' and 'Department' on the 'Department' and 'DepartmentID' columns, respectively.", "A condition is added to filter the results based on the 'PrimaryAffiliation' column using a placeholder for numeric values."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "description": "This virtual table describes the names of physicians along with the names of the departments they are affiliated with, specifically filtering for those whose affiliation is marked as primary. The placeholders in the WHERE clause represent the primary affiliation status.", "virtual_table": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3929", "db_id": "hospital_1", "question": "Return the name of each physician and the number of patients he or she treats.", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Patient'.", "It selects the 'Name' column from the 'Physician' table and counts the number of patients associated with each physician.", "A join is performed between the 'Physician' table and the 'Patient' table using the physician's employee ID and the patient's PCP identifier.", "The results are grouped by the physician's employee ID to provide a count of patients for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "description": "This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.", "virtual_table": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Patient'.", "It selects the 'Name' column from the 'Physician' table.", "A JOIN operation is performed between 'Physician' and 'Patient' on the condition that the physician's EmployeeID matches the patient's PCP identifier.", "The results are grouped by the physician's EmployeeID to aggregate the patient counts.", "The HAVING clause filters the results to include only those physicians who have more than a specified number of patients, using a placeholder for the numeric value."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "description": "This virtual table lists the names of physicians who are primary care physicians (PCP) for patients, specifically those who have more than a specified number of patients. The placeholder in the HAVING clause represents the minimum count of patients a physician must have to be included in the results.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3931", "db_id": "hospital_1", "question": "Which physicians are in charge of more than one patient? Give me their names.", "rationale": ["The query identifies the relevant tables, 'Physician' and 'Patient'.", "It selects the 'Name' column from the 'Physician' table.", "A JOIN operation is performed between 'Physician' and 'Patient' on the condition that the physician's EmployeeID matches the patient's PCP identifier.", "The results are grouped by the physician's EmployeeID to aggregate the patient counts.", "The HAVING clause filters the results to include only those physicians who have more patients than the specified number, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "description": "This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3934", "db_id": "hospital_1", "question": "Find the number of rooms for different block code?", "rationale": ["The query identifies the relevant tables, which are 'Block' and 'Room'.", "It selects a count of rooms and the block code from the 'Block' table.", "A JOIN operation is performed on the 'Block' and 'Room' tables based on matching block floor and block code values.", "The results are grouped by the block code to provide a summary count for each unique block code."], "gold_sql": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode", "source_tables": ["block", "room"], "description": "This virtual table provides a count of rooms grouped by their block code status from the 'Block' and 'Room' tables. The placeholders represent the block floor and block code statuses used for filtering the results.", "virtual_table": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["The query identifies the relevant tables, which are 'medication' and 'prescribes'.", "It selects a count of prescriptions and the name of the medication from the 'medication' table.", "The JOIN operation links the two tables based on the medication code, ensuring that only prescribed medications are counted.", "The GROUP BY clause organizes the results by the brand of the medication, allowing for a summary count per brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "description": "This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.", "virtual_table": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["The query identifies the relevant tables, which are 'Physician' and 'Prescribes'.", "It selects the 'Name' column from the 'Physician' table, aliased as T1.", "A JOIN operation is performed between 'Physician' (T1) and 'Prescribes' (T2) on the condition that the 'EmployeeID' from 'Physician' matches the 'Physician' identifier in 'Prescribes'.", "The results are ordered by the 'Dose' column from the 'Prescribes' table in descending order to show the highest dosages first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "description": "This virtual table lists the names of physicians from the 'Physician' table who have prescribed medications, ordered by the dosage of the medications in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["The query identifies the relevant table, which is 'Affiliated_With'.", "Select the columns to display, 'physician' and 'department'.", "Add a condition to filter the 'primaryaffiliation' column for the specified status using a placeholder for numeric values."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "description": "This virtual table provides a list of physicians along with their associated departments from the 'Affiliated_With' table, filtered by whether the affiliation is marked as primary. The placeholder in the WHERE clause represents the primary affiliation status.", "virtual_table": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3961", "db_id": "hospital_1", "question": "What are each physician's employee id and department id primarily affiliated.", "rationale": ["The query identifies the relevant table, which is 'Affiliated_With'.", "Select the columns to display, 'physician' and 'department'.", "Add a condition to filter the 'primaryaffiliation' column for the specified status using a placeholder for numeric values."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "description": "This virtual table provides a list of physicians along with their associated departments from the 'Affiliated_With' table, filtered by whether the affiliation is marked as primary. The placeholder in the WHERE clause represents the primary affiliation status.", "virtual_table": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3970", "db_id": "hospital_1", "question": "Find the three most expensive procedures.", "rationale": ["The query identifies the relevant table, which is 'Procedures'.", "Select the column to display, 'name', which represents the names of the procedures.", "Order the results by the 'cost' column to sort the procedures based on their costs.", "Use a placeholder in the LIMIT clause to allow the user to specify how many procedure names they want to retrieve."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "description": "This virtual table lists the names of medical procedures from the 'Procedures' table, ordered by their associated costs. The placeholder in the LIMIT clause allows the user to specify the maximum number of procedure names to retrieve.", "virtual_table": "SELECT name FROM procedures ORDER BY cost LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["The query identifies the relevant table, which is 'Procedures'.", "Select the column to display, 'name', which represents the name of the medical procedure.", "Order the results by the 'cost' column to sort the procedures based on their associated costs.", "Use a placeholder in the LIMIT clause to allow the user to specify how many procedure names they want to retrieve."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "description": "This virtual table lists the names of medical procedures from the 'Procedures' table, ordered by their cost. The placeholder in the LIMIT clause allows the user to specify the maximum number of procedure names to retrieve.", "virtual_table": "SELECT name FROM procedures ORDER BY cost LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3973", "db_id": "hospital_1", "question": "Which physicians are trained in procedures that are more expensive than 5000?", "rationale": ["The query identifies the relevant tables: 'Physician', 'Trained_In', and 'Procedures'.", "It selects the 'Name' column from the 'Physician' table.", "The query joins 'Physician' with 'Trained_In' on the 'EmployeeID' and 'Physician' identifiers to link physicians with their training.", "It further joins 'Trained_In' with 'Procedures' on the 'Code' and 'Treatment' identifiers to associate procedures with their costs.", "A condition is added to filter procedures based on their cost, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "description": "This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["The query identifies the relevant tables: 'Physician', 'Trained_In', and 'Procedures'.", "It selects the 'Name' column from the 'Physician' table (aliased as T1).", "It joins the 'Trained_In' table (aliased as T2) on the condition that the 'EmployeeID' from 'Physician' matches the 'Physician' identifier in 'Trained_In'.", "It further joins the 'Procedures' table (aliased as T3) on the condition that the 'Code' from 'Procedures' matches the 'Treatment' identifier in 'Trained_In'.", "The results are ordered by the 'Cost' of the procedures in descending order, and a limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "description": "This virtual table lists the names of physicians who are trained in specific medical procedures, ordered by the cost of those procedures in descending order. The placeholder in the LIMIT clause represents the maximum number of physician names to be returned.", "virtual_table": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.3985", "db_id": "hospital_1", "question": "What procedures cost less than 5000 and have John Wen as a trained physician?", "rationale": ["The query identifies the relevant table, which is 'Procedures', to select the names of procedures based on their cost.", "It uses a condition to filter procedures where the cost is less than a specified number using a placeholder.", "The query also intersects with another selection that involves joining the 'Physician' and 'Trained_In' tables to find procedures that a specific physician is trained in.", "The join condition links the physician's employee ID with the trained procedures, and the physician's name is filtered using a placeholder for string values."], "gold_sql": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "description": "This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.", "virtual_table": "SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4321", "db_id": "tracking_grants_for_research", "question": "What are the different grant amounts for documents sent before '1986-08-26 20:49:27' and after the grant ended on '1989-03-16 18:27:16'?", "rationale": ["The query identifies the relevant tables, which are 'Grants' and 'Documents'.", "It selects the 'grant_amount' from the 'Grants' table.", "A JOIN operation is performed between 'Grants' and 'Documents' on the 'grant_id' to link the two tables.", "A condition is added to filter documents based on the 'sent_date' being earlier than a specified date using a placeholder for string values.", "An INTERSECT operation is used to ensure that the selected grant amounts are also from grants that have an 'end_date' later than another specified date, again using a placeholder for string values."], "gold_sql": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  '1986-08-26 20:49:27' INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  '1989-03-16 18:27:16'", "source_tables": ["grants", "documents"], "description": "This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.", "virtual_table": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4322", "db_id": "tracking_grants_for_research", "question": "List the project details of the project both producing patent and paper as outcomes.", "rationale": ["The query identifies the relevant table, which is 'Projects', and aliases it as T1.", "It joins the 'Project_Outcomes' table, aliased as T2, on the project_id to link projects with their outcomes.", "The WHERE clause filters the results based on the first outcome_code using a placeholder for string values.", "The INTERSECT operation is used to find projects that also meet a second outcome_code condition, again using a placeholder for string values."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.", "virtual_table": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["The query identifies the relevant tables: 'Grants', 'Organisations', and 'Organisation_Types'.", "It selects the sum of the 'grant_amount' from the 'Grants' table.", "The query joins 'Grants' with 'Organisations' on the 'organisation_id' to associate grants with their organisations.", "It further joins 'Organisations' with 'Organisation_Types' on 'organisation_type' to filter by organisation type.", "The WHERE clause uses a placeholder to specify the organisation type description for filtering the results."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "description": "This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter by the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.", "virtual_table": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects the columns 'date_from' and 'date_to' to show the involvement period of staff members.", "The first part of the query filters projects based on the count of staff members, using a subquery to get the top N projects.", "The second part of the query filters by a specific 'role_code', allowing for a focused view of staff involvement based on their roles."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "description": "This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the columns 'organisation_type' and 'organisation_id' from the 'Organisations' table.", "A JOIN operation is performed to connect 'Organisations' with 'Research_Staff' based on the employer organisation ID.", "The results are grouped by 'organisation_id' to aggregate the data.", "The results are ordered by the count of research staff in descending order to prioritize organisations with more staff.", "A LIMIT clause is added to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisation types and their corresponding organisation IDs from the 'Organisations' table. It joins with the 'Research_Staff' table to filter organisations based on their employment of research staff. The results are grouped by organisation ID and ordered by the count of research staff associated with each organisation, limiting the output to a specified number of results.", "virtual_table": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["The query identifies the relevant tables: 'Documents', 'Grants', 'Organisations', and 'Organisation_Types'.", "It selects the 'sent_date' from the 'Documents' table.", "Joins are established between 'Documents' and 'Grants' on 'grant_id', between 'Grants' and 'Organisations' on 'organisation_id', and between 'Organisations' and 'Organisation_Types' on 'organisation_type'.", "A condition is added to filter grants with a specified amount using a placeholder for numeric values.", "Another condition filters the organisation type description using a placeholder for string values."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "description": "This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter based on the type of organisation. The placeholders represent the grant amount and the organisation type description.", "virtual_table": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER] AND T4.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4338", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects which did not hire any staff for a researcher role.", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "It selects the 'project_details' column to display information about the projects.", "The WHERE clause filters out projects that have staff members with a specific role by using a subquery on the 'Project_Staff' table, where the role code is represented by a placeholder for string values."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "description": "This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.", "virtual_table": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4339", "db_id": "tracking_grants_for_research", "question": "What are the details for all projects that did not hire any staff in a research role?", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "It selects the 'project_details' column to display information about the projects.", "The WHERE clause filters out projects that have staff members with a specific role by using a subquery on the 'Project_Staff' table, where the role code is represented by a placeholder for string values."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "description": "This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.", "virtual_table": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )"}
{"sample_id": "train.4342", "db_id": "tracking_grants_for_research", "question": "When do all the researcher role staff start to work, and when do they stop working?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "Select the columns to display, 'date_from' and 'date_to', which represent the involvement period of staff members.", "Add a condition to filter the 'role_code' column for the specified role using a placeholder for string values."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "description": "This virtual table provides the start and end dates of staff members' involvement in projects from the 'Project_Staff' table, filtered by a specific role code. The placeholder in the WHERE clause represents the role of the staff member.", "virtual_table": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4350", "db_id": "tracking_grants_for_research", "question": "How many staff does each project has? List the project id and the number in an ascending order.", "rationale": ["The query identifies the relevant tables, which are 'Project_Staff' and 'Projects'.", "It selects the 'project_id' from 'Project_Staff' and counts the number of staff members associated with each project.", "The JOIN operation links 'Project_Staff' to 'Projects' using the 'project_id' to ensure that the count corresponds to the correct project.", "The results are grouped by 'project_id' to aggregate the count of staff members for each project.", "Finally, the results are ordered in ascending order based on the count of staff members."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "description": "This virtual table provides a count of staff members associated with each project from the 'Project_Staff' table, grouped by project ID. The results are ordered in ascending order based on the number of staff members per project.", "virtual_table": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC"}
{"sample_id": "train.4351", "db_id": "tracking_grants_for_research", "question": "For each project id, how many staff does it have? List them in increasing order.", "rationale": ["The query identifies the relevant tables, which are 'Project_Staff' and 'Projects'.", "It selects the 'project_id' from 'Project_Staff' and counts the number of staff members associated with each project.", "The JOIN operation links 'Project_Staff' to 'Projects' using the 'project_id' to ensure that the count corresponds to the correct project.", "The results are grouped by 'project_id' to aggregate the count of staff members for each project.", "Finally, the results are ordered in ascending order based on the count of staff members."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "description": "This virtual table provides a count of staff members associated with each project from the 'Project_Staff' table, grouped by project ID. The results are ordered in ascending order based on the number of staff members per project.", "virtual_table": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["The query identifies the relevant tables, 'Projects' and 'Project_Outcomes'.", "It selects the 'project_details' and 'project_id' from the 'Projects' table.", "A JOIN operation is performed between 'Projects' and 'Project_Outcomes' on the 'project_id' to link projects with their outcomes.", "The results are grouped by 'project_id' to aggregate the outcomes for each project.", "The results are ordered by the count of outcomes in descending order to prioritize projects with more outcomes.", "A LIMIT clause is included to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.", "virtual_table": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4359", "db_id": "tracking_grants_for_research", "question": "What are the details of the project with no outcomes?", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "It selects the 'project_details' column to display information about the projects.", "A subquery is used to filter out project IDs that exist in the 'Project_Outcomes' table, ensuring that only projects without outcomes are included in the results."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )", "source_tables": ["project_outcomes", "projects"], "description": "This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated outcomes in the 'Project_Outcomes' table. The query uses a subquery to filter out projects that have recorded outcomes, ensuring that only projects without outcomes are displayed.", "virtual_table": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["The query identifies the relevant tables, 'Organisations' and 'Research_Staff'.", "It selects the columns 'organisation_id', 'organisation_type', and 'organisation_details' from the 'Organisations' table.", "A JOIN operation is performed between 'Organisations' and 'Research_Staff' on the condition that the organisation ID matches the employer organisation ID.", "The results are grouped by 'organisation_id' to aggregate the data for each organisation.", "The results are ordered by the count of research staff in descending order to prioritize organisations with more staff.", "A LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "description": "This virtual table provides a list of organisations along with their types and details, specifically focusing on those that employ research staff. The results are grouped by organisation ID and ordered by the number of research staff associated with each organisation, with a limit on the number of results returned as specified by the placeholder.", "virtual_table": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["The query identifies the relevant tables: 'Staff_Roles', 'Project_Staff', and 'Project_Outcomes'.", "It selects the 'role_description' from 'Staff_Roles' and 'staff_id' from 'Project_Staff'.", "The JOIN operation connects 'Staff_Roles' and 'Project_Staff' on the 'role_code'.", "Another JOIN connects 'Project_Staff' to 'Project_Outcomes' on 'project_id'.", "The results are grouped by 'staff_id' to aggregate the data.", "The results are ordered by the count of outcomes associated with each staff member in descending order.", "A LIMIT clause is added to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "description": "This virtual table provides a list of staff members along with their role descriptions from the 'Staff_Roles' and 'Project_Staff' tables. It joins these tables based on the role code and further connects to the 'Project_Outcomes' table to group the results by staff ID. The results are ordered by the count of associated outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.", "virtual_table": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4364", "db_id": "tracking_grants_for_research", "question": "Which document type is described with the prefix 'Initial'?", "rationale": ["The query identifies the relevant table, which is 'Document_Types'.", "It selects the column 'document_type_code' to display the unique codes.", "A condition is added to filter the results based on the 'document_description' using a placeholder for string values."], "gold_sql": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'", "source_tables": ["document_types"], "description": "This virtual table retrieves the unique document type codes from the 'Document_Types' table based on a specific description of the document type. The placeholder in the WHERE clause allows for filtering the results according to the desired document description.", "virtual_table": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["The query identifies the relevant table, which is 'Documents'.", "It selects the 'grant_id' and counts the number of documents associated with each grant using the COUNT function.", "The results are grouped by 'grant_id' to aggregate the document counts for each grant.", "The results are ordered in descending order based on the count of documents to show the grants with the most documents first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "description": "This virtual table summarizes the number of documents associated with each grant from the 'Documents' table. It groups the results by 'grant_id' and orders them in descending order based on the count of documents, allowing the user to specify a limit on the number of results returned.", "virtual_table": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.4374", "db_id": "tracking_grants_for_research", "question": "How many Patent outcomes are generated from all the projects?", "rationale": ["The query identifies the relevant table, which is 'Project_Outcomes'.", "It uses the COUNT function to count the number of records that meet the specified condition.", "A condition is added to filter the results based on the 'outcome_code' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  'Patent'", "source_tables": ["project_outcomes"], "description": "This virtual table provides the count of project outcomes from the 'Project_Outcomes' table that match a specific outcome code. The placeholder in the WHERE clause represents the outcome code being queried.", "virtual_table": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4376", "db_id": "tracking_grants_for_research", "question": "How many project staff worked as leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects a count of all records in the table.", "The WHERE clause includes conditions to filter by 'role_code' and 'date_from', using placeholders for string values."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "description": "This virtual table provides a count of staff members associated with projects, filtered by a specific role code or a start date that is earlier than a specified date. The placeholders in the WHERE clause represent the role code and the date for filtering the results.", "virtual_table": "SELECT count(*) FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] OR date_from  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["The query identifies the relevant tables: 'Research_Outcomes', 'Project_Outcomes', and 'Projects'.", "It selects the 'outcome_description' from the 'Research_Outcomes' table.", "The JOIN operations link the 'Research_Outcomes' to 'Project_Outcomes' using the 'outcome_code', and 'Project_Outcomes' to 'Projects' using the 'project_id'.", "A condition is added to filter the results based on the 'project_details' column from the 'Projects' table, using a placeholder for string values."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "description": "This virtual table describes the outcome descriptions of research outcomes associated with specific projects. The query joins the 'Research_Outcomes' table with the 'Project_Outcomes' table and the 'Projects' table to filter the results based on the project details. The placeholder in the WHERE clause represents the specific project details being queried.", "virtual_table": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["The query identifies the relevant tables: 'Research_Outcomes', 'Project_Outcomes', and 'Projects'.", "It selects the 'outcome_description' from the 'Research_Outcomes' table.", "The JOIN operations link the 'Research_Outcomes' to 'Project_Outcomes' using the 'outcome_code', and 'Project_Outcomes' to 'Projects' using the 'project_id'.", "A condition is added to filter the results based on the 'project_details' column from the 'Projects' table, using a placeholder for string values."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "description": "This virtual table describes the outcome descriptions of research outcomes associated with specific projects. The query joins the 'Research_Outcomes' table with the 'Project_Outcomes' table and the 'Projects' table to filter the results based on the project details. The placeholder in the WHERE clause represents the specific project details being queried.", "virtual_table": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4385", "db_id": "tracking_grants_for_research", "question": "What are the details for the projects which were launched by the organization with the most projects?", "rationale": ["The query identifies the relevant table, which is 'Projects'.", "It selects the 'project_details' column to display information about the projects.", "The WHERE clause filters the results to include only those organisations that have the highest number of projects, using a subquery that groups by 'organisation_id' and orders by the count of projects in descending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many top organisations to include in the results."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "description": "This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.", "virtual_table": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )"}
{"sample_id": "train.4391", "db_id": "tracking_grants_for_research", "question": "For each project id, how many tasks are there?", "rationale": ["The query identifies the relevant tables, which are 'Projects' and 'Tasks'.", "It selects the count of tasks and the project details from the 'Projects' table.", "A JOIN operation is performed on the 'project_id' to link tasks to their respective projects.", "The results are grouped by 'project_id' to aggregate the task counts for each project."], "gold_sql": "SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id", "source_tables": ["tasks", "projects"], "description": "This virtual table provides a count of tasks associated with each project from the 'Projects' table, along with the project details. The count is grouped by the unique project identifier, allowing users to see how many tasks are linked to each project.", "virtual_table": "SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "Select the column to display, 'role_code'.", "Add conditions to filter the 'date_from' and 'date_to' columns for the specified date range using placeholders for string values."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "description": "This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.", "virtual_table": "SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["The query identifies the relevant table, which is 'Project_Staff'.", "It selects the 'role_code' column to display unique role codes.", "The results are grouped by 'role_code' to ensure uniqueness.", "The results are ordered by the count of occurrences of each role code in descending order to prioritize the most common roles.", "A placeholder is included in the LIMIT clause to allow the user to specify how many role codes they want to retrieve."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "description": "This virtual table provides a list of unique role codes from the 'Project_Staff' table, grouped by the role code and ordered by the number of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of role codes to retrieve.", "virtual_table": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["The query identifies the relevant table, which is 'Products'.", "It uses the COUNT function to count the number of products that meet specific criteria.", "The WHERE clause filters products based on the 'product_category_code' and checks if the 'typical_buying_price' is greater than a specified value, using placeholders for both the category code and the price."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "description": "This virtual table provides the count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.", "virtual_table": "SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["The query identifies the relevant tables, which are 'Ref_Product_Categories' and 'Products'.", "It selects the 'product_category_description' from 'Ref_Product_Categories'.", "A JOIN is performed between 'Ref_Product_Categories' and 'Products' on the 'product_category_code' to link the product categories with their respective products.", "A condition is added to filter the results based on the 'product_description' using a placeholder for string values."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "description": "This virtual table provides the descriptions of product categories from the 'Ref_Product_Categories' table for products that have a specific description. The placeholder in the WHERE clause allows for filtering products based on their description.", "virtual_table": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5576", "db_id": "products_gen_characteristics", "question": "Count the products that have the color description \"white\" or have the characteristic name \"hot\".", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors'.", "It uses JOIN operations to connect these tables based on their foreign key relationships.", "The SELECT statement counts the total number of products that meet the specified conditions.", "The WHERE clause filters the results based on the color description or characteristic name, using placeholders for string values."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "description": "This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from the 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors' tables, using joins to link the relevant identifiers and applying filters based on the provided placeholders.", "virtual_table": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["The query identifies the relevant table, which is 'Ref_Product_Categories'.", "Select the column to display, 'unit_of_measure'.", "Add a condition to filter the 'product_category_code' column for the specified product category using a placeholder for string values."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "description": "This virtual table provides the unit of measure for a specific product category from the 'Ref_Product_Categories' table. The placeholder in the WHERE clause represents the unique code for the product category.", "virtual_table": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["The query identifies the relevant tables, 'Products' and 'Ref_Product_Categories'.", "It selects the columns 'unit_of_measure' and 'product_category_code' from the 'Ref_Product_Categories' table.", "A JOIN operation is performed on the 'product_category_code' to link the 'Products' table with the 'Ref_Product_Categories' table.", "A condition is added to filter the results based on the specified product name using a placeholder for string values."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "description": "This virtual table provides the unit of measure and product category code for a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.", "virtual_table": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5589", "db_id": "products_gen_characteristics", "question": "What are the names of products that are not 'white' in color and are not measured by the unit 'Handful'?", "rationale": ["The query identifies the relevant tables: 'Products', 'Ref_Product_Categories', and 'Ref_Colors'.", "It selects the 'product_name' from the 'Products' table.", "The JOIN operations link the 'Products' table with 'Ref_Product_Categories' and 'Ref_Colors' based on their respective codes.", "The WHERE clause filters the results based on the specified color description and excludes products with a certain unit of measure using placeholders."], "gold_sql": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  'white' AND t2.unit_of_measure != 'Handful'", "source_tables": ["products", "ref_colors", "ref_product_categories"], "description": "This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure that should be excluded.", "virtual_table": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["The query identifies the relevant tables, 'Products' and 'Ref_Colors'.", "It selects the 'color_description' from the 'Ref_Colors' table.", "A JOIN operation is performed on the 'color_code' to link products with their respective colors.", "The results are grouped by 'color_description' to aggregate the data based on color.", "The ORDER BY clause sorts the results by the count of products associated with each color in ascending order.", "The LIMIT clause uses a placeholder to allow the user to specify how many color descriptions to return."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "description": "This virtual table provides a list of color descriptions for products from the 'Products' table, grouped by color and ordered by the count of products associated with each color. The placeholder in the LIMIT clause allows the user to specify the maximum number of color descriptions to retrieve.", "virtual_table": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["The query identifies the relevant tables: 'Products', 'Product_Characteristics', and 'Characteristics'.", "It selects the 'characteristic_name' from the 'Characteristics' table.", "The JOIN operations link the 'Products' table to 'Product_Characteristics' and then to 'Characteristics' based on their respective IDs.", "The results are grouped by 'characteristic_name' to aggregate the data.", "The HAVING clause filters the results to include only those characteristic names that have a count of associated products greater than or equal to a specified number using a placeholder."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "description": "This virtual table describes the names of characteristics associated with products from the 'Products' table. It retrieves characteristic names by joining the 'Products', 'Product_Characteristics', and 'Characteristics' tables. The results are grouped by characteristic name, and only those with a count of associated products greater than or equal to a specified number are included. The placeholder in the HAVING clause represents the minimum count of products for the characteristic names to be displayed.", "virtual_table": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5669", "db_id": "dorm_1", "question": "What are the names of the all-female dorms?", "rationale": ["The query is identifying the relevant table, which is 'Dorm'.", "Select the column to display, 'dorm_name'.", "Add a condition to filter the 'gender' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT dorm_name FROM dorm WHERE gender  =  'F'", "source_tables": ["dorm"], "description": "This virtual table lists the names of dormitories from the 'Dorm' table that are designated for a specific gender. The placeholder in the WHERE clause represents the gender designation for the dormitory.", "virtual_table": "SELECT dorm_name FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5688", "db_id": "dorm_1", "question": "Find the average and total capacity of dorms for the students with gender X.", "rationale": ["The query identifies the relevant table, which is 'Dorm'.", "It selects the average and sum of the 'student_capacity' column.", "A condition is added to filter the 'gender' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  'X'", "source_tables": ["dorm"], "description": "This virtual table provides the average and total student capacity of dormitories filtered by a specific gender designation. The placeholder in the WHERE clause represents the gender of the dormitory.", "virtual_table": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5699", "db_id": "dorm_1", "question": "What are the names and types of the dorms that have a capacity greater than 300 or less than 100?", "rationale": ["The query identifies the relevant table, which is 'Dorm'.", "Select the columns to display, 'dorm_name' and 'gender'.", "Add a condition to filter the 'student_capacity' column for values greater than or less than the specified number using placeholders for numeric values."], "gold_sql": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100", "source_tables": ["dorm"], "description": "This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.", "virtual_table": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] OR student_capacity  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["The query identifies the relevant tables: 'student', 'lives_in', and 'dorm'.", "It joins the 'student' table with the 'lives_in' table on the student ID to associate students with their dormitory.", "Then, it joins the 'dorm' table to access the gender designation of the dormitories.", "Finally, it counts the number of students filtered by the specified gender using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "description": "This virtual table provides the count of students residing in dormitories based on gender designation. The placeholders in the WHERE clause represent the gender of the dormitory.", "virtual_table": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5755", "db_id": "dorm_1", "question": "What is the most common amenity in the dorms?", "rationale": ["The query identifies the relevant tables, 'dorm_amenity' and 'has_amenity'.", "It selects the 'amenity_name' from the 'dorm_amenity' table.", "A JOIN operation is performed on 'has_amenity' to link amenities to dormitories using their identifiers.", "The results are grouped by the amenity identifier to aggregate the data.", "The results are ordered by the count of occurrences in descending order to show the most common amenities first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_amenity", "dorm_amenity"], "description": "The virtual table describes the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to be displayed.", "virtual_table": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5757", "db_id": "dorm_1", "question": "What are the first names of all students who live in the dorm with the most amenities?", "rationale": ["The query identifies the relevant tables, which are 'Student', 'Lives_in', 'Dorm', 'Has_amenity', and 'Dorm_amenity'.", "It selects the 'fname' column from the 'Student' table.", "The query joins 'Student' with 'Lives_in' to find which students live in which dorms.", "A subquery is used to find dorms with the most amenities by joining 'Dorm', 'Has_amenity', and 'Dorm_amenity', counting the amenities for each dorm, and ordering them.", "The LIMIT clause uses a placeholder for the maximum number of dormitories to return."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "description": "This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.", "virtual_table": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.5776", "db_id": "customer_complaints", "question": "Find the emails of customers who has filed a complaints of the product with the most complaints.", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Complaints'.", "It selects the 'email_address' from the 'Customers' table.", "A JOIN operation is performed between 'Customers' and 'Complaints' on the 'customer_id' to link customers with their complaints.", "The results are grouped by 'customer_id' to aggregate the complaints per customer.", "The results are ordered by the count of complaints to prioritize customers with more complaints.", "A LIMIT clause is included to restrict the number of results returned based on a numeric placeholder."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "description": "This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited by a specified numeric placeholder.", "virtual_table": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Complaints'.", "It selects the 'email_address' from the 'Customers' table, aliased as 't1'.", "A JOIN operation is performed between 'Customers' and 'Complaints' on the 'customer_id' to link customers with their complaints.", "The results are grouped by 'customer_id' to ensure unique email addresses are returned for each customer.", "The results are ordered by the count of complaints to prioritize customers with more complaints.", "A LIMIT clause is included to restrict the number of results returned based on a specified number."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "description": "This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited by a specified number.", "virtual_table": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5779", "db_id": "customer_complaints", "question": "Return the names of products that have had complaints filed by the customer who has filed the fewest complaints.", "rationale": ["The query identifies the relevant tables: 'Products', 'Complaints', and 'Customers'.", "It selects distinct product names from the 'Products' table.", "The join condition links the 'Products' table to the 'Complaints' table using the product identifier.", "The query groups the results by customer identifiers to ensure unique customer counts.", "The results are ordered by the count of complaints associated with each product, and a placeholder is included to limit the number of results returned."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "description": "This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers to ensure that each customer is counted only once. The results are ordered by the count of complaints, and a placeholder is included to limit the number of results returned.", "virtual_table": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["The query identifies the relevant tables: 'staff', 'complaints', and 'products'.", "It selects the 'last_name' column from the 'staff' table.", "The query joins the 'staff' table with the 'complaints' table on the 'staff_id' to link staff members to the complaints they handle.", "It further joins the 'complaints' table with the 'products' table on the 'product_id' to associate complaints with the respective products.", "The results are ordered by the 'product_price' from the 'products' table, ensuring that the staff names are listed according to the price of the products involved in the complaints.", "The LIMIT clause uses a placeholder for a numeric value to allow users to specify how many results they want."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "description": "This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.", "virtual_table": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5800", "db_id": "customer_complaints", "question": "How many customers are there in the customer type with the most customers?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It uses the COUNT function to count the number of customers for each type, grouping the results by 'customer_type_code'.", "The results are ordered in descending order based on the count of customers, allowing the most common customer types to appear first.", "A LIMIT clause is included to restrict the number of results returned, with a placeholder for the user to specify the desired number."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.", "virtual_table": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["The query identifies the relevant tables, 'Staff' and 'Complaints'.", "It selects the 'first_name' column from the 'Staff' table, aliased as 't1'.", "A JOIN operation is performed between 'Staff' and 'Complaints' on the 'staff_id' column to link staff members to the complaints they handle.", "The results are grouped by 'staff_id' to aggregate the data for each staff member.", "The results are ordered by the count of complaints handled by each staff member, allowing us to see who has the most complaints.", "A LIMIT clause is included to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "description": "This virtual table provides the first names of staff members from the 'Staff' table who are associated with complaints in the 'Complaints' table. The results are grouped by staff member and ordered by the number of complaints they have handled, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5812", "db_id": "customer_complaints", "question": "Which state has the most customers?", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'state' column to display the states of customers.", "The results are grouped by 'state' to aggregate customer counts per state.", "The results are ordered by the count of customers in each state to prioritize states with more customers.", "The LIMIT clause uses a placeholder to allow the user to specify how many states to return."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the states where customers reside, grouping the results by state and ordering them by the number of customers in each state. The placeholder in the LIMIT clause allows for specifying the maximum number of states to return.", "virtual_table": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5813", "db_id": "customer_complaints", "question": "Give the state that has the most customers.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'state' column to display the states of the customers.", "The results are grouped by 'state' to aggregate customer counts per state.", "The results are ordered by the count of customers in each state to prioritize states with more customers.", "The LIMIT clause uses a placeholder to allow the user to specify how many states to return."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the states where customers reside, grouping the results by state and ordering them by the number of customers in each state. The placeholder in the LIMIT clause allows for specifying the maximum number of states to return.", "virtual_table": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5865", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions whose share count is bigger than 100 and whose type code is \"PUR\"?", "rationale": ["The query identifies the relevant tables: 'Lots', 'Transactions_Lots', and 'Transactions'.", "It selects the 'lot_details' from the 'Lots' table.", "The query uses JOINs to connect 'Lots' with 'Transactions_Lots' and 'Transactions' based on their respective identifiers.", "A condition is added to filter the results based on the 'share_count' and 'transaction_type_code', using placeholders for numeric and string values."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  100 AND T3.transaction_type_code  =  'PUR'", "source_tables": ["lots", "transactions_lots", "transactions"], "description": "This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.", "virtual_table": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "It selects the 'transaction_type_code' to categorize the transactions.", "The query calculates the average of 'amount_of_transaction' for each transaction type.", "The GROUP BY clause is used to group the results by 'transaction_type_code' to get the average amount for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "description": "This virtual table summarizes the average amount of transactions grouped by their respective transaction types from the 'Transactions' table. The placeholder in the SELECT clause represents the transaction type code, while the average amount is calculated for each type.", "virtual_table": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code"}
{"sample_id": "train.5873", "db_id": "tracking_share_transactions", "question": "Show the number of transactions with transaction type code \"SALE\" for different investors if it is larger than 0.", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "It selects the 'investor_id' and counts the number of transactions for each investor.", "A condition is added to filter the transactions based on the specified transaction type using a placeholder for string values.", "The results are grouped by 'investor_id' to provide a count of transactions per investor."], "gold_sql": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE' GROUP BY investor_id", "source_tables": ["transactions"], "description": "This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.", "virtual_table": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY investor_id"}
{"sample_id": "train.5876", "db_id": "tracking_share_transactions", "question": "Show the transaction type code that occurs the most frequently.", "rationale": ["The query identifies the relevant table, which is 'Transactions'.", "It selects the 'transaction_type_code' to display the unique types of transactions.", "The GROUP BY clause is used to group the results by 'transaction_type_code'.", "The ORDER BY clause sorts the grouped results based on the count of each transaction type in descending order.", "The LIMIT clause restricts the number of results returned to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["transactions"], "description": "This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.", "virtual_table": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5884", "db_id": "tracking_share_transactions", "question": "What are the details of the lots which are not used in any transactions?", "rationale": ["The query identifies the relevant table, which is 'Lots'.", "It selects the 'lot_details' column from the 'Lots' table.", "The EXCEPT clause is used to filter out lot details that are linked to transactions by joining the 'Lots' table with the 'Transactions_Lots' table on the 'lot_id' column."], "gold_sql": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id", "source_tables": ["lots", "transactions_lots"], "description": "This virtual table provides the details of lots from the 'Lots' table that are not associated with any transactions. The query uses an EXCEPT clause to exclude lot details that are linked to transactions through the 'Transactions_Lots' table.", "virtual_table": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id"}
{"sample_id": "train.5893", "db_id": "cre_Theme_park", "question": "Show details of all visitors.", "rationale": ["The query identifies the relevant table, which is 'Visitors'.", "Select the column to display, 'Tourist_Details'."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "description": "This virtual table provides details about tourists from the 'Visitors' table. The placeholder in the SELECT clause represents the specific details related to each tourist.", "virtual_table": "SELECT Tourist_Details FROM VISITORS"}
{"sample_id": "train.5901", "db_id": "cre_Theme_park", "question": "What is the detail of the location UK Gallery?", "rationale": ["The query identifies the relevant table, which is 'Locations'.", "Select the column to display, 'Other_Details'.", "Add a condition to filter the 'Location_Name' column for the specified location using a placeholder for string values."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "description": "This virtual table provides additional information about a specific location from the 'Locations' table based on the location's name. The placeholder in the WHERE clause represents the name of the location being queried.", "virtual_table": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5902", "db_id": "cre_Theme_park", "question": "Return the detail of the location named \"UK Gallery\".", "rationale": ["The query identifies the relevant table, which is 'Locations'.", "Select the column to display, 'Other_Details'.", "Add a condition to filter the 'Location_Name' column for the specified location using a placeholder for string values."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "description": "This virtual table provides additional information about a specific location from the 'Locations' table based on the location's name. The placeholder in the WHERE clause represents the name of the location being queried.", "virtual_table": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5914", "db_id": "cre_Theme_park", "question": "Give me the star rating descriptions of the hotels that cost more than 10000.", "rationale": ["The query identifies the relevant tables, which are 'Hotels' and 'Ref_Hotel_Star_Ratings'.", "It selects the 'star_rating_description' from the 'Ref_Hotel_Star_Ratings' table.", "A JOIN operation is performed on the 'star_rating_code' to link the two tables based on their relationship.", "A condition is added to filter hotels based on their 'price_range', using a placeholder for numeric values."], "gold_sql": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  10000", "source_tables": ["ref_hotel_star_ratings", "hotels"], "description": "This virtual table describes the star rating descriptions of hotels from the 'Ref_Hotel_Star_Ratings' table that have a price range above a specified value. The placeholder in the WHERE clause represents the price range threshold.", "virtual_table": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["The query identifies the relevant tables, which are 'Museums' and 'Tourist_Attractions'.", "It selects the 'Museum_Details' from the 'Museums' table and 'Opening_Hours' from the 'Tourist_Attractions' table.", "A JOIN operation is performed on the 'Museum_ID' from the 'Museums' table and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table to link the two tables based on their relationship."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "description": "This virtual table provides details about museums and their opening hours by joining the 'Museums' table with the 'Tourist_Attractions' table. The placeholder in the SELECT statement allows for the retrieval of specific museum details and their corresponding opening hours.", "virtual_table": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["The query identifies the relevant tables, which are 'Royal_Family' and 'Tourist_Attractions'.", "It selects the 'Royal_Family_Details' from the 'Royal_Family' table and 'How_to_Get_There' from the 'Tourist_Attractions' table.", "A join operation is performed on the 'Royal_Family_ID' from the 'Royal_Family' table and 'Tourist_Attraction_ID' from the 'Tourist_Attractions' table to link the two tables based on their relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "description": "This virtual table provides details about royal families and the instructions on how to reach the associated tourist attractions. The join operation links the 'Royal_Family' table with the 'Tourist_Attractions' table based on the unique identifier for royal family entries and the tourist attraction ID.", "virtual_table": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID"}
{"sample_id": "train.5924", "db_id": "cre_Theme_park", "question": "Find the details of the shops that can be reached by walk.", "rationale": ["The query identifies the relevant tables, which are 'SHOPS' and 'TOURIST_ATTRACTIONS'.", "It selects the 'Shop_Details' column from the 'SHOPS' table.", "A JOIN operation is performed to link 'SHOPS' with 'TOURIST_ATTRACTIONS' based on the matching 'Shop_ID' and 'Tourist_Attraction_ID'.", "A condition is added to filter the results based on the 'How_to_Get_There' column from the 'TOURIST_ATTRACTIONS' table, using a placeholder for string values."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "description": "This virtual table provides the details of shops that are associated with tourist attractions, filtered by specific instructions on how to reach those attractions. The placeholder in the WHERE clause represents the directions to the attraction.", "virtual_table": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5927", "db_id": "cre_Theme_park", "question": "What are the details of the markets that can be accessed by walk or bus?", "rationale": ["The query identifies the relevant tables, 'Street_Markets' and 'Tourist_Attractions'.", "It selects the 'Market_Details' from the 'Street_Markets' table.", "A JOIN operation is performed to link 'Street_Markets' with 'Tourist_Attractions' using the 'Market_ID' and 'Tourist_Attraction_ID'.", "Conditions are added to filter the results based on the 'How_to_Get_There' column from 'Tourist_Attractions', allowing for two different sets of instructions using placeholders."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "description": "This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.", "virtual_table": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5928", "db_id": "cre_Theme_park", "question": "Find the details of all the markets that are accessible by walk or bus.", "rationale": ["The query identifies the relevant tables, 'Street_Markets' and 'Tourist_Attractions'.", "It selects the 'Market_Details' from the 'Street_Markets' table.", "A JOIN operation is performed to link 'Street_Markets' with 'Tourist_Attractions' based on the matching 'Market_ID' and 'Tourist_Attraction_ID'.", "The WHERE clause filters the results based on the 'How_to_Get_There' column from 'Tourist_Attractions', allowing for two different methods of access using placeholders."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "description": "This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access using placeholders.", "virtual_table": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Select the column to display, 'other_hotel_details'.", "Order the results by 'price_range' in descending order to show the most expensive hotels first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "description": "This virtual table provides additional details about hotels from the 'Hotels' table, sorted by their price range in descending order. The placeholder in the LIMIT clause represents the maximum number of hotel details to retrieve.", "virtual_table": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5943", "db_id": "cre_Theme_park", "question": "Show the details and star ratings of the 3 least expensive hotels.", "rationale": ["The query identifies the relevant table, which is 'Hotels'.", "Selects the columns 'other_hotel_details' and 'star_rating_code' to display information about the hotels.", "Orders the results by 'price_range' in ascending order to show cheaper hotels first.", "Limits the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "description": "This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.", "virtual_table": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["The query identifies the relevant table, which is 'Tourist_Attractions'.", "Select the column 'How_to_Get_There' to display the instructions for reaching attractions.", "Group the results by 'How_to_Get_There' to consolidate similar instructions.", "Order the results by the count of occurrences of each instruction in descending order to prioritize the most common ones.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "description": "This virtual table provides a list of instructions on how to reach various tourist attractions, grouped by the unique directions available. The results are ordered by the frequency of each instruction, allowing users to see the most common ways to get to attractions. The placeholder in the LIMIT clause represents the maximum number of instructions to retrieve.", "virtual_table": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["The query identifies the relevant table, which is 'Tourist_Attractions'.", "Select the column 'How_to_Get_There' to display the instructions for reaching attractions.", "Group the results by 'How_to_Get_There' to consolidate similar instructions.", "Order the results by the count of occurrences of each instruction in descending order to prioritize the most common ones.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "description": "This virtual table provides a list of instructions on how to reach various tourist attractions, grouped by the unique directions available. The results are ordered by the frequency of each instruction, allowing users to see the most common ways to get to attractions. The placeholder in the LIMIT clause represents the maximum number of instructions to retrieve.", "virtual_table": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.5951", "db_id": "cre_Theme_park", "question": "Show different tourist attractions' names, ids, and the corresponding number of visits.", "rationale": ["The query identifies the relevant tables, which are 'Tourist_Attractions' and 'Visits'.", "It selects the 'Name' of the tourist attraction from 'Tourist_Attractions' and the 'Tourist_Attraction_ID' from 'Visits'.", "The COUNT function is used to count the number of visits for each attraction.", "The JOIN operation links the two tables on the 'Tourist_Attraction_ID' to associate visits with their respective attractions.", "Finally, the results are grouped by 'Tourist_Attraction_ID' to aggregate the visit counts for each attraction."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "description": "This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.", "virtual_table": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Tourist_Attraction_Features', and 'Features'.", "It selects the 'Name' column from the 'Tourist_Attractions' table.", "The JOIN operations link the tables based on their foreign key relationships, ensuring that only attractions with the specified features are included.", "The WHERE clause filters the results based on the feature details, using placeholders for the specific feature descriptions. The UNION operator allows for combining results from two similar queries, each filtering by a different feature detail."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "description": "This virtual table lists the names of tourist attractions that feature specific characteristics. The query combines results from the 'Tourist_Attractions', 'Tourist_Attraction_Features', and 'Features' tables, filtering based on the details of the features. The placeholders in the WHERE clause represent the specific feature details being queried.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Tourist_Attraction_Features', and 'Features'.", "It selects the 'Name' column from the 'Tourist_Attractions' table.", "The JOIN operations link the tables based on their foreign key relationships, ensuring that only attractions with the specified features are included.", "The WHERE clause filters the results based on the feature details, using placeholders for the specific feature descriptions. The UNION operator allows for combining results from two similar queries, each filtering by a different feature detail."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "description": "This virtual table lists the names of tourist attractions that feature specific characteristics. The query combines results from the 'Tourist_Attractions', 'Tourist_Attraction_Features', and 'Features' tables, filtering based on the details of the features. The placeholders in the WHERE clause represent the specific feature details being queried.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.5964", "db_id": "cre_Theme_park", "question": "Which tourist attractions do the tourists Vincent and Marcelle visit? Tell me the names of the attractions.", "rationale": ["The query identifies the relevant tables: 'Tourist_Attractions', 'Visitors', and 'Visits'.", "It selects the 'Name' of the tourist attractions from the 'Tourist_Attractions' table.", "The JOIN operations link the 'Tourist_Attractions' with 'Visitors' and 'Visits' to filter the attractions based on the tourists' details.", "The WHERE clause uses placeholders to specify the details of the tourists being compared.", "The INTERSECT operator is used to find common attractions visited by both tourists."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "description": "This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of the tourists being compared.", "virtual_table": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6059", "db_id": "customers_and_addresses", "question": "What is the average amount of items ordered in each order?", "rationale": ["The query identifies the relevant table, which is 'Order_Items'.", "It selects the average of the 'order_quantity' column to provide a summary statistic.", "The use of the aggregate function 'avg()' indicates that we are interested in the average value of the specified column."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "description": "This virtual table calculates the average quantity of products ordered from the 'Order_Items' table. The placeholder in the SELECT clause represents the average of the order quantities.", "virtual_table": "SELECT avg(order_quantity) FROM order_items"}
{"sample_id": "train.6066", "db_id": "customers_and_addresses", "question": "Find the payment method that is used most frequently.", "rationale": ["The query identifies the relevant table, which is 'Customers'.", "It selects the 'payment_method' column to display the preferred payment methods.", "The results are grouped by 'payment_method' to aggregate the data.", "The query orders the results by the count of each payment method in descending order to show the most popular methods first.", "A limit is applied to restrict the number of payment methods returned, using a placeholder for numeric values."], "gold_sql": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "description": "This virtual table summarizes the preferred payment methods used by customers from the 'Customers' table. It groups the results by payment method and orders them by the frequency of each method, allowing the user to specify a limit on the number of payment methods returned.", "virtual_table": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["The query identifies the relevant tables: 'Customers', 'Customer_Addresses', and 'Addresses'.", "It selects the 'city' column from the 'Addresses' table.", "The query joins the 'Customers' table with 'Customer_Addresses' on 'customer_id' and then joins 'Customer_Addresses' with 'Addresses' on 'address_id'.", "The results are grouped by 'city' to aggregate the number of customers in each city.", "The results are ordered by the count of customers in descending order, and a limit is applied to restrict the number of cities returned based on a placeholder for numeric values."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "description": "This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.", "virtual_table": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6098", "db_id": "customers_and_addresses", "question": "Find the contact channel code that was used by the customer named \"Tillman Ernser\".", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects distinct values from the 'channel_code' column to avoid duplicates.", "A JOIN operation is performed on 'customer_id' to link the two tables based on the customer.", "A condition is added to filter the results based on the specified customer's name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.", "virtual_table": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6099", "db_id": "customers_and_addresses", "question": "What is the \"active to date\" of the latest contact channel used by \"Tillman Ernser\"?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects the maximum value of 'active_to_date' from 'Customer_Contact_Channels' to find the most recent deactivation date.", "A JOIN operation is performed on 'customer_id' to link the two tables based on the customer.", "A condition is added to filter the results based on the specified customer's name using a placeholder for string values."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table retrieves the most recent deactivation date of a contact channel for a specific customer from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the customer's name.", "virtual_table": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It uses a JOIN operation to link the two tables based on the 'customer_id'.", "The SELECT statement retrieves the maximum 'active_to_date' from the 'Customer_Contact_Channels' table.", "A condition is added to filter the results based on the specified customer's name using a placeholder for string values."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table retrieves the most recent deactivation date of a contact channel for a specific customer from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the customer's name.", "virtual_table": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["The query identifies the relevant table, which is 'Customer_Contact_Channels'.", "It calculates the average duration by subtracting 'active_from_date' from 'active_to_date'.", "The result is aggregated using the AVG function to provide the average duration of active contact channels."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "description": "This virtual table calculates the average duration that contact channels remain active for customers in the 'Customer_Contact_Channels' table. The placeholder in the SELECT clause represents the calculation of the difference between the active dates.", "virtual_table": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels"}
{"sample_id": "train.6102", "db_id": "customers_and_addresses", "question": "Compute the average active time span of contact channels.", "rationale": ["The query identifies the relevant table, which is 'Customer_Contact_Channels'.", "It calculates the average duration of active contact channels by subtracting 'active_from_date' from 'active_to_date'.", "The result is aggregated using the AVG function to provide the average duration of active contact channels."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "description": "This virtual table calculates the average duration that contact channels remain active for customers in the 'Customer_Contact_Channels' table. The placeholder in the SELECT clause represents the calculation of the difference between the active dates.", "virtual_table": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels"}
{"sample_id": "train.6104", "db_id": "customers_and_addresses", "question": "Return the channel code and contact number of the customer contact channel whose active duration was the longest.", "rationale": ["The query identifies the relevant table, which is 'Customer_Contact_Channels'.", "Select the columns to display, 'channel_code' and 'contact_number'.", "Add a condition to filter the active contact channels based on their active duration, comparing it to the maximum active duration found in a subquery.", "The subquery calculates the longest active duration by ordering the active durations in descending order and limiting the results to a specified number using a placeholder for numeric values."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "description": "This virtual table provides the channel codes and contact numbers of customer contact channels that have been active for a duration equal to the longest active duration found in the 'Customer_Contact_Channels' table. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.", "virtual_table": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])"}
{"sample_id": "train.6105", "db_id": "customers_and_addresses", "question": "Find the name and active date of the customer that use email as the contact channel.", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Contact_Channels'.", "It selects the 'customer_name' from the 'Customers' table and 'active_from_date' from the 'Customer_Contact_Channels' table.", "A JOIN operation is performed on the 'customer_id' to link the two tables together.", "A condition is added to filter the results based on the 'channel_code' using a placeholder for string values."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "description": "This virtual table provides the names of customers along with the activation dates of their preferred contact channels from the 'Customers' and 'Customer_Contact_Channels' tables. The placeholder in the WHERE clause represents the specific contact channel code being queried.", "virtual_table": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6127", "db_id": "customers_and_addresses", "question": "Who made the latest order?", "rationale": ["The query identifies the relevant tables, which are 'Customers' and 'Customer_Orders'.", "It selects the 'customer_name' column from the 'Customers' table.", "A JOIN operation is performed to link 'Customers' with 'Customer_Orders' based on the 'customer_id'.", "The results are ordered by 'order_date' in descending order to show the most recent orders first.", "The LIMIT clause is included to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT 1", "source_tables": ["customer_orders", "customers"], "description": "This virtual table provides a list of customer names from the 'Customers' table who have placed orders, sorted by the date of their most recent order. The placeholder in the LIMIT clause allows for specifying the maximum number of customer names to retrieve.", "virtual_table": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["The query identifies the relevant tables, 'Order_Items' and 'Products'.", "It selects the 'product_details' and 'product_id' from the 'Products' table.", "A JOIN operation is performed between 'Order_Items' and 'Products' on the 'product_id' to link ordered items with their details.", "The results are grouped by 'product_id' to aggregate the order quantities for each product.", "The results are ordered by the sum of 'order_quantity' to show the most ordered products first.", "A limit is applied to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "description": "This virtual table provides a summary of product details and their identifiers from the 'Products' table, based on the quantities ordered from the 'Order_Items' table. The results are grouped by product ID and ordered by the total quantity ordered, with a limit specified by a placeholder for numeric values.", "virtual_table": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects the 'address_content' column to display the detailed description of the addresses.", "The query includes two conditions to filter the results based on the specified city and state, using placeholders for string values.", "The UNION operator is used to combine results from two identical queries, allowing for flexibility in retrieving addresses from two different locations."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "description": "This virtual table retrieves the detailed address content from the 'Addresses' table for specific cities and states, allowing for the combination of results from two different queries based on the same criteria. The placeholders in the WHERE clauses represent the city and state names.", "virtual_table": "SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6134", "db_id": "customers_and_addresses", "question": "What are all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects the 'address_content' column to display the detailed description of the addresses.", "The query includes a condition to filter the results based on the 'city' and 'state_province_county' columns using placeholders for string values.", "The UNION operator is used to combine results from two identical queries, allowing for flexibility in retrieving addresses from two different locations."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "description": "This virtual table retrieves the detailed address content from the 'Addresses' table for specific cities and states, allowing for the combination of results from two different queries based on the same criteria. The placeholders in the WHERE clauses represent the city and state names.", "virtual_table": "SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["The query is identifying the relevant table, which is 'match'.", "Select the column to display, 'match_id'.", "Add a condition to filter the 'competition' column for the specified competition using a placeholder for string values."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "description": "This virtual table describes the unique identifiers of matches from the 'match' table that are part of a specific competition. The placeholder in the WHERE clause represents the competition's identifier.", "virtual_table": "SELECT match_id FROM MATCH WHERE competition = [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6275", "db_id": "city_record", "question": "Find the city that hosted the most events.", "rationale": ["The query identifies the relevant tables, 'city' and 'hosting_city'.", "It selects the 'city' from the 'city' table, using an alias for clarity.", "A JOIN operation is performed between 'city' and 'hosting_city' on the condition that the city ID matches the host city ID.", "The results are grouped by the host city to count the number of matches hosted in each city.", "The results are ordered in descending order based on the count of matches, and a placeholder is used in the LIMIT clause to specify the number of results to return."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "description": "This virtual table lists the cities that have hosted the most matches, ordered by the number of matches hosted. The placeholder in the LIMIT clause allows the user to specify how many top cities they want to retrieve.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6282", "db_id": "city_record", "question": "Which three cities have the largest regional population?", "rationale": ["The query identifies the relevant table, which is 'city'.", "Select the column to display, 'city'.", "Order the results by 'regional_population' in descending order to show the most populated cities first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "description": "This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.", "virtual_table": "SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6283", "db_id": "city_record", "question": "What are the three largest cities in terms of regional population?", "rationale": ["The query identifies the relevant table, which is 'city'.", "Select the column to display, 'city'.", "Order the results by 'regional_population' in descending order to show the most populated cities first.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "description": "This virtual table lists the names of cities from the 'city' table, ordered by their regional population in descending order. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.", "virtual_table": "SELECT city FROM city ORDER BY regional_population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["The query identifies the relevant tables, which are 'city' and 'temperature'.", "It selects the 'city' column from the 'city' table, aliased as T1.", "A JOIN operation is performed between 'city' and 'temperature' on the 'city_id' to combine data from both tables.", "The results are ordered by the average temperature in February from the 'temperature' table in descending order.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "description": "This virtual table lists the names of cities from the 'city' table, ordered by their average temperature in February from the 'temperature' table. The placeholder in the LIMIT clause represents the maximum number of cities to be displayed.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["The query identifies the relevant tables, which are 'city' and 'temperature'.", "It selects the 'city' column from the 'city' table, aliased as T1.", "A JOIN operation is performed between 'city' (T1) and 'temperature' (T2) on the 'city_id' to combine data from both tables.", "The WHERE clause applies conditions to filter cities based on their average temperatures in March, July, and October using placeholders for the temperature values."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "description": "This virtual table lists the names of cities from the 'city' table that have a March average temperature lower than July or higher than October. The placeholders in the WHERE clause represent the temperature values for the respective months.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct"}
{"sample_id": "train.6290", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in July and which have also served as host cities?", "rationale": ["The query is identifying the relevant tables, which are 'city', 'temperature', and 'hosting_city'.", "It selects the 'city' from the 'city' table where the average temperature in March is less than that in July, using a join with the 'temperature' table.", "The INTERSECT clause is used to find cities that also appear in the 'hosting_city' table, indicating they have hosted a match."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["The query starts by selecting the 'city' from the 'city' table, aliased as T1.", "It joins the 'temperature' table, aliased as T2, on the 'city_id' to access temperature data.", "The WHERE clause filters cities where the average temperature in March is less than that in December.", "The EXCEPT clause is used to exclude cities that are found in the 'hosting_city' table, which indicates they have hosted a match. This is done by joining the 'city' table again, aliased as T3, with the 'hosting_city' table, aliased as T4, on the 'city_id' and 'host_city'."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table identifies cities that have a higher average temperature in March compared to December, while excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6295", "db_id": "city_record", "question": "Which cities have higher temperature in Feb than in Jun or have once served as host cities?", "rationale": ["The query identifies the relevant tables, which are 'city', 'temperature', and 'hosting_city'.", "It selects the 'city' column from the 'city' table.", "The first part of the query joins 'city' and 'temperature' tables to filter cities based on the condition that the average temperature in February is greater than in June.", "The second part of the query selects cities from the 'hosting_city' table that have hosted matches, ensuring that the results include cities from both conditions.", "The use of UNION combines the results from both queries into a single list of cities."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "description": "This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than that in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.", "virtual_table": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city"}
{"sample_id": "train.6324", "db_id": "e_government", "question": "Find the last name of the first ever contact person of the organization with the highest UK Vat number.", "rationale": ["The query identifies the relevant tables: 'organizations', 'organization_contact_individuals', and 'individuals'.", "It selects the 'individual_last_name' from the 'individuals' table.", "The query joins the 'organizations' table with 'organization_contact_individuals' on 'organization_id' and then joins with 'individuals' on 'individual_id'.", "A subquery is used to find the organization with the maximum 'uk_vat_number'.", "The results are ordered by 'date_contact_to' in ascending order, and a placeholder is included to limit the number of results returned."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "description": "This virtual table provides the last names of individuals who have contacted the organization with the highest VAT registration number. The results are ordered by the end date of the contact period, and a placeholder is included to limit the number of results returned.", "virtual_table": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6328", "db_id": "e_government", "question": "Find name of the services that has never been used.", "rationale": ["The query identifies the relevant table, which is 'Services'.", "It selects the 'service_name' column to display the names of the services.", "The EXCEPT clause is used to filter out service names that are linked to any bookings in the 'Party_Services' table by joining the 'Services' table with the 'Party_Services' table on the 'service_id' column."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "description": "This virtual table lists the names of services from the 'Services' table that are not booked by any party in the 'Party_Services' table. The query uses an EXCEPT clause to exclude service names that are present in the 'Party_Services' table, ensuring only unbooked services are displayed.", "virtual_table": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects the 'town_city' column and the 'state_province_county' column.", "The UNION operator is used to combine the results from both columns, ensuring that the final output contains unique values from both selections."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "description": "This virtual table provides a combined list of town/city names and state/province/county names from the 'Addresses' table. The use of UNION allows for the retrieval of unique entries from both columns, ensuring that any duplicates are removed.", "virtual_table": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses"}
{"sample_id": "train.6331", "db_id": "e_government", "question": "What are the names of all cities and states?", "rationale": ["The query identifies the relevant table, which is 'Addresses'.", "It selects the 'town_city' column to retrieve names of towns or cities.", "It also selects the 'state_province_county' column to retrieve names of states, provinces, or counties.", "The UNION operator is used to combine the results from both selections, ensuring that only unique values are returned."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "description": "This virtual table provides a combined list of town or city names and state, province, or county names from the 'Addresses' table. The use of UNION allows for the retrieval of unique entries from both columns, ensuring that the results do not contain duplicates.", "virtual_table": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["The query identifies the relevant tables, which are 'Individuals' and 'Organization_Contact_Individuals'.", "It selects the 'individual_last_name' column from the 'Individuals' table.", "A JOIN operation is performed on the 'individual_id' to link individuals with their corresponding organization contacts.", "The DISTINCT keyword is used to ensure that only unique last names are included in the result."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "description": "This virtual table provides a list of unique last names of individuals who have contacted organizations. It combines data from the 'Individuals' table and the 'Organization_Contact_Individuals' table, ensuring that only distinct last names are returned.", "virtual_table": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id"}
{"sample_id": "train.6723", "db_id": "activity_1", "question": "Show the first name, last name, and phone number for all female faculty members.", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the columns to display, 'Fname', 'Lname', and 'phone'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "description": "This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.", "virtual_table": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["The query is identifying the relevant table, which is 'Faculty'.", "Select the column to display, 'FacID'.", "Add a condition to filter the 'Sex' column for the specified gender using a placeholder for string values."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "description": "This virtual table describes the unique identifiers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.", "virtual_table": "SELECT FacID FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6738", "db_id": "activity_1", "question": "Find the building that has the largest number of faculty members.", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'building' column to display the names of the buildings.", "The results are grouped by 'building' to aggregate the data.", "The query orders the results by the count of faculty members in each building in descending order.", "A limit is applied to restrict the number of buildings returned, using a placeholder for numeric values."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "description": "This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building in descending order, with a limit on the number of buildings returned as specified by the placeholder.", "virtual_table": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6740", "db_id": "activity_1", "question": "In which buildings are there at least ten professors?", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "Select the 'building' column to display the locations of faculty offices.", "Add a condition to filter the 'rank' column for the specified academic rank using a placeholder for string values.", "Group the results by 'building' to aggregate the data based on the location.", "Use the HAVING clause to filter the grouped results to include only those buildings with a count of faculty members greater than or equal to a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT building FROM Faculty WHERE rank  =  'Professor' GROUP BY building HAVING count(*)  >=  10", "source_tables": ["faculty"], "description": "This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.", "virtual_table": "SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'sex' column and counts the number of occurrences for each gender.", "A condition is added to filter the results based on the specified 'rank' using a placeholder for string values.", "The results are grouped by the 'sex' column to provide a count for each gender."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "description": "This virtual table summarizes the count of faculty members by gender from the 'Faculty' table, filtered by a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty members.", "virtual_table": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY sex"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the columns to display, 'fname' and 'lname' from the 'Faculty' table.", "A JOIN operation is performed between 'Faculty' and 'Student' on the condition that the faculty member's ID matches the student's advisor ID.", "Conditions are added to filter the results based on the specified first and last names of the student using placeholders for string values."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "description": "This virtual table describes the first names and last names of faculty members who are academic advisors to a specific student. The placeholders in the WHERE clause represent the first and last names of the student.", "virtual_table": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  [PLACEHOLDER-TYPE:STRING] AND T2.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["The query is identifying the relevant tables, which are 'Faculty' and 'Student'.", "A JOIN operation is performed to connect the 'Faculty' table with the 'Student' table based on the advisor relationship.", "The SELECT statement specifies that we want to retrieve the 'StuID' from the 'Student' table.", "A condition is added to filter faculty members based on their rank using a placeholder for string values."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "description": "This virtual table identifies the unique identifiers of students who are advised by faculty members of a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.", "virtual_table": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the columns to display, 'fname' and 'lname' from the 'Student' table.", "A JOIN operation is performed between 'Faculty' and 'Student' on the advisor relationship.", "Conditions are added to filter the faculty member by their first and last names using placeholders for string values."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "description": "This virtual table describes the first and last names of students who are advised by a specific faculty member. The placeholders in the WHERE clause represent the first and last names of the faculty member.", "virtual_table": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6759", "db_id": "activity_1", "question": "What are the first and last name of the faculty who has the most students?", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Student'.", "It selects the first name and last name of faculty members (aliased as T1) who are advisors to students (aliased as T2).", "A JOIN operation is performed on the Faculty and Student tables using the advisor relationship.", "The results are grouped by the faculty ID to aggregate the number of students each faculty member advises.", "The results are ordered in descending order based on the count of students advised, and a limit is applied to restrict the number of faculty members returned using a placeholder for numeric values."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty", "student"], "description": "This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.", "virtual_table": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6765", "db_id": "activity_1", "question": "What activities do we have?", "rationale": ["The query is identifying the relevant table, which is 'Activity'.", "Select the column to display, 'activity_name'.", "No conditions are applied, so all activity names will be retrieved."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "description": "This virtual table describes the names of activities from the 'Activity' table. The query retrieves all activity names without any filtering conditions.", "virtual_table": "SELECT activity_name FROM Activity"}
{"sample_id": "train.6766", "db_id": "activity_1", "question": "List all the activities we have.", "rationale": ["The query identifies the relevant table, which is 'Activity'.", "Select the column to display, 'activity_name'.", "No filtering conditions are applied, so all activity names will be retrieved."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "description": "This virtual table describes the names of activities from the 'Activity' table. The query retrieves all activity names without any filtering conditions.", "virtual_table": "SELECT activity_name FROM Activity"}
{"sample_id": "train.6780", "db_id": "activity_1", "question": "What is the first and last name of the faculty members who participated in at least one activity? For each of them, also show the number of activities they participated in.", "rationale": ["The query identifies the relevant tables, which are 'Faculty' and 'Faculty_Participates_in'.", "It selects the first name and last name of faculty members from the 'Faculty' table.", "It counts the number of activities each faculty member participates in by using the COUNT function.", "The JOIN operation links the 'Faculty' table with the 'Faculty_Participates_in' table based on the faculty identifier.", "The results are grouped by the unique identifier of each faculty member to aggregate the count of activities."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "description": "This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and the 'Faculty_Participates_in' table, grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.", "virtual_table": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID"}
{"sample_id": "train.6781", "db_id": "activity_1", "question": "Show all the activity names and the number of faculty involved in each activity.", "rationale": ["The query identifies the relevant tables, which are 'Activity' and 'Faculty_Participates_in'.", "It selects the 'activity_name' from the 'Activity' table and counts the number of faculty members participating in each activity.", "The JOIN operation links the two tables based on the activity identifier 'actID'.", "The GROUP BY clause is used to aggregate the results by each activity, allowing for a count of faculty members per activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "description": "This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the SELECT statement represents the activity name, and the count reflects the total number of faculty involved in each activity.", "virtual_table": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID"}
{"sample_id": "train.6782", "db_id": "activity_1", "question": "How many faculty members participate in each activity? Return the activity names and the number of faculty members.", "rationale": ["The query identifies the relevant tables, which are 'Activity' and 'Faculty_Participates_in'.", "It selects the 'activity_name' from the 'Activity' table and counts the number of faculty members participating in each activity.", "The JOIN operation links the two tables based on the activity identifier, ensuring that only relevant records are counted.", "The GROUP BY clause is used to aggregate the results by activity, allowing for a count of faculty members for each distinct activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "description": "This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the SELECT statement represents the activity name, and the count function aggregates the number of faculty members for each activity.", "virtual_table": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["The query is identifying the relevant tables, which are 'Participates_in' and 'Student'.", "The INTERSECT operator is used to find common student IDs from both tables.", "The first SELECT statement retrieves student IDs from the 'Participates_in' table, indicating participation in activities.", "The second SELECT statement retrieves student IDs from the 'Student' table, applying a condition to filter students based on age using a placeholder for numeric values."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "description": "This virtual table identifies students who participate in activities and are younger than a specified age. The placeholder in the WHERE clause represents the age limit for filtering the students.", "virtual_table": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "train.6795", "db_id": "activity_1", "question": "Find the first names of the faculty members who are playing Canoeing or Kayaking.", "rationale": ["The query identifies the relevant tables: 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "It selects distinct last names from the 'Faculty' table.", "The JOIN operations link faculty members to their respective activities through the 'Faculty_Participates_in' table and the 'Activity' table.", "The WHERE clause filters the activities based on their names, using placeholders for the specific activity names."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.", "virtual_table": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6796", "db_id": "activity_1", "question": "Which faculty members are playing either Canoeing or Kayaking? Tell me their first names.", "rationale": ["The query identifies the relevant tables: 'Faculty', 'Faculty_Participates_in', and 'Activity'.", "It selects distinct last names from the 'Faculty' table.", "The JOIN operations link faculty members to their respective activities through the 'Faculty_Participates_in' table and the 'Activity' table.", "The WHERE clause filters the results based on the specified activity names using placeholders for string values."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The query joins the 'Faculty' table with the 'Faculty_Participates_in' table to link faculty members to their activities, and then further joins with the 'Activity' table to filter based on the names of the activities. The placeholders in the WHERE clause represent the names of the activities of interest.", "virtual_table": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["The query identifies the relevant table, which is 'Faculty'.", "It selects the 'lname' column to display the last names of faculty members.", "A condition is added to filter faculty members based on their 'rank' using a placeholder for string values.", "The EXCEPT clause is used to exclude faculty members who participate in activities, which is determined by joining the 'Faculty' table with 'Faculty_Participates_in' and 'Activity' tables.", "The activities to be excluded are specified using placeholders for string values in the WHERE clause."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "description": "This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.", "virtual_table": "SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["The query is identifying the relevant tables, which are 'Participates_in' and 'Activity'.", "It selects the 'stuid' column from the 'Participates_in' table.", "The query uses a JOIN to connect 'Participates_in' with 'Activity' based on the 'actid'.", "It filters the results based on the 'activity_name' for two different activities using placeholders.", "The INTERSECT operator is used to find students who participate in both activities."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "description": "This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clauses represent the names of the activities being queried.", "virtual_table": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the condition that 'MakeId' from 'car_names' matches 'Id' from 'cars_data'.", "The results are ordered by the 'horsepower' column from 'cars_data' in ascending order.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table lists the car models from the 'car_names' table, ordered by their horsepower in ascending order. The placeholder in the LIMIT clause represents the maximum number of car models to be displayed.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.97", "db_id": "car_1", "question": "Find the model of the car whose weight is below the average weight.", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'model' column from the 'car_names' table.", "A JOIN operation is performed between 'car_names' and 'cars_data' on the 'MakeId' and 'Id' columns to link car models with their respective data.", "A condition is added to filter the results where the weight of the cars is less than the average weight calculated from the 'cars_data' table using a subquery."], "gold_sql": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "source_tables": ["car_names", "cars_data"], "description": "The virtual table describes the car models from the 'car_names' table that have a weight less than the average weight of all cars in the 'cars_data' table. The query uses a subquery to calculate the average weight, ensuring that only lighter models are selected.", "virtual_table": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["The query identifies the relevant tables, which are 'cars_data' and 'car_names'.", "It selects the 'Accelerate' column from the 'cars_data' table.", "A JOIN operation is performed to link 'cars_data' with 'car_names' based on the matching 'Id' and 'MakeId'.", "A condition is added to filter the results based on the specified car make using a placeholder for string values."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "description": "The virtual table describes the acceleration times of cars from the 'cars_data' table, filtered by a specific car make from the 'car_names' table. The placeholder in the WHERE clause represents the name of the car make.", "virtual_table": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.112", "db_id": "car_1", "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?", "rationale": ["The query identifies the relevant tables, 'cars_data' and 'car_names'.", "It selects the 'Accelerate' column from the 'cars_data' table.", "A JOIN operation is performed between 'cars_data' and 'car_names' on the 'Id' and 'MakeId' columns to link car entries with their respective makes.", "A condition is added to filter the results based on the car make using a placeholder for string values."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "description": "This virtual table provides the acceleration times of cars from the 'cars_data' table, specifically focusing on the time taken to accelerate from 0 to 60 mph. The data is filtered based on the car make, which is specified by a placeholder in the WHERE clause.", "virtual_table": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["The query identifies the relevant tables, which are 'car_makers' and 'countries'.", "It uses a JOIN operation to connect these tables based on the country identifier.", "The SELECT statement counts the number of car makers that match the specified country name using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "description": "This virtual table provides the count of car makers based in a specific country. It joins the 'car_makers' table with the 'countries' table using the country identifier, and filters the results based on the specified country name.", "virtual_table": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.121", "db_id": "car_1", "question": "What are all the makers and models?", "rationale": ["The query identifies the relevant table, which is 'model_list'.", "Select the columns to display, 'Maker' and 'Model'.", "This query provides a list of car makers along with their corresponding car models without any filtering conditions."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "description": "The virtual table describes the relationship between car makers and their respective car models from the 'model_list' table. The placeholders represent the identifiers for the car makers and models.", "virtual_table": "SELECT Maker ,  Model FROM MODEL_LIST;"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["The query identifies the relevant tables: 'countries', 'continents', and 'car_makers'.", "It selects the 'CountryName' from the 'countries' table.", "The JOIN operation connects 'countries' with 'continents' based on the continent identifier, allowing filtering by continent.", "Another JOIN connects 'countries' with 'car_makers' to ensure that only countries with car makers are included.", "The GROUP BY clause groups the results by 'CountryName' to aggregate the data.", "The HAVING clause filters the grouped results to include only those countries that have a count of car makers greater than or equal to a specified number."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "description": "This virtual table lists the names of countries from the 'countries' table that belong to a specific continent. It joins the 'continents' table to filter countries by continent and the 'car_makers' table to ensure that the countries have associated car makers. The placeholders in the WHERE clause represent the continent's name and the minimum count of car makers per country.", "virtual_table": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.CountryName HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.130", "db_id": "car_1", "question": "What are the names of all European countries with at least 3 manufacturers?", "rationale": ["The query identifies the relevant tables: 'countries', 'continents', and 'car_makers'.", "It selects the 'CountryName' from the 'countries' table.", "The JOIN operation connects 'countries' with 'continents' based on the continent identifier to filter by a specific continent.", "Another JOIN connects 'countries' with 'car_makers' to ensure that only countries with car makers are included.", "The GROUP BY clause is used to group the results by 'CountryName'.", "The HAVING clause filters the grouped results to include only those countries that have a count of car makers greater than or equal to a specified number."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "description": "This virtual table lists the names of countries from the 'countries' table that belong to a specific continent. It joins the 'continents' table to filter countries by continent and the 'car_makers' table to ensure that the countries have associated car makers. The placeholders in the WHERE clause represent the continent's name and the minimum count of car makers per country.", "virtual_table": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.CountryName HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Make' from 'car_names' and 'horsepower' from 'cars_data'.", "A JOIN operation is performed on 'MakeId' from 'car_names' and 'Id' from 'cars_data' to combine the data.", "A condition is added to filter the results based on the number of cylinders using a placeholder for numeric values.", "The results are ordered by 'horsepower' in descending order to show the most powerful cars first.", "A LIMIT clause is included to restrict the number of results returned, using another placeholder for numeric values."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table provides a list of car makes along with their horsepower from the 'car_names' and 'cars_data' tables. The results are filtered to include only those cars with a specific number of cylinders, represented by a placeholder for numeric values. The output is ordered by horsepower in descending order, and the number of results returned is limited by another numeric placeholder.", "virtual_table": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.141", "db_id": "car_1", "question": "Which model has the most version(make) of cars?", "rationale": ["The query identifies the relevant table, which is 'car_names'.", "It selects the 'Model' column to display the names of car models.", "The results are grouped by 'Model' to aggregate the data based on unique model names.", "The query orders the results by the count of each model in descending order to show the most common models first.", "Finally, it limits the output to a specified number of top models using a placeholder for numeric values."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "description": "The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of top models. The placeholder in the LIMIT clause represents the maximum number of models to return.", "virtual_table": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.142", "db_id": "car_1", "question": "What model has the most different versions?", "rationale": ["The query identifies the relevant table, which is 'car_names'.", "Select the 'Model' column to display the car models.", "Group the results by 'Model' to aggregate the data based on unique car models.", "Order the results by the count of each model in descending order to show the most common models first.", "Limit the output to a specified number of results using a placeholder for numeric values."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "description": "The virtual table describes the car models from the 'car_names' table, grouped by model name. It orders the results by the count of occurrences of each model in descending order and limits the output to a specified number of results. The placeholder in the LIMIT clause represents the maximum number of models to return.", "virtual_table": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["The query identifies the relevant tables, which are 'car_makers' and 'model_list'.", "It selects the 'FullName' and 'Id' columns from the 'car_makers' table.", "A JOIN operation is performed between 'car_makers' and 'model_list' on the 'Id' and 'Maker' columns respectively to associate car makers with their models.", "The results are grouped by the 'Id' of the car makers to aggregate the number of models each maker has.", "The HAVING clause is used to filter the grouped results to include only those car makers that have produced more than a specified number of models, using a placeholder for numeric values."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "description": "This virtual table provides a list of car makers along with their unique identifiers from the 'car_makers' table. It filters the results to include only those car makers that have produced more than a specified number of car models, as indicated by the placeholder in the HAVING clause.", "virtual_table": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.161", "db_id": "car_1", "question": "How many countries has more than 2 car makers ?", "rationale": ["The query identifies the relevant tables, which are 'countries' and 'car_makers'.", "It performs a join operation on the 'countryid' from 'countries' and 'country' from 'car_makers' to associate car makers with their respective countries.", "The count of car makers is calculated for each country using the COUNT function.", "The results are grouped by 'countryid' to aggregate the counts per country.", "A HAVING clause is added to filter the results, only including countries that have more than a specified number of car makers, represented by a placeholder for numeric values."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "description": "This virtual table provides a count of car makers grouped by their respective countries from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers that must be associated with a country for it to be included in the results.", "virtual_table": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["The query identifies the relevant tables, 'car_names' and 'cars_data'.", "It selects the 'Model' column from the 'car_names' table.", "A join is performed between 'car_names' and 'cars_data' on the 'MakeId' and 'Id' columns to combine relevant data.", "A condition is added to filter the results based on the number of cylinders using a placeholder for numeric values.", "The results are ordered by the 'horsepower' column in descending order to show the most powerful cars first.", "A limit is applied to restrict the number of results returned, using another placeholder for numeric values."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "description": "This virtual table lists the car models from the 'car_names' table that have a specific number of cylinders. The results are ordered by the horsepower of the cars in descending order, and the number of results returned is limited by a placeholder value.", "virtual_table": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.horsepower DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.171", "db_id": "car_1", "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?", "rationale": ["The query identifies the relevant tables: 'model_list', 'car_names', 'cars_data', and 'car_makers'.", "It selects distinct car models from the 'model_list' table.", "The JOIN operations link the tables based on their relationships, ensuring that the correct models are associated with their respective car data and makers.", "A condition is added to filter the results based on the weight of the cars, using a placeholder for numeric values.", "Another condition excludes car makers based on their full name, using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';", "source_tables": ["car_makers", "model_list", "car_names", "cars_data"], "description": "This virtual table provides a list of distinct car models from the 'model_list' table that meet specific criteria. It filters the results based on the weight of the cars from the 'cars_data' table, ensuring that only cars lighter than a specified weight are included. Additionally, it excludes car makers based on their full name from the 'car_makers' table, allowing users to focus on models from specific manufacturers. The placeholders in the WHERE clause represent the maximum weight and the name of the car maker to exclude.", "virtual_table": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  [PLACEHOLDER-TYPE:NUMBER] AND T4.FullName != [PLACEHOLDER-TYPE:STRING];"}
{"sample_id": "dev.175", "db_id": "car_1", "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .", "rationale": ["The query starts by selecting the 'id' and 'maker' from the 'car_makers' table, aliased as t1.", "It joins the 'model_list' table, aliased as t2, on the condition that the 'id' from 'car_makers' matches the 'maker' in 'model_list'.", "The results are grouped by 'id' and filtered using the HAVING clause to ensure that the count of models is greater than or equal to a specified number, represented by a placeholder.", "The second part of the query performs a similar operation but includes an additional join with the 'car_names' table, aliased as t3, to ensure that the models are associated with specific car names.", "Again, the results are grouped by 'id' and filtered with a HAVING clause to ensure that the count of names is greater than a specified number, also represented by a placeholder.", "The use of INTERSECT ensures that only car makers meeting both criteria are included in the final result."], "gold_sql": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "description": "This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.", "virtual_table": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["The query identifies the relevant tables, which are 'CAR_MAKERS', 'MODEL_LIST', and 'CAR_NAMES'.", "It selects the 'Id' and 'Maker' from 'CAR_MAKERS' and joins it with 'MODEL_LIST' to count the number of models for each maker.", "The first part of the query uses a HAVING clause to filter makers with a count of models greater than or equal to a specified number.", "The second part of the query intersects with another selection that counts the number of car names associated with the models, filtering those with a count greater than a specified number."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "description": "This virtual table identifies car makers who have produced a significant number of car models, as well as those who have a specific number of car names associated with their models. The placeholders in the HAVING clauses represent the minimum counts of models and names, respectively.", "virtual_table": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER];"}
{"sample_id": "dev.526", "db_id": "student_transcripts_tracking", "question": "What are the names and ids of every course with less than 2 sections?", "rationale": ["The query identifies the relevant tables, which are 'Courses' and 'Sections'.", "It selects the 'course_name' and 'course_id' from the 'Courses' table, aliased as T1.", "A JOIN operation is performed between 'Courses' and 'Sections' on the 'course_id' to link courses with their sections.", "The results are grouped by 'course_id' to aggregate the sections for each course.", "The HAVING clause is used to filter the results based on the count of sections, using a placeholder for the maximum number of sections."], "gold_sql": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2", "source_tables": ["courses", "sections"], "description": "This virtual table provides a list of course names and their corresponding identifiers from the 'Courses' table, specifically for those courses that have a number of sections less than or equal to a specified threshold. The placeholder in the HAVING clause represents the maximum number of sections allowed for the courses listed.", "virtual_table": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.534", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?", "rationale": ["The query identifies the relevant tables, 'Students' and 'Student_Enrolment'.", "It selects the columns to display: 'first_name', 'middle_name', 'last_name', and 'student_id' from the 'Students' table.", "The JOIN operation is used to link 'Students' with 'Student_Enrolment' based on the 'student_id'.", "The GROUP BY clause is applied to group the results by 'student_id'.", "The HAVING clause filters the results to include only those students who are enrolled in a specific number of courses, represented by a placeholder for numeric values."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "description": "This virtual table provides the first name, middle name, last name, and student ID of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.", "virtual_table": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.535", "db_id": "student_transcripts_tracking", "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.", "rationale": ["The query identifies the relevant tables: 'Students', 'Student_Enrolment', and 'Degree_Programs'.", "It selects distinct names (first, middle, last) from the 'Students' table.", "The JOIN operations link the 'Students' table to 'Student_Enrolment' and then to 'Degree_Programs' based on their respective identifiers.", "A condition is added to filter the results based on the specified degree program name using a placeholder for string values."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "description": "This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["The query identifies the relevant tables, 'Degree_Programs' and 'Student_Enrolment'.", "It selects the degree program ID and name from the 'Degree_Programs' table.", "A JOIN operation is performed between 'Degree_Programs' and 'Student_Enrolment' on the degree program ID to link degree programs with their enrolled students.", "The results are grouped by the degree program ID to aggregate the count of students enrolled in each program.", "The results are ordered by the count of students in descending order to show the most popular programs first.", "A LIMIT clause is added to restrict the number of results returned based on a placeholder for numeric values."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "description": "This virtual table provides a list of degree programs along with their unique identifiers from the 'Degree_Programs' table. It joins with the 'Student_Enrolment' table to count how many students are enrolled in each degree program. The results are grouped by the degree program ID and ordered by the number of students enrolled in descending order, with a limit on the number of results returned based on a specified number.", "virtual_table": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["The query identifies the relevant tables, 'Students' and 'Student_Enrolment'.", "It selects the student ID, first name, middle name, and last name from the 'Students' table.", "It counts the number of courses each student is enrolled in by joining 'Students' with 'Student_Enrolment' on the student ID.", "The results are grouped by the student ID to aggregate the course counts.", "Finally, the results are ordered by the count of courses in descending order, and a placeholder is used in the LIMIT clause to specify how many results to return."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "description": "This virtual table provides a list of students along with their first, middle, and last names, and the count of courses they are enrolled in. The results are grouped by each student's unique identifier and ordered by the number of courses in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.", "virtual_table": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Enrolment_Courses'.", "It selects the 'course_name' from the 'Courses' table.", "A JOIN operation is performed between 'Courses' and 'Student_Enrolment_Courses' on the 'course_id' to link courses with their enrolments.", "The results are grouped by 'course_name' to aggregate the data based on course popularity.", "The results are ordered by the count of enrolments in descending order to show the most popular courses first.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "description": "This virtual table provides a list of course names from the 'Courses' table that are associated with student enrolments. The results are grouped by course name and ordered by the number of enrolments in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of course names to return.", "virtual_table": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.548", "db_id": "student_transcripts_tracking", "question": "What is the name of the course with the most students enrolled?", "rationale": ["The query identifies the relevant tables, 'Courses' and 'Student_Enrolment_Courses'.", "It selects the 'course_name' from the 'Courses' table.", "A JOIN operation is performed to link 'Courses' with 'Student_Enrolment_Courses' based on the course identifier.", "The results are grouped by 'course_name' to aggregate enrolment counts.", "The results are ordered by the count of enrolments in descending order to highlight the most popular courses.", "A LIMIT clause is added to restrict the number of results returned, using a placeholder for numeric values."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "description": "This virtual table provides a list of course names from the 'Courses' table that are associated with student enrolments. The results are grouped by course name and ordered by the number of enrolments in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of course names to return.", "virtual_table": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["The query identifies the relevant tables, which are 'Students' and 'Addresses'.", "It selects the 'last_name' column from the 'Students' table.", "A JOIN is performed between 'Students' and 'Addresses' on the 'current_address_id' to filter students based on their current address.", "A WHERE clause is added to filter the results based on the 'state_province_county' of the address using a placeholder for string values.", "An EXCEPT clause is used to exclude students who are enrolled in any degree program by joining 'Students' with 'Student_Enrolment' and selecting distinct last names."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "description": "This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.", "virtual_table": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["The query identifies the relevant table, which is 'Students'.", "Select the column to display, 'cell_mobile_number'.", "Add conditions to filter the 'first_name' and 'last_name' columns for the specified student using placeholders for string values."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "description": "This virtual table provides the mobile phone numbers of students from the 'Students' table based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.", "virtual_table": "select cell_mobile_number from students where first_name  =  [PLACEHOLDER-TYPE:STRING] and last_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["The query identifies the relevant tables, 'Addresses' and 'Students'.", "It selects the 'address_id', 'line_1', and 'line_2' columns from the 'Addresses' table.", "A JOIN operation is performed to link 'Addresses' with 'Students' based on the current address ID.", "The results are grouped by 'address_id' to ensure uniqueness of addresses.", "The results are ordered by the count of students associated with each address in descending order.", "A LIMIT clause is added to restrict the number of results based on a placeholder for numeric values."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "description": "This virtual table provides a list of unique addresses that are currently associated with students, including the address ID and primary and secondary address lines. The results are grouped by address ID and ordered by the number of students linked to each address, with a limit on the number of addresses returned based on a specified numeric value.", "virtual_table": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.578", "db_id": "student_transcripts_tracking", "question": "What are the different addresses that have students living there?", "rationale": ["The query is identifying the relevant table, which is 'Students'.", "The goal is to count the distinct current addresses, so the COUNT function is used with DISTINCT on the 'current_address_id' column."], "gold_sql": "SELECT count(DISTINCT current_address_id) FROM Students", "source_tables": ["students"], "description": "This virtual table provides the count of distinct current addresses associated with students from the 'Students' table. The placeholder in the SELECT clause represents the unique current address identifiers.", "virtual_table": "SELECT count(DISTINCT current_address_id) FROM Students"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The query identifies the relevant table, which is 'Sections'.", "Select the column to display, 'section_description'.", "Add a condition to filter the 'section_name' column for the specified section using a placeholder for string values."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "description": "This virtual table provides the description of a specific section from the 'Sections' table based on the section's name. The placeholder in the WHERE clause represents the name of the section being queried.", "virtual_table": "SELECT section_description FROM Sections WHERE section_name  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects a count of all entries in the table.", "A condition is added to filter the results based on the 'GovernmentForm' column using a placeholder for string values."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "description": "This virtual table provides the count of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.", "virtual_table": "SELECT count(*) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.723", "db_id": "world_1", "question": "How many people live in Asia, and what is the largest GNP among them?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'Population' column and the maximum value of the 'GNP' column to provide aggregate data.", "A condition is added to filter the results based on the 'Continent' column using a placeholder for string values."], "gold_sql": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  'Asia'", "source_tables": ["country"], "description": "This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.", "virtual_table": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.724", "db_id": "world_1", "question": "What is the average life expectancy in African countries that are republics?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the average of the 'LifeExpectancy' column to compute the average life expectancy.", "Conditions are added to filter the results based on the specified continent and government form using placeholders for string values."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "description": "This virtual table calculates the average life expectancy of countries from the 'country' table that are located in a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and the government form.", "virtual_table": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.725", "db_id": "world_1", "question": "Give the average life expectancy for countries in Africa which are republics?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the average of the 'LifeExpectancy' column to compute the average life expectancy.", "Conditions are added to filter the results based on the specified continent and government form using placeholders for string values."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "description": "This virtual table calculates the average life expectancy of countries from the 'country' table that belong to a specific continent and have a particular form of government. The placeholders in the WHERE clause represent the continent and government form criteria.", "virtual_table": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING] AND GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.731", "db_id": "world_1", "question": "Give the mean GNP and total population of nations which are considered US territory.", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the average GNP and the sum of the population columns to provide aggregate data.", "A condition is added to filter the results based on the 'GovernmentForm' column using a placeholder for string values."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "description": "This virtual table calculates the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.", "virtual_table": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the count of distinct values in the 'GovernmentForm' column.", "A condition is added to filter the results based on the 'Continent' column using a placeholder for string values."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "description": "This virtual table provides the count of distinct government forms present in countries located within a specific continent. The placeholder in the WHERE clause represents the continent's name.", "virtual_table": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.754", "db_id": "world_1", "question": "What are the countries where either English or Dutch is the official language ?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the 'name' column from the 'country' table.", "The join condition links the 'country' table with the 'countrylanguage' table based on the country code.", "The WHERE clause filters the results to include only those countries where the specified language is spoken and is marked as official, using placeholders for both the language and its official status."], "gold_sql": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'english' and isofficial  =  't' union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'dutch' and isofficial  =  't'", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.", "virtual_table": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING] union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It performs a JOIN operation on these tables using the country code to combine related data.", "The WHERE clause filters the results based on the specified language and its official status, using placeholders for these values.", "The UNION operator is used to combine results from two similar queries, allowing for flexibility in the language and official status criteria."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a comprehensive view of countries and their languages by joining the 'country' and 'countrylanguage' tables. It filters the results to show only those countries where a specific language is spoken, and whether that language is official or not. The placeholders in the WHERE clause represent the language name and its official status.", "virtual_table": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] AND IsOfficial  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] AND IsOfficial  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.758", "db_id": "world_1", "question": "Which languages are spoken by only one country in republic governments?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It performs a JOIN operation on the country code to link the two tables.", "The SELECT statement retrieves the 'Language' from the 'countrylanguage' table.", "A condition is added to filter countries based on their government form using a placeholder for string values.", "The results are grouped by language, and a HAVING clause is used to filter languages that are spoken in a specific number of countries, using a placeholder for numeric values."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "description": "This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.", "virtual_table": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.759", "db_id": "world_1", "question": "What languages are only used by a single country with a republic government?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It performs a JOIN operation on the country code to link the two tables.", "The WHERE clause filters the countries based on a specific government form using a placeholder for string values.", "The GROUP BY clause groups the results by language to aggregate the data.", "The HAVING clause ensures that only languages spoken in a specified number of countries are included, using a placeholder for numeric values."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "description": "This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. It filters the results to include only those countries with a specified government form and groups the results by language, ensuring that only languages spoken in a certain number of countries are included. The placeholders in the WHERE and HAVING clauses represent the government form and the count of countries, respectively.", "virtual_table": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.760", "db_id": "world_1", "question": "Find the city with the largest population that uses English.", "rationale": ["The query identifies the relevant tables, 'city' and 'countrylanguage'.", "It selects the 'Name' and 'Population' columns from the 'city' table (aliased as T1).", "A JOIN operation is performed between 'city' and 'countrylanguage' on the 'CountryCode' to link cities with their respective languages.", "A condition is added to filter the results based on the specified language using a placeholder for string values.", "The results are ordered by the 'Population' column in descending order, and a limit is set to control the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  'English' ORDER BY T1.Population DESC LIMIT 1", "source_tables": ["city", "countrylanguage"], "description": "This virtual table provides the names and populations of cities from the 'city' table that have a specific language spoken, as indicated in the 'countrylanguage' table. The placeholder in the WHERE clause represents the language of interest, while the LIMIT placeholder allows for specifying the maximum number of results to return, sorted by population in descending order.", "virtual_table": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It uses the SUM function to calculate the total population of countries.", "A subquery is included to filter out countries that have the specified language as an official language.", "The placeholder in the subquery represents the language name that is being checked against the countries."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "description": "This virtual table calculates the total population of countries that do not have a specific language as an official language. The placeholder in the subquery represents the language name that is being checked against the countries.", "virtual_table": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.774", "db_id": "world_1", "question": "What are the African countries that have a  population less than any country in Asia?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the 'Name' column to display the names of the countries.", "A condition is added to filter countries based on the specified continent using a placeholder for string values.", "Another condition is included to ensure the population of the country is less than the maximum population of any country in the same continent, which is determined by a subquery."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Africa'  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  'Asia')", "source_tables": ["country"], "description": "This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.", "virtual_table": "SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.777", "db_id": "world_1", "question": "What are the Asian countries which have a population larger than that of any country in Africa?", "rationale": ["The query identifies the relevant table, which is 'country'.", "Select the column to display, 'Name', which represents the country's name.", "Add conditions to filter the 'Continent' column for the specified continent using a placeholder for string values.", "Include a subquery to find the minimum population of countries within the same continent, ensuring that only countries with a greater population are selected."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Asia'  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  'Africa')", "source_tables": ["country"], "description": "This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.", "virtual_table": "SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])"}
{"sample_id": "dev.778", "db_id": "world_1", "question": "What are the country codes for countries that do not speak English?", "rationale": ["The query is identifying the relevant table, which is 'countrylanguage'.", "Select the 'CountryCode' column to display the country codes.", "Use the EXCEPT clause to exclude country codes where the specified language is an official language, using a placeholder for string values in the WHERE clause."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "description": "This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.", "virtual_table": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.786", "db_id": "world_1", "question": "Which unique cities are in Asian countries where Chinese is the official language ?", "rationale": ["The query identifies the relevant tables: 'country', 'countrylanguage', and 'city'.", "It uses JOIN operations to connect these tables based on their foreign key relationships, specifically linking country codes.", "The SELECT statement retrieves distinct city names from the 'city' table.", "The WHERE clause applies filters to ensure that only cities from countries where a specified language is official, and that belong to a specified continent, are included. Placeholders are used for the official status of the language, the language name, and the continent."], "gold_sql": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  't' and t2.language  =  'chinese' and t1.continent  =  'asia'", "source_tables": ["country", "city", "countrylanguage"], "description": "This virtual table provides a list of distinct city names from the 'city' table that are located in countries where a specific language is spoken officially. The query filters based on whether the language is official, the name of the language, and the continent the country belongs to, using placeholders for these criteria.", "virtual_table": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  [PLACEHOLDER-TYPE:STRING] and t2.language  =  [PLACEHOLDER-TYPE:STRING] and t1.continent  =  [PLACEHOLDER-TYPE:STRING]"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["The query identifies the relevant table, which is 'country'.", "Select the columns to display: 'Name', 'SurfaceArea', and 'IndepYear'.", "Order the results by the 'Population' column to sort countries based on their population size.", "Limit the number of results returned using a placeholder for numeric values."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "description": "This virtual table provides a list of countries, displaying their names, surface areas, and the year they gained independence. The results are ordered by the population of the countries, and the number of entries returned is limited by a specified placeholder for numeric values.", "virtual_table": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["The query identifies the relevant tables, which are 'country' and 'countrylanguage'.", "It selects the count of languages (T2.Language) and the name of the country (T1.Name).", "A JOIN operation is performed on the country code to link the two tables.", "The results are grouped by the country's name to aggregate the language counts.", "A HAVING clause is used to filter the results to include only those countries with a language count greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "description": "This virtual table provides a count of languages spoken in each country from the 'country' table, along with the country's name. The query filters the results to only include countries where the number of languages spoken exceeds a specified threshold, represented by a placeholder for numeric values.", "virtual_table": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["The query identifies the relevant table, which is 'country'.", "It selects the sum of the 'Population' column and the 'GovernmentForm' column.", "The results are grouped by 'GovernmentForm' to aggregate the population for each type of government.", "A condition is added to filter the results using the HAVING clause, which checks if the average 'LifeExpectancy' is greater than a specified number, using a placeholder for numeric values."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "description": "This virtual table summarizes the total population of countries grouped by their government form, filtering for those government forms where the average life expectancy exceeds a specified threshold. The placeholder in the HAVING clause represents the minimum average life expectancy value.", "virtual_table": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["The query is identifying the relevant table, which is 'city'.", "Select the column to display, 'name'.", "Add a condition to filter the 'Population' column for values between the specified range using placeholders for numeric values."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "description": "This virtual table describes the names of cities from the 'city' table that have a population within a specified range. The placeholders in the WHERE clause represent the lower and upper limits of the population range.", "virtual_table": "SELECT name FROM city WHERE Population BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.820", "db_id": "world_1", "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?", "rationale": ["The query identifies the relevant table, which is 'countrylanguage'.", "Select the 'CountryCode' and the maximum 'Percentage' of speakers for the specified language.", "Add a condition to filter the 'Language' column for the specified language using a placeholder for string values.", "Group the results by 'CountryCode' to get the maximum percentage of speakers for each country."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "description": "This virtual table provides the country codes and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name that the user wants to query.", "virtual_table": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode"}
{"sample_id": "dev.821", "db_id": "world_1", "question": "Return the codes of countries for which Spanish is the predominantly spoken language.", "rationale": ["The query identifies the relevant table, which is 'countrylanguage'.", "Select the 'CountryCode' and the maximum 'Percentage' of speakers for the specified language.", "Add a condition to filter the 'Language' column for the specified language using a placeholder for string values.", "Group the results by 'CountryCode' to aggregate the maximum percentage of speakers for each country."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "description": "This virtual table provides the country codes and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.", "virtual_table": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode"}
{"sample_id": "dev.920", "db_id": "dog_kennels", "question": "What is the average age of the dogs who have gone through any treatments?", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects the average age of dogs using the AVG function.", "The WHERE clause filters the dogs to include only those that have treatment records by using a subquery that selects dog_ids from the 'Treatments' table."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "description": "This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause allows for filtering based on specific dog identifiers that have treatment records.", "virtual_table": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )"}
{"sample_id": "dev.936", "db_id": "dog_kennels", "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.", "rationale": ["The query identifies the relevant tables: 'Owners', 'Dogs', and 'Treatments'.", "It selects the 'owner_id' and 'last_name' from the 'Owners' table, using an alias for clarity.", "The JOIN operation links 'Owners' to 'Dogs' based on the 'owner_id', and then links 'Dogs' to 'Treatments' based on 'dog_id'.", "The GROUP BY clause groups the results by 'owner_id' to aggregate the number of treatments per owner.", "The ORDER BY clause sorts the results by the count of treatments in descending order, ensuring that owners with the most treatments appear first.", "The LIMIT clause uses a placeholder to allow the user to specify how many owners to return."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "description": "This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.", "virtual_table": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["The query identifies the relevant tables, which are 'Professionals' and 'Treatments'.", "It selects the 'professional_id' and 'cell_number' from the 'Professionals' table.", "A JOIN operation is performed between 'Professionals' and 'Treatments' on the 'professional_id' to link treatments to the professionals who administered them.", "The results are grouped by 'professional_id' to aggregate the treatment counts for each professional.", "The HAVING clause filters the results to include only those professionals who have administered a specified minimum number of treatments, using a placeholder for numeric values."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "description": "This virtual table provides a list of professionals along with their cell numbers who have administered a minimum number of treatments. The placeholder in the HAVING clause represents the minimum count of treatments that a professional must have administered to be included in the results.", "virtual_table": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]"}
{"sample_id": "dev.944", "db_id": "dog_kennels", "question": "What are the first name and last name of the professionals who have done treatment with cost below average?", "rationale": ["The query identifies the relevant tables, which are 'Professionals' and 'Treatments'.", "It selects distinct first and last names from the 'Professionals' table.", "A join is performed between 'Professionals' and 'Treatments' to link professionals with the treatments they administered.", "A condition is added to filter treatments where the cost is less than the average cost of treatments, calculated using a subquery."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "description": "This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The query joins the 'Professionals' table with the 'Treatments' table to filter based on treatment costs, using a subquery to calculate the average treatment cost.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["The query identifies the relevant tables, which are 'Owners' and 'Dogs'.", "It selects the columns 'first_name' and 'last_name' from the 'Owners' table (aliased as T1) and 'size_code' from the 'Dogs' table (aliased as T2).", "The JOIN operation is used to link the two tables on the 'owner_id' column, ensuring that only the owners of the dogs are included in the results."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "description": "This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' and 'Dogs' tables, linking them through the owner_id. The placeholders in the SELECT statement allow for dynamic querying of owner names and their corresponding dog's size category.", "virtual_table": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id"}
{"sample_id": "dev.951", "db_id": "dog_kennels", "question": "What are each owner's first name, last name, and the size of their dog?", "rationale": ["The query identifies the relevant tables, which are 'Owners' and 'Dogs'.", "It selects the columns 'first_name' and 'last_name' from the 'Owners' table (aliased as T1) and 'size_code' from the 'Dogs' table (aliased as T2).", "A JOIN operation is performed on the 'owner_id' to link the two tables, allowing for the retrieval of owner information alongside their dog's size code."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "description": "This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the specific values that can be modified to filter or retrieve specific information about owners and their dogs.", "virtual_table": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["The query identifies the relevant tables, which are 'Dogs' and 'Treatments'.", "It selects distinct values for the 'date_arrived' and 'date_departed' columns from the 'Dogs' table.", "A JOIN operation is performed on the 'dog_id' to link the 'Dogs' table with the 'Treatments' table, ensuring that only dogs with treatments are included."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "description": "This virtual table provides a list of unique arrival and departure dates for dogs from the 'Dogs' table, along with their associated treatments from the 'Treatments' table. The placeholders in the JOIN clause represent the relationships between the dogs and their treatments.", "virtual_table": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id"}
{"sample_id": "dev.961", "db_id": "dog_kennels", "question": "Who owns the youngest dog? Give me his or her last name.", "rationale": ["The query identifies the relevant tables, which are 'Owners' and 'Dogs'.", "It selects the 'last_name' column from the 'Owners' table.", "A JOIN operation is performed between 'Owners' and 'Dogs' on the 'owner_id' to link owners with their dogs.", "A subquery is used to find the maximum age of dogs in the 'Dogs' table, which is then used to filter the results in the WHERE clause."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "description": "This virtual table provides the last names of owners who own the oldest dog in the database. It joins the 'Owners' table with the 'Dogs' table based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.", "virtual_table": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["The query identifies the relevant table, which is 'Dogs'.", "It selects distinct values for 'breed_code' and 'size_code' to ensure that each combination is unique.", "The use of DISTINCT ensures that duplicate entries are not included in the result set."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "description": "This virtual table provides a unique list of breed codes and size codes from the 'Dogs' table. The placeholders represent the breed and size categories associated with the dogs.", "virtual_table": "SELECT DISTINCT breed_code ,  size_code FROM dogs"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["The query identifies the relevant tables: 'professionals', 'Treatments', and 'Treatment_Types'.", "It selects distinct first names from the 'professionals' table and the treatment type descriptions from the 'Treatment_Types' table.", "The JOIN operations link the 'professionals' table to the 'Treatments' table using the 'professional_id', and the 'Treatments' table to the 'Treatment_Types' table using the 'treatment_type_code'.", "The use of DISTINCT ensures that only unique combinations of professional first names and treatment type descriptions are returned."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "description": "This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The placeholders in the query allow for filtering or further specification of the professionals or treatment types if needed.", "virtual_table": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code"}
