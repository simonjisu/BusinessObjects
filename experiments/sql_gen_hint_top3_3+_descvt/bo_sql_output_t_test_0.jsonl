{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["We need to find the IDs of students who have attended courses.", "The relevant table for attendance is 'Student_Course_Attendance', which contains the 'student_id' of students who attended courses.", "To get unique student IDs, we will use the DISTINCT keyword to avoid duplicates in the results."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.68", "db_id": "student_assessment", "question": "What details do we have on the students who registered for courses most recently?", "rationale": ["We need to find details on students who registered for courses most recently.", "To do this, we will join the 'Students' table with the 'Student_Course_Registrations' table to get the registration details.", "Next, we will join with the 'Courses' table to retrieve the course names associated with each registration.", "We will order the results by the 'registration_date' in descending order to get the most recent registrations first.", "Finally, we will limit the results to the top 10 most recent registrations."], "gold_sql": "SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT S.student_id, S.student_details, SCR.registration_date, C.course_name \nFROM Students AS S \nJOIN Student_Course_Registrations AS SCR ON S.student_id = SCR.student_id \nJOIN Courses AS C ON SCR.course_id = C.course_id \nORDER BY SCR.registration_date DESC \nLIMIT 10;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates, Student_Course_Attendance, and Student_Course_Registrations.", "Join the Candidates table with Student_Course_Attendance on candidate_id and student_id to link candidates with their course attendance.", "Join the result with Student_Course_Registrations to ensure we are looking at the correct course registrations.", "Order the results by date_of_attendance in descending order to get the most recent attendance first.", "Limit the results to 1 to get only the most recent candidate who accessed the course."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT DISTINCT c.candidate_id\nFROM Candidates c\nJOIN Student_Course_Attendance sca ON c.candidate_id = sca.student_id\nJOIN Student_Course_Registrations scr ON sca.student_id = scr.student_id AND sca.course_id = scr.course_id\nORDER BY sca.date_of_attendance DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.78", "db_id": "student_assessment", "question": "What are the details of the student who registered for the most number of courses?", "rationale": ["We need to find the details of the student who registered for the most number of courses.", "To do this, we will join the 'Students' table with the 'Student_Course_Registrations' table on the student_id.", "We will group the results by student_id to count the number of courses each student has registered for.", "We will order the results in descending order based on the count of course registrations.", "Finally, we will limit the results to 1 to get the student with the highest number of registrations."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT T1.student_id, T1.student_details \nFROM Students AS T1 \nJOIN Student_Course_Registrations AS T2 ON T1.student_id = T2.student_id \nGROUP BY T1.student_id \nORDER BY COUNT(T2.course_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["Identify the tables involved: Students, Student_Course_Registrations, and Courses.", "Join the Students table with the Student_Course_Registrations table on student_id to link students to their course registrations.", "Join the result with the Courses table on course_id to retrieve course names.", "Use COUNT(*) to count the number of students registered for each course.", "Group the results by course_id to get the count for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT T3.course_name, COUNT(*) AS student_count FROM Students AS T1 JOIN Student_Course_Registrations AS T2 ON T1.student_id = T2.student_id JOIN Courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.89", "db_id": "student_assessment", "question": "What is the id of the student who most recently registered course 301?", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Filter the records in 'Student_Course_Registrations' to only include those with course_id '301'.", "Order the results by 'registration_date' in descending order to get the most recent registration first.", "Limit the results to 1 to get only the most recent student registration for course 301."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.92", "db_id": "student_assessment", "question": "What are the different cities where people live?", "rationale": ["The question asks for different cities where people live, which implies we need to extract unique city names from the database.", "To find the cities, we need to join the 'Addresses' table with the 'People_Addresses' table to link addresses to people.", "Since we are interested in people, we also need to join the 'Students' table to ensure we are only considering registered students.", "Using 'SELECT DISTINCT' will ensure that we only get unique city names in the result set."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id", "source_tables": ["addresses", "people_addresses"], "pred_sql": "SELECT DISTINCT T1.city FROM Addresses AS T1 JOIN People_Addresses AS T2 ON T1.address_id = T2.address_id JOIN Students AS T3 ON T2.person_id = T3.student_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique cities where students are located, by joining the 'Addresses', 'People_Addresses', and 'Students' tables. The placeholders in the query represent the necessary identifiers for the relationships between these tables.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id\"\n    }\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant tables: We need to look at the 'Students' and 'Student_Course_Registrations' tables to find students who registered for a specific course.", "Determine the course: The course we are interested in is 'Statistics'. We will need to find the course_id associated with this course from the 'Courses' table.", "Join the tables: We will join the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations.", "Filter by course: We will filter the results to only include registrations for the course 'Statistics'.", "Order by registration date: Finally, we will order the results by the registration date to get the desired output."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant tables: We need to look at the 'Students' table and the 'Student_Course_Registrations' table to find student registrations.", "Filter for the course: We need to filter the registrations to only include those for the course 'Statistics'.", "Select the student IDs: We will select the 'student_id' from the 'Student_Course_Registrations' table.", "Order by registration date: Finally, we will order the results by the 'registration_date' to get the students in the order they registered."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT T2.student_id FROM Student_Course_Registrations AS T2 JOIN Courses AS T3 ON T2.course_id = T3.course_id WHERE T3.course_name = 'Statistics' ORDER BY T2.registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.387", "db_id": "flight_1", "question": "Show origins of all flights with destination Honolulu.", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their origins and destinations.", "Determine the required columns: We need the 'origin' column for flights that have 'Honolulu' as their destination.", "Construct the SQL query: Use a SELECT statement to retrieve the 'origin' from the 'flight' table where the 'destination' is 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the required columns: We need the 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We want flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query using the SELECT statement to retrieve the specified columns from the 'flight' table with the appropriate WHERE clause."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.400", "db_id": "flight_1", "question": "What are the numbers of the shortest flights?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their distances.", "Determine the requirement: The user wants to find the shortest flights, which means we need to sort the flights by distance.", "Construct the SQL query: We will select the flight number (flno) from the flight table, order the results by distance in ascending order, and limit the results to 1 to get the shortest flight."], "gold_sql": "SELECT flno FROM Flight ORDER BY distance ASC LIMIT 3", "source_tables": ["flight"], "pred_sql": "SELECT flno FROM flight ORDER BY distance ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.408", "db_id": "flight_1", "question": "What place has the most flights coming from there?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their origin.", "Determine the required information: We need to find the place (origin) with the most flights.", "Use the COUNT function to count the number of flights for each origin.", "Group the results by the 'origin' column to aggregate the flight counts.", "Order the results in descending order based on the flight count to get the place with the most flights at the top.", "Limit the results to 1 to get only the top place."], "gold_sql": "SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flight"], "pred_sql": "SELECT origin, COUNT(*) AS flight_count FROM flight GROUP BY origin ORDER BY flight_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables needed: 'aircraft' for aircraft names and 'flight' for flight counts.", "Use a LEFT JOIN to connect 'aircraft' and 'flight' on the aircraft ID (aid) to ensure all aircraft are included, even those with no flights.", "Select the aircraft name from the 'aircraft' table and count the number of flights from the 'flight' table, grouping by aircraft ID to get the count for each aircraft.", "The final SQL query will return the name of each aircraft along with the number of flights it has completed."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT A.name, COUNT(F.flno) AS flight_count \nFROM aircraft AS A \nLEFT JOIN flight AS F ON A.aid = F.aid \nGROUP BY A.aid;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\",\n        \"virtual_table\": \"SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.429", "db_id": "flight_1", "question": "Show names for all employees who do not have certificate of Boeing 737-800.", "rationale": ["Identify the main goal: to find names of employees who do not have a certificate for the Boeing 737-800.", "Use the provided virtual table structure that lists names of employees from the 'employee' table who do not hold a certificate for a specific aircraft model.", "The virtual table uses the EXCEPT clause to exclude names of employees who have a certificate for the specified aircraft.", "Construct the SQL query by selecting names from the 'employee' table and excluding those who have a certificate for 'Boeing 737-800' using the JOINs with 'certificate' and 'aircraft' tables."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT name FROM employee EXCEPT SELECT T1.name FROM employee AS T1 JOIN certificate AS T2 ON T1.eid = T2.eid JOIN aircraft AS T3 ON T3.aid = T2.aid WHERE T3.name = 'Boeing 737-800'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\",\n        \"virtual_table\": \"SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.433", "db_id": "flight_1", "question": "Show the name and distance of the aircrafts with more than 5000 distance and which at least 5 people have its certificate.", "rationale": ["Identify the relevant tables: We need to get information from the 'aircraft' and 'certificate' tables.", "We want to select the 'name' and 'distance' from the 'aircraft' table.", "We need to join the 'aircraft' table with the 'certificate' table on the 'aid' column to link aircraft with their certificates.", "We will group the results by 'aircraft.aid' to count the number of certificates for each aircraft.", "We will use the HAVING clause to filter for aircraft that have more than 5 certificates and a distance greater than 5000."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT T3.name, T3.distance FROM Aircraft AS T3 JOIN Certificate AS T2 ON T3.aid = T2.aid GROUP BY T3.aid HAVING COUNT(T2.eid) > 5 AND T3.distance > 5000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\",\n        \"virtual_table\": \"SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.434", "db_id": "flight_1", "question": "What is the name and distance of every aircraft that can cover a distance of more than 5000 and which at least 5 people can fly?", "rationale": ["Identify the columns needed: 'name' and 'distance' from the 'aircraft' table.", "Set the condition for distance: we need aircraft that can cover more than 5000 miles or kilometers, so we add 'distance > 5000'.", "Next, we need to ensure that at least 5 people can fly, which implies that we need to check the number of flights associated with each aircraft.", "To do this, we can use a subquery that counts the distinct flight numbers ('flno') for each aircraft ID ('aid') in the 'flight' table.", "We group the results by 'aid' and use the HAVING clause to filter for those aircraft that have 5 or more distinct flights.", "Finally, we combine these conditions in the main query to get the desired results."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  5000 GROUP BY T1.aid ORDER BY count(*)  >=  5", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT name, distance FROM aircraft WHERE distance > 5000 AND aid IN (SELECT aid FROM flight GROUP BY aid HAVING COUNT(DISTINCT flno) >= 5)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\",\n        \"virtual_table\": \"SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.437", "db_id": "flight_1", "question": "What is the salary and name of the employee who has the most number of certificates on aircrafts with distance more than 5000?", "rationale": ["Identify the relevant tables: employee, certificate, and aircraft.", "We need to join these tables to get the employee names and their salaries based on the certificates they hold for aircraft with a distance greater than 5000.", "Use JOIN to connect employee and certificate on employee ID (eid), and then connect certificate and aircraft on aircraft ID (aid).", "Filter the results to include only those aircraft where the distance is greater than 5000.", "Group the results by employee ID to count the number of certificates each employee holds.", "Order the results by the count of certificates in descending order to get the employee with the most certificates.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT T1.name, T1.salary FROM employee AS T1 JOIN certificate AS T2 ON T1.eid = T2.eid JOIN aircraft AS T3 ON T3.aid = T2.aid WHERE T3.distance > 5000 GROUP BY T1.eid ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\",\n        \"virtual_table\": \"SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The user wants to know all the different food allergies.", "To find the different food allergies, we need to select the 'Allergy' column from the 'Allergy_Type' table.", "Using 'DISTINCT' ensures that we get unique allergy names without duplicates."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Allergy_Type", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.456", "db_id": "allergy_1", "question": "Which allergy type is most common?", "rationale": ["Identify the relevant tables: We need to look at the 'Has_Allergy' table to see which allergies students have and the 'Allergy_Type' table to categorize these allergies.", "Join the two tables: We will join 'Has_Allergy' with 'Allergy_Type' on the 'Allergy' column to get the allergy types associated with each student.", "Count the occurrences: We will count how many times each allergy type appears by grouping the results by 'AllergyType'.", "Order the results: To find the most common allergy type, we will order the results in descending order based on the count of allergies.", "Limit the results: We only need the top result, so we will limit the output to 1."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(*) as AllergyCount FROM Has_Allergy AS HA JOIN Allergy_Type AS AT ON HA.Allergy = AT.Allergy GROUP BY AllergyType ORDER BY AllergyCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["Identify the goal: We need to find the least common allergy type.", "To find the least common allergy, we can count the occurrences of each allergy in the Has_Allergy table.", "We will group the results by Allergy to get the count of each allergy.", "Next, we will order the results by the count in ascending order to get the least common allergy at the top.", "Finally, we will limit the results to 1 to get only the least common allergy type.", "We will join this result with the Allergy_Type table to get the corresponding AllergyType for the least common allergy."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType FROM Allergy_Type WHERE Allergy IN (SELECT Allergy FROM Has_Allergy GROUP BY Allergy ORDER BY COUNT(*) ASC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "Determine the columns needed to get the full names of students, which are 'Fname' and 'LName'.", "Construct the SQL query to select 'Fname' and 'LName' from the 'Student' table."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname, LName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the relevant table: The 'Student' table contains the information about students, including their gender.", "Determine the condition: We need to filter the students based on their gender, specifically for male students.", "Construct the SQL query: We will select the 'StuID' from the 'Student' table where the 'Sex' column is equal to 'Male'."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the major information, which is the 'Student' table.", "To find the largest major, we need to count the number of students in each major.", "We will use the COUNT function to count the number of students for each major.", "We will group the results by the 'Major' column to get the count for each major.", "To find the largest major, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.501", "db_id": "allergy_1", "question": "Which advisor has most number of students?", "rationale": ["Identify the relevant table: The 'Student' table contains information about students and their advisors.", "Determine the required information: We need to find out which advisor has the most students.", "Use the COUNT function: We will count the number of students (StuID) for each advisor.", "Group the results: We will group the results by the 'Advisor' column to aggregate the student counts for each advisor.", "Order the results: We will order the results in descending order based on the student count to find the advisor with the most students.", "Limit the results: We will limit the output to 1 to get only the advisor with the highest count."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount\nFROM Student\nGROUP BY Advisor\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the main goal: Count the number of students affected by cat allergies.", "Determine the relevant tables: We need to use the 'Student' table to get student information and the 'Has_Allergy' table to find students with specific allergies.", "Join the 'Has_Allergy' table with the 'Allergy_Type' table to filter for cat allergies.", "Use a subquery to find all student IDs (StuID) that have a cat allergy.", "Count the number of students whose StuID is in the result of the subquery."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT count(*) FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.508", "db_id": "allergy_1", "question": "Which students are unaffected by allergies?", "rationale": ["Identify the goal: We need to find students who are unaffected by allergies.", "To find students without allergies, we can use the 'Student' table and filter out those who have allergies listed in the 'Has_Allergy' table.", "We will use a subquery to select all student IDs (StuID) from the 'Has_Allergy' table that have any allergies.", "The main query will select the first name (fname) and last name (lname) of students whose StuID is not in the list of IDs returned by the subquery."], "gold_sql": "SELECT StuID FROM Student EXCEPT SELECT StuID FROM Has_allergy", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT fname, lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.509", "db_id": "allergy_1", "question": "How many female students have milk or egg allergies?", "rationale": ["Identify the gender of the students we are interested in, which is 'Female'.", "We need to count the number of female students, so we will use the COUNT function.", "We need to filter students based on their allergies, specifically those who have either 'Milk' or 'Egg' allergies.", "To do this, we will join the 'Has_Allergy' table with the 'Allergy_Type' table to find students with the specified allergies.", "We will use a subquery to get the StuID of students who have either 'Milk' or 'Egg' allergies.", "Finally, we will combine the conditions to count the female students who meet the allergy criteria."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT count(*) FROM Student WHERE sex = 'Female' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy IN ('Milk', 'Egg'));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the target demographic: female students.", "Count the number of students who are female and have specific allergies (milk or eggs).", "Use a subquery to find students with the specified allergies by joining the Has_Allergy and Allergy_Type tables.", "Filter the main query by gender and the results of the subquery to get the final count."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT count(*) FROM Student WHERE Sex = 'Female' AND StuID IN (SELECT StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy IN ('Milk', 'Eggs'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.513", "db_id": "allergy_1", "question": "Which allergy has most number of students affected?", "rationale": ["We need to find out which allergy has the most number of students affected.", "To do this, we will count the number of students for each allergy in the Has_Allergy table.", "We will group the results by the Allergy column to get the count for each allergy.", "Then, we will order the results in descending order based on the count of students affected.", "Finally, we will limit the results to just one record to get the allergy with the highest count."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT Allergy, COUNT(*) AS StudentCount FROM Has_Allergy GROUP BY Allergy ORDER BY StudentCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.518", "db_id": "allergy_1", "question": "How many students are affected by each allergy type?", "rationale": ["Identify the tables needed: We need to count students affected by each allergy type, so we will use the Has_Allergy and Allergy_Type tables.", "Join the Has_Allergy table with the Allergy_Type table on the Allergy column to get the allergy type for each student.", "Use COUNT(DISTINCT T1.StuID) to count the unique students for each allergy type.", "Group the results by AllergyType to get the count for each type of allergy."], "gold_sql": "SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype", "source_tables": ["has_allergy", "allergy_type"], "pred_sql": "SELECT T2.AllergyType, COUNT(DISTINCT T1.StuID) AS StudentCount \nFROM Has_Allergy AS T1 \nJOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy \nGROUP BY T2.AllergyType;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the tables needed: Student, Has_Allergy, and Allergy_Type.", "We need to find students who have specific allergies (milk and cat).", "Use the Has_Allergy table to find students with these allergies by their StuID.", "Join the Has_Allergy table with the Allergy_Type table to filter by the specific allergies (milk and cat).", "Use the INTERSECT operator to find students who have both allergies.", "Select the last names and ages of these students from the Student table."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT LName, Age FROM Student WHERE StuID IN (SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'milk' INTERSECT SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.522", "db_id": "allergy_1", "question": "What are the allergies the girl named Lisa has? And what are the types of them? Order the result by allergy names.", "rationale": ["Identify the tables needed: Student, Has_Allergy, and Allergy_Type.", "Join the Student table with Has_Allergy to get the allergies for each student.", "Join the result with Allergy_Type to get the type of each allergy.", "Filter the results to only include the student named Lisa who is female.", "Select the Allergy and AllergyType columns from the result.", "Order the final result by the Allergy names."], "gold_sql": "SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  'Lisa' ORDER BY T1.Allergy", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT A.Allergy, T.AllergyType FROM Student S JOIN Has_Allergy H ON S.StuID = H.StuID JOIN Allergy_Type A ON H.Allergy = A.Allergy WHERE S.Fname = 'Lisa' AND S.Sex = 'Female' ORDER BY A.Allergy;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the goal: Calculate the average age of students with specific allergy types (food and animal).", "Use the Student table to access the age of students.", "Filter students based on their allergies using the Has_Allergy and Allergy_Type tables.", "Join Has_Allergy with Allergy_Type to find students with allergies of type 'food'.", "Join Has_Allergy with Allergy_Type again to find students with allergies of type 'animal'.", "Use INTERSECT to find students who have both types of allergies.", "Finally, calculate the average age of the filtered students."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT avg(Age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'food' INTERSECT SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'animal')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.527", "db_id": "allergy_1", "question": "List the first and last name of the students who do not have any food type allergy.", "rationale": ["Identify the main goal: List the first and last names of students without food type allergies.", "Use the 'Student' table to get the first and last names, which are 'Fname' and 'LName'.", "To filter out students with food allergies, we need to check the 'Has_Allergy' table joined with the 'Allergy_Type' table.", "The subquery will select 'StuID' from 'Has_Allergy' where the allergy type is 'Food'.", "Use the NOT IN clause to exclude those students from the main query.", "Construct the final SQL query to select 'Fname' and 'LName' from 'Student' where 'StuID' is not in the result of the subquery."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'Food')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.529", "db_id": "allergy_1", "question": "Find the number of male (sex is 'M') students who have some food type allery.", "rationale": ["Identify the requirement to count male students with food allergies.", "Use the 'Student' table to filter by gender (sex = 'M').", "Join the 'Has_Allergy' table with the 'Allergy_Type' table to filter for food allergies.", "Count the number of students who meet both criteria."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT count(*) FROM Student WHERE sex = 'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.allergytype = 'food')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables needed: We need data from the Student table for first names and city codes, and the Has_Allergy table to filter students based on their allergies.", "Determine the condition: We are looking for students who have allergies to either 'milk' or 'cat'.", "Use a subquery to find the StuIDs of students who have these allergies by checking the Has_Allergy table.", "Use the DISTINCT keyword to ensure we get unique combinations of first names and city codes.", "Construct the final SQL query to select the first names and city codes from the Student table where the StuID matches those found in the subquery."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT Fname, city_code FROM Student WHERE StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy IN ('milk', 'cat'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.533", "db_id": "allergy_1", "question": "Find the number of students who are older than 18 and do not have allergy to either food or animal.", "rationale": ["Identify the main requirement: count students older than 18 without allergies to food or animals.", "Use the 'Student' table to filter students based on age.", "Use a subquery to find students with allergies by joining 'Has_Allergy' and 'Allergy_Type' tables.", "In the subquery, filter allergies to exclude 'food' and 'animal' types.", "Combine the main query and subquery to count the students who meet the criteria."], "gold_sql": "SELECT count(*) FROM Student WHERE age  >  18 AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' OR T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT count(*) FROM Student WHERE Age > 18 AND StuID NOT IN ( SELECT StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'food' OR T2.AllergyType = 'animal')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the WHERE clause represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.535", "db_id": "allergy_1", "question": "Find the first name and major of the students who are not allegry to soy.", "rationale": ["Identify the required fields: first name (Fname) and major from the Student table.", "Determine the condition: students who do not have an allergy to soy.", "Use a subquery to find students with an allergy to soy by joining Has_Allergy and Allergy_Type tables.", "The subquery selects StuID from Has_Allergy where the allergy matches 'soy'.", "The main query selects Fname and Major from Student where StuID is not in the result of the subquery."], "gold_sql": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Soy')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Major FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'soy')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for filtering based on these allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["Identify the relevant table: The invoices table contains the billing country and total amount of each invoice.", "Select the columns needed: We need the billing_country and the average of the total column.", "Use the AVG() function to calculate the average invoice size for each country.", "Group the results by billing_country to get the average for each country.", "Order the results by average_invoice_size in descending order to get the top countries by size.", "Limit the results to the top 10 countries."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size\nFROM invoices\nGROUP BY billing_country\nORDER BY average_invoice_size DESC\nLIMIT 10;", "hint": "\n"}
{"sample_id": "train.553", "db_id": "store_1", "question": "List every album ordered by album title in ascending order.", "rationale": ["Identify the table that contains album information, which is the 'albums' table.", "Determine the column that contains the album titles, which is 'title'.", "Specify that we want to select the 'title' column from the 'albums' table.", "Add an ORDER BY clause to sort the results by the 'title' in ascending order."], "gold_sql": "SELECT title FROM albums ORDER BY title;", "source_tables": ["albums"], "pred_sql": "SELECT title FROM albums ORDER BY title ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that have been purchased by customers with a specific first and last name. The placeholders in the WHERE clause represent the customer's first and last names.\",\n        \"virtual_table\": \"SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = [PLACEHOLDER-TYPE:STRING] AND T4.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific genre and media type. The placeholders in the WHERE clause represent the genre's name and the media type's name.\",\n        \"virtual_table\": \"SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = [PLACEHOLDER-TYPE:STRING] AND T3.name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.560", "db_id": "store_1", "question": "What are the total amount of money in the invoices billed from Chicago, Illinois?", "rationale": ["Identify the relevant table: invoices, which contains billing information and total amounts.", "Determine the columns needed: total (for the amount) and billing_city, billing_state (for filtering).", "Formulate the condition to filter invoices: where billing_city is 'Chicago' and billing_state is 'Illinois'.", "Use the SUM() function to calculate the total amount from the filtered invoices."], "gold_sql": "SELECT sum(total) FROM invoices WHERE billing_city  =  'Chicago' AND billing_state  =  'IL';", "source_tables": ["invoices"], "pred_sql": "SELECT SUM(total) AS total_amount FROM invoices WHERE billing_city = 'Chicago' AND billing_state = 'Illinois';", "hint": "\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["Identify the relevant table: The invoices table contains the billing information including the state.", "Determine the required fields: We need the billing_state and a count of invoices for each state.", "Use the COUNT() function to count the number of invoices for each state.", "Group the results by billing_state to get the count for each state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state;", "hint": "\n"}
{"sample_id": "train.565", "db_id": "store_1", "question": "List the state in the US with the most invoices.", "rationale": ["We need to find the state in the US with the most invoices.", "The relevant table for invoices is the 'invoices' table, which contains a column 'billing_state'.", "To count the number of invoices per state, we will use the COUNT() function and group the results by 'billing_state'.", "We will order the results in descending order based on the count of invoices to get the state with the most invoices at the top.", "Finally, we will limit the results to 1 to get only the state with the highest count."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state\nORDER BY invoice_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["Identify the relevant table: The 'invoices' table contains the information about invoices, including the billing state.", "Determine the required information: We need to count the number of invoices for each state.", "Use the COUNT() function to count the invoices grouped by 'billing_state'.", "Group the results by 'billing_state' to aggregate the counts for each state.", "Order the results in descending order to find the states with the most invoices."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count\nFROM invoices\nGROUP BY billing_state\nORDER BY invoice_count DESC;", "hint": "\n"}
{"sample_id": "train.567", "db_id": "store_1", "question": "List the number of invoices and the invoice total from California.", "rationale": ["We need to count the number of invoices and sum the total from invoices issued to customers in California.", "The relevant tables are 'invoices' and 'customers'.", "We will join the 'invoices' table with the 'customers' table on the customer_id field.", "We will filter the results to include only those customers who reside in California using a WHERE clause.", "Finally, we will use COUNT(*) to get the number of invoices and SUM(total) to get the total invoice amount."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS invoice_total\nFROM invoices\nJOIN customers ON invoices.customer_id = customers.id\nWHERE customers.state = 'California';", "hint": "\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the table that contains the information needed: the 'employees' table has the email and phone number.", "Determine the specific columns to select: 'email' and 'phone'.", "Filter the results to find the specific employee by their first and last name: 'Astrid Gruber'.", "Construct the SQL query using the SELECT statement with the appropriate WHERE clause."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: employees and customers.", "We need to find the employee who has supported the most customers, which means we need to join the employees table with the customers table on the support_rep_id.", "Group the results by employee ID to count the number of customers each employee supports.", "Order the results by the count of customers in descending order to get the employee with the most customers at the top.", "Limit the results to 1 to get only the top employee.", "Select the full name of the employee by concatenating first_name and last_name."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.594", "db_id": "store_1", "question": "What is the full name of the employee who has the most customers?", "rationale": ["Identify the relevant tables: employees and customers.", "We need to find the employee who has the most customers, which means we need to join the employees table with the customers table on the support_rep_id.", "Use a GROUP BY clause to group the results by employee ID.", "Count the number of customers for each employee using COUNT(c.id).", "Order the results in descending order to get the employee with the most customers at the top.", "Limit the results to 1 to get only the top employee.", "Select the full name of the employee by concatenating first_name and last_name."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.604", "db_id": "store_1", "question": "How many employees who are IT staff are from each city?", "rationale": ["Identify the relevant table: The 'employees' table contains information about employees, including their job titles and cities.", "Determine the criteria: We need to filter employees who are in the IT staff, which can be identified by checking if the 'title' column contains 'IT'.", "Count the number of employees: We will use the COUNT() function to count the number of employees that meet the criteria.", "Group the results: We will group the results by 'city' to get the count of IT staff from each city."], "gold_sql": "SELECT count(*) ,  city FROM employees WHERE title  =  'IT Staff' GROUP BY city", "source_tables": ["employees"], "pred_sql": "SELECT city, COUNT(*) AS employee_count \nFROM employees \nWHERE title LIKE '%IT%'\nGROUP BY city;", "hint": "\n"}
{"sample_id": "train.624", "db_id": "store_1", "question": "What is the name of the album that has the track Ball to the Wall?", "rationale": ["Identify the relevant tables: We need to find the album title, which is in the 'albums' table, and we need to link it to the 'tracks' table to find the specific track.", "Determine the relationship: The 'albums' table has a foreign key 'id' that corresponds to 'album_id' in the 'tracks' table. This means we can join these two tables on these columns.", "Specify the condition: We are looking for a specific track name, 'Ball to the Wall', so we will add a WHERE clause to filter the results based on the track name.", "Construct the SQL query: Using the identified tables, relationships, and conditions, we can construct the SQL query to select the album title where the track name matches 'Ball to the Wall'."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title \nFROM albums \nJOIN tracks ON albums.id = tracks.album_id \nWHERE tracks.name = 'Ball to the Wall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that have been purchased by customers with a specific first and last name. The placeholders in the WHERE clause represent the customer's first and last names.\",\n        \"virtual_table\": \"SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = [PLACEHOLDER-TYPE:STRING] AND T4.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific genre and media type. The placeholders in the WHERE clause represent the genre's name and the media type's name.\",\n        \"virtual_table\": \"SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = [PLACEHOLDER-TYPE:STRING] AND T3.name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the relevant tables: genres, tracks, and media_types.", "Join the genres table with the tracks table on genre_id to filter tracks by genre.", "Join the tracks table with the media_types table on media_type_id to filter tracks by media type.", "Use a WHERE clause to specify the genre as 'Rock' and the media type as 'MPEG'.", "Select the name of the tracks that meet these criteria."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that belong to a specific genre and media type. The placeholders in the WHERE clause represent the genre's name and the media type's name.\",\n        \"virtual_table\": \"SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = [PLACEHOLDER-TYPE:STRING] AND T3.name = [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tracks from the 'tracks' table that have been purchased by customers with a specific first and last name. The placeholders in the WHERE clause represent the customer's first and last names.\",\n        \"virtual_table\": \"SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = [PLACEHOLDER-TYPE:STRING] AND T4.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.946", "db_id": "medicine_enzyme_interaction", "question": "What are the names and trade names of the medcines that are FDA approved?", "rationale": ["Identify the relevant table: The 'medicine' table contains the information about medicines, including their names, trade names, and FDA approval status.", "Determine the required columns: We need the 'name' and 'Trade_Name' columns from the 'medicine' table.", "Specify the condition: We only want medicines that are FDA approved, which is indicated by the 'FDA_approved' column being equal to 'yes'.", "Construct the SQL query: Combine the selected columns and the condition into a SELECT statement."], "gold_sql": "SELECT name ,  trade_name FROM medicine WHERE FDA_approved  =  'Yes'", "source_tables": ["medicine"], "pred_sql": "SELECT name, Trade_Name FROM medicine WHERE FDA_approved = 'yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\",\n        \"virtual_table\": \"SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.951", "db_id": "medicine_enzyme_interaction", "question": "What are the ids, names and FDA approval status of medicines in descending order of the number of enzymes that it can interact with.", "rationale": ["Identify the relevant tables: medicine and medicine_enzyme_interaction.", "We need to select the medicine's id, name, and FDA approval status.", "To find the number of enzymes each medicine interacts with, we will join the medicine table with the medicine_enzyme_interaction table on the medicine_id.", "We will group the results by the medicine's id, name, and FDA approval status to aggregate the count of enzyme interactions.", "Finally, we will order the results in descending order based on the count of enzyme interactions."], "gold_sql": "SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC", "source_tables": ["medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.id, m.name, m.FDA_approved\nFROM medicine m\nJOIN medicine_enzyme_interaction mei ON mei.medicine_id = m.id\nGROUP BY m.id, m.name, m.FDA_approved\nORDER BY COUNT(mei.enzyme_id) DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\",\n        \"virtual_table\": \"SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.953", "db_id": "medicine_enzyme_interaction", "question": "What is the id and name of the enzyme with most number of medicines that can interact as 'activator'?", "rationale": ["Identify the relevant tables: We need to work with the 'enzyme' and 'medicine_enzyme_interaction' tables to find the enzyme that interacts with the most medicines as 'activator'.", "Join the tables: We will join the 'enzyme' table with the 'medicine_enzyme_interaction' table on the enzyme ID to get the necessary data about interactions.", "Filter the interactions: We will filter the results to only include interactions where the interaction type is 'activator'.", "Group the results: We will group the results by enzyme ID and name to count the number of medicines that interact with each enzyme.", "Order the results: We will order the results in descending order based on the count of interacting medicines to find the enzyme with the most interactions.", "Limit the results: We will limit the results to only the top result to get the enzyme with the most medicines that can interact as 'activator'."], "gold_sql": "SELECT T1.id ,  T1.name FROM enzyme AS T1 JOIN medicine_enzyme_interaction AS T2 ON T1.id  =  T2.enzyme_id WHERE T2.interaction_type  =  'activitor' GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["enzyme", "medicine_enzyme_interaction"], "pred_sql": "SELECT e.id, e.name\nFROM enzyme e\nJOIN medicine_enzyme_interaction mei ON e.id = mei.enzyme_id\nWHERE mei.interaction_type = 'activator'\nGROUP BY e.id, e.name\nORDER BY COUNT(mei.medicine_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\",\n        \"virtual_table\": \"SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.968", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that can interact as an inhibitor and activitor with enzymes?", "rationale": ["Identify the relevant tables: medicine, enzyme, and medicine_enzyme_interaction.", "We need to retrieve the names and trade names of medicines that interact with enzymes as either inhibitors or activators.", "Join the medicine table with the medicine_enzyme_interaction table on the medicine_id to get the interaction details.", "Join the enzyme table to get enzyme details, although we don't need specific enzyme information for this query.", "Filter the results where the interaction_type is either 'inhibitor' or 'activator'.", "Select the name and Trade_Name from the medicine table."], "gold_sql": "SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'inhibitor' INTERSECT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id WHERE interaction_type  =  'activitor'", "source_tables": ["medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT m.name, m.Trade_Name FROM medicine AS m JOIN medicine_enzyme_interaction AS mei ON mei.medicine_id = m.id JOIN enzyme AS e ON e.id = mei.enzyme_id WHERE mei.interaction_type IN ('inhibitor', 'activator')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\",\n        \"virtual_table\": \"SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.970", "db_id": "medicine_enzyme_interaction", "question": "What are the medicine and trade names that cannot interact with the enzyme with the product 'Heme'?", "rationale": ["Identify the main goal: to find medicines that do not interact with the enzyme that produces 'Heme'.", "Use the medicine table to get the names and trade names of all medicines.", "Utilize the EXCEPT clause to exclude medicines that interact with the enzyme producing 'Heme'.", "Join the medicine table with the medicine_enzyme_interaction table to find interactions.", "Join the enzyme table to filter for the specific product 'Heme'.", "Construct the SQL query using the provided virtual table structure and replace the placeholder with 'Heme'."], "gold_sql": "SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  'Protoporphyrinogen IX'", "source_tables": ["enzyme", "medicine", "medicine_enzyme_interaction"], "pred_sql": "SELECT name, trade_name FROM medicine EXCEPT SELECT T1.name, T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id = T1.id JOIN enzyme AS T3 ON T3.id = T2.enzyme_id WHERE T3.product = 'Heme'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and trade names of medicines from the 'medicine' table that do not interact with a specific enzyme product. The placeholder in the EXCEPT clause represents the product associated with the enzyme.\",\n        \"virtual_table\": \"SELECT name ,  trade_name FROM medicine EXCEPT SELECT T1.name ,  T1.trade_name FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id JOIN enzyme AS T3 ON T3.id  =  T2.enzyme_id WHERE T3.product  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1355", "db_id": "college_2", "question": "What is the name of the department with an instructure who has a name like 'Soisalon'?", "rationale": ["Identify the relevant tables: We need to find the department associated with an instructor whose name matches 'Soisalon'. The relevant tables are 'department' and 'instructor'.", "Determine the relationship: The 'instructor' table has a foreign key 'dept_name' that links to the 'department' table. We can use this relationship to find the department name.", "Construct the inner query: We will first select the 'dept_name' from the 'instructor' table where the 'name' matches 'Soisalon'. This will give us the department(s) associated with that instructor.", "Construct the outer query: We will then select the 'dept_name' from the 'department' table where the 'dept_name' is in the result of the inner query. This will give us the name of the department(s) with the instructor named 'Soisalon'.", "Combine the queries: The final SQL query combines the inner and outer queries to retrieve the desired department name."], "gold_sql": "SELECT dept_name FROM instructor WHERE name LIKE '%Soisalon%'", "source_tables": ["instructor"], "pred_sql": "SELECT dept_name FROM department WHERE dept_name IN (SELECT dept_name FROM instructor WHERE name LIKE 'Soisalon')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\",\n        \"virtual_table\": \"SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.1365", "db_id": "college_2", "question": "What are the titles of courses that are in the Statistics department but not the Psychology department?", "rationale": ["Identify the relevant table: The 'course' table contains the titles of courses and their associated departments.", "Filter for the Statistics department: We need to select courses where the 'dept_name' is 'Statistics'.", "Exclude the Psychology department: We need to ensure that the courses selected are not from the 'Psychology' department. However, since a course can only belong to one department, we only need to check for the Statistics department in this case. Therefore, we can directly select courses from the Statistics department without needing to check for Psychology."], "gold_sql": "SELECT title FROM course WHERE dept_name  =  'Statistics' EXCEPT SELECT title FROM course WHERE dept_name  =  'Psychology'", "source_tables": ["course"], "pred_sql": "SELECT title FROM course WHERE dept_name = 'Statistics' AND dept_name != 'Psychology';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\",\n        \"virtual_table\": \"SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    }\n}\n"}
{"sample_id": "train.1424", "db_id": "college_2", "question": "Find the title of course whose prerequisite is course Differential Geometry.", "rationale": ["Identify the table that contains course titles, which is the 'course' table.", "Identify the table that contains prerequisites, which is the 'prereq' table.", "To find the course title whose prerequisite is 'Differential Geometry', we need to join the 'course' table with the 'prereq' table on the course_id.", "We need to filter the results to only include those courses that have 'Differential Geometry' as a prerequisite.", "To do this, we can use a subquery to find the course_id of 'Differential Geometry' and use it in the WHERE clause."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.course_id FROM prereq AS T1 JOIN course AS T2 ON T1.prereq_id  =  T2.course_id WHERE T2.title  =  'Differential Geometry')", "source_tables": ["course", "prereq"], "pred_sql": "SELECT c.title \nFROM course c \nJOIN prereq p ON c.course_id = p.course_id \nWHERE p.prereq_id = (SELECT course_id FROM course WHERE title = 'Differential Geometry');", "hint": "\n"}
{"sample_id": "train.1426", "db_id": "college_2", "question": "Find the names of students who have taken any course in the fall semester of year 2003.", "rationale": ["Identify the tables involved: We need information from the 'student', 'takes', and 'section' tables.", "We want the names of students, so we will select the 'name' column from the 'student' table.", "To find students who have taken courses, we need to join the 'student' table with the 'takes' table on the student ID.", "Next, we need to join the 'takes' table with the 'section' table to filter by semester and year.", "We will add a WHERE clause to filter for the fall semester of the year 2003."], "gold_sql": "SELECT name FROM student WHERE id IN (SELECT id FROM takes WHERE semester  =  'Fall' AND YEAR  =  2003)", "source_tables": ["student", "takes"], "pred_sql": "SELECT student.name \nFROM student \nJOIN takes ON student.ID = takes.ID \nJOIN section ON takes.course_id = section.course_id AND takes.sec_id = section.sec_id AND takes.semester = section.semester AND takes.year = section.year \nWHERE section.semester = 'Fall' AND section.year = '2003';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\",\n        \"virtual_table\": \"SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n        \"virtual_table\": \"SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1435", "db_id": "college_2", "question": "What are the names of all instructors who advise students in the math depart sorted by total credits of the student.", "rationale": ["Identify the tables involved: advisor, instructor, and student.", "Join the advisor table with the instructor table to get the names of instructors who are advisors.", "Join the advisor table with the student table to get the students being advised.", "Filter the results to include only those students who are in the 'math' department.", "Order the results by the total credits earned by the students in descending order."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id WHERE T3.dept_name  =  'Math' ORDER BY T3.tot_cred", "source_tables": ["instructor", "student", "advisor"], "pred_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_ID = T2.ID JOIN student AS T3 ON T1.s_ID = T3.ID WHERE T3.dept_name = 'math' ORDER BY T3.tot_cred DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n        \"virtual_table\": \"SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    }\n}\n"}
{"sample_id": "train.1436", "db_id": "college_2", "question": "What is the course title of the prerequisite of course Mobile Computing?", "rationale": ["Identify the course for which we need to find the prerequisite, which is 'Mobile Computing'.", "Find the course_id of 'Mobile Computing' from the course table.", "Join the course table with the prereq table to find the prerequisite course_id.", "Select the title of the course from the course table where the course_id matches the prerequisite course_id found in the previous step."], "gold_sql": "SELECT title FROM course WHERE course_id IN (SELECT T1.prereq_id FROM prereq AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.title  =  'Mobile Computing')", "source_tables": ["course", "prereq"], "pred_sql": "SELECT c.title \nFROM course c \nJOIN prereq p ON c.course_id = p.prereq_id \nWHERE p.course_id = (SELECT course_id FROM course WHERE title = 'Mobile Computing');", "hint": "\n"}
{"sample_id": "train.1439", "db_id": "college_2", "question": "What is the name of the instructor who advises the student with the greatest number of total credits?", "rationale": ["Identify the tables involved: advisor, instructor, and student.", "We need to find the instructor who advises a student with the greatest number of total credits.", "Join the advisor table with the instructor table to get the names of instructors.", "Join the advisor table with the student table to access the total credits of students.", "Order the results by total credits in descending order to get the student with the highest credits at the top.", "Limit the results to 1 to get only the instructor for the student with the greatest number of total credits."], "gold_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT 1", "source_tables": ["instructor", "student", "advisor"], "pred_sql": "SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_ID = T2.ID JOIN student AS T3 ON T1.s_ID = T3.ID ORDER BY T3.tot_cred DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n        \"virtual_table\": \"SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    }\n}\n"}
{"sample_id": "train.1448", "db_id": "college_2", "question": "Find the number and averaged salary of all instructors who are in the department with the highest budget.", "rationale": ["Identify the department with the highest budget by selecting the 'dept_name' from the 'department' table and ordering by 'budget' in descending order, limiting the result to 1.", "Count the number of instructors in that department using COUNT(ID) from the 'instructor' table where 'dept_name' matches the department identified in the previous step.", "Calculate the average salary of those instructors using AVG(salary) from the 'instructor' table under the same condition."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "pred_sql": "SELECT COUNT(ID) AS instructor_count, AVG(salary) AS average_salary \nFROM instructor \nWHERE dept_name = (SELECT dept_name \n                   FROM department \n                   ORDER BY budget DESC \n                   LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n        \"virtual_table\": \"SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1449", "db_id": "college_2", "question": "How many instructors are in the department with the highest budget, and what is their average salary?", "rationale": ["Identify the department with the highest budget by ordering the 'department' table by 'budget' in descending order and selecting the top entry.", "Use a subquery to find the 'dept_name' of the department with the highest budget.", "Count the number of instructors in that department by filtering the 'instructor' table based on the 'dept_name' obtained from the subquery.", "Calculate the average salary of the instructors in that department using the AVG() function."], "gold_sql": "SELECT avg(T1.salary) ,  count(*) FROM instructor AS T1 JOIN department AS T2 ON T1.dept_name  =  T2.dept_name ORDER BY T2.budget DESC LIMIT 1", "source_tables": ["instructor", "department"], "pred_sql": "SELECT COUNT(ID) AS instructor_count, AVG(salary) AS average_salary \nFROM instructor \nWHERE dept_name = (SELECT dept_name \n                   FROM department \n                   ORDER BY budget DESC \n                   LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n        \"virtual_table\": \"SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1452", "db_id": "college_2", "question": "Find the name of students who didn't take any course from Biology department.", "rationale": ["Identify the main requirement: Find students who did not take any course from the Biology department.", "Use the 'student' table to get the names of students.", "To find students who did not take any courses from the Biology department, we need to check against the 'takes' table, which records the courses students are enrolled in.", "Join the 'takes' table with the 'course' table to filter courses by the Biology department.", "Use a subquery to select IDs of students who took courses from the Biology department.", "Use the NOT IN clause to exclude these students from the main query that selects student names."], "gold_sql": "SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  'Biology')", "source_tables": ["course", "student", "takes"], "pred_sql": "SELECT name FROM student WHERE ID NOT IN (SELECT T1.ID FROM takes AS T1 JOIN course AS T2 ON T1.course_id = T2.course_id WHERE T2.dept_name = 'Biology')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\",\n        \"virtual_table\": \"SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    }\n}\n"}
{"sample_id": "train.1458", "db_id": "college_2", "question": "Find the name and salary of instructors whose salary is below the average salary of the instructors in the Physics department.", "rationale": ["Identify the relevant tables: We need the 'instructor' table for instructor details and their salaries.", "Determine the condition: We want instructors whose salary is below the average salary of those in the Physics department.", "Calculate the average salary: Use a subquery to calculate the average salary of instructors in the Physics department.", "Construct the main query: Select the name and salary of instructors from the 'instructor' table where their salary is less than the average calculated in the subquery."], "gold_sql": "SELECT name ,  salary FROM instructor WHERE salary  <  (SELECT avg(salary) FROM instructor WHERE dept_name  =  'Physics')", "source_tables": ["instructor"], "pred_sql": "SELECT name, salary FROM instructor WHERE salary < (SELECT AVG(salary) FROM instructor WHERE dept_name = 'Physics')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n        \"virtual_table\": \"SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    }\n}\n"}
{"sample_id": "train.1461", "db_id": "college_2", "question": "What are the names of students who have taken Statistics courses?", "rationale": ["Identify the relevant tables: student, takes, and course.", "We need to find students who have taken Statistics courses, so we will join the student table with the takes table on the student ID.", "Next, we join the takes table with the course table on the course ID to access course titles.", "We filter the results to only include courses with the title 'Statistics'.", "Finally, we select the names of the students from the resulting joined table."], "gold_sql": "SELECT T3.name FROM course AS T1 JOIN takes AS T2 ON T1.course_id  =  T2.course_id JOIN student AS T3 ON T2.id  =  T3.id WHERE T1.dept_name  =  'Statistics'", "source_tables": ["course", "student", "takes"], "pred_sql": "SELECT student.name FROM student JOIN takes ON student.ID = takes.ID JOIN course ON takes.course_id = course.course_id WHERE course.title = 'Statistics';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\",\n        \"virtual_table\": \"SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    }\n}\n"}
{"sample_id": "train.1464", "db_id": "college_2", "question": "Find the names of all instructors in computer science department", "rationale": ["Identify the table that contains instructor information, which is the 'instructor' table.", "Determine the relevant column for instructor names, which is 'name'.", "Identify the condition needed to filter instructors by department, which is 'dept_name'.", "Specify the department of interest, which is 'computer science'.", "Construct the SQL query to select the names of instructors from the 'instructor' table where the 'dept_name' matches 'computer science'."], "gold_sql": "SELECT name FROM instructor WHERE dept_name  =  'Comp. Sci.'", "source_tables": ["instructor"], "pred_sql": "SELECT name FROM instructor WHERE dept_name = 'computer science'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n        \"virtual_table\": \"SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    }\n}\n"}
{"sample_id": "train.1480", "db_id": "college_2", "question": "Find courses that ran in Fall 2009 but not in Spring 2010.", "rationale": ["Identify the courses that were offered in Fall 2009 by joining the 'course' and 'section' tables on 'course_id'.", "Filter the results to only include sections from Fall 2009 by specifying the semester and year in the WHERE clause.", "To find courses that did not run in Spring 2010, create a subquery that selects 'course_id' from the 'section' table for Spring 2010.", "Use the NOT IN clause to exclude any courses from the main query that are present in the subquery results."], "gold_sql": "SELECT course_id FROM SECTION WHERE semester  =  'Fall' AND YEAR  =  2009 EXCEPT SELECT course_id FROM SECTION WHERE semester  =  'Spring' AND YEAR  =  2010", "source_tables": ["section"], "pred_sql": "SELECT DISTINCT c.title \nFROM course c \nJOIN section s1 ON c.course_id = s1.course_id \nWHERE s1.semester = 'Fall' AND s1.year = '2009' \nAND c.course_id NOT IN (\n    SELECT s2.course_id \n    FROM section s2 \n    WHERE s2.semester = 'Spring' AND s2.year = '2010'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of students who are not enrolled in any courses offered by a specific department. The placeholder in the subquery represents the department's name.\",\n        \"virtual_table\": \"SELECT name FROM student WHERE id NOT IN (SELECT T1.id FROM takes AS T1 JOIN course AS T2 ON T1.course_id  =  T2.course_id WHERE T2.dept_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.1489", "db_id": "college_2", "question": "What are the names of instructors who earn more than at least one instructor from the Biology department?", "rationale": ["Identify the instructors who earn more than at least one instructor from the Biology department.", "To do this, we need to find the maximum salary of instructors in the Biology department.", "We can achieve this by using a subquery that selects the maximum salary from the instructor table where the dept_name is 'Biology'.", "Then, we will select the names of instructors from the instructor table whose salary is greater than the result of the subquery."], "gold_sql": "SELECT name FROM instructor WHERE salary  >  (SELECT min(salary) FROM instructor WHERE dept_name  =  'Biology')", "source_tables": ["instructor"], "pred_sql": "SELECT name FROM instructor WHERE salary > (SELECT MAX(salary) FROM instructor WHERE dept_name = 'Biology')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of instructors who are advisors to students, ordered by the total credits earned by the students in descending order. The placeholder in the LIMIT clause represents the maximum number of instructor names to be returned.\",\n        \"virtual_table\": \"SELECT T2.name FROM advisor AS T1 JOIN instructor AS T2 ON T1.i_id  =  T2.id JOIN student AS T3 ON T1.s_id  =  T3.id ORDER BY T3.tot_cred DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of distinct students and instructors associated with each academic department. It joins the 'department', 'student', and 'instructor' tables based on the department name, and groups the results by department name to provide a count of unique students and instructors for each department.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T2.id) ,  count(DISTINCT T3.id) ,  T3.dept_name FROM department AS T1 JOIN student AS T2 ON T1.dept_name  =  T2.dept_name JOIN instructor AS T3 ON T1.dept_name  =  T3.dept_name GROUP BY T3.dept_name\"\n    }\n}\n"}
{"sample_id": "train.1515", "db_id": "insurance_and_eClaims", "question": "Find the total and average amount paid in claim headers.", "rationale": ["The task is to find the total and average amount paid in claim headers.", "To achieve this, we need to use the Claim_Headers table, which contains the Amount_Piad column that represents the amount paid for each claim.", "We can use the SUM() function to calculate the total amount paid and the AVG() function to calculate the average amount paid.", "The SQL query will select the total and average amounts from the Amount_Piad column in the Claim_Headers table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Piad) AS Total_Amount_Paid, AVG(Amount_Piad) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["The question asks for the total and average amount paid in claim headers, which indicates that we need to perform aggregate functions on the 'Amount_Piad' column in the 'Claim_Headers' table.", "To get the total amount paid, we will use the SUM() function on the 'Amount_Piad' column.", "To get the average amount paid, we will use the AVG() function on the same column.", "We will select both the total and average amounts in a single SQL query, using appropriate aliases for clarity."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Piad) AS Total_Amount_Paid, AVG(Amount_Piad) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1517", "db_id": "insurance_and_eClaims", "question": "Find the total amount claimed in the most recently created document.", "rationale": ["To find the total amount claimed in the most recently created document, we need to focus on the Claim_Headers and Claims_Documents tables.", "We will join the Claim_Headers table with the Claims_Documents table using the Claim_ID to link claims to their respective documents.", "Next, we will order the results by the Created_Date in descending order to get the most recently created document first.", "Finally, we will use the SUM function to calculate the total amount claimed from the Claim_Headers table for the most recent document, limiting the results to just one record."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT SUM(ch.Amount_Claimed) FROM Claim_Headers AS ch JOIN Claims_Documents AS cd ON ch.Claim_Header_ID = cd.Claim_ID ORDER BY cd.Created_Date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Claim_Headers for claims, Policies for linking claims to customers, and Customers for customer details.", "Join the Claim_Headers table with the Policies table on Policy_ID to link claims to their respective policies.", "Join the resulting table with the Customers table on Customer_ID to get customer details.", "Use a subquery to find the maximum amount claimed from the Claim_Headers table.", "Filter the results to only include the customer(s) who made the claim with the maximum amount claimed."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT t3.Customer_Details FROM Claim_Headers AS t1 JOIN Policies AS t2 ON t1.Policy_ID = t2.Policy_ID JOIN Customers AS t3 ON t2.Customer_ID = t3.Customer_ID WHERE t1.Amount_Claimed = (SELECT max(Amount_Claimed) FROM Claim_Headers)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1527", "db_id": "insurance_and_eClaims", "question": "What is the name of the claim processing stage that most of the claims are on?", "rationale": ["To find the claim processing stage that most claims are on, we need to count the number of claims in each processing stage.", "We will join the Claims_Processing table with the Claims_Processing_Stages table on the Claim_Stage_ID to get the names of the stages.", "We will use the COUNT function to count the number of claims for each stage.", "We will group the results by the Claim_Status_Name to get the count for each stage.", "Finally, we will order the results in descending order based on the count and limit the results to 1 to get the stage with the most claims."], "gold_sql": "SELECT t2.claim_status_name FROM claims_processing AS t1 JOIN claims_processing_stages AS t2 ON t1.claim_stage_id  =  t2.claim_stage_id GROUP BY t1.claim_stage_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["claims_processing", "claims_processing_stages"], "pred_sql": "SELECT cps.Claim_Status_Name, COUNT(*) as Claim_Count FROM Claims_Processing cp JOIN Claims_Processing_Stages cps ON cp.Claim_Stage_ID = cps.Claim_Stage_ID GROUP BY cps.Claim_Status_Name ORDER BY Claim_Count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1535", "db_id": "insurance_and_eClaims", "question": "Find the names of all the customers and staff members.", "rationale": ["Identify the tables needed: Customers and Staff.", "Determine the columns to select: Customer_Details from Customers and Staff_Details from Staff.", "Use a SELECT statement to retrieve the desired columns.", "Since we want names from both tables, we can use a cross join (implicit join) to combine them, as there is no direct relationship needed for this query."], "gold_sql": "SELECT customer_details FROM customers UNION SELECT staff_details FROM staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT Customers.Customer_Details AS Customer_Name, Staff.Staff_Details AS Staff_Name \nFROM Customers, Staff;", "hint": "\n"}
{"sample_id": "train.1545", "db_id": "insurance_and_eClaims", "question": "Which customer is associated with the latest policy?", "rationale": ["Identify the relevant tables: We need to find the customer associated with the latest policy, so we will work with the Policies and Customers tables.", "Determine the latest policy: To find the latest policy, we can use the MAX function on the Start_Date column in the Policies table.", "Join the tables: We will join the Policies table with the Customers table on the Customer_ID to get the customer details associated with the latest policy.", "Construct the SQL query: We will select the Customer_Details from the Customers table where the Start_Date of the policy matches the latest Start_Date found in the previous step."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT t3.Customer_Details FROM Policies AS t1 JOIN Customers AS t2 ON t1.Customer_ID = t2.Customer_ID WHERE t1.Start_Date = (SELECT MAX(Start_Date) FROM Policies)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: We need to find customers and their policies, so we will use the Customers and Policies tables.", "Determine the relationship: The Policies table has a foreign key linking to the Customers table via Customer_ID.", "Find the most recent policy: We need to find the maximum Start_Date from the Policies table to identify the most recently started policy.", "Construct the SQL query: We will select the Customer_Details from the Customers table where the Start_Date in the Policies table matches the maximum Start_Date found in the subquery."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT t3.Customer_Details FROM Policies AS t1 JOIN Customers AS t3 ON t1.Customer_ID = t3.Customer_ID WHERE t1.Start_Date = (SELECT MAX(Start_Date) FROM Policies)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves detailed information about customers associated with claims that have the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to their respective policies, and then joins with the 'Customers' table to get customer details. The placeholder in the WHERE clause represents the minimum amount paid for claims.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "Determine the columns needed: account_id, account_name, and other_account_details from Accounts.", "Establish the relationship between Accounts and Customers using the customer_id foreign key.", "Filter the results to include only those accounts associated with the customer whose first name is 'Meaghan'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_id, Accounts.account_name, Accounts.other_account_details \nFROM Accounts \nJOIN Customers ON Accounts.customer_id = Customers.customer_id \nWHERE Customers.customer_first_name = 'Meaghan';", "hint": "\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to retrieve account details for a specific customer, so we will join the Customers table with the Accounts table using the customer_id.", "Filter the results to only include the customer named 'Meaghan Keeling' by checking both the first and last name in the WHERE clause.", "Select the desired columns: account_name and other_account_details from the Accounts table."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_name, Accounts.other_account_details \nFROM Customers \nJOIN Accounts ON Customers.customer_id = Accounts.customer_id \nWHERE Customers.customer_first_name = 'Meaghan' AND Customers.customer_last_name = 'Keeling';", "hint": "\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "Determine the columns needed: full names (first and last) from Customers and account name from Accounts.", "Join the Customers table with the Accounts table on the customer_id field to link customers with their accounts.", "Filter the results to include only those accounts with the name '900'.", "Select the concatenated first and last names as the full name."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nJOIN Accounts ON Customers.customer_id = Accounts.customer_id\nWHERE Accounts.account_name = '900';", "hint": "\n"}
{"sample_id": "train.1569", "db_id": "customers_and_invoices", "question": "Show id, first name and last name for all customers and the number of accounts.", "rationale": ["Identify the required fields: customer_id, customer_first_name, customer_last_name from the Customers table and the count of accounts from the Accounts table.", "Use a LEFT JOIN to connect the Customers table with the Accounts table on the customer_id field, ensuring that all customers are included even if they have no accounts.", "Use the COUNT function to count the number of accounts for each customer, and alias this count as number_of_accounts.", "Group the results by customer_id, customer_first_name, and customer_last_name to ensure that the count is calculated per customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name, COUNT(a.account_id) AS number_of_accounts\nFROM Customers c\nLEFT JOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name;", "hint": "\n"}
{"sample_id": "train.1570", "db_id": "customers_and_invoices", "question": "What are the the full names and ids for all customers, and how many accounts does each have?", "rationale": ["Identify the required fields: customer_id, full name (first and last), and account count.", "To get the full name, concatenate customer_first_name and customer_last_name.", "We need to count the number of accounts for each customer, which requires a join between Customers and Accounts tables.", "Use a LEFT JOIN to ensure all customers are included, even those without accounts.", "Group the results by customer_id and full name to get the count of accounts for each customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name, COUNT(a.account_id) AS account_count\nFROM Customers c\nLEFT JOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id, c.customer_first_name, c.customer_last_name;", "hint": "\n"}
{"sample_id": "train.1580", "db_id": "customers_and_invoices", "question": "Count the number of financial transactions that correspond to each account id.", "rationale": ["Identify the relevant table: Financial_Transactions contains the account_id and transaction_id.", "We need to count the number of transactions for each account, so we will use the COUNT() function.", "To group the results by account_id, we will use the GROUP BY clause.", "The final query will select the account_id and the count of transaction_id, giving us the number of transactions per account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT account_id, COUNT(transaction_id) AS transaction_count\nFROM Financial_Transactions\nGROUP BY account_id;", "hint": "\n"}
{"sample_id": "train.1607", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of invoices for each order.", "rationale": ["We need to retrieve the order ids and the number of invoices for each order.", "The relevant tables for this query are 'Orders' and 'Invoices'.", "We will perform a LEFT JOIN between 'Orders' and 'Invoices' on the order_id to ensure we get all orders even if they have no invoices.", "We will use the COUNT function to count the number of invoices associated with each order.", "Finally, we will group the results by order_id to get the count for each individual order."], "gold_sql": "SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id", "source_tables": ["invoices"], "pred_sql": "SELECT O.order_id, COUNT(I.invoice_number) AS number_of_invoices \nFROM Orders AS O \nLEFT JOIN Invoices AS I ON O.order_id = I.order_id \nGROUP BY O.order_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.\",\n        \"virtual_table\": \"SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name\"\n    }\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["We need to show the order ids and the number of items in each order.", "To achieve this, we will use the 'Order_Items' table to count the number of items for each order.", "We will join the 'Order_Items' table with the 'Orders' table to get the corresponding order ids.", "The COUNT function will be used to count the number of items (order_item_id) for each order.", "Finally, we will group the results by order_id to get the count for each order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT T3.order_id, COUNT(T1.order_item_id) AS number_of_items \nFROM Order_Items AS T1 \nJOIN Orders AS T3 ON T3.order_id = T1.order_id \nGROUP BY T3.order_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.\",\n        \"virtual_table\": \"SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name\"\n    }\n}\n"}
{"sample_id": "train.1622", "db_id": "customers_and_invoices", "question": "What are teh names of the different products, as well as the number of customers who have ordered each product.", "rationale": ["Identify the tables needed: Products, Order_Items, and Orders.", "Join Order_Items with Products to get product names.", "Join Orders to get customer information related to each order.", "Count distinct customers for each product ordered to avoid double counting.", "Group the results by product name to get the count of customers for each product."], "gold_sql": "SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name", "source_tables": ["orders", "products", "order_items"], "pred_sql": "SELECT T2.product_name, COUNT(DISTINCT T3.customer_id) AS customer_count \nFROM Order_Items AS T1 \nJOIN Products AS T2 ON T1.product_id = T2.product_id \nJOIN Orders AS T3 ON T3.order_id = T1.order_id \nGROUP BY T2.product_name", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total quantity of each product ordered from the 'Products' table by joining it with the 'Order_Items' and 'Orders' tables. The placeholder in the SELECT statement represents the product name, and the count function aggregates the total number of items ordered for each product.\",\n        \"virtual_table\": \"SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name\"\n    }\n}\n"}
{"sample_id": "train.2050", "db_id": "party_people", "question": "Which ministers are not a part of the Progress Party?", "rationale": ["Identify the relevant tables: We need to look at the 'member' table to find ministers and the 'party' table to identify the party they belong to.", "Join the 'member' table with the 'party' table on the Party_ID to access the party names associated with each member.", "Filter the results to exclude members who belong to the 'Progress Party' by using a WHERE clause that checks if the Party_name is not equal to 'Progress Party'.", "Select distinct member names to ensure that we do not have duplicate entries in the result."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT DISTINCT m.Member_Name \nFROM member AS m \nJOIN party AS p ON m.Party_ID = p.Party_ID \nWHERE p.Party_name != 'Progress Party';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.\",\n        \"virtual_table\": \"SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2057", "db_id": "party_people", "question": "Show all party names and the number of members in each party.", "rationale": ["Identify the tables needed: We need data from the 'party' table for party names and the 'member' table for counting members.", "Join the 'party' table with the 'member' table on the Party_ID to associate members with their respective parties.", "Use COUNT() function to count the number of members for each party.", "Group the results by party name to get the count of members for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT p.Party_name, COUNT(m.Member_ID) AS Number_of_Members\nFROM party AS p\nLEFT JOIN member AS m ON p.Party_ID = m.Party_ID\nGROUP BY p.Party_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.\",\n        \"virtual_table\": \"SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2072", "db_id": "party_people", "question": "How many events are there for each party?", "rationale": ["Identify the tables involved: We need to count events for each party, so we will use the 'party' and 'party_events' tables.", "Determine the relationship: The 'party' table has a unique identifier 'Party_ID' which is also present in the 'party_events' table, allowing us to join these tables.", "Construct the SQL query: We will use a LEFT JOIN to include all parties even if they have no events, and we will count the 'Event_ID' from the 'party_events' table.", "Group the results by 'Party_name' to get the count of events for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT party.Party_name, COUNT(party_events.Event_ID) AS Event_Count \nFROM party \nLEFT JOIN party_events ON party.Party_ID = party_events.Party_ID \nGROUP BY party.Party_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.\",\n        \"virtual_table\": \"SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the relevant tables: region, party, and party_events.", "Determine the relationship between the tables: region is linked to party via Region_ID, and party is linked to party_events via Party_ID.", "Filter the results based on the region name 'United Kingdom' and the event name 'Annual Meeting'.", "Construct the SQL query using a JOIN to combine the tables and a COUNT function to count the number of events."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.Region_ID = t2.Region_ID JOIN party_events AS t3 ON t2.Party_ID = t3.Party_ID WHERE t1.Region_name = 'United Kingdom' AND t3.Event_Name = 'Annual Meeting'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of party events that are associated with a specific region and event name. The placeholders in the WHERE clause represent the region's name and the event's name, allowing users to filter the results based on their input.\",\n        \"virtual_table\": \"SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2167", "db_id": "formula_1", "question": "What is the id and family name of the driver who has the longest laptime?", "rationale": ["We need to find the driver with the longest lap time, which means we will be looking at the lapTimes table.", "The lapTimes table contains the time taken to complete each lap for each driver in each race.", "To find the driver with the longest lap time, we will join the results table with the lapTimes table on raceId and driverId.", "We will then order the results by the lap time in descending order to get the longest lap time at the top.", "Finally, we will select the driverId and surname of the driver with the longest lap time by limiting the results to 1."], "gold_sql": "SELECT T1.driverid ,  T1.surname FROM drivers AS T1 JOIN laptimes AS T2 ON T1.driverid = T2.driverid ORDER BY T2.milliseconds DESC LIMIT 1", "source_tables": ["laptimes", "drivers"], "pred_sql": "SELECT driverId, surname FROM results JOIN lapTimes ON results.raceId = lapTimes.raceId AND results.driverId = lapTimes.driverId ORDER BY lapTimes.time DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2174", "db_id": "formula_1", "question": "How many drivers did not race in 2009?", "rationale": ["We need to find the number of drivers who did not race in 2009.", "To do this, we will first identify all drivers who participated in races during the year 2009.", "We can achieve this by joining the 'races' table with the 'results' table and then with the 'drivers' table, filtering for the year 2009.", "Next, we will use the 'NOT IN' clause to exclude these drivers from the total list of drivers.", "Finally, we will count the remaining drivers who did not participate in any race in 2009."], "gold_sql": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )", "source_tables": ["results", "races"], "pred_sql": "SELECT COUNT(*) FROM drivers WHERE driverId NOT IN (SELECT T3.driverId FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T1.year = 2009)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2179", "db_id": "formula_1", "question": "Find the id and forenames of drivers who participated both the races with name Australian Grand Prix and the races with name Chinese Grand Prix?", "rationale": ["Identify the races of interest: 'Australian Grand Prix' and 'Chinese Grand Prix'.", "Use the results table to find drivers who participated in these races by joining the races and results tables.", "To find drivers who participated in both races, use the INTERSECT operator to combine the results of two queries: one for the Australian Grand Prix and one for the Chinese Grand Prix.", "Select distinct driverId and forename from the results of both queries to ensure unique entries."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT DISTINCT T3.driverId, T3.forename \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nJOIN drivers AS T3 ON T2.driverId = T3.driverId \nWHERE T1.name = 'Australian Grand Prix' \nINTERSECT \nSELECT DISTINCT T3.driverId, T3.forename \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nJOIN drivers AS T3 ON T2.driverId = T3.driverId \nWHERE T1.name = 'Chinese Grand Prix';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2180", "db_id": "formula_1", "question": "What is the id and first name of all the drivers who participated in the Australian Grand Prix and the Chinese Grand Prix?", "rationale": ["Identify the races of interest: Australian Grand Prix and Chinese Grand Prix.", "Join the races table with the results table to link races to drivers.", "Join the drivers table to get the first names of the drivers.", "Filter the results to include only those drivers who participated in both races.", "Use GROUP BY to group the results by driver ID and first name.", "Use HAVING to ensure that only drivers who participated in both races are included (i.e., count of distinct race names should be 2)."], "gold_sql": "SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Australian Grand Prix' INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT DISTINCT T3.driverId, T3.forename \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nJOIN drivers AS T3 ON T2.driverId = T3.driverId \nWHERE T1.name IN ('Australian Grand Prix', 'Chinese Grand Prix') \nGROUP BY T3.driverId, T3.forename \nHAVING COUNT(DISTINCT T1.name) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the races of interest: Australian Grand Prix and Chinese Grand Prix.", "Use a JOIN to connect the races table with the results table to get the drivers for the Australian Grand Prix.", "Use another JOIN to connect the results table with the drivers table to get the first and last names of the drivers for the Australian Grand Prix.", "Use the EXCEPT clause to exclude drivers who participated in the Chinese Grand Prix by performing a similar JOIN operation for that race.", "Construct the final SQL query to select the first and last names of drivers from the Australian Grand Prix who are not in the Chinese Grand Prix."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT T3.forename, T3.surname \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nJOIN drivers AS T3 ON T2.driverId = T3.driverId \nWHERE T1.name = 'Australian Grand Prix' \nEXCEPT \nSELECT T3.forename, T3.surname \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nJOIN drivers AS T3 ON T2.driverId = T3.driverId \nWHERE T1.name = 'Chinese Grand Prix';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2190", "db_id": "formula_1", "question": "For each constructor id, how many races are there?", "rationale": ["Identify the relevant tables: We need to count the number of races for each constructor, so we will use the constructorResults table which contains raceId and constructorId.", "Use COUNT function: To count the number of races, we will use the COUNT() function on the raceId column.", "Group by constructorId: Since we want the count for each constructor, we will group the results by constructorId.", "Construct the SQL query: Combine the above elements into a complete SQL query."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(raceId) AS race_count FROM constructorResults GROUP BY constructorId;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2194", "db_id": "formula_1", "question": "What are the names of all races held after 2000 in Spain?", "rationale": ["Identify the relevant tables: 'races' for race details and 'circuits' for circuit details.", "We need to find races held after the year 2000, so we will filter the 'year' column in the 'races' table.", "We also need to filter the races that took place in Spain, which requires joining the 'races' table with the 'circuits' table on 'circuitId'.", "Select the 'name' of the races from the 'races' table after applying the filters for year and country."], "gold_sql": "SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = 'Spain' AND T1.year > 2000", "source_tables": ["races", "circuits"], "pred_sql": "SELECT T2.name FROM races AS T2 JOIN circuits AS T1 ON T2.circuitId = T1.circuitId WHERE T2.year > 2000 AND T1.country = 'Spain';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2217", "db_id": "formula_1", "question": "Find the names of Japanese constructors that have once earned more than 5 points?", "rationale": ["Identify the relevant tables: We need to find constructors and their points, so we will use the 'constructors' and 'constructorResults' tables.", "Determine the relationship: The 'constructorResults' table contains the points earned by constructors, and it has a foreign key 'constructorId' that links to the 'constructors' table.", "Filter for Japanese constructors: We need to add a condition to filter constructors based on their nationality being 'Japanese'.", "Set the points condition: We need to filter the results to only include constructors that have earned more than 5 points.", "Select distinct names: Since we want the names of the constructors, we will select the 'name' column from the 'constructors' table and use DISTINCT to avoid duplicates."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT DISTINCT constructors.name \nFROM constructors \nJOIN constructorResults ON constructors.constructorId = constructorResults.constructorId \nWHERE constructorResults.points > 5 \nAND constructors.nationality = 'Japanese';", "hint": "\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant table: The 'constructors' table contains information about constructors, including their names and nationality.", "Determine the conditions: We need to filter for constructors that are Japanese and have earned more than 5 points.", "Construct the SQL query: Use a SELECT statement to retrieve the names of constructors from the 'constructors' table where the nationality is 'Japanese' and points are greater than 5."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT name FROM constructors WHERE nationality = 'Japanese' AND points > 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, lapTimes, and circuits are needed to find the average fastest lap speed for a specific race.", "We need to join the races table with the lapTimes table on raceId to access the fastest lap speeds for each race.", "We also need to join the circuits table to filter for the Monaco Grand Prix by its name.", "The WHERE clause will filter for the specific race name 'Monaco' and the year 2008.", "Finally, we will use the AVG() function to calculate the average of the fastest lap speeds from the lapTimes table."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(lapTimes.fastestLapSpeed) AS average_fastest_lap_speed \nFROM races \nJOIN lapTimes ON races.raceId = lapTimes.raceId \nJOIN circuits ON races.circuitId = circuits.circuitId \nWHERE circuits.name = 'Monaco' AND races.year = 2008;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: lapTimes for fastest lap speed, races for race details, and circuits for circuit information.", "Join the lapTimes table with the races table on raceId to get race details for each lap time.", "Join the resulting table with the circuits table on circuitId to filter by the Monaco Grand Prix.", "Use a WHERE clause to specify the circuit name as 'Monaco' and the year as 2008.", "Select the maximum fastest lap speed from the filtered results."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(fastestLapSpeed) AS max_fastest_lap_speed \nFROM lapTimes AS LT \nJOIN races AS R ON LT.raceId = R.raceId \nJOIN circuits AS C ON R.circuitId = C.circuitId \nWHERE C.name = 'Monaco' AND R.year = 2008;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2223", "db_id": "formula_1", "question": "What are the maximum fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables: races and results are needed to get race names and fastest lap speeds.", "We need to filter races that occurred after 2004, so we will use a WHERE clause on the year column in the races table.", "To get the maximum fastest lap speed, we will use the MAX function on the fastestLapSpeed column from the results table.", "We will group the results by race name to get the maximum speed for each race.", "Finally, we will order the results by year to meet the requirement of the query."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT T1.name, MAX(T2.fastestLapSpeed) AS max_fastest_lap_speed \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nWHERE T1.year > 2004 \nGROUP BY T1.name \nORDER BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get race names, results, and fastest lap speeds.", "Join the races table with the results table on raceId to link races with their results.", "Join the results table with the lapTimes table on raceId and driverId to get the fastest lap speeds for each driver in each race.", "Filter the results to include only races that occurred after the year 2004.", "Group the results by race name and year to calculate the maximum fastest lap speed for each race.", "Select the race name and the maximum fastest lap speed, ordering the results by year."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races r\nJOIN results res ON r.raceId = res.raceId\nJOIN lapTimes l ON res.raceId = l.raceId AND res.driverId = l.driverId\nWHERE r.year > 2004\nGROUP BY r.name, r.year\nORDER BY r.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and years of races in which a specific driver participated, identified by their first name. The placeholders in the WHERE clause allow for filtering based on the driver's first name.\",\n        \"virtual_table\": \"SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2325", "db_id": "csu_1", "question": "What campuses are located in the county of Los Angeles?", "rationale": ["Identify the relevant table: The question asks about campuses, so we will focus on the 'Campuses' table.", "Determine the filtering condition: The question specifies that we are looking for campuses located in 'Los Angeles', which corresponds to the 'County' column in the 'Campuses' table.", "Construct the SQL query: We will select all columns from the 'Campuses' table where the 'County' is 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT * FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2347", "db_id": "csu_1", "question": "In what year was the most degrees conferred?", "rationale": ["The question asks for the year in which the most degrees were conferred.", "To find this, we need to count the number of degrees awarded for each year.", "We can use the 'degrees' table, which contains the 'Year' and 'Degrees' columns.", "We will group the results by 'Year' and count the number of degrees for each year using COUNT(Degrees).", "Next, we will order the results in descending order to get the year with the highest count of degrees first.", "Finally, we will limit the results to 1 to get only the year with the most degrees conferred."], "gold_sql": "SELECT YEAR FROM degrees GROUP BY YEAR ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Year FROM degrees GROUP BY Year ORDER BY COUNT(Degrees) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2348", "db_id": "csu_1", "question": "Which campus has the most degrees conferred in all times?", "rationale": ["Identify the relevant table for degrees awarded, which is the 'degrees' table.", "We need to count the total number of degrees conferred for each campus, so we will use the COUNT function on the 'Degrees' column.", "Group the results by 'Campus' to aggregate the counts for each campus.", "Order the results in descending order based on the total count of degrees to find the campus with the most degrees conferred.", "Limit the results to 1 to get only the campus with the highest count."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Campus, COUNT(Degrees) AS TotalDegrees FROM degrees GROUP BY Campus ORDER BY TotalDegrees DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2349", "db_id": "csu_1", "question": "What campus has the most degrees  conferrred over its entire existence?", "rationale": ["Identify the relevant table for degrees awarded, which is the 'degrees' table.", "Count the number of degrees awarded for each campus by using COUNT(Degrees).", "Group the results by campus to aggregate the degree counts.", "Order the results in descending order to find the campus with the most degrees awarded.", "Limit the results to 1 to get only the campus with the highest count."], "gold_sql": "SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT 1", "source_tables": ["degrees"], "pred_sql": "SELECT Campus, COUNT(Degrees) AS TotalDegrees\nFROM degrees\nGROUP BY Campus\nORDER BY TotalDegrees DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2351", "db_id": "csu_1", "question": "What campus has the most faculties in 2003?", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty'.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Filter the results to only include records from the year 2003.", "Order the results by the number of faculty members in descending order to get the campus with the most faculty.", "Limit the results to 1 to get only the campus with the highest number of faculty."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T1.Campus, T2.Faculty FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus WHERE T2.Year = 2003 ORDER BY T2.Faculty DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2358", "db_id": "csu_1", "question": "For each Orange county campus, report the number of degrees granted after 2000.", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to filter campuses located in Orange County, so we will use the County column from the Campuses table.", "We need to count the number of degrees granted after the year 2000, so we will filter the degrees table based on the Year column.", "We will join the Campuses table with the degrees table on the Campus identifier to associate campuses with their awarded degrees.", "Finally, we will group the results by campus to get the count of degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT COUNT(Degrees) AS NumberOfDegrees, Campuses.Campus \nFROM Campuses \nJOIN degrees ON Campuses.Id = degrees.Campus \nWHERE Campuses.County = 'Orange' AND degrees.Year > '2000' \nGROUP BY Campuses.Campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to count the total number of degrees granted after the year 2000, so we will use the COUNT function on the Degrees column from the degrees table.", "We need to filter the results to only include campuses located in Orange County, which is done by adding a WHERE clause that checks the County column in the Campuses table.", "We also need to filter the degrees to only include those awarded after the year 2000, which is done by adding another condition in the WHERE clause that checks the Year column in the degrees table.", "Finally, we group the results by the Campus name to get the total number of degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT C.Campus, COUNT(D.Degrees) AS TotalDegrees\nFROM Campuses C\nJOIN degrees D ON C.Id = D.Campus\nWHERE C.County = 'Orange' AND D.Year > '2000'\nGROUP BY C.Campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant table: The 'enrollments' table contains the total enrollment and full-time equivalent enrollment data.", "Specify the year of interest: We need to filter the data for the year 1956.", "Set the conditions for total enrollment and full-time enrollment: We want campuses with more than 400 total enrollments and more than 200 full-time equivalent enrollments.", "Construct the SQL query using the SELECT statement to retrieve the 'Campus' column from the 'enrollments' table, applying the specified filters."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT Campus FROM enrollments WHERE Year = '1956' AND TotalEnrollment_AY > 400 AND FTE_AY > 200;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2367", "db_id": "csu_1", "question": "What campuses are in Los Angeles county?", "rationale": ["Identify the relevant table: The question asks about campuses, so we will focus on the 'Campuses' table.", "Determine the filtering criteria: The question specifies 'Los Angeles county', which indicates we need to filter the results based on the 'County' column.", "Construct the SQL query: We will select all columns from the 'Campuses' table where the 'County' is 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT * FROM Campuses WHERE County = 'Los Angeles';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: 'degrees' for the degrees conferred and 'Campuses' for campus identification.", "Join the 'degrees' table with the 'Campuses' table on the campus identifier to filter by campus name.", "Filter the results for the specific campus 'San Jose State University' and the year '2000'.", "Count the number of degrees awarded in that year for the specified campus."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT COUNT(*) AS DegreesConferred \nFROM degrees AS D \nJOIN Campuses AS C ON D.Campus = C.Id \nWHERE C.Campus = 'San Jose State University' AND D.Year = '2000';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant tables: 'Campuses' for campus information, 'faculty' for faculty data, and 'degrees' to ensure the faculty data corresponds to the same year as degrees awarded.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier to get faculty data for each campus.", "Join the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded.", "Filter the results to only include data for 'San Francisco State University' and the year 2004.", "Select the number of faculty members from the joined tables."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T2.Faculty FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus JOIN degrees AS T3 ON T1.Id = T3.Campus AND T2.Year = T3.Year WHERE T1.Campus = 'San Francisco State University' AND T2.Year = 2004", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2378", "db_id": "csu_1", "question": "List the campus that have between 600 and 1000 faculty lines in year 2004.", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty'.", "We need to filter the faculty data for the year 2004, so we will use the 'Year' column from the 'faculty' table.", "We need to find campuses where the number of faculty members is between 600 and 1000, so we will use the 'Faculty' column from the 'faculty' table with a BETWEEN clause.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier to get the campus names along with their faculty counts.", "Select the 'Campus' column from the 'Campuses' table where the conditions are met."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T1.Campus FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus WHERE T2.Year = 2004 AND T2.Faculty BETWEEN 600 AND 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2379", "db_id": "csu_1", "question": "What are the campuses that had between 600 and 1000 faculty members in 2004?", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty'.", "We need to filter the faculty data for the year 2004, so we will use the 'Year' column from the 'faculty' table.", "We need to find campuses with faculty members between 600 and 1000, so we will use the 'Faculty' column from the 'faculty' table with a BETWEEN clause.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier to get the campus names along with their faculty counts.", "Select the 'Campus' from the 'Campuses' table where the conditions for year and faculty count are met."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  600 AND t2.faculty  <=  1000 AND T1.year  =  2004", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T1.Campus FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus WHERE T2.Year = 2004 AND T2.Faculty BETWEEN 600 AND 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2380", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the most number of degrees in year 2002?", "rationale": ["Identify the year of interest, which is 2002.", "Join the 'Campuses' table with the 'faculty' table to get the number of faculty members.", "Join the 'degrees' table to find out which campus conferred the most degrees in 2002.", "Filter the results to only include records from the year 2002.", "Order the results by the number of degrees awarded in descending order to get the campus with the most degrees.", "Limit the results to 1 to get only the campus with the highest number of degrees."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT T2.Faculty FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus JOIN degrees AS T3 ON T1.Id = T3.Campus AND T2.Year = T3.Year WHERE T2.Year = 2002 ORDER BY T3.Degrees DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the relevant tables: 'faculty' for faculty members and 'degrees' for the number of degrees awarded.", "Join the 'Campuses' table with 'faculty' and 'degrees' tables using the campus identifier.", "Filter the results for the year 2001 in the 'faculty' table.", "Order the results by the number of degrees awarded in ascending order to find the campus with the least degrees awarded.", "Limit the results to 1 to get only the campus with the least degrees awarded and its corresponding faculty count."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT T2.Faculty FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus JOIN degrees AS T3 ON T1.Id = T3.Campus AND T2.Year = T3.Year WHERE T2.Year = 2001 ORDER BY T3.Degrees ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "Determine the specific campus of interest, which is 'San Jose State'.", "Use a subquery to find the 'Id' of 'San Jose State' from the 'Campuses' table.", "Construct the SQL query to select the 'Undergraduate' column from 'discipline_enrollments' where the 'Campus' matches the 'Id' of 'San Jose State'."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT Undergraduate FROM discipline_enrollments WHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Jose State')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for campuses that have awarded degrees in a specific year. The query joins the 'campuses' table with the 'faculty' and 'degrees' tables based on the campus identifier and filters the results for a particular year. The placeholders in the WHERE clause represent the year of interest and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to associate campuses with their respective faculty data and also joins the 'degrees' table to ensure that the faculty data corresponds to the same year as the degrees awarded. The placeholders in the WHERE clause represent the year of interest and the limit on the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3131", "db_id": "assets_maintenance", "question": "Which engineer has visited the most times? Show the engineer id, first name and last name.", "rationale": ["Identify the relevant tables: Engineer_Visits and Maintenance_Engineers.", "We need to count the number of visits for each engineer, so we will use COUNT(*) to aggregate the visits.", "Join the Engineer_Visits table with the Maintenance_Engineers table on the engineer_id to get the first and last names of the engineers.", "Group the results by engineer_id, first_name, and last_name to get the count of visits for each engineer.", "Order the results by the visit count in descending order to find the engineer with the most visits.", "Limit the results to 1 to get only the engineer with the highest visit count."], "gold_sql": "SELECT T1.engineer_id ,  T1.first_name ,  T1.last_name FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2 GROUP BY T1.engineer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["maintenance_engineers", "engineer_visits"], "pred_sql": "SELECT engineer_id, first_name, last_name, COUNT(*) as visit_count\nFROM Engineer_Visits\nJOIN Maintenance_Engineers ON Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id\nGROUP BY engineer_id, first_name, last_name\nORDER BY visit_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3139", "db_id": "assets_maintenance", "question": "How many fault status codes are recorded in the fault log parts table?", "rationale": ["The question asks for the number of distinct fault status codes recorded in the Fault_Log_Parts table.", "To find the distinct fault status codes, we will use the COUNT function along with the DISTINCT keyword.", "We will select the fault_status column from the Fault_Log_Parts table to count the unique values.", "The final SQL query will count the distinct fault status codes and return that count."], "gold_sql": "SELECT DISTINCT fault_status FROM Fault_Log_Parts", "source_tables": ["fault_log_parts"], "pred_sql": "SELECT COUNT(DISTINCT fault_status) AS fault_status_count FROM Fault_Log_Parts;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of fault short names along with their corresponding skill descriptions required to fix those faults. The data is sourced from the 'Part_Faults' table, which contains information about faults related to parts, and is joined with the 'Skills_Required_To_Fix' table to identify the necessary skills, and the 'Skills' table to get detailed descriptions of those skills.\",\n        \"virtual_table\": \"SELECT T1.fault_short_name ,  T3.skill_description FROM Part_Faults AS T1 JOIN Skills_Required_To_Fix AS T2 ON T1.part_fault_id  =  T2.part_fault_id JOIN Skills AS T3 ON T2.skill_id  =  T3.skill_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes assets that have a specific number of associated parts and a lesser number of recorded faults. The placeholders in the HAVING clauses represent the numeric values for the counts of parts and faults.\",\n        \"virtual_table\": \"SELECT T1.asset_id ,  T1.asset_details FROM Assets AS T1 JOIN Asset_Parts AS T2 ON T1.asset_id  =  T2.asset_id GROUP BY T1.asset_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.asset_id ,  T1.asset_details FROM Assets AS T1 JOIN Fault_Log AS T2 ON T1.asset_id  =  T2.asset_id GROUP BY T1.asset_id HAVING count(*)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3143", "db_id": "assets_maintenance", "question": "Which part fault requires the most number of skills to fix? List part id and name.", "rationale": ["Identify the relevant tables: Part_Faults and Skills_Required_To_Fix are needed to find part faults and their required skills.", "Join the Part_Faults table with the Skills_Required_To_Fix table to associate each part fault with its required skills.", "Group the results by part_id to count the number of skills required for each part fault.", "Order the results in descending order based on the count of skills to find the part fault that requires the most skills.", "Limit the results to 1 to get only the part fault with the highest number of required skills."], "gold_sql": "SELECT T1.part_id ,  T1.part_name FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id  =  T2.part_id JOIN Skills_Required_To_Fix AS T3 ON T2.part_fault_id  =  T3.part_fault_id GROUP BY T1.part_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["part_faults", "parts", "skills_required_to_fix"], "pred_sql": "SELECT T1.part_id, T2.part_name\nFROM Part_Faults AS T1\nJOIN Skills_Required_To_Fix AS T2 ON T1.part_fault_id = T2.part_fault_id\nGROUP BY T1.part_id\nORDER BY COUNT(T2.skill_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of fault short names along with their corresponding skill descriptions required to fix those faults. The data is sourced from the 'Part_Faults' table, which contains information about faults related to parts, and is joined with the 'Skills_Required_To_Fix' table to identify the necessary skills, and the 'Skills' table to get detailed descriptions of those skills.\",\n        \"virtual_table\": \"SELECT T1.fault_short_name ,  T3.skill_description FROM Part_Faults AS T1 JOIN Skills_Required_To_Fix AS T2 ON T1.part_fault_id  =  T2.part_fault_id JOIN Skills AS T3 ON T2.skill_id  =  T3.skill_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes assets that have a specific number of associated parts and a lesser number of recorded faults. The placeholders in the HAVING clauses represent the numeric values for the counts of parts and faults.\",\n        \"virtual_table\": \"SELECT T1.asset_id ,  T1.asset_details FROM Assets AS T1 JOIN Asset_Parts AS T2 ON T1.asset_id  =  T2.asset_id GROUP BY T1.asset_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.asset_id ,  T1.asset_details FROM Assets AS T1 JOIN Fault_Log AS T2 ON T1.asset_id  =  T2.asset_id GROUP BY T1.asset_id HAVING count(*)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and PROFESSOR.", "We need to count the number of distinct professors teaching a specific class, so we will use COUNT(DISTINCT p.EMP_NUM).", "Join the CLASS table with the PROFESSOR table on the common key PROF_NUM.", "Filter the results to only include the class with the code 'ACCT-211'.", "Construct the SQL query to select the count of distinct professors for the specified class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS ProfessorCount\nFROM CLASS c\nJOIN PROFESSOR p ON c.PROF_NUM = p.EMP_NUM\nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "\n"}
{"sample_id": "train.3180", "db_id": "college_1", "question": "What are the first names and birthdates of the professors in charge of ACCT-211?", "rationale": ["Identify the relevant tables: CLASS, PROFESSOR, and EMPLOYEE are needed to get the first names and birthdates of professors.", "Join the CLASS table with the PROFESSOR table on the PROF_NUM to get the professors for each class.", "Join the PROFESSOR table with the EMPLOYEE table to access the first names and birthdates of the professors.", "Filter the results to only include classes with the course code 'ACCT-211'.", "Select the first names and birthdates of the professors from the joined tables."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, EMPLOYEE.EMP_DOB \nFROM CLASS \nJOIN PROFESSOR ON CLASS.PROF_NUM = PROFESSOR.EMP_NUM \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nWHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n        \"virtual_table\": \"SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\",\n        \"virtual_table\": \"SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3189", "db_id": "college_1", "question": "How many different locations does the school with code BUS has?", "rationale": ["Identify the table that contains the location information, which is the DEPARTMENT table.", "We need to count the distinct addresses (DEPT_ADDRESS) to find out how many different locations there are.", "We filter the results to only include departments that belong to the school with the code 'BUS'.", "The SQL query uses COUNT(DISTINCT ...) to ensure we only count unique addresses."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT COUNT(DISTINCT DEPT_ADDRESS) AS different_locations\nFROM DEPARTMENT\nWHERE SCHOOL_CODE = 'BUS';", "hint": "\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the table that contains the school locations, which is the DEPARTMENT table.", "Determine the relevant column for the school code, which is SCHOOL_CODE in the DEPARTMENT table.", "Use the DISTINCT keyword to ensure unique locations are retrieved.", "Construct the SQL query to select DEPT_ADDRESS from the DEPARTMENT table where the SCHOOL_CODE is 'BUS'."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n        \"virtual_table\": \"SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3206", "db_id": "college_1", "question": "How many classes are held in each department?", "rationale": ["We need to count the number of classes held in each department.", "To do this, we will join the DEPARTMENT table with the COURSE table using the DEPT_CODE.", "Next, we will join the resulting table with the CLASS table using the CRS_CODE to link classes to their respective courses.", "We will then group the results by department name to get the count of classes for each department.", "Finally, we will use the COUNT function to count the number of CLASS_CODE entries for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"], "pred_sql": "SELECT D.DEPT_NAME, COUNT(C.CLASS_CODE) AS CLASS_COUNT \nFROM DEPARTMENT D \nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE \nJOIN CLASS CL ON C.CRS_CODE = CL.CRS_CODE \nGROUP BY D.DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\",\n        \"virtual_table\": \"SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3209", "db_id": "college_1", "question": "What is the number of professors for different school?", "rationale": ["Identify the relevant tables: DEPARTMENT and PROFESSOR.", "We need to count the number of professors, so we will use the COUNT() function.", "To get the number of professors per school, we need to group the results by SCHOOL_CODE.", "Join the DEPARTMENT table with the PROFESSOR table on DEPT_CODE to link professors to their respective departments.", "Select the SCHOOL_CODE and the count of professors, using GROUP BY to aggregate the results."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "pred_sql": "SELECT SCHOOL_CODE, COUNT(*) AS NUMBER_OF_PROFESSORS\nFROM DEPARTMENT\nJOIN PROFESSOR ON DEPARTMENT.DEPT_CODE = PROFESSOR.DEPT_CODE\nGROUP BY SCHOOL_CODE;", "hint": "\n"}
{"sample_id": "train.3210", "db_id": "college_1", "question": "How many different professors are there for the different schools?", "rationale": ["We need to count the number of different professors associated with different schools.", "To do this, we will use the PROFESSOR table to get the unique professors and the DEPARTMENT table to link professors to their respective schools.", "We will perform a JOIN between the PROFESSOR and DEPARTMENT tables on the DEPT_CODE column.", "We will use COUNT(DISTINCT PROFESSOR.EMP_NUM) to count the unique professors.", "Finally, we will group the results by SCHOOL_CODE to ensure we are counting professors per school."], "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"], "pred_sql": "SELECT COUNT(DISTINCT PROFESSOR.EMP_NUM) AS different_professors\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.SCHOOL_CODE;", "hint": "\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["We need to find the number of students for each department, which involves counting students grouped by their department.", "The relevant tables are DEPARTMENT and STUDENT, as we need to get department names and the count of students in each department.", "We will use a LEFT JOIN to connect the DEPARTMENT table with the STUDENT table on the DEPT_CODE, ensuring we include departments even if they have no students.", "We will use the COUNT function to count the number of students (STU_NUM) for each department.", "Finally, we will group the results by DEPARTMENT.DEPT_NAME to get the count for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(STUDENT.STU_NUM) AS NUM_STUDENTS\nFROM DEPARTMENT\nLEFT JOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "\n"}
{"sample_id": "train.3218", "db_id": "college_1", "question": "How many students are in each department?", "rationale": ["We need to count the number of students in each department.", "To do this, we will join the DEPARTMENT table with the COURSE table to get the courses offered by each department.", "Next, we will join the CLASS table to link classes to their respective courses.", "Then, we will join the ENROLL table to find out which students are enrolled in those classes.", "Finally, we will join the STUDENT table to get the student information and count the number of students per department.", "We will group the results by department name to get the count of students in each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT D.DEPT_NAME, COUNT(S.STU_NUM) AS STUDENT_COUNT \nFROM DEPARTMENT D \nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE \nJOIN CLASS CL ON C.CRS_CODE = CL.CRS_CODE \nJOIN ENROLL E ON CL.CLASS_CODE = E.CLASS_CODE \nJOIN STUDENT S ON E.STU_NUM = S.STU_NUM \nGROUP BY D.DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\",\n        \"virtual_table\": \"SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3220", "db_id": "college_1", "question": "How many hours do the students spend studying in each department?", "rationale": ["Identify the relevant tables: DEPARTMENT, COURSE, CLASS, ENROLL, and STUDENT.", "Join the DEPARTMENT table with the COURSE table on DEPT_CODE to get the courses offered by each department.", "Join the COURSE table with the CLASS table on CRS_CODE to link courses to their respective classes.", "Join the CLASS table with the ENROLL table on CLASS_CODE to find out which students are enrolled in those classes.", "Join the ENROLL table with the STUDENT table on STU_NUM to get the students' information.", "Use SUM to calculate the total credit hours (CRS_CREDIT) for each department.", "Group the results by department name (DEPT_NAME) to get the total hours spent studying in each department.", "Order the results by the total hours in descending order to see which department has the most hours."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT D.DEPT_NAME, SUM(C.CRS_CREDIT) AS TOTAL_HOURS\nFROM DEPARTMENT D\nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE\nJOIN CLASS CL ON C.CRS_CODE = CL.CRS_CODE\nJOIN ENROLL E ON CL.CLASS_CODE = E.CLASS_CODE\nJOIN STUDENT S ON E.STU_NUM = S.STU_NUM\nGROUP BY D.DEPT_NAME\nORDER BY TOTAL_HOURS DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\",\n        \"virtual_table\": \"SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3222", "db_id": "college_1", "question": "What is the highest, lowest, and average student GPA for every department?", "rationale": ["Identify the required information: highest, lowest, and average GPA for students, grouped by department.", "Determine the relevant tables: DEPARTMENT for department names and STUDENT for GPA data.", "Join the DEPARTMENT and STUDENT tables on the DEPT_CODE to associate students with their respective departments.", "Use aggregate functions: MAX() for highest GPA, MIN() for lowest GPA, and AVG() for average GPA.", "Group the results by department name to get the statistics for each department."], "gold_sql": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, \n       MAX(STUDENT.STU_GPA) AS Highest_GPA, \n       MIN(STUDENT.STU_GPA) AS Lowest_GPA, \n       AVG(STUDENT.STU_GPA) AS Average_GPA \nFROM DEPARTMENT \nJOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE \nGROUP BY DEPARTMENT.DEPT_NAME;", "hint": "\n"}
{"sample_id": "train.3234", "db_id": "college_1", "question": "How many courses does the department of Computer Information Systmes offer?", "rationale": ["Identify the department of Computer Information Systems in the DEPARTMENT table to get its DEPT_CODE.", "Use the DEPT_CODE obtained to filter the COURSE table to count how many courses are offered by that department."], "gold_sql": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "department"], "pred_sql": "SELECT COUNT(*) FROM COURSE WHERE DEPT_CODE = (SELECT DEPT_CODE FROM DEPARTMENT WHERE DEPT_NAME = 'Computer Information Systems')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\",\n        \"virtual_table\": \"SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3238", "db_id": "college_1", "question": "What are the total number of credits offered by each department?", "rationale": ["Identify the tables needed: COURSE, CLASS, and DEPARTMENT are required to get the total credits offered by each department.", "Join the COURSE table with the CLASS table on CRS_CODE to link courses to their respective classes.", "Join the resulting table with the DEPARTMENT table on DEPT_CODE to retrieve department names.", "Use SUM() function to calculate the total credits for each department based on the CRS_CREDIT from the COURSE table.", "Group the results by DEPT_CODE to aggregate the total credits for each department.", "Order the results by the total credits in descending order to see which department offers the most credits."], "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"], "pred_sql": "SELECT T3.DEPT_NAME, SUM(T1.CRS_CREDIT) AS TOTAL_CREDITS \nFROM COURSE AS T1 \nJOIN CLASS AS T2 ON T1.CRS_CODE = T2.CRS_CODE \nJOIN DEPARTMENT AS T3 ON T1.DEPT_CODE = T3.DEPT_CODE \nGROUP BY T1.DEPT_CODE \nORDER BY TOTAL_CREDITS DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\",\n        \"virtual_table\": \"SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the tables involved: CLASS, ENROLL, and STUDENT are needed to get the first names of students enrolled in a specific class.", "Determine the relationship between the tables: CLASS is linked to ENROLL through CLASS_CODE, and ENROLL is linked to STUDENT through STU_NUM.", "Specify the course code: The question asks for students enrolled in class ACCT-211, so we will filter by CRS_CODE = 'ACCT-211'.", "Construct the SQL query using JOINs to connect the tables and select the first names of the students."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN ENROLL AS T2 ON T1.CLASS_CODE = T2.CLASS_CODE JOIN STUDENT AS T3 ON T2.STU_NUM = T3.STU_NUM WHERE T1.CRS_CODE = 'ACCT-211'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n        \"virtual_table\": \"SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3253", "db_id": "college_1", "question": "What is the name of the department that has the largest number of students enrolled?", "rationale": ["Identify the department with the largest number of students enrolled.", "To do this, we need to count the number of students in each department.", "We can achieve this by grouping the students by their department code (DEPT_CODE) and counting the number of students (STU_NUM) in each group.", "We will then order these counts in descending order to find the department with the most students.", "Finally, we will select the department name (DEPT_NAME) corresponding to the department code that has the highest count of students."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT dept_name FROM department WHERE dept_code IN (SELECT dept_code FROM student GROUP BY dept_code ORDER BY COUNT(stu_num) DESC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["Identify the department with the most students enrolled.", "To do this, we need to count the number of students in each department.", "We can achieve this by grouping the students by their department code.", "We will use the COUNT function to count the number of students in each department.", "Next, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to only the top department (the one with the most students).", "We will select the department name from the department table using the department code obtained from the previous query."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT dept_name FROM department WHERE dept_code IN (SELECT dept_code FROM student GROUP BY dept_code ORDER BY COUNT(stu_num) DESC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including the room where they are held and the course code associated with each class.", "Determine the required columns: We need the CRS_CODE of the courses located in room KLR209.", "Construct the SQL query: Use a SELECT statement to retrieve the distinct CRS_CODE from the CLASS table where the CLASS_ROOM matches 'KLR209'.", "Use DISTINCT to ensure that each course code is listed only once, even if multiple classes are held in the same room."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CRS_CODE FROM CLASS WHERE CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n        \"virtual_table\": \"SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the tables involved: ENROLL, CLASS, and STUDENT are relevant for this query.", "We need to find students who received a grade of 'C', so we will filter the ENROLL table based on the ENROLL_GRADE column.", "To get the first names of the students, we will select the STU_FNAME column from the STUDENT table.", "We will join the ENROLL table with the CLASS table on CLASS_CODE to link the enrollments to specific classes.", "We will also join the STUDENT table on STU_NUM to get the student details for those who received a grade of 'C'.", "The final SQL query will select the first names of students who got a grade of 'C' in any class."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT T3.STU_FNAME FROM ENROLL AS T2 JOIN CLASS AS T1 ON T1.CLASS_CODE = T2.CLASS_CODE JOIN STUDENT AS T3 ON T2.STU_NUM = T3.STU_NUM WHERE T2.ENROLL_GRADE = 'C'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n        \"virtual_table\": \"SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["We need to find the first names of professors who do not teach any class.", "To do this, we will use a LEFT JOIN between the EMPLOYEE table and the PROFESSOR table to get all professors.", "Next, we will perform another LEFT JOIN with the CLASS table to find out if these professors are associated with any classes.", "In the WHERE clause, we will check for NULL values in the CLASS.CLASS_CODE, which indicates that the professor does not teach any class."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nLEFT JOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nLEFT JOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CLASS_CODE IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\",\n        \"virtual_table\": \"SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n        \"virtual_table\": \"SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the relevant tables: We need to find professors and their teaching status, so we will use the PROFESSOR and CLASS tables.", "We need the first names of professors, which are in the EMPLOYEE table, linked to the PROFESSOR table by EMP_NUM.", "To find professors not teaching any classes, we can use a subquery to select PROF_NUM from the CLASS table.", "The main query will select EMP_FNAME from the EMPLOYEE table where EMP_NUM is not in the list of PROF_NUM from the CLASS table."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME FROM EMPLOYEE WHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\",\n        \"virtual_table\": \"SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the relevant table: The 'professor' table contains information about professors, including their highest degree obtained.", "Determine the condition: We need to count professors who have either a Ph.D. or a Masters degree.", "Use the COUNT function: To get the total number of professors meeting the criteria, we will use the COUNT(*) function.", "Construct the SQL query: The final SQL query will select the count of professors from the 'professor' table where the 'prof_high_degree' is either 'Ph.D.' or 'Masters'."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) FROM professor WHERE prof_high_degree IN ('Ph.D.', 'Masters')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\",\n        \"virtual_table\": \"SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the requirement: We need the first names of students enrolled in classes from two specific departments: Accounting and Computer Info. Systems.", "Use the provided hint to create a virtual table that selects student first names based on department enrollment.", "The hint suggests using an INTERSECT operation to find students enrolled in classes from both departments.", "Construct the first part of the query to select students from the Accounting department.", "Construct the second part of the query to select students from the Computer Info. Systems department.", "Combine both parts using the INTERSECT operator to ensure only students enrolled in both departments are returned."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT T1.stu_fname \nFROM student AS T1 \nJOIN enroll AS T2 ON T1.stu_num = T2.stu_num \nJOIN CLASS AS T3 ON T2.class_code = T3.class_code \nJOIN course AS T4 ON T3.crs_code = T4.crs_code \nJOIN department AS T5 ON T5.dept_code = T4.dept_code \nWHERE T5.dept_name = 'Accounting' \nINTERSECT \nSELECT T1.stu_fname \nFROM student AS T1 \nJOIN enroll AS T2 ON T1.stu_num = T2.stu_num \nJOIN CLASS AS T3 ON T2.class_code = T3.class_code \nJOIN course AS T4 ON T3.crs_code = T4.crs_code \nJOIN department AS T5 ON T5.dept_code = T4.dept_code \nWHERE T5.dept_name = 'Computer Info. Systems'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n        \"virtual_table\": \"SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3300", "db_id": "college_1", "question": "What is the name of the department with the student that has the lowest GPA?", "rationale": ["Identify the department associated with the student who has the lowest GPA.", "To find the student with the lowest GPA, we can use a subquery that selects the minimum GPA from the STUDENT table.", "We then join the DEPARTMENT table with the STUDENT table on the DEPT_CODE to get the department name for the student with the lowest GPA.", "The final query selects the DEPT_NAME from the DEPARTMENT table where the student's GPA matches the minimum GPA found in the subquery."], "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"], "pred_sql": "SELECT D.DEPT_NAME \nFROM DEPARTMENT D \nJOIN STUDENT S ON D.DEPT_CODE = S.DEPT_CODE \nWHERE S.STU_GPA = (SELECT MIN(STU_GPA) FROM STUDENT)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n        \"virtual_table\": \"SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3314", "db_id": "college_1", "question": "What are the first names, office locations of all lecturers who have taught some course?", "rationale": ["Identify the tables needed: EMPLOYEE for first names and PROFESSOR for office locations.", "Join the EMPLOYEE table with the PROFESSOR table on the EMP_NUM column to link employees with their professor roles.", "Select the first names (EMP_FNAME) from the EMPLOYEE table and the office locations (PROF_OFFICE) from the PROFESSOR table.", "No additional filtering is needed since we want all lecturers who have taught some course."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num", "source_tables": ["course", "employee", "professor", "class"], "pred_sql": "SELECT T1.EMP_FNAME, T2.PROF_OFFICE FROM EMPLOYEE AS T1 JOIN PROFESSOR AS T2 ON T1.EMP_NUM = T2.EMP_NUM", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\",\n        \"virtual_table\": \"SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students enrolled in classes associated with a specific course code and who have received a particular grade. The placeholders in the WHERE clause represent the course code and the grade received by the students.\",\n        \"virtual_table\": \"SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.enroll_grade  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3315", "db_id": "college_1", "question": "Find the first names and offices of all instructors who have taught some course and the course description and the department name.", "rationale": ["Identify the required fields: first names of instructors (from EMPLOYEE), office locations (from PROFESSOR), course descriptions (from COURSE), and department names (from DEPARTMENT).", "Determine the necessary tables to join: EMPLOYEE, PROFESSOR, CLASS, COURSE, and DEPARTMENT.", "Establish the relationships between the tables: EMPLOYEE is linked to PROFESSOR via EMP_NUM, PROFESSOR is linked to CLASS via PROF_NUM, CLASS is linked to COURSE via CRS_CODE, and COURSE is linked to DEPARTMENT via DEPT_CODE.", "Construct the SQL query using JOIN statements to combine the relevant tables and select the required fields."], "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code", "source_tables": ["course", "department", "professor", "class", "employee"], "pred_sql": "SELECT E.EMP_FNAME, P.PROF_OFFICE, C.CRS_DESCRIPTION, D.DEPT_NAME \nFROM EMPLOYEE AS E \nJOIN PROFESSOR AS P ON E.EMP_NUM = P.EMP_NUM \nJOIN CLASS AS CL ON P.EMP_NUM = CL.PROF_NUM \nJOIN COURSE AS C ON CL.CRS_CODE = C.CRS_CODE \nJOIN DEPARTMENT AS D ON C.DEPT_CODE = D.DEPT_CODE;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names of employees and the office locations of professors from the 'employee' and 'professor' tables, respectively. It filters the results based on a specific department name and the highest degree obtained by the professors, both represented by placeholders for string values.\",\n        \"virtual_table\": \"SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  [PLACEHOLDER-TYPE:STRING] AND T2.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: We need to find the department name associated with classes that have a specific course description.", "The relevant tables are COURSE, CLASS, and DEPARTMENT.", "Join the COURSE table with the CLASS table on the CRS_CODE to link courses to their classes.", "Join the resulting table with the DEPARTMENT table on the DEPT_CODE to get the department names.", "Filter the results where the course description contains the word 'Statistics' using the LIKE operator."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT DISTINCT D.DEPT_NAME \nFROM COURSE AS C \nJOIN CLASS AS CL ON C.CRS_CODE = CL.CRS_CODE \nJOIN DEPARTMENT AS D ON C.DEPT_CODE = D.DEPT_CODE \nWHERE C.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names from the 'DEPARTMENT' table, which are associated with courses from the 'COURSE' table. The query joins the 'COURSE' and 'CLASS' tables to link courses to their respective classes, and then joins the 'DEPARTMENT' table to retrieve the department names. The results are grouped by department code and ordered by the total sum of credit hours for the courses in descending order, with a limit on the number of departments returned as specified by a placeholder.\",\n        \"virtual_table\": \"SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the name of the department.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3417", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M.", "rationale": ["Identify the required fields: first name, last name, hire date, salary, and department number.", "The salary is not needed in the final output as per the user's request, so we will exclude it.", "We need to filter employees whose first name does not contain the letter 'M'.", "Use the NOT LIKE operator to filter out first names containing 'M'.", "Construct the SQL query to select the specified fields from the employees table with the appropriate WHERE clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, hire_date, department_id FROM employees WHERE first_name NOT LIKE '%M%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (first and last name), hire date, salary, and department id.", "To get the full name, concatenate first_name and last_name with a space in between.", "Filter employees whose first name does not contain the letter 'M'.", "Use the WHERE clause with NOT LIKE '%M%' to exclude those names.", "Select from the employees table since all required information is contained within it."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name, hire_date, salary, department_id FROM employees WHERE first_name NOT LIKE '%M%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department number.", "To get the full name, concatenate first_name and last_name using '||'.", "Filter employees whose first name does not contain the letter 'M' using the NOT LIKE operator.", "Sort the results in ascending order by department number using ORDER BY.", "Construct the SQL query using the SELECT statement with the identified fields and conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name, hire_date, salary, department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The question pertains to job titles and salaries, so we will focus on the 'jobs' table.", "Determine the condition: We need to find jobs with salaries over 9000, which refers to the 'MAX_SALARY' column in the 'jobs' table.", "Construct the SQL query: We will select the 'JOB_TITLE' from the 'jobs' table where the 'MAX_SALARY' is greater than 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MAX_SALARY > 9000;", "hint": "\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question asks for job titles and salary ranges, which are found in the 'jobs' table.", "Determine the columns needed: We need 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY' from the 'jobs' table.", "Apply the condition: The question specifies that we want jobs with a maximum salary between 12000 and 18000, so we will use a WHERE clause to filter the results based on 'MAX_SALARY'.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE condition to form the complete SQL query."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY \nFROM jobs \nWHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["We need to find the employee IDs and the final dates of employment for each employee.", "The relevant tables are 'employees' and 'job_history'.", "We will join the 'employees' table with the 'job_history' table on the EMPLOYEE_ID.", "To get the final date of employment, we need to find the maximum END_DATE for each employee in the job_history table.", "We can use a subquery to get the maximum END_DATE for each employee and filter the results accordingly."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT e.EMPLOYEE_ID, j.END_DATE\nFROM employees e\nJOIN job_history j ON e.EMPLOYEE_ID = j.EMPLOYEE_ID\nWHERE j.END_DATE = (SELECT MAX(END_DATE) FROM job_history WHERE EMPLOYEE_ID = e.EMPLOYEE_ID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3451", "db_id": "hr_1", "question": "Find the ids of the departments where any manager is managing 4 or more employees.", "rationale": ["We need to find departments where any manager is managing 4 or more employees.", "To do this, we will first identify the managers who have 4 or more employees. We can achieve this by grouping the employees by their manager_id and counting the number of employees for each manager.", "Using the HAVING clause, we can filter out those managers who manage less than 4 employees.", "Once we have the list of manager_ids that manage 4 or more employees, we can then find the corresponding department_ids from the departments table where the manager_id matches those identified in the previous step."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT department_id FROM departments WHERE manager_id IN (SELECT manager_id FROM employees GROUP BY manager_id HAVING COUNT(employee_id) >= 4)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3457", "db_id": "hr_1", "question": "display job ID for those jobs that were done by two or more for more than 300 days.", "rationale": ["We need to find job IDs for jobs that were done by two or more employees for more than 300 days.", "To achieve this, we will use the 'job_history' table which contains records of jobs held by employees along with their start and end dates.", "We will group the results by 'job_id' to aggregate the data for each job.", "We will use the COUNT function to count the number of employees (employee_id) for each job_id and filter for those with 2 or more employees using HAVING COUNT(employee_id) >= 2.", "Next, we will calculate the total duration of each job by subtracting the start date from the end date using the julianday function, and we will sum these durations for each job_id.", "Finally, we will filter for jobs where the total duration is greater than 300 days using HAVING SUM(julianday(end_date) - julianday(start_date)) > 300."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "pred_sql": "SELECT job_id FROM job_history GROUP BY job_id HAVING COUNT(employee_id) >= 2 AND SUM(julianday(end_date) - julianday(start_date)) > 300;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3458", "db_id": "hr_1", "question": "What are the job ids for jobs done more than once for a period of more than 300 days?", "rationale": ["We need to find job ids for jobs that have been done more than once.", "This means we need to group the records in the job_history table by job_id.", "To find jobs done more than once, we can use the COUNT function and filter with HAVING COUNT(*) > 1.", "Next, we need to check the duration of each job held by an employee.", "We can calculate the duration by subtracting the start_date from the end_date using the julianday function.", "We need to sum these durations for each job_id and filter with HAVING SUM(duration) > 300, where duration is in days.", "Combining these conditions, we can construct the SQL query."], "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"], "pred_sql": "SELECT job_id FROM job_history GROUP BY job_id HAVING COUNT(*) > 1 AND SUM(julianday(end_date) - julianday(start_date)) > 300;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3463", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "To get the department name, we will select it from the 'departments' table.", "To count the number of employees in each department, we will use the 'employees' table and count the 'EMPLOYEE_ID'.", "We will perform a LEFT JOIN between the 'departments' table and the 'employees' table on the 'DEPARTMENT_ID' to ensure we get all departments even if they have no employees.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count of employees for each department."], "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES \nFROM departments AS d \nLEFT JOIN employees AS e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3470", "db_id": "hr_1", "question": "Provide the full names of employees earning more than the employee with id 163.", "rationale": ["Identify the requirement: We need to find the full names of employees earning more than the employee with ID 163.", "To achieve this, we will need to select the first and last names from the 'employees' table.", "We will also need to compare the salaries of these employees to the salary of the employee with ID 163.", "To get the salary of the employee with ID 163, we will use a subquery that selects the salary from the 'employees' table where the employee_id is 163.", "The main query will select the first and last names of employees whose salary is greater than the result of the subquery."], "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = 163 )", "source_tables": ["employees"], "pred_sql": "SELECT T1.first_name, T1.last_name \nFROM employees AS T1 \nWHERE T1.salary > (SELECT salary FROM employees WHERE employee_id = 163)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3471", "db_id": "hr_1", "question": "return the smallest salary for every departments.", "rationale": ["We need to find the smallest salary for every department.", "To do this, we will use the 'employees' table, which contains salary information and department IDs.", "We will use the MIN() function to get the smallest salary for each department.", "We will group the results by 'department_id' to ensure we get the minimum salary for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT department_id, MIN(salary) AS smallest_salary FROM employees GROUP BY department_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3472", "db_id": "hr_1", "question": "What is the minimum salary in each department?", "rationale": ["We need to find the minimum salary in each department.", "To do this, we will select the department ID and the minimum salary from the employees table.", "We will join the employees table with the departments table on the DEPARTMENT_ID to associate employees with their respective departments.", "We will use the MIN() function to calculate the minimum salary for each department.", "Finally, we will group the results by DEPARTMENT_ID to get the minimum salary for each department."], "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, MIN(e.SALARY) AS MIN_SALARY\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the employees who are managers by checking the MANAGER_ID in the employees table.", "Use a subquery to find distinct MANAGER_IDs from the employees table, which indicates the employees who are managers.", "Join the employees table with departments, locations, and countries to get the required information about these managers.", "Select the first name, last name, employee ID, and country name of the employees who are managers."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT T1.first_name, T1.last_name, T1.employee_id, T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id JOIN locations AS T3 ON T2.location_id = T3.location_id JOIN countries AS T4 ON T3.country_id = T4.country_id WHERE T1.employee_id IN (SELECT DISTINCT MANAGER_ID FROM employees WHERE MANAGER_ID IS NOT NULL)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department ids where a manager oversees 4 or more employees.", "To do this, we first need to identify managers who have 4 or more employees reporting to them. We can achieve this by grouping the employees by their manager_id and counting the number of employees for each manager.", "Using the HAVING clause, we can filter out those managers who have less than 4 employees.", "Once we have the list of manager_ids that meet this criterion, we can then select the department_ids from the employees table where the manager_id matches any of the identified managers."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT department_id\nFROM employees\nWHERE manager_id IN (\n    SELECT manager_id\n    FROM employees\n    GROUP BY manager_id\n    HAVING COUNT(employee_id) >= 4\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3497", "db_id": "hr_1", "question": "Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.", "rationale": ["Identify the employees who do not work in certain departments.", "We need to find departments where employees have a manager ID in the range of 100 to 200.", "Use a subquery to select distinct department IDs from the employees table where the manager ID is within the specified range.", "The main query will select employee IDs from the employees table where their department ID is not in the list of department IDs returned by the subquery."], "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"], "pred_sql": "SELECT EMPLOYEE_ID \nFROM employees \nWHERE DEPARTMENT_ID NOT IN (\n    SELECT DISTINCT DEPARTMENT_ID \n    FROM employees \n    WHERE MANAGER_ID BETWEEN '100' AND '200'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the requirement: We need the full names and hire dates of employees in the same department as someone named Clara, excluding Clara herself.", "To find employees in the same department as Clara, we can use a subquery to get Clara's department_id.", "The subquery will select the department_id from the employees table where the first_name is 'Clara'.", "The main query will select first_name, last_name, and hire_date from the employees table where the department_id matches the one found in the subquery.", "Additionally, we need to ensure that we do not include Clara in the results, so we add a condition to exclude her by checking that first_name is not 'Clara'."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, hire_date \nFROM employees \nWHERE department_id = (SELECT department_id \n                      FROM employees \n                      WHERE first_name = 'Clara') \nAND first_name != 'Clara';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3506", "db_id": "hr_1", "question": "What are the ids, full names, and salaries for employees making more than average and who work in a department with employees who have the letter J in their first name?", "rationale": ["Identify the columns needed: employee IDs, full names (first and last), and salaries.", "To get the full name, concatenate first_name and last_name with a space in between.", "Filter employees whose salary is greater than the average salary of all employees. This requires a subquery to calculate the average salary.", "Additionally, filter employees who work in departments that have at least one employee with a first name containing the letter 'J'. This requires another subquery to find such departments.", "Combine these conditions in the WHERE clause of the main query."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%J%')", "source_tables": ["employees"], "pred_sql": "SELECT employee_id, first_name || ' ' || last_name AS full_name, salary \nFROM employees \nWHERE salary > (SELECT AVG(salary) FROM employees) \nAND department_id IN (SELECT DISTINCT department_id \n                     FROM employees \n                     WHERE first_name LIKE '%J%');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main requirement: We need to display the employee number (EMPLOYEE_ID) and job id (JOB_ID) for employees whose salary is less than any salary of those employees whose job title is MK_MAN.", "To achieve this, we will use a subquery to find the minimum salary of employees with the job title 'MK_MAN'.", "The subquery will join the 'employees' table with the 'jobs' table to filter employees based on the job title.", "The main query will select EMPLOYEE_ID and JOB_ID from the 'employees' table where the salary is less than the result of the subquery."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID FROM employees WHERE SALARY < (SELECT MIN(SALARY) FROM employees AS e JOIN jobs AS j ON e.JOB_ID = j.JOB_ID WHERE j.JOB_TITLE = 'MK_MAN')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3510", "db_id": "hr_1", "question": "What are the employee ids, full names, and job ids for employees who make more than the highest earning employee with title PU_MAN?", "rationale": ["Identify the columns needed: employee_id, full names (first and last), and job_id.", "To get the full names, concatenate first_name and last_name with a space in between.", "Filter employees based on their salary being greater than the highest salary of employees with the job title 'PU_MAN'.", "Use a subquery to find the maximum salary of employees with the job title 'PU_MAN'.", "The final query selects the required columns from the employees table, applying the salary filter."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  'PU_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT employee_id, first_name || ' ' || last_name AS full_name, job_id \nFROM employees \nWHERE salary > (SELECT MAX(salary) \n                 FROM employees \n                 WHERE job_id = (SELECT job_id \n                                 FROM jobs \n                                 WHERE job_title = 'PU_MAN'));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To do this, we will use the 'employees' table, which contains the 'department_id' and 'salary' columns.", "We will group the results by 'department_id' to aggregate the salaries for each department.", "We will use the SUM function to calculate the total salary for each department.", "To filter the departments that have more than 2 employees, we will use the HAVING clause with COUNT(employee_id) > 2."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT department_id, SUM(salary) AS total_salaries \nFROM employees \nGROUP BY department_id \nHAVING COUNT(employee_id) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To achieve this, we will first create a subquery that selects the maximum salary for each department by grouping the employees by department_id.", "The subquery will return the department_id and the maximum salary (max_salary) for each department.", "Next, we will join this subquery with the employees table on department_id and salary to get the details of the employees who have the maximum salary in their respective departments.", "Finally, we will select the department_id, concatenate first_name and last_name to create full_name, and the salary from the employees table."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.department_id, e.first_name || ' ' || e.last_name AS full_name, e.salary \nFROM employees e \nJOIN (\n    SELECT department_id, MAX(salary) AS max_salary \n    FROM employees \n    GROUP BY department_id\n) AS max_salaries \nON e.department_id = max_salaries.department_id AND e.salary = max_salaries.max_salary;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3516", "db_id": "hr_1", "question": "What are the department ids, full names, and salaries for employees who make the most in their departments?", "rationale": ["We need to find the department ids, full names, and salaries of employees who make the most in their departments.", "To achieve this, we will first create a subquery that selects the maximum salary for each department by grouping the employees by department_id.", "Next, we will join this subquery with the employees table to get the full names and salaries of those employees who have the maximum salary in their respective departments.", "The full name can be constructed by concatenating the first name and last name of the employees.", "Finally, we will select the department_id, the constructed full name, and the salary from the joined tables."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.department_id, e.first_name || ' ' || e.last_name AS full_name, e.salary \nFROM employees e \nJOIN (\n    SELECT department_id, MAX(salary) AS max_salary \n    FROM employees \n    GROUP BY department_id\n) AS max_salaries \nON e.department_id = max_salaries.department_id AND e.salary = max_salaries.max_salary;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the relevant table: The 'employees' table contains the first names and last names of employees.", "We need to select the full names of employees, which can be created by concatenating the first name and last name.", "We also need the city of the employees, but since the city is not in the 'employees' table, we need to join it with the 'departments' and 'locations' tables to get the city information.", "The condition specifies that we are only interested in employees whose first names contain the letter 'Z'. This can be achieved using the LIKE operator with a wildcard.", "The final SQL query will select the concatenated full name and the city from the joined tables, applying the filter for the first name."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name, city FROM employees WHERE first_name LIKE '%Z%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "Join the employees table with the departments table on department_id to get department information for each employee.", "Join the resulting table with the locations table on location_id to get location information for each department.", "Join the resulting table with the countries table on country_id to get the country information for each location.", "Select the first name and last name of the employee along with the country name.", "Add a WHERE clause to filter the results for a specific employee ID."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id JOIN locations AS T3 ON T2.location_id = T3.location_id JOIN countries AS T4 ON T3.country_id = T4.country_id WHERE T1.employee_id = ?", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "To get the department name, we will select it from the 'departments' table.", "To count the number of employees in each department, we will use the COUNT function on the 'EMPLOYEE_ID' from the 'employees' table.", "We will join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' to link employees to their respective departments.", "Since some departments may not have any employees, we will use a LEFT JOIN to ensure all departments are included in the result.", "Finally, we will group the results by the department name to get the count of employees per department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES \nFROM departments AS d \nLEFT JOIN employees AS e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    }\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["We need to retrieve the department names and the count of employees in each department.", "To get the department names, we will select the 'department_name' from the 'departments' table.", "To count the number of employees in each department, we will use the COUNT() function on 'employee_id' from the 'employees' table.", "We will join the 'employees' table with the 'departments' table on the 'department_id' to link employees to their respective departments.", "Finally, we will group the results by 'department_name' to get the count of employees for each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT T2.department_name, COUNT(T1.employee_id) AS employee_count \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nGROUP BY T2.department_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the required information: full names (first and last) and salaries of employees.", "Determine the relevant tables: 'employees' for employee details, 'departments' for department information, and 'locations' for city details.", "Join the 'employees' table with the 'departments' table on 'department_id' to link employees to their departments.", "Join the resulting table with the 'locations' table on 'location_id' to access location details, including the city.", "Filter the results to include only those employees who work in the city of London by adding a WHERE clause that specifies the city."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT first_name, last_name, salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id JOIN locations AS T3 ON T2.location_id = T3.location_id WHERE T3.city = 'London'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names, last names, and salaries of employees from the 'employees' table who work in departments located in a specific city. The placeholders in the WHERE clause represent the city name.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their unique identifiers and the names of the countries where their departments are located. The data is sourced from the 'employees', 'departments', 'locations', and 'countries' tables, linked through their respective identifiers.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3641", "db_id": "baseball_1", "question": "In 2014, what are the id and rank of the team that has the largest average number of attendance?", "rationale": ["Identify the relevant table: The 'home_game' table contains information about attendance for teams in specific years.", "Filter for the year 2014: We need to focus on records from the year 2014.", "Select the team_id and rank: We want to retrieve the team_id and rank of the team with the highest attendance.", "Order by attendance: To find the team with the largest average attendance, we will order the results by the 'attendance' column in descending order.", "Limit the results to 1: Since we only want the team with the largest attendance, we will limit the results to 1."], "gold_sql": "SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  2014 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, rank FROM home_game WHERE year = 2014 ORDER BY attendance DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3647", "db_id": "baseball_1", "question": "Which 3 players won the most player awards? List their full name and id.", "rationale": ["We need to find the players who won the most player awards.", "The relevant table for player awards is 'player_award', which contains the player_id and award_id.", "We will join the 'player_award' table with the 'player' table to get the full names of the players.", "We will group the results by player_id to count the number of awards each player has won.", "We will order the results in descending order based on the count of awards to get the top players.", "Finally, we will limit the results to the top 3 players."], "gold_sql": "SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT 3;", "source_tables": ["player_award", "player"], "pred_sql": "SELECT T2.name_first, T2.name_last, T2.player_id \nFROM player_award AS T1 \nJOIN player AS T2 ON T1.player_id = T2.player_id \nGROUP BY T2.player_id \nORDER BY COUNT(T1.award_id) DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3649", "db_id": "baseball_1", "question": "List three countries which are the origins of the least players.", "rationale": ["We need to find the countries with the least number of players.", "The relevant table for player information is the 'player' table, which includes 'birth_country' and 'player_id'.", "To count the number of players from each country, we will use the COUNT function and group the results by 'birth_country'.", "We will order the results in ascending order based on the count of players to get the countries with the least players at the top.", "Finally, we will limit the results to the top 3 countries."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count \nFROM player \nGROUP BY birth_country \nORDER BY player_count ASC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["We need to find the countries with the least number of players.", "The relevant table for player information is the 'player' table, which contains the 'birth_country' and 'player_id' columns.", "To count the number of players from each country, we will use the COUNT() function and group the results by 'birth_country'.", "We will order the results in ascending order based on the count of players to get the countries with the least players first.", "Finally, we will limit the results to the top 3 countries using the LIMIT clause."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.3651", "db_id": "baseball_1", "question": "Find all the players' first name and last name who have empty death record.", "rationale": ["Identify the relevant table: The 'player' table contains the first and last names of players as well as their death records.", "Determine the condition for empty death records: A player has an empty death record if the 'death_year', 'death_month', and 'death_day' fields are all NULL.", "Construct the SQL query: Select the 'name_first' and 'name_last' from the 'player' table where the death records are empty."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE death_year = '';", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE death_year IS NULL AND death_month IS NULL AND death_day IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["We need to find the highest salary for each team, which requires aggregating salary data by team.", "To do this, we will join the 'salary' table with the 'team' table using the 'team_id' column.", "We will select the team name and team id from the 'team' table, and the maximum salary from the 'salary' table.", "We will use the GROUP BY clause to group the results by team id and team name, allowing us to calculate the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T3.name, T3.team_id, MAX(T1.salary) AS max_salary \nFROM salary AS T1 \nJOIN team AS T3 ON T1.team_id = T3.team_id \nGROUP BY T3.team_id, T3.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3662", "db_id": "baseball_1", "question": "Which players won awards in both 1960 and 1961? Return their first names and last names.", "rationale": ["Identify the relevant table for player awards, which is 'player_award'.", "We need to find players who won awards in both 1960 and 1961, so we will filter the records by year using a WHERE clause.", "To ensure that we only get players who won awards in both years, we will group the results by player_id and use HAVING to count distinct years, ensuring it equals 2 (for both 1960 and 1961).", "Finally, we will select the first and last names of these players from the 'player' table, joining it with 'player_award' on player_id."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT T1.name_first, T1.name_last \nFROM player_award AS T1 \nWHERE T1.year IN (1960, 1961) \nGROUP BY T1.player_id \nHAVING COUNT(DISTINCT T1.year) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: We need to look at the 'postseason' table for postseason results and the 'team' table for team information.", "Determine the condition: We want to find the maximum scores (wins) of the team 'Boston Red Stockings' when they won in the postseason.", "Join the tables: We will join the 'postseason' table with the 'team' table on the winning team ID.", "Select the maximum wins: We will use the MAX function to get the highest number of wins for the specified team."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) FROM postseason AS p JOIN team AS t ON p.team_id_winner = t.team_id WHERE t.name = 'Boston Red Stockings'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team information.", "We need to find the maximum scores (wins) for the team 'Boston Red Stockings' when they won in postseason.", "Join the 'postseason' table with the 'team' table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Use the MAX function to get the maximum wins for the specified team."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) FROM postseason AS p JOIN team AS t ON p.team_id_winner = t.team_id WHERE t.name = 'Boston Red Stockings'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3669", "db_id": "baseball_1", "question": "What are the name and id of the team with the most victories in 2008 postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the team with the most victories in the 2008 postseason, so we will focus on the postseason table to get the winning teams.", "Join the postseason table with the team table using the winning team identifier (team_id_winner).", "Filter the results to only include records from the year 2008.", "Order the results by the number of wins in descending order to get the team with the most victories at the top.", "Limit the results to 1 to get only the top team."], "gold_sql": "SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  2008 GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["postseason", "team"], "pred_sql": "SELECT team.name, team.team_id FROM postseason JOIN team ON postseason.team_id_winner = team.team_id WHERE postseason.year = 2008 ORDER BY postseason.wins DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3673", "db_id": "baseball_1", "question": "What is the total number of postseason games that team Boston Red Stockings participated in?", "rationale": ["Identify the relevant table for postseason games, which is 'batting_postseason'.", "Determine the column that represents the total number of games played in postseason, which is 'g'.", "To find the total number of postseason games for the team 'Boston Red Stockings', we need to filter the records by the team_id associated with that team.", "Use a subquery to get the team_id for 'Boston Red Stockings' from the 'team' table where the team name matches.", "Finally, sum the 'g' column for the filtered records to get the total number of postseason games."], "gold_sql": "SELECT count(*) FROM ( SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' UNION SELECT * FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' );", "source_tables": ["postseason", "team"], "pred_sql": "SELECT SUM(g) AS total_postseason_games \nFROM batting_postseason \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3678", "db_id": "baseball_1", "question": "What is the total salary expenses of team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant tables: salary and team.", "We need to sum the salary expenses for a specific team in a specific year.", "Join the salary table with the team table on team_id to filter by team name.", "Use a WHERE clause to specify the year (2010) and the team name ('Boston Red Stockings').", "Select the sum of the salary column to get the total salary expenses."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT SUM(salary) AS total_salary_expenses \nFROM salary AS T1 \nJOIN team AS T2 ON T1.team_id = T2.team_id \nWHERE T1.year = 2010 AND T2.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3679", "db_id": "baseball_1", "question": "How many players were in the team Boston Red Stockings in 2000?", "rationale": ["Identify the relevant tables: salary, player, and team.", "We need to count the distinct players associated with the 'Boston Red Stockings' team in the year 2000.", "Join the salary table with the player table to get player details, and then join with the team table to filter by team name.", "Use the COUNT function to count the distinct player IDs that match the criteria."], "gold_sql": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000", "source_tables": ["team", "salary"], "pred_sql": "SELECT COUNT(DISTINCT T2.player_id) FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2000 AND T3.name = 'Boston Red Stockings'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant tables: We need the 'salary' table to get salary information and the 'player' table to get player names.", "Join the 'salary' table with the 'player' table on 'player_id' to access player names along with their salaries.", "Filter the results to only include records from the year 2001 by adding a WHERE clause for T1.year = 2001.", "Order the results by salary in descending order to get the highest salaries first.", "Limit the results to the top 3 entries to get the three highest salaries."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT T2.name_first, T2.name_last, T1.salary FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id WHERE T1.year = 2001 ORDER BY T1.salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3684", "db_id": "baseball_1", "question": "List all the salary values players received in 2010 and 2001.", "rationale": ["Identify the relevant table for salary records, which is the 'salary' table.", "Determine the years of interest, which are 2010 and 2001.", "Construct a SQL query to select the 'salary' column from the 'salary' table where the 'year' is either 2010 or 2001 using the IN clause."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT salary FROM salary WHERE year IN (2010, 2001);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["Identify the relevant table: The 'hall_of_fame' table contains information about player inductions into the Hall of Fame, including the year of induction and whether the player was inducted.", "Filter for inducted players: We need to filter the records to only include those where the 'inducted' column is marked as 'Y', indicating that the player was inducted.", "Group by year: To find out how many players were inducted in each year, we will group the results by the 'yearid' column.", "Count the number of inductions: We will count the number of inductions for each year using COUNT(*) and alias it as 'num_inductions'.", "Order the results: To find the year with the least inductions, we will order the results in ascending order based on 'num_inductions'.", "Limit the results: Finally, we will limit the results to just one record to get the year with the least inductions."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) AS num_inductions \nFROM hall_of_fame \nWHERE inducted = 'Y' \nGROUP BY yearid \nORDER BY num_inductions ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["To find the year in which the least people entered the Hall of Fame, we need to count the number of inductions for each year.", "The relevant table for this information is the 'hall_of_fame' table, which contains the 'yearid' for each induction.", "We will group the results by 'yearid' and count the number of entries for each year using COUNT(*).", "To find the year with the least inductions, we will order the results in ascending order based on the count of inductions.", "Finally, we will limit the results to 1 to get the year with the least number of inductions."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) AS num_inductions \nFROM hall_of_fame \nGROUP BY yearid \nORDER BY num_inductions ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: 'home_game' for games played and 'park' for park details.", "We need to sum the total games played in a specific park and year, so we will use the SUM function on the 'games' column from the 'home_game' table.", "Join the 'home_game' table with the 'park' table on the 'park_id' to access the park name.", "Filter the results to only include games played in 'Columbia Park' in the year 1907 using a WHERE clause."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(home_game.games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.park_name = 'Columbia Park' AND home_game.year = 1907;", "hint": "\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: 'home_game' for game statistics and 'park' for park details.", "We need to count the total number of games, so we will use the SUM function on the 'games' column from the 'home_game' table.", "To filter the results for 'Columbia Park', we will join the 'home_game' table with the 'park' table on the 'park_id'.", "We will also filter the results for the year 1907 using a WHERE clause.", "The final SQL query will select the sum of games from the joined tables with the specified conditions."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE park.park_name = 'Columbia Park' AND home_game.year = 1907;", "hint": "\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant table: The 'home_game' table contains information about games played, including the year and city.", "Determine the columns needed: We need to sum the 'games' column to get the total number of games played.", "Apply the conditions: We need to filter the results for the year 2000 and the city of Atlanta.", "Construct the SQL query: Use the SUM function to aggregate the total games played in Atlanta for the specified year."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game\nWHERE city = 'Atlanta' AND year = 2000;", "hint": "\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: 'home_game' for game statistics and 'park' for location details.", "We need to find the total number of games played in Atlanta in the year 2000.", "Join the 'home_game' table with the 'park' table on the park_id to access city information.", "Filter the results to include only those games that took place in Atlanta and in the year 2000.", "Use the SUM function to calculate the total number of games from the filtered results."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) AS total_games\nFROM home_game h\nJOIN park p ON h.park_id = p.park_id\nWHERE p.city = 'Atlanta' AND h.year = 2000;", "hint": "\n"}
{"sample_id": "train.3697", "db_id": "baseball_1", "question": "List players' first name and last name who received salary from team Washington Nationals in both 2005 and 2007.", "rationale": ["Identify the relevant tables: salary, player, and team.", "We need to find players who received a salary from the Washington Nationals in two specific years: 2005 and 2007.", "Use the salary table to filter records for the years 2005 and 2007, and join it with the player table to get the first and last names of the players.", "Join the team table to ensure we are only looking at records for the Washington Nationals.", "Use the INTERSECT operator to find players who appear in both years' results, ensuring they received a salary in both 2005 and 2007."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT T2.name_first, T2.name_last \nFROM salary AS T1 \nJOIN player AS T2 ON T1.player_id = T2.player_id \nJOIN team AS T3 ON T3.team_id = T1.team_id \nWHERE T1.year = 2005 AND T3.name = 'Washington Nationals' \nINTERSECT \nSELECT T2.name_first, T2.name_last \nFROM salary AS T1 \nJOIN player AS T2 ON T1.player_id = T2.player_id \nJOIN team AS T3 ON T3.team_id = T1.team_id \nWHERE T1.year = 2007 AND T3.name = 'Washington Nationals';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3699", "db_id": "baseball_1", "question": "How many home games did the team Boston Red Stockings play from 1990 to 2000 in total?", "rationale": ["Identify the relevant table for home games, which is 'home_game'.", "Determine the columns needed: 'games' for total home games and 'year' for the date range.", "Filter the results by the team name 'Boston Red Stockings'.", "Use a subquery to find the 'team_id' corresponding to 'Boston Red Stockings'.", "Set the year range from 1990 to 2000 using the BETWEEN clause.", "Sum the total home games played by the team in the specified years."], "gold_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' AND T1.year BETWEEN 1990 AND 2000;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT SUM(games) AS total_home_games \nFROM home_game \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings') \nAND year BETWEEN 1990 AND 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant table: The 'home_game' table contains information about home games played by teams, including the year and the number of games.", "Specify the year: We are interested in the year 1980, so we will filter the records in the 'home_game' table for that year.", "Select the team and games: We need to select the 'team_id' and the 'games' columns from the 'home_game' table.", "Order the results: To find the team with the least number of home games, we will order the results by the 'games' column in ascending order.", "Limit the results: Since we only want the team with the least number of home games, we will limit the results to 1."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT team_id, games FROM home_game WHERE year = 1980 ORDER BY games ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3710", "db_id": "baseball_1", "question": "Which park did the most people attend in 2008?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'park' for park names.", "We need to find the park with the highest attendance in the year 2008.", "Join the 'home_game' table with the 'park' table on 'park_id' to get park names along with attendance.", "Filter the results to only include records from the year 2008.", "Order the results by attendance in descending order to get the highest attendance first.", "Limit the results to 1 to get only the park with the most attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT park.park_name, home_game.attendance\nFROM home_game\nJOIN park ON home_game.park_id = park.park_id\nWHERE home_game.year = 2008\nORDER BY home_game.attendance DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees in each department, which involves joining the Department table with the Physician table.", "Use a LEFT JOIN to include all departments, even those without physicians.", "Count the number of employees (physicians) in each department using COUNT(Physician.EmployeeID).", "Group the results by department name to get the count per department.", "Order the results by the count of employees in descending order to find the department with the largest number of employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Physician.EmployeeID) AS EmployeeCount\nFROM Department\nLEFT JOIN Physician ON Department.Head = Physician.EmployeeID\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["To find the department with the most employees, we need to count the number of physicians affiliated with each department.", "We will join the Department table with the Affiliated_With table on the DepartmentID to get the list of physicians in each department.", "We will use the COUNT function to count the number of physicians for each department.", "We will group the results by department name to get the count for each department.", "To find the department with the most employees, we will order the results by the count of employees in descending order.", "Finally, we will limit the results to 1 to get only the department with the highest count."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Affiliated_With.Physician) AS EmployeeCount\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["We need to find the name and position of the head of the department with the least number of employees.", "The head of a department is identified by the 'Head' column in the Department table, which corresponds to the 'EmployeeID' in the Physician table.", "To find the department with the least number of employees, we can use the Affiliated_With table to count the number of physicians affiliated with each department.", "We will group the results by department and order them by the count of physicians in ascending order, limiting the result to the first one to get the department with the least employees.", "Finally, we will join the Physician and Department tables to get the name and position of the head of that department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Department ON Physician.EmployeeID = Department.Head \nWHERE Department.DepartmentID = \n  (SELECT Affiliated_With.Department \n   FROM Affiliated_With \n   GROUP BY Affiliated_With.Department \n   ORDER BY COUNT(Affiliated_With.Physician) ASC \n   LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["We need to find the names of patients who made an appointment.", "The relevant tables are Patient and Appointment.", "We will join the Patient table with the Appointment table on the Patient's SSN and the Appointment's Patient identifier.", "We use DISTINCT to ensure we get unique patient names in case a patient has multiple appointments."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT P.Name FROM Patient AS P JOIN Appointment AS A ON P.SSN = A.Patient", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3905", "db_id": "hospital_1", "question": "List the names of patients who have made appointments.", "rationale": ["Identify the relevant tables: Patient and Appointment.", "We need to find the names of patients who have made appointments, which means we need to join the Patient table with the Appointment table.", "The common field between these two tables is Patient.SSN in the Patient table and Appointment.Patient in the Appointment table.", "We will select the distinct names of patients from the Patient table who have corresponding entries in the Appointment table."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT P.Name FROM Patient AS P JOIN Appointment AS A ON P.SSN = A.Patient;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables needed: Physician, Affiliated_With, and Department.", "We need to get the names of physicians and their affiliated departments.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns.", "Join the result with the Department table on the Department column from Affiliated_With and DepartmentID from Department.", "Select the names of physicians and their corresponding department names.", "Filter the results to only include primary affiliations by checking the PrimaryAffiliation column."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT P.Name AS PhysicianName, D.Name AS DepartmentName \nFROM Physician P \nJOIN Affiliated_With AW ON P.EmployeeID = AW.Physician \nJOIN Department D ON AW.Department = D.DepartmentID \nWHERE AW.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3915", "db_id": "hospital_1", "question": "What are the name and primarily affiliated department name of each physician?", "rationale": ["Identify the relevant tables: Physician, Department, and Affiliated_With.", "We need to retrieve the names of physicians and their primarily affiliated department names.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns respectively.", "Join the resulting table with the Department table on the Department column from Affiliated_With and DepartmentID from Department.", "Select the Name from Physician and Name from Department where the affiliation is primary."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT P.Name, D.Name \nFROM Physician P \nJOIN Affiliated_With A ON P.EmployeeID = A.Physician \nJOIN Department D ON A.Department = D.DepartmentID \nWHERE A.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3929", "db_id": "hospital_1", "question": "Return the name of each physician and the number of patients he or she treats.", "rationale": ["We need to return the names of physicians and the number of patients they treat.", "To achieve this, we will use the Physician table to get the names of the physicians.", "We will join the Appointment table to count the number of distinct patients associated with each physician.", "The join condition will be based on the EmployeeID of the Physician and the Physician field in the Appointment table.", "Finally, we will group the results by the physician's name to get the count of patients for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT P.Name, COUNT(DISTINCT A.Patient) AS NumberOfPatients\nFROM Physician P\nJOIN Appointment A ON P.EmployeeID = A.Physician\nGROUP BY P.Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["We need to find physicians who are in charge of more than one patient.", "To do this, we will join the Physician table with the Prescribes table on the EmployeeID and Physician columns respectively.", "We will group the results by the physician's name to aggregate the data for each physician.", "Using the HAVING clause, we will filter the groups to only include those where the count of distinct patients is greater than one."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Prescribes AS T2 ON T1.EmployeeID = T2.Physician GROUP BY T1.Name HAVING COUNT(DISTINCT T2.Patient) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3931", "db_id": "hospital_1", "question": "Which physicians are in charge of more than one patient? Give me their names.", "rationale": ["Identify the relevant tables: Physician and Prescribes.", "Join the Physician table with the Prescribes table on the EmployeeID and Physician identifiers respectively.", "Group the results by physician name to aggregate the data.", "Use the HAVING clause to filter for physicians who have prescribed to more than one distinct patient, which is indicated by counting the distinct Patient identifiers in the Prescribes table."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Prescribes AS T2 ON T1.EmployeeID = T2.Physician GROUP BY T1.Name HAVING COUNT(DISTINCT T2.Patient) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3934", "db_id": "hospital_1", "question": "Find the number of rooms for different block code?", "rationale": ["Identify the relevant table: The Room table contains information about rooms and their block codes.", "Determine the required information: We need to count the number of rooms for each block code.", "Use the COUNT() function to count the rooms and GROUP BY BlockCode to get the count for each unique block code.", "Construct the SQL query to select the BlockCode and the count of RoomNumber, grouping by BlockCode."], "gold_sql": "SELECT count(*) ,  T1.blockcode FROM BLOCK AS T1 JOIN room AS T2 ON T1.blockfloor  =  T2.blockfloor AND T1.blockcode  =  T2.blockcode GROUP BY T1.blockcode", "source_tables": ["block", "room"], "pred_sql": "SELECT BlockCode, COUNT(RoomNumber) AS NumberOfRooms\nFROM Room\nGROUP BY BlockCode;", "hint": "\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["The task is to find the number of medications prescribed for each brand.", "To achieve this, we need to count the number of medications grouped by their brand name.", "We will use the Medication table, which contains the Brand column.", "The SQL query will select the Brand and count the number of occurrences of each brand, grouping the results by the Brand column."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT Brand, COUNT(*) AS NumberOfMedications\nFROM Medication\nGROUP BY Brand;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of patients who have not been prescribed a specific medication. It filters the patients based on their Social Security Number (SSN) and checks against a subquery that retrieves patients who have received the specified medication by joining the 'Prescribes' and 'Medication' tables. The placeholder in the query represents the name of the medication.\",\n        \"virtual_table\": \"SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: Physician and Prescribes.", "Join the Physician table with the Prescribes table on the physician's identifier (EmployeeID).", "Select the name of the physician from the Physician table.", "Order the results by the Dose in descending order to get the highest dose first.", "Limit the results to 1 to get only the physician who prescribed the highest dose."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT P.Name\nFROM Physician P\nJOIN Prescribes Pr ON P.EmployeeID = Pr.Physician\nORDER BY Pr.Dose DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the relevant tables: Physician and Affiliated_With.", "We need to select the EmployeeID from the Physician table and the Department from the Affiliated_With table.", "Join the Physician table with the Affiliated_With table on the EmployeeID and Physician columns respectively.", "Filter the results to only include primary affiliations by checking the PrimaryAffiliation column in the Affiliated_With table."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT P.EmployeeID, A.Department FROM Physician P JOIN Affiliated_With A ON P.EmployeeID = A.Physician WHERE A.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique physician names who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3961", "db_id": "hospital_1", "question": "What are each physician's employee id and department id primarily affiliated.", "rationale": ["Identify the relevant tables: Physician and Affiliated_With.", "Determine the columns needed: EmployeeID from Physician and Department from Affiliated_With.", "Establish the relationship between the tables: Physician.EmployeeID matches Affiliated_With.Physician.", "Filter for primary affiliations by checking the PrimaryAffiliation column in Affiliated_With.", "Construct the SQL query to select the required columns with the appropriate JOIN and WHERE clause."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department FROM Physician JOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician WHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of physicians who have prescribed a specific medication. The placeholders in the WHERE clause represent the name of the medication being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3970", "db_id": "hospital_1", "question": "Find the three most expensive procedures.", "rationale": ["The task is to find the three most expensive procedures.", "To achieve this, we need to select the 'Name' column from the 'Procedures' table.", "We will order the results by the 'Cost' column in descending order to get the most expensive procedures first.", "Finally, we will limit the results to the top three using 'LIMIT 3'."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["The task is to find the three most costly procedures.", "To achieve this, we need to select the 'Name' from the 'Procedures' table.", "We will order the results by the 'Cost' column in descending order to get the most expensive procedures first.", "Finally, we will limit the results to 3 to get only the top three costly procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3973", "db_id": "hospital_1", "question": "Which physicians are trained in procedures that are more expensive than 5000?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "Join the Physician table with the Trained_In table on the EmployeeID and Physician columns to get the physicians and their trained procedures.", "Join the resulting table with the Procedures table on the Treatment and Code columns to access the cost of the procedures.", "Filter the results to include only those procedures where the cost is greater than 5000."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician JOIN Procedures AS T3 ON T3.Code = T2.Treatment WHERE T3.Cost > 5000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the tables involved: Physician, Trained_In, and Procedures.", "We need to find the physician who is trained in the most expensive procedure.", "Join the Physician table with the Trained_In table on the EmployeeID and Physician columns.", "Join the resulting table with the Procedures table on the Treatment and Code columns.", "To find the most expensive procedure, we can use a subquery to get the maximum cost from the Procedures table.", "Finally, select the Name of the physician where the cost of the procedure matches the maximum cost."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician JOIN Procedures AS T3 ON T3.Code = T2.Treatment WHERE T3.Cost = (SELECT MAX(Cost) FROM Procedures)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3985", "db_id": "hospital_1", "question": "What procedures cost less than 5000 and have John Wen as a trained physician?", "rationale": ["Identify the procedures that cost less than 5000.", "Use the Procedures table to filter by cost.", "Join the Trained_In table to find procedures that John Wen is trained in.", "Filter the results to only include procedures that John Wen is associated with."], "gold_sql": "SELECT name FROM procedures WHERE cost  <  5000 INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT T3.Name FROM Procedures AS T3 WHERE T3.Cost < 5000 AND T3.Code IN (SELECT T2.Treatment FROM Trained_In AS T2 JOIN Physician AS T1 ON T1.EmployeeID = T2.Physician WHERE T1.Name = 'John Wen');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians who are trained in specific procedures that have a cost exceeding a certain amount. The placeholders in the WHERE clause represent the cost threshold for the procedures.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of medical procedures that either exceed a specified cost or are associated with a physician who has been trained in those procedures. The first part of the query retrieves procedure names based on a cost threshold, while the second part retrieves procedure names linked to a specific physician's training. The placeholders represent the cost limit and the physician's name, respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4321", "db_id": "tracking_grants_for_research", "question": "What are the different grant amounts for documents sent before '1986-08-26 20:49:27' and after the grant ended on '1989-03-16 18:27:16'?", "rationale": ["Identify the relevant tables: Grants and Documents are needed to access grant amounts and document sent dates.", "Join the Grants and Documents tables on the grant_id to link documents to their respective grants.", "Filter the results based on the sent_date of documents being before '1986-08-26 20:49:27' and the grant_end_date being after '1989-03-16 18:27:16'.", "Select the distinct grant amounts from the filtered results to avoid duplicates."], "gold_sql": "SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  '1986-08-26 20:49:27' INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  '1989-03-16 18:27:16'", "source_tables": ["grants", "documents"], "pred_sql": "SELECT DISTINCT Grants.grant_amount FROM Grants JOIN Documents ON Grants.grant_id = Documents.grant_id WHERE Documents.sent_date < '1986-08-26 20:49:27' AND Grants.grant_end_date < '1989-03-16 18:27:16';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\",\n        \"virtual_table\": \"SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER] AND T4.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the start dates of grants from the 'Grants' table that are associated with documents of a specific type. It uses joins to connect the 'Grants', 'Documents', and 'Document_Types' tables based on their foreign key relationships. The placeholder in the WHERE clause represents the description of the document type, allowing users to specify which document type they are interested in. The INTERSECT operation ensures that only the start dates of grants that meet the criteria in both queries are returned.\",\n        \"virtual_table\": \"SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4322", "db_id": "tracking_grants_for_research", "question": "List the project details of the project both producing patent and paper as outcomes.", "rationale": ["Identify the main goal: to list project details for projects that produce both patent and paper outcomes.", "Understand the relationships: Projects are linked to Project_Outcomes, which in turn are linked to Research_Outcomes.", "Use JOINs to connect the Projects table with Project_Outcomes and Research_Outcomes based on their foreign keys.", "Filter the results using a WHERE clause to include only those outcomes that are either 'patent' or 'paper'.", "Since we want projects that produce both outcomes, we can use the IN clause to specify both outcomes in the filter."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Paper' INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  'Patent'", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id JOIN Research_Outcomes AS T3 ON T2.outcome_code = T3.outcome_code WHERE T3.outcome_description IN ('patent', 'paper')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the tables involved: Grants, Organisations, and Organisation_Types.", "Determine the relationship between these tables: Grants are linked to Organisations via organisation_id, and Organisations are linked to Organisation_Types via organisation_type.", "We need to calculate the total grant amount, so we will use the SUM function on the grant_amount column from the Grants table.", "To filter the organisations described as research, we will use a WHERE clause that checks the organisation_type_description in the Organisation_Types table for the value 'research'.", "Construct the SQL query using the identified tables, relationships, and conditions."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id = T2.organisation_id JOIN Organisation_Types AS T3 ON T2.organisation_type = T3.organisation_type WHERE T3.organisation_type_description = 'research'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total grant amount from the 'Grants' table for organisations of a specific type. It joins the 'Grants' table with the 'Organisations' table to link grants to their respective organisations, and further joins with the 'Organisation_Types' table to filter based on the organisation type description. The placeholder in the WHERE clause represents the specific organisation type description being queried.\",\n        \"virtual_table\": \"SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\",\n        \"virtual_table\": \"SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER] AND T4.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the role code for the leader role from the Staff_Roles table.", "Find the project_id(s) that have staff members with the leader role by filtering on the role_code.", "Group the results by project_id and count the number of staff members for each project.", "Order the results by the count of staff members in descending order and limit the results to the top project (the one with the most staff).", "Select the date_from and date_to for the staff members working on the identified project_id."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to \nFROM Project_Staff \nWHERE project_id = (\n    SELECT project_id \n    FROM Project_Staff \n    WHERE role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Leader') \n    GROUP BY project_id \n    ORDER BY COUNT(staff_id) DESC \n    LIMIT 1\n)", "hint": "\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields.", "Group the results by organisation_id and organisation_type to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most research staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_type, o.organisation_id\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the tables involved: Documents, Grants, Organisations, Organisation_Types.", "Determine the relationships: Documents are linked to Grants via grant_id, Grants are linked to Organisations via organisation_id, and Organisations are linked to Organisation_Types via organisation_type.", "Select the relevant columns: We need the sent_date from the Documents table.", "Apply the necessary filters: We want grants with a grant_amount greater than 5000.", "Construct the SQL query using JOINs to connect the tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT T1.sent_date FROM Documents AS T1 JOIN Grants AS T2 ON T1.grant_id = T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id = T3.organisation_id JOIN Organisation_Types AS T4 ON T3.organisation_type = T4.organisation_type WHERE T2.grant_amount > 5000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\",\n        \"virtual_table\": \"SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER] AND T4.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table retrieves the start dates of grants from the 'Grants' table that are associated with documents of a specific type. It uses joins to connect the 'Grants', 'Documents', and 'Document_Types' tables based on their foreign key relationships. The placeholder in the WHERE clause represents the description of the document type, allowing users to specify which document type they are interested in. The INTERSECT operation ensures that only the start dates of grants that meet the criteria in both queries are returned.\",\n        \"virtual_table\": \"SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4338", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects which did not hire any staff for a researcher role.", "rationale": ["We need to list project details of projects that did not hire any staff for a researcher role.", "To achieve this, we will select the project details from the 'Projects' table.", "We will use a LEFT JOIN to connect the 'Projects' table with the 'Project_Staff' table on the project_id.", "We will filter the join condition to only include staff members with the role of 'Researcher'.", "To find the role_code for 'Researcher', we will use a subquery on the 'Staff_Roles' table.", "Finally, we will filter the results to include only those projects where there are no associated staff members (i.e., where staff_id is NULL)."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT P.project_details \nFROM Projects AS P \nLEFT JOIN Project_Staff AS PS ON P.project_id = PS.project_id AND PS.role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Researcher') \nWHERE PS.staff_id IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4339", "db_id": "tracking_grants_for_research", "question": "What are the details for all projects that did not hire any staff in a research role?", "rationale": ["We need to find projects that did not hire any staff in a research role.", "To do this, we will select all columns from the Projects table.", "We will perform a LEFT JOIN with the Project_Staff table on the project_id to include all projects and their associated staff.", "We will filter the results where the staff_id from the Project_Staff table is NULL, indicating that no staff were hired for that project."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT P.* FROM Projects AS P LEFT JOIN Project_Staff AS PS ON P.project_id = PS.project_id WHERE PS.staff_id IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4342", "db_id": "tracking_grants_for_research", "question": "When do all the researcher role staff start to work, and when do they stop working?", "rationale": ["Identify the relevant table: Project_Staff contains information about staff members, including their roles and dates of involvement.", "Determine the columns needed: We need the 'date_from' and 'date_to' columns to know when researchers start and stop working.", "Filter for researcher roles: Use a subquery to select role codes from the Staff_Roles table where the role description includes 'researcher'.", "Construct the SQL query to select the required dates from Project_Staff where the role code matches the researcher roles."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to \nFROM Project_Staff \nWHERE role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%researcher%');", "hint": "\n"}
{"sample_id": "train.4350", "db_id": "tracking_grants_for_research", "question": "How many staff does each project has? List the project id and the number in an ascending order.", "rationale": ["Identify the relevant table: The question asks about staff associated with projects, so we will use the Project_Staff table.", "Count the number of staff members for each project: We will use the COUNT() function to count the staff_id for each project_id.", "Group the results by project_id: We will use GROUP BY to aggregate the counts for each project.", "Order the results in ascending order: We will use ORDER BY to sort the results by project_id in ascending order."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT project_id, COUNT(staff_id) AS staff_count\nFROM Project_Staff\nGROUP BY project_id\nORDER BY project_id ASC;", "hint": "\n"}
{"sample_id": "train.4351", "db_id": "tracking_grants_for_research", "question": "For each project id, how many staff does it have? List them in increasing order.", "rationale": ["Identify the relevant table: The question pertains to the number of staff associated with each project, so we will focus on the 'Project_Staff' table.", "Count the staff members: We need to count the number of staff members for each project, which can be done using the COUNT() function.", "Group by project_id: To get the count of staff for each project, we will group the results by 'project_id'.", "Order the results: The final output should be in increasing order of 'project_id', so we will use the ORDER BY clause."], "gold_sql": "SELECT T1.project_id ,  count(*) FROM Project_Staff AS T1 JOIN Projects AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) ASC", "source_tables": ["project_staff", "projects"], "pred_sql": "SELECT project_id, COUNT(staff_id) AS staff_count\nFROM Project_Staff\nGROUP BY project_id\nORDER BY project_id ASC;", "hint": "\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the tables needed: Projects and Project_Outcomes are essential to get project details and their associated outcomes.", "Join the Projects table with the Project_Outcomes table on the project_id to link projects with their outcomes.", "Use COUNT() to count the number of outcomes for each project.", "Group the results by project_id and project_details to aggregate the outcome counts per project.", "Order the results by the outcome count in descending order to find the project with the most outcomes.", "Limit the results to 1 to get only the project with the highest number of outcomes."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT P.project_id, P.project_details, COUNT(PO.outcome_code) AS outcome_count \nFROM Projects AS P \nJOIN Project_Outcomes AS PO ON P.project_id = PO.project_id \nGROUP BY P.project_id, P.project_details \nORDER BY outcome_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4359", "db_id": "tracking_grants_for_research", "question": "What are the details of the project with no outcomes?", "rationale": ["Identify the main table to query: Projects.", "Determine the requirement: details of projects with no outcomes.", "To find projects with no outcomes, we can use a subquery that selects project_ids from the Project_Outcomes table.", "Use the NOT IN clause to filter out projects that have outcomes, ensuring we only get those without any associated outcomes."], "gold_sql": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT * FROM Projects WHERE project_id NOT IN (SELECT project_id FROM Project_Outcomes)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "We need to find the organisation that hired the most research staff, so we will join the Organisations table with the Research_Staff table on the organisation_id.", "We will group the results by organisation_id, organisation_type, and organisation_details to count the number of research staff for each organisation.", "We will use COUNT(rs.staff_id) to count the number of research staff per organisation.", "To find the organisation with the most research staff, we will order the results in descending order based on the count and limit the results to 1."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id, o.organisation_type, o.organisation_details\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff for staff involvement in projects and Staff_Roles for role descriptions.", "We need to find the role involved with the most number of projects for each staff member.", "Use a subquery to count the number of projects each role is involved in and order them to find the top role.", "Join the Project_Staff table with the Staff_Roles table to get the role descriptions.", "Select the staff_id and the corresponding role description for the role involved in the most projects."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT ps.staff_id, sr.role_description\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nWHERE ps.project_id IN (\n    SELECT project_id\n    FROM Project_Staff\n    GROUP BY project_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "\n"}
{"sample_id": "train.4364", "db_id": "tracking_grants_for_research", "question": "Which document type is described with the prefix 'Initial'?", "rationale": ["Identify the relevant table: The question asks about document types, so we will focus on the Document_Types table.", "Determine the filtering criteria: The user is looking for document types that start with the prefix 'Initial'.", "Use the LIKE operator to filter the document_description column for entries that start with 'Initial'.", "Construct the SQL query to select the document_description from the Document_Types table where the document_description matches the criteria."], "gold_sql": "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'", "source_tables": ["document_types"], "pred_sql": "SELECT document_description FROM Document_Types WHERE document_description LIKE 'Initial%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the start dates of grants from the 'Grants' table that are associated with documents of a specific type. It uses joins to connect the 'Grants', 'Documents', and 'Document_Types' tables based on their foreign key relationships. The placeholder in the WHERE clause represents the description of the document type, allowing users to specify which document type they are interested in. The INTERSECT operation ensures that only the start dates of grants that meet the criteria in both queries are returned.\",\n        \"virtual_table\": \"SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\",\n        \"virtual_table\": \"SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER] AND T4.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the relevant tables: We need to work with the 'Documents' and 'Grants' tables to get the required information about documents associated with each grant.", "Count the number of documents for each grant: We can use the COUNT function to count the number of documents for each grant by grouping the results by 'grant_id'.", "Select the grant_id and the count of documents: The SELECT statement will include 'grant_id' and the count of documents as 'document_count'.", "Determine which grant has the most documents: We can order the results by 'document_count' in descending order to find the grant with the most documents.", "Limit the results to the top grant: Using LIMIT 1 will ensure we only get the grant with the highest document count."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT D.grant_id, COUNT(D.document_id) AS document_count, D.document_id \nFROM Documents D \nJOIN Grants G ON D.grant_id = G.grant_id \nGROUP BY D.grant_id \nORDER BY document_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\",\n        \"virtual_table\": \"SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER] AND T4.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table retrieves the start dates of grants from the 'Grants' table that are associated with documents of a specific type. It uses joins to connect the 'Grants', 'Documents', and 'Document_Types' tables based on their foreign key relationships. The placeholder in the WHERE clause represents the description of the document type, allowing users to specify which document type they are interested in. The INTERSECT operation ensures that only the start dates of grants that meet the criteria in both queries are returned.\",\n        \"virtual_table\": \"SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4374", "db_id": "tracking_grants_for_research", "question": "How many Patent outcomes are generated from all the projects?", "rationale": ["Identify the tables involved: Projects, Project_Outcomes, and Research_Outcomes.", "Determine the relationship between the tables: Projects are linked to Project_Outcomes via project_id, and Project_Outcomes are linked to Research_Outcomes via outcome_code.", "Focus on the outcome description to filter for Patent outcomes.", "Use COUNT(*) to count the number of records that match the criteria.", "Construct the SQL query using JOINs to connect the tables and apply the WHERE clause to filter for Patent outcomes."], "gold_sql": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  'Patent'", "source_tables": ["project_outcomes"], "pred_sql": "SELECT COUNT(*) AS patent_outcome_count FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id JOIN Research_Outcomes AS T3 ON T2.outcome_code = T3.outcome_code WHERE T3.outcome_description LIKE '%Patent%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4376", "db_id": "tracking_grants_for_research", "question": "How many project staff worked as leaders or started working before '1989-04-24 23:51:54'?", "rationale": ["Identify the relevant table: Project_Staff contains information about staff members associated with projects.", "Determine the criteria for counting staff: We need to count those who worked as leaders or started before a specific date.", "To find leaders, we need to reference the Staff_Roles table to get the role codes associated with leadership roles.", "Use a subquery to select role codes from Staff_Roles where the role description contains 'leader'.", "Combine the conditions using a WHERE clause: check if the role_code is in the list of leader role codes and if the date_from is before the specified date.", "Count the number of records that meet these criteria."], "gold_sql": "SELECT count(*) FROM Project_Staff WHERE role_code  =  'leader' OR date_from  <  '1989-04-24 23:51:54'", "source_tables": ["project_staff"], "pred_sql": "SELECT COUNT(*) \nFROM Project_Staff \nWHERE role_code IN (SELECT role_code FROM Staff_Roles WHERE role_description LIKE '%leader%') \nAND date_from < '1989-04-24 23:51:54';", "hint": "\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant table: The question asks for project details, which are found in the 'Projects' table.", "Determine the filtering criteria: The project detail must match the string 'sint'.", "Construct the SQL query: Use a SELECT statement to retrieve 'project_details' from the 'Projects' table where 'project_details' contains 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT T1.project_details FROM Projects AS T1 WHERE T1.project_details LIKE '%sint%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects, Project_Outcomes, and Research_Outcomes are needed to get the outcome description based on project details.", "Join the Projects table with Project_Outcomes on project_id to link projects to their outcomes.", "Join the Project_Outcomes table with Research_Outcomes on outcome_code to get the descriptions of the outcomes.", "Filter the results where the project_details in the Projects table match the specified string 'sint'.", "Select the outcome_description from the Research_Outcomes table as the final output."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT T3.outcome_description FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id JOIN Research_Outcomes AS T3 ON T2.outcome_code = T3.outcome_code WHERE T1.project_details LIKE 'sint'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4385", "db_id": "tracking_grants_for_research", "question": "What are the details for the projects which were launched by the organization with the most projects?", "rationale": ["Identify the organization with the most projects by counting the number of projects for each organization.", "Use a subquery to group the projects by organization_id and count them, ordering by the count in descending order and limiting the result to the top organization.", "Join the Projects table with the result of the subquery to get the details of the projects associated with the organization that has the most projects."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT P.* FROM Projects AS P JOIN (SELECT organisation_id, COUNT(*) AS project_count FROM Projects GROUP BY organisation_id ORDER BY project_count DESC LIMIT 1) AS Most_Projects ON P.organisation_id = Most_Projects.organisation_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the sent dates of documents from the 'Documents' table that are associated with grants exceeding a specified amount. The query joins multiple tables: 'Grants' to link grants with documents, 'Organisations' to connect grants to their respective organisations, and 'Organisation_Types' to filter organisations based on their type description. The placeholders in the WHERE clause represent the grant amount and the organisation type description.\",\n        \"virtual_table\": \"SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER] AND T4.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4391", "db_id": "tracking_grants_for_research", "question": "For each project id, how many tasks are there?", "rationale": ["Identify the relevant tables: We need to count tasks associated with each project, so we will use the 'Tasks' table which contains 'task_id' and 'project_id'.", "We need to group the results by 'project_id' to get the count of tasks for each project.", "Use the COUNT() function to count the number of tasks for each project.", "The final SQL query will select the 'project_id' and the count of 'task_id' from the 'Tasks' table, grouping by 'project_id'."], "gold_sql": "SELECT count(*) ,  T1.project_details FROM Projects AS T1 JOIN Tasks AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id", "source_tables": ["tasks", "projects"], "pred_sql": "SELECT project_id, COUNT(task_id) AS task_count FROM Tasks GROUP BY project_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that are associated with specific research outcomes. The query filters the results based on a description of the research outcome, represented by a placeholder for string values.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["Identify the relevant table for staff roles, which is 'Staff_Roles'.", "Select the columns 'role_code' and 'role_description' from the 'Staff_Roles' table to get the information about staff roles."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, role_description FROM Staff_Roles;", "hint": "\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["Identify the relevant table: The question pertains to staff roles, so we will focus on the Project_Staff table.", "Determine the information needed: We need to find the most common role, which implies counting occurrences of each role.", "Group the results: We will group the results by role_code to count how many times each role appears.", "Order the results: To find the most common role, we will order the results by the count in descending order.", "Limit the results: Since we only want the most common role, we will limit the results to 1."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM Project_Staff \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to count the number of products, so we will use the COUNT function.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter by category.", "Add a WHERE clause to filter for products in the 'Spices' category.", "Add another condition in the WHERE clause to filter for products with a typical selling price greater than 1000."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT count(*) FROM Products AS p JOIN Ref_Product_Categories AS pc ON p.product_category_code = pc.product_category_code WHERE pc.product_category_description = 'Spices' AND p.typical_selling_price > 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to retrieve the product category descriptions, so we will select from Ref_Product_Categories.", "Join the Products table with Ref_Product_Categories on the product_category_code to link products to their categories.", "Filter the products based on their descriptions containing the letter 't' using the LIKE operator.", "Use DISTINCT to ensure that we only get unique category descriptions."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description \nFROM Products p \nJOIN Ref_Product_Categories rpc ON p.product_category_code = rpc.product_category_code \nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query filters the results based on the product's name and the type of characteristic, using placeholders for both values.\",\n        \"virtual_table\": \"SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5576", "db_id": "products_gen_characteristics", "question": "Count the products that have the color description \"white\" or have the characteristic name \"hot\".", "rationale": ["Identify the tables involved: Products, Product_Characteristics, Characteristics, and Ref_Colors.", "Determine the relationships between the tables using foreign keys: Products to Product_Characteristics, Product_Characteristics to Characteristics, and Products to Ref_Colors.", "Use JOIN clauses to combine these tables based on their relationships.", "Specify the conditions in the WHERE clause to filter products by color description 'white' or characteristic name 'hot'.", "Count the total number of products that meet either of these conditions using COUNT(*) function."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT count(*) FROM Products AS t1 JOIN Product_Characteristics AS t2 ON t1.product_id = t2.product_id JOIN Characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id JOIN Ref_Colors AS t4 ON t1.color_code = t4.color_code WHERE t4.color_description = 'white' OR t3.characteristic_name = 'hot'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: We need to find the unit of measure for 'Herb' products, which involves the Products and Ref_Product_Categories tables.", "Determine the relationship: The Products table has a foreign key relationship with the Ref_Product_Categories table through the product_category_code.", "Filter the Products table: We need to filter the Products table to find products that have 'Herb' in their name.", "Select the unit of measure: Once we have the relevant product categories from the Products table, we can select the unit_of_measure from the Ref_Product_Categories table based on the product_category_code."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT unit_of_measure FROM Ref_Product_Categories WHERE product_category_code IN (SELECT product_category_code FROM Products WHERE product_name LIKE '%Herb%')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query filters the results based on the product's name and the type of characteristic, using placeholders for both values.\",\n        \"virtual_table\": \"SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the columns needed: product_category_code from Ref_Product_Categories and unit_of_measure from Ref_Product_Categories.", "Establish the relationship between Products and Ref_Product_Categories using the product_category_code foreign key.", "Filter the results based on the product name 'chervil'.", "Construct the SQL query to select the required columns with the appropriate JOIN and WHERE clause."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT pc.product_category_code, p.unit_of_measure FROM Products p JOIN Ref_Product_Categories pc ON p.product_category_code = pc.product_category_code WHERE p.product_name = 'chervil';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query filters the results based on the product's name and the type of characteristic, using placeholders for both values.\",\n        \"virtual_table\": \"SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5589", "db_id": "products_gen_characteristics", "question": "What are the names of products that are not 'white' in color and are not measured by the unit 'Handful'?", "rationale": ["Identify the relevant tables: Products, Ref_Colors, and Ref_Product_Categories.", "Join the Products table with the Ref_Colors table on the color_code to filter products based on color.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter products based on the unit of measure.", "Use a WHERE clause to specify that the color_description should not be 'white' and the unit_of_measure should not be 'Handful'.", "Select the product_name from the resulting joined tables."], "gold_sql": "SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  'white' AND t2.unit_of_measure != 'Handful'", "source_tables": ["products", "ref_colors", "ref_product_categories"], "pred_sql": "SELECT product_name FROM Products AS p JOIN Ref_Colors AS c ON p.color_code = c.color_code JOIN Ref_Product_Categories AS pc ON p.product_category_code = pc.product_category_code WHERE c.color_description != 'white' AND pc.unit_of_measure != 'Handful';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["Identify the color descriptions from the Ref_Colors table.", "Count the number of products associated with each color by grouping the Products table by color_code.", "Order the results by the count of products in ascending order to find the color used by the least products.", "Limit the results to 1 to get the color with the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT color_description FROM Ref_Colors WHERE color_code IN (SELECT color_code FROM Products GROUP BY color_code ORDER BY COUNT(product_id) ASC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using joins based on their relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To do this, we will join the 'Product_Characteristics' table with the 'Characteristics' table to get the characteristic names.", "Next, we will join the 'Products' table to link the characteristics to the products.", "We will group the results by the characteristic name to count how many distinct products each characteristic is associated with.", "Finally, we will use the HAVING clause to filter the results to only include characteristics that are associated with two or more products."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT t3.characteristic_name \nFROM product_characteristics AS t2 \nJOIN characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id \nJOIN products AS t1 ON t2.product_id = t1.product_id \nGROUP BY t3.characteristic_name \nHAVING COUNT(DISTINCT t1.product_id) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query filters the results based on the product's name and the type of characteristic, using placeholders for both values.\",\n        \"virtual_table\": \"SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5669", "db_id": "dorm_1", "question": "What are the names of the all-female dorms?", "rationale": ["Identify the relevant table: The question asks about dorms, so we will focus on the 'Dorm' table.", "Determine the condition: The question specifies 'all-female dorms', which indicates we need to filter by the 'gender' column in the 'Dorm' table.", "Construct the SQL query: We will select the 'dorm_name' from the 'Dorm' table where the 'gender' is 'female'."], "gold_sql": "SELECT dorm_name FROM dorm WHERE gender  =  'F'", "source_tables": ["dorm"], "pred_sql": "SELECT dorm_name FROM Dorm WHERE gender = 'female'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.5688", "db_id": "dorm_1", "question": "Find the average and total capacity of dorms for the students with gender X.", "rationale": ["Identify the tables needed: We need to get information from the Dorm table for capacity and the Student table for gender.", "Join the Dorm table with the Lives_in table to link students to their respective dorms.", "Join the resulting table with the Student table to filter by gender.", "Use the AVG() function to calculate the average capacity of the dorms and the SUM() function to calculate the total capacity.", "Filter the results where the gender of the students is 'X'."], "gold_sql": "SELECT avg(student_capacity) ,  sum(student_capacity) FROM dorm WHERE gender  =  'X'", "source_tables": ["dorm"], "pred_sql": "SELECT AVG(D.student_capacity) AS average_capacity, SUM(D.student_capacity) AS total_capacity \nFROM Dorm AS D \nJOIN Lives_in AS L ON D.dormid = L.dormid \nJOIN Student AS S ON L.stuid = S.StuID \nWHERE S.Sex = 'X';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.5699", "db_id": "dorm_1", "question": "What are the names and types of the dorms that have a capacity greater than 300 or less than 100?", "rationale": ["Identify the relevant table: The question pertains to dormitories, so we will focus on the 'Dorm' table.", "Determine the required columns: We need the names and types of the dorms, which correspond to 'dorm_name' and 'student_capacity' in the 'Dorm' table.", "Establish the filtering criteria: The question specifies a capacity greater than 300 or less than 100, which will be used in the WHERE clause.", "Construct the SQL query: Combine the selected columns and the filtering criteria into a complete SQL statement."], "gold_sql": "SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  300 OR student_capacity  <  100", "source_tables": ["dorm"], "pred_sql": "SELECT dorm_name, student_capacity FROM Dorm WHERE student_capacity > 300 OR student_capacity < 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables needed: We need to count students, so we will use the 'Lives_in' table to find students and the 'Dorm' table to filter by dormitory gender.", "Join the 'Lives_in' table with the 'Dorm' table on the dormid to associate students with their respective dorms.", "Filter the results to include only those dorms that are designated for males by checking the 'gender' column in the 'Dorm' table.", "Use the COUNT(*) function to count the total number of students living in male dorms."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(*) FROM Lives_in AS L JOIN Dorm AS D ON L.dormid = D.dormid WHERE D.gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5755", "db_id": "dorm_1", "question": "What is the most common amenity in the dorms?", "rationale": ["To find the most common amenity in the dorms, we need to count how many times each amenity appears in the Has_amenity table.", "We will join the Has_amenity table with the Dorm_amenity table to get the names of the amenities.", "We will group the results by amenity name to count the occurrences of each amenity.", "Finally, we will order the results by the count in descending order and limit the output to 1 to get the most common amenity."], "gold_sql": "SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_amenity", "dorm_amenity"], "pred_sql": "SELECT amenity_name, COUNT(*) as amenity_count FROM Has_amenity JOIN Dorm_amenity ON Has_amenity.amenid = Dorm_amenity.amenid GROUP BY amenity_name ORDER BY amenity_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.5757", "db_id": "dorm_1", "question": "What are the first names of all students who live in the dorm with the most amenities?", "rationale": ["Identify the tables involved: Student, Lives_in, Dorm, Has_amenity, and Dorm_amenity.", "We need to find the first names of students, so we will select the 'Fname' column from the Student table.", "Students live in dorms, so we will join the Student table with the Lives_in table on the student ID.", "To find the dorm with the most amenities, we will create a subquery that counts the amenities for each dorm.", "Join the Dorm table with the Has_amenity table to get the amenities for each dorm, and then join with Dorm_amenity to ensure we are counting the correct amenities.", "Group the results by dorm ID and order them by the count of amenities in descending order to find the dorm with the most amenities.", "Limit the subquery to 1 to get only the dorm with the highest count of amenities.", "Use the dorm ID from the subquery to filter the students who live in that dorm."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT T1.Fname FROM Student AS T1 JOIN Lives_in AS T2 ON T1.StuID = T2.stuid WHERE T2.dormid IN (SELECT T3.dormid FROM Dorm AS T3 JOIN Has_amenity AS T4 ON T3.dormid = T4.dormid JOIN Dorm_amenity AS T5 ON T4.amenid = T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who live in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students residing in specific dorms. It filters the dorms based on a subquery that counts the number of amenities in each dorm, ordering them by the count and limiting the results to a specified number of dormitories. The placeholder in the LIMIT clause represents the maximum number of dormitories to consider.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first names and ages of students who live in dormitories that do not offer a specific amenity. The placeholder in the subquery represents the name of the amenity being checked.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5776", "db_id": "customer_complaints", "question": "Find the emails of customers who has filed a complaints of the product with the most complaints.", "rationale": ["Identify the main goal: Find the emails of customers who have filed complaints about the product with the most complaints.", "To achieve this, we need to join the Customers table with the Complaints table on the customer_id.", "Next, we need to determine which product has the most complaints. This can be done by grouping the Complaints table by product_id and counting the number of complaints for each product.", "We will order the results of this count in descending order and limit the results to 1 to get the product_id of the product with the most complaints.", "Finally, we will use this product_id in the main query to filter the customers who have filed complaints about that product."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address FROM Customers AS c JOIN Complaints AS comp ON c.customer_id = comp.customer_id WHERE comp.product_id = (SELECT product_id FROM Complaints GROUP BY product_id ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the relevant tables: Customers and Complaints.", "We need to find the emails of customers who filed complaints, so we will join the Customers table with the Complaints table on customer_id.", "To find the product with the greatest number of complaints, we will use a subquery that groups the Complaints by product_id and orders them by the count of complaints in descending order, limiting the result to the top product.", "The outer query will select the email addresses from the Customers table where the customer_id matches those in the Complaints table for the product identified in the subquery."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address \nFROM Customers AS c \nJOIN Complaints AS co ON c.customer_id = co.customer_id \nWHERE co.product_id = \n    (SELECT product_id \n     FROM Complaints \n     GROUP BY product_id \n     ORDER BY COUNT(*) DESC \n     LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5779", "db_id": "customer_complaints", "question": "Return the names of products that have had complaints filed by the customer who has filed the fewest complaints.", "rationale": ["Identify the relevant tables: Products, Complaints, and Customers.", "We need to find products that have had complaints filed by customers.", "Join the Products table with the Complaints table on product_id to link products to their complaints.", "Join the resulting table with the Customers table on customer_id to link complaints to customers.", "Group the results by customer_id to count the number of complaints per customer.", "Order the results by the count of complaints in ascending order to find the customer with the fewest complaints.", "Select distinct product names from the Products table based on the complaints made by the customer with the fewest complaints.", "Limit the results to 1 to get only the products associated with the customer who has filed the fewest complaints."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT DISTINCT t1.product_name FROM Products AS t1 JOIN Complaints AS t2 ON t1.product_id = t2.product_id JOIN Customers AS t3 ON t2.customer_id = t3.customer_id GROUP BY t3.customer_id ORDER BY COUNT(t2.complaint_id) LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: Staff, Complaints, and Products are needed to find the last name of the staff member handling the complaint related to the product with the lowest price.", "Join the Staff table with the Complaints table on staff_id to link staff members to the complaints they handle.", "Join the resulting table with the Products table on product_id to access product details, specifically the product price.", "Order the results by product price in ascending order to ensure the product with the lowest price is at the top.", "Limit the results to 1 to get only the last name of the staff member handling the complaint for the lowest priced product."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT t1.last_name \nFROM Staff AS t1 \nJOIN Complaints AS t2 ON t1.staff_id = t2.staff_id \nJOIN Products AS t3 ON t2.product_id = t3.product_id \nORDER BY t3.product_price \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5800", "db_id": "customer_complaints", "question": "How many customers are there in the customer type with the most customers?", "rationale": ["Identify the relevant table: The question pertains to customers, so we will focus on the 'Customers' table.", "Count the number of customers for each customer type: We will use the COUNT() function to count the number of customers grouped by 'customer_type_code'.", "Order the results: To find the customer type with the most customers, we will order the results in descending order based on the count of customers.", "Limit the results: Since we only need the customer type with the most customers, we will limit the results to 1."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT customer_type_code, COUNT(*) as customer_count FROM Customers GROUP BY customer_type_code ORDER BY customer_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to find the first names of staff members, so we will select 'first_name' from the Staff table.", "To determine how many complaints each staff member has handled, we will join the Staff table with the Complaints table on 'staff_id'.", "We will group the results by 'staff_id' to aggregate the number of complaints handled by each staff member.", "We will use COUNT() to count the number of complaints for each staff member.", "To get the top 5 staff members who handled the greatest number of complaints, we will order the results in descending order based on the count of complaints and limit the results to 5."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT t1.first_name FROM Staff AS t1 JOIN Complaints AS t2 ON t1.staff_id = t2.staff_id GROUP BY t1.staff_id ORDER BY COUNT(t2.complaint_id) DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5812", "db_id": "customer_complaints", "question": "Which state has the most customers?", "rationale": ["Identify the relevant table: The question asks about customers, so we will focus on the Customers table.", "Determine the required information: We need to find out which state has the most customers, which means we need to count the number of customers in each state.", "Group the results by state: To count the customers per state, we will use the GROUP BY clause on the state column.", "Count the customers: We will use the COUNT function to count the number of customer IDs for each state.", "Order the results: To find the state with the most customers, we will order the results in descending order based on the customer count.", "Limit the results: Since we only want the state with the most customers, we will limit the results to 1."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT state, COUNT(customer_id) AS customer_count FROM Customers GROUP BY state ORDER BY customer_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct product names from the 'Products' table that have been associated with complaints. The query joins the 'Products' table with the 'Complaints' table based on the product identifier, and it groups the results by customer identifiers from the 'Customers' table. The results are ordered by the count of complaints for each customer, and a limit is applied to restrict the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5813", "db_id": "customer_complaints", "question": "Give the state that has the most customers.", "rationale": ["We need to find the state with the most customers.", "To do this, we will count the number of customers in each state.", "We will use the COUNT function to count the customer_id for each state.", "We will group the results by state using GROUP BY.", "To get the state with the highest count, we will order the results in descending order using ORDER BY.", "Finally, we will limit the results to 1 to get only the state with the most customers."], "gold_sql": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT state, COUNT(customer_id) AS customer_count \nFROM Customers \nGROUP BY state \nORDER BY customer_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of staff members who are handling complaints related to products, ordered by the price of those products. The placeholder in the LIMIT clause allows for specifying the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5865", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions whose share count is bigger than 100 and whose type code is \"PUR\"?", "rationale": ["Identify the tables involved: Lots, Transactions_Lots, and Transactions.", "We need to retrieve lot details, so we will select 'lot_details' from the Lots table.", "We need to join the Lots table with the Transactions_Lots table to link lots to transactions.", "Next, we join the Transactions_Lots table with the Transactions table to access transaction details.", "We apply the conditions: share count must be greater than 100 and the transaction type code must be 'PUR'.", "Construct the SQL query using the selected columns and the necessary joins with the specified conditions."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  100 AND T3.transaction_type_code  =  'PUR'", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT L.lot_details \nFROM Lots AS L \nJOIN Transactions_Lots AS TL ON L.lot_id = TL.lot_id \nJOIN Transactions AS T ON TL.transaction_id = T.transaction_id \nWHERE T.share_count > 100 AND T.transaction_type_code = 'PUR';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions where the number of shares involved in the transaction is less than a specified amount. The placeholders in the WHERE clause represent the numeric value for the share count.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the tables involved: Transactions and Ref_Transaction_Types.", "We need to calculate the average transaction amount, so we will use the AVG() function on the amount_of_transaction column from the Transactions table.", "To categorize the average amounts by transaction type, we will join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code.", "We will select the transaction_type_description from the Ref_Transaction_Types table and the average of the amount_of_transaction from the Transactions table.", "Finally, we will group the results by transaction_type_description to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "\n"}
{"sample_id": "train.5873", "db_id": "tracking_share_transactions", "question": "Show the number of transactions with transaction type code \"SALE\" for different investors if it is larger than 0.", "rationale": ["Identify the tables involved: Investors and Transactions.", "We need to count the number of transactions for each investor, specifically for those with a transaction type code of 'SALE'.", "Join the Investors table with the Transactions table on the investor_id column to link investors with their transactions.", "Use the COUNT() function to count the number of transactions for each investor where the transaction type code is 'SALE'.", "Group the results by investor_id to get the count for each investor.", "Use the HAVING clause to filter out investors with a transaction count of 0."], "gold_sql": "SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  'SALE' GROUP BY investor_id", "source_tables": ["transactions"], "pred_sql": "SELECT Investors.investor_id, COUNT(Transactions.transaction_id) AS transaction_count\nFROM Investors\nJOIN Transactions ON Investors.investor_id = Transactions.investor_id\nWHERE Transactions.transaction_type_code = 'SALE'\nGROUP BY Investors.investor_id\nHAVING COUNT(Transactions.transaction_id) > 0;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions where the number of shares involved in the transaction is less than a specified amount. The placeholders in the WHERE clause represent the numeric value for the share count.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5876", "db_id": "tracking_share_transactions", "question": "Show the transaction type code that occurs the most frequently.", "rationale": ["Identify the relevant table: The Transactions table contains the transaction_type_code that we need to analyze.", "Group the data: We need to group the results by transaction_type_code to count the occurrences of each type.", "Count occurrences: Use COUNT(*) to count how many times each transaction_type_code appears.", "Order the results: We will order the results in descending order based on the count to get the most frequent transaction type at the top.", "Limit the results: Since we only want the most frequent transaction type, we will limit the results to 1."], "gold_sql": "SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["transactions"], "pred_sql": "SELECT transaction_type_code\nFROM Transactions\nGROUP BY transaction_type_code\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5884", "db_id": "tracking_share_transactions", "question": "What are the details of the lots which are not used in any transactions?", "rationale": ["We need to find details of lots that are not used in any transactions.", "To achieve this, we can use a LEFT JOIN between the Lots table and the Transactions_Lots table on the lot_id.", "Next, we will also LEFT JOIN the Transactions table to ensure we can check if there are any associated transactions for those lots.", "In the WHERE clause, we will filter for cases where the transaction_id from the Transactions table is NULL, indicating that there are no transactions associated with those lots."], "gold_sql": "SELECT lot_details FROM Lots EXCEPT SELECT T1.lot_details FROM Lots AS T1 JOIN transactions_lots AS T2 ON T1.lot_id  =  T2.lot_id", "source_tables": ["lots", "transactions_lots"], "pred_sql": "SELECT L.lot_details \nFROM Lots AS L \nLEFT JOIN Transactions_Lots AS TL ON L.lot_id = TL.lot_id \nLEFT JOIN Transactions AS T ON TL.transaction_id = T.transaction_id \nWHERE T.transaction_id IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions where the number of shares involved in the transaction is less than a specified amount. The placeholders in the WHERE clause represent the numeric value for the share count.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5893", "db_id": "cre_Theme_park", "question": "Show details of all visitors.", "rationale": ["The task is to show details of all visitors, which means we need to select all columns from the Visitors table.", "The SQL query to retrieve all records from a table is done using the SELECT statement followed by the asterisk (*) to indicate all columns.", "The table we are interested in is the Visitors table, so we specify 'FROM Visitors' after the SELECT statement."], "gold_sql": "SELECT Tourist_Details FROM VISITORS", "source_tables": ["visitors"], "pred_sql": "SELECT * FROM Visitors;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5901", "db_id": "cre_Theme_park", "question": "What is the detail of the location UK Gallery?", "rationale": ["Identify the table that contains location details, which is the 'Locations' table.", "Determine the specific column that holds the name of the location, which is 'Location_Name'.", "Formulate a SQL query to select all columns from the 'Locations' table where the 'Location_Name' matches 'UK Gallery'."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name = 'UK Gallery';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5902", "db_id": "cre_Theme_park", "question": "Return the detail of the location named \"UK Gallery\".", "rationale": ["Identify the table that contains location details, which is the Locations table.", "Determine the columns needed: Location_Name, Address, and Other_Details.", "Formulate the SQL query to select these columns from the Locations table where the Location_Name matches 'UK Gallery'."], "gold_sql": "SELECT Other_Details FROM LOCATIONS WHERE Location_Name  =  'UK Gallery'", "source_tables": ["locations"], "pred_sql": "SELECT Location_Name, Address, Other_Details FROM Locations WHERE Location_Name = 'UK Gallery';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5914", "db_id": "cre_Theme_park", "question": "Give me the star rating descriptions of the hotels that cost more than 10000.", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings.", "Determine the columns needed: star_rating_description from Ref_Hotel_Star_Ratings and price_range from Hotels.", "Establish the relationship between the tables using the foreign key: Hotels.star_rating_code = Ref_Hotel_Star_Ratings.star_rating_code.", "Filter the hotels based on the price range condition: cost more than 10000.", "Construct the SQL query to select the star rating descriptions of the filtered hotels."], "gold_sql": "SELECT T2.star_rating_description FROM HOTELS AS T1 JOIN Ref_Hotel_Star_Ratings AS T2 ON T1.star_rating_code  =  T2.star_rating_code WHERE T1.price_range  >  10000", "source_tables": ["ref_hotel_star_ratings", "hotels"], "pred_sql": "SELECT R.star_rating_description FROM Hotels AS H JOIN Ref_Hotel_Star_Ratings AS R ON H.star_rating_code = R.star_rating_code WHERE H.price_range = 'More than 10000';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["The question asks for details and opening hours of museums, which means we need to retrieve data from the Museums table and the Tourist_Attractions table.", "The Museums table contains the details of the museums, while the Tourist_Attractions table contains the opening hours.", "To get the required information, we will perform a JOIN operation between the Museums table and the Tourist_Attractions table on the common key, which is the Tourist_Attraction_ID.", "The final SQL query will select the Museum_ID and Museum_Details from the Museums table and the Opening_Hours from the Tourist_Attractions table."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT M.Museum_ID, M.Museum_Details, T.Opening_Hours \nFROM Museums AS M \nJOIN Tourist_Attractions AS T ON M.Museum_ID = T.Tourist_Attraction_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Royal_Family.", "Determine the relationship between the tables: Tourist_Attractions has a foreign key linking to Royal_Family.", "Select all columns from Tourist_Attractions and the How_to_Get_There column to provide details and directions.", "Construct the SQL query using JOIN to combine the two tables based on the relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT TA.*, TA.How_to_Get_There \nFROM Tourist_Attractions AS TA \nJOIN Royal_Family AS RF ON TA.Tourist_Attraction_ID = RF.Royal_Family_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5924", "db_id": "cre_Theme_park", "question": "Find the details of the shops that can be reached by walk.", "rationale": ["Identify the relevant tables: Shops and Tourist_Attractions.", "Determine the relationship between Shops and Tourist_Attractions using the Shop_ID and Tourist_Attraction_ID.", "Filter the results based on the condition that the attractions can be reached by walking, which is indicated in the How_to_Get_There column of the Tourist_Attractions table.", "Construct the SQL query to select the Shop_ID and Shop_Details from the Shops table, joining it with the Tourist_Attractions table and applying the filter for walking."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT Shops.Shop_ID, Shops.Shop_Details \nFROM Shops \nJOIN Tourist_Attractions ON Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Tourist_Attractions.How_to_Get_There LIKE '%walk%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5927", "db_id": "cre_Theme_park", "question": "What are the details of the markets that can be accessed by walk or bus?", "rationale": ["Identify the relevant tables: Street_Markets and Tourist_Attractions.", "We need to retrieve details of street markets, which are stored in the Street_Markets table.", "Street markets are linked to tourist attractions through the Tourist_Attractions table, using the Market_ID as the identifier.", "We need to filter the results based on the accessibility of the markets, specifically those that can be accessed by walking or by bus.", "The condition for accessibility is found in the 'How_to_Get_There' column of the Tourist_Attractions table, where we will check for the presence of 'walk' or 'bus'.", "Construct the SQL query to select the Market_ID and Market_Details from the Street_Markets table, joining it with the Tourist_Attractions table, and applying the necessary WHERE clause for filtering."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "pred_sql": "SELECT SM.Market_ID, SM.Market_Details \nFROM Street_Markets AS SM \nJOIN Tourist_Attractions AS TA ON SM.Market_ID = TA.Tourist_Attraction_ID \nWHERE TA.How_to_Get_There LIKE '%walk%' OR TA.How_to_Get_There LIKE '%bus%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5928", "db_id": "cre_Theme_park", "question": "Find the details of all the markets that are accessible by walk or bus.", "rationale": ["Identify the relevant table for street markets, which is 'Street_Markets'.", "Determine the columns needed from the 'Street_Markets' table, which are 'Market_ID' and 'Market_Details'.", "Identify the condition for accessibility, which is based on the 'How_to_Get_There' column in the 'Tourist_Attractions' table.", "Use a subquery to select 'Tourist_Attraction_ID' from 'Tourist_Attractions' where 'How_to_Get_There' includes 'walk' or 'bus'.", "Combine the results of the subquery with the 'Street_Markets' table to filter the markets that are accessible by walk or bus."], "gold_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk' OR  T2.How_to_Get_There  =  'bus'", "source_tables": ["street_markets", "tourist_attractions"], "pred_sql": "SELECT Market_ID, Market_Details FROM Street_Markets WHERE Market_ID IN (SELECT Tourist_Attraction_ID FROM Tourist_Attractions WHERE How_to_Get_There LIKE '%walk%' OR How_to_Get_There LIKE '%bus%');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "Determine the relevant columns needed to retrieve the details of the hotels, which are all columns in this case.", "To find the most expensive hotels, we need to sort the hotels by their price range in descending order.", "Use the ORDER BY clause to sort the results by 'price_range' in descending order.", "Limit the results to the top three entries using the LIMIT clause."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5943", "db_id": "cre_Theme_park", "question": "Show the details and star ratings of the 3 least expensive hotels.", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings.", "We need to select hotel details and their star ratings, so we will select columns from both tables: hotel_id and price_range from Hotels, and star_rating_description from Ref_Hotel_Star_Ratings.", "Join the Hotels table with the Ref_Hotel_Star_Ratings table on the star_rating_code to get the star rating descriptions for each hotel.", "Order the results by price_range in ascending order to find the least expensive hotels.", "Limit the results to 3 to get only the three least expensive hotels."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT H.hotel_id, H.price_range, R.star_rating_description \nFROM Hotels AS H \nJOIN Ref_Hotel_Star_Ratings AS R ON H.star_rating_code = R.star_rating_code \nORDER BY H.price_range ASC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["The question asks for the transportation method most people choose to get to tourist attractions, which is represented by the 'How_to_Get_There' column in the 'Tourist_Attractions' table.", "To find the most popular transportation method, we need to count how many visits correspond to each method. This requires joining the 'Tourist_Attractions' table with the 'Visits' table on the 'Tourist_Attraction_ID'.", "We will group the results by 'How_to_Get_There' to aggregate the counts of visits for each transportation method.", "To determine the most chosen method, we will order the results by the count of visits in descending order and limit the output to the top result."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Visit_Count \nFROM Tourist_Attractions AS T1 \nJOIN Visits AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nGROUP BY How_to_Get_There \nORDER BY Visit_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions and Visits are needed to determine how tourists get to attractions and how often they visit them.", "Join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID to link visits to their respective attractions.", "Select the How_to_Get_There column from the Tourist_Attractions table to find out the transportation methods used.", "Count the number of visits for each transportation method using COUNT(*) and group the results by How_to_Get_There.", "Order the results by the count of visits in descending order to find the most frequently used transportation method.", "Limit the results to 1 to get the top transportation method."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT How_to_Get_There, COUNT(*) as Visit_Count FROM Tourist_Attractions AS T1 JOIN Visits AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID GROUP BY How_to_Get_There ORDER BY Visit_Count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5951", "db_id": "cre_Theme_park", "question": "Show different tourist attractions' names, ids, and the corresponding number of visits.", "rationale": ["We need to show the names and IDs of different tourist attractions along with the number of visits they received.", "To achieve this, we will select the 'Tourist_Attraction_ID' and 'Name' from the 'Tourist_Attractions' table.", "We will also need to count the number of visits for each attraction, which can be done by joining the 'Visits' table on 'Tourist_Attraction_ID'.", "Using a LEFT JOIN allows us to include attractions that may not have any visits, ensuring we still list all attractions.", "We will group the results by 'Tourist_Attraction_ID' and 'Name' to aggregate the visit counts correctly."], "gold_sql": "SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT T1.Tourist_Attraction_ID, T1.Name, COUNT(T2.Visit_ID) AS Number_of_Visits \nFROM Tourist_Attractions AS T1 \nLEFT JOIN Visits AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nGROUP BY T1.Tourist_Attraction_ID, T1.Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions to their features.", "Join the resulting table with the Features table to access the feature details.", "Filter the results to include only those attractions that have 'parking' or 'shopping' as their feature details."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT T1.Name \nFROM Tourist_Attractions AS T1 \nJOIN Tourist_Attraction_Features AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nJOIN Features AS T3 ON T2.Feature_ID = T3.Feature_ID \nWHERE T3.Feature_Details IN ('parking', 'shopping')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions to their features.", "Join the resulting table with the Features table to access the feature details.", "Filter the results to include only those attractions that have 'parking' or 'shopping' as their feature details.", "Select the names of the tourist attractions that meet the criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT T.Name \nFROM Tourist_Attractions AS T \nJOIN Tourist_Attraction_Features AS F ON T.Tourist_Attraction_ID = F.Tourist_Attraction_ID \nJOIN Features AS D ON F.Feature_ID = D.Feature_ID \nWHERE D.Feature_Details IN ('parking', 'shopping')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5964", "db_id": "cre_Theme_park", "question": "Which tourist attractions do the tourists Vincent and Marcelle visit? Tell me the names of the attractions.", "rationale": ["Identify the tables involved: Tourist_Attractions, Visits, and Visitors.", "We need to find the names of tourist attractions visited by both Vincent and Marcelle.", "Use JOINs to connect the Tourist_Attractions table with Visits and Visitors to filter by tourist details.", "Use INTERSECT to find common attractions visited by both tourists.", "Construct the SQL query using the identified tables and conditions."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT T1.Name \nFROM Tourist_Attractions AS T1 \nJOIN Visits AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nJOIN Visitors AS T3 ON T2.Tourist_ID = T3.Tourist_ID \nWHERE T3.Tourist_Details = 'Vincent' \nINTERSECT \nSELECT T1.Name \nFROM Tourist_Attractions AS T1 \nJOIN Visits AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nJOIN Visitors AS T3 ON T2.Tourist_ID = T3.Tourist_ID \nWHERE T3.Tourist_Details = 'Marcelle'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, excluding those that have been visited by another specified tourist. The placeholders in the WHERE clause represent the details of the tourists.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist. The query joins the 'Tourist_Attractions' table with the 'Visits' table to link attractions to visits, and then further joins with the 'Visitors' table to filter by the specific tourist's details. The placeholder in the WHERE clause represents the details of the tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6059", "db_id": "customers_and_addresses", "question": "What is the average amount of items ordered in each order?", "rationale": ["To find the average amount of items ordered in each order, we need to focus on the 'Order_Items' table, which contains the 'order_quantity' for each product in an order.", "We will use the AVG() function to calculate the average of 'order_quantity'.", "Since we want the average per order, we will group the results by 'order_id' to ensure we get the average for each individual order.", "The final SQL query will select the average quantity of items ordered, grouped by each order."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT AVG(order_quantity) AS average_items_ordered FROM Order_Items GROUP BY order_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.\",\n        \"virtual_table\": \"SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)\"\n    }\n}\n"}
{"sample_id": "train.6066", "db_id": "customers_and_addresses", "question": "Find the payment method that is used most frequently.", "rationale": ["Identify the relevant table: The question asks about payment methods, which are stored in the Customers table.", "Count the occurrences of each payment method: Use the COUNT function to tally how many times each payment method appears.", "Group the results by payment method: Use GROUP BY to aggregate the counts for each unique payment method.", "Order the results by frequency: Use ORDER BY to sort the counts in descending order, so the most frequent payment method appears first.", "Limit the results to one: Use LIMIT 1 to return only the most frequently used payment method."], "gold_sql": "SELECT payment_method FROM customers GROUP BY payment_method ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT payment_method, COUNT(payment_method) AS frequency\nFROM Customers\nGROUP BY payment_method\nORDER BY frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses are needed to find the city of customers.", "Join the tables: Use JOIN to connect Customers with Customer_Addresses and then with Addresses based on their foreign key relationships.", "Group by city: Use GROUP BY to aggregate the results by city to count the number of customers in each city.", "Order the results: Use ORDER BY count(*) DESC to sort the cities by the number of customers in descending order.", "Limit the results: Use LIMIT 1 to get only the city with the most customers."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT t3.city FROM Customers AS t1 JOIN Customer_Addresses AS t2 ON t1.customer_id = t2.customer_id JOIN Addresses AS t3 ON t2.address_id = t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.\",\n        \"virtual_table\": \"SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6098", "db_id": "customers_and_addresses", "question": "Find the contact channel code that was used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to find the contact channel code for a specific customer, so we will join the Customers table with the Customer_Contact_Channels table on the customer_id.", "Filter the results to only include the customer named 'Tillman Ernser'.", "Select the channel_code from the Customer_Contact_Channels table."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT Customer_Contact_Channels.channel_code \nFROM Customers \nJOIN Customer_Contact_Channels ON Customers.customer_id = Customer_Contact_Channels.customer_id \nWHERE Customers.customer_name = 'Tillman Ernser';", "hint": "\n"}
{"sample_id": "train.6099", "db_id": "customers_and_addresses", "question": "What is the \"active to date\" of the latest contact channel used by \"Tillman Ernser\"?", "rationale": ["Identify the relevant tables: Customer_Contact_Channels and Customers.", "We need to find the 'active to date' for the contact channel associated with the customer named 'Tillman Ernser'.", "Join the Customer_Contact_Channels table with the Customers table on the customer_id to link contact channels to the customer.", "Filter the results to only include the customer with the name 'Tillman Ernser'.", "To get the latest contact channel, we will order the results by 'active_from_date' in descending order.", "Limit the results to 1 to get only the latest contact channel's 'active to date'."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT Customer_Contact_Channels.active_to_date \nFROM Customer_Contact_Channels \nJOIN Customers ON Customer_Contact_Channels.customer_id = Customers.customer_id \nWHERE Customers.customer_name = 'Tillman Ernser' \nORDER BY Customer_Contact_Channels.active_from_date DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the customer ID for 'Tillman Ernser' from the Customers table.", "Use the identified customer ID to find the active contact channels in the Customer_Contact_Channels table.", "Sort the results by 'active_from_date' in descending order to get the latest contact channel.", "Limit the results to 1 to get only the latest contact channel's 'active_to_date'."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT active_to_date \nFROM Customer_Contact_Channels \nWHERE customer_id = (\n    SELECT customer_id \n    FROM Customers \n    WHERE customer_name = 'Tillman Ernser'\n) \nORDER BY active_from_date DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the contact channel information.", "Determine the columns needed: active_from_date and active_to_date are necessary to calculate the time span.", "Calculate the time span: Use the julianday function to convert the dates to Julian day numbers and find the difference.", "Use AVG function: To find the average of the calculated time spans.", "Filter out inactive channels: Ensure that only channels with a valid active_to_date are considered."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_time_span\nFROM Customer_Contact_Channels\nWHERE active_to_date IS NOT NULL;", "hint": "\n"}
{"sample_id": "train.6102", "db_id": "customers_and_addresses", "question": "Compute the average active time span of contact channels.", "rationale": ["Identify the relevant table: The question pertains to contact channels, so we will use the Customer_Contact_Channels table.", "Determine the columns needed: We need the active_from_date and active_to_date to calculate the active time span.", "Calculate the time span: We can use the julianday function to convert the dates to Julian day numbers and subtract them to get the difference in days.", "Compute the average: We will use the AVG function to compute the average of the calculated time spans.", "Filter out inactive channels: We will include a WHERE clause to ensure we only consider channels that have an active_to_date (i.e., they are not currently active)."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_active_time_span\nFROM Customer_Contact_Channels\nWHERE active_to_date IS NOT NULL;", "hint": "\n"}
{"sample_id": "train.6104", "db_id": "customers_and_addresses", "question": "Return the channel code and contact number of the customer contact channel whose active duration was the longest.", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the channel code and contact number.", "Determine the duration of activity for each contact channel by calculating the difference between active_to_date and active_from_date using julianday function.", "Use a subquery to find the maximum duration of activity across all contact channels.", "Select the channel_code and contact_number where the duration equals the maximum duration found in the subquery."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number FROM Customer_Contact_Channels WHERE (julianday(active_to_date) - julianday(active_from_date)) = (SELECT max(julianday(active_to_date) - julianday(active_from_date)) FROM Customer_Contact_Channels)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.\",\n        \"virtual_table\": \"SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)\"\n    }\n}\n"}
{"sample_id": "train.6105", "db_id": "customers_and_addresses", "question": "Find the name and active date of the customer that use email as the contact channel.", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to retrieve the customer name and the active date of the contact channel.", "Join the Customers table with the Customer_Contact_Channels table on the customer_id field.", "Filter the results to include only those records where the channel_code is 'email'.", "Additionally, ensure that the contact channel is currently active by checking that active_to_date is NULL."], "gold_sql": "SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  'Email'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT c.customer_name, cc.active_from_date \nFROM Customers c \nJOIN Customer_Contact_Channels cc ON c.customer_id = cc.customer_id \nWHERE cc.channel_code = 'email' AND cc.active_to_date IS NULL;", "hint": "\n"}
{"sample_id": "train.6127", "db_id": "customers_and_addresses", "question": "Who made the latest order?", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Order_Items are needed to find out who made the latest order.", "Join the Customers table with Customer_Orders to link customers to their orders using customer_id.", "Join the resulting table with Order_Items to access the order details and quantities.", "To find the latest order, we need to filter the Customer_Orders by the maximum order_date.", "The final query selects the customer_name from the Customers table where the order_date is the maximum order_date from the Customer_Orders table."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id ORDER BY t2.order_date DESC LIMIT 1", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT t1.customer_name FROM Customers AS t1 JOIN Customer_Orders AS t2 ON t1.customer_id = t2.customer_id JOIN Order_Items AS t3 ON t2.order_id = t3.order_id WHERE t2.order_date = (SELECT max(order_date) FROM Customer_Orders)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.\",\n        \"virtual_table\": \"SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)\"\n    }\n}\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["Identify the tables involved: Products and Order_Items.", "We need to find the product with the largest total order quantity, so we will join the Products table with the Order_Items table on product_id.", "We will use a subquery to find the maximum order quantity from the Order_Items table.", "The main query will select the product_id and product_details from the Products table where the order quantity matches the maximum found in the subquery."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT p.product_id, p.product_details FROM Products AS p JOIN Order_Items AS oi ON p.product_id = oi.product_id WHERE oi.order_quantity = (SELECT MAX(order_quantity) FROM Order_Items)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of customers who have placed orders containing the maximum quantity of any product. It joins the 'Customers' table with the 'Customer_Orders' table to link customers to their orders, and then further joins with the 'Order_Items' table to access the order quantities. The placeholder in the WHERE clause is used to filter for the maximum order quantity across all orders.\",\n        \"virtual_table\": \"SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)\"\n    }\n}\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The Addresses table contains the information about addresses, including city and state.", "Determine the conditions: We need to find addresses in two specific cities (East Julianaside and Gleasonmouth) and their corresponding states (Texas and Arizona).", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the Addresses table where the city and state match the specified criteria.", "Combine the conditions using OR to ensure that either of the two city-state pairs can be returned."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.\",\n        \"virtual_table\": \"SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6134", "db_id": "customers_and_addresses", "question": "What are all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The Addresses table contains the information about addresses, including city and state.", "Determine the conditions: We need to filter addresses based on two specific cities (East Julianaside and Gleasonmouth) and their respective states (Texas and Arizona).", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the Addresses table where the city and state match the specified criteria.", "Combine the conditions using OR to ensure that addresses from either city/state combination are included."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities where customers are located, derived from the 'Customers', 'Customer_Addresses', and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.\",\n        \"virtual_table\": \"SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the relevant table: The 'match' table contains the 'Competition' column which is needed to find the match ID.", "Formulate the SQL query: We need to select the 'Match_ID' from the 'match' table where the 'Competition' matches '1994 FIFA World Cup qualification'.", "Construct the SQL query: The final SQL query is constructed to retrieve the match ID based on the specified competition."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT Match_ID FROM match WHERE Competition = '1994 FIFA World Cup qualification';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n        \"virtual_table\": \"SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6275", "db_id": "city_record", "question": "Find the city that hosted the most events.", "rationale": ["To find the city that hosted the most events, we need to count the number of matches hosted by each city.", "The 'hosting_city' table contains the 'Host_City' and 'Match_ID', which allows us to group by 'Host_City' and count the occurrences of 'Match_ID'.", "We will use the COUNT function to count the number of matches for each city.", "To get the city with the most events, we will order the results in descending order based on the count and limit the results to 1."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT Host_City, COUNT(Match_ID) AS Event_Count FROM hosting_city GROUP BY Host_City ORDER BY Event_Count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n        \"virtual_table\": \"SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6282", "db_id": "city_record", "question": "Which three cities have the largest regional population?", "rationale": ["Identify the table that contains the relevant data: the 'city' table contains the 'City' and 'Regional_Population' columns.", "To find the three cities with the largest regional population, we need to sort the cities by 'Regional_Population' in descending order.", "We will use the 'ORDER BY' clause to sort the results and the 'LIMIT' clause to restrict the output to the top three cities."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "pred_sql": "SELECT City, Regional_Population FROM city ORDER BY Regional_Population DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6283", "db_id": "city_record", "question": "What are the three largest cities in terms of regional population?", "rationale": ["Identify the table that contains the relevant data for cities and their populations, which is the 'city' table.", "To find the largest cities by regional population, we need to select the 'City' and 'Regional_Population' columns from the 'city' table.", "We need to order the results by 'Regional_Population' in descending order to get the largest cities first.", "Finally, we limit the results to the top three cities using 'LIMIT 3'."], "gold_sql": "SELECT city FROM city ORDER BY regional_population DESC LIMIT 3", "source_tables": ["city"], "pred_sql": "SELECT City, Regional_Population FROM city ORDER BY Regional_Population DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n        \"virtual_table\": \"SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables: We need data from the 'city' table for city names and the 'temperature' table for February temperatures.", "Join the 'city' table with the 'temperature' table on the 'City_ID' to access both city names and their corresponding February temperatures.", "Use the ORDER BY clause to sort the results by the February temperature in descending order, so the highest temperature comes first.", "Limit the results to 1 to get only the city with the highest temperature in February."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID ORDER BY T2.Feb DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n        \"virtual_table\": \"SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables.", "Determine the conditions: We want cities where the average temperature in March is lower than in July or higher than in October.", "Construct the SQL query: Use a JOIN to combine the 'city' and 'temperature' tables on 'City_ID'.", "Apply the conditions using a WHERE clause to filter the results based on the temperature comparisons."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID WHERE T2.Mar < T2.Jul OR T2.Mar > T2.Oct", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6290", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in July and which have also served as host cities?", "rationale": ["Identify the cities from the 'city' table that have a corresponding temperature record in the 'temperature' table.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data.", "Filter the results to include only those cities where the average temperature in March (T2.Mar) is lower than in July (T2.Jul).", "Next, identify the cities that have hosted a match by joining the 'city' table with the 'hosting_city' table on 'City_ID' and 'Host_City'.", "Use the INTERSECT operator to find cities that meet both conditions: lower temperature in March compared to July and have hosted a match."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID WHERE T2.Mar < T2.Jul INTERSECT SELECT T3.City FROM city AS T3 JOIN hosting_city AS T4 ON T3.City_ID = T4.Host_City", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n        \"virtual_table\": \"SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the cities from the 'city' table that have a lower average temperature in March compared to December.", "Join the 'temperature' table to access the temperature data for each city.", "Use the condition T2.Mar < T2.Dec to filter cities with lower temperatures in March than in December.", "Next, we need to exclude cities that have hosted matches.", "Join the 'hosting_city' table to find cities that have hosted matches.", "Use the EXCEPT clause to exclude these cities from the final result."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID WHERE T2.Mar < T2.Dec EXCEPT SELECT T3.City FROM city AS T3 JOIN hosting_city AS T4 ON T3.City_ID = T4.Host_City", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n        \"virtual_table\": \"SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6295", "db_id": "city_record", "question": "Which cities have higher temperature in Feb than in Jun or have once served as host cities?", "rationale": ["Identify the cities from the 'city' table that have temperature data in the 'temperature' table.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Filter the results to find cities where the average temperature in February (Feb) is higher than in June (Jun).", "Additionally, identify cities that have hosted matches by joining the 'city' table with the 'hosting_city' table on 'City_ID' and 'Host_City'.", "Use a UNION to combine the results of cities with higher temperatures in February than June and those that have hosted matches."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID WHERE T2.Feb > T2.Jun UNION SELECT T3.City FROM city AS T3 JOIN hosting_city AS T4 ON T3.City_ID = T4.Host_City", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities that have a higher average temperature in March compared to December, excluding those cities that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n        \"virtual_table\": \"SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6324", "db_id": "e_government", "question": "Find the last name of the first ever contact person of the organization with the highest UK Vat number.", "rationale": ["Identify the organization with the highest UK VAT number by ordering the Organizations table by the uk_vat_number in descending order and limiting the result to 1.", "Use the organization_id of the identified organization to find the contact individuals associated with it by joining the Organization_Contact_Individuals table.", "Join the Individuals table to retrieve the last names of the contact individuals.", "Order the results by the date_contact_to in ascending order to get the first contact person.", "Limit the results to 1 to get only the first contact person's last name."], "gold_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT 1", "source_tables": ["organizations", "organization_contact_individuals", "individuals"], "pred_sql": "SELECT t3.individual_last_name FROM Organizations AS t1 JOIN Organization_Contact_Individuals AS t2 ON t1.organization_id = t2.organization_id JOIN Individuals AS t3 ON t2.individual_id = t3.individual_id WHERE t1.organization_id = (SELECT organization_id FROM Organizations ORDER BY uk_vat_number DESC LIMIT 1) ORDER BY t2.date_contact_to ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of individuals who have contacted a specific organization. It retrieves data from the 'Organizations', 'Organization_Contact_Individuals', and 'Individuals' tables, filtering based on the organization's name. The results are ordered by the end date of the contact period, and a limit is applied to the number of results returned.\",\n        \"virtual_table\": \"SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY t2.date_contact_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6328", "db_id": "e_government", "question": "Find name of the services that has never been used.", "rationale": ["Identify the table that contains the service names, which is the Services table.", "We need to find services that have never been used, which means we need to check against the Party_Services table where service bookings are recorded.", "To find services that have never been used, we can select service names from the Services table where the service_id is not present in the Party_Services table.", "Construct the SQL query using a subquery to filter out the used services from the Services table."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name \nFROM Services \nWHERE service_id NOT IN (SELECT service_id FROM Party_Services);", "hint": "\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The question asks for cities and states, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' for cities and 'state_province_county' for states.", "Use DISTINCT to avoid duplicate entries: Since the same city or state may appear multiple times, we use DISTINCT to get unique values.", "Construct the SQL query: Combine the selected columns and table into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6331", "db_id": "e_government", "question": "What are the names of all cities and states?", "rationale": ["Identify the relevant table: The question asks for city and state names, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' and 'state_province_county' from the Addresses table.", "Use DISTINCT to avoid duplicate entries: Since cities and states can repeat, we use DISTINCT to get unique combinations of city and state.", "Construct the SQL query: Combine the selected columns and table into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the tables involved: Organizations, Organization_Contact_Individuals, and Individuals.", "Determine the relationship between these tables: Organization_Contact_Individuals links individuals to organizations.", "Select the last name of individuals from the Individuals table.", "Join the Organizations table to get the organization details and the Organization_Contact_Individuals table to link individuals to organizations.", "The query will retrieve the last names of individuals who have contacted organizations."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT t3.individual_last_name FROM Organizations AS t1 JOIN Organization_Contact_Individuals AS t2 ON t1.organization_id = t2.organization_id JOIN Individuals AS t3 ON t2.individual_id = t3.individual_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of individuals who have contacted a specific organization. It retrieves data from the 'Organizations', 'Organization_Contact_Individuals', and 'Individuals' tables, filtering based on the organization's name. The results are ordered by the end date of the contact period, and a limit is applied to the number of results returned.\",\n        \"virtual_table\": \"SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY t2.date_contact_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6723", "db_id": "activity_1", "question": "Show the first name, last name, and phone number for all female faculty members.", "rationale": ["Identify the relevant table: Faculty, which contains information about faculty members.", "Select the columns needed: Fname, Lname, and Phone from the Faculty table.", "Add a condition to filter for female faculty members by checking the Sex column for 'Female'.", "Construct the SQL query using the SELECT statement with the specified columns and the WHERE clause for filtering."], "gold_sql": "SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  'F'", "source_tables": ["faculty"], "pred_sql": "SELECT F.Fname, F.Lname, F.Phone FROM Faculty AS F WHERE F.Sex = 'Female';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the table that contains faculty information, which is the Faculty table.", "Determine the column that indicates the gender of faculty members, which is the 'Sex' column in the Faculty table.", "Formulate a SQL query to select the 'FacID' of faculty members where the 'Sex' is 'Male'."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'Male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6738", "db_id": "activity_1", "question": "Find the building that has the largest number of faculty members.", "rationale": ["To find the building with the largest number of faculty members, we need to count the number of faculty members in each building.", "We will use the COUNT function to count the number of unique faculty IDs (FacID) for each building.", "We will group the results by the 'Building' column to get the count for each building.", "To get the building with the largest number of faculty members, we will order the results in descending order based on the count of faculty members.", "Finally, we will limit the results to 1 to get only the building with the highest count."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(FacID) AS FacultyCount \nFROM Faculty \nGROUP BY Building \nORDER BY FacultyCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6740", "db_id": "activity_1", "question": "In which buildings are there at least ten professors?", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their building and unique identifiers.", "Count the number of faculty members in each building: Use COUNT(FacID) to count the number of professors in each building.", "Group the results by building: Use GROUP BY Building to aggregate the counts for each building.", "Filter the results to include only buildings with at least ten professors: Use HAVING COUNT(FacID) >= 10 to filter the groups."], "gold_sql": "SELECT building FROM Faculty WHERE rank  =  'Professor' GROUP BY building HAVING count(*)  >=  10", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(FacID) as ProfessorCount \nFROM Faculty \nGROUP BY Building \nHAVING COUNT(FacID) >= 10;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: Faculty, which contains information about faculty members including their rank and gender.", "Filter the faculty members to only include those with the rank of 'Assistant Professor'.", "Group the results by the 'Sex' column to count the number of male and female assistant professors.", "Use the COUNT function to get the number of faculty members for each gender."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) as count FROM Faculty WHERE Rank = 'Assistant Professor' GROUP BY Sex;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the Student table as it contains information about students including their advisors.", "To find the advisor of Linda Smith, we need to first locate her record in the Student table using her first and last name.", "Once we have Linda's record, we can retrieve her advisor's ID from the Advisor column.", "Next, we will use this advisor ID to find the corresponding advisor's first and last name from the Faculty table.", "The final SQL query will select the first name and last name of the advisor based on the advisor ID obtained from Linda's record."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE StuID = (SELECT Advisor FROM Student WHERE Fname = 'Linda' AND LName = 'Smith')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["Identify the relevant tables: We need to find students and their advisors, which involves the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the SQL query: We will select the distinct student IDs (StuID) from the Student table where the Advisor matches the FacID in the Faculty table."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT DISTINCT Student.StuID \nFROM Student \nJOIN Faculty ON Student.Advisor = Faculty.FacID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the relevant tables: We need to retrieve student information, which is in the 'Student' table, and we need to find the advisor's ID from the 'Faculty' table.", "Determine the relationship: The 'Student' table has a column 'Advisor' that corresponds to the 'FacID' in the 'Faculty' table.", "Construct a subquery: We will create a subquery to find the 'FacID' of the faculty member named Michael Goodrich.", "Combine the queries: Use the result of the subquery to filter the students in the main query, selecting their first and last names."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE Advisor = (SELECT FacID FROM Faculty WHERE Fname = 'Michael' AND Lname = 'Goodrich')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6759", "db_id": "activity_1", "question": "What are the first and last name of the faculty who has the most students?", "rationale": ["Identify the tables involved: Faculty, Faculty_Participates_in, and Participates_in.", "We need to join these tables to connect faculty members with the students they supervise through activities.", "Use JOIN to connect Faculty with Faculty_Participates_in on FacID, and then join with Participates_in on actid.", "Group the results by faculty ID to count the number of students associated with each faculty member.", "Order the results by the count of students in descending order to find the faculty member with the most students.", "Limit the results to 1 to get only the faculty member with the highest count."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty", "student"], "pred_sql": "SELECT F.Fname, F.Lname \nFROM Faculty AS F \nJOIN Faculty_Participates_in AS FP ON F.FacID = FP.FacID \nJOIN Participates_in AS P ON FP.actid = P.actid \nGROUP BY F.FacID \nORDER BY COUNT(P.stuid) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6765", "db_id": "activity_1", "question": "What activities do we have?", "rationale": ["The question asks for a list of activities, which corresponds to the 'activity_name' column in the 'Activity' table.", "To retrieve the names of all activities, we need to select the 'activity_name' from the 'Activity' table without any conditions or joins, as we are not filtering or relating to other tables."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "pred_sql": "SELECT activity_name FROM Activity;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6766", "db_id": "activity_1", "question": "List all the activities we have.", "rationale": ["The task is to list all the activities available in the database.", "To achieve this, we need to select the 'activity_name' column from the 'Activity' table.", "The 'Activity' table contains all the activities, and selecting the 'activity_name' will give us the names of all activities.", "The SQL query is straightforward as it only requires a SELECT statement without any conditions or joins."], "gold_sql": "SELECT activity_name FROM Activity", "source_tables": ["activity"], "pred_sql": "SELECT activity_name FROM Activity;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6780", "db_id": "activity_1", "question": "What is the first and last name of the faculty members who participated in at least one activity? For each of them, also show the number of activities they participated in.", "rationale": ["Identify the relevant tables: Faculty and Faculty_Participates_in.", "We need to select the first name (Fname) and last name (Lname) of faculty members.", "We also need to count the number of activities each faculty member participated in, which can be done using COUNT on the actid from Faculty_Participates_in.", "Join the Faculty table with Faculty_Participates_in on the FacID to link faculty members with their activities.", "Group the results by faculty member to aggregate the count of activities.", "Use HAVING to filter out faculty members who have not participated in any activities (i.e., count > 0)."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname, F.Lname, COUNT(FPI.actid) AS activity_count\nFROM Faculty AS F\nJOIN Faculty_Participates_in AS FPI ON F.FacID = FPI.FacID\nGROUP BY F.FacID, F.Fname, F.Lname\nHAVING COUNT(FPI.actid) > 0;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6781", "db_id": "activity_1", "question": "Show all the activity names and the number of faculty involved in each activity.", "rationale": ["Identify the tables needed: Activity and Faculty_Participates_in.", "We need to show activity names and count the number of faculty involved in each activity.", "Join the Activity table with Faculty_Participates_in on the actid column.", "Use COUNT to count the number of faculty members for each activity.", "Group the results by activity_name to get the count for each activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "pred_sql": "SELECT A.activity_name, COUNT(FP.FacID) AS faculty_count \nFROM Activity AS A \nLEFT JOIN Faculty_Participates_in AS FP ON A.actid = FP.actid \nGROUP BY A.activity_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6782", "db_id": "activity_1", "question": "How many faculty members participate in each activity? Return the activity names and the number of faculty members.", "rationale": ["Identify the tables needed: Activity and Faculty_Participates_in.", "We need to count the number of faculty members participating in each activity, so we will use a COUNT function.", "Join the Activity table with the Faculty_Participates_in table on the actid column to link activities with faculty participation.", "Use a LEFT JOIN to ensure we include activities even if no faculty members participate in them.", "Group the results by activity_name to get the count of faculty members for each activity."], "gold_sql": "SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID", "source_tables": ["activity", "faculty_participates_in"], "pred_sql": "SELECT A.activity_name, COUNT(FP.FacID) AS faculty_count \nFROM Activity AS A \nLEFT JOIN Faculty_Participates_in AS FP ON A.actid = FP.actid \nGROUP BY A.activity_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: We need to find students who participate in activities, so we will use the 'Participates_in' and 'Student' tables.", "Determine the columns needed: We need the student IDs ('stuid') from the 'Participates_in' table and the age from the 'Student' table.", "Join the tables: We will join 'Participates_in' with 'Student' on the student ID to get the necessary information about the students.", "Apply the age filter: We need to filter the results to include only those students who are under 20 years old.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT P.stuid FROM Participates_in AS P JOIN Student AS S ON P.stuid = S.StuID WHERE S.Age < 20;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6795", "db_id": "activity_1", "question": "Find the first names of the faculty members who are playing Canoeing or Kayaking.", "rationale": ["Identify the tables needed: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members, so we will select from the Faculty table.", "We need to join the Faculty table with the Faculty_Participates_in table to find out which activities they participate in.", "Next, we join with the Activity table to filter by the activity names 'Canoeing' and 'Kayaking'.", "We use the DISTINCT keyword to ensure that we only get unique first names of faculty members who participate in either of the two activities."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT DISTINCT F.Fname \nFROM Faculty AS F \nJOIN Faculty_Participates_in AS FP ON F.FacID = FP.FacID \nJOIN Activity AS A ON FP.actid = A.actid \nWHERE A.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6796", "db_id": "activity_1", "question": "Which faculty members are playing either Canoeing or Kayaking? Tell me their first names.", "rationale": ["Identify the relevant tables: Faculty, Faculty_Participates_in, and Activity.", "We need to find faculty members who participate in either Canoeing or Kayaking, so we will join the Faculty table with the Faculty_Participates_in table on FacID, and then join with the Activity table on actid.", "Use a WHERE clause to filter the activities to 'Canoeing' or 'Kayaking'.", "Select the distinct first names of the faculty members who meet the criteria."], "gold_sql": "SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT DISTINCT F.Fname \nFROM Faculty AS F \nJOIN Faculty_Participates_in AS FP ON F.FacID = FP.FacID \nJOIN Activity AS A ON FP.actid = A.actid \nWHERE A.activity_name IN ('Canoeing', 'Kayaking');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the main goal: We need to find the first names of professors who do not participate in Canoeing or Kayaking activities.", "Use the Faculty table to get the first names of all faculty members.", "To exclude those who participate in Canoeing or Kayaking, we will use an EXCEPT clause.", "The subquery will join Faculty, Faculty_Participates_in, and Activity tables to find faculty members who participate in either Canoeing or Kayaking.", "In the subquery, we filter the activities by their names and select distinct first names of faculty members who participate in those activities."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty AS F \nEXCEPT \nSELECT DISTINCT F1.Fname \nFROM Faculty AS F1 \nJOIN Faculty_Participates_in AS FP ON F1.FacID = FP.FacID \nJOIN Activity AS A ON FP.actid = A.actid \nWHERE A.activity_name = 'Canoeing' OR A.activity_name = 'Kayaking';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of faculty members who hold a specific academic rank but do not participate in certain activities. The placeholders in the query represent the rank of the faculty and the names of the activities they do not participate in.\",\n        \"virtual_table\": \"SELECT lname FROM faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the activities of interest: Canoeing and Kayaking.", "Find the activity IDs (actid) for these activities from the Activity table.", "Use a subquery to select the actid for Canoeing and Kayaking.", "Join the Participates_in table to find the student IDs (stuid) that correspond to these activity IDs."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT stuid FROM Participates_in WHERE actid IN (SELECT actid FROM Activity WHERE activity_name IN ('Canoeing', 'Kayaking'));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of activities in which a specific faculty member participates. The placeholders in the WHERE clause represent the first and last names of the faculty member.\",\n        \"virtual_table\": \"SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  [PLACEHOLDER-TYPE:STRING] AND T1.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to find faculty members who are involved in the same activity twice, ensuring that the results are distinct. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: car_names, model_list, and cars_data are needed to find car models and their horsepower.", "Join the car_names table with the model_list table to get the model names associated with each car maker.", "Join the resulting table with the cars_data table to access the horsepower of each car model.", "Order the results by horsepower in ascending order to find the model with the minimum horsepower.", "Limit the results to 1 to get only the model with the minimum horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model FROM car_names AS T1 JOIN model_list AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T1.MakeId = T3.Id ORDER BY T3.Horsepower ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.97", "db_id": "car_1", "question": "Find the model of the car whose weight is below the average weight.", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data are needed to find car models and their weights.", "Join the model_list table with the car_names table to get the model names associated with each car maker.", "Join the resulting table with the cars_data table to access the weight of each car model.", "Use a subquery to calculate the average weight of all cars in the cars_data table.", "Filter the results to include only those car models whose weight is below the average weight calculated in the subquery."], "gold_sql": "SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA)", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT DISTINCT T2.Model \nFROM model_list AS T1 \nJOIN car_names AS T2 ON T1.Model = T2.Model \nJOIN cars_data AS T3 ON T2.MakeId = T3.Id \nWHERE T3.Weight < (SELECT AVG(Weight) FROM cars_data);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: car_names, model_list, and cars_data are needed to find the accelerate of the specific car make and model.", "Join the car_names table with the model_list table on the Model column to link car makes with their respective models.", "Join the resulting table with the cars_data table on the MakeId to access the accelerate data for the specific car model.", "Filter the results by specifying the car make as 'amc' and the model as 'hornet sportabout' to get the desired accelerate value."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT C.Accelerate FROM car_names AS CN JOIN model_list AS ML ON CN.Model = ML.Model JOIN cars_data AS C ON CN.MakeId = C.Id WHERE CN.Make = 'amc' AND ML.Model = 'hornet sportabout';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n        \"virtual_table\": \"SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;\"\n    }\n}\n"}
{"sample_id": "dev.112", "db_id": "car_1", "question": "How much does the car accelerate that makes amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: We need to find the acceleration of a specific car model, which involves the 'cars_data', 'car_names', 'model_list', 'car_makers', and 'countries' tables.", "Determine the relationships: 'car_names' links to 'model_list' through the 'Model' column, 'model_list' links to 'car_makers' through the 'Maker' column, and 'car_makers' links to 'countries' through the 'Country' column.", "Filter for the specific car model: We need to filter for the car make 'amc' and the model 'hornet sportabout'.", "Select the 'Accelerate' column from the 'cars_data' table, which contains the acceleration data we are interested in."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT cars_data.Accelerate \nFROM car_names \nJOIN model_list ON car_names.Model = model_list.Model \nJOIN car_makers ON model_list.Maker = car_makers.Id \nJOIN countries ON car_makers.Country = countries.CountryId \nWHERE car_names.Make = 'amc' AND model_list.Model = 'hornet sportabout';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the relevant tables: model_list, car_makers, and countries are needed to find car makers in France.", "Join the model_list table with the car_makers table on the Maker ID.", "Join the car_makers table with the countries table on the Country ID.", "Filter the results to only include car makers from France using a WHERE clause.", "Count the number of car makers that meet the criteria."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT count(*) FROM model_list AS T1 JOIN car_makers AS T2 ON T1.Maker = T2.Id JOIN countries AS T3 ON T2.Country = T3.CountryId WHERE T3.CountryName = 'France';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n        \"virtual_table\": \"SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.121", "db_id": "car_1", "question": "What are all the makers and models?", "rationale": ["The question asks for all the makers and models of cars.", "To get the makers and models, we need to join the 'model_list' table with the 'car_names' table to link models with their respective makes.", "Next, we need to select distinct combinations of makers and models to avoid duplicates.", "The final SQL query will select the distinct maker names from the 'car_names' table and the model names from the 'model_list' table."], "gold_sql": "SELECT Maker ,  Model FROM MODEL_LIST;", "source_tables": ["model_list"], "pred_sql": "SELECT DISTINCT T3.Make, T1.Model FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n        \"virtual_table\": \"SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;\"\n    }\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the continent of interest, which is Europe.", "Join the 'countries' table with the 'car_makers' table to associate countries with their car manufacturers.", "Filter the countries to only include those that belong to Europe by using a subquery to get the ContId for Europe.", "Group the results by country name to count the number of car manufacturers per country.", "Use the HAVING clause to filter the grouped results to only include countries with at least 3 car manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT T3.CountryName FROM COUNTRIES AS T3 JOIN CAR_MAKERS AS T2 ON T3.CountryId = T2.Country WHERE T3.Continent = (SELECT ContId FROM CONTINENTS WHERE Continent = 'Europe') GROUP BY T3.CountryName HAVING COUNT(T2.Id) >= 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n        \"virtual_table\": \"SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.130", "db_id": "car_1", "question": "What are the names of all European countries with at least 3 manufacturers?", "rationale": ["Identify the relevant tables: countries, car_makers, and continents.", "We need to find countries in Europe, so we will filter by the continent name 'Europe'.", "We will count the number of car manufacturers for each country.", "We will use a subquery to count the number of manufacturers per country and filter those with at least 3 manufacturers using HAVING clause.", "Join the countries table with the car_makers table to get the country names and their respective counts of manufacturers.", "Finally, select the country names from the countries table where the continent is Europe and the count of manufacturers is at least 3."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT T3.CountryName FROM COUNTRIES AS T3 JOIN CAR_MAKERS AS T2 ON T3.CountryId = T2.Country JOIN (SELECT T3.Country, COUNT(*) AS MakerCount FROM CAR_MAKERS AS T2 JOIN COUNTRIES AS T3 ON T2.Country = T3.CountryId GROUP BY T3.Country HAVING COUNT(*) >= 3) AS T1 ON T3.CountryId = T1.Country WHERE T3.Continent = (SELECT ContId FROM CONTINENTS WHERE Continent = 'Europe');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n        \"virtual_table\": \"SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the tables needed: We need data from 'cars_data' for horsepower and cylinders, 'car_names' for the make of the car, and 'model_list' to link the models with their respective makes.", "We need to filter the results to only include cars with 3 cylinders, which will be done in the WHERE clause.", "To get the maximum horsepower, we will use the MAX() function on the horsepower column from the 'cars_data' table.", "We will select the make of the car from the 'car_names' table along with the maximum horsepower.", "The final SQL query will join the necessary tables and apply the required filters."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(CD.Horsepower) AS MaxHorsepower, CN.Make AS CarMake \nFROM cars_data AS CD \nJOIN car_names AS CN ON CD.Id = CN.MakeId \nJOIN model_list AS ML ON CN.Model = ML.Model \nWHERE CD.Cylinders = 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.141", "db_id": "car_1", "question": "Which model has the most version(make) of cars?", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data are needed to find car models and their makes.", "Join the model_list table with the car_names table to associate each model with its respective make.", "Join the resulting table with the cars_data table to ensure we are considering all versions of each model.", "Use COUNT to count the number of makes for each model.", "Group the results by model to aggregate the counts.", "Order the results by the count of makes in descending order to find the model with the most versions.", "Limit the results to 1 to get only the top model."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "pred_sql": "SELECT T1.Model, COUNT(T2.Make) AS VersionCount FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id GROUP BY T1.Model ORDER BY VersionCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n        \"virtual_table\": \"SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;\"\n    }\n}\n"}
{"sample_id": "dev.142", "db_id": "car_1", "question": "What model has the most different versions?", "rationale": ["We need to find the car model that has the most different versions.", "To do this, we will join the 'model_list' table with the 'car_names' table to get the models and their corresponding makes.", "Next, we will join with the 'cars_data' table to count the number of entries (versions) for each model.", "We will group the results by the model name to get the count of versions for each model.", "Finally, we will order the results in descending order based on the count of versions and limit the output to 1 to get the model with the most versions."], "gold_sql": "SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["car_names"], "pred_sql": "SELECT T1.Model, COUNT(*) AS VersionCount FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id GROUP BY T1.Model ORDER BY VersionCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["Identify the table that contains car makers and their identifiers, which is the 'car_makers' table.", "We need to find makers that have more than 3 models, so we will use the 'model_list' table to count the number of models associated with each maker.", "We will group the results from the 'model_list' table by the 'Maker' column and use the HAVING clause to filter those groups to only include makers with a count greater than 3.", "The subquery will return the list of makers that meet the criteria, and we will use this list to filter the main query on the 'car_makers' table to get the names and ids of those makers."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT Maker, Id FROM car_makers WHERE Id IN (SELECT Maker FROM model_list GROUP BY Maker HAVING COUNT(ModelId) > 3);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n        \"virtual_table\": \"SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;\"\n    }\n}\n"}
{"sample_id": "dev.161", "db_id": "car_1", "question": "How many countries has more than 2 car makers ?", "rationale": ["We need to count the number of countries that have more than 2 car makers.", "To do this, we will join the 'car_makers' table with the 'countries' table on the country identifier.", "We will group the results by the country identifier to count the number of car makers per country.", "Using the HAVING clause, we will filter the groups to only include those with a count greater than 2.", "Finally, we will count the distinct countries that meet this condition."], "gold_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT T2.CountryId) FROM car_makers AS T1 JOIN countries AS T2 ON T1.Country = T2.CountryId GROUP BY T2.CountryId HAVING COUNT(T1.Id) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n        \"virtual_table\": \"SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data are needed to find the car models and their horsepower.", "Join the model_list table with the car_names table to get the model names associated with each car maker.", "Join the resulting table with the cars_data table to access the horsepower and filter by the number of cylinders (4 in this case).", "Use the ORDER BY clause to sort the results by horsepower in descending order to get the model with the largest horsepower.", "Limit the results to 1 to get only the top result."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT T1.Model, T3.Horsepower FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id WHERE T3.Cylinders = 4 ORDER BY T3.Horsepower DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.171", "db_id": "car_1", "question": "Which models are lighter than 3500 but not built by the 'Ford Motor Company'?", "rationale": ["Identify the relevant tables: model_list, car_names, cars_data, car_makers, and countries.", "We need to select distinct car models that meet the weight condition and are not made by 'Ford Motor Company'.", "Join model_list with car_names to get the make of each model.", "Join the result with cars_data to filter based on the weight of the cars.", "Join with car_makers to filter out the models made by 'Ford Motor Company'.", "Finally, apply the weight condition (< 3500) and the exclusion condition (not made by 'Ford Motor Company') in the WHERE clause."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';", "source_tables": ["car_makers", "model_list", "car_names", "cars_data"], "pred_sql": "SELECT DISTINCT T1.Model \nFROM model_list AS T1 \nJOIN car_names AS T2 ON T1.Model = T2.Model \nJOIN cars_data AS T3 ON T2.MakeId = T3.Id \nJOIN car_makers AS T4 ON T1.Maker = T4.Id \nJOIN countries AS T5 ON T4.Country = T5.CountryId \nWHERE T3.Weight < 3500 \nAND T4.FullName != 'Ford Motor Company';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car models from the 'model_list' table that are associated with car makers from a specific country. The placeholders in the WHERE clause represent the name of the country being queried.\",\n        \"virtual_table\": \"SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.175", "db_id": "car_1", "question": "Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .", "rationale": ["Identify the relevant tables: car_makers and model_list.", "Join the car_makers table with the model_list table on the Maker ID.", "Group the results by car maker ID and name to aggregate the number of models each maker produces.", "Use the HAVING clause to filter for car makers that produce at least 2 models."], "gold_sql": "select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT T1.Id, T1.Maker FROM car_makers AS T1 JOIN model_list AS T2 ON T1.Id = T2.Maker GROUP BY T1.Id, T1.Maker HAVING COUNT(T2.ModelId) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n        \"virtual_table\": \"SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["We need to find car makers that produce at least 2 models and make more than 3 cars.", "To do this, we will join the 'car_makers' table with the 'model_list' table to get the models associated with each maker.", "Next, we will join the 'car_names' table to link the models to their respective makes.", "Finally, we will join the 'cars_data' table to count the number of cars produced by each maker.", "We will group the results by the car maker's ID and name, and use the HAVING clause to filter for makers that have at least 2 distinct models and more than 3 cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT T1.Id, T1.Maker FROM car_makers AS T1 JOIN model_list AS T2 ON T1.Id = T2.Maker JOIN car_names AS T3 ON T2.Model = T3.Model JOIN cars_data AS T4 ON T3.MakeId = T4.Id GROUP BY T1.Id, T1.Maker HAVING COUNT(DISTINCT T2.Model) >= 2 AND COUNT(T4.Id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of car makers associated with each continent by joining the 'continents', 'countries', and 'car_makers' tables. The placeholder in the SELECT statement represents the continent's name, and the count function aggregates the number of car makers per continent.\",\n        \"virtual_table\": \"SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models with their respective makes, and then further joins with the 'cars_data' table to filter the results based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.526", "db_id": "student_transcripts_tracking", "question": "What are the names and ids of every course with less than 2 sections?", "rationale": ["Identify the relevant tables: Courses and Sections.", "We need to find courses that have less than 2 sections, so we will join the Courses table with the Sections table on the course_id.", "Use a LEFT JOIN to ensure we include courses that may not have any sections.", "Group the results by course_id and course_name to aggregate the section counts for each course.", "Use the HAVING clause to filter the grouped results to only include courses with a count of sections less than 2."], "gold_sql": "SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2", "source_tables": ["courses", "sections"], "pred_sql": "SELECT c.course_id, c.course_name\nFROM Courses c\nLEFT JOIN Sections s ON c.course_id = s.course_id\nGROUP BY c.course_id, c.course_name\nHAVING COUNT(s.section_id) < 2;", "hint": "\n"}
{"sample_id": "dev.534", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs are needed to get student names and their degree program enrollments.", "Join the Students table with Student_Enrolment to link students with their enrollments.", "Join the Student_Enrolment table with Degree_Programs to access degree program information.", "Use a subquery to find semesters where students are enrolled in exactly 2 distinct degree programs.", "Select the student_id, first_name, middle_name, and last_name from the joined tables, filtering by the semesters identified in the subquery."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT S.student_id, S.first_name, S.middle_name, S.last_name \nFROM Students AS S \nJOIN Student_Enrolment AS SE ON S.student_id = SE.student_id \nJOIN Degree_Programs AS DP ON SE.degree_program_id = DP.degree_program_id \nWHERE SE.semester_id IN (\n    SELECT semester_id \n    FROM Student_Enrolment \n    GROUP BY semester_id, student_id \n    HAVING COUNT(DISTINCT degree_program_id) = 2\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.535", "db_id": "student_transcripts_tracking", "question": "Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.", "rationale": ["Identify the tables needed: Students, Student_Enrolment, and Degree_Programs.", "Determine the columns to select: first_name, middle_name, last_name from Students.", "Establish the relationships between the tables using JOINs: Students to Student_Enrolment on student_id, and Student_Enrolment to Degree_Programs on degree_program_id.", "Filter the results to only include students enrolled in a Bachelor degree program using a WHERE clause on the degree_summary_name column."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT DISTINCT T1.first_name, T1.middle_name, T1.last_name \nFROM Students AS T1 \nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id \nJOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id \nWHERE T3.degree_summary_name = 'Bachelor'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["Identify the relevant tables: Degree_Programs and Student_Enrolment are needed to find the degree programs and their enrolled students.", "Join the Degree_Programs table with the Student_Enrolment table on the degree_program_id to associate each program with its enrolled students.", "Use COUNT() to count the number of students enrolled in each degree program.", "Group the results by degree_program_id and degree_summary_name to aggregate the student counts for each program.", "Order the results by the student count in descending order to find the program with the most students.", "Limit the results to 1 to get only the program with the highest enrollment."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_program_id, dp.degree_summary_name, COUNT(se.student_enrolment_id) AS student_count\nFROM Degree_Programs AS dp\nJOIN Student_Enrolment AS se ON dp.degree_program_id = se.degree_program_id\nGROUP BY dp.degree_program_id, dp.degree_summary_name\nORDER BY student_count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment are needed to find student details and their enrollment counts.", "Join the Students table with the Student_Enrolment table on student_id to link students with their enrollments.", "Use COUNT() to count the number of enrollments for each student.", "Group the results by student_id to aggregate the enrollment counts for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to 1 to get only the student with the highest enrollment count."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT S.student_id, S.first_name, S.middle_name, S.last_name, COUNT(SE.student_enrolment_id) AS number_of_enrollments\nFROM Students AS S\nJOIN Student_Enrolment AS SE ON S.student_id = SE.student_id\nGROUP BY S.student_id\nORDER BY number_of_enrollments DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["Identify the relevant tables: Courses and Student_Enrolment_Courses are needed to find course names and their enrollments.", "Join the Courses table with the Student_Enrolment_Courses table on the course_id to link courses with their enrollments.", "Group the results by course_id to aggregate the number of enrollments for each course.", "Count the number of student_course_id in the Student_Enrolment_Courses table to determine the number of enrollments for each course.", "Order the results in descending order based on the count of enrollments to get the course with the most enrollments at the top.", "Limit the results to 1 to get only the course with the highest number of enrollments."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT C.course_name\nFROM Courses AS C\nJOIN Student_Enrolment_Courses AS SEC ON C.course_id = SEC.course_id\nGROUP BY C.course_id\nORDER BY COUNT(SEC.student_course_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.548", "db_id": "student_transcripts_tracking", "question": "What is the name of the course with the most students enrolled?", "rationale": ["Identify the relevant tables: Courses, Student_Enrolment_Courses, and Student_Enrolment are needed to find the course with the most students enrolled.", "Join the Courses table with the Student_Enrolment_Courses table on course_id to link courses to their enrollments.", "Then, join the Student_Enrolment table to link the enrollments to students.", "Group the results by course_id to count the number of students enrolled in each course.", "Order the results in descending order based on the count of students enrolled to find the course with the most students.", "Limit the results to 1 to get only the top course."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT C.course_name\nFROM Courses AS C\nJOIN Student_Enrolment_Courses AS SEC ON C.course_id = SEC.course_id\nJOIN Student_Enrolment AS SE ON SEC.student_enrolment_id = SE.student_enrolment_id\nGROUP BY C.course_id\nORDER BY COUNT(SEC.student_course_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant tables: Students and Addresses for student information and their current address.", "Join the Students table with the Addresses table on the current_address_id to filter students based on their current state.", "Filter the results to include only those students who live in 'North Carolina'.", "Use the EXCEPT clause to exclude students who are enrolled in any degree programs by joining the Students table with the Student_Enrolment table.", "Select the last names of the students who meet the criteria."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT T1.last_name \nFROM Students AS T1 \nJOIN Addresses AS T2 ON T1.current_address_id = T2.address_id \nWHERE T2.state_province_county = 'North Carolina' \nEXCEPT \nSELECT DISTINCT T3.last_name \nFROM Students AS T3 \nJOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table: The question pertains to student information, specifically the mobile phone number, which is found in the Students table.", "Determine the necessary columns: We need the 'cell_mobile_number' column from the Students table.", "Filter criteria: The question specifies the student's name as 'Timmothy Ward', so we will filter based on the first name and last name columns.", "Construct the SQL query: Using the SELECT statement to retrieve the mobile number from the Students table where the first name is 'Timmothy' and the last name is 'Ward'."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["Identify the relevant tables: Students and Addresses.", "We need to join the Students table with the Addresses table based on the current address of the students.", "Group the results by address to count the number of students at each address.", "Order the results by the count of students in descending order to find the address with the most students.", "Limit the results to 1 to get only the address with the highest count."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT A.address_id, A.line_1, A.line_2, A.line_3\nFROM Addresses AS A\nJOIN Students AS S ON A.address_id = S.current_address_id\nGROUP BY A.address_id, A.line_1, A.line_2, A.line_3\nORDER BY COUNT(S.student_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id\"\n    }\n}\n"}
{"sample_id": "dev.578", "db_id": "student_transcripts_tracking", "question": "What are the different addresses that have students living there?", "rationale": ["We need to find the different addresses where students are currently living.", "The relevant tables are 'Students' and 'Addresses'.", "We will join the 'Students' table with the 'Addresses' table on the 'current_address_id' and 'address_id' fields respectively.", "We want to select distinct addresses to avoid duplicates, so we will use SELECT DISTINCT.", "The fields we want to retrieve from the 'Addresses' table include line_1, line_2, line_3, city, zip_postcode, state_province_county, and country."], "gold_sql": "SELECT count(DISTINCT current_address_id) FROM Students", "source_tables": ["students"], "pred_sql": "SELECT DISTINCT T2.line_1, T2.line_2, T2.line_3, T2.city, T2.zip_postcode, T2.state_province_county, T2.country \nFROM Students AS T1 \nJOIN Addresses AS T2 ON T1.current_address_id = T2.address_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholder in the WHERE clause represents the name of the degree program.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve information about a section, we need to select all columns from the Sections table.", "We will use a WHERE clause to filter the results to only include the section where the section_name is 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT * FROM Sections WHERE section_name = 'h';", "hint": "\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the relevant table: The question pertains to countries and their government forms, so we will use the 'country' table.", "Determine the condition: We need to count the number of countries where the government form includes the word 'Republic'.", "Construct the SQL query: We will use the COUNT function to count the rows that meet the condition, and we will filter the results using a WHERE clause that checks if the GovernmentForm contains 'Republic'."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(*) FROM country WHERE GovernmentForm LIKE '%Republic%';", "hint": "\n"}
{"sample_id": "dev.723", "db_id": "world_1", "question": "How many people live in Asia, and what is the largest GNP among them?", "rationale": ["Identify the relevant tables: 'country' for GNP and continent, and 'city' for population.", "We need to sum the population of cities in Asia, so we will use the SUM function on the 'Population' column from the 'city' table.", "We also need to find the maximum GNP among countries in Asia, so we will use the MAX function on the 'GNP' column from the 'country' table.", "To relate cities to their respective countries, we will join the 'city' table with the 'country' table on the 'CountryCode' field.", "We will filter the results to include only those countries that are in the continent of Asia using a WHERE clause."], "gold_sql": "SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  'Asia'", "source_tables": ["country"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation, MAX(co.GNP) AS LargestGNP\nFROM country AS co\nJOIN city AS ci ON co.Code = ci.CountryCode\nWHERE co.Continent = 'Asia';", "hint": "\n"}
{"sample_id": "dev.724", "db_id": "world_1", "question": "What is the average life expectancy in African countries that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains the information about countries, including life expectancy and government form.", "Determine the columns needed: We need 'LifeExpectancy' for the average calculation and 'GovernmentForm' to filter for republics.", "Filter for African countries: Use the 'Continent' column to specify 'Africa'.", "Filter for republics: Use the 'GovernmentForm' column to include only those entries that contain 'Republic'.", "Calculate the average life expectancy: Use the AVG() function to compute the average of the 'LifeExpectancy' column for the filtered results."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT AVG(LifeExpectancy) AS AverageLifeExpectancy\nFROM country\nWHERE Continent = 'Africa' AND GovernmentForm LIKE '%Republic%';", "hint": "\n"}
{"sample_id": "dev.725", "db_id": "world_1", "question": "Give the average life expectancy for countries in Africa which are republics?", "rationale": ["Identify the relevant table: The 'country' table contains the information about countries, including life expectancy and government form.", "Determine the columns needed: We need the 'LifeExpectancy' column to calculate the average and the 'GovernmentForm' column to filter for republics.", "Set the conditions for the query: We want countries that are in the continent of Africa and have a government form that includes 'Republic'.", "Use the AVG() function to calculate the average life expectancy for the filtered results."], "gold_sql": "SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  'Africa' AND GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT AVG(LifeExpectancy) AS AverageLifeExpectancy \nFROM country \nWHERE Continent = 'Africa' \nAND GovernmentForm LIKE '%Republic%';", "hint": "\n"}
{"sample_id": "dev.731", "db_id": "world_1", "question": "Give the mean GNP and total population of nations which are considered US territory.", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their GNP and population.", "Determine the criteria for US territories: We will look for countries that are associated with the United States, which may include names that contain 'United States' or 'US'.", "Construct the SQL query: We will use the AVG function to calculate the mean GNP and the SUM function to calculate the total population of the selected countries.", "Use a WHERE clause to filter the countries based on the criteria identified in the previous step."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT AVG(GNP) AS Mean_GNP, SUM(Population) AS Total_Population \nFROM country \nWHERE Name LIKE '%United States%' OR Name LIKE '%US%';", "hint": "\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and continent.", "Determine the specific continent: We are interested in countries located in Africa.", "Select distinct government forms: We want to know how many different forms of government exist, so we will use the DISTINCT keyword to avoid duplicates.", "Construct the SQL query: Combine the selected columns and conditions into a complete SQL statement."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Continent = 'Africa'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.754", "db_id": "world_1", "question": "What are the countries where either English or Dutch is the official language ?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find countries with specific official languages.", "Determine the criteria: We are interested in countries where either English or Dutch is an official language.", "Use the 'countrylanguage' table to filter for official languages: We will check the 'IsOfficial' column for 'T' (true) and the 'Language' column for 'English' or 'Dutch'.", "Join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' columns to get the country names that meet the criteria.", "Select distinct country names to avoid duplicates in the result."], "gold_sql": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'english' and isofficial  =  't' union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'dutch' and isofficial  =  't'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.IsOfficial = 'T' AND (T2.Language = 'English' OR T2.Language = 'Dutch')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find countries with specific official languages.", "Determine the criteria: We are interested in countries where either English or Dutch is an official language.", "Use the 'countrylanguage' table to filter for official languages: We will check the 'IsOfficial' column for 'T' (true) and the 'Language' column for 'English' or 'Dutch'.", "Join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' columns to get the country names that meet the criteria.", "Select distinct country names to avoid duplicates in the result."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.IsOfficial = 'T' AND (T2.Language = 'English' OR T2.Language = 'Dutch')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.758", "db_id": "world_1", "question": "Which languages are spoken by only one country in republic governments?", "rationale": ["Identify the relevant tables: We need to look at the 'countrylanguage' table for languages and the 'country' table for government forms.", "Filter for official languages: We only want languages that are marked as official, so we filter on 'IsOfficial' being 'T'.", "Filter for republic governments: We need to ensure that the government form includes 'Republic', so we filter on 'GovernmentForm' using a LIKE clause.", "Group by language: We want to group the results by language to count how many countries speak each language.", "Count distinct countries: We use HAVING to ensure that we only get languages spoken by exactly one country, which is done by counting distinct country codes."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT cl.Language FROM countrylanguage AS cl JOIN country AS c ON cl.CountryCode = c.Code WHERE cl.IsOfficial = 'T' AND c.GovernmentForm LIKE '%Republic%' GROUP BY cl.Language HAVING COUNT(DISTINCT c.Code) = 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.759", "db_id": "world_1", "question": "What languages are only used by a single country with a republic government?", "rationale": ["Identify the relevant tables: We need to look at the 'countrylanguage' table for languages and the 'country' table for government forms.", "Join the 'countrylanguage' table with the 'country' table on the CountryCode to access both language and government form information.", "Filter the results to include only official languages by checking 'IsOfficial' = 'T'.", "Group the results by language to count how many distinct countries speak each language.", "Use the HAVING clause to filter for languages that are spoken in exactly one country (COUNT(DISTINCT c.Code) = 1).", "Additionally, filter for countries that have a government form that includes 'Republic' in it."], "gold_sql": "SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  'Republic' GROUP BY T2.Language HAVING COUNT(*)  =  1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl.Language FROM countrylanguage AS cl JOIN country AS c ON cl.CountryCode = c.Code WHERE cl.IsOfficial = 'T' GROUP BY cl.Language HAVING COUNT(DISTINCT c.Code) = 1 AND c.GovernmentForm LIKE '%Republic%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.760", "db_id": "world_1", "question": "Find the city with the largest population that uses English.", "rationale": ["Identify the requirement: We need to find the city with the largest population that uses English.", "Understand the language criteria: We need to filter out countries where English is an official language.", "Use the countrylanguage table to find countries where English is an official language by checking IsOfficial = 'T'.", "Select the country codes from the country table that do not have English as an official language.", "Join the city table with the country table to filter cities based on the country codes obtained in the previous step.", "Order the results by population in descending order to get the city with the largest population.", "Limit the results to 1 to get only the top city."], "gold_sql": "SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  'English' ORDER BY T1.Population DESC LIMIT 1", "source_tables": ["city", "countrylanguage"], "pred_sql": "SELECT Name FROM city WHERE CountryCode IN (SELECT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE IsOfficial = 'T' AND Language = 'English')) ORDER BY Population DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the countries that do not use English as an official language.", "To find these countries, we need to look at the 'countrylanguage' table where 'IsOfficial' is 'T' and 'Language' is 'English'.", "We will create a subquery to get the 'CountryCode' of countries that have English as an official language.", "Next, we will use this subquery to filter out these countries from the 'country' table.", "Finally, we will sum the 'Population' of the remaining countries to get the total number of people living in nations that do not use English."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(Population) FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE IsOfficial = 'T' AND Language = 'English')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.774", "db_id": "world_1", "question": "What are the African countries that have a  population less than any country in Asia?", "rationale": ["Identify the countries in Africa by filtering the 'country' table for the continent 'Africa'.", "Determine the maximum population of countries in Asia by using a subquery that selects the maximum population from the 'country' table where the continent is 'Asia'.", "Combine these two criteria to find African countries whose population is less than the maximum population found in the Asian countries."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Africa'  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  'Asia')", "source_tables": ["country"], "pred_sql": "SELECT Name FROM country WHERE Continent = 'Africa' AND Population < (SELECT MAX(Population) FROM country WHERE Continent = 'Asia')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.777", "db_id": "world_1", "question": "What are the Asian countries which have a population larger than that of any country in Africa?", "rationale": ["Identify the countries in Asia by filtering the 'country' table for the continent 'Asia'.", "To find countries with a population larger than any country in Africa, we need to compare the populations.", "Use a subquery to find the maximum population of countries in Africa by filtering the 'country' table for the continent 'Africa'.", "Combine the results to select distinct country names from Asia where their population is greater than the maximum population found in Africa."], "gold_sql": "SELECT Name FROM country WHERE Continent  =  'Asia'  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  'Africa')", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT T1.Name FROM country AS T1 WHERE T1.Continent = 'Asia' AND T1.Population > (SELECT MAX(T2.Population) FROM country AS T2 WHERE T2.Continent = 'Africa')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.778", "db_id": "world_1", "question": "What are the country codes for countries that do not speak English?", "rationale": ["Identify the requirement: We need country codes for countries that do not speak English.", "Understand the schema: The 'country' table contains country codes, and the 'countrylanguage' table indicates which languages are spoken in which countries.", "We need to filter out countries where English is an official language. This is indicated by the 'IsOfficial' column in the 'countrylanguage' table.", "Construct a subquery to find all country codes where English is an official language: SELECT CountryCode FROM countrylanguage WHERE IsOfficial = 'T' AND Language = 'English'.", "Use the NOT IN clause to exclude these country codes from the main query that selects all country codes from the 'country' table.", "The final SQL query selects distinct country codes from the 'country' table that are not in the list of country codes where English is an official language."], "gold_sql": "SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["countrylanguage"], "pred_sql": "SELECT DISTINCT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE IsOfficial = 'T' AND Language = 'English')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.786", "db_id": "world_1", "question": "Which unique cities are in Asian countries where Chinese is the official language ?", "rationale": ["Identify the continent of interest, which is Asia.", "We need to find cities in countries that have Chinese as an official language.", "Join the 'country' table with the 'city' table to get city names along with their corresponding country codes.", "Filter the results to include only those countries that are in Asia.", "Use a subquery to find countries where Chinese is an official language, ensuring we only include those countries in our main query."], "gold_sql": "select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  't' and t2.language  =  'chinese' and t1.continent  =  'asia'", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode = T1.Code WHERE T1.Continent = 'Asia' AND T1.Code IN (SELECT T3.Code FROM countrylanguage AS T4 JOIN country AS T3 ON T4.CountryCode = T3.Code WHERE T4.IsOfficial = 'T' AND T4.Language = 'Chinese')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the columns needed: Name, IndepYear, and SurfaceArea from the country table.", "Determine the condition to find the country with the lowest population: this requires a subquery to find the minimum population.", "Construct the subquery to select the minimum population from the country table: SELECT MIN(Population) FROM country.", "Use the result of the subquery in the main query to filter the country with that minimum population.", "Combine the selected columns and the condition into a complete SQL query."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);", "hint": "\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["Identify the relevant tables: We need to use the 'country' and 'countrylanguage' tables to get the names of countries and the languages they speak.", "Join the 'country' table with the 'countrylanguage' table on the 'Code' and 'CountryCode' columns respectively to associate each country with its languages.", "Group the results by country code to count the number of languages spoken in each country.", "Use the COUNT function to count the number of languages for each country.", "Filter the results using the HAVING clause to include only those countries that speak more than 2 languages."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name, COUNT(cl.Language) AS LanguageCount \nFROM country c \nJOIN countrylanguage cl ON c.Code = cl.CountryCode \nGROUP BY c.Code \nHAVING COUNT(cl.Language) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the relevant table: The question pertains to government forms and population, which are found in the 'country' table.", "Select the columns needed: We need 'GovernmentForm' and the total population, so we will select 'GovernmentForm' and use SUM() on 'Population'.", "Apply the condition: We need to filter for countries with an average life expectancy greater than 72, so we will add a WHERE clause for 'LifeExpectancy > 72'.", "Group the results: Since we want the total population for each government form, we will use GROUP BY on 'GovernmentForm'.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation\nFROM country\nWHERE LifeExpectancy > 72\nGROUP BY GovernmentForm;", "hint": "\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the relevant table: The 'city' table contains the population data we need.", "Determine the condition: We need to find cities with a population between 160000 and 900000.", "Construct the SQL query: Use the SELECT statement to retrieve the 'Name' of the cities from the 'city' table where the 'Population' falls within the specified range."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT Name FROM city WHERE Population BETWEEN '160000' AND '900000';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.820", "db_id": "world_1", "question": "What are the codes of countries where Spanish is spoken by the largest percentage of people?", "rationale": ["Identify the relevant language, which is Spanish.", "Use the countrylanguage table to find the countries where Spanish is spoken.", "Order the results by the percentage of speakers in descending order to find the largest percentage.", "Select the country codes from the country table based on the results from the countrylanguage table."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "pred_sql": "SELECT Code FROM country WHERE Code IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'Spanish' ORDER BY Percentage DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.821", "db_id": "world_1", "question": "Return the codes of countries for which Spanish is the predominantly spoken language.", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find the country codes based on the language spoken.", "Determine the criteria: We are interested in countries where Spanish is predominantly spoken, which can be interpreted as having a high percentage of speakers.", "Construct the SQL query: We will join the 'country' table with the 'countrylanguage' table on the country code, filter for Spanish as the language, and check if the percentage of speakers is above a certain threshold (e.g., 50%).", "Select the distinct country codes that meet these criteria."], "gold_sql": "SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  'Spanish' GROUP BY CountryCode", "source_tables": ["countrylanguage"], "pred_sql": "SELECT DISTINCT T1.Code FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'Spanish' AND T2.Percentage > 50;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of cities from the 'city' table that are located in a specific continent, while excluding those cities from countries where a specified language is an official language. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in a specific continent, as defined in the 'country' table. Additionally, it filters out cities from countries where a specified language is an official language, ensuring that only cities from countries without that official language are included. The placeholders in the WHERE clause represent the continent and the language criteria.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  [PLACEHOLDER-TYPE:STRING] AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  [PLACEHOLDER-TYPE:STRING] AND T4.Language  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.920", "db_id": "dog_kennels", "question": "What is the average age of the dogs who have gone through any treatments?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need to find the average age of dogs that have undergone treatments, so we will join the Dogs table with the Treatments table on the dog_id.", "Use the AVG() function to calculate the average age of the dogs from the Dogs table after the join."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT AVG(D.age) AS average_age FROM Dogs AS D JOIN Treatments AS T ON D.dog_id = T.dog_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.936", "db_id": "dog_kennels", "question": "Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.", "rationale": ["Identify the relevant tables: Owners, Dogs, and Treatments.", "Join the Owners table with the Dogs table on owner_id to link owners to their dogs.", "Join the resulting table with the Treatments table on dog_id to link dogs to their treatments.", "Group the results by owner_id to aggregate the number of treatments per owner.", "Order the results by the count of treatments in descending order to find the owner with the most treatments.", "Limit the results to 1 to get only the top owner who has paid for the most treatments."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT T1.owner_id, T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id JOIN Treatments AS T3 ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    }\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to join these tables on the professional_id to link professionals with the treatments they have administered.", "We want to group the results by professional_id to count the number of distinct treatment types each professional has done.", "Use the HAVING clause to filter for professionals who have administered at least two different treatment types.", "Select the professional_id and cell_number from the filtered results."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT professional_id, cell_number \nFROM Professionals AS P \nJOIN Treatments AS T ON P.professional_id = T.professional_id \nGROUP BY P.professional_id \nHAVING COUNT(DISTINCT T.treatment_type_code) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    }\n}\n"}
{"sample_id": "dev.944", "db_id": "dog_kennels", "question": "What are the first name and last name of the professionals who have done treatment with cost below average?", "rationale": ["Identify the tables needed: Professionals and Treatments.", "We need to select the first name and last name of professionals, so we will select 'first_name' and 'last_name' from the Professionals table.", "We need to join the Treatments table to get the treatment costs associated with each professional.", "The condition requires us to filter professionals based on treatment costs that are below the average cost of treatments.", "To find the average treatment cost, we will use a subquery that calculates the average from the Treatments table.", "Finally, we will use DISTINCT to ensure that we only get unique combinations of first and last names."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT DISTINCT P.first_name, P.last_name \nFROM Professionals AS P \nJOIN Treatments AS T ON P.professional_id = T.professional_id \nWHERE T.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["Identify the tables needed: Owners, Dogs, and Sizes.", "We need to select the first name and last name from the Owners table.", "We also need the size of the dog, which is in the Sizes table.", "Join the Owners table with the Dogs table on owner_id to link owners to their dogs.", "Join the Dogs table with the Sizes table on size_code to get the size description of each dog.", "Select the required fields: owner's first name, last name, and dog's size description."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT O.first_name, O.last_name, S.size_description \nFROM Owners AS O \nJOIN Dogs AS D ON O.owner_id = D.owner_id \nJOIN Sizes AS S ON D.size_code = S.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.951", "db_id": "dog_kennels", "question": "What are each owner's first name, last name, and the size of their dog?", "rationale": ["Identify the required information: owner's first name, last name, and the size of their dog.", "Determine the tables needed: Owners for owner details, Dogs for dog details, and Sizes for size descriptions.", "Establish relationships between the tables: Owners are linked to Dogs via owner_id, and Dogs are linked to Sizes via size_code.", "Construct the SQL query using JOINs to combine the relevant tables and select the desired columns."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT Owners.first_name, Owners.last_name, Sizes.size_description \nFROM Owners \nJOIN Dogs ON Owners.owner_id = Dogs.owner_id \nJOIN Sizes ON Dogs.size_code = Sizes.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "Determine the columns needed: arriving date (date_arrived) and departing date (date_departed) from the Dogs table.", "Establish the relationship between Dogs and Treatments using the dog_id foreign key.", "Construct the SQL query to select the required columns from the Dogs table, joining it with the Treatments table on the dog_id."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT D.date_arrived, D.date_departed \nFROM Dogs AS D \nJOIN Treatments AS T ON D.dog_id = T.dog_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.961", "db_id": "dog_kennels", "question": "Who owns the youngest dog? Give me his or her last name.", "rationale": ["Identify the relevant tables: Owners and Dogs.", "We need to find the youngest dog, so we will order the Dogs table by age in ascending order.", "We will join the Owners table with the Dogs table on the owner_id to get the owner's last name associated with the youngest dog.", "Finally, we will limit the result to 1 to get only the youngest dog owner."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT O.last_name FROM Owners AS O JOIN Dogs AS D ON O.owner_id = D.owner_id ORDER BY D.age ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["Identify the tables needed: Dogs, Breeds, and Sizes.", "We need to find distinct combinations of breed types and size types for dogs.", "Join the Dogs table with the Breeds table on the breed_code to get breed names.", "Join the Dogs table with the Sizes table on the size_code to get size descriptions.", "Select distinct breed names and size descriptions to avoid duplicates."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT B.breed_name, S.size_description FROM Dogs AS D JOIN Breeds AS B ON D.breed_code = B.breed_code JOIN Sizes AS S ON D.size_code = S.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    }\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["Identify the tables involved: Professionals, Treatments, and Treatment_Types.", "Determine the columns needed: first_name from Professionals and treatment_type_description from Treatment_Types.", "Establish relationships between the tables using JOINs: Professionals to Treatments on professional_id, and Treatments to Treatment_Types on treatment_type_code.", "Use DISTINCT to ensure unique combinations of first names and treatment descriptions are returned."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT DISTINCT T1.first_name, T3.treatment_type_description \nFROM Professionals AS T1 \nJOIN Treatments AS T2 ON T1.professional_id = T2.professional_id \nJOIN Treatment_Types AS T3 ON T2.treatment_type_code = T3.treatment_type_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first names of professionals along with the descriptions of the treatment types they have administered. The data is sourced from the 'Professionals', 'Treatments', and 'Treatment_Types' tables, ensuring that only distinct combinations of professional names and treatment descriptions are displayed.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code\"\n    }\n}\n"}
