{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["Identify the relevant table: The 'Student_Course_Registrations' table contains the information about which students are registered for which courses.", "Count the number of students registered for each course: Use the COUNT function to count the 'student_id' for each 'course_id'.", "Group the results by course: Use GROUP BY 'course_id' to aggregate the counts for each course.", "Order the results: Use ORDER BY to sort the results in descending order based on the count of students.", "Limit the results to the top course: Use LIMIT 1 to get only the course with the highest number of registered students."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT course_id, COUNT(student_id) AS number_of_students \nFROM Student_Course_Registrations \nGROUP BY course_id \nORDER BY number_of_students DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["We need to list the IDs of students who have attended courses.", "The relevant table for this information is 'Student_Course_Attendance', which contains records of student attendance.", "To get unique student IDs, we will use the DISTINCT keyword to avoid duplicates.", "The final SQL query will select the 'student_id' from the 'Student_Course_Attendance' table."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["We need to find the ids of all students who have attended at least one course.", "The relevant table for this information is 'Student_Course_Attendance', which records the attendance of students for courses.", "To get unique student ids, we will use the DISTINCT keyword to avoid duplicates.", "The final SQL query will select the distinct student_id from the Student_Course_Attendance table."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates and Student_Course_Attendance.", "We need to find the candidate who most recently accessed a course, which implies looking at the Student_Course_Attendance table.", "The hint provides a virtual table that selects student_id from Student_Course_Attendance ordered by date_of_attendance in descending order, limiting the results to the most recent entry.", "We will use a subquery to get the most recent student_id from Student_Course_Attendance.", "Then, we will select the candidate_id from the Candidates table where the candidate_id matches the student_id from the subquery."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT candidate_id FROM Candidates WHERE candidate_id IN (SELECT student_id FROM Student_Course_Attendance ORDER BY date_of_attendance DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student identifiers from the 'Student_Course_Attendance' table for a specific course. The results are ordered by the date of attendance in descending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_attendance WHERE course_id = [PLACEHOLDER-TYPE:NUMBER] ORDER BY date_of_attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.77", "db_id": "student_assessment", "question": "What is detail of the student who registered the most number of courses?", "rationale": ["Identify the relevant tables: Students and Student_Course_Registrations are needed to get student details and their course registrations.", "Join the Students table with the Student_Course_Registrations table on the student_id to link students with their registered courses.", "Group the results by student_id to ensure we count the number of courses each student has registered for.", "Use the COUNT function to count the number of course registrations for each student.", "Order the results in descending order based on the count of course registrations to find the student with the most registrations.", "Limit the results to 1 to get only the student who registered for the most courses."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT T1.student_details FROM Students AS T1 JOIN Student_Course_Registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["We need to find the number of students registered for each course and the corresponding course names.", "To achieve this, we will join the 'Student_Course_Registrations' table with the 'Courses' table on the course_id.", "We will select the course_id and course_name from the Courses table, and count the number of student_id from the Student_Course_Registrations table to get the number of students registered for each course.", "We will group the results by course_id and course_name to ensure we get the count for each course separately."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT sr.course_id, c.course_name, COUNT(sr.student_id) AS student_count \nFROM Student_Course_Registrations sr \nJOIN Courses c ON sr.course_id = c.course_id \nGROUP BY sr.course_id, c.course_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the number of results returned is limited by a specified placeholder value.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.90", "db_id": "student_assessment", "question": "What are the ids of the students who registered for course 301 most recently?", "rationale": ["Identify the relevant table: We need to look at the 'Student_Course_Registrations' table to find students registered for a specific course.", "Filter by course_id: We will filter the records to only include those where the course_id is '301'.", "Order by registration_date: To find the most recent registration, we will order the results by the registration_date in descending order.", "Limit the results: Since we only want the most recent registration, we will limit the results to 1."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["We need to find distinct cities of addresses associated with students.", "To do this, we will need to join the Addresses table with the People_Addresses table to link addresses to people.", "Next, we will join the resulting table with the Students table to filter for only those people who are students.", "Finally, we will select the distinct cities from the Addresses table."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "pred_sql": "SELECT DISTINCT a.city\nFROM Addresses a\nJOIN People_Addresses pa ON a.address_id = pa.address_id\nJOIN Students s ON pa.person_id = s.student_id;", "hint": "\n"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["We need to find students who registered for courses but did not attend any.", "To do this, we will use a LEFT JOIN between the Students table and the Student_Course_Registrations table to get all students who have registered for courses.", "Next, we will perform another LEFT JOIN with the Student_Course_Attendance table to check if these students attended any courses.", "In the WHERE clause, we will filter for students who have a registration (R.student_id IS NOT NULL) but do not have any attendance records (A.student_id IS NULL).", "Finally, we will select the student_id and student_details from the Students table."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "pred_sql": "SELECT S.student_id, S.student_details \nFROM Students AS S \nLEFT JOIN Student_Course_Registrations AS R ON S.student_id = R.student_id \nLEFT JOIN Student_Course_Attendance AS A ON R.student_id = A.student_id AND R.course_id = A.course_id \nWHERE R.student_id IS NOT NULL AND A.student_id IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of student details from the 'Students' table, specifically focusing on those who have registered for courses. The results are grouped by each student to ensure unique entries, and they are ordered by the number of course registrations in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of student details to retrieve.\",\n        \"virtual_table\": \"SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Determine the specific course of interest, which is 'Statistics'.", "Use a subquery to find the course_id associated with the course name 'Statistics'.", "Select the student_id from 'Student_Course_Registrations' where the course_id matches the one found in the subquery.", "Order the results by the registration_date to get the students in the order they registered for the course."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Determine the specific course of interest, which is 'Statistics'.", "Use a subquery to find the course_id associated with the course name 'Statistics'.", "Filter the 'Student_Course_Registrations' table to only include records where the course_id matches that of 'Statistics'.", "Select the student_id from the filtered results and order them by the registration_date to get the desired order."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique student identifiers from the 'Student_Course_Registrations' table, grouped by each student. The results are ordered by the number of course registrations for each student, and the limit on the number of results returned can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT student_id FROM student_course_registrations GROUP BY student_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["Identify the relevant table: The 'weather' table contains the temperature data and zip codes.", "Determine the required fields: We need the 'zip_code' and the average of 'mean_temperature_f'.", "Filter the data for August: We will filter the records where the date falls within the range of August 1 to August 31.", "Group the results by zip code: To get the average temperature for each zip code, we will use the GROUP BY clause."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "pred_sql": "SELECT zip_code, AVG(mean_temperature_f) AS average_mean_temperature\nFROM weather\nWHERE date BETWEEN '2023-08-01' AND '2023-08-31'\nGROUP BY zip_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["Identify the relevant table for trips, which is the 'trip' table.", "Filter the trips based on the specified zip code (94002).", "Group the results by bike_id to count how many times each bike was used.", "Order the results in descending order to find the bike with the highest count.", "Limit the results to 1 to get the bike that traveled the most often."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT T3.bike_id, COUNT(T3.bike_id) AS trip_count \nFROM trip AS T3 \nWHERE T3.zip_code = '94002' \nGROUP BY T3.bike_id \nORDER BY trip_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.136", "db_id": "bike_1", "question": "What is the id of the bike that traveled the most in 94002?", "rationale": ["Identify the relevant tables: We need to look at the 'trip' table to find bike IDs and their travel durations, and the 'station' table to filter by zip code.", "Join the 'trip' table with the 'station' table on the end station ID to access the zip code information for filtering.", "Filter the results to only include trips that ended at stations in the zip code '94002'.", "Order the results by the duration of the trips in descending order to find the bike that traveled the most.", "Limit the results to 1 to get the bike ID of the trip with the maximum duration."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT T3.bike_id FROM trip AS T3 JOIN station AS T1 ON T3.end_station_id = T1.id WHERE T1.zip_code = '94002' ORDER BY T3.duration DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["We need to find the names and ids of stations that either have more than 14 bikes available on average or were installed in December.", "To achieve this, we will use a subquery to calculate the average number of bikes available for each station from the 'status' table.", "The subquery will group the results by 'station_id' and use the HAVING clause to filter for those with an average of more than 14 bikes available.", "For the second condition, we will check if the installation date of the station falls in December using the strftime function to extract the month from the 'installation_date' column.", "Finally, we will combine both conditions using an OR operator in the main query, selecting the 'id' and 'name' from the 'station' table."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT id, name FROM station WHERE id IN (SELECT station_id FROM status GROUP BY station_id HAVING AVG(bikes_available) > 14) OR strftime('%m', installation_date) = '12';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["We need to find the names and ids of all stations that meet two criteria: (1) have more than 14 bikes available on average, and (2) had bikes installed in December.", "To address the first criterion, we can use the provided virtual table description which allows us to filter stations based on the number of bikes available from the 'status' table. We will use a condition to check if 'bikes_available' is greater than 14.", "For the second criterion, we need to check the 'installation_date' in the 'station' table to see if it contains '12' (indicating December). We can use the LIKE operator to match any installation date that has '12' in it.", "We will combine both conditions using an OR operator in the WHERE clause to ensure that either condition being true will include the station in the results."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT DISTINCT T1.id, T1.name \nFROM station AS T1 \nJOIN status AS T2 ON T1.id = T2.station_id \nWHERE T2.bikes_available > 14 \nOR T1.installation_date LIKE '%-12-%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique bike stations that currently have a certain number of bikes available. The data is retrieved from the 'station' table, which includes the station's unique identifier and name, and is filtered based on the availability of bikes from the 'status' table. The placeholder in the WHERE clause represents the minimum number of bikes that must be available at the station.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.id ,  T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id WHERE T2.bikes_available  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["Identify the relevant table: The question pertains to cloud cover rates, which are found in the 'weather' table.", "Filter by zip code: We need to focus on records where the zip code is 94107.", "Group by cloud cover: To find the most common cloud cover rates, we will group the results by the 'cloud_cover' column.", "Count occurrences: We will count how many times each cloud cover rate appears using COUNT(cloud_cover).", "Order by frequency: To get the most common rates, we will order the results in descending order based on the count.", "Limit the results: Finally, we will limit the output to the top 3 most common cloud cover rates."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "pred_sql": "SELECT cloud_cover, COUNT(cloud_cover) as frequency \nFROM weather \nWHERE zip_code = 94107 \nGROUP BY cloud_cover \nORDER BY frequency DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["Identify the relevant tables: We need data from the 'trip' table for the ending station and the 'station' table for the installation date.", "Determine the relationship: The 'end_station_id' in the 'trip' table corresponds to the 'id' in the 'station' table.", "Select the required fields: We need the 'installation_date' from the 'station' table.", "Construct the SQL query: Use a JOIN to combine the 'station' and 'trip' tables based on the station ID, and select the installation date."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT S.installation_date FROM station AS S JOIN trip AS T ON S.id = T.end_station_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["Identify the relevant tables: We need information from the 'station' table for installation dates and the 'trip' table for ending stations.", "Determine the columns needed: We need the 'installation_date' from the 'station' table and the 'end_station_id' from the 'trip' table.", "Join the tables: We will join the 'station' table with the 'trip' table on the condition that the station ID in the trip matches the station ID in the station table.", "Group the results: Since we want the installation date for each ending station, we will group the results by 'end_station_id' to ensure we get unique entries for each station."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.name, T1.installation_date FROM station AS T1 JOIN trip AS T2 ON T1.id = T2.end_station_id GROUP BY T2.end_station_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["Identify the station with the largest dock count by using a subquery to find the maximum dock count from the 'station' table.", "Join the 'trip' table with the 'station' table on the start station ID to filter trips that started from the identified station.", "Select the trip ID from the 'trip' table where the start station's dock count matches the maximum dock count found in the subquery."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "pred_sql": "SELECT T3.id FROM trip AS T3 JOIN station AS T1 ON T3.start_station_id = T1.id WHERE T1.dock_count = (SELECT MAX(dock_count) FROM station)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.165", "db_id": "bike_1", "question": "Count the number of trips that did not end in San Francisco city.", "rationale": ["Identify the requirement to count trips that did not end in San Francisco.", "To achieve this, we need to filter trips based on their end station's city.", "We can use a subquery to find all station IDs located in San Francisco.", "The subquery will select the IDs from the 'station' table where the city is 'San Francisco'.", "The main query will count all trips where the end station ID is not in the list of IDs returned by the subquery."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip WHERE end_station_id NOT IN (SELECT id FROM station WHERE city = 'San Francisco')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.166", "db_id": "bike_1", "question": "How many trips did not end in San Francisco?", "rationale": ["Identify the relevant table: The 'trip' table contains information about trips, including the end station name.", "Determine the condition: We need to count trips that did not end in San Francisco, which means we will filter out trips where the 'end_station_name' is 'San Francisco'.", "Construct the SQL query: We will use the COUNT function to count the number of trips that meet the condition, using a WHERE clause to specify that the 'end_station_name' should not be 'San Francisco'."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != 'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip WHERE end_station_name != 'San Francisco';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["Identify the relevant zip code, which is 94107.", "Use the weather table to filter records for the specified zip code.", "Check for days where the weather events do not include 'Fog' or 'Rain'.", "Select the date from the filtered results."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT date FROM weather WHERE zip_code = 94107 AND events NOT IN ('Fog', 'Rain')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.168", "db_id": "bike_1", "question": "On which day has it neither been foggy nor rained in the zip code of 94107?", "rationale": ["Identify the relevant weather conditions: neither foggy nor rained means no precipitation and no weather events.", "Use the weather table to filter records based on the zip code 94107.", "Check for days where precipitation_inches is 0 (indicating no rain) and events is 0 (indicating no fog or other weather events).", "Select the date from the filtered results."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT date FROM weather WHERE zip_code = 94107 AND precipitation_inches = 0 AND events = 0", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.183", "db_id": "bike_1", "question": "List all the cities in a decreasing order of each city's stations' highest latitude.", "rationale": ["We need to list all the cities from the 'station' table.", "To find the highest latitude for each city, we will use the MAX function on the 'lat' column.", "We will group the results by 'city' to ensure we get the highest latitude for each city.", "Finally, we will order the results in decreasing order of the highest latitude using ORDER BY highest_latitude DESC."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, MAX(lat) AS highest_latitude FROM station GROUP BY city ORDER BY highest_latitude DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["Identify the relevant table: The 'station' table contains the necessary information about the stations, including their names and latitude coordinates.", "Determine the requirement: We need to list the names of the stations for each city, ordered by the highest latitude.", "Use a subquery to find the maximum latitude for each city: This can be done by grouping the stations by city and selecting the maximum latitude for each group.", "Join the results back to the 'station' table to get the names of the stations corresponding to the maximum latitude for each city.", "Finally, order the results by latitude in descending order to meet the requirement."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, name FROM station WHERE lat = (SELECT MAX(lat) FROM station GROUP BY city) ORDER BY lat DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.189", "db_id": "bike_1", "question": "For each station, return its longitude and the average duration of trips that started from the station.", "rationale": ["Identify the required data: longitude of each station and the average duration of trips starting from each station.", "The 'station' table contains the longitude information, while the 'trip' table contains the duration of trips and the starting station ID.", "Join the 'station' table with the 'trip' table on the station ID to link trips to their respective starting stations.", "Use the AVG() function to calculate the average duration of trips for each station.", "Group the results by the station ID to ensure the average is calculated for each station individually."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT S.long, AVG(T.duration) AS average_duration\nFROM station AS S\nJOIN trip AS T ON S.id = T.start_station_id\nGROUP BY S.id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["Identify the relevant tables: 'station' for station details and 'trip' for trip details.", "We need the station name and longitude from the 'station' table, and the average duration of trips from the 'trip' table.", "Join the 'station' table with the 'trip' table on the condition that the station ID in the 'station' table matches the start station ID in the 'trip' table.", "Use the AVG() function to calculate the average duration of trips for each start station.", "Group the results by the station ID to ensure we get one result per station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.name, T1.long, AVG(T2.duration) AS average_duration\nFROM station AS T1\nJOIN trip AS T2 ON T1.id = T2.start_station_id\nGROUP BY T1.id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.192", "db_id": "bike_1", "question": "For each end station id, what is its name, latitude, and minimum duration for trips ended there?", "rationale": ["Identify the required information: end station id, name, latitude, and minimum duration for trips that ended at each station.", "Determine the relevant tables: 'station' for station details and 'trip' for trip details.", "Join the 'station' table with the 'trip' table on the end station id to correlate trips with their respective stations.", "Select the station name and latitude from the 'station' table and the minimum trip duration from the 'trip' table.", "Group the results by the end station id to ensure we get the minimum duration for each station."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT T1.name, T1.lat, MIN(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id = T2.end_station_id GROUP BY T2.end_station_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and latitude coordinates of bike stations from the 'station' table, along with the minimum trip duration recorded for trips that ended at each station. The data is aggregated by the end station identifier, allowing users to see which stations have the shortest trip durations.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id\"\n    }\n}\n"}
{"sample_id": "train.196", "db_id": "bike_1", "question": "What are all the different zip codes that have a maximum dew point that was always below 70?", "rationale": ["We need to find all distinct zip codes where the maximum dew point is always below 70.", "To do this, we can select distinct zip codes from the weather table.", "We will use a subquery to filter out any zip codes that have a maximum dew point of 70 or above.", "The subquery will select zip codes from the weather table where the maximum dew point is greater than or equal to 70.", "The main query will then select distinct zip codes that are not in the result of the subquery."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT zip_code FROM weather WHERE zip_code NOT IN (SELECT zip_code FROM weather WHERE max_dew_point_f >= 70)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["We need to find zip codes where the average mean humidity is below 70 and at least 100 trips took place.", "The relevant table for humidity data is the 'weather' table, which contains mean humidity values and zip codes.", "We will filter the weather records to only include those with a mean humidity below 70.", "To ensure that at least 100 trips took place, we will use a GROUP BY clause on the zip_code and a HAVING clause to count the distinct dates (which represent trips) for each zip code.", "The final SQL query will select the zip codes that meet both conditions."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code \nFROM weather \nWHERE mean_humidity < 70 \nGROUP BY zip_code \nHAVING COUNT(DISTINCT date) >= 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.206", "db_id": "bike_1", "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?", "rationale": ["We need to find zip codes with an average mean humidity below 70 and at least 100 trips.", "First, we will create a subquery to select zip codes from the weather table where the average mean humidity is below 70. We will group the results by zip code and use the HAVING clause to filter those with an average mean humidity below 70.", "Next, we will use the trip table to count the number of trips for each zip code. We will group the results by zip code and use the HAVING clause to filter those with at least 100 trips.", "Finally, we will combine the results from the two queries using the IN clause to get the zip codes that meet both conditions."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code \nFROM trip \nWHERE zip_code IN (\n    SELECT zip_code \n    FROM weather \n    GROUP BY zip_code \n    HAVING AVG(mean_humidity) < 70\n) \nGROUP BY zip_code \nHAVING COUNT(id) >= 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates and zip codes of weather reports where the minimum dew point is less than the minimum dew point recorded for a specific zip code. The placeholder in the subquery represents the zip code for which the minimum dew point is being compared.\",\n        \"virtual_table\": \"SELECT date ,  zip_code FROM weather WHERE min_dew_point_f  <  (SELECT min(min_dew_point_f) FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.304", "db_id": "product_catalog", "question": "What are the attribute data types with more than 3 attribute definitions?", "rationale": ["Identify the table that contains attribute definitions, which is 'Attribute_Definitions'.", "Determine the relevant column for the attribute data type, which is 'attribute_data_type'.", "To find attribute data types with more than 3 definitions, use the COUNT function to count the occurrences of each 'attribute_data_type'.", "Group the results by 'attribute_data_type' using the GROUP BY clause.", "Filter the results to include only those with a count greater than 3 using the HAVING clause."], "gold_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  3", "source_tables": ["attribute_definitions"], "pred_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING COUNT(attribute_id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["Identify the tables involved: Catalog_Contents for entry names and Catalog_Contents_Additional_Attributes for attributes.", "We need to find the catalog entry names associated with the attribute that has the most entries.", "To do this, we will join Catalog_Contents and Catalog_Contents_Additional_Attributes on catalog_entry_id.", "We need to determine which attribute has the most entries, which can be done by grouping by catalog_entry_id in the Catalog_Contents_Additional_Attributes table and counting the entries.", "We will order the results by the count of entries in descending order and limit the results to 1 to get the catalog_level_number of the attribute with the most entries.", "Finally, we will use this catalog_level_number in the WHERE clause of our main query to filter the results."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT t1.catalog_entry_name \nFROM Catalog_Contents AS t1 \nJOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id = t2.catalog_entry_id \nWHERE t2.catalog_level_number = (SELECT catalog_level_number \n                                   FROM Catalog_Contents_Additional_Attributes \n                                   GROUP BY catalog_entry_id \n                                   ORDER BY COUNT(*) DESC \n                                   LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["Identify the most expensive catalog by finding the maximum price in dollars from the Catalog_Contents table.", "Join the Catalogs table with the Catalog_Contents table to link catalog entries with their respective catalogs.", "Use a subquery to find the catalog_id of the catalog with the highest maximum price.", "Select the catalog_entry_name from the Catalog_Contents table for the identified catalog."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "pred_sql": "SELECT cc.catalog_entry_name \nFROM Catalogs AS c \nJOIN Catalog_Contents AS cc ON c.catalog_id = cc.catalog_id \nWHERE c.catalog_id = (SELECT catalog_id \n                     FROM Catalogs \n                     ORDER BY (SELECT MAX(price_in_dollars) \n                                 FROM Catalog_Contents \n                                 WHERE catalog_id = Catalogs.catalog_id) DESC \n                     LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.330", "db_id": "product_catalog", "question": "What are the names of catalog entries with level number 8?", "rationale": ["Identify the relevant tables: Catalog_Contents for catalog entries and Catalog_Contents_Additional_Attributes for additional attributes.", "Determine the relationship between the tables: Catalog_Contents and Catalog_Contents_Additional_Attributes are linked by catalog_entry_id.", "Focus on the requirement: We need the names of catalog entries with a specific level number (8).", "Use a JOIN to combine the two tables based on the catalog_entry_id.", "Filter the results using a WHERE clause to specify the catalog_level_number as '8'."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id = t2.catalog_entry_id WHERE t2.catalog_level_number = '8'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["Identify the table that contains product information, which is the Catalog_Contents table.", "Determine the relevant columns needed for the query: catalog_entry_name for product names, length for the length condition, and height for the height condition.", "Construct the SQL SELECT statement to retrieve the catalog_entry_name from the Catalog_Contents table.", "Add the WHERE clause to filter products based on the conditions: length smaller than 3 or height greater than 5."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name \nFROM Catalog_Contents \nWHERE length < 3 OR height > 5;", "hint": "\n"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["Identify the relevant table: The question pertains to catalog contents, so we will use the 'Catalog_Contents' table.", "Determine the columns needed: We need the 'catalog_entry_name' and the 'length' of the catalog entries.", "Formulate the condition: We are looking for entries where the length is below 3 or above 5.", "Construct the SQL query: We will select the 'catalog_entry_name' from 'Catalog_Contents' where the length meets the specified conditions."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE length < 3 OR length > 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.338", "db_id": "product_catalog", "question": "On which days more than one revisions were made on catalogs.", "rationale": ["Identify the relevant table: The 'Catalogs' table contains information about catalog revisions, including the date of the latest revision.", "Select the date of the latest revision and count the number of revisions made on that date.", "Group the results by the date of the latest revision to aggregate the counts.", "Use the HAVING clause to filter the results to only include dates where the count of revisions is greater than one."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "pred_sql": "SELECT date_of_latest_revision, COUNT(*) as revision_count \nFROM Catalogs \nGROUP BY date_of_latest_revision \nHAVING COUNT(*) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that are associated with specific additional attributes. The placeholder in the WHERE clause represents the level number of the catalog entry, allowing users to filter results based on this attribute.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flight origins and destinations.", "Determine the required information: We need the origins of flights that are headed to Honolulu.", "Construct the SQL query: Use a SELECT statement to retrieve the 'origin' column from the 'flight' table where the 'destination' is 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the required columns: We need the 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We want flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Use a SELECT statement to retrieve the specified columns from the 'flight' table with the appropriate WHERE clause."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flights, including their prices and origins.", "Determine the specific columns needed: We need the 'price' column to calculate the average price.", "Apply the necessary conditions: We want to filter the flights where the origin is 'LA' and the destination is 'Honolulu'.", "Use the AVG() function to calculate the average price of the filtered flights."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT AVG(price) AS average_price FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of flight origins from the 'Flight' table, grouped by the origin location. The results are ordered by the number of flights departing from each origin in descending order, with a limit on the number of origins returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT origin FROM Flight GROUP BY origin ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["Identify the tables needed: We need data from the 'aircraft' table for aircraft names and from the 'flight' table to count the number of flights.", "We will use a LEFT JOIN to combine the 'aircraft' and 'flight' tables on the aircraft ID (aid) to ensure we get all aircraft even if they have no flights.", "We will use COUNT(f.flno) to count the number of flights associated with each aircraft.", "We need to group the results by aircraft ID and name to get the count for each aircraft."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS number_of_flights\nFROM aircraft a\nLEFT JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid, a.name;", "hint": "\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables needed: We need data from the 'aircraft' table for aircraft names and from the 'flight' table to count the number of flights.", "Use a LEFT JOIN to combine the 'aircraft' table with the 'flight' table on the aircraft ID (aid) to ensure we get all aircraft, even those with no flights.", "Count the number of flights for each aircraft using COUNT(f.flno) and alias it as flight_count.", "Group the results by the aircraft ID (a.aid) to get the count of flights for each aircraft.", "Select the aircraft name (a.name) and the count of flights."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT a.name, COUNT(f.flno) AS flight_count\nFROM aircraft a\nLEFT JOIN flight f ON a.aid = f.aid\nGROUP BY a.aid;", "hint": "\n"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["Identify the main table to query from, which is the 'employee' table to get employee names.", "We need to find employees who are not certified to fly a specific aircraft, in this case, the 'Boeing 737-800'.", "To find certified employees, we will use the 'certificate' table and join it with the 'aircraft' table to filter by aircraft name.", "The subquery will select employee IDs (eid) from the 'certificate' table where the associated aircraft is 'Boeing 737-800'.", "The main query will select names from the 'employee' table where the employee ID is not in the list of IDs returned by the subquery."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.name \nFROM employee e \nWHERE e.eid NOT IN (\n    SELECT c.eid \n    FROM certificate c \n    JOIN aircraft a ON c.aid = a.aid \n    WHERE a.name = 'Boeing 737-800'\n);", "hint": "\n"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["We need to find the name of the aircraft with the fewest number of certificates held by employees.", "To do this, we will join the 'aircraft' table with the 'certificate' table on the aircraft ID (aid).", "We will group the results by the aircraft ID to count the number of certificates for each aircraft.", "Next, we will order the results by the count of certificates in ascending order to get the aircraft with the fewest certificates at the top.", "Finally, we will limit the results to just one entry to get the aircraft with the fewest certificates."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nORDER BY COUNT(c.eid) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["We need to find the names of aircraft with the least number of certified pilots.", "To do this, we will join the 'aircraft' table with the 'certificate' table on the aircraft ID ('aid').", "We will group the results by the aircraft ID to count how many employees are certified for each aircraft.", "We will use the HAVING clause to filter the groups to only those where the count of certified employees is equal to the minimum count of certified employees across all aircraft.", "To find the minimum count, we will use a subquery that counts the number of certifications for each aircraft and selects the minimum count from those counts."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT a.name\nFROM aircraft a\nJOIN certificate c ON a.aid = c.aid\nGROUP BY a.aid\nHAVING COUNT(c.eid) = (\n    SELECT MIN(cert_count)\n    FROM (\n        SELECT COUNT(eid) AS cert_count\n        FROM certificate\n        GROUP BY aid\n    ) AS counts\n);", "hint": "\n"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["Identify the relevant tables: employee, certificate, and aircraft.", "We need to find employees who have certificates to fly aircraft with a distance greater than 5000.", "Join the employee table with the certificate table on employee ID (eid) and then join with the aircraft table on aircraft ID (aid).", "Filter the results to include only those aircraft where the distance is greater than 5000.", "Group the results by employee ID to count the number of certificates each employee has.", "Order the results by the count of certificates in descending order to find the employee with the most certificates.", "Limit the results to 1 to get only the top employee."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT e.salary, e.name \nFROM employee e \nJOIN certificate c ON e.eid = c.eid \nJOIN aircraft a ON c.aid = a.aid \nWHERE a.distance > 5000 \nGROUP BY e.eid \nORDER BY COUNT(c.aid) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The question asks for all the different food allergies, which implies we need to retrieve unique allergy types.", "We will use the 'Allergy_Type' table since it contains the allergy names and their types.", "To get the different types of allergies, we can use the DISTINCT keyword to ensure we only get unique allergy types.", "The final SQL query will select the distinct AllergyType from the Allergy_Type table."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT AllergyType FROM Allergy_Type;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.452", "db_id": "allergy_1", "question": "How many animal type allergies exist?", "rationale": ["Identify the relevant table: Allergy_Type contains the allergy types.", "We need to count the distinct allergy types that fall under 'Animal'.", "Use the COUNT function to get the number of distinct allergy types.", "Filter the results using a WHERE clause to only include those with AllergyType as 'Animal'."], "gold_sql": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  'animal'", "source_tables": ["allergy_type"], "pred_sql": "SELECT COUNT(DISTINCT AllergyType) AS Animal_Allergy_Count FROM Allergy_Type WHERE AllergyType = 'Animal';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["Identify the table that contains the allergy types, which is 'Allergy_Type'.", "We need to group the allergies by their type, so we will use the 'GROUP BY' clause on the 'AllergyType' column.", "To find out which allergy type has the most allergies, we will count the occurrences of each allergy type using 'COUNT(Allergy)'.", "We will order the results in descending order to get the most common allergy type at the top using 'ORDER BY COUNT(Allergy) DESC'.", "Finally, we will limit the results to only one record using 'LIMIT 1' to get the allergy type with the highest count."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType FROM Allergy_Type GROUP BY AllergyType ORDER BY COUNT(Allergy) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["Identify the need to find the least common allergy type.", "Understand that we need to count the occurrences of each allergy in the Has_Allergy table.", "Group the allergies by their name and order them by the count in ascending order to find the least common one.", "Use a subquery to get the least common allergy from the Has_Allergy table.", "Join this result with the Allergy_Type table to get the corresponding allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType FROM Allergy_Type WHERE Allergy IN (SELECT Allergy FROM Has_Allergy GROUP BY Allergy ORDER BY COUNT(*) ASC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "To get the full names, we need to concatenate the 'Fname' and 'LName' columns.", "Use the SQL SELECT statement to retrieve the concatenated names from the 'Student' table."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the relevant table: The 'Student' table contains the information about students, including their gender.", "Determine the condition: We need to filter the students based on their gender, specifically for male students.", "Construct the SQL query: We will select the 'StuID' from the 'Student' table where the 'Sex' column is equal to 'Male'."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the majors, which is the 'Student' table.", "We need to group the results by the 'Major' column to count how many students are in each major.", "Order the results in descending order based on the count of students in each major to find the largest major.", "Limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major and ordered by the number of students in each major in descending order. The placeholder in the LIMIT clause represents the maximum number of majors to return.\",\n        \"virtual_table\": \"SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.502", "db_id": "allergy_1", "question": "Give the advisor with the most students.", "rationale": ["Identify the relevant table: The 'Student' table contains the advisor information and student identifiers.", "Count the number of students for each advisor: Use COUNT(*) to count the number of students associated with each advisor.", "Group the results by advisor: Use GROUP BY Advisor to aggregate the student counts for each advisor.", "Order the results: Use ORDER BY COUNT(*) DESC to sort the advisors by the number of students in descending order.", "Limit the results to the top advisor: Use LIMIT 1 to get only the advisor with the most students."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(*) as StudentCount FROM Student GROUP BY Advisor ORDER BY StudentCount DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of academic advisors from the 'Student' table, grouped by the advisor's name. The results are ordered by the number of students assigned to each advisor in descending order, with a limit on the number of advisors returned, specified by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["Identify the relevant tables: Has_Allergy and Student.", "We need to count the number of students with a specific allergy, which is 'cat'.", "Join the Has_Allergy table with the Student table on StuID to get student details along with their allergies.", "Filter the results to only include records where the Allergy is 'cat'.", "Use the COUNT function to get the total number of students with cat allergies."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.Allergy = 'cat'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the relevant tables: Has_Allergy and Student.", "We need to count the number of students affected by cat allergies, so we will focus on the Has_Allergy table for allergies and the Student table for student information.", "Join the Has_Allergy table with the Student table on the StuID to link students with their allergies.", "Filter the results to only include records where the Allergy is 'cat'.", "Use the COUNT function to count the number of students who have cat allergies."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T1.Allergy = 'cat'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the tables involved: Has_Allergy and Student.", "We need to count the number of students, so we will use the COUNT function.", "We need to join the Has_Allergy table with the Student table on the StuID column to get student details along with their allergies.", "We filter the results to include only female students by adding a condition in the WHERE clause: T2.Sex = 'Female'.", "We also need to filter for specific allergies, which are 'Milk' and 'Eggs'. This can be done using an OR condition in the WHERE clause: T1.Allergy = 'Milk' OR T1.Allergy = 'Eggs'.", "Combine the conditions in the WHERE clause using AND to ensure both filters are applied."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T2.Sex = 'Female' AND (T1.Allergy = 'Milk' OR T1.Allergy = 'Eggs')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.514", "db_id": "allergy_1", "question": "Which allergy is the most common?", "rationale": ["To find the most common allergy, we need to count the occurrences of each allergy in the Has_Allergy table.", "We will use the COUNT function to count how many times each allergy appears.", "We will group the results by the Allergy column to get the count for each unique allergy.", "To determine which allergy is the most common, we will order the results in descending order based on the count.", "Finally, we will limit the results to 1 to get only the most common allergy."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT Allergy, COUNT(*) as AllergyCount FROM Has_Allergy GROUP BY Allergy ORDER BY AllergyCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of allergies categorized in the 'Allergy_Type' table. It groups the allergies by their type and orders them by the frequency of occurrence, allowing users to see the most common allergy types. The placeholder in the LIMIT clause represents the maximum number of allergy types to display.\",\n        \"virtual_table\": \"SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["Identify the tables needed: We need to retrieve student information (last name and age) and their allergies, so we will use the Student and Has_Allergy tables.", "Determine the relationships: The Has_Allergy table links students to their allergies via the StuID column, which is a foreign key in Has_Allergy referencing Student.", "Join the tables: We will join the Student table with the Has_Allergy table twice to check for both allergies (milk and cat).", "Specify the conditions: We need to filter the results to only include students who have both allergies, which can be done by checking the conditions in the WHERE clause for each joined instance of Has_Allergy."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age \nFROM Student AS S \nJOIN Has_Allergy AS HA1 ON S.StuID = HA1.StuID \nJOIN Has_Allergy AS HA2 ON S.StuID = HA2.StuID \nWHERE HA1.Allergy = 'milk' AND HA2.Allergy = 'cat';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the tables needed: We need to retrieve student information (last names and ages) and their allergies, so we will use the Student and Has_Allergy tables.", "Determine the columns to select: We need the last names (LName) and ages (Age) of the students.", "Establish the relationship between tables: The Has_Allergy table links students to their allergies via the StuID column, which is common in both tables.", "Filter the results: We need to filter the allergies to only include 'milk' and 'cat'.", "Construct the SQL query: We will use a JOIN to combine the Student and Has_Allergy tables, select the required columns, and apply the necessary filters."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT S.LName, S.Age \nFROM Student AS S \nJOIN Has_Allergy AS HA ON S.StuID = HA.StuID \nWHERE HA.Allergy IN ('milk', 'cat') \nGROUP BY S.StuID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.523", "db_id": "allergy_1", "question": "Find the first name and gender of the student who has allergy to milk but not cat.", "rationale": ["Identify the tables needed: We need data from the Student and Has_Allergy tables.", "Select the columns: We want the first name (Fname) and gender (Sex) of the students.", "Join the tables: We will join the Student table with the Has_Allergy table on the StuID column to link students with their allergies.", "Filter for milk allergy: We need to filter the results to include only those students who have an allergy to milk.", "Exclude cat allergy: We also need to ensure that these students do not have an allergy to cat. This can be done using a subquery that selects StuIDs of students with a cat allergy and excludes them from the main query."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex FROM Student AS S JOIN Has_Allergy AS H ON S.StuID = H.StuID WHERE H.Allergy = 'milk' AND S.StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.524", "db_id": "allergy_1", "question": "What are the first name and gender of the students who have allergy to milk but can put up with cats?", "rationale": ["Identify the required information: first name and gender of students with a specific allergy (milk) and without another (cats).", "To get the first name and gender, we need to select these columns from the Student table.", "We need to join the Student table with the Has_Allergy table to filter students based on their allergies.", "The condition for the allergy to milk is straightforward: we filter where the Allergy column equals 'milk'.", "For the condition of not having an allergy to cats, we can use a subquery that selects StuID from Has_Allergy where Allergy equals 'cats'.", "We will use the NOT IN clause to exclude those students who have an allergy to cats from our main query.", "Finally, we combine these conditions in the WHERE clause of our SQL query."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex FROM Student AS S JOIN Has_Allergy AS HA ON S.StuID = HA.StuID WHERE HA.Allergy = 'milk' AND S.StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'cats');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the tables needed: Student, Has_Allergy, and Allergy_Type.", "We need to find students with specific allergies, so we will join Has_Allergy with Student on StuID.", "Next, we need to filter these allergies by their type, which requires joining with the Allergy_Type table.", "We will filter the results where the AllergyType is either 'food' or 'animal'.", "Finally, we will calculate the average age of the filtered students using AVG() and ensure to cast Age to an integer for accurate calculation."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT AVG(CAST(Age AS INTEGER)) AS average_age \nFROM Student AS S \nJOIN Has_Allergy AS HA ON S.StuID = HA.StuID \nJOIN Allergy_Type AS AT ON HA.Allergy = AT.Allergy \nWHERE AT.AllergyType IN ('food', 'animal')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["Identify the tables needed: We need to retrieve student names from the Student table and check their allergies from the Has_Allergy table.", "We want to find students who are not allergic to any type of food, so we need to filter out those who have allergies categorized as 'Food'.", "To do this, we can use a subquery that selects the StuID of students who have food allergies.", "The main query will select the full name (concatenation of first and last name) of students whose StuID is not in the list returned by the subquery.", "The final SQL query combines these elements to provide the desired output."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName \nFROM Student \nWHERE StuID NOT IN (\n    SELECT StuID \n    FROM Has_Allergy \n    JOIN Allergy_Type ON Has_Allergy.Allergy = Allergy_Type.Allergy \n    WHERE AllergyType = 'Food'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["Identify the tables involved: Has_Allergy for allergies and Student for student details.", "We need to count the number of male students, so we will filter the Student table by Sex = 'M'.", "We need to check for allergies related to food, which requires a subquery to the Allergy_Type table to get all allergies of type 'Food'.", "Join the Has_Allergy table with the Student table on StuID to correlate students with their allergies.", "Use the COUNT function to get the total number of male students with food allergies."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT count(*) FROM Has_Allergy AS T1 JOIN Student AS T2 ON T1.StuID = T2.StuID WHERE T2.Sex = 'M' AND T1.Allergy IN (SELECT Allergy FROM Allergy_Type WHERE AllergyType = 'Food')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables needed: We need data from the Student and Has_Allergy tables.", "We need to find students with specific allergies (milk or cat).", "We will join the Student table with the Has_Allergy table on the StuID column to get the relevant student information for those allergies.", "We need to select distinct first names and city codes to avoid duplicates in the results.", "The WHERE clause will filter the results to include only those students who have an allergy to either milk or cat."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student AS S \nJOIN Has_Allergy AS HA ON S.StuID = HA.StuID \nWHERE HA.Allergy = 'milk' OR HA.Allergy = 'cat';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["Identify the tables needed: We need data from the Student and Has_Allergy tables.", "We need to select distinct first names and city codes, so we will use SELECT DISTINCT.", "We will join the Student table with the Has_Allergy table on the StuID column to link students with their allergies.", "We need to filter the results to include only those students who have allergies to either 'milk' or 'cat'.", "Construct the SQL query using the identified tables, columns, and conditions."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student AS S \nJOIN Has_Allergy AS H ON S.StuID = H.StuID \nWHERE H.Allergy = 'milk' OR H.Allergy = 'cat';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of students who have specific allergies, filtered by their gender. The placeholders in the WHERE clause represent the gender of the students and the names of the allergies.\",\n        \"virtual_table\": \"SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  [PLACEHOLDER-TYPE:STRING] AND T1.allergy  =  [PLACEHOLDER-TYPE:STRING] OR T1.allergy  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["The query needs to retrieve the names of countries and the average invoice size.", "We will select the 'billing_country' from the 'invoices' table.", "To calculate the average invoice size, we will use the AVG() function on the 'total' column from the 'invoices' table.", "We will group the results by 'billing_country' to get the average for each country.", "Finally, we will order the results by the average invoice size in descending order to get the top countries."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size \nFROM invoices \nGROUP BY billing_country \nORDER BY AVG(total) DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["We need to count the number of invoices for each state.", "The relevant table for invoices is the 'invoices' table, which contains a 'billing_state' column.", "To get the count of invoices per state, we can use the COUNT() function.", "We will group the results by 'billing_state' to get the count for each state."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count FROM invoices GROUP BY billing_state;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["We need to find the states with the most invoices, which means we need to count the number of invoices per state.", "The relevant table for this information is the 'invoices' table, which contains a 'billing_state' column.", "We will use the COUNT() function to count the number of invoices for each state.", "To group the results by state, we will use the GROUP BY clause on the 'billing_state' column.", "Finally, we will order the results in descending order based on the count of invoices to get the states with the most invoices at the top."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count \nFROM invoices \nGROUP BY billing_state \nORDER BY invoice_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.568", "db_id": "store_1", "question": "What is the number of invoices and total money billed in them from CA?", "rationale": ["Identify the relevant table: invoices, which contains billing information.", "Determine the required fields: count of invoices and total amount billed.", "Use COUNT(*) to get the number of invoices and SUM(total) to calculate the total amount billed.", "Filter the results by the state 'CA' using the WHERE clause."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS total_billed FROM invoices WHERE billing_state = 'CA';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the table that contains the required information: the 'employees' table has the email and phone number of employees.", "Use the provided hint to construct a query that selects the email and phone number from the 'employees' table.", "Filter the results by specifying the first name as 'Astrid' and the last name as 'Gruber' in the WHERE clause."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the street address of employees from the 'employees' table based on their first and last names. The placeholders in the WHERE clause represent the specific first and last names of the employee being queried.\",\n        \"virtual_table\": \"SELECT address FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["Identify the relevant table: The question asks about customers, so we will use the 'customers' table.", "Determine the condition: We need to count customers from California, which is specified in the 'state' column.", "Construct the SQL query: We will use the COUNT function to count the number of customers where the state is 'California'."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) FROM customers WHERE state = 'California';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: We need to find employees and customers, so we will use the 'employees' and 'customers' tables.", "Join the tables: We will join the 'employees' table with the 'customers' table on the 'support_rep_id' to link employees with the customers they support.", "Group the results: We will group the results by employee ID to count the number of customers each employee supports.", "Count the customers: We will use COUNT(c.id) to count the number of customers for each employee.", "Order the results: We will order the results in descending order based on the count of customers to find the employee with the most customers.", "Limit the results: We will limit the results to 1 to get only the employee who supports the most customers.", "Select the full name: We will concatenate the first and last names of the employee to get the full name."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT e.first_name || ' ' || e.last_name AS full_name\nFROM employees e\nJOIN customers c ON e.id = c.support_rep_id\nGROUP BY e.id\nORDER BY COUNT(c.id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees who report to a specific manager from the 'employees' table. The placeholders in the WHERE clause represent the first and last names of the manager.\",\n        \"virtual_table\": \"SELECT T2.first_name , T2.last_name FROM employees AS T1 JOIN employees AS T2 ON T1.id = T2.reports_to WHERE T1.first_name = [PLACEHOLDER-TYPE:STRING] AND T1.last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["Identify the customer 'Luca Mancini' by searching in the 'customers' table using first and last name.", "Use the customer ID obtained from the previous step to filter the invoices in the 'invoices' table.", "Count the number of invoices associated with the customer ID to determine how many orders Luca Mancini has."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "pred_sql": "SELECT COUNT(*) FROM invoices WHERE customer_id IN (SELECT id FROM customers WHERE first_name = 'Luca' AND last_name = 'Mancini');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount of invoices issued for a specific billing city and state. The placeholders in the WHERE clause represent the billing city and state for which the total is being calculated.\",\n        \"virtual_table\": \"SELECT sum(total) FROM invoices WHERE billing_city  =  [PLACEHOLDER-TYPE:STRING] AND billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["Identify the track 'Balls to the Wall' in the tracks table.", "Join the tracks table with the albums table using the album_id foreign key.", "Select the title of the album that corresponds to the identified track."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title \nFROM albums \nJOIN tracks ON albums.id = tracks.album_id \nWHERE tracks.name = 'Balls to the Wall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\",\n        \"virtual_table\": \"SELECT title FROM albums WHERE title LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY title;\"\n    }\n}\n"}
{"sample_id": "train.626", "db_id": "store_1", "question": "What is the name of all tracks in the album named Balls to the Wall?", "rationale": ["Identify the relevant tables: We need to retrieve track names, which are stored in the 'tracks' table, and we need to filter these tracks based on the album title, which is stored in the 'albums' table.", "Establish the relationship: The 'tracks' table has a foreign key 'album_id' that references the 'id' in the 'albums' table. This means we can join these two tables on this key to get the necessary information.", "Formulate the SQL query: We will select the 'name' from the 'tracks' table and join it with the 'albums' table to filter by the album title 'Balls to the Wall'.", "Use the WHERE clause to specify the album title we are interested in."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN albums ON tracks.album_id = albums.id \nWHERE albums.title = 'Balls to the Wall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\",\n        \"virtual_table\": \"SELECT title FROM albums WHERE title LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY title;\"\n    }\n}\n"}
{"sample_id": "train.630", "db_id": "store_1", "question": "What are the names of all Rock tracks that are stored on MPEG audio files?", "rationale": ["Identify the relevant tables: tracks, media_types, and genres are needed to get track names, media type, and genre respectively.", "Join the tracks table with media_types on media_type_id to filter tracks based on their media type.", "Join the tracks table with genres on genre_id to filter tracks based on their genre.", "Use a WHERE clause to specify that we want tracks that are of the genre 'Rock' and are stored in 'MPEG audio' files."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN media_types ON tracks.media_type_id = media_types.id \nJOIN genres ON tracks.genre_id = genres.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG audio';", "hint": "\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the tables involved: tracks, genres, and media_types.", "We need to select the track names, so we will select 'tracks.name'.", "To filter tracks by genre, we will join the 'tracks' table with the 'genres' table on 'tracks.genre_id = genres.id'.", "To filter tracks by media type, we will join the 'tracks' table with the 'media_types' table on 'tracks.media_type_id = media_types.id'.", "We will add a WHERE clause to filter for the genre 'Rock' and the media type 'MPEG'.", "Combine all these elements to form the final SQL query."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN genres ON tracks.genre_id = genres.id \nJOIN media_types ON tracks.media_type_id = media_types.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG';", "hint": "\n"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["Identify the relevant tables: We need to find tracks that a specific customer (Dean Peeters) bought, which involves the 'tracks', 'invoice_lines', 'invoices', and 'customers' tables.", "Join the tables: We will join 'tracks' with 'invoice_lines' to get the track details for each invoice line, then join 'invoice_lines' with 'invoices' to link to the customer, and finally join 'invoices' with 'customers' to filter by the specific customer.", "Filter by customer name: We will add a WHERE clause to filter the results to only include purchases made by Dean Peeters, using both first and last name."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN invoice_lines ON tracks.id = invoice_lines.track_id \nJOIN invoices ON invoice_lines.invoice_id = invoices.id \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Dean' AND customers.last_name = 'Peeters';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of albums from the 'albums' table that match a specific pattern. The placeholder in the WHERE clause represents the title pattern to search for.\",\n        \"virtual_table\": \"SELECT title FROM albums WHERE title LIKE [PLACEHOLDER-TYPE:STRING] ORDER BY title;\"\n    }\n}\n"}
{"sample_id": "train.686", "db_id": "customers_card_transactions", "question": "What are the full names of customers who do not have any accounts?", "rationale": ["We need to find customers who do not have any accounts.", "To do this, we can use a LEFT JOIN between the Customers table and a virtual table that counts the number of accounts per customer from the Accounts table.", "The virtual table is created using a subquery that selects customer_id and counts the number of accounts, grouping by customer_id.", "We then join this virtual table with the Customers table on customer_id.", "To find customers without accounts, we filter the results where the account count from the virtual table is NULL.", "Finally, we select the full names of these customers by concatenating their first and last names."], "gold_sql": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nLEFT JOIN (SELECT customer_id, count(*) AS account_count FROM Accounts GROUP BY customer_id) a ON c.customer_id = a.customer_id\nWHERE a.account_count IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\",\n        \"virtual_table\": \"SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id\"\n    }\n}\n"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["Identify the information needed: full names of customers who have accounts.", "To get the full names, we need to select the first and last names from the Customers table.", "We need to filter customers who have accounts, which requires joining the Customers table with the Accounts table.", "The hint provides a virtual table that summarizes the number of accounts per customer, which we can use to filter customers with accounts.", "We will use a JOIN operation between the Customers table and the virtual table that counts accounts, matching on customer_id.", "Finally, we will concatenate the first and last names to get the full name."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_first_name || ' ' || c.customer_last_name AS full_name \nFROM Customers c \nJOIN (SELECT customer_id, count(*) \n      FROM Accounts \n      GROUP BY customer_id) a \nON c.customer_id = a.customer_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\",\n        \"virtual_table\": \"SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id\"\n    }\n}\n"}
{"sample_id": "train.704", "db_id": "customers_card_transactions", "question": "Return the full name and phone of the customer who has card number 4560596484842.", "rationale": ["Identify the required information: full name and phone number of the customer.", "The full name can be constructed by concatenating the first name and last name from the Customers table.", "To find the customer associated with the specific card number, we need to join the Customers table with the Customers_Cards table.", "Use a subquery to filter the customer_id from the Customers_Cards table where the card_number matches '4560596484842'.", "Select the full name and phone number from the Customers table based on the filtered customer_id."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  '4560596484842'", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name, customer_phone FROM Customers WHERE customer_id IN (SELECT customer_id FROM Customers_Cards WHERE card_number = '4560596484842')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers\"\n    }\n}\n"}
{"sample_id": "train.717", "db_id": "customers_card_transactions", "question": "What is the customer id, first and last name with least number of accounts.", "rationale": ["We need to find the customer with the least number of accounts.", "To do this, we will join the 'Customers' table with the 'Accounts' table on 'customer_id'.", "We will group the results by 'customer_id' to count the number of accounts each customer has.", "We will order the results by the count of accounts in ascending order to get the customer with the least number of accounts at the top.", "Finally, we will limit the results to 1 to get only the customer with the least number of accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name \nFROM Customers c \nJOIN Accounts a ON c.customer_id = a.customer_id \nGROUP BY c.customer_id \nORDER BY COUNT(a.account_id) ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the customer ID, first name, last name, and phone number of customers from the 'Customers' table. The placeholders represent the specific values that can be filtered or modified as needed.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name ,  customer_last_name ,  customer_phone FROM Customers\"\n    }\n}\n"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["We need to find the customer with the fewest accounts, so we first summarize the number of accounts per customer using a subquery.", "The subquery selects the customer_id and counts the number of accounts for each customer, grouping by customer_id.", "Next, we join this subquery with the Customers table to get the full name of the customer.", "We select the customer_id and concatenate the first and last names to create a full_name field.", "Finally, we order the results by account_count in ascending order and limit the results to 1 to get the customer with the fewest accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN (\n    SELECT customer_id, COUNT(*) AS account_count\n    FROM Accounts\n    GROUP BY customer_id\n) AS account_summary ON c.customer_id = account_summary.customer_id\nORDER BY account_count ASC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of accounts associated with each customer from the 'Accounts' table. The placeholder in the SELECT clause represents the customer identifier, and the count function aggregates the total number of accounts per customer.\",\n        \"virtual_table\": \"SELECT customer_id ,  count(*) FROM Accounts GROUP BY customer_id\"\n    }\n}\n"}
{"sample_id": "train.721", "db_id": "customers_card_transactions", "question": "What is the card type code with most number of cards?", "rationale": ["Identify the relevant table: Customers_Cards contains the card type codes.", "Group the results by card type code to count the number of cards for each type.", "Order the results in descending order based on the count of cards to find the most frequent card type.", "Limit the results to 1 to get only the card type code with the most number of cards."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "pred_sql": "SELECT card_type_code FROM Customers_Cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table summarizes the different types of cards issued to customers, displaying the card type codes from the 'Customers_Cards' table. The results are grouped by card type code and ordered by the frequency of each type, allowing the user to specify a limit on the number of types returned.\",\n        \"virtual_table\": \"SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.735", "db_id": "customers_card_transactions", "question": "Show the number of transaction types.", "rationale": ["The user wants to know the number of transaction types.", "To achieve this, we need to count the occurrences of each transaction type in the Financial_Transactions table.", "We will use the COUNT() function to count the number of transactions for each type.", "We will group the results by transaction_type to get the count for each distinct type."], "gold_sql": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, COUNT(*) as transaction_count FROM Financial_Transactions GROUP BY transaction_type;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account identifier, while the count function aggregates the total number of transactions for each account.\",\n        \"virtual_table\": \"SELECT account_id ,  count(*) FROM Financial_transactions GROUP BY account_id\"\n    }\n}\n"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["Identify the relevant table: The 'Financial_Transactions' table contains the transaction types and amounts.", "Determine the required information: We need to find the transaction type with the greatest total amount.", "Use the SUM function to calculate the total amount for each transaction type.", "Group the results by transaction type to aggregate the amounts.", "Order the results in descending order to get the highest total amount at the top.", "Limit the results to 1 to get only the transaction type with the greatest total amount."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, SUM(transaction_amount) AS total_amount \nFROM Financial_Transactions \nGROUP BY transaction_type \nORDER BY total_amount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions associated with each account from the 'Financial_Transactions' table. The placeholder in the SELECT clause represents the account identifier, while the count function aggregates the total number of transactions for each account.\",\n        \"virtual_table\": \"SELECT account_id ,  count(*) FROM Financial_transactions GROUP BY account_id\"\n    }\n}\n"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["Identify the relevant tables: Available_Policies, Customers_Policies, and Customers.", "We need to retrieve customer phone numbers, which are in the Available_Policies table.", "Join the Available_Policies table with the Customers_Policies table on Policy_ID to link policies to customers.", "Join the Customers_Policies table with the Customers table on Customer_ID to get customer details.", "Filter the results to only include policies of type 'Life Insurance' using a WHERE clause."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "pred_sql": "SELECT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN Customers c ON cp.Customer_ID = c.Customer_ID \nWHERE ap.policy_type_code = 'Life Insurance';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["Identify the table that contains policy types, which is 'Available_Policies'.", "We need to group the records by 'policy_type_code' to count how many records exist for each type.", "Use the COUNT function to count the occurrences of each policy type.", "Order the results in descending order to get the most common policy type at the top.", "Limit the results to 1 to get only the policy type with the most records."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "pred_sql": "SELECT policy_type_code FROM Available_Policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["Identify the most popular policy type by counting occurrences in the Available_Policies table.", "Use a subquery to select the policy_type_code that has the highest count, limiting the result to 1 to get the most popular policy type.", "Join the Available_Policies table with the Customers_Policies table to link policies to customers.", "Select the Customer_Phone from the Available_Policies table where the policy type matches the most popular policy type identified in the subquery.", "Use DISTINCT to ensure that each phone number is listed only once."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN (\n    SELECT policy_type_code \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    ORDER BY count(*) DESC \n    LIMIT 1\n) AS most_popular_policy ON ap.policy_type_code = most_popular_policy.policy_type_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["Identify the tables involved: Customers, Customers_Policies, and Available_Policies.", "We need to find the phone numbers of customers, so we will select 'Customer_Phone' from the Customers table.", "To link customers with their policies, we will join the Customers table with the Customers_Policies table on 'Customer_ID'.", "Next, we will join the Customers_Policies table with the Available_Policies table on 'Policy_ID' to access the policy types.", "To find the most common policy type, we will use a subquery that groups the policies by 'policy_type_code', counts them, and orders them in descending order, limiting the result to the top one.", "Finally, we will filter the main query to only include customers whose policies match the most common policy type found in the subquery."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT c.Customer_Phone \nFROM Customers c \nJOIN Customers_Policies cp ON c.Customer_ID = cp.Customer_ID \nJOIN Available_Policies ap ON cp.Policy_ID = ap.Policy_ID \nWHERE ap.policy_type_code = (\n    SELECT policy_type_code \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    ORDER BY count(*) DESC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies available in the 'Available_Policies' table. It groups the policies by their type code and orders them by the number of occurrences, allowing users to see the most common policy types. The placeholder in the LIMIT clause represents the maximum number of policy types to return.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1060", "db_id": "match_season", "question": "Show the players from college UCLA.", "rationale": ["Identify the relevant table: The 'player' table contains player information, and the 'match_season' table contains college information.", "Determine the condition: We need to find players who attended UCLA, which is specified in the 'College' column of the 'match_season' table.", "Use a subquery: To find the teams associated with UCLA, we can use a subquery to select 'Team_id' from 'match_season' where 'College' is 'UCLA'.", "Join the results: We will then select the 'Player' from the 'player' table where the 'Team' matches the 'Team_id' from the subquery."], "gold_sql": "SELECT Player FROM match_season WHERE College  =  'UCLA'", "source_tables": ["match_season"], "pred_sql": "SELECT Player FROM player WHERE Team IN (SELECT Team_id FROM match_season WHERE College = 'UCLA');", "hint": "\n"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["Identify the required columns: season, player, and team name.", "The 'season' and 'player' information is found in the 'match_season' table.", "The 'team name' is found in the 'team' table.", "To get the team name associated with each player, a JOIN operation is needed between 'match_season' and 'team' tables using the 'Team' identifier.", "The SQL query is constructed to select the desired columns from the joined tables."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "pred_sql": "SELECT T1.Season, T1.Player, T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team = T2.Team_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of match seasons, including the season name, player name, and the corresponding team name. The data is retrieved from the 'match_season' table, which is joined with the 'team' table to associate each player with their respective team using the team identifier.\",\n        \"virtual_table\": \"SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id\"\n    }\n}\n"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["Identify the tables needed: We need data from the 'country' table for country names and the 'match_season' and 'player' tables to count the players.", "Join the 'country' table with the 'match_season' table on the country ID to link players to their respective countries.", "Join the 'match_season' table with the 'player' table to ensure we are counting players correctly.", "Use COUNT to count the number of players for each country.", "Group the results by country name to get the count of players per country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "pred_sql": "SELECT C.Country_name, COUNT(P.Player) AS Number_of_Players \nFROM country AS C \nJOIN match_season AS M ON C.Country_id = M.Country \nJOIN player AS P ON M.Player = P.Player \nGROUP BY C.Country_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct official native languages of countries represented by players in a specific position during matches. The placeholder in the WHERE clause represents the player's position.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T1.Official_native_language) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1098", "db_id": "match_season", "question": "Show the top 3 most common colleges of players in match seasons.", "rationale": ["We need to find the top 3 most common colleges of players in match seasons.", "To do this, we will use the 'match_season' table which contains the 'College' column.", "We will group the results by 'College' to count how many players attended each college.", "We will use the COUNT function to count the number of players for each college.", "To get the most common colleges, we will order the results in descending order based on the count.", "Finally, we will limit the results to the top 3 colleges."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as College_Count FROM match_season GROUP BY College ORDER BY College_Count DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of match seasons along with the players participating in those seasons and their corresponding country names. The data is retrieved by joining the 'country' table with the 'match_season' table based on the country identifier, allowing us to associate each player with their respective country during a specific season.\",\n        \"virtual_table\": \"SELECT T2.Season ,  T2.Player ,  T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country\"\n    }\n}\n"}
{"sample_id": "train.1099", "db_id": "match_season", "question": "What are the three colleges from which the most players are from?", "rationale": ["Identify the relevant table: The 'match_season' table contains the 'College' column and player information.", "We need to count the number of players from each college, so we will use the COUNT() function.", "Group the results by 'College' to aggregate the player counts for each college.", "Order the results in descending order based on the player count to get the colleges with the most players at the top.", "Limit the results to the top three colleges using LIMIT 3."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as Player_Count \nFROM match_season \nGROUP BY College \nORDER BY Player_Count DESC \nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.1107", "db_id": "match_season", "question": "Return the names of countries that have players that play the Forward position, as well as players who play the Defender position.", "rationale": ["Identify the tables needed: We need data from the 'country' and 'match_season' tables.", "We want to return the names of countries, so we will select 'Country_name' from the 'country' table.", "We need to join the 'country' table with the 'match_season' table on the 'Country_id' and 'Country' columns respectively.", "We are interested in players who play either the 'Forward' or 'Defender' position, so we will use a WHERE clause with an IN condition to filter for these positions.", "Finally, we will use DISTINCT to ensure that we only get unique country names in the result."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "pred_sql": "SELECT DISTINCT C.Country_name FROM country AS C JOIN match_season AS MS ON C.Country_id = MS.Country WHERE MS.Position IN ('Forward', 'Defender')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct official native languages of countries represented by players in a specific position during matches. The placeholder in the WHERE clause represents the player's position.\",\n        \"virtual_table\": \"SELECT count(DISTINCT T1.Official_native_language) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1109", "db_id": "match_season", "question": "Return the colleges that have players who play the Midfielder position, as well as players who play the Defender position.", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players, their positions, and the colleges they attended.", "Determine the required positions: We need to filter players who play as 'Midfielder' or 'Defender'.", "Use the SELECT statement to retrieve the 'College' column from the 'match_season' table.", "Apply a WHERE clause to filter the results based on the specified positions using the IN operator.", "Use DISTINCT to ensure that each college is listed only once in the results."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "pred_sql": "SELECT DISTINCT College \nFROM match_season \nWHERE Position IN ('Midfielder', 'Defender');", "hint": "\n"}
{"sample_id": "train.1222", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with type code \"Duplex\"?", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for apartment type.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to link bookings to their respective apartments.", "Filter the results to only include apartments with the type code 'Duplex'.", "Select the booking_start_date and booking_end_date from the filtered results."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  'Duplex'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartment_Bookings ab \nJOIN Apartments a ON ab.apt_id = a.apt_id \nWHERE a.apt_type_code = 'Duplex';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1224", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with more than 2 bedrooms?", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to access both booking dates and bedroom count.", "Filter the results to include only those apartments that have more than 2 bedrooms by using a WHERE clause."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartment_Bookings ab \nJOIN Apartments a ON ab.apt_id = a.apt_id \nWHERE a.bedroom_count > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1225", "db_id": "apartment_rentals", "question": "Find the booking start date and end date for the apartments that have more than two bedrooms.", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "We need to select the booking start and end dates, which are in the Apartment_Bookings table.", "To filter apartments with more than two bedrooms, we will join the Apartments table on the apt_id from Apartment_Bookings and apply a WHERE clause for bedroom_count > 2."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartment_Bookings ab \nJOIN Apartments a ON ab.apt_id = a.apt_id \nWHERE a.bedroom_count > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1229", "db_id": "apartment_rentals", "question": "Which apartments have bookings with status code \"Confirmed\"? Return their apartment numbers.", "rationale": ["Identify the relevant tables: Apartments and Apartment_Bookings.", "We need to find apartments that have bookings with a specific status code, which is 'Confirmed'.", "Join the Apartments table with the Apartment_Bookings table on the apt_id to link apartments with their bookings.", "Filter the results to include only those bookings where the booking_status_code is 'Confirmed'.", "Select the apt_number from the filtered results to return the apartment numbers."], "gold_sql": "SELECT DISTINCT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  'Confirmed'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT a.apt_number \nFROM Apartments a \nJOIN Apartment_Bookings ab ON a.apt_id = ab.apt_id \nWHERE ab.booking_status_code = 'Confirmed';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1232", "db_id": "apartment_rentals", "question": "Show the guest first names, start dates, and end dates of all the apartment bookings.", "rationale": ["Identify the required fields: guest first names, booking start dates, and booking end dates.", "Determine the relevant tables: 'Apartment_Bookings' for booking details and 'Guests' for guest information.", "Establish the relationship between the tables: 'Apartment_Bookings' links to 'Guests' through the guest_id.", "Construct the SQL query to select the desired fields from the joined tables."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT Guests.guest_first_name, Apartment_Bookings.booking_start_date, Apartment_Bookings.booking_end_date\nFROM Apartment_Bookings\nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1234", "db_id": "apartment_rentals", "question": "Show the start dates and end dates of all the apartment bookings made by guests with gender code \"Female\".", "rationale": ["Identify the relevant tables: Apartment_Bookings and Guests are needed to get booking dates and guest information.", "Determine the columns needed: booking_start_date and booking_end_date from Apartment_Bookings.", "Establish the relationship between tables: Join Apartment_Bookings with Guests on guest_id to filter by gender.", "Apply the filter: Use a WHERE clause to select only those records where gender_code is 'Female'."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT Apartment_Bookings.booking_start_date, Apartment_Bookings.booking_end_date \nFROM Apartment_Bookings \nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id \nWHERE Guests.gender_code = 'Female';", "hint": "\n"}
{"sample_id": "train.1238", "db_id": "apartment_rentals", "question": "Show the facility codes of apartments with more than 4 bedrooms.", "rationale": ["Identify the relevant tables: We need to look at the 'Apartments' table for bedroom counts and the 'Apartment_Facilities' table for facility codes.", "Join the 'Apartments' table with the 'Apartment_Facilities' table on the 'apt_id' to link apartments with their facilities.", "Filter the results to include only those apartments that have more than 4 bedrooms by using a WHERE clause.", "Select the distinct facility codes from the joined tables to avoid duplicates."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "pred_sql": "SELECT DISTINCT af.facility_code \nFROM Apartments a \nJOIN Apartment_Facilities af ON a.apt_id = af.apt_id \nWHERE a.bedroom_count > 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1256", "db_id": "apartment_rentals", "question": "Show the top 3 apartment type codes sorted by the average number of rooms in descending order.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of rooms.", "Group the results by apartment type code: This allows us to calculate the average number of rooms for each type.", "Calculate the average number of rooms: Use the AVG function on the room_count column to get the average for each type code.", "Sort the results in descending order: This will show the apartment types with the most rooms on average at the top.", "Limit the results to the top 3: Use the LIMIT clause to restrict the output to the top 3 apartment type codes."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1258", "db_id": "apartment_rentals", "question": "Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.", "rationale": ["Identify the relevant columns needed: apt_type_code, bathroom_count, and bedroom_count from the Apartments table.", "To find the apartment type code with the largest number of total rooms, we need to use a subquery to determine the maximum room count.", "The subquery will select the maximum room_count from the Apartments table.", "The main query will select the apt_type_code, bathroom_count, and bedroom_count from the Apartments table where the room_count matches the maximum room_count found in the subquery."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, bathroom_count, bedroom_count FROM Apartments WHERE room_count = (SELECT MAX(room_count) FROM Apartments)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1261", "db_id": "apartment_rentals", "question": "Which apartment type code appears the most often?", "rationale": ["Identify the relevant table: The Apartments table contains the apt_type_code which we need to analyze.", "Count the occurrences of each apartment type code: We will use COUNT(*) to count how many times each apt_type_code appears.", "Group the results by apt_type_code: This is done using GROUP BY apt_type_code to aggregate the counts for each type code.", "Order the results by the count in descending order: This allows us to see which apartment type code appears the most often.", "Limit the results to 1: We only need the most frequent apartment type code, so we use LIMIT 1."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, COUNT(*) as type_count FROM Apartments GROUP BY apt_type_code ORDER BY type_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1262", "db_id": "apartment_rentals", "question": "Show the most common apartment type code among apartments with more than 1 bathroom.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of bathrooms.", "Filter apartments: We need to filter apartments that have more than 1 bathroom, which can be done using a WHERE clause.", "Group by apartment type: To find the most common apartment type code, we will group the results by apt_type_code.", "Count occurrences: We will count the number of occurrences of each apartment type code using COUNT(*) to determine which is the most common.", "Order the results: We will order the results in descending order based on the count to get the most common type at the top.", "Limit the results: Finally, we will limit the results to 1 to get only the most common apartment type code."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count > 1 GROUP BY apt_type_code ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1272", "db_id": "apartment_rentals", "question": "Show the apartment numbers of apartments with unit status availability of both 0 and 1.", "rationale": ["Identify the relevant tables: Apartments and View_Unit_Status.", "We need to retrieve apartment numbers, so we will select 'apt_number' from the Apartments table.", "To check the availability status, we will join the Apartments table with the View_Unit_Status table on 'apt_id'.", "We need to filter the results to include only those apartments that have an availability status of either '0' or '1'.", "Construct the SQL query using the SELECT statement, JOIN clause, and WHERE condition."], "gold_sql": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1", "source_tables": ["view_unit_status", "apartments"], "pred_sql": "SELECT apt_number FROM Apartments a JOIN View_Unit_Status vus ON a.apt_id = vus.apt_id WHERE vus.available_yn IN ('0', '1');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the different types of apartments available in the 'Apartments' table, grouped by their type code. The results are ordered by the average number of rooms in each apartment type, allowing users to see which types of apartments have more rooms on average. The placeholder in the LIMIT clause represents the maximum number of apartment types to return.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1294", "db_id": "soccer_1", "question": "How many leagues are there in England?", "rationale": ["Identify the relevant table: The question pertains to leagues, so we will use the 'League' table.", "Determine the condition: We need to count the leagues specifically in England.", "Construct the SQL query: Use the COUNT function to count the number of records in the 'League' table where the name is 'England'."], "gold_sql": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  'England'", "source_tables": ["country", "league"], "pred_sql": "SELECT COUNT(*) AS league_count FROM League WHERE name = 'England';", "hint": "\n"}
{"sample_id": "train.1303", "db_id": "soccer_1", "question": "List all of the player ids with a height of at least 180cm and an overall rating higher than 85.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "Determine the conditions: height >= 180cm and overall_rating > 85.", "Use the Player table to filter players based on height.", "Use a subquery on Player_Attributes to filter players based on overall rating.", "Combine the results to get player ids that meet both conditions."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE overall_rating  >  85", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT player_api_id FROM Player WHERE height >= 180 AND player_api_id IN (SELECT player_api_id FROM Player_Attributes WHERE overall_rating > 85)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of players from the 'Player' table who have an overall skill rating higher than the average overall rating of all players recorded in the 'Player_Attributes' table. The query uses a subquery to calculate the average overall rating and filters the results accordingly.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.overall_rating  >  ( SELECT avg(overall_rating) FROM Player_Attributes )\"\n    }\n}\n"}
{"sample_id": "train.1304", "db_id": "soccer_1", "question": "List all of the ids for left-footed players with a height between 180cm and 190cm.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to filter players based on their preferred foot, which is in the Player_Attributes table.", "We also need to filter players based on their height, which is in the Player table.", "Join the Player table with the Player_Attributes table using the player_api_id as the common key.", "Select the id of players who are left-footed and have a height between 180cm and 190cm."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 AND height  <=  190 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE preferred_foot  =  'left'", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT P.id FROM Player AS P JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE PA.preferred_foot = 'left' AND P.height BETWEEN 180 AND 190;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have the highest overall skill rating recorded in the 'Player_Attributes' table. The query joins the 'Player' and 'Player_Attributes' tables based on the player's API identifier and filters the results to only include players whose dribbling attribute matches the maximum overall rating found in the 'Player_Attributes' table.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.dribbling  =  ( SELECT max(overall_rating) FROM Player_Attributes)\"\n    }\n}\n"}
{"sample_id": "train.1306", "db_id": "soccer_1", "question": "List the names and birthdays of the top five players in terms of potential.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to retrieve player names and birthdays, so we will select 'player_name' and 'birthday' from the Player table.", "To find the top five players in terms of potential, we will need to order the Player_Attributes table by the 'potential' column in descending order.", "We will limit the results to the top five players using 'LIMIT 5'.", "We will use a subquery to get the 'player_api_id' of these top five players based on their potential.", "Finally, we will join the results of the subquery with the Player table to get the names and birthdays of these players."], "gold_sql": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT 5", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT player_name, birthday FROM Player WHERE player_api_id IN (SELECT player_api_id FROM Player_Attributes ORDER BY potential DESC LIMIT 5)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have the highest overall skill rating recorded in the 'Player_Attributes' table. The query joins the 'Player' and 'Player_Attributes' tables based on the player's API identifier and filters the results to only include players whose dribbling attribute matches the maximum overall rating found in the 'Player_Attributes' table.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.dribbling  =  ( SELECT max(overall_rating) FROM Player_Attributes)\"\n    }\n}\n"}
{"sample_id": "train.1511", "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["To find the most frequently used policy type, we need to count the occurrences of each Policy_Type_Code in the Policies table.", "We will use the COUNT() function to count how many times each Policy_Type_Code appears.", "We will group the results by Policy_Type_Code to aggregate the counts for each type.", "To determine which policy type is the most frequent, we will order the results in descending order based on the count.", "Finally, we will limit the results to only the top entry to get the most frequently used policy type."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(*) as Frequency\nFROM Policies\nGROUP BY Policy_Type_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\",\n        \"virtual_table\": \"SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)\"\n    }\n}\n"}
{"sample_id": "train.1513", "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["Identify the relevant table: The 'Policies' table contains the 'Policy_Type_Code' and 'Customer_ID' which are needed to find the policy types used by customers.", "Group the results by 'Policy_Type_Code': This allows us to count how many distinct customers are associated with each policy type.", "Use the HAVING clause: This clause filters the grouped results to only include those policy types that have more than 2 distinct customers associated with them."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code FROM Policies GROUP BY Policy_Type_Code HAVING COUNT(DISTINCT Customer_ID) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\",\n        \"virtual_table\": \"SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)\"\n    }\n}\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["Identify the relevant table: The 'Claim_Headers' table contains the 'Amount_Piad' column which is needed for the calculations.", "Determine the required calculations: We need to calculate the total amount paid and the average amount paid.", "Use aggregate functions: Use SUM() to calculate the total amount and AVG() to calculate the average amount.", "Construct the SQL query: Combine the aggregate functions in a SELECT statement from the 'Claim_Headers' table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Piad) AS Total_Amount_Paid, AVG(Amount_Piad) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1518", "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["Identify the relevant tables: Claim_Headers and Claims_Documents are needed to find the total amount claimed in the most recently created document.", "We need to sum the Amount_Claimed from the Claim_Headers table.", "To find the most recently created document, we will use a subquery to get the maximum Created_Date from the Claims_Documents table.", "Join Claim_Headers with Claims_Documents on Claim_Header_ID and Claim_ID to link claims with their documents.", "Filter the results to only include claims associated with the most recently created document by using the subquery result in the WHERE clause."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT SUM(ch.Amount_Claimed) AS Total_Claimed\nFROM Claim_Headers AS ch\nJOIN Claims_Documents AS cd ON ch.Claim_Header_ID = cd.Claim_ID\nWHERE cd.Created_Date = (SELECT MAX(Created_Date) FROM Claims_Documents)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Claim_Headers for claims, Policies for linking claims to customers, and Customers for customer details.", "Join the Claim_Headers table with the Policies table on Policy_ID to link claims to their respective policies.", "Join the resulting table with the Customers table on Customer_ID to retrieve customer details.", "Use a subquery to find the maximum amount claimed from the Claim_Headers table.", "Filter the results to get the customer details where the Amount_Claimed matches the maximum amount found in the subquery."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT t3.Customer_Details FROM Claim_Headers AS t1 JOIN Policies AS t2 ON t1.Policy_ID = t2.Policy_ID JOIN Customers AS t3 ON t2.Customer_ID = t3.Customer_ID WHERE t1.Amount_Claimed = (SELECT max(Amount_Claimed) FROM Claim_Headers)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1521", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the minimum amount of payment in one claim?", "rationale": ["Identify the relevant tables: Claim_Headers, Policies, and Customers are needed to find the customer associated with the minimum payment claim.", "Join Claim_Headers with Policies on Policy_ID to link claims to their respective policies.", "Join the resulting table with Customers on Customer_ID to retrieve customer details.", "Use a subquery to find the minimum Amount_Paid from the Claim_Headers table.", "Filter the main query to only include the claim that has the minimum Amount_Paid, and select the Customer_Details from the Customers table."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT t3.Customer_Details FROM Claim_Headers AS t1 JOIN Policies AS t2 ON t1.Policy_ID = t2.Policy_ID JOIN Customers AS t3 ON t2.Customer_ID = t3.Customer_ID WHERE t1.Amount_Paid = (SELECT min(Amount_Paid) FROM Claim_Headers)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers associated with the claim that has the minimum amount paid. It joins the 'Claim_Headers' table with the 'Policies' table to link claims to policies, and then joins with the 'Customers' table to get customer details. The query filters for the claim with the lowest amount paid using a subquery.\",\n        \"virtual_table\": \"SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)\"\n    }\n}\n"}
{"sample_id": "train.1531", "db_id": "insurance_and_eClaims", "question": "Find the names of the customers who have an deputy policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between the tables: Policies has a foreign key linking to Customers via Customer_ID.", "Filter the Policies table for those with a Policy_Type_Code that indicates a deputy policy.", "Select the Customer_Details from the Customers table for those filtered policies."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT t2.Customer_Details FROM Policies AS t1 JOIN Customers AS t2 ON t1.Customer_ID = t2.Customer_ID WHERE t1.Policy_Type_Code = 'deputy'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\",\n        \"virtual_table\": \"SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)\"\n    }\n}\n"}
{"sample_id": "train.1533", "db_id": "insurance_and_eClaims", "question": "Find the names of customers who either have an deputy policy or uniformed policy.", "rationale": ["Identify the tables needed: Customers and Policies.", "We need to retrieve customer names, which are in the Customers table under the column Customer_Details.", "We need to filter policies based on their type, specifically looking for 'deputy' or 'uniformed' policies.", "Join the Customers table with the Policies table on the Customer_ID to link customers with their policies.", "Use a WHERE clause to filter the results to only include policies with the specified types ('deputy' or 'uniformed').", "Select distinct customer details to avoid duplicates in the results."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT DISTINCT c.Customer_Details \nFROM Customers c \nJOIN Policies p ON c.Customer_ID = p.Customer_ID \nWHERE p.Policy_Type_Code IN ('deputy', 'uniformed')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\",\n        \"virtual_table\": \"SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)\"\n    }\n}\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find the customer associated with the most recently started policy, so we will join the Customers table with the Policies table on Customer_ID.", "To find the most recent policy, we will use a subquery to get the maximum Start_Date from the Policies table.", "The main query will select the Customer_Details from the Customers table where the Start_Date matches the maximum Start_Date found in the subquery."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT t2.Customer_Details FROM Policies AS t1 JOIN Customers AS t2 ON t1.Customer_ID = t2.Customer_ID WHERE t1.Start_Date = (SELECT max(Start_Date) FROM Policies)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed information about customers from the 'Customers' table who have the most recently started insurance policy from the 'Policies' table. The query uses a subquery to find the maximum start date of policies, ensuring that only the latest policy is considered.\",\n        \"virtual_table\": \"SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)\"\n    }\n}\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "Determine the columns needed: account_id, account_name, and other_account_details from Accounts.", "Establish the relationship between Accounts and Customers using the customer_id foreign key.", "Filter the results to include only those accounts associated with the customer whose first name is 'Meaghan'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_id, Accounts.account_name, Accounts.other_account_details \nFROM Accounts \nJOIN Customers ON Accounts.customer_id = Customers.customer_id \nWHERE Customers.customer_first_name = 'Meaghan';", "hint": "\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to retrieve account details for a specific customer, so we will join the Customers table with the Accounts table using the customer_id.", "Filter the results to only include the customer named 'Meaghan Keeling' by checking both the first and last name in the WHERE clause.", "Select the desired columns: account_name and other_account_details from the Accounts table."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT Accounts.account_name, Accounts.other_account_details \nFROM Customers \nJOIN Accounts ON Customers.customer_id = Accounts.customer_id \nWHERE Customers.customer_first_name = 'Meaghan' AND Customers.customer_last_name = 'Keeling';", "hint": "\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "Determine the columns needed: full names (first and last) from Customers and account name from Accounts.", "Join the Customers table with the Accounts table on the customer_id field to link customers with their accounts.", "Filter the results to include only those accounts with the name '900'.", "Select the concatenated first and last names as the full name."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name || ' ' || customer_last_name AS full_name\nFROM Customers\nJOIN Accounts ON Customers.customer_id = Accounts.customer_id\nWHERE Accounts.account_name = '900';", "hint": "\n"}
{"sample_id": "train.1568", "db_id": "customers_and_invoices", "question": "Return the id and full name of the customer with the most accounts.", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to join these tables on the customer_id to link customers with their accounts.", "We will group the results by customer_id to count the number of accounts each customer has.", "We will order the results by the count of accounts in descending order to find the customer with the most accounts.", "Finally, we will limit the results to 1 to get only the top customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT c.customer_id, c.customer_first_name || ' ' || c.customer_last_name AS full_name\nFROM Customers c\nJOIN Accounts a ON c.customer_id = a.customer_id\nGROUP BY c.customer_id\nORDER BY COUNT(a.account_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1579", "db_id": "customers_and_invoices", "question": "How many transaction does each account have? Show the number and account id.", "rationale": ["Identify the relevant table: Financial_Transactions contains the account_id and transaction details.", "Use the COUNT() function to count the number of transactions for each account.", "Group the results by account_id to get the count for each account."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT account_id, COUNT(*) AS transaction_count FROM Financial_Transactions GROUP BY account_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\",\n        \"virtual_table\": \"SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id\"\n    }\n}\n"}
{"sample_id": "train.1589", "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["We need to select the account name and account id from the Accounts table.", "We also need to count the number of transactions for each account, which is stored in the Financial_Transactions table.", "To get the number of transactions per account, we will perform a LEFT JOIN between the Accounts table and the Financial_Transactions table on the account_id.", "We will use the COUNT function to count the transaction_id from the Financial_Transactions table, grouping by account_id and account_name to ensure we get the correct count for each account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "pred_sql": "SELECT a.account_name, a.account_id, COUNT(ft.transaction_id) AS number_of_transactions\nFROM Accounts a\nLEFT JOIN Financial_Transactions ft ON a.account_id = ft.account_id\nGROUP BY a.account_id, a.account_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\",\n        \"virtual_table\": \"SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id\"\n    }\n}\n"}
{"sample_id": "train.1599", "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["We need to show the invoice number and the number of transactions for each invoice.", "The 'Financial_Transactions' table contains the 'invoice_number' and 'transaction_id' which we can use to count the number of transactions per invoice.", "We will use the COUNT function to count the number of transactions grouped by 'invoice_number'.", "The final SQL query will select the 'invoice_number' and the count of 'transaction_id' as 'number_of_transactions' from the 'Financial_Transactions' table, grouping the results by 'invoice_number'."], "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"], "pred_sql": "SELECT invoice_number, COUNT(transaction_id) AS number_of_transactions \nFROM Financial_Transactions \nGROUP BY invoice_number;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\",\n        \"virtual_table\": \"SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id\"\n    }\n}\n"}
{"sample_id": "train.1602", "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["We need to find the invoice number and invoice date for the invoice with the greatest number of transactions.", "To do this, we first need to identify which order has the greatest number of invoices. We can achieve this by grouping the invoices by order_id and counting the number of invoices for each order.", "The subquery `SELECT order_id FROM Invoices GROUP BY order_id ORDER BY COUNT(*) DESC LIMIT 1` will give us the order_id with the highest count of invoices.", "Once we have the order_id, we can then select the corresponding invoice_number and invoice_date from the Invoices table where the order_id matches the one we found in the subquery."], "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"], "pred_sql": "SELECT invoice_number, invoice_date \nFROM Invoices \nWHERE order_id = (\n    SELECT order_id \n    FROM Invoices \n    GROUP BY order_id \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\",\n        \"virtual_table\": \"SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id\"\n    }\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["We need to show the order ids and the number of items in each order.", "To achieve this, we will use the Orders table to get the order ids.", "We will join the Order_Items table to count the number of items associated with each order.", "The COUNT function will be used to count the number of order items for each order id.", "Finally, we will group the results by order_id to get the count for each individual order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT Orders.order_id, COUNT(Order_Items.order_item_id) AS number_of_items\nFROM Orders\nJOIN Order_Items ON Orders.order_id = Order_Items.order_id\nGROUP BY Orders.order_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices associated with each order from the 'Invoices' table. The placeholder in the SELECT clause represents the unique identifier for each order, while the count function aggregates the number of invoices per order.\",\n        \"virtual_table\": \"SELECT order_id ,  count(*) FROM Invoices GROUP BY order_id\"\n    }\n}\n"}
{"sample_id": "train.2049", "db_id": "party_people", "question": "Show all ministers who do not belong to Progress Party.", "rationale": ["Identify the tables involved: We need to get information about ministers and their associated parties, so we will use the 'member' and 'party' tables.", "We need to select the names of members (ministers) who do not belong to the 'Progress Party'.", "To do this, we will join the 'member' table with the 'party' table on the 'Party_ID' column, which is the foreign key in the 'member' table that references the 'party' table.", "We will use a SELECT statement to get distinct member names from the 'member' table.", "We will apply a WHERE clause to filter out members whose associated party name is 'Progress Party'."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT DISTINCT m.Member_Name \nFROM member m \nJOIN party p ON m.Party_ID = p.Party_ID \nWHERE p.Party_name != 'Progress Party';", "hint": "\n"}
{"sample_id": "train.2058", "db_id": "party_people", "question": "How many members are in each party?", "rationale": ["Identify the tables needed: We need the 'party' table to get party names and the 'member' table to count the members in each party.", "Join the 'party' table with the 'member' table on the Party_ID to associate members with their respective parties.", "Use COUNT() function to count the number of members for each party.", "Group the results by party name to get the count of members for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT p.Party_name, COUNT(m.Member_ID) AS Member_Count \nFROM party AS p \nLEFT JOIN member AS m ON p.Party_ID = m.Party_ID \nGROUP BY p.Party_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of party events associated with a specific region and event name. It joins the 'region', 'party', and 'party_events' tables to filter the results based on the specified region name and event name. The placeholders in the WHERE clause represent the region's name and the event's name.\",\n        \"virtual_table\": \"SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2071", "db_id": "party_people", "question": "Show party names and the number of events for each party.", "rationale": ["Identify the tables needed: We need the 'party' table to get party names and the 'party_events' table to count the events.", "Determine the relationship: The 'party' table is related to the 'party_events' table through the 'Party_ID'.", "Use a LEFT JOIN to include all parties even if they have no events.", "Count the number of events for each party using COUNT(party_events.Event_ID).", "Group the results by party name to get the count for each party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT party.Party_name, COUNT(party_events.Event_ID) AS Number_of_Events \nFROM party \nLEFT JOIN party_events ON party.Party_ID = party_events.Party_ID \nGROUP BY party.Party_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of party events associated with a specific region and event name. It joins the 'region', 'party', and 'party_events' tables to filter the results based on the specified region name and event name. The placeholders in the WHERE clause represent the region's name and the event's name.\",\n        \"virtual_table\": \"SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the tables involved: region, party, and party_events.", "Determine the relationship between the tables: region is linked to party via Region_ID, and party is linked to party_events via Party_ID.", "Filter the results based on the region name 'United Kingdom' and the event name 'Annual Meeting'.", "Use the count function to get the total number of events that match the criteria."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.Region_ID = t2.Region_ID JOIN party_events AS t3 ON t2.Party_ID = t3.Party_ID WHERE t1.Region_name = 'United Kingdom' AND t3.Event_Name = 'Annual Meeting'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of party events associated with a specific region and event name. It joins the 'region', 'party', and 'party_events' tables to filter the results based on the specified region name and event name. The placeholders in the WHERE clause represent the region's name and the event's name.\",\n        \"virtual_table\": \"SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.Event_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["Identify the tables needed: races, results, and drivers.", "We need to find races that had a driver with the last name 'Lewis'.", "Join the races table with the results table on raceId to link races with their results.", "Join the results table with the drivers table on driverId to link results with the drivers.", "Filter the results to only include those where the driver's surname is 'Lewis'.", "Select the names and years of the races from the races table."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "pred_sql": "SELECT races.name, races.year FROM races JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE drivers.surname = 'Lewis';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["We need to find the first and last names of drivers who participated in the Australian Grand Prix but not in the Chinese Grand Prix.", "First, we will select the drivers who participated in the Australian Grand Prix by joining the 'drivers' table with the 'results' table and then with the 'races' table to filter by the race name 'Australian Grand Prix'.", "Next, we will use a subquery to find the drivers who participated in the Chinese Grand Prix by joining the same tables but filtering for 'Chinese Grand Prix'.", "We will use the NOT IN clause to exclude the drivers found in the subquery from the list of drivers who participated in the Australian Grand Prix.", "Finally, we will select distinct first names and surnames of the remaining drivers."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT DISTINCT d.forename, d.surname \nFROM drivers d \nJOIN results r1 ON d.driverId = r1.driverId \nJOIN races ra ON r1.raceId = ra.raceId \nWHERE ra.name = 'Australian Grand Prix' \nAND d.driverId NOT IN (\n    SELECT d2.driverId \n    FROM drivers d2 \n    JOIN results r2 ON d2.driverId = r2.driverId \n    JOIN races rb ON r2.raceId = rb.raceId \n    WHERE rb.name = 'Chinese Grand Prix'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2183", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who was in position 1 as standing and won?", "rationale": ["Identify the tables needed: 'drivers' for driver information and 'driverStandings' for standings and wins.", "We need to select distinct forenames of drivers, so we will use SELECT DISTINCT on the 'forename' column from the 'drivers' table.", "To filter the results, we will join the 'drivers' table with the 'driverStandings' table on the 'driverId' column.", "We need to apply conditions: the position must be 1 and the number of wins must be greater than 0.", "Construct the SQL query using the identified columns and conditions."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverStandings AS T2 ON T1.driverId = T2.driverId WHERE T2.position = 1 AND T2.wins > 0", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["Identify the relevant tables: 'drivers' for driver information and 'driverStandings' for standings details.", "We need to select distinct forenames of drivers, so we will use SELECT DISTINCT on the 'forename' column from the 'drivers' table.", "To filter the results, we will join the 'drivers' table with the 'driverStandings' table on the 'driverId' column.", "We need to apply two conditions: the driver's position must be 1 (indicating they won) and they must have more than 20 points.", "The final SQL query will combine these elements to retrieve the desired information."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverStandings AS T2 ON T1.driverId = T2.driverId WHERE T2.position = 1 AND T2.points > 20", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2186", "db_id": "formula_1", "question": "What are the first names of the different drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["Identify the relevant tables: 'drivers' for driver information and 'driverStandings' for standings data.", "We need to find distinct first names of drivers who won (position 1) and have more than 20 points.", "Use a JOIN between 'drivers' and 'driverStandings' on the driverId to combine the necessary information.", "Filter the results where the position is 1 and points are greater than 20.", "Select the distinct first names from the resulting dataset."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverStandings AS T2 ON T1.driverId = T2.driverId WHERE T2.position = 1 AND T2.points > 20", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["The question asks for the number of races for each constructor id.", "To find this information, we need to count the number of races associated with each constructor.", "The relevant table for this information is the 'results' table, which contains the 'constructorId' and 'raceId'.", "We will use the COUNT() function to count the occurrences of 'raceId' for each 'constructorId'.", "We will group the results by 'constructorId' to get the count for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(raceId) AS number_of_races \nFROM results \nGROUP BY constructorId;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the official names of constructors from the 'constructors' table who are from a specific nationality and have scored more points than a specified threshold in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.\",\n        \"virtual_table\": \"SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = [PLACEHOLDER-TYPE:STRING] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant tables: 'constructors' for constructor information and 'constructorStandings' for points earned.", "Join the 'constructors' table with the 'constructorStandings' table on the 'constructorId' to link constructors with their standings.", "Filter the results to include only those constructors whose nationality is 'Japanese'.", "Further filter the results to include only those constructors who have earned more than 5 points.", "Select the 'name' of the constructors that meet these criteria."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorStandings AS T2 ON T1.constructorId = T2.constructorId WHERE T1.nationality = 'Japanese' AND T2.points > 5", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the official names of constructors from the 'constructors' table who are from a specific nationality and have scored more points than a specified threshold in the constructor standings. The placeholders in the WHERE clause represent the constructor's nationality and the points threshold.\",\n        \"virtual_table\": \"SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = [PLACEHOLDER-TYPE:STRING] AND T2.points > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, lapTimes, and circuits are needed to find the average fastest lap speed for a specific race.", "We need to join the races table with the lapTimes table to access the fastest lap speed data for each race.", "We also need to join the circuits table to filter the races specifically for the Monaco Grand Prix.", "The WHERE clause will filter for the circuit name 'Monaco' and the year 2008 to get the correct race.", "Finally, we will use the AVG() function to calculate the average of the fastest lap speeds from the lapTimes table."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(lapTimes.fastestLapSpeed) AS average_fastest_lap_speed \nFROM races \nJOIN lapTimes ON races.raceId = lapTimes.raceId \nJOIN circuits ON races.circuitId = circuits.circuitId \nWHERE circuits.name = 'Monaco' AND races.year = 2008;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2221", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["Identify the relevant tables: We need data from the 'lapTimes', 'results', and 'races' tables to find the maximum fastest lap speed for a specific race.", "Join the tables: We will join 'lapTimes' with 'results' on raceId and driverId to get the fastest lap speeds associated with the race results.", "Filter the results: We will filter the races to only include those named 'Monaco Grand Prix' that occurred in the year 2008.", "Select the maximum fastest lap speed: We will use the MAX function to get the highest fastest lap speed from the filtered results."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(fastestLapSpeed) AS max_fastest_lap_speed \nFROM lapTimes AS LT \nJOIN results AS R ON LT.raceId = R.raceId AND LT.driverId = R.driverId \nJOIN races AS RA ON R.raceId = RA.raceId \nWHERE RA.name = 'Monaco Grand Prix' AND RA.year = 2008;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: races, lapTimes, and circuits are needed to find the fastest lap speed for the Monaco Grand Prix in 2008.", "We need to filter the races table to find the race that corresponds to the Monaco Grand Prix in 2008. This can be done by checking the circuit name and the year.", "Join the races table with the lapTimes table to access the fastest lap speed data for the races.", "Join the circuits table to ensure we are only looking at the Monaco Grand Prix.", "Use the MAX function to find the maximum fastest lap speed from the filtered results."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT MAX(lapTimes.fastestLapSpeed) AS max_fastest_lap_speed \nFROM races \nJOIN lapTimes ON races.raceId = lapTimes.raceId \nJOIN circuits ON races.circuitId = circuits.circuitId \nWHERE circuits.name = 'Monaco' \nAND races.year = 2008;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first names of drivers from the 'drivers' table who have achieved a specific position in the standings and have a certain number of wins. The placeholders in the WHERE clause represent the desired position and the number of wins.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = [PLACEHOLDER-TYPE:NUMBER] AND T2.wins = [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get race names and fastest lap speeds.", "Join the races table with results to link each race to its results.", "Join the results table with lapTimes to access the fastest lap speeds for each driver in each race.", "Filter the races to include only those after the year 2004.", "Group the results by race name to calculate the maximum fastest lap speed for each race.", "Select the race name and the maximum fastest lap speed, ordering the results by year."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name, MAX(l.fastestLapSpeed) AS max_fastest_lap_speed\nFROM races AS r\nJOIN results AS res ON r.raceId = res.raceId\nJOIN lapTimes AS l ON res.raceId = l.raceId AND res.driverId = l.driverId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get race names and fastest lap speeds.", "Join the races table with the results table on raceId to link races with their results.", "Join the results table with the lapTimes table on raceId and driverId to get the fastest lap speeds for each race.", "Filter the results to include only races held after the year 2004 using a WHERE clause.", "Group the results by race name to calculate the average fastest lap speed for each race.", "Use the AVG function to calculate the average fastest lap speed for each race.", "Order the final results by year to get the races in chronological order."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.name, AVG(l.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races AS r\nJOIN results AS res ON r.raceId = res.raceId\nJOIN lapTimes AS l ON res.raceId = l.raceId AND res.driverId = l.driverId\nWHERE r.year > 2004\nGROUP BY r.name\nORDER BY r.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2226", "db_id": "formula_1", "question": "What is the average fastest lap speed for races held after 2004, for each race, ordered by year?", "rationale": ["Identify the relevant tables: races, results, and lapTimes are needed to get the race year, results, and fastest lap speed.", "Join the races table with the results table on raceId to link races with their results.", "Join the results table with the lapTimes table on raceId and driverId to get the fastest lap speed for each driver in each race.", "Filter the results to include only races held after the year 2004.", "Group the results by year to calculate the average fastest lap speed for each year.", "Order the final results by year to present the data in chronological order."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT r.year, AVG(l.fastestLapSpeed) AS average_fastest_lap_speed\nFROM races AS r\nJOIN results AS res ON r.raceId = res.raceId\nJOIN lapTimes AS l ON res.raceId = l.raceId AND res.driverId = l.driverId\nWHERE r.year > 2004\nGROUP BY r.year\nORDER BY r.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique race names from the 'races' table that were held at circuits located in a specific country and after a certain year. The placeholders in the WHERE clause represent the country name and the year threshold.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = [PLACEHOLDER-TYPE:STRING] AND T1.year > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2243", "db_id": "machine_repair", "question": "What is the starting year of the oldest technicians?", "rationale": ["Identify the relevant table: The 'technician' table contains the information about technicians including their starting year.", "Determine the required information: We need to find the starting year of the oldest technician.", "Use the MIN function: To find the oldest starting year, we can use the MIN function on the 'Starting_Year' column.", "Construct the SQL query: The SQL query will select the minimum starting year from the technician table."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT MIN(Starting_Year) AS Oldest_Technician_Starting_Year FROM technician;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of technicians who are assigned to repair tasks for machines that have a value point greater than a specified threshold. The placeholders in the WHERE clause represent the minimum value points for filtering the machines.\",\n        \"virtual_table\": \"SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID WHERE T2.value_points  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2248", "db_id": "machine_repair", "question": "What are the teams with the most technicians?", "rationale": ["Identify the relevant table: The 'technician' table contains information about technicians and their teams.", "Group by team: To find the number of technicians in each team, we need to group the results by the 'Team' column.", "Count technicians: Use the COUNT function to count the number of technicians in each team.", "Order by count: To find the teams with the most technicians, order the results in descending order based on the count of technicians.", "Limit the results: Although the hint suggests a limit, the question does not specify a number, so we will not include a LIMIT clause in the final query."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of technician teams from the 'technician' table, grouped by their team identifier. The results are ordered by the number of technicians in each team in descending order, and the placeholder allows for limiting the number of teams returned.\",\n        \"virtual_table\": \"SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2258", "db_id": "machine_repair", "question": "What are the names of the technicians  and how many machines are they assigned to repair?", "rationale": ["Identify the tables involved: We need to get technician names and the count of machines they are assigned to, which involves the 'technician' and 'repair_assignment' tables.", "Determine the necessary columns: We need the 'Name' from the 'technician' table and a count of 'Machine_ID' from the 'repair_assignment' table.", "Join the tables: We will join 'repair_assignment' with 'technician' on the technician ID to link repairs to technicians.", "Group the results: To get the count of machines per technician, we will group the results by technician name.", "Count the machines: Use the COUNT() function to count the number of machines assigned to each technician."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "pred_sql": "SELECT T3.Name, COUNT(T1.Machine_ID) AS Machine_Count \nFROM repair_assignment AS T1 \nJOIN technician AS T3 ON T1.technician_id = T3.technician_id \nGROUP BY T3.Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of technicians who are assigned to repair tasks for machines that have a value point greater than a specified threshold. The placeholders in the WHERE clause represent the minimum value points for filtering the machines.\",\n        \"virtual_table\": \"SELECT T3.Name FROM repair_assignment AS T1 JOIN machine AS T2 ON T1.machine_id  =  T2.machine_id JOIN technician AS T3 ON T1.technician_ID  =  T3.technician_ID WHERE T2.value_points  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2328", "db_id": "csu_1", "question": "Find all the campuses opened in 1958.", "rationale": ["Identify the relevant table: The 'Campuses' table contains the information about the campuses and their opening years.", "Determine the condition: We need to find campuses that were opened in the year 1958, which corresponds to the 'Year' column in the 'Campuses' table.", "Construct the SQL query: We will select the 'Campus' column from the 'Campuses' table where the 'Year' is '1958'."], "gold_sql": "SELECT campus FROM campuses WHERE YEAR  =  1958", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE Year = '1958';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2334", "db_id": "csu_1", "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "rationale": ["Identify the relevant table: The 'Campuses' table contains the information about campus names and their locations.", "Determine the filtering criteria: We need to find campuses located in either 'Northridge, Los Angeles' or 'San Francisco, San Francisco'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' column from the 'Campuses' table, applying a WHERE clause to filter based on the specified locations."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE (Location = 'Northridge, Los Angeles' OR Location = 'San Francisco, San Francisco')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2350", "db_id": "csu_1", "question": "Which campus has the most faculties in year 2003?", "rationale": ["Identify the relevant tables: 'Campuses' and 'faculty'.", "We need to find campuses with faculty data for the year 2003.", "Join the 'Campuses' table with the 'faculty' table on the campus identifier.", "Filter the results to only include records for the year 2003.", "Order the results by the number of faculty members in descending order to find the campus with the most faculty.", "Limit the results to 1 to get only the campus with the highest number of faculty."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T1.Campus FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus WHERE T2.Year = 2003 ORDER BY T2.Faculty DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2356", "db_id": "csu_1", "question": "report the total number of degrees granted between 1998 and 2002.", "rationale": ["Identify the relevant table: The 'degrees' table contains information about degrees awarded, including the year and the number of degrees.", "Determine the required data: We need to calculate the total number of degrees awarded between the years 1998 and 2002.", "Construct the SQL query: Use the SUM function to aggregate the number of degrees, and filter the results using a WHERE clause to include only the years 1998 to 2002."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(Degrees) AS TotalDegrees\nFROM degrees\nWHERE Year BETWEEN '1998' AND '2002';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: 'Campuses' and 'degrees'.", "We need to find the total number of degrees granted after the year 2000, so we will filter the 'degrees' table based on the 'Year' column.", "We also need to filter the campuses to only include those located in Orange County, which is done by checking the 'County' column in the 'Campuses' table.", "To get the total degrees for each campus, we will use a JOIN between 'Campuses' and 'degrees' on the campus identifier.", "We will group the results by campus to aggregate the total degrees awarded using the SUM function.", "Finally, we will select the campus name and the total degrees awarded for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT c.Campus, SUM(d.Degrees) AS TotalDegrees\nFROM Campuses c\nJOIN degrees d ON c.Id = d.Campus\nWHERE d.Year > '2000' AND c.County = 'Orange'\nGROUP BY c.Campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant tables: Campuses and enrollments.", "We need to find campuses with specific enrollment criteria for the year 1956.", "Join the Campuses table with the enrollments table on the campus identifier.", "Filter the results for the year 1956 and apply the conditions for total enrollment and full-time equivalent enrollment."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT C.Campus \nFROM Campuses AS C \nJOIN enrollments AS E ON C.Id = E.Campus \nWHERE E.Year = '1956' \nAND E.TotalEnrollment_AY > 400 \nAND E.FTE_AY > 200;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2363", "db_id": "csu_1", "question": "What campus started in year 1956, has more than 200 full time students, and more than 400 students enrolled?", "rationale": ["Identify the relevant tables: Campuses and enrollments are needed to answer the question.", "Join the Campuses table with the enrollments table on the campus identifier.", "Filter the results to include only campuses that started in the year 1956.", "Add conditions to ensure that the full-time equivalent (FTE) enrollments are greater than 200 and total enrollments are greater than 400."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT C.Campus \nFROM Campuses C \nJOIN enrollments E ON C.Id = E.Campus \nWHERE C.Year = '1956' \nAND E.FTE_AY > '200' \nAND E.TotalEnrollment_AY > '400';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2366", "db_id": "csu_1", "question": "List the campuses in Los Angeles county.", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about campuses, including their location and county.", "Determine the filtering criteria: We need to filter campuses based on the county, specifically 'Los Angeles'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' column from the 'Campuses' table where the 'County' is 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: 'degrees' for degrees conferred and 'Campuses' for campus names.", "We need to filter the degrees awarded in the year 2000 for 'San Jose State University'.", "Join the 'degrees' table with the 'Campuses' table on the campus identifier to access the campus name.", "Use the SUM function to calculate the total number of degrees conferred for the specified campus and year."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(Degrees) AS TotalDegrees\nFROM degrees\nJOIN Campuses ON degrees.Campus = Campuses.Id\nWHERE Campuses.Campus = 'San Jose State University' AND degrees.Year = '2000';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of campuses from the 'degrees' table, grouped by campus name and ordered by the total number of degrees awarded in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of campuses to return.\",\n        \"virtual_table\": \"SELECT campus FROM degrees GROUP BY campus ORDER BY sum(degrees) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2374", "db_id": "csu_1", "question": "What is the number of faculty lines in campus \"Long Beach State University\" in 2002?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "We need to count the number of faculty lines for a specific campus and year, so we will use the COUNT() function.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to filter by campus name.", "Add a WHERE clause to filter for 'Long Beach State University' and the year 2002."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2002 AND T2.campus  =  'Long Beach State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) AS NumberOfFacultyLines \nFROM faculty \nJOIN campuses ON faculty.Campus = campuses.Id \nWHERE campuses.Campus = 'Long Beach State University' AND faculty.Year = 2002;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2376", "db_id": "csu_1", "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to link faculty data with campus names.", "Filter the results to include only the campus named 'San Francisco State University' and the year 2004.", "Count the number of faculty lines (records) that meet the criteria."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) FROM faculty AS T1 JOIN Campuses AS T2 ON T1.Campus = T2.Id WHERE T2.Campus = 'San Francisco State University' AND T1.Year = 2004;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "We need to find the specific campus ID for 'San Francisco State University' from the 'Campuses' table.", "Use a subquery to get the ID of 'San Francisco State University'.", "Count the number of faculty lines in the 'faculty' table for the year 2004 where the campus matches the ID obtained from the subquery."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) FROM faculty WHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Francisco State University') AND Year = 2004;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2381", "db_id": "csu_1", "question": "How many faculty members did the university that conferred the most degrees in 2002 have?", "rationale": ["Identify the year of interest, which is 2002.", "We need to find the campus that conferred the most degrees in 2002, so we will join the 'degrees' table to get the number of degrees awarded.", "We also need to get the number of faculty members for the same year, so we will join the 'faculty' table.", "The 'campuses' table is used to link the campuses with their respective faculty and degrees data.", "We will order the results by the number of degrees in descending order to get the campus with the most degrees at the top.", "Finally, we will limit the results to 1 to get only the campus with the most degrees and select the number of faculty members from that campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT T2.Faculty FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus JOIN degrees AS T3 ON T1.Id = T3.Campus AND T2.Year = T3.Year WHERE T2.Year = 2002 ORDER BY T3.Degrees DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2382", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the least number of degrees in year 2001?", "rationale": ["Identify the year of interest, which is 2001.", "We need to find the campus that conferred the least number of degrees in 2001, so we will order the degrees in ascending order.", "Join the 'Campuses' table with the 'faculty' table to get the faculty data for each campus.", "Also, join the 'degrees' table to get the number of degrees awarded for each campus in 2001.", "Filter the results to only include records from the year 2001.", "Order the results by the number of degrees in ascending order to find the campus with the least degrees.", "Limit the results to 1 to get only the campus with the least degrees.", "Select the faculty count for that campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT T2.Faculty FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus JOIN degrees AS T3 ON T1.Id = T3.Campus AND T2.Year = T3.Year WHERE T2.Year = 2001 ORDER BY T3.Degrees ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the relevant tables: 'faculty' for faculty members and 'degrees' for the number of degrees awarded.", "Join the 'Campuses' table with 'faculty' and 'degrees' to correlate faculty data with the number of degrees awarded.", "Filter the results for the year 2001 in both the 'faculty' and 'degrees' tables.", "Order the results by the number of degrees awarded in ascending order to find the campus with the least degrees awarded.", "Limit the results to 1 to get only the campus with the least degrees awarded in 2001 and select the corresponding faculty count."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT T2.Faculty FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus JOIN degrees AS T3 ON T1.Id = T3.Campus WHERE T2.Year = 2001 AND T3.Year = 2001 ORDER BY T3.Degrees ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of faculty members from the 'faculty' table for each campus, filtered by a specific year. It joins the 'campuses' table to ensure that the faculty data corresponds to the correct campus and also joins the 'degrees' table to order the results based on the number of degrees awarded in descending order. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the year and the number of results to return.\",\n        \"virtual_table\": \"SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY t3.degrees DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "Determine the specific campus of interest, which is 'San Jose State'.", "Use a subquery to find the 'Id' of 'San Jose State' from the 'Campuses' table.", "Filter the 'discipline_enrollments' table by the campus 'Id' obtained from the subquery.", "Sum the 'Undergraduate' column to get the total number of undergraduates for 'San Jose State'."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT SUM(Undergraduate) AS TotalUndergraduates \nFROM discipline_enrollments \nWHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Jose State') \nGROUP BY Campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of campuses from the 'Campuses' table that have faculty data for a specific year. The results are ordered by the number of faculty members in descending order, and the number of campuses returned is limited by a placeholder value.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY T2.faculty DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2397", "db_id": "candidate_poll", "question": "Return the poll resource associated with the most candidates.", "rationale": ["Identify the relevant table: The 'candidate' table contains the 'Poll_Source' column which we need to analyze.", "Group by poll source: We need to group the results by 'Poll_Source' to count how many candidates are associated with each source.", "Count occurrences: Use the COUNT function to count the number of candidates for each poll source.", "Order by count: We want to order the results in descending order to get the poll source with the most candidates at the top.", "Limit the results: Since we only want the poll source associated with the most candidates, we will limit the results to 1."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of poll sources from the 'candidate' table, grouped by the source and ordered by the number of occurrences. The placeholder in the LIMIT clause allows the user to specify the maximum number of poll sources to retrieve.\",\n        \"virtual_table\": \"SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2405", "db_id": "candidate_poll", "question": "Return the poll source corresponding to the candidate who has the oppose rate.", "rationale": ["Identify the relevant table: The 'candidate' table contains the 'Poll_Source' and 'Oppose_rate' columns.", "Determine the condition: We need to find the poll source corresponding to candidates who have an oppose rate, which implies we need to check for non-null values in the 'Oppose_rate' column.", "Construct the SQL query: We will select the 'Poll_Source' from the 'candidate' table where 'Oppose_rate' is not null."], "gold_sql": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source FROM candidate WHERE Oppose_rate IS NOT NULL", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of poll sources from the 'candidate' table, grouped by the source and ordered by the number of occurrences. The placeholder in the LIMIT clause allows the user to specify the maximum number of poll sources to retrieve.\",\n        \"virtual_table\": \"SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2417", "db_id": "candidate_poll", "question": "For each sex, what is the name and sex of the candidate with the oppose rate for their sex?", "rationale": ["Identify the relevant tables: 'people' and 'candidate'.", "We need to join these tables on the 'People_ID' field to access both candidate and person details.", "We want to select the 'Name' and 'Sex' from the 'people' table and the 'Oppose_rate' from the 'candidate' table.", "We need to filter the results based on the sex of the candidates, which can be done by using a subquery to get distinct sexes from the 'people' table.", "Finally, we order the results by the 'Oppose_rate' in descending order to get the candidates with the highest oppose rates for their respective sexes."], "gold_sql": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex", "source_tables": ["candidate", "people"], "pred_sql": "SELECT p.Name, p.Sex, c.Oppose_rate FROM people AS p JOIN candidate AS c ON p.People_ID = c.People_ID WHERE p.Sex IN (SELECT DISTINCT Sex FROM people) ORDER BY c.Oppose_rate DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the gender distribution of candidates based on their support rates. It joins the 'people' and 'candidate' tables on the 'People_ID' field, grouping the results by gender and ordering them by the average unsure rate of the candidates. The placeholder in the LIMIT clause allows for specifying the number of results to return.\",\n        \"virtual_table\": \"SELECT t1.sex FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex ORDER BY avg(t2.unsure_rate) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2434", "db_id": "movie_1", "question": "Find the titles of all movies directed by steven spielberg.", "rationale": ["Identify the relevant table: The 'Movie' table contains the information about movies, including their titles and directors.", "Determine the required columns: We need the 'title' of the movies directed by 'steven spielberg'.", "Formulate the WHERE clause: We need to filter the results to only include movies where the 'director' is 'steven spielberg'.", "Combine these elements into a SQL SELECT statement: We will select the 'title' from the 'Movie' table with the specified condition."], "gold_sql": "SELECT title FROM Movie WHERE director = 'Steven Spielberg'", "source_tables": ["movie"], "pred_sql": "SELECT title FROM Movie WHERE director = 'steven spielberg'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    }\n}\n"}
{"sample_id": "train.2461", "db_id": "movie_1", "question": "What are the different names of all reviewers whose ratings do not have a date field?", "rationale": ["Identify the goal: We need to find the names of reviewers whose ratings do not have a date field.", "Understand the schema: The Reviewer table contains reviewer names and the Rating table contains ratings linked to reviewers and movies, including a date field.", "Determine the condition: We want to filter out reviewers who have ratings with a non-null ratingDate.", "Construct a subquery: We can create a subquery that selects rID from the Rating table where ratingDate is not null.", "Use NOT IN: We will use the NOT IN clause to find reviewers whose rID is not in the list of rIDs from the subquery.", "Select distinct names: Finally, we will select distinct names from the Reviewer table based on the filtered rIDs."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT name FROM Reviewer WHERE rID NOT IN (SELECT rID FROM Rating WHERE ratingDate IS NOT NULL)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n        \"virtual_table\": \"SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2476", "db_id": "movie_1", "question": "Find the names of all reviewers who rated Gone with the Wind.", "rationale": ["Identify the tables involved: Reviewer, Rating, and Movie.", "We need to find reviewers who rated a specific movie, so we will join the Reviewer table with the Rating table on the reviewer ID (rID).", "Next, we will join the Rating table with the Movie table on the movie ID (mID) to access movie details.", "We are specifically looking for the movie titled 'Gone with the Wind', so we will add a WHERE clause to filter the results based on the movie title.", "Finally, we will select the names of the reviewers from the Reviewer table."], "gold_sql": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  'Gone with the Wind'", "source_tables": ["rating", "movie", "reviewer"], "pred_sql": "SELECT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nJOIN Movie ON Rating.mID = Movie.mID \nWHERE Movie.title = 'Gone with the Wind';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    }\n}\n"}
{"sample_id": "train.2483", "db_id": "movie_1", "question": "What are the names of all the reviewers and movie names?", "rationale": ["Identify the tables involved: Reviewer and Movie.", "Determine the columns needed: names of reviewers and titles of movies.", "Use the UNION operator to combine the results from both tables into a single result set.", "Construct the SQL query to select the 'name' from the Reviewer table and 'title' from the Movie table."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "pred_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    }\n}\n"}
{"sample_id": "train.2495", "db_id": "movie_1", "question": "For each director, how many reviews have they received?", "rationale": ["We need to count the number of reviews for each director.", "The reviews are stored in the 'Rating' table, which links to the 'Movie' table through the movie ID (mID).", "To get the count of reviews per director, we will join the 'Movie' table with the 'Rating' table on the mID column.", "We will group the results by the director's name to get the count of reviews for each director.", "The provided hint gives us a virtual table that already outlines the necessary SQL structure to achieve this."], "gold_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director\"\n    }\n}\n"}
{"sample_id": "train.2500", "db_id": "movie_1", "question": "What are the names and years of the movies that has the top 3 highest rating star?", "rationale": ["We need to find the names and years of movies with the top 3 highest ratings.", "To do this, we will join the 'Rating' table with the 'Movie' table using the movie identifier (mID).", "We will calculate the average rating for each movie using the AVG function on the stars column from the Rating table.", "We will group the results by movie identifier (mID) to ensure we get one average rating per movie.", "Next, we will order the results by the average rating in descending order to get the highest ratings first.", "Finally, we will limit the results to the top 3 movies."], "gold_sql": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT 3", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title, T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2502", "db_id": "movie_1", "question": "For each director, return the director's name together with the title of the movie they directed that received the highest rating among all of their movies, and the value of that rating. Ignore movies whose director is NULL.", "rationale": ["We need to find the highest-rated movie for each director.", "First, we join the Movie and Rating tables on the movie ID (mID) to access both movie titles and their ratings.", "We filter out any movies where the director is NULL using a WHERE clause.", "Next, we group the results by director and movie title to aggregate the ratings for each movie directed by a specific director.", "To find the highest rating for each director, we use the MAX function on the stars column.", "Finally, we ensure that we only return the movie with the highest rating for each director by using a HAVING clause that compares the stars to the maximum stars for that director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT M.director, M.title, MAX(R.stars) AS highest_rating\nFROM Movie AS M\nJOIN Rating AS R ON M.mID = R.mID\nWHERE M.director IS NOT NULL\nGROUP BY M.director, M.title\nHAVING R.stars = (SELECT MAX(stars) FROM Rating WHERE mID IN (SELECT mID FROM Movie WHERE director = M.director))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director\"\n    }\n}\n"}
{"sample_id": "train.2503", "db_id": "movie_1", "question": "For each director, what are the titles and ratings for all the movies they reviewed?", "rationale": ["We need to retrieve the titles of movies and their ratings for each director.", "The relevant tables are Movie, Reviewer, and Rating.", "We will join the Movie table with the Rating table on the movie ID (mID) to get the ratings for each movie.", "Next, we will join the Reviewer table on the reviewer ID (rID) to get the names of the reviewers who rated the movies.", "Finally, we will select the movie title, the rating (stars), and the director's name from the joined tables.", "To organize the results, we will order the output by director and then by movie title."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT Movie.title, Rating.stars, Movie.director \nFROM Movie \nJOIN Rating ON Movie.mID = Rating.mID \nJOIN Reviewer ON Rating.rID = Reviewer.rID \nORDER BY Movie.director, Movie.title;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    }\n}\n"}
{"sample_id": "train.2505", "db_id": "movie_1", "question": "For each reviewer id, what is the title and rating for the movie with the smallest rating?", "rationale": ["We need to find the title and rating for the movie with the smallest rating for each reviewer.", "To do this, we will join the Rating table with the Movie table on the movie ID (mID).", "We will then need to find the minimum rating for each reviewer. This can be done using a subquery that groups the ratings by reviewer ID (rID) and selects the minimum stars for each group.", "The main query will select the reviewer ID, movie title, and stars from the joined tables where the (reviewer ID, stars) pair matches the minimum stars found in the subquery.", "Finally, we will order the results by reviewer ID to organize the output."], "gold_sql": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID", "source_tables": ["rating", "movie"], "pred_sql": "SELECT r.rID, m.title, r.stars \nFROM Rating r \nJOIN Movie m ON r.mID = m.mID \nWHERE (r.rID, r.stars) IN (\n    SELECT r1.rID, MIN(r1.stars) \n    FROM Rating r1 \n    GROUP BY r1.rID\n) \nORDER BY r.rID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n        \"virtual_table\": \"SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2507", "db_id": "movie_1", "question": "For each director, what is the title and score of their most poorly rated movie?", "rationale": ["We need to find the title and score of the most poorly rated movie for each director.", "To do this, we will join the Movie and Rating tables on the movie ID (mID).", "We will then group the results by director and find the minimum rating (stars) for each director.", "The subquery will select the director and the minimum stars rating for each director.", "Finally, we will select the title and stars from the main query where the director and stars match the results from the subquery."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT M.title, M.director, R.stars \nFROM Movie AS M \nJOIN Rating AS R ON M.mID = R.mID \nWHERE (M.director, R.stars) IN (\n    SELECT M2.director, MIN(R2.stars) \n    FROM Movie AS M2 \n    JOIN Rating AS R2 ON M2.mID = R2.mID \n    GROUP BY M2.director\n) \nORDER BY M.director;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of ratings for each movie director from the 'Movie' and 'Rating' tables. The placeholder in the SELECT statement represents the total number of ratings grouped by each director's name.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director\"\n    }\n}\n"}
{"sample_id": "train.2508", "db_id": "movie_1", "question": "What is the name of the movie that is rated by most of times?", "rationale": ["We need to find the movie that has been rated the most times.", "To do this, we will join the Rating table with the Movie table using the movie identifier (mID).", "We will count the number of ratings for each movie using COUNT(T1.mID).", "We will group the results by movie identifier (T1.mID) to get the count for each movie.", "Next, we will order the results by the count of ratings in descending order to get the movie with the highest count at the top.", "Finally, we will limit the results to 1 to get only the movie that is rated the most times."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title, COUNT(T1.mID) AS rating_count FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID GROUP BY T1.mID ORDER BY rating_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2509", "db_id": "movie_1", "question": "What is the name of the movie that has been reviewed the most?", "rationale": ["Identify the goal: We need to find the name of the movie that has been reviewed the most.", "To determine which movie has been reviewed the most, we need to count the number of reviews for each movie.", "The Rating table contains the mID which links to the Movie table, and we can group by mID to count the reviews.", "We will use a subquery to count the number of reviews for each movie and order them in descending order.", "We will limit the results to 1 to get the movie with the highest count of reviews.", "Finally, we will select the title of the movie from the Movie table using the mID obtained from the subquery."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title FROM Movie WHERE mID IN (SELECT mID FROM Rating GROUP BY mID ORDER BY COUNT(rID) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    }\n}\n"}
{"sample_id": "train.2517", "db_id": "movie_1", "question": "What are the ids of all moviest hat have not been reviewed by Britanny Harris?", "rationale": ["Identify the requirement: We need to find movie IDs that have not been reviewed by a specific reviewer, Britanny Harris.", "Use the provided hint about the virtual table which suggests using the EXCEPT clause to filter out movies that have been rated by the specified reviewer.", "The first part of the EXCEPT clause selects all movie IDs from the Rating table.", "The second part of the EXCEPT clause selects movie IDs that have been rated by Britanny Harris by joining the Rating table with the Reviewer table on the reviewer ID (rID) and filtering by the reviewer's name.", "Replace the placeholder in the hint with 'Britanny Harris' to complete the SQL query."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  = 'Britanny Harris'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique movie identifiers from the 'Rating' table that have not been rated by a specific reviewer. The placeholder in the query represents the reviewer's name, allowing users to filter out movies rated by that particular reviewer.\",\n        \"virtual_table\": \"SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2518", "db_id": "movie_1", "question": "Find the average rating star for each movie that received at least 2 ratings.", "rationale": ["We need to find the average rating star for each movie that received at least 2 ratings.", "To do this, we will join the 'Rating' table (T1) with the 'Movie' table (T2) on the movie identifier (mID).", "We will calculate the average of the stars given in the ratings using the AVG() function.", "To ensure we only include movies that have received at least 2 ratings, we will use the HAVING clause with COUNT(T1.rID) >= 2 after grouping by T1.mID."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "pred_sql": "SELECT T2.title, avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID GROUP BY T1.mID HAVING COUNT(T1.rID) >= 2", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2528", "db_id": "movie_1", "question": "What are the names of reviewers who had rated 3 star and 4 star?", "rationale": ["Identify the tables involved: Reviewer and Rating.", "We need to find the names of reviewers, so we will select the 'name' column from the Reviewer table.", "The Rating table contains the star ratings, so we will join the Reviewer table with the Rating table on the reviewer ID (rID).", "We need to filter the results to include only those ratings that are either 3 stars or 4 stars.", "Use the DISTINCT keyword to ensure that each reviewer's name appears only once in the result, even if they rated multiple movies with 3 or 4 stars."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT Reviewer.name \nFROM Reviewer \nJOIN Rating ON Reviewer.rID = Rating.rID \nWHERE Rating.stars IN ('3', '4');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table combines the names of reviewers and the titles of movies from the respective tables. The result will include a unified list of names and titles, allowing for a comprehensive view of both reviewers and movies.\",\n        \"virtual_table\": \"SELECT name FROM Reviewer UNION SELECT title FROM Movie\"\n    }\n}\n"}
{"sample_id": "train.2530", "db_id": "movie_1", "question": "What are the names of movies that get 3 star and 4 star?", "rationale": ["Identify the tables involved: Movie and Rating.", "We need to find movie titles, so we will select from the Movie table.", "We need to filter ratings to include only those that are 3 stars or 4 stars.", "Join the Rating table with the Movie table on the movie identifier (mID).", "Use a WHERE clause to filter the ratings to include only 3 and 4 stars.", "Group the results by movie title to avoid duplicates."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID WHERE T1.stars IN ('3', '4') GROUP BY T2.title;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the titles of movies along with their average ratings from the 'Rating' table. The results are grouped by movie identifier and ordered by the average rating in ascending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.title ,  avg(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY avg(T1.stars) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2576", "db_id": "inn_1", "question": "Find the most popular room in the hotel. The most popular room is the room that had seen the largest number of reservations.", "rationale": ["Identify the tables involved: Reservations and Rooms.", "We need to count the number of reservations for each room, so we will join the Reservations table with the Rooms table on the RoomId.", "Use COUNT() to count the number of reservations for each room.", "Group the results by RoomId to get the count for each room.", "Order the results by the count of reservations in descending order to find the most popular room.", "Limit the results to 1 to get only the most popular room."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.roomName, COUNT(T1.Code) AS reservation_count \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nGROUP BY T2.RoomId \nORDER BY reservation_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2577", "db_id": "inn_1", "question": "Which room has the largest number of reservations?", "rationale": ["Identify the tables involved: Reservations and Rooms.", "We need to count the number of reservations for each room, so we will join the Reservations table with the Rooms table on the RoomId.", "We will group the results by room name to count the number of reservations for each room.", "To find the room with the largest number of reservations, we will order the results by the count of reservations in descending order.", "Finally, we will limit the results to only the top result to get the room with the largest number of reservations."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.roomName, COUNT(T1.Code) AS reservation_count FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room = T2.RoomId GROUP BY T2.roomName ORDER BY reservation_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2578", "db_id": "inn_1", "question": "How many kids stay in the rooms reserved by ROY SWEAZY?", "rationale": ["Identify the relevant tables: Reservations contains the information about guests and their reservations.", "Determine the specific guest: The query is focused on the guest with the first name 'ROY' and last name 'SWEAZY'.", "Use the provided hint to construct the SQL query: The hint suggests a virtual table that selects the number of kids from the Reservations table based on the guest's name.", "Replace the placeholders in the hint with the actual names: Substitute [PLACEHOLDER-TYPE:STRING] with 'ROY' and 'SWEAZY'.", "Construct the final SQL query: Combine the elements to form the complete SQL statement."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "pred_sql": "SELECT Kids FROM Reservations WHERE FirstName = 'ROY' AND LastName = 'SWEAZY';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\",\n        \"virtual_table\": \"SELECT kids FROM Reservations WHERE FirstName = [PLACEHOLDER-TYPE:STRING] AND LastName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2582", "db_id": "inn_1", "question": "Which room has the highest rate? List the room's full name, rate, check in and check out date.", "rationale": ["Identify the required information: room's full name, rate, check-in and check-out dates.", "Determine the tables involved: Rooms and Reservations.", "Join the Rooms and Reservations tables on the RoomId to access room details along with reservation details.", "Use a subquery to find the maximum rate from the Reservations table.", "Filter the results to only include the room(s) with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, Reservations.Rate, Reservations.CheckIn, Reservations.CheckOut \nFROM Reservations \nJOIN Rooms ON Reservations.Room = Rooms.RoomId \nWHERE Reservations.Rate = (SELECT MAX(Rate) FROM Reservations)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n        \"virtual_table\": \"SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2583", "db_id": "inn_1", "question": "Return the name, rate, check in and check out date for the room with the highest rate.", "rationale": ["Identify the required fields: room name, rate, check-in date, and check-out date.", "Determine the tables involved: Rooms and Reservations.", "Join the Reservations table with the Rooms table on the RoomId to access room details.", "Use a subquery to find the maximum rate from the Reservations table.", "Filter the results to only include the room(s) with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, Reservations.Rate, Reservations.CheckIn, Reservations.CheckOut \nFROM Reservations \nJOIN Rooms ON Reservations.Room = Rooms.RoomId \nWHERE Reservations.Rate = (SELECT MAX(Rate) FROM Reservations)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n        \"virtual_table\": \"SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2589", "db_id": "inn_1", "question": "Find the total number of king beds available.", "rationale": ["Identify the requirement: We need to find the total number of king beds available.", "Understand the schema: The 'Rooms' table contains a column 'bedType' which specifies the type of beds in each room.", "Use the COUNT function to count the number of rooms that have 'king' as their bedType.", "Construct the SQL query to select the count of rooms where bedType is 'king'."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT COUNT(*) AS total_king_beds FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2590", "db_id": "inn_1", "question": "List the names and decor of rooms that have a king bed. Sort the list by their price.", "rationale": ["Identify the relevant table: Rooms, which contains information about room names, decor, and bed types.", "Filter the rooms to only include those with a king bed by using the condition 'bedType = 'king''.", "Select the columns 'roomName' and 'decor' to display the names and decor of the filtered rooms.", "Sort the results by 'basePrice' to order the rooms by their price."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName, decor FROM Rooms WHERE bedType = 'king' ORDER BY basePrice;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2594", "db_id": "inn_1", "question": "What is the decor of room Recluse and defiance?", "rationale": ["Identify the relevant table: The question pertains to the decor of specific rooms, which are stored in the 'Rooms' table.", "Determine the columns needed: We need the 'decor' column from the 'Rooms' table.", "Specify the rooms of interest: The rooms specified are 'Recluse' and 'defiance'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'decor' for the specified room names using a WHERE clause to filter by room names."], "gold_sql": "SELECT decor FROM Rooms WHERE roomName  =  'Recluse and defiance';", "source_tables": ["rooms"], "pred_sql": "SELECT decor FROM Rooms WHERE roomName IN ('Recluse', 'defiance');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2604", "db_id": "inn_1", "question": "Find the first and last names of people who payed more than the rooms' base prices.", "rationale": ["Identify the tables involved: Reservations and Rooms.", "Determine the columns needed: FirstName and LastName from Reservations, and basePrice from Rooms.", "Establish the relationship between the tables using the foreign key: Reservations.Room = Rooms.RoomId.", "Formulate the condition: Rate from Reservations should be greater than basePrice from Rooms.", "Construct the SQL query using a JOIN to combine the two tables and apply the condition."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T1.FirstName, T1.LastName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room = T2.RoomId WHERE T1.Rate - T2.basePrice > 0", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of guests from the 'Reservations' table who have a reservation rate that exceeds the base price of the room they booked. The placeholder in the WHERE clause represents the difference in price that is being queried.\",\n        \"virtual_table\": \"SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2609", "db_id": "inn_1", "question": "How many rooms have a king bed?", "rationale": ["Identify the relevant table: The question pertains to the 'Rooms' table.", "Determine the condition: We need to find rooms that have a specific bed type, which is 'king'.", "Construct the SQL query: We will use the COUNT function to count the number of rooms that meet the condition."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT COUNT(*) FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2612", "db_id": "inn_1", "question": "Find the name of the room with the maximum occupancy.", "rationale": ["Identify the relevant table: The 'Rooms' table contains the information about room names and their maximum occupancy.", "Determine the requirement: We need to find the room name with the maximum occupancy.", "Use a subquery to find the maximum occupancy: The subquery (SELECT MAX(maxOccupancy) FROM Rooms) will return the highest value of maxOccupancy from the Rooms table.", "Filter the main query: The main query will select the roomName from the Rooms table where the maxOccupancy matches the maximum value found in the subquery."], "gold_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE maxOccupancy = (SELECT MAX(maxOccupancy) FROM Rooms);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2621", "db_id": "inn_1", "question": "What is the average minimum and price of the rooms for each different decor.", "rationale": ["Identify the tables involved: Rooms and Reservations.", "Determine the required fields: decor, average price, and minimum price.", "Use JOIN to connect Rooms and Reservations based on the RoomId.", "Use AVG() to calculate the average price and MIN() to find the minimum price of rooms.", "Group the results by the decor type to get the average and minimum prices for each decor."], "gold_sql": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;", "source_tables": ["rooms"], "pred_sql": "SELECT Rooms.decor, AVG(CAST(Rooms.basePrice AS REAL)) AS average_price, MIN(CAST(Rooms.basePrice AS REAL)) AS minimum_price \nFROM Rooms \nJOIN Reservations ON Rooms.RoomId = Reservations.Room \nGROUP BY Rooms.decor;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of room decorations from the 'Rooms' table that have been reserved, grouped by their decor type. The results are ordered by the count of reservations for each decor type in ascending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.decor FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T2.decor ORDER BY count(T2.decor) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.2628", "db_id": "inn_1", "question": "List the name of rooms with king or queen bed.", "rationale": ["Identify the relevant table: The 'Rooms' table contains the information about room names and bed types.", "Determine the required columns: We need the 'roomName' column from the 'Rooms' table.", "Specify the condition for bed types: We are interested in rooms with either 'king' or 'queen' beds.", "Construct the SQL query: Using the identified table and columns, we create a SELECT statement with a WHERE clause to filter by the specified bed types."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE bedType = 'king' OR bedType = 'queen';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of rooms from the 'Rooms' table that have specific types of beds available. The placeholders in the WHERE clause represent the types of beds that the user is interested in.\",\n        \"virtual_table\": \"SELECT roomName FROM Rooms WHERE bedType  =  [PLACEHOLDER-TYPE:STRING] OR bedType  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["Identify the columns needed: room name and the count of reservations.", "Use the Rooms table to get the room names.", "Join the Rooms table with the Reservations table on the RoomId to link rooms with their reservations.", "Count the number of reservations for each room using COUNT() function.", "Group the results by RoomId to get the count for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT Rooms.roomName, COUNT(Reservations.Code) AS reservation_count \nFROM Rooms \nLEFT JOIN Reservations ON Rooms.RoomId = Reservations.Room \nGROUP BY Rooms.RoomId;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of kids associated with reservations made by a specific guest. The placeholders in the WHERE clause represent the first and last names of the guest.\",\n        \"virtual_table\": \"SELECT kids FROM Reservations WHERE FirstName = [PLACEHOLDER-TYPE:STRING] AND LastName  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["Identify the table needed: The question asks for details of trucks, so we will use the 'Trucks' table.", "Select all columns: We need all details, so we will use SELECT *.", "Order by license number: The question specifies to order the results by the truck's license number, so we will add ORDER BY truck_licence_number."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "pred_sql": "SELECT * FROM Trucks ORDER BY truck_licence_number;", "hint": "\n"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to find customer names, so we will select 'customer_name' from the Customers table.", "To filter customers based on their address, we need to join the Customers table with the Customer_Addresses table using 'customer_id'.", "Next, we join the Customer_Addresses table with the Addresses table using 'address_id' to access the state information.", "Finally, we apply a WHERE clause to filter out customers whose state is 'California'."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT customer_name \nFROM Customers C \nJOIN Customer_Addresses CA ON C.customer_id = CA.customer_id \nJOIN Addresses A ON CA.address_id = A.address_id \nWHERE A.state_province_county != 'California';", "hint": "\n"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["We need to find the name of the route with the highest number of deliveries.", "To do this, we will first count the number of deliveries for each route in the Order_Deliveries table.", "We will group the results by route_id and order them in descending order based on the count of deliveries.", "We will limit the results to 1 to get the route with the highest number of deliveries.", "Finally, we will select the route_name from the Delivery_Routes table where the route_id matches the one we found in the previous step."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "pred_sql": "SELECT route_name\nFROM Delivery_Routes\nWHERE route_id = (\n    SELECT route_id\n    FROM Order_Deliveries\n    GROUP BY route_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n);", "hint": "\n"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and PROFESSOR.", "Determine the relationship between the tables: CLASS has a foreign key PROF_NUM that links to EMP_NUM in PROFESSOR.", "We need to count the number of distinct professors teaching the class with code 'ACCT-211'.", "Use a JOIN to connect CLASS and PROFESSOR on the PROF_NUM and EMP_NUM fields respectively.", "Filter the results to only include the class with CLASS_CODE 'ACCT-211'.", "Use COUNT(DISTINCT p.EMP_NUM) to get the number of unique professors teaching that class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS professor_count \nFROM CLASS c \nJOIN PROFESSOR p ON c.PROF_NUM = p.EMP_NUM \nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    }\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: PROFESSOR and CLASS are needed to find professors teaching a specific class.", "Join the PROFESSOR table with the CLASS table on the common column PROF_NUM to link professors to their classes.", "Filter the results to only include classes with the CLASS_CODE 'ACCT-211'.", "Use COUNT(DISTINCT p.EMP_NUM) to count the unique professors teaching that class."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) \nFROM PROFESSOR p \nJOIN CLASS c ON p.EMP_NUM = c.PROF_NUM \nWHERE c.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    }\n}\n"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the tables needed: We need information from the PROFESSOR (to get first names), CLASS (to link professors to courses), and COURSE (to filter by course code).", "Join the CLASS table with the EMPLOYEE table to get the first names of professors teaching the classes.", "Join the CLASS table with the COURSE table to filter for the specific course 'ACCT-211'.", "Select the first names and date of birth of the professors from the EMPLOYEE table."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT T2.emp_fname, T2.emp_dob FROM CLASS AS T1 JOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM JOIN COURSE AS T3 ON T1.CRS_CODE = T3.CRS_CODE WHERE T3.CRS_CODE = 'ACCT-211'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["The user is asking for the location of the history department, which implies we need to query the DEPARTMENT table.", "To find the history department, we will filter the DEPARTMENT table by the department name, specifically looking for 'History'.", "We will select the department name and address from the DEPARTMENT table to provide the location information."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "pred_sql": "SELECT T5.dept_name, T5.dept_address FROM DEPARTMENT AS T5 WHERE T5.dept_name = 'History'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the relevant table: The question asks about locations associated with a specific school code, which relates to the DEPARTMENT table where school codes and addresses are stored.", "Determine the specific column needed: We need the DEPT_ADDRESS column to get the locations of the departments.", "Filter by the school code: We will add a WHERE clause to filter the results to only include departments that belong to the school with the code 'BUS'.", "Use DISTINCT to ensure unique addresses are returned, as multiple departments may share the same address."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of school codes from the 'department' table, grouped by the school code and ordered by the count of professors associated with each school. The placeholder in the LIMIT clause allows the user to specify the maximum number of school codes to retrieve.\",\n        \"virtual_table\": \"SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["Identify the tables involved: We need to gather information from the COURSE and CLASS tables to determine the total credit hours offered by each department.", "Determine the relationship: The COURSE table has a DEPT_CODE that links to the department, and the CLASS table has a CRS_CODE that links to the COURSE table.", "Use aggregation: We need to sum the credit hours (CRS_CREDIT) for each department, which requires a GROUP BY clause on the DEPT_CODE.", "Construct the SQL query: Using the JOIN clause to connect the COURSE and CLASS tables on the CRS_CODE, and then summing the CRS_CREDIT while grouping by DEPT_CODE."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT sum(T1.CRS_CREDIT) AS total_credit, T1.DEPT_CODE FROM COURSE AS T1 JOIN CLASS AS T2 ON T1.CRS_CODE = T2.CRS_CODE GROUP BY T1.DEPT_CODE", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["The question asks for the total credits offered by the department.", "To find this, we need to sum the credit hours from the COURSE table.", "The COURSE table contains the CRS_CREDIT column which represents the number of credit hours for each course.", "We need to join the COURSE table with the CLASS table to ensure we are considering only the courses that have classes scheduled.", "The join is done on the CRS_CODE column which is common in both tables.", "After joining, we can group the results by DEPT_CODE to get the total credits for each department.", "Finally, we select the sum of CRS_CREDIT and the DEPT_CODE to get the desired result."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT sum(T1.CRS_CREDIT) AS total_credits, T1.DEPT_CODE FROM COURSE AS T1 JOIN CLASS AS T2 ON T1.CRS_CODE = T2.CRS_CODE GROUP BY T1.DEPT_CODE", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["We need to find the school with the smallest number of professors.", "The hint provides a virtual table that counts professors grouped by school code.", "We will use the provided virtual table to create a subquery that counts the number of professors for each school.", "Next, we will order the results of this subquery by the count of professors in ascending order.", "Finally, we will limit the results to 1 to get the school with the smallest number of professors."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "pred_sql": "SELECT T1.school_code FROM (SELECT count(*) AS professor_count, T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code = T2.dept_code GROUP BY T1.school_code) AS counts ORDER BY professor_count ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    }\n}\n"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["Identify the tables needed: DEPARTMENT and PROFESSOR.", "We need to count the number of professors, so we will use COUNT(*) in the SELECT clause.", "We need to filter professors with a Ph.D. degree, so we will add a WHERE clause to check for 'Ph.D.' in the PROF_HIGH_DEGREE column.", "We want to group the results by department, so we will use GROUP BY on the DEPT_NAME from the DEPARTMENT table.", "Join the DEPARTMENT and PROFESSOR tables on the DEPT_CODE to get the necessary information for the count and department name."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) AS professor_count, D.DEPT_NAME \nFROM DEPARTMENT D \nJOIN PROFESSOR P ON D.DEPT_CODE = P.DEPT_CODE \nWHERE P.PROF_HIGH_DEGREE = 'Ph.D.' \nGROUP BY D.DEPT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by the school code from the 'Department' table. The placeholder in the SELECT clause represents the count of professors, while the school code is derived from the department associated with each professor.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code\"\n    }\n}\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["We need to find the number of students for each department.", "The relevant table for student information is the STUDENT table.", "To count the number of students, we can use the COUNT() function.", "We will group the results by the department code to get the count for each department.", "The provided hint suggests a virtual table that counts students grouped by department code, which we can use as a basis for our query."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT count(*) AS student_count, dept_code FROM STUDENT GROUP BY dept_code", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students grouped by their department codes from the 'student' table. The placeholder in the SELECT statement represents the department code for which the count of students is being aggregated.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["Identify the relevant table: The STUDENT table contains the total credit hours completed by students and their department codes.", "Determine the aggregation needed: We need to sum the total credit hours for each department.", "Group the results: Use GROUP BY to organize the results by department code.", "Construct the SQL query: Combine the SELECT statement with the SUM function and GROUP BY clause to create the final query."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT sum(STU_HRS) AS total_hours, DEPT_CODE FROM STUDENT GROUP BY DEPT_CODE", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["Identify the relevant tables: COURSE and CLASS, as we need to aggregate credit hours by department.", "Join the COURSE and CLASS tables on the CRS_CODE to link courses to their respective classes.", "Use the SUM function to calculate the total credit hours for each department.", "Group the results by DEPT_CODE to get the total credits per department.", "Order the results in descending order to find the department with the most credits.", "Limit the results to 1 to get only the department with the highest total credits."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "pred_sql": "SELECT DEPT_CODE, SUM(CRS_CREDIT) AS TOTAL_CREDITS \nFROM COURSE \nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE \nGROUP BY DEPT_CODE \nORDER BY TOTAL_CREDITS DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the relevant tables: ENROLL, CLASS, and STUDENT.", "We need to find the first names of students enrolled in a specific class, which is identified by the CRS_CODE 'ACCT-211'.", "Join the ENROLL table with the CLASS table on CLASS_CODE to link students to their classes.", "Join the resulting table with the STUDENT table on STU_NUM to access student details.", "Select the STU_FNAME column from the STUDENT table where the class code matches 'ACCT-211'."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME FROM ENROLL JOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE JOIN STUDENT ON ENROLL.STU_NUM = STUDENT.STU_NUM WHERE CLASS.CRS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["Identify the tables needed: STUDENT, ENROLL, and CLASS are required to get the first names of students enrolled in a specific class and their grades.", "The STUDENT table contains the first names of students, while the ENROLL table links students to their enrolled classes and their grades.", "The CLASS table provides the class code to filter the results to only those enrolled in 'ACCT-211'.", "Join the STUDENT table with the ENROLL table on the student number (STU_NUM) to get the grades for each student.", "Join the resulting table with the CLASS table on the class code (CLASS_CODE) to filter for the specific class 'ACCT-211'.", "Add a WHERE clause to filter for students who received a grade of 'C'.", "Select the first names of the students that meet these criteria."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE CLASS.CLASS_CODE = 'ACCT-211' AND ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours completed by students, grouped by their respective departments. The placeholder in the SELECT clause represents the total credit hours, while the GROUP BY clause organizes the results by department code.\",\n        \"virtual_table\": \"SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["To find the department with the most students enrolled, we first need to count the number of students in each department.", "We can use the provided virtual table to count students grouped by their department codes: `SELECT count(*), dept_code FROM student GROUP BY dept_code`.", "Next, we need to join this result with the DEPARTMENT table to get the department names corresponding to the department codes.", "We will join the DEPARTMENT table on the DEPT_CODE column with the result of our student count query.", "To find the department with the most students, we will order the results by the student count in descending order and limit the results to 1."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT d.DEPT_NAME\nFROM DEPARTMENT d\nJOIN (\n    SELECT count(*) as student_count, dept_code \n    FROM STUDENT \n    GROUP BY dept_code\n) as dept_student_count ON d.DEPT_CODE = dept_student_count.dept_code\nORDER BY student_count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students grouped by their department codes from the 'student' table. The placeholder in the SELECT statement represents the department code for which the count of students is being aggregated.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["Identify the relevant table: The CLASS table contains information about class schedules, including the room where each class is held.", "Determine the specific column needed: We need the CLASS_ROOM column to filter for classes held in room KLR209.", "Select the course codes: The CRS_CODE column in the CLASS table will provide the course codes for the classes held in the specified room.", "Use DISTINCT to ensure unique course codes are returned, as multiple sections of the same course may be held in the same room."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE\nFROM CLASS\nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about class locations, including the CLASS_ROOM column.", "Determine the specific condition: We need to filter the results to only include classes held in room 'KLR209'.", "Select the desired output: We want the unique course codes (CRS_CODE) associated with the classes in that room.", "Construct the SQL query: Use SELECT DISTINCT to get unique course codes from the CLASS table where the CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE \nFROM CLASS \nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total credit hours for courses grouped by their respective department codes. It combines data from the 'COURSE' and 'CLASS' tables, where the course code links the two tables, allowing for the aggregation of credit hours per department.\",\n        \"virtual_table\": \"SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed since we want student names and their grades.", "We need to join the STUDENT table with the ENROLL table on the student number (STU_NUM) to access the grades associated with each student.", "We are specifically looking for students who received a grade of 'C', so we will filter the results using a WHERE clause on the ENROLL_GRADE column.", "To avoid duplicate names, we will use DISTINCT to ensure each student's first name appears only once in the result."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["Identify the relevant tables: We need to find professors and their teaching status, so we will use the EMPLOYEE and CLASS tables.", "We need the first names of professors, which are in the EMPLOYEE table under the column 'emp_fname'.", "To find professors who do not teach a class, we need to check which professors are not present in the CLASS table. This can be done using a subquery that selects 'prof_num' from the CLASS table.", "The main query will select 'emp_fname' from the EMPLOYEE table where 'emp_num' is not in the list of 'prof_num' from the CLASS table."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT emp_fname FROM EMPLOYEE WHERE emp_num NOT IN (SELECT prof_num FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the table that contains professor information, which is the PROFESSOR table.", "We need to find professors who are not teaching any classes, so we will check the CLASS table for any entries associated with each professor.", "We can use a subquery to select all professor numbers (prof_num) from the CLASS table.", "The main query will select the first names (emp_fname) of professors whose employee numbers (emp_num) are not in the list obtained from the subquery."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT emp_fname FROM PROFESSOR WHERE emp_num NOT IN (SELECT prof_num FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors, including their highest degree obtained.", "Determine the condition: We need to count professors who have either a Ph.D. or a Masters degree.", "Construct the SQL query: Use the COUNT function to count the number of professors meeting the condition, filtering with a WHERE clause that checks if PROF_HIGH_DEGREE is either 'Ph.D.' or 'Masters'."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) FROM PROFESSOR WHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, COURSE, PROFESSOR, and DEPARTMENT.", "Join the CLASS table with EMPLOYEE to get the professor's first name.", "Join the CLASS table with COURSE to filter by the course codes 'CIS-220' and 'QM-261'.", "Join with PROFESSOR to ensure we are getting the correct professors for the classes.", "Join with DEPARTMENT to gather any additional department information if needed, although it's not required for the final output.", "Use a WHERE clause to filter the results to only include the specified course codes."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "pred_sql": "SELECT T2.emp_fname FROM CLASS AS T1 JOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM JOIN COURSE AS T3 ON T1.CRS_CODE = T3.CRS_CODE JOIN PROFESSOR AS T4 ON T2.EMP_NUM = T4.EMP_NUM JOIN DEPARTMENT AS T5 ON T4.DEPT_CODE = T5.DEPT_CODE WHERE T3.CRS_CODE IN ('CIS-220', 'QM-261')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the tables needed: STUDENT, ENROLL, CLASS, COURSE, and DEPARTMENT.", "Join the ENROLL table with STUDENT to get student details.", "Join the CLASS table to link classes with enrollments.", "Join the COURSE table to get course details associated with each class.", "Join the DEPARTMENT table to filter courses by department names.", "Use a WHERE clause to filter departments to 'Accounting' and 'Computer Info. Systems'.", "Select the distinct first names of students who meet the criteria."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME \nFROM STUDENT AS S \nJOIN ENROLL AS E ON S.STU_NUM = E.STU_NUM \nJOIN CLASS AS C ON E.CLASS_CODE = C.CLASS_CODE \nJOIN COURSE AS CRS ON C.CRS_CODE = CRS.CRS_CODE \nJOIN DEPARTMENT AS D ON CRS.DEPT_CODE = D.DEPT_CODE \nWHERE D.DEPT_NAME IN ('Accounting', 'Computer Info. Systems');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, PROFESSOR, and DEPARTMENT.", "Join the CLASS table with the EMPLOYEE table to get the first names of professors.", "Join the EMPLOYEE table with the PROFESSOR table to get office details.", "Join the PROFESSOR table with the DEPARTMENT table to filter by department name (History) and highest degree (Ph.D).", "Select the first names and office locations of the professors who meet the criteria."], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "pred_sql": "SELECT T2.emp_fname, T4.prof_office FROM CLASS AS T1 JOIN EMPLOYEE AS T2 ON T1.PROF_NUM = T2.EMP_NUM JOIN PROFESSOR AS T4 ON T2.EMP_NUM = T4.EMP_NUM JOIN DEPARTMENT AS T5 ON T4.DEPT_CODE = T5.DEPT_CODE WHERE T5.DEPT_NAME = 'History' AND T4.PROF_HIGH_DEGREE = 'Ph.D';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["Identify the tables needed: STUDENT for student names and ENROLL for enrollment details including grades.", "We need to find students who received either an 'A' or 'C' grade, so we will filter the ENROLL table based on the ENROLL_GRADE column.", "To get the names of the students, we will select the first and last names from the STUDENT table.", "We will join the STUDENT table with the ENROLL table on the student number (STU_NUM) to link students with their grades.", "Finally, we will use DISTINCT to ensure that each student's name appears only once in the result, even if they took multiple courses with qualifying grades."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME, S.STU_LNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nWHERE E.ENROLL_GRADE IN ('A', 'C');", "hint": "\n"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the relevant tables: CLASS, EMPLOYEE, PROFESSOR, and DEPARTMENT.", "We need to get the first names of professors and their highest degree, so we will select T2.emp_fname and T4.prof_high_degree.", "Join the CLASS table with EMPLOYEE to get the professor's first name using the professor number.", "Join the PROFESSOR table to access the highest degree of the professors.", "Join the DEPARTMENT table to filter for the Computer Information Systems department.", "Use a WHERE clause to specify that we only want professors from the Computer Information Systems department."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "pred_sql": "SELECT T2.emp_fname, T4.prof_high_degree \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.prof_num = T2.emp_num \nJOIN PROFESSOR AS T4 ON T2.emp_num = T4.emp_num \nJOIN DEPARTMENT AS T5 ON T4.dept_code = T5.dept_code \nWHERE T5.dept_name = 'Computer Information Systems'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a view of the first names of professors, their office locations, course descriptions, and department names associated with classes. The query joins multiple tables: 'CLASS' to identify the class and its professor, 'EMPLOYEE' to get the professor's first name, 'COURSE' to describe the course, 'PROFESSOR' for office details, and 'DEPARTMENT' for the department name. This allows for a comprehensive overview of the teaching staff and their respective courses and departments.\",\n        \"virtual_table\": \"SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code\"\n    }\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: We need to find the department name, which is in the DEPARTMENT table, and we need to filter classes based on their descriptions, which are in the COURSE table.", "Join the DEPARTMENT and COURSE tables: We will join these tables on the DEPT_CODE to link courses to their respective departments.", "Filter the courses: We need to filter the courses to only those whose description contains the word 'Statistics'.", "Select the department name: Finally, we will select the distinct department names that meet the criteria."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT DISTINCT D.DEPT_NAME \nFROM DEPARTMENT D \nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE \nWHERE C.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of classes grouped by department code from the 'CLASS' and 'COURSE' tables. The placeholder in the SELECT statement represents the count of classes for each department.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["The question asks for the types and countries of competitions.", "We need to select the 'Competition_type' and 'Country' columns from the 'competition' table.", "To ensure we get unique combinations of competition types and their respective countries, we will use the GROUP BY clause on both 'Competition_type' and 'Country'."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "pred_sql": "SELECT Competition_type, Country FROM competition GROUP BY Competition_type, Country", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n        \"virtual_table\": \"SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3355", "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["Identify the tables needed: 'club' for club names and 'player' for player names.", "Determine the relationship between the tables: 'player' has a foreign key 'Club_ID' that references 'club'.", "Use a JOIN operation to combine data from both tables based on the 'Club_ID'.", "Select the desired columns: the name of the club and the name of the player."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "pred_sql": "SELECT c.name AS club_name, p.name AS player_name \nFROM club c \nJOIN player p ON c.Club_ID = p.Club_ID;", "hint": "\n"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["Identify the relevant table: The 'player' table contains the information about players and their positions.", "Determine the required calculation: We need to calculate the average number of points scored by players in each position.", "Group the results: Use GROUP BY to group the players by their Position.", "Filter the results: Use HAVING to filter out positions where the average points scored is greater than 20."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player GROUP BY Position HAVING AVG(Points) > 20;", "hint": "\n"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant column for player positions, which is 'Position'.", "Identify the column that contains the points scored by players, which is 'Points'.", "Formulate the condition to filter players based on their points: greater than 20 or less than 10.", "Construct the SQL SELECT statement to retrieve the 'Position' of players that meet the specified conditions."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player WHERE Points > 20 OR Points < 10;", "hint": "\n"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about the competitions, including their type and country.", "Filter for tournament competitions: We need to focus on competitions where the Competition_type is 'tournament'.", "Group by country: To find out how many tournaments each country participated in, we will group the results by the 'Country' column.", "Count the number of tournaments: We will count the number of occurrences for each country using COUNT(*).", "Order the results: We will order the results in descending order based on the count of tournaments to find the country with the most tournaments.", "Limit the results: Finally, we will limit the results to 1 to get the country with the highest count."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) as Tournament_Count \nFROM competition \nWHERE Competition_type = 'tournament' \nGROUP BY Country \nORDER BY Tournament_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n        \"virtual_table\": \"SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3384", "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about the competitions, including their type and country.", "Filter for tournament competitions: We need to focus on competitions that are of type 'tournament'.", "Group by country: To find out which country participated in the most tournaments, we will group the results by the 'Country' column.", "Count the occurrences: We will count the number of tournaments for each country to determine participation levels.", "Order by count: We will order the results in descending order to get the country with the highest participation at the top.", "Limit the results: Finally, we will limit the results to just one entry to get the country with the most tournament participations."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country FROM competition WHERE Competition_type = 'tournament' GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n        \"virtual_table\": \"SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3388", "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["We need to find countries that have never participated in friendly-type competitions.", "First, we will select distinct countries from the competition table.", "We will use a LEFT JOIN with the competition_result table to find any associated results for friendly competitions.", "We will filter the results to only include competitions of type 'friendly'.", "To find countries that have never participated, we will check for NULL values in both Club_ID_1 and Club_ID_2 from the competition_result table, indicating no participation."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT c.Country \nFROM competition c \nLEFT JOIN competition_result cr ON c.Competition_ID = cr.Competition_ID \nWHERE c.Competition_type = 'friendly' \nAND cr.Club_ID_1 IS NULL \nAND cr.Club_ID_2 IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of competitions held, grouped by their type, and orders them by the number of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of competition types to display.\",\n        \"virtual_table\": \"SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["Identify the relevant table: The 'employees' table contains the necessary information about employees' names and salaries.", "Determine the required fields: We need the first name, last name, and salary of employees.", "Set the condition: We want to filter employees who earn below 6000.", "Construct the SQL query: Using the SELECT statement to retrieve the specified fields from the 'employees' table with the appropriate WHERE clause."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME, LAST_NAME, SALARY FROM employees WHERE SALARY < 6000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (first and last name), hire date, salary, and department id.", "To get the full name, we can concatenate the first name and last name of the employee.", "We need to filter employees whose first name does not contain the letter 'M'.", "The relevant table for employee information is the 'employees' table.", "Construct the SQL query to select the required fields from the 'employees' table with the specified condition."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT CONCAT(e.FIRST_NAME, ' ', e.LAST_NAME) AS full_name, e.HIRE_DATE, e.SALARY, e.DEPARTMENT_ID \nFROM employees AS e \nWHERE e.FIRST_NAME NOT LIKE '%M%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: first name, last name, hire date, salary, and department number.", "Filter employees whose first name does not contain the letter 'M'.", "Sort the results in ascending order by department number.", "Construct the SQL query using the SELECT statement with the appropriate WHERE clause and ORDER BY clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, hire_date, department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the required fields: full name (first and last), hire date, salary, and department id.", "To create the full name, concatenate the first name and last name using '||'.", "Filter employees whose first name does not contain the letter 'M' using the NOT LIKE operator.", "Order the results by department id in ascending order.", "Construct the SQL SELECT statement with the identified fields and conditions."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID \nFROM employees \nWHERE FIRST_NAME NOT LIKE '%M%' \nORDER BY DEPARTMENT_ID ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The 'jobs' table contains information about job titles and their corresponding salary ranges.", "Determine the condition: We need to find jobs with salaries over 9000, which means we should check both the 'MIN_SALARY' and 'MAX_SALARY' columns.", "Construct the SQL query: We will select the 'JOB_TITLE' from the 'jobs' table where either 'MIN_SALARY' or 'MAX_SALARY' is greater than 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MIN_SALARY > 9000 OR MAX_SALARY > 9000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question asks for job titles and salary ranges, which are found in the 'jobs' table.", "Determine the columns needed: We need 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY' from the 'jobs' table.", "Apply the condition: The question specifies that we want jobs with a maximum salary between 12000 and 18000, so we will use a WHERE clause to filter the results based on 'MAX_SALARY'.", "Construct the SQL query: Combine the selected columns and the condition into a complete SQL statement."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY FROM jobs WHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["Identify the relevant table: The 'job_history' table contains the employment history of employees, including their end dates.", "Determine the required information: We need the employee IDs and the final dates of employment at their last job.", "Use the MAX function: To find the last job end date for each employee, we can use the MAX function on the 'end_date' column.", "Group by employee: To ensure we get the last end date for each employee, we will group the results by 'employee_id'.", "Construct the SQL query: Combine the selected columns and functions into a complete SQL query."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT employee_id, MAX(end_date) FROM job_history GROUP BY employee_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the most recent job end dates for each employee from the 'job_history' table. The placeholder in the SELECT clause represents the employee's unique identifier, while the MAX function is used to retrieve the latest end date for each employee's job history.\",\n        \"virtual_table\": \"SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id\"\n    }\n}\n"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["Identify the relevant tables: employees and departments are needed to get the average salary per department.", "We need to calculate the average salary, so we will use the AVG() function on the SALARY column from the employees table.", "To filter employees who receive a commission percentage, we will add a WHERE clause to check if COMMISSION_PCT is not NULL.", "We will join the employees table with the departments table on the DEPARTMENT_ID to get the department information for each employee.", "Finally, we will group the results by DEPARTMENT_ID to get the average salary for each department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, AVG(e.SALARY) AS average_salary\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nWHERE e.COMMISSION_PCT IS NOT NULL\nGROUP BY d.DEPARTMENT_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum salary for each department from the 'employees' table. The placeholder in the SELECT clause represents the salary values, while the GROUP BY clause organizes the results by department identifier.\",\n        \"virtual_table\": \"SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["Identify the table needed: The 'employees' table contains the salary and commission percentage information.", "Determine the condition: We need to filter employees whose commission percentage is not null, which can be done using the WHERE clause.", "Calculate the average salary: Use the AVG() function to compute the average salary of the filtered employees.", "Construct the SQL query: Combine the SELECT statement with the AVG function and the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT AVG(SALARY) AS average_salary FROM employees WHERE COMMISSION_PCT IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["Identify the required columns: COUNTRY_ID from countries and the count of cities from locations.", "To get the number of cities for each country, we need to join the countries table with the locations table on the COUNTRY_ID.", "Use the COUNT function to count the number of cities for each country.", "Group the results by COUNTRY_ID to ensure we get a count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT countries.COUNTRY_ID, COUNT(locations.CITY) AS number_of_cities\nFROM countries\nJOIN locations ON countries.COUNTRY_ID = locations.COUNTRY_ID\nGROUP BY countries.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["Identify the tables needed: 'countries' for country information and 'locations' for city information.", "Determine the relationship between the tables: 'locations' has a foreign key 'COUNTRY_ID' that links to 'countries'.", "Use a JOIN to combine 'countries' and 'locations' on 'COUNTRY_ID'.", "Count the number of cities (from 'locations') for each country (from 'countries').", "Group the results by 'COUNTRY_ID' to get the count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT c.COUNTRY_ID, COUNT(l.CITY) AS CITY_COUNT\nFROM countries c\nJOIN locations l ON c.COUNTRY_ID = l.COUNTRY_ID\nGROUP BY c.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["The query needs to return detailed information about jobs.", "We need to find jobs that have been done by employees who currently earn a salary of 12000 or more.", "To do this, we will first select the employee IDs from the 'employees' table where the salary is greater than or equal to 12000.", "Next, we will use these employee IDs to find the job IDs from the 'job_history' table, which records the jobs held by employees.", "Finally, we will select all columns from the 'jobs' table where the JOB_ID matches those found in the job history for the selected employees."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "pred_sql": "SELECT jobs.* FROM jobs WHERE jobs.JOB_ID IN (SELECT job_history.JOB_ID FROM job_history WHERE job_history.EMPLOYEE_ID IN (SELECT employees.EMPLOYEE_ID FROM employees WHERE employees.SALARY >= 12000))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who earn more than a specific employee's salary. The placeholder in the subquery represents the unique identifier of the employee whose salary is being compared.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the requirement: We need information about employees who are managers.", "To find employees who are managers, we can look for employees whose IDs appear in the manager_id field of the employees table.", "We will use a subquery to select distinct manager_ids from the employees table.", "We will join the employees table with the departments and locations tables to get the department names and location details.", "The final query will select the first name, last name, department name, city, and state/province of those employees who are managers."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT T1.first_name, T1.last_name, T2.department_name, T3.city, T3.state_province \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nJOIN locations AS T3 ON T2.location_id = T3.location_id \nWHERE T1.employee_id IN (SELECT DISTINCT manager_id FROM employees WHERE manager_id IS NOT NULL);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["We need to find departments where any manager is managing 4 or more employees.", "To do this, we will join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID'.", "We will group the results by 'DEPARTMENT_ID' to count the number of employees in each department.", "Using the HAVING clause, we will filter the groups to only include those with 4 or more employees.", "Finally, we will select the unique 'DEPARTMENT_ID' from the filtered results."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID \nFROM departments d \nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_ID \nHAVING COUNT(e.EMPLOYEE_ID) >= 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find departments where a manager is in charge of 4 or more employees.", "To do this, we will first join the 'employees' table with the 'departments' table to get the department information for each employee.", "We will use the COUNT function to count the number of employees in each department.", "We will group the results by department_id to get the count of employees per department.", "Finally, we will filter the results to only include departments with 4 or more employees and select the distinct department ids."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT department_id FROM (SELECT T2.department_id, COUNT(*) AS employee_count FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id GROUP BY T2.department_id) AS dept_counts WHERE employee_count >= 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["Identify the relevant table: The 'employees' table contains the information about employees, including their salaries.", "Determine the salary conditions: We need to find employees with salaries above the minimum salary defined in the 'jobs' table and below 2500.", "Use a subquery to find the minimum salary: The minimum salary can be obtained from the 'jobs' table using a subquery.", "Construct the SQL query: Combine the conditions to select all columns from the 'employees' table where the salary is greater than the minimum salary and less than 2500."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "pred_sql": "SELECT * FROM employees WHERE salary > (SELECT MIN_SALARY FROM jobs) AND salary < 2500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names, last names, and salaries of employees from the 'employees' table who earn less than a specified salary. The placeholder in the WHERE clause represents the salary threshold.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["Identify the requirement: We need the full names (first and last) and hire dates of employees who work in the same department as an employee named Clara.", "To find Clara's department, we will first query the employees table to get the department ID for Clara.", "We will then use this department ID to filter employees in the same department.", "The main query will select the first name, last name, and hire date from the employees table, joining with the departments table to ensure we are looking at the correct department.", "The subquery will find the department ID for Clara, which will be used in the main query's WHERE clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "pred_sql": "SELECT T1.FIRST_NAME, T1.LAST_NAME, T1.HIRE_DATE \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nWHERE T2.DEPARTMENT_ID IN (\n    SELECT T3.DEPARTMENT_ID \n    FROM employees AS T3 \n    WHERE T3.FIRST_NAME = 'Clara'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the requirement: We need the full names (first and last) and hire dates of employees who are in the same department as an employee named Clara, excluding Clara herself.", "To achieve this, we will need to join the employees table with the departments table to access department information.", "We will use a subquery to find the department_id of Clara, which will allow us to filter employees in the same department.", "The final query will select the first name, last name, and hire date of employees from the employees table, ensuring that we exclude Clara by adding a condition in the WHERE clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT T1.first_name, T1.last_name, T1.hire_date \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.department_id = T2.department_id \nWHERE T2.department_id = (SELECT department_id FROM employees WHERE first_name = 'Clara') \nAND T1.first_name != 'Clara';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["Identify the main requirement: We need to display the employee number and name (first name and last name) for all employees who work in a department with any employee whose name contains a 'T'.", "To achieve this, we need to find the department IDs of employees whose first or last name contains 'T'.", "We can use a subquery to select distinct department IDs from the employees table where either the first name or last name contains 'T'.", "Next, we will use this subquery in the main query to select the employee ID, first name, and last name of employees who belong to those departments.", "The final SQL query will join these two parts together, ensuring we get the correct employee details based on the department IDs identified in the subquery."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "pred_sql": "SELECT e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME \nFROM employees e \nWHERE e.DEPARTMENT_ID IN (\n    SELECT DISTINCT e2.DEPARTMENT_ID \n    FROM employees e2 \n    WHERE e2.FIRST_NAME LIKE '%T%' OR e2.LAST_NAME LIKE '%T%'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the requirement: We need to display employee number and job id for employees whose salary is less than any salary of those with job title 'MK_MAN'.", "Determine the relevant tables: The 'employees' table contains employee details including salary and job id, while the 'jobs' table contains job titles and their corresponding job ids.", "Create a subquery to find the job id for 'MK_MAN': This involves selecting the job_id from the jobs table where job_title is 'MK_MAN'.", "Create another subquery to find the minimum salary for the job id obtained in the previous step: This will help us compare the salaries of other employees against this minimum salary.", "Combine the subqueries: Use the main query to select employee_id and job_id from the employees table where their salary is less than the minimum salary obtained from the subquery."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT employee_id, job_id FROM employees WHERE salary < (SELECT MIN(salary) FROM employees WHERE job_id = (SELECT job_id FROM jobs WHERE job_title = 'MK_MAN'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employee IDs and their corresponding job IDs from the 'employees' table, specifically for those employees whose salary is less than the minimum salary for a specified job. The placeholder in the subquery represents the job identifier for which the minimum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for departments with more than 2 employees.", "To do this, we will join the 'employees' table with the 'departments' table on the DEPARTMENT_ID.", "We will use the SUM function to calculate the total salaries for each department.", "We will group the results by DEPARTMENT_ID to get the total salaries per department.", "To filter the departments that have more than 2 employees, we will use the HAVING clause with COUNT to count the number of employees in each department."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT T2.DEPARTMENT_ID, SUM(T1.SALARY) AS total_salaries \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nGROUP BY T2.DEPARTMENT_ID \nHAVING COUNT(T1.EMPLOYEE_ID) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees with the highest salary in each department.", "To get the full name, we can concatenate the first name and last name using the '||' operator.", "We will select the department ID and the concatenated full name as 'FULL_NAME'.", "To find the highest salary in each department, we can use a subquery that selects the maximum salary from the employees table, filtered by the department ID.", "The main query will select from the employees table where the salary matches the maximum salary from the subquery for the corresponding department."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nWHERE e.SALARY = (SELECT MAX(SALARY) \n                   FROM employees \n                   WHERE DEPARTMENT_ID = e.DEPARTMENT_ID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of employees from the 'employees' table who belong to specific departments identified by their department IDs. The placeholders in the WHERE clause represent the department IDs to filter the employees accordingly.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name FROM employees WHERE department_id  =  [PLACEHOLDER-TYPE:NUMBER] OR department_id  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the tables needed: employees, departments, and locations.", "We need to retrieve the first name and last name of employees, which are in the employees table.", "We also need the city of the employees' departments, which requires joining the departments and locations tables.", "The join conditions are: employees to departments on DEPARTMENT_ID, and departments to locations on LOCATION_ID.", "We need to filter the results to only include employees whose first names contain the letter 'Z'.", "Construct the SQL query using the identified tables, joins, and conditions."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.FIRST_NAME, T1.LAST_NAME, T3.CITY \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nJOIN locations AS T3 ON T2.LOCATION_ID = T3.LOCATION_ID \nWHERE T1.FIRST_NAME LIKE '%Z%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed to retrieve the employee's full name and the country they are working in.", "The 'employees' table contains the first and last names of employees.", "The 'departments' table is needed to link employees to their respective departments.", "The 'locations' table provides the location details of the departments, including the country.", "The 'countries' table contains the names of the countries associated with the locations.", "Join the 'employees' table with 'departments', 'locations', and 'countries' to get the required information.", "Use a WHERE clause to filter the results for a specific employee ID."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT T1.first_name, T1.last_name, T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id = T2.department_id JOIN locations AS T3 ON T2.location_id = T3.location_id JOIN countries AS T4 ON T3.country_id = T4.country_id WHERE T1.employee_id = ?", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["Identify the tables needed: 'employees' for employee data and 'departments' for department names.", "Join the 'employees' table with the 'departments' table on the common column 'DEPARTMENT_ID'.", "Select the department name from the 'departments' table and count the number of employees from the 'employees' table.", "Group the results by department name to get the count of employees in each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT T2.DEPARTMENT_NAME, COUNT(*) AS NUMBER_OF_EMPLOYEES \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nGROUP BY T2.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["Identify the tables needed: 'employees' for employee data and 'departments' for department names.", "Determine the relationship between the tables: 'employees' has a foreign key 'DEPARTMENT_ID' that links to 'departments'.", "Use a JOIN operation to combine data from both tables based on the 'DEPARTMENT_ID'.", "Select the department name from the 'departments' table and count the number of employees from the 'employees' table.", "Group the results by department name to get the count of employees in each department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT T2.DEPARTMENT_NAME, COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID GROUP BY T2.DEPARTMENT_NAME", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of employees in each department by joining the 'employees' and 'departments' tables. The placeholder in the SELECT statement represents the department's name, while the COUNT function calculates the total number of employees per department.\",\n        \"virtual_table\": \"SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name\"\n    }\n}\n"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["Identify the required information: full name (first and last name) and salary of employees in departments located in London.", "To get the full name, we need to select the FIRST_NAME and LAST_NAME from the employees table.", "The salary can be directly selected from the employees table as well.", "We need to join the employees table with the departments table to link employees to their respective departments using DEPARTMENT_ID.", "Next, we join the departments table with the locations table to find the location of each department using LOCATION_ID.", "Finally, we filter the results to include only those departments that are located in London by using a WHERE clause on the CITY column of the locations table."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.FIRST_NAME, T1.LAST_NAME, T1.SALARY \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nJOIN locations AS T3 ON T2.LOCATION_ID = T3.LOCATION_ID \nWHERE T3.CITY = 'London';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the tables needed: employees, departments, and locations.", "We need to retrieve the first name, last name, and salary of employees.", "To get the city information, we need to join the employees table with the departments table and then with the locations table.", "The join condition is based on the department_id and location_id.", "Finally, we filter the results to only include employees who work in the city of London."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT T1.FIRST_NAME, T1.LAST_NAME, T1.SALARY \nFROM employees AS T1 \nJOIN departments AS T2 ON T1.DEPARTMENT_ID = T2.DEPARTMENT_ID \nJOIN locations AS T3 ON T2.LOCATION_ID = T3.LOCATION_ID \nWHERE T3.CITY = 'London'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department names and the corresponding city and state/province of their department's location. The placeholders in the query represent the necessary identifiers for joining the tables and retrieving the relevant information.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.department_name ,  T3.city ,  T3.state_province FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id\"\n    }\n}\n"}
{"sample_id": "train.3532", "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["Identify the table that contains the song information, which is the 'song' table.", "Determine the relevant column for the song duration, which is 'duration'.", "To find the song that lasts the longest, we need to sort the songs by duration in descending order.", "Use the ORDER BY clause to sort the results by 'duration' in descending order.", "To get only the longest song, we will limit the results to 1 using the LIMIT clause.", "Select the 'f_id' column to get the id of the longest song."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT f_id FROM song ORDER BY duration DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their duration and the artist who performed them.", "Determine the goal: We need to find the names of the artists who sang the shortest song.", "Use the ORDER BY clause: To find the shortest song, we can order the songs by their duration in ascending order.", "Limit the results: Since we only want the shortest song, we will limit the results to 1 using LIMIT 1.", "Select the artist's name: We will select the 'artist_name' from the 'song' table for the shortest song."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "pred_sql": "SELECT artist_name FROM song ORDER BY duration ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["Identify the relevant table: The 'song' table contains the duration of songs.", "Determine the condition: We need to find songs with a duration of 4 minutes, which is represented as '4:00'.", "Construct the SQL query: Use the COUNT function to count the number of records in the 'song' table that meet the duration condition."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "pred_sql": "SELECT COUNT(*) FROM song WHERE duration = '4:00';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3549", "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["Identify the relevant tables: We need to use the 'artist' table to filter by gender and the 'song' table to get the ratings of the songs.", "We need to join the 'artist' table with the 'song' table on the 'artist_name' column to access the ratings of songs produced by female artists.", "Filter the results to include only female artists by adding a WHERE clause that checks if the gender is 'female'.", "Finally, calculate the average rating of the songs using the AVG() function on the 'rating' column from the 'song' table."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "pred_sql": "SELECT AVG(T3.rating) AS average_rating FROM artist AS T1 JOIN song AS T3 ON T1.artist_name = T3.artist_name WHERE T1.gender = 'female';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["We need to find the file format that is used by the most files.", "To do this, we will select the 'formats' column from the 'files' table.", "We will count the number of occurrences of each format using COUNT(*) and alias it as 'file_count'.", "To get the count for each format, we will group the results by the 'formats' column using GROUP BY.", "To find the most used format, we will order the results in descending order based on 'file_count' using ORDER BY file_count DESC.", "Finally, we will limit the results to only the top entry using LIMIT 1."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(*) as file_count \nFROM files \nGROUP BY formats \nORDER BY file_count DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3556", "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["Identify the table that contains the file information, which is the 'files' table.", "We need to select the 'f_id' column from the 'files' table.", "The condition requires filtering files that are in the 'mp4' format, which can be checked using the 'formats' column with a LIKE clause.", "Additionally, we need to ensure that the 'resolution' is smaller than 1000. Since 'resolution' is stored as text, we will cast it to an integer for comparison.", "Combine these conditions in the WHERE clause to filter the results accordingly."], "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp4%' AND CAST(resolution AS INTEGER) < 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the relevant tables: We need information from the 'artist' table for the country of origin and the 'song' table to check the language of the song.", "We need to filter artists based on gender (female) and the language of the song (Bangla).", "Join the 'artist' table with the 'song' table on the artist's name to correlate the artist with their songs.", "Construct the SQL query to select the country from the 'artist' table where the artist is female and the song is in Bangla."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE artist.gender = 'female' AND song.languages LIKE '%Bangla%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant table: We need information about artists, specifically their country and gender, so we will use the 'artist' table.", "Filter for female artists: We will add a condition to select only those artists whose gender is 'female'.", "Identify the language condition: We need to find artists who have sung songs in the Bangla language, which is found in the 'song' table.", "Use a subquery: We will create a subquery to select the artist names from the 'song' table where the languages include 'Bangla'.", "Combine the conditions: We will combine the conditions to filter female artists from the 'artist' table whose names are in the list of artists from the subquery."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.country FROM artist WHERE artist.gender = 'female' AND artist.artist_name IN (SELECT song.artist_name FROM song WHERE song.languages LIKE '%Bangla%')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the relevant tables: We need information from the 'artist' and 'song' tables.", "Determine the required fields: We need the 'gender' and 'artist_name' from the 'artist' table.", "Establish the relationship: The 'artist' table is linked to the 'song' table through the 'artist_name' field.", "Find the song with the smallest resolution: We can use a subquery to find the minimum resolution from the 'song' table.", "Join the results: We will join the 'artist' and 'song' tables to get the artist's gender and name for the song with the smallest resolution."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.gender, artist.artist_name \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.resolution = (SELECT MIN(resolution) FROM song)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3567", "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["We need to count the number of distinct artists for each file format.", "To do this, we will join the 'files' table with the 'song' table on the 'f_id' column, since 'f_id' in the 'song' table corresponds to the file associated with the song.", "Next, we will join the 'artist' table with the 'song' table on the 'artist_name' column to get the artist details for each song.", "We will select the 'formats' from the 'files' table and count the distinct 'artist_name' from the 'artist' table.", "Finally, we will group the results by 'formats' to get the count of artists for each file format."], "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"], "pred_sql": "SELECT f.formats, COUNT(DISTINCT a.artist_name) AS artist_count \nFROM files AS f \nJOIN song AS s ON f.f_id = s.f_id \nJOIN artist AS a ON s.artist_name = a.artist_name \nGROUP BY f.formats;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3576", "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["Identify the tables involved: 'artist' and 'song'.", "We need to retrieve the names and genders of artists, which are in the 'artist' table.", "We need to filter songs based on their release date, specifically for the month of March.", "The release date format is assumed to be 'YYYY-MM-DD', so we can use a LIKE clause to match any date in March by using '%-03-%'.", "Join the 'artist' table with the 'song' table on the artist's name to correlate artists with their songs.", "Construct the SQL query using the selected columns and the appropriate WHERE clause."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "pred_sql": "SELECT T1.artist_name, T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name WHERE T2.releasedate LIKE '%-03-%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["To find the languages used most often in songs, we need to count the occurrences of each language in the 'song' table.", "We will use the COUNT() function to count how many times each language appears.", "We will group the results by the 'languages' column to get the count for each distinct language.", "Finally, we will order the results in descending order to show the most frequently used languages at the top."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "pred_sql": "SELECT languages, COUNT(*) as language_count FROM song GROUP BY languages ORDER BY language_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3590", "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["Identify the relevant table: The 'artist' table contains information about artists, including their names, countries, and genders.", "Determine the criteria: We need to filter for artists who are from Britain and are male.", "Construct the SQL query: Use a SELECT statement to retrieve the 'artist_name' from the 'artist' table where the 'country' is 'Britain' and the 'gender' is 'male'."], "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"], "pred_sql": "SELECT artist_name FROM artist WHERE country = 'Britain' AND gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of artists from the 'artist' table who have released songs on a specific date. The placeholder in the WHERE clause represents the release date of the songs.\",\n        \"virtual_table\": \"SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3598", "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["Identify the relevant table: The 'song' table contains the information about songs, including their genre and rating.", "Determine the genre of interest: The user is asking for 'Bangla' songs, so we will filter the results based on the genre_is column.", "Calculate the average rating: We will use the AVG() function to calculate the average rating of the Bangla songs.", "Select the resolution: We will also select the resolution of the songs, as requested by the user.", "Construct the SQL query: Combine the above elements into a single SQL query that selects the average rating and resolution for Bangla songs."], "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"], "pred_sql": "SELECT AVG(rating) AS average_rating, resolution FROM song WHERE genre_is = 'Bangla'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3599", "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["Identify the relevant table: The 'song' table contains the resolution and duration of songs.", "Determine the conditions: We need to filter songs based on a specific duration of '3 minutes'.", "Select the required fields: We need to find the maximum and minimum resolution of the filtered songs.", "Construct the SQL query: Use the SELECT statement to get the MAX and MIN of the resolution column, applying the WHERE clause for the duration."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "pred_sql": "SELECT MAX(resolution) AS max_resolution, MIN(resolution) AS min_resolution FROM song WHERE duration = '3 minutes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the subquery represents the language for which the minimum resolution is being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["Identify the columns needed: maximum duration and resolution of songs, grouped by languages.", "Use the MAX() function to get the maximum values for duration and resolution.", "Group the results by the 'languages' column to aggregate the data accordingly.", "Order the results by the 'languages' column for better readability."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "pred_sql": "SELECT languages, MAX(duration) AS max_duration, MAX(resolution) AS max_resolution \nFROM song \nGROUP BY languages \nORDER BY languages;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the relevant tables: 'song' and 'genre' are needed to get the song details and their corresponding genres.", "We need to find the shortest duration and lowest rating of songs, which requires using aggregate functions MIN() on the 'duration' and 'rating' columns from the 'song' table.", "To group the results by genre, we will use the GROUP BY clause on the 'g_name' column from the 'genre' table.", "To ensure we get the correct genre for each song, we will join the 'song' table with the 'genre' table on the genre name.", "Finally, we will order the results by genre name using the ORDER BY clause."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "pred_sql": "SELECT genre.g_name, MIN(song.duration) AS shortest_duration, MIN(song.rating) AS lowest_rating\nFROM song\nJOIN genre ON song.genre_is = genre.g_name\nGROUP BY genre.g_name\nORDER BY genre.g_name;", "hint": "\n"}
{"sample_id": "train.3607", "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["Identify the tables involved: We need information from the 'artist' table and the 'song' table.", "Determine the columns needed: We need the 'artist_name' and 'country' from the 'artist' table.", "Establish the relationship: The 'artist' table is related to the 'song' table through the 'artist_name' column.", "Filter the results: We need to filter songs based on the resolution being greater than 900.", "Use DISTINCT to avoid duplicate artist entries if they have multiple songs meeting the criteria."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"], "pred_sql": "SELECT DISTINCT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE song.resolution > 900;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3619", "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their languages and associated artists.", "Filter songs by language: We need to filter the songs to only include those where the language is 'Bangla'.", "Count the number of songs per artist: We will group the results by 'artist_name' and count the number of songs for each artist using COUNT(song_name).", "Order the results: To find the top artists, we will order the results in descending order based on the count of songs.", "Limit the results: Finally, we will limit the results to the top 3 artists."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist_name, COUNT(song_name) AS song_count \nFROM song \nWHERE languages = 'Bangla' \nGROUP BY artist_name \nORDER BY song_count DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3623", "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["Identify the relevant tables: 'song' for song details and 'files' for file details.", "Determine the columns needed: 'duration' from 'song', 'file_size' and 'formats' from 'files'.", "Establish the relationship between the tables: 'song' and 'files' are linked by 'f_id'.", "Filter the results to include only songs where the genre is 'pop'.", "Order the results by the song title, which is represented by 'song_name' in the 'song' table."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT song.duration, files.file_size, files.formats \nFROM song \nJOIN files ON song.f_id = files.f_id \nWHERE song.genre_is = 'pop' \nORDER BY song.song_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the required columns: duration, file size, and song format.", "Determine the relevant tables: 'song' for song details and 'files' for file details.", "Establish the relationship between the tables: 'song' and 'files' are linked by the 'f_id' column.", "Filter the results to include only pop songs by using a WHERE clause on the 'genre_is' column in the 'song' table.", "Order the results alphabetically by song title using the ORDER BY clause on the 'song_name' column."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT song.duration, files.file_size, files.formats \nFROM song \nJOIN files ON song.f_id = files.f_id \nWHERE song.genre_is = 'pop' \nORDER BY song.song_name ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct song titles from the 'song' table that have a resolution greater than the minimum resolution of songs available in a specific language. The placeholder in the WHERE clause represents the language being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the relevant tables: We need the 'salary' table to get the salary information and the 'team' table to filter by team name.", "Join the 'salary' table with the 'team' table on 'team_id' to associate salaries with the respective teams.", "Filter the results to only include the team named 'Boston Red Stockings'.", "Use the AVG() function to calculate the average salary of the players in that team."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "pred_sql": "SELECT AVG(s.salary) FROM salary AS s JOIN team AS t ON s.team_id = t.team_id WHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\",\n        \"virtual_table\": \"SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their birth countries.", "Group the data: We need to group the players by their birth country to count how many players are from each country.", "Count the players: Use the COUNT function to count the number of players for each country.", "Order the results: We want to order the countries by the count of players in ascending order to find the countries with the least players.", "Limit the results: We only need the top three countries with the least players, so we will use the LIMIT clause."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of countries where players were born, grouped by country and ordered by the number of players from each country in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of countries to return.\",\n        \"virtual_table\": \"SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["Identify the tables needed: 'team' for team names and IDs, and 'salary' for salary information.", "Join the 'team' table with the 'salary' table on 'team_id' to associate each team with its salaries.", "Use the MAX() function to find the highest salary for each team.", "Group the results by 'team_id' and 'team name' to ensure we get the maximum salary for each team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T1.name, T1.team_id, MAX(T2.salary) AS max_salary \nFROM team AS T1 \nJOIN salary AS T2 ON T1.team_id = T2.team_id \nGROUP BY T1.team_id, T1.name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["We need to retrieve the team name, team id, and the maximum salary for each team.", "The relevant tables for this query are 'team' and 'salary'.", "We will join the 'team' table with the 'salary' table on the 'team_id' column, which is common to both tables.", "To find the maximum salary for each team, we will use the MAX() function on the 'salary' column from the 'salary' table.", "We will group the results by 'team.team_id' and 'team.name' to ensure we get one result per team."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id, MAX(salary.salary) AS max_salary\nFROM team\nJOIN salary ON team.team_id = salary.team_id\nGROUP BY team.team_id, team.name;", "hint": "\n"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["Identify the relevant tables: 'team' for team names and IDs, and 'salary' for salary information.", "Join the 'team' and 'salary' tables on 'team_id' to associate teams with their salaries.", "Group the results by 'team_id' to calculate the average salary for each team.", "Use the AVG() function to compute the average salary for each team.", "Order the results in ascending order based on the average salary to find the lowest.", "Limit the results to 1 to get only the team with the lowest average salary."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.name, team.team_id\nFROM team\nJOIN salary ON team.team_id = salary.team_id\nGROUP BY team.team_id\nORDER BY AVG(salary.salary) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["We need to find players who won awards in both 1960 and 1961.", "The relevant table for player awards is 'player_award', which contains the player_id and the year they won an award.", "We will join the 'player' table to get the first and last names of the players.", "To find players who won awards in both years, we will perform a self-join on the 'player_award' table, filtering for the years 1960 and 1961."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM player p \nJOIN player_award pa1 ON p.player_id = pa1.player_id \nJOIN player_award pa2 ON p.player_id = pa2.player_id \nWHERE pa1.year = '1960' AND pa2.year = '1961';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["Identify the relevant table: The 'player' table contains the necessary columns for player names, weight, and height.", "Determine the columns to select: We need to select 'name_first' and 'name_last' for the players.", "Establish the conditions: We want players with a weight greater than 220 or a height shorter than 75.", "Construct the SQL query: Combine the selected columns and conditions into a valid SQL SELECT statement."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a specified year of death. The placeholder in the WHERE clause represents the year of death.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the conditions: We need players with a weight greater than 220 or a height less than 75.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team names.", "Join the 'postseason' table with the 'team' table on the winning team ID to get the team names associated with the postseason results.", "Filter the results to only include the Boston Red Stockings by using a WHERE clause.", "Select the maximum wins from the postseason results for the Boston Red Stockings using the MAX() function."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason AS p\nJOIN team AS t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team names.", "Join the 'postseason' table with the 'team' table on the winning team identifier.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Select the maximum wins from the filtered results to find the highest score the team achieved when they won in the postseason."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(p.wins) AS max_wins\nFROM postseason AS p\nJOIN team AS t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3672", "db_id": "baseball_1", "question": "For each year, return the year and the number of times the team Boston Red Stockings won in the postseasons.", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team names.", "Join the 'postseason' table with the 'team' table on the winning team ID to filter for the Boston Red Stockings.", "Use a WHERE clause to specify that we are only interested in rows where the team name is 'Boston Red Stockings'.", "Group the results by year to count the number of wins for each year.", "Select the year and the count of wins for the final output."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "pred_sql": "SELECT p.year, COUNT(p.team_id_winner) AS wins\nFROM postseason AS p\nJOIN team AS t ON p.team_id_winner = t.team_id\nWHERE t.name = 'Boston Red Stockings'\nGROUP BY p.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3677", "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant tables: salary and team.", "We need to calculate the total salary, so we will use the SUM function on the salary column from the salary table.", "We need to join the salary table with the team table to filter by the team name 'Boston Red Stockings'.", "The join condition is based on the team_id column from both tables.", "We also need to filter the results for the year 2010.", "Construct the SQL query using the identified tables, join condition, and filters."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT SUM(salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id WHERE T2.name = 'Boston Red Stockings' AND T1.year = 2010;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total attendance for home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the attendance data.\",\n        \"virtual_table\": \"SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table for salary information, which is the 'salary' table.", "Filter the records to only include those from the year 2001 using the WHERE clause.", "Order the results by salary in descending order to get the highest salaries first.", "Limit the results to the top 3 entries using the LIMIT clause."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3682", "db_id": "baseball_1", "question": "How much salary did the top 3 well-paid players get in 2001?", "rationale": ["Identify the relevant table: The salary table contains the salary information for players.", "Filter by year: We need to focus on the year 2001, so we will add a WHERE clause to filter the records for that year.", "Select the top 3 salaries: To get the top 3 well-paid players, we will order the results by salary in descending order and limit the results to 3 using ORDER BY and LIMIT clauses."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3683", "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["Identify the relevant table: The salary table contains the salary information for players.", "Determine the years of interest: The user is interested in the years 2010 and 2001.", "Construct the SQL query: Use a SELECT statement to retrieve the salary values from the salary table where the year is either 2010 or 2001."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT salary FROM salary WHERE year IN (2010, 2001);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["To find the year with the least number of players inducted into the Hall of Fame, we need to count the number of inductees for each year.", "We can achieve this by using a GROUP BY clause on the 'yearid' column in the 'hall_of_fame' table and applying the COUNT function to count the number of players for each year.", "Next, we need to order the results by the count of inductees in ascending order to get the year with the least inductees at the top.", "Finally, we can limit the results to just one record to get the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid FROM (SELECT yearid, COUNT(*) as inductee_count FROM hall_of_fame GROUP BY yearid) ORDER BY inductee_count ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "To do this, we can use a SQL query that counts the number of players inducted for each year.", "The hint provides a virtual table that summarizes the number of players inducted into the Hall of Fame for each year using the COUNT function and grouping by year.", "We will then order the results in ascending order based on the count of inductees to find the year with the least.", "Finally, we will limit the results to just one year using LIMIT 1."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of players inducted into the Hall of Fame for each year. The placeholder in the SELECT statement represents the year of induction, and the count function aggregates the total number of inductees per year.\",\n        \"virtual_table\": \"SELECT yearid ,  count(*) FROM hall_of_fame GROUP BY yearid;\"\n    }\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: 'home_game' for games played and 'park' for park names.", "We need to filter the 'home_game' table for the year 1907 and the specific park 'Columbia Park'.", "To do this, we will use a subquery to find the 'park_id' corresponding to 'Columbia Park' from the 'park' table.", "Finally, we will sum the 'games' column from the 'home_game' table where the year is 1907 and the park_id matches the one found in the subquery."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) FROM home_game WHERE year = '1907' AND park_id = (SELECT park_id FROM park WHERE park_name = 'Columbia Park');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: 'home_game' for home games and 'park' for park names.", "Join the 'home_game' table with the 'park' table on the 'park_id' to access park names associated with home games.", "Filter the results for the year 1907 and the park name 'Columbia Park'.", "Count the number of games that match these criteria using COUNT(*) function."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT COUNT(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant tables: home_game and team.", "We need to sum the total number of games played in Atlanta in the year 2000.", "Join the home_game table with the team table on the team_id to access the city information.", "Filter the results to only include games played in Atlanta for the year 2000.", "Use the SUM function to calculate the total number of games played."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.city = 'Atlanta' AND T1.year = 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: home_game and team.", "We need to sum the number of games played in Atlanta in the year 2000.", "Join the home_game table with the team table on the team_id to access the city information.", "Filter the results to only include games played in Atlanta and in the year 2000."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.city = 'Atlanta' AND T1.year = 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total number of home games played by a specific team over a range of years. The placeholders represent the team's name and the start and end years for the query.\",\n        \"virtual_table\": \"SELECT sum(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T2.name = [PLACEHOLDER-TYPE:STRING] AND T1.year BETWEEN [PLACEHOLDER-TYPE:NUMBER] AND [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3693", "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["Identify the relevant tables: home_game and team.", "We need to sum the attendance from the home_game table.", "Join the home_game table with the team table to filter by team name.", "Filter the results for the team 'Boston Red Stockings'.", "Add a condition to limit the years from 2000 to 2010.", "Use the SUM function to calculate the total attendance."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT SUM(attendance) AS total_attendance \nFROM home_game AS hg \nJOIN team AS t ON hg.team_id = t.team_id \nWHERE t.name = 'Boston Red Stockings' \nAND hg.year BETWEEN 2000 AND 2010;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3698", "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["Identify the relevant tables: We need the 'player' table for player names and the 'salary' table for salary records.", "Join the 'player' table with the 'salary' table on 'player_id' to get the names of players along with their salary information.", "Filter the results to include only those players who were paid by the 'Washington Nationals' team. This requires a subquery to get the 'team_id' for 'Washington Nationals'.", "We need to check for players who have salary records for both 2005 and 2007. This can be done using the 'WHERE' clause to filter by year and 'GROUP BY' to group results by player.", "Use 'HAVING COUNT(DISTINCT s.year) = 2' to ensure that only players with salary records for both years are included in the final result."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT p.name_first, p.name_last \nFROM player p \nJOIN salary s ON p.player_id = s.player_id \nWHERE s.team_id = (SELECT team_id FROM team WHERE name = 'Washington Nationals') \nAND s.year IN (2005, 2007) \nGROUP BY p.player_id \nHAVING COUNT(DISTINCT s.year) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players from the 'player' table who have a recorded year of death. The placeholder in the WHERE clause represents the specific year of death being queried.\",\n        \"virtual_table\": \"SELECT name_first ,  name_last FROM player WHERE death_year = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant tables: 'home_game' for home games and 'team' for team names.", "Join the 'home_game' table with the 'team' table on 'team_id' to get the team names associated with the home games.", "Filter the results for the year 1980 using a WHERE clause.", "Order the results by attendance in ascending order to find the team with the least number of home games.", "Limit the results to 1 to get only the team with the least attendance."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of teams that hosted home games in a specific year, ordered by their attendance in ascending order. The placeholders represent the year of the home games and the limit on the number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3709", "db_id": "baseball_1", "question": "Which park had most attendances in 2008?", "rationale": ["Identify the relevant tables: home_game for attendance and park for park names.", "Join the home_game table with the park table on the park_id to get park names associated with attendance records.", "Filter the results for the year 2008 using a WHERE clause.", "Order the results by attendance in descending order to get the park with the highest attendance.", "Limit the results to 1 to get only the park with the most attendance."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of park names where home games were played in a specific year, ordered by attendance in descending order. The placeholders represent the year of the home games and the limit on the number of park names to return.\",\n        \"virtual_table\": \"SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] ORDER BY T1.attendance DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3857", "db_id": "insurance_policies", "question": "Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.", "rationale": ["Identify the need to find the settlement amount of the claim with the largest claim amount.", "The largest claim amount can be found using a subquery that selects the maximum value from the 'Amount_Claimed' column in the 'Claims' table.", "Once the largest claim amount is identified, we can select the corresponding 'Amount_Settled' from the 'Claims' table where 'Amount_Claimed' matches the maximum value found in the subquery."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "pred_sql": "SELECT Amount_Settled, Amount_Claimed FROM Claims WHERE Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claims)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3862", "db_id": "insurance_policies", "question": "Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find settlements where the claimed amount is no more than the average claimed amount.", "To do this, we will join the Claims table with the Settlements table on the Claim_ID.", "We will use a subquery to calculate the average claimed amount from the Claims table.", "Finally, we will select the Start_Date from the Claims table for those settlements that meet the criteria."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT c.Start_Date \nFROM Claims AS cl \nJOIN Settlements AS s ON cl.Claim_ID = s.Claim_ID \nWHERE s.Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the amounts settled and claimed for insurance claims from the 'Claims' table. The results are ordered by the settled amount in ascending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Settled ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3863", "db_id": "insurance_policies", "question": "Return the claim start date for the claims whose claimed amount is no more than the average", "rationale": ["Identify the relevant table: The 'Claims' table contains the information about claims, including the claimed amount and the date the claim was made.", "Determine the condition: We need to find claims where the claimed amount is no more than the average claimed amount. This requires calculating the average of the 'Amount_Claimed' column in the 'Claims' table.", "Construct the subquery: The subquery will calculate the average claimed amount using 'SELECT AVG(Amount_Claimed) FROM Claims'.", "Combine the main query and the subquery: The main query selects the 'Date_Claim_Made' from the 'Claims' table where the 'Amount_Claimed' is less than or equal to the average calculated in the subquery."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT c.Date_Claim_Made \nFROM Claims c \nWHERE c.Amount_Claimed <= (SELECT AVG(Amount_Claimed) FROM Claims)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the amounts claimed and settled for insurance claims from the 'Claims' table. The results are ordered by the claimed amount in descending order, and the placeholder allows for limiting the number of records returned.\",\n        \"virtual_table\": \"SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3868", "db_id": "insurance_policies", "question": "How many settlements were made on the claim with the most recent claim settlement date? List the number and the claim id.", "rationale": ["Identify the need to count settlements for claims with the most recent settlement date.", "Use the provided virtual table to count the number of settlements associated with each claim.", "Filter the results to only include claims that have the most recent settlement date by using a subquery to find the maximum settlement date.", "Group the results by Claim_ID to get the count of settlements for each claim."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT Claim_ID, COUNT(*) AS Settlement_Count \nFROM Claims AS T1 \nJOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID \nWHERE T2.Date_Claim_Settled = (SELECT MAX(Date_Claim_Settled) FROM Settlements) \nGROUP BY T1.Claim_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count reflects the number of settlements linked to that claim.\",\n        \"virtual_table\": \"SELECT T1.Claim_id ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id\"\n    }\n}\n"}
{"sample_id": "train.3869", "db_id": "insurance_policies", "question": "Find the claim id and the number of settlements made for the claim with the most recent settlement date.", "rationale": ["We need to find the claim ID and the number of settlements for the claim with the most recent settlement date.", "The hint provides a virtual table that counts the number of settlements for each claim by joining the Claims and Settlements tables.", "To find the most recent settlement date, we can use a subquery that selects the maximum Date_Claim_Settled from the Settlements table.", "We will join the Claims table with the Settlements table on Claim_ID to get the relevant data.", "Finally, we will group the results by Claim_ID to get the count of settlements for each claim."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT T1.Claim_ID, COUNT(*) AS Number_of_Settlements \nFROM Claims AS T1 \nJOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID \nWHERE T2.Date_Claim_Settled = (\n    SELECT MAX(Date_Claim_Settled) \n    FROM Settlements\n) \nGROUP BY T1.Claim_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count reflects the number of settlements linked to that claim.\",\n        \"virtual_table\": \"SELECT T1.Claim_id ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id\"\n    }\n}\n"}
{"sample_id": "train.3878", "db_id": "insurance_policies", "question": "What is the most popular payment method?", "rationale": ["Identify the table relevant to payment methods, which is the 'Payments' table.", "To find the most popular payment method, we need to group the records by 'Payment_Method_Code'.", "We will count the occurrences of each payment method using the COUNT function.", "To determine popularity, we will order the results in descending order based on the count of each payment method.", "Finally, we will limit the results to 1 to get the most popular payment method."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.\",\n        \"virtual_table\": \"SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3879", "db_id": "insurance_policies", "question": "Which payment method is used the most often?", "rationale": ["Identify the table relevant to the question: The 'Payments' table contains information about payment transactions, including the payment method used.", "Determine the goal: We want to find out which payment method is used the most often.", "Group the results by 'Payment_Method_Code' to count the occurrences of each payment method.", "Order the results in descending order based on the count of each payment method to get the most frequently used method at the top.", "Limit the results to 1 to retrieve only the most frequently used payment method."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.\",\n        \"virtual_table\": \"SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3880", "db_id": "insurance_policies", "question": "With which kind of payment method were the least number of payments processed?", "rationale": ["Identify the table relevant to payment methods, which is the 'Payments' table.", "We need to group the results by 'Payment_Method_Code' to count the number of payments for each method.", "Use the COUNT function to count the number of payments for each payment method.", "Order the results in ascending order based on the count of payments to find the least used payment method.", "Limit the results to 1 to get only the payment method with the least number of payments."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique payment method codes used in the 'Payments' table, grouped by the method code and ordered by the frequency of each method in ascending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of payment methods to retrieve.\",\n        \"virtual_table\": \"SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3886", "db_id": "insurance_policies", "question": "Which kind of policy type was chosen by the most customers?", "rationale": ["Identify the relevant table: The question pertains to the types of insurance policies, which are stored in the 'Customer_Policies' table.", "Group by policy type: To find out which policy type was chosen by the most customers, we need to group the records in 'Customer_Policies' by 'Policy_Type_Code'.", "Count the occurrences: We will count the number of occurrences of each policy type using the COUNT function.", "Order by frequency: To determine the most chosen policy type, we will order the results in descending order based on the count of each policy type.", "Limit the results: Since we only want the most chosen policy type, we will limit the results to 1."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "pred_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies from the 'Customer_Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.\",\n        \"virtual_table\": \"SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3893", "db_id": "insurance_policies", "question": "Which customers do not have any policies? Find the details of these customers.", "rationale": ["Identify the Customers table to retrieve customer details.", "Determine the criteria for customers without policies, which means their Customer_ID should not exist in the Customer_Policies table.", "Use a subquery to select all Customer_IDs from the Customer_Policies table.", "Use the NOT IN clause to filter out those Customer_IDs from the Customers table."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "pred_sql": "SELECT * FROM Customers WHERE Customer_ID NOT IN (SELECT Customer_ID FROM Customer_Policies);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of insurance policies from the 'Customer_Policies' table, grouping them by their policy type code. The placeholder in the LIMIT clause allows the user to specify the maximum number of policy types to retrieve, sorted by the frequency of each type in descending order.\",\n        \"virtual_table\": \"SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3895", "db_id": "insurance_policies", "question": "Which claims had exactly one settlement? For each, tell me the the date the claim was made, the date it was settled and the amount settled.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find claims that have exactly one settlement, so we will use a subquery to count the number of settlements for each claim.", "The subquery will join the Claims table with the Settlements table, grouping by Claim_ID and using HAVING COUNT(*) = 1 to filter for claims with exactly one settlement.", "In the main query, we will select the required fields: Date_Claim_Made, Date_Claim_Settled, and Amount_Settled from the Claims and Settlements tables.", "We will join the Claims table with the Settlements table on Claim_ID and filter the results using the IN clause with the subquery."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT C.Date_Claim_Made, C.Date_Claim_Settled, S.Amount_Settled \nFROM Claims AS C \nJOIN Settlements AS S ON C.Claim_ID = S.Claim_ID \nWHERE C.Claim_ID IN (\n    SELECT T1.Claim_ID \n    FROM Claims AS T1 \n    JOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID \n    GROUP BY T1.Claim_ID \n    HAVING COUNT(*) = 1\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of settlements associated with each insurance claim from the 'Claims' table. The placeholder in the SELECT statement represents the unique identifier for each claim, while the count reflects the number of settlements linked to that claim.\",\n        \"virtual_table\": \"SELECT T1.Claim_id ,  count(*) FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id\"\n    }\n}\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees (physicians) in each department.", "Join the Department table with the Physician table on the Head of the department.", "Group the results by DepartmentID to get the count of physicians per department.", "Order the results by the count of physicians in descending order to find the department with the most employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(p.EmployeeID) AS EmployeeCount\nFROM Department d\nLEFT JOIN Physician p ON d.Head = p.EmployeeID\nGROUP BY d.DepartmentID\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["Identify the relevant tables: Department and Affiliated_With.", "Join the Department table with the Affiliated_With table on the DepartmentID to get the count of physicians in each department.", "Group the results by DepartmentID to aggregate the count of physicians per department.", "Order the results by the count of physicians in descending order to find the department with the most employees.", "Limit the results to 1 to get only the top department."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(a.Physician) AS EmployeeCount\nFROM Department d\nJOIN Affiliated_With a ON d.DepartmentID = a.Department\nGROUP BY d.DepartmentID\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["Identify the department with the least employees by counting the number of physicians affiliated with each department.", "Use the Affiliated_With table to count the number of physicians per department.", "Order the results by the count of physicians in ascending order to find the department with the least employees.", "Limit the results to 1 to get the department with the least employees.", "Once the department with the least employees is identified, retrieve the head of that department from the Department table."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Head FROM Department WHERE DepartmentID = (SELECT DepartmentID FROM Affiliated_With GROUP BY Department ORDER BY COUNT(Physician) ASC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["Identify the head of each department by joining the 'Department' table with the 'Physician' table on the 'Head' column.", "To find the department with the least number of employees, use the 'Affiliated_With' table to count the number of physicians affiliated with each department.", "Group the results by 'DepartmentID' and order them by the count of physicians in ascending order, limiting the result to the first entry to get the department with the least employees.", "Use the 'DepartmentID' from the previous step to filter the 'Department' table and get the corresponding head's name and position."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Department \nJOIN Physician ON Department.Head = Physician.EmployeeID \nWHERE Department.DepartmentID = \n  (SELECT DepartmentID \n   FROM Affiliated_With \n   GROUP BY DepartmentID \n   ORDER BY COUNT(Physician) \n   LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["Identify the department with the least employees by counting the number of physicians affiliated with each department.", "Use a subquery to select the DepartmentID of the department with the least number of affiliated physicians, ordering by the count and limiting the result to 1.", "Join the Department table with the Physician table to get the names and positions of the heads of the departments.", "Select the Name and Position of the physician who is the head of the department identified in the subquery."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Department \nJOIN Physician ON Department.Head = Physician.EmployeeID \nWHERE Department.DepartmentID = (SELECT DepartmentID \n                                  FROM Affiliated_With \n                                  GROUP BY DepartmentID \n                                  ORDER BY COUNT(Physician) \n                                  LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department heads from the 'Department' table, grouped by their department identifiers. The result is ordered by the count of departments, and a placeholder is used to limit the number of results returned.\",\n        \"virtual_table\": \"SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["Identify the relevant tables: Patient and Appointment.", "We need to find the names of patients who have made appointments, which means we need to join the Patient table with the Appointment table.", "The join condition will be based on the Patient's SSN matching the Patient field in the Appointment table.", "We will select the distinct names of patients to avoid duplicates, as a patient can have multiple appointments."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT Patient.Name \nFROM Patient \nJOIN Appointment ON Patient.SSN = Appointment.Patient;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables needed: Physician, Department, and Affiliated_With.", "We need to join the Affiliated_With table with the Physician and Department tables to get the names of physicians and their affiliated departments.", "The join condition will be based on the foreign keys: Affiliated_With.Physician with Physician.EmployeeID and Affiliated_With.Department with Department.DepartmentID.", "We need to filter the results to only include primary affiliations, which is indicated by the PrimaryAffiliation column in the Affiliated_With table.", "The final query will select the names of physicians and their corresponding department names."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT Physician.Name, Department.Name \nFROM Affiliated_With \nJOIN Physician ON Affiliated_With.Physician = Physician.EmployeeID \nJOIN Department ON Affiliated_With.Department = Department.DepartmentID \nWHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["Identify the tables needed: Physician and Patient.", "We need to join these tables to relate physicians to their patients. The relationship is established through the Patient's PCP (Primary Care Physician) which references the Physician's EmployeeID.", "Use a LEFT JOIN to ensure we include physicians even if they have no patients.", "Count the number of patients for each physician using COUNT(Patient.SSN).", "Group the results by Physician's name to get the count for each physician."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name, COUNT(Patient.SSN) AS NumberOfPatients\nFROM Physician\nLEFT JOIN Patient ON Physician.EmployeeID = Patient.PCP\nGROUP BY Physician.Name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["Identify the relevant tables: Physician and Patient.", "Determine the relationship: A physician can be a primary care physician (PCP) for multiple patients.", "Join the Physician table with the Patient table on the PCP field.", "Group the results by Physician's EmployeeID to count the number of patients per physician.", "Use the HAVING clause to filter for physicians who have more than one patient."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT Physician.Name\nFROM Physician\nJOIN Patient ON Physician.EmployeeID = Patient.PCP\nGROUP BY Physician.EmployeeID\nHAVING COUNT(Patient.SSN) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["Identify the relevant tables: Prescribes, Physician, and Medication are needed to find the names of physicians who prescribe a specific medication.", "Join the Prescribes table with the Physician table on the Physician identifier to get the names of the physicians.", "Join the Prescribes table with the Medication table on the Medication identifier to filter by the medication name 'Thesisin'.", "Use a WHERE clause to specify that we are only interested in prescriptions for the medication 'Thesisin'.", "Select distinct names of physicians to avoid duplicates in the result."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT DISTINCT Physician.Name \nFROM Prescribes \nJOIN Physician ON Prescribes.Physician = Physician.EmployeeID \nJOIN Medication ON Prescribes.Medication = Medication.Code \nWHERE Medication.Name = 'Thesisin';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication.", "We need to find the names of physicians who prescribe a specific medication, which is 'Thesisin'.", "Join the Physician table with the Prescribes table on the EmployeeID and Physician columns respectively.", "Join the Prescribes table with the Medication table on the Medication column.", "Filter the results to only include rows where the medication name is 'Thesisin'.", "Select the Name column from the Physician table to get the names of the physicians."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT Physician.Name \nFROM Physician \nJOIN Prescribes ON Physician.EmployeeID = Prescribes.Physician \nJOIN Medication ON Prescribes.Medication = Medication.Code \nWHERE Medication.Name = 'Thesisin';", "hint": "\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["Identify the relevant tables: Medication and Prescribes.", "We need to count the number of medications prescribed for each brand, so we will join the Medication table with the Prescribes table on the medication code.", "Select the brand from the Medication table and count the number of prescriptions from the Prescribes table.", "Group the results by the brand to get the count for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT m.Brand, COUNT(p.Medication) AS NumberOfMedications\nFROM Medication m\nJOIN Prescribes p ON m.Code = p.Medication\nGROUP BY m.Brand;", "hint": "\n"}
{"sample_id": "train.3948", "db_id": "hospital_1", "question": "Find the patient who has the most recent undergoing treatment?", "rationale": ["Identify the relevant tables: The 'Undergoes' table contains information about patients undergoing procedures, including the date of the procedures.", "To find the most recent undergoing treatment, we need to order the records in the 'Undergoes' table by the 'DateUndergoes' column in descending order.", "Using 'LIMIT 1' will allow us to retrieve only the most recent record.", "The final SQL query selects the 'Patient' from the 'Undergoes' table, orders by 'DateUndergoes' in descending order, and limits the result to 1."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT u.Patient\nFROM Undergoes u\nORDER BY u.DateUndergoes DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["Identify the relevant tables: Patient and Undergoes are the main tables needed to find the patient undergoing treatment.", "Join the Patient table with the Undergoes table on the Patient's SSN to link patients with their treatments.", "Order the results by the DateUndergoes in descending order to get the most recent treatment first.", "Limit the results to 1 to get only the most recent patient undergoing treatment."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT Patient.Name\nFROM Patient\nJOIN Undergoes ON Patient.SSN = Undergoes.Patient\nORDER BY Undergoes.DateUndergoes DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: Prescribes for prescriptions and Physician for physician details.", "We need to find the physician who prescribed the highest dose, so we will use the MAX function on the Dose column in the Prescribes table.", "To get the physician's name, we will join the Prescribes table with the Physician table on the Physician identifier (EmployeeID).", "The final query will select the name of the physician where the dose is equal to the maximum dose found in the subquery."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT Physician.Name\nFROM Prescribes\nJOIN Physician ON Prescribes.Physician = Physician.EmployeeID\nWHERE Prescribes.Dose = (SELECT MAX(Dose) FROM Prescribes);", "hint": "\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["We need to list the employee IDs of physicians along with their primary affiliation department IDs.", "The relevant tables for this query are 'Physician' and 'Affiliated_With'.", "We will join the 'Physician' table with the 'Affiliated_With' table on the common column 'EmployeeID' from 'Physician' and 'Physician' from 'Affiliated_With'.", "We need to filter the results to only include those records where the 'PrimaryAffiliation' is marked as 'Yes'.", "Finally, we will select the 'EmployeeID' from the 'Physician' table and the 'Department' from the 'Affiliated_With' table."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT Physician.EmployeeID, Affiliated_With.Department FROM Physician JOIN Affiliated_With ON Physician.EmployeeID = Affiliated_With.Physician WHERE Affiliated_With.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct department names from the 'Department' table that are associated with physicians based on their primary affiliation. The placeholder in the WHERE clause represents whether the affiliation is primary or not.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.name FROM affiliated_with AS T1 JOIN department AS T2 ON T1.department = T2.departmentid WHERE PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["Identify the table that contains procedure information, which is the Procedures table.", "Determine the relevant columns needed for the query: Name and Cost of the procedures.", "To find the most costly procedures, sort the results by the Cost column in descending order.", "Limit the results to the top three entries to get the three most costly procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name, Cost FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "\n"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find physicians who are trained in specific procedures, so we will join the Physician table with the Trained_In table on the Physician's EmployeeID.", "Next, we join the Trained_In table with the Procedures table on the Treatment code to access the cost of the procedures.", "We need to filter the results to only include procedures that cost more than 5000, so we will add a WHERE clause for Procedures.Cost > 5000.", "Finally, we select the distinct names of the physicians to avoid duplicates."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT DISTINCT Physician.Name\nFROM Physician\nJOIN Trained_In ON Physician.EmployeeID = Trained_In.Physician\nJOIN Procedures ON Trained_In.Treatment = Procedures.Code\nWHERE Procedures.Cost > 5000;", "hint": "\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "We need to find the physician who was trained in the most expensive procedure, so we will join the Physician table with the Trained_In table on the physician's identifier.", "Next, we will join the Trained_In table with the Procedures table on the treatment code to access the cost of the procedures.", "To find the most expensive procedure, we will use a subquery to select the maximum cost from the Procedures table.", "Finally, we will filter the results to only include the physician(s) associated with the most expensive procedure and select their names."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT p.Name\nFROM Physician p\nJOIN Trained_In t ON p.EmployeeID = t.Physician\nJOIN Procedures pr ON t.Treatment = pr.Code\nWHERE pr.Cost = (SELECT MAX(Cost) FROM Procedures);", "hint": "\n"}
{"sample_id": "train.3980", "db_id": "hospital_1", "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.", "rationale": ["Identify the relevant tables: Procedures and Trained_In, and Physician.", "We need to find procedures that either cost more than 1000 or are associated with the physician named John Wen.", "Use a LEFT JOIN to connect Procedures with Trained_In on the procedure code and then join with Physician on the physician's EmployeeID.", "In the WHERE clause, specify the conditions: Procedures.Cost > 1000 or the Physician's Name is 'John Wen'.", "Select the distinct names of the procedures that meet either of these conditions."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT DISTINCT Procedures.Name \nFROM Procedures \nLEFT JOIN Trained_In ON Procedures.Code = Trained_In.Treatment \nLEFT JOIN Physician ON Trained_In.Physician = Physician.EmployeeID \nWHERE Procedures.Cost > 1000 OR Physician.Name = 'John Wen';", "hint": "\n"}
{"sample_id": "train.3993", "db_id": "hospital_1", "question": "How many patients are not using Procrastin-X as medication?", "rationale": ["Identify the main goal: Count the number of patients not using 'Procrastin-X' as medication.", "To find patients not using 'Procrastin-X', we need to first identify which patients are using it. This can be done by querying the 'Prescribes' table where the medication matches 'Procrastin-X'.", "The 'Medication' table can be used to get the unique code for 'Procrastin-X'.", "We will use a subquery to find all patients who have prescribed 'Procrastin-X' and then count all patients whose SSN is not in that list.", "The final SQL query will count the total number of patients from the 'Patient' table whose SSN is not in the list of patients using 'Procrastin-X'."], "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"], "pred_sql": "SELECT COUNT(*) AS PatientCount \nFROM Patient \nWHERE SSN NOT IN (\n    SELECT Patient \n    FROM Prescribes \n    WHERE Medication = (SELECT Code FROM Medication WHERE Name = 'Procrastin-X')\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of patients currently staying in a specific room, ordered by the start date of their stay in descending order. The placeholders represent the room number and the limit on the number of patients to retrieve.\",\n        \"virtual_table\": \"SELECT patient FROM stay WHERE room  =  [PLACEHOLDER-TYPE:NUMBER] ORDER BY staystart DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4256", "db_id": "club_1", "question": "What are the first names of all the students?", "rationale": ["The question asks for the first names of all students, which corresponds to the 'Fname' column in the 'Student' table.", "To retrieve the first names, we need to select the 'Fname' column from the 'Student' table without any conditions or filters, as we want all students.", "The SQL query will be a simple SELECT statement that specifies the column to retrieve from the specified table."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "pred_sql": "SELECT Fname FROM Student;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4271", "db_id": "club_1", "question": "Give me the first name and last name for all the female members of the club \"Bootup Baltimore\".", "rationale": ["Identify the tables needed: We need data from the Student, Member_of_club, and Club tables.", "Determine the columns to select: We need the first name (Fname) and last name (LName) of female members.", "Establish the relationships: We will join the Student table with the Member_of_club table on StuID, and then join the Member_of_club table with the Club table on ClubID.", "Filter the results: We need to filter for female students (Sex = 'Female') and for the specific club (ClubName = 'Bootup Baltimore').", "Construct the SQL query using the SELECT statement with the necessary JOINs and WHERE conditions."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Fname, LName FROM Student AS s JOIN Member_of_club AS m ON s.StuID = m.StuID JOIN Club AS c ON m.ClubID = c.ClubID WHERE s.Sex = 'Female' AND c.ClubName = 'Bootup Baltimore';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4277", "db_id": "club_1", "question": "Find the club which has the largest number of members majoring in \"600\".", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "We need to count the number of members in each club who are majoring in '600'.", "Join the Club table with the Member_of_club table on ClubID to link clubs with their members.", "Join the resulting table with the Student table on StuID to access the major of each student.", "Filter the results to include only those students whose Major is '600'.", "Group the results by ClubID to count the number of members per club.", "Order the results by the count of members in descending order to find the club with the most members majoring in '600'.", "Limit the results to 1 to get only the club with the largest number of members."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  '600' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT Club.ClubName, COUNT(Member_of_club.StuID) AS MemberCount \nFROM Club \nJOIN Member_of_club ON Club.ClubID = Member_of_club.ClubID \nJOIN Student ON Member_of_club.StuID = Student.StuID \nWHERE Student.Major = '600' \nGROUP BY Club.ClubID \nORDER BY MemberCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4278", "db_id": "club_1", "question": "Find the name of the club that has the most female students.", "rationale": ["Identify the tables involved: We need to get club names and count female students, so we will use the Student, Club, and Member_of_club tables.", "Join the tables: We will join the Club table with the Member_of_club table on ClubID, and then join the Member_of_club table with the Student table on StuID to get access to student details.", "Filter for female students: We will add a WHERE clause to filter the results to only include female students by checking the Sex column in the Student table.", "Group by club: We will group the results by ClubID to count the number of female students in each club.", "Count female students: We will use COUNT(s.StuID) to count the number of female students in each club.", "Order by count: We will order the results in descending order based on the count of female students to find the club with the most female members.", "Limit the results: Finally, we will limit the results to 1 to get only the club with the most female students."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT c.ClubName\nFROM Club c\nJOIN Member_of_club m ON c.ClubID = m.ClubID\nJOIN Student s ON m.StuID = s.StuID\nWHERE s.Sex = 'Female'\nGROUP BY c.ClubID\nORDER BY COUNT(s.StuID) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4312", "db_id": "club_1", "question": "List the clubs that have at least a member with advisor \"1121\".", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "We need to find clubs that have members with a specific advisor, so we will join the Club table with the Member_of_club table on ClubID, and then join the Member_of_club table with the Student table on StuID.", "We will filter the results based on the condition that the Advisor of the student is '1121'.", "We want to list the clubs, so we will select the ClubName from the Club table and use DISTINCT to avoid duplicates."], "gold_sql": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  1121", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT DISTINCT c.ClubName \nFROM Club AS c \nJOIN Member_of_club AS m ON c.ClubID = m.ClubID \nJOIN Student AS s ON m.StuID = s.StuID \nWHERE s.Advisor = '1121';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of clubs that a specific student is a member of, based on their first and last names. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.fname  =  [PLACEHOLDER-TYPE:STRING] AND t3.lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: Grants and Organisations are needed to get the total grant amount and the type of organisations.", "Join the Grants table with the Organisations table on the organisation_id to link grants to their respective organisations.", "Use a subquery to find organisation types that are associated with research staff. This subquery selects organisation types from the Organisations table that have entries in the Research_Staff table.", "The subquery groups the results by organisation type to ensure we get distinct types associated with research staff.", "The main query sums the grant amounts from the Grants table where the organisation type matches those found in the subquery."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT SUM(Grants.grant_amount) AS total_grant_amount \nFROM Grants \nJOIN Organisations ON Grants.organisation_id = Organisations.organisation_id \nWHERE Organisations.organisation_type IN \n(SELECT T1.organisation_type \n FROM Organisations AS T1 \n JOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id \n GROUP BY T1.organisation_type)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the role code for the leader role from the Staff_Roles table.", "Filter the Project_Staff table to find projects that have staff members with the leader role.", "Group the results by project_id and count the number of staff members for each project.", "Order the grouped results in descending order to find the project with the most staff members.", "Limit the results to the top project (the one with the most staff).", "Select the date_from and date_to for the staff members working on that project."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to \nFROM Project_Staff \nWHERE project_id = (\n    SELECT project_id \n    FROM Project_Staff \n    WHERE role_code = (SELECT role_code FROM Staff_Roles WHERE role_description = 'Leader') \n    GROUP BY project_id \n    ORDER BY COUNT(staff_id) DESC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4328", "db_id": "tracking_grants_for_research", "question": "Find the organisation ids and details of the organisations which are involved in", "rationale": ["The user wants to find the organisation ids and details of the organisations involved.", "We need to select the 'organisation_id' and 'organisation_details' from the 'Organisations' table.", "There is no specific filtering condition provided in the user's query, so we will select all organisations."], "gold_sql": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  6000", "source_tables": ["grants", "organisations"], "pred_sql": "SELECT organisation_id, organisation_details FROM Organisations", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the details of organisations from the 'Organisations' table that are associated with a specific type of organisation. It joins the 'Organisations' table with the 'Organisation_Types' table to filter organisations based on their type description. The placeholder in the WHERE clause represents the description of the organisation type, and the results are ordered by the organisation details.\",\n        \"virtual_table\": \"SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  [PLACEHOLDER-TYPE:STRING] ORDER BY organisation_details\"\n    }\n}\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields.", "Group the results by organisation type and organisation id to aggregate the number of research staff per organisation type.", "Order the results by the count of research staff in descending order to find the organisation type with the most research staff.", "Limit the results to 1 to get only the top organisation type and id."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT T1.organisation_type, T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id GROUP BY T1.organisation_type, T1.organisation_id ORDER BY count(T2.staff_id) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4331", "db_id": "tracking_grants_for_research", "question": "What is the type and id of the organization that has the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id respectively.", "Group the results by organisation_id to aggregate the number of research staff per organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most research staff.", "Limit the results to 1 to get only the top organisation with the most research staff.", "Select the organisation type and organisation id from the grouped results."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT T1.organisation_type, T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(T2.staff_id) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4333", "db_id": "tracking_grants_for_research", "question": "What is the type of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Determine the relationship between the tables: Research_Staff is linked to Organisations through employer_organisation_id.", "We need to group the results by organisation type to count the number of research staff in each type.", "Order the results by the count of research staff in descending order to find the type with the most staff.", "Limit the results to 1 to get only the top organisation type."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id = T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, Organisations, and Organisation_Types.", "Determine the columns needed: sent_date from Documents and grant_amount from Grants.", "Establish the relationships: Documents are linked to Grants via grant_id, Grants are linked to Organisations via organisation_id, and Organisations are linked to Organisation_Types via organisation_type.", "Filter the results based on the condition that grant_amount must be greater than 5000.", "Construct the SQL query using JOINs to combine the necessary tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT T1.sent_date FROM Documents AS T1 JOIN Grants AS T2 ON T1.grant_id = T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id = T3.organisation_id JOIN Organisation_Types AS T4 ON T3.organisation_type = T4.organisation_type WHERE T2.grant_amount > 5000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4335", "db_id": "tracking_grants_for_research", "question": "What are the send dates for all documents that have a grant amount of more than 5000 and are involved in research?", "rationale": ["Identify the relevant tables: Documents and Grants.", "We need to retrieve the 'sent_date' from the Documents table.", "We need to filter documents based on the grant amount from the Grants table, specifically those greater than 5000.", "Join the Documents table with the Grants table on the 'grant_id' to access the grant amount.", "Construct the SQL query to select 'sent_date' where the grant amount condition is met."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT T1.sent_date FROM Documents AS T1 JOIN Grants AS T2 ON T1.grant_id = T2.grant_id WHERE T2.grant_amount > 5000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4343", "db_id": "tracking_grants_for_research", "question": "When did researchers start and stop working?", "rationale": ["Identify the relevant table: Project_Staff contains information about staff members associated with projects, including their involvement dates.", "Determine the required fields: We need to know when researchers started and stopped working, which corresponds to the 'date_from' and 'date_to' columns in the Project_Staff table.", "Construct the SQL query: We will select 'date_from' and 'date_to' from the Project_Staff table, ensuring that we only include records where these dates are not null."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to FROM Project_Staff WHERE date_from IS NOT NULL AND date_to IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4349", "db_id": "tracking_grants_for_research", "question": "What are the details for the project whose research has been published?", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes.", "Determine the relationship: Projects have associated outcomes in Project_Outcomes.", "To find projects whose research has been published, we need to check for projects that have entries in the Project_Outcomes table.", "Use a subquery to select project_ids from Project_Outcomes and filter the Projects table based on these project_ids."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT * FROM Projects WHERE project_id IN (SELECT project_id FROM Project_Outcomes)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the tables involved: Projects and Project_Outcomes.", "We need to join these tables on the project_id to relate projects to their outcomes.", "We will select the project_details and project_id from the Projects table.", "To find the project with the most outcomes, we will group the results by project_id and count the outcomes for each project.", "We will order the results in descending order based on the count of outcomes.", "Finally, we will limit the results to 1 to get the project with the most outcomes."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT T1.project_details, T1.project_id FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Organisations and Research_Staff are needed to find the organisation that hired research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id respectively to link organisations with their staff.", "Group the results by organisation_id, organisation_type, and organisation_details to aggregate the number of research staff per organisation.", "Use COUNT(R.staff_id) to count the number of research staff for each organisation.", "Order the results in descending order to get the organisation with the most research staff at the top.", "Limit the results to 1 to get only the organisation that hired the most research staff."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT O.organisation_id, O.organisation_type, O.organisation_details \nFROM Organisations AS O \nJOIN Research_Staff AS R ON O.organisation_id = R.employer_organisation_id \nGROUP BY O.organisation_id, O.organisation_type, O.organisation_details \nORDER BY COUNT(R.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4361", "db_id": "tracking_grants_for_research", "question": "What are the ids, types, and details of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "Join the Organisations table with the Research_Staff table on the organisation_id and employer_organisation_id fields.", "Select the organisation_id, organisation_type, and organisation_details from the Organisations table.", "Group the results by organisation_id, organisation_type, and organisation_details to aggregate the research staff count for each organisation.", "Order the results by the count of research staff in descending order to find the organisation with the most research staff.", "Limit the results to 1 to get only the organisation with the highest count."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT O.organisation_id, O.organisation_type, O.organisation_details \nFROM Organisations AS O \nJOIN Research_Staff AS R ON O.organisation_id = R.employer_organisation_id \nGROUP BY O.organisation_id, O.organisation_type, O.organisation_details \nORDER BY COUNT(R.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["We need to find the role description for each staff member that is involved in the most number of projects.", "To do this, we will join the Project_Staff table with the Staff_Roles table on the role_code to get the role descriptions.", "We will count the distinct project_ids for each staff member to determine how many projects they are involved in.", "We will group the results by staff_id and role_description to aggregate the project counts for each role.", "Finally, we will order the results by the project count in descending order and limit the results to 1 to get the role with the most projects for each staff member."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT ps.staff_id, sr.role_description, COUNT(DISTINCT ps.project_id) AS project_count\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nGROUP BY ps.staff_id, sr.role_description\nORDER BY project_count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4367", "db_id": "tracking_grants_for_research", "question": "For grants that have descriptions of Regular and Initial Applications, what are their start dates?", "rationale": ["Identify the relevant tables: Grants, Documents, and Document_Types.", "We need to retrieve the start dates of grants, so we will select 'grant_start_date' from the Grants table.", "To filter the grants based on document descriptions, we will join the Documents table with the Grants table using 'grant_id'.", "Next, we will join the Document_Types table with the Documents table using 'document_type_code' to access the document descriptions.", "We will filter the results where the document descriptions are either 'Regular Applications' or 'Initial Applications' using the IN clause."], "gold_sql": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Regular' INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Initial Application'", "source_tables": ["grants", "document_types", "documents"], "pred_sql": "SELECT G.grant_start_date FROM Grants AS G JOIN Documents AS D ON G.grant_id = D.grant_id JOIN Document_Types AS DT ON D.document_type_code = DT.document_type_code WHERE DT.document_description IN ('Regular Applications', 'Initial Applications')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["We need to count the number of documents for each grant id.", "To do this, we will use the COUNT function on the document_id column from the Documents table.", "We will group the results by grant_id to get the count for each grant.", "To find the grant with the most documents, we will order the results by the document count in descending order.", "Finally, we will limit the results to 1 to get the grant with the most documents."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT D.grant_id, COUNT(D.document_id) AS document_count, D.document_id AS most_documents\nFROM Documents AS D\nGROUP BY D.grant_id\nORDER BY document_count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the response received dates of documents from the 'Documents' table, joining with 'Document_Types' to filter by a specific document description and with 'Grants' to filter by grant amount. The placeholders in the WHERE clause represent the document description and the grant amount criteria.\",\n        \"virtual_table\": \"SELECT T1.response_received_date FROM Documents AS T1 JOIN Document_Types AS T2 ON T1.document_type_code  =  T2.document_type_code JOIN Grants AS T3 ON T1.grant_id  =  T3.grant_id WHERE T2.document_description  =  [PLACEHOLDER-TYPE:STRING] OR T3.grant_amount  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4372", "db_id": "tracking_grants_for_research", "question": "What are all the details of the organisations described as 'Sponsor'? Sort the result in an ascending order.", "rationale": ["Identify the relevant table: Organisations contains the details of the organisations.", "Determine the filtering criteria: We need to filter organisations based on their type, specifically those described as 'Sponsor'.", "Find the organisation type code for 'Sponsor': This requires a subquery to the Organisation_Types table to get the organisation_type that corresponds to the description 'Sponsor'.", "Construct the main query: Select all columns from the Organisations table where the organisation_type matches the result of the subquery.", "Sort the results in ascending order based on organisation_id."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "pred_sql": "SELECT * FROM Organisations WHERE organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'Sponsor') ORDER BY organisation_id ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of organisation types associated with research staff, grouped by the organisation type. The results are ordered by the number of research staff in each organisation type, and the placeholder in the LIMIT clause allows for specifying the maximum number of organisation types to return.\",\n        \"virtual_table\": \"SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes.", "We need to find the project_id from the Projects table where the project_details match 'sint'.", "Once we have the project_id, we can retrieve the outcome_details from the Project_Outcomes table that corresponds to that project_id.", "The final SQL query combines these two steps using a subquery to filter the project_id based on the project_details."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT outcome_details FROM Project_Outcomes WHERE project_id IN (SELECT project_id FROM Projects WHERE project_details = 'sint')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant table for project details, which is the 'Projects' table.", "We need to find the project_id associated with the project detail 'sint'.", "Use a subquery to select project_id from the 'Projects' table where project_details = 'sint'.", "Next, we need to find the outcome details related to the project_id obtained from the previous step.", "The relevant table for project outcomes is 'Project_Outcomes', which contains outcome_code and outcome_details.", "Select outcome_details from 'Project_Outcomes' where project_id matches the project_id from the subquery."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT outcome_details FROM Project_Outcomes WHERE project_id IN (SELECT project_id FROM Projects WHERE project_details = 'sint')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.4383", "db_id": "tracking_grants_for_research", "question": "What is the id of the organization with the maximum number of outcomes and how many outcomes are there?", "rationale": ["Identify the tables involved: Organisations, Projects, and Project_Outcomes are relevant for this query.", "We need to count the number of outcomes associated with each organisation, which requires joining these tables.", "Join Organisations with Projects on organisation_id, and then join Projects with Project_Outcomes on project_id.", "Group the results by organisation_id to count the outcomes for each organisation.", "Order the results by the count of outcomes in descending order to find the organisation with the maximum outcomes.", "Limit the results to 1 to get only the organisation with the maximum number of outcomes."], "gold_sql": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT O.organisation_id, COUNT(PO.outcome_code) AS outcome_count \nFROM Organisations AS O \nJOIN Projects AS P ON O.organisation_id = P.organisation_id \nJOIN Project_Outcomes AS PO ON P.project_id = PO.project_id \nGROUP BY O.organisation_id \nORDER BY outcome_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4384", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects launched by the organisation", "rationale": ["Identify the main table to query: Projects, which contains project details.", "Determine the requirement: List project details for projects launched by organisations.", "Use a subquery to find organisations with the highest number of associated projects.", "Group the results by organisation_id to count the number of projects per organisation.", "Order the results in descending order based on the project count to prioritize organisations with more projects.", "Select the project_details from the Projects table where the organisation_id matches those from the subquery."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC )", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for organisations that have the highest number of associated projects. The placeholder in the LIMIT clause allows the user to specify the maximum number of organisations to retrieve based on their project count.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["Identify the relevant table: Project_Staff contains the staff roles and their involvement dates.", "Determine the columns needed: We need the role_code of the staff members.", "Use the provided hint to create a virtual table query that filters staff roles based on their involvement dates.", "Incorporate placeholders for the date range to filter the results accordingly."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code FROM Project_Staff WHERE date_from > ? AND date_to < ?", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4394", "db_id": "tracking_grants_for_research", "question": "What are the descriptions of all the project outcomes?", "rationale": ["The user wants to know the descriptions of all project outcomes, which are stored in the Project_Outcomes table.", "The relevant columns in the Project_Outcomes table are outcome_code and outcome_details.", "To retrieve all descriptions, a simple SELECT statement is sufficient, selecting both outcome_code and outcome_details from the Project_Outcomes table."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code", "source_tables": ["project_outcomes", "research_outcomes"], "pred_sql": "SELECT outcome_code, outcome_details FROM Project_Outcomes;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of project details and their corresponding project IDs from the 'Projects' table. It joins with the 'Project_Outcomes' table to aggregate the outcomes associated with each project. The results are grouped by project ID and ordered by the count of outcomes in descending order, allowing the user to limit the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["To find the most common role for the staff, we need to count the occurrences of each role code in the Project_Staff table.", "The hint provides a virtual table that filters staff members based on their involvement dates. We will use this to filter the roles.", "We will count the number of occurrences of each role code using COUNT(*) and group the results by role_code.", "To find the most common role, we will order the results by the count in descending order and limit the results to 1."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM (SELECT role_code \n      FROM Project_Staff \n      WHERE date_from > '2020-01-01' AND date_to < '2023-01-01') \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the role codes of staff members associated with projects, filtered by their involvement dates. The placeholders in the WHERE clause represent the start and end dates for the staff members' participation in the projects.\",\n        \"virtual_table\": \"SELECT role_code FROM Project_Staff WHERE date_from  >  [PLACEHOLDER-TYPE:STRING] AND date_to  <  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4410", "db_id": "network_2", "question": "Who is the oldest person whose job is student?", "rationale": ["Identify the job title we are interested in, which is 'student'.", "We need to find the oldest person with this job title.", "To do this, we will use a subquery to find the maximum age of individuals with the job title 'student'.", "The main query will select the name of the person from the 'Person' table where the job is 'student' and the age matches the maximum age found in the subquery."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "pred_sql": "SELECT name FROM Person WHERE job = 'student' AND age = (SELECT max(age) FROM Person WHERE job = 'student')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4439", "db_id": "network_2", "question": "What is the name and age of every male? Order the results by age.", "rationale": ["Identify the relevant table: The 'Person' table contains the necessary information about individuals.", "Determine the required fields: We need the 'name' and 'age' of every male.", "Apply the filter: We will filter the results to include only those individuals whose gender is 'male'.", "Order the results: The results should be ordered by the 'age' column in ascending order."], "gold_sql": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE gender = 'male' ORDER BY age", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    }\n}\n"}
{"sample_id": "train.4441", "db_id": "network_2", "question": "What are the names and ages of every person who is a friend of both Dan and Alice?", "rationale": ["Identify the requirement: We need the names and ages of individuals who are friends with both Dan and Alice.", "To find friends of Dan, we will join the PersonFriend table with the Person table where the friend's name matches.", "We will perform a similar join for Alice to find her friends.", "Since we need individuals who are friends with both, we will use two joins on the PersonFriend table, one for each person (Dan and Alice).", "We will select distinct names and ages from the Person table based on the results of the joins."], "gold_sql": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT p.name, p.age \nFROM Person p \nJOIN PersonFriend pf1 ON p.name = pf1.friend \nJOIN PersonFriend pf2 ON p.name = pf2.friend \nWHERE pf1.name = 'Dan' AND pf2.name = 'Alice';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    }\n}\n"}
{"sample_id": "train.4444", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 and under age 30?", "rationale": ["Identify the tables involved: Person and PersonFriend.", "We need to find names from the PersonFriend table where the friends' ages are either above 40 or below 30.", "Join the PersonFriend table with the Person table on the friend's name to access their age.", "Use a WHERE clause to filter friends based on the specified age conditions (age > 40 OR age < 30).", "Select distinct names from the PersonFriend table to avoid duplicates."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT pf.name \nFROM PersonFriend pf \nJOIN Person p ON pf.friend = p.name \nWHERE p.age > 40 OR p.age < 30;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    }\n}\n"}
{"sample_id": "train.4445", "db_id": "network_2", "question": "What are the names of every person who has a friend over 40 and under 30?", "rationale": ["Identify the main table to query from, which is the 'Person' table for the names of individuals.", "We need to find friends of these individuals, so we will join the 'PersonFriend' table to link persons with their friends.", "Next, we need to join again with the 'Person' table to access the age of the friends.", "The condition requires us to filter friends who are either over 40 or under 30 years old.", "We use DISTINCT to ensure that we only get unique names of persons who have at least one friend meeting the age criteria."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT p1.name \nFROM Person p1 \nJOIN PersonFriend pf1 ON p1.name = pf1.name \nJOIN Person p2 ON pf1.friend = p2.name \nWHERE (p2.age > 40 OR p2.age < 30);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    }\n}\n"}
{"sample_id": "train.4449", "db_id": "network_2", "question": "What are the names of the people who have no friends who are students?", "rationale": ["Identify the main requirement: we need the names of people who have no friends that are students.", "To find friends who are students, we need to look at the 'Person' table and filter by job = 'student'.", "We will create a subquery to select the names of friends who are students.", "Next, we need to find people in the 'Person' table whose names are not in the list of friends who are students.", "We will use a NOT IN clause to filter out those names from the 'Person' table."], "gold_sql": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  'student'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT name FROM Person WHERE name NOT IN (SELECT name FROM PersonFriend WHERE friend IN (SELECT name FROM Person WHERE job = 'student'));", "hint": "\n"}
{"sample_id": "train.4454", "db_id": "network_2", "question": "Find the name of persons who are friends with Bob.", "rationale": ["Identify the table to query: We need to find friends of a specific person, which is in the PersonFriend table.", "Determine the specific person: The question asks for friends of 'Bob'.", "Use the provided virtual table structure: The hint provides a template for querying friends based on the most recent year of friendship established.", "Construct the SQL query: Replace the placeholders in the virtual table with 'Bob' to get the friends of Bob who have the most recent friendship year."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Bob' AND year = (SELECT max(year) FROM PersonFriend WHERE name = 'Bob')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4455", "db_id": "network_2", "question": "What are the names of all of Bob's friends?", "rationale": ["Identify the table that contains the friends of a person, which is the PersonFriend table.", "We need to filter the friends specifically for 'Bob', so we will use a WHERE clause to specify name = 'Bob'.", "The hint suggests using a virtual table that lists friends filtered by the most recent year of friendship, but since the question only asks for the names of all friends, we can simplify the query to just select the friends without filtering by year."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Bob'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4456", "db_id": "network_2", "question": "Find the names of females who are friends with Zach", "rationale": ["We need to find the names of females who are friends with Zach.", "To do this, we will join the 'Person' table with the 'PersonFriend' table on the condition that the name in 'Person' matches the friend in 'PersonFriend'.", "We will filter the results to only include those records where the name in 'PersonFriend' is 'Zach'.", "Additionally, we will filter the results to only include females by checking the gender column in the 'Person' table.", "Finally, we will select the names of these females."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name FROM Person p JOIN PersonFriend pf ON p.name = pf.friend WHERE pf.name = 'Zach' AND p.gender = 'female';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    }\n}\n"}
{"sample_id": "train.4465", "db_id": "network_2", "question": "What are the different names of friends who are younger than the average age for a friend?", "rationale": ["Identify the friends of a specific person from the 'PersonFriend' table using a subquery to filter by the most recent year of friendship established.", "Calculate the average age of friends by selecting their names from the 'Person' table where their age is less than the average age.", "Use the DISTINCT keyword to ensure that only unique friend names are returned in the final result."], "gold_sql": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT friend FROM PersonFriend WHERE friend IN (SELECT name FROM Person WHERE age < (SELECT AVG(age) FROM Person WHERE name IN (SELECT friend FROM PersonFriend WHERE name = [PLACEHOLDER-TYPE:STRING] AND year = (SELECT max(year) FROM PersonFriend WHERE name = [PLACEHOLDER-TYPE:STRING]))))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4466", "db_id": "network_2", "question": "Who has friends that are older than the average age? Print their friends and their ages as well", "rationale": ["Identify the tables involved: Person and PersonFriend.", "We need to find friends of individuals, so we will use the PersonFriend table to get the friends.", "We need to join the Person table to get the ages of these friends.", "Calculate the average age from the Person table using a subquery.", "Filter the results to only include friends whose age is greater than the average age.", "Select the friend's name and their age in the final output."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT pf.friend, p.age \nFROM PersonFriend pf \nJOIN Person p ON pf.friend = p.name \nWHERE p.age > (SELECT AVG(age) FROM Person)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of individuals from the 'Person' table who belong to a specific gender. The results are ordered by their age, allowing for easy identification of individuals within that gender category.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE gender  =  [PLACEHOLDER-TYPE:STRING] ORDER BY age\"\n    }\n}\n"}
{"sample_id": "train.4467", "db_id": "network_2", "question": "Whare the names, friends, and ages of all people who are older than the average age of a person?", "rationale": ["Identify the required fields: names, friends, and ages of people.", "We need to join the 'Person' table with the 'PersonFriend' table to get the friends of each person.", "The condition specifies that we want people who are older than the average age.", "To find the average age, we can use a subquery: (SELECT AVG(age) FROM Person).", "Construct the SQL query using a JOIN to combine the two tables and apply the age condition."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT p.name, pf.friend, p.age \nFROM Person p \nJOIN PersonFriend pf ON p.name = pf.name \nWHERE p.age > (SELECT AVG(age) FROM Person)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)\"\n    }\n}\n"}
{"sample_id": "train.4473", "db_id": "network_2", "question": "What are the names of all people who are friends with Alice for the shortest amount of time?", "rationale": ["Identify the person of interest, which is 'Alice'.", "We need to find friends of Alice, so we will query the 'PersonFriend' table where the name is 'Alice'.", "To find the shortest amount of time, we need to look for the minimum year of friendship established with Alice.", "We will use a subquery to find the minimum year from the 'PersonFriend' table for Alice.", "Finally, we will select the friends of Alice who have the friendship established in that minimum year."], "gold_sql": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend"], "pred_sql": "SELECT friend FROM PersonFriend WHERE name = 'Alice' AND year = (SELECT MIN(year) FROM PersonFriend WHERE name = 'Alice')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4475", "db_id": "network_2", "question": "What are the names, ages, and jobs of all people who are friends with Alice for the longest amount of time?", "rationale": ["Identify the required information: names, ages, and jobs of people who are friends with Alice.", "Use the Person table to get the names, ages, and jobs of individuals.", "Use the PersonFriend table to find friends of Alice.", "Join the Person table with the PersonFriend table on the condition that the friend's name matches the name in the Person table.", "Filter the results to only include friends of Alice by using a WHERE clause.", "To find the friend with the longest friendship, order the results by the year the friendship was established in ascending order.", "Limit the results to the first entry to get the friend with the longest friendship."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, P.age, P.job \nFROM Person P \nJOIN PersonFriend PF ON P.name = PF.friend \nWHERE PF.name = 'Alice' \nORDER BY PF.year ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of individuals from the 'Person' table who have a specific job title and are the oldest among those with the same job. The placeholders in the WHERE clause represent the job title being queried.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE job  =  [PLACEHOLDER-TYPE:STRING] AND age  =  (SELECT max(age) FROM person WHERE job  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4478", "db_id": "network_2", "question": "Which person whose friends have the oldest average age?", "rationale": ["We need to find the person whose friends have the oldest average age.", "To do this, we will join the PersonFriend table with the Person table on the condition that the friend's name in PersonFriend matches the name in Person.", "Next, we will group the results by the person's name from the PersonFriend table.", "We will then calculate the average age of the friends for each person using AVG(p.age).", "Finally, we will order the results in descending order of the average age and limit the results to 1 to get the person with the oldest average age of friends."], "gold_sql": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT pf.name FROM PersonFriend pf JOIN Person p ON pf.friend = p.name GROUP BY pf.name ORDER BY AVG(p.age) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the name of the oldest person from the 'Person' table. The placeholder in the WHERE clause is used to filter the age based on the maximum age found in the table.\",\n        \"virtual_table\": \"SELECT name FROM Person WHERE age  =  (SELECT max(age) FROM person)\"\n    }\n}\n"}
{"sample_id": "train.4480", "db_id": "network_2", "question": "What is the total number of people who has no friend living in the city of Austin.", "rationale": ["We need to count the total number of people who have no friends living in Austin.", "First, we select all people from the Person table who live in Austin.", "Next, we need to ensure that these people have no friends. We can do this by checking the PersonFriend table.", "We will use a subquery to find all friends of each person and ensure that the person's name is not in that list of friends.", "The final query counts the number of people who meet these criteria."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT COUNT(*) FROM Person WHERE city = 'Austin' AND name NOT IN (SELECT friend FROM PersonFriend WHERE name = Person.name)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the friends of a specific person from the 'PersonFriend' table, filtered by the most recent year of friendship established. The placeholders in the WHERE clause represent the person's name.\",\n        \"virtual_table\": \"SELECT friend FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING] AND YEAR  =  (SELECT max(YEAR) FROM PersonFriend WHERE name =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4503", "db_id": "document_management", "question": "Find the types of documents with more than 4 documents.", "rationale": ["Identify the relevant table: The 'Documents' table contains the information about document types and their counts.", "Count the number of documents for each type: Use COUNT(document_code) to count how many documents exist for each document type.", "Group the results by document type: Use GROUP BY document_type_code to aggregate the counts for each type.", "Filter the results: Use HAVING COUNT(document_code) > 4 to only include document types that have more than 4 documents."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code, COUNT(document_code) AS document_count \nFROM Documents \nGROUP BY document_type_code \nHAVING COUNT(document_code) > 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average access count of documents grouped by their document structure code. The placeholder in the LIMIT clause allows the user to specify the maximum number of groups to return, based on the ascending order of their count.\",\n        \"virtual_table\": \"SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4504", "db_id": "document_management", "question": "What are the codes of types of documents of which there are for or more?", "rationale": ["Identify the table that contains the document types, which is the 'Documents' table.", "We need to group the results by 'document_type_code' to count how many documents exist for each type.", "Use the HAVING clause to filter the groups to only include those with a count of 4 or more."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code FROM Documents GROUP BY document_type_code HAVING COUNT(*) >= 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of document structure descriptions from the 'Document_Structures' table, which are associated with documents in the 'Documents' table. The results are grouped by the document structure code and ordered by the number of documents associated with each structure, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4505", "db_id": "document_management", "question": "Find the total access count of all documents in the most popular document type.", "rationale": ["Identify the requirement to find the total access count of all documents in the most popular document type.", "The most popular document type can be determined by grouping the documents by their document_type_code and summing their access counts, then ordering by this sum in descending order.", "To get the most popular document type, we can use a subquery that selects the document_type_code with the highest total access count.", "Finally, we need to sum the access counts of all documents that match this most popular document type."], "gold_sql": "SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT SUM(access_count) FROM documents WHERE document_type_code = (SELECT document_type_code FROM documents GROUP BY document_type_code ORDER BY SUM(access_count) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average access count of documents grouped by their document structure code. The placeholder in the LIMIT clause allows the user to specify the maximum number of groups to return, based on the ascending order of their count.\",\n        \"virtual_table\": \"SELECT avg(access_count) FROM documents GROUP BY document_structure_code ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4525", "db_id": "document_management", "question": "Find names of the document without any images.", "rationale": ["Identify the main table to query: The 'Documents' table contains the names of the documents.", "Determine the condition: We need to find documents that do not have any associated images.", "To find documents without images, we can use a subquery that selects document codes from the 'Document_Sections_Images' table.", "The subquery will return all document codes that have images, and we will use this in a NOT IN clause to filter out those documents from the main query.", "The final SQL query selects the 'document_name' from the 'Documents' table where the 'document_code' is not in the list of document codes returned by the subquery."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "pred_sql": "SELECT document_name FROM Documents WHERE document_code NOT IN (SELECT DISTINCT document_code FROM Document_Sections_Images)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of document structure descriptions from the 'Document_Structures' table, which are associated with documents in the 'Documents' table. The results are grouped by the document structure code and ordered by the number of documents associated with each structure, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT t2.document_structure_description FROM documents AS t1 JOIN document_structures AS t2 ON t1.document_structure_code  =  t2.document_structure_code GROUP BY t1.document_structure_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4532", "db_id": "document_management", "question": "Count the number of users that are logged in.", "rationale": ["Identify the table that contains user information, which is the 'Users' table.", "To count the number of users, we will use the COUNT() function.", "Since the question asks for the number of users that are logged in, we assume that all users in the 'Users' table are considered logged in for this query.", "The SQL query will select the count of all entries in the 'Users' table."], "gold_sql": "SELECT count(*) FROM users WHERE user_login  =  1", "source_tables": ["users"], "pred_sql": "SELECT COUNT(*) AS logged_in_users FROM Users;", "hint": "\n"}
{"sample_id": "train.4733", "db_id": "department_store", "question": "Return the distinct name of customers whose order status is Pending, in the order of customer id.", "rationale": ["Identify the relevant tables: Customers and Customer_Orders.", "We need to find customers with a specific order status, which is 'Pending'.", "Use a subquery to get distinct customer_ids from Customer_Orders where order_status_code is 'Pending'.", "Join this result with the Customers table to get the customer names.", "Select distinct customer names to avoid duplicates.", "Order the results by customer_id as specified."], "gold_sql": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending' ORDER BY T2.customer_id", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT customer_name FROM Customers WHERE customer_id IN (SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_status_code = 'Pending') ORDER BY customer_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4736", "db_id": "department_store", "question": "What are the names and addressed of customers who have both New and Pending orders?", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Customer_Addresses.", "We need to select customer names and their addresses, so we will select from the Customers table and join it with Customer_Orders to filter based on order status.", "Join the Customer_Addresses table to get the address details for each customer.", "Filter the orders to include only those with statuses 'New' and 'Pending'.", "Group the results by customer_id to ensure we only get unique customers.", "Use HAVING to ensure that we only include customers who have both order statuses by counting distinct order statuses and checking that the count equals 2."], "gold_sql": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'New' INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending'", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT c.customer_name, ca.address_id \nFROM Customers c \nJOIN Customer_Orders co ON c.customer_id = co.customer_id \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nWHERE co.order_status_code IN ('New', 'Pending') \nGROUP BY c.customer_id \nHAVING COUNT(DISTINCT co.order_status_code) = 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4749", "db_id": "department_store", "question": "Find the id and name of the staff who has been assigned for the shortest period.", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to find the staff who has been assigned for the shortest period, which requires calculating the duration of each assignment.", "The duration can be calculated as the difference between date_assigned_to and date_assigned_from.", "We can use a subquery to order the assignments by duration and limit the results to the shortest one.", "Finally, we will join this result with the Staff table to get the staff_id and staff_name."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Staff_Department_Assignments ORDER BY date_assigned_to - date_assigned_from LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to find the staff member who has been assigned for the least amount of time, which implies looking for the earliest date in the Staff_Department_Assignments table.", "Use an ORDER BY clause on the date_assigned_from column to sort the assignments by the start date in ascending order.", "Limit the results to 1 to get the staff member with the earliest assignment date.", "Join this result with the Staff table to get the staff_id and staff_name of the identified staff member."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Staff_Department_Assignments ORDER BY date_assigned_from ASC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["Identify the requirement to find distinct customer IDs who made orders after cancelled orders.", "Use a subquery to find the minimum order date for orders that have a status of 'Cancelled'.", "The main query selects distinct customer IDs from the 'Customer_Orders' table where the order date is greater than the date obtained from the subquery."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "pred_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date > (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code = 'Cancelled')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique customer identifiers from the 'Customer_Orders' table for orders placed after a specific date. The date is determined by finding the earliest order date associated with a particular order status, represented by a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["Identify the requirement: We need the staff ID of those who had a department assignment earlier than any Clerical Staff.", "Use the provided hint to create a virtual table that selects staff IDs from the Staff_Department_Assignments table.", "The condition for the selection is that the date_assigned_to must be earlier than the maximum date_assigned_to for Clerical staff.", "The subquery will find the maximum date_assigned_to for staff with the job title code 'Clerical'.", "Combine these elements to form the final SQL query."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "pred_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to < (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant tables: Customers, Customer_Addresses, and Addresses.", "We need to retrieve customer names and IDs, so we will select 'customer_name' and 'customer_id' from the Customers table.", "To find customers with 'TN' in their address, we need to join the Customers table with the Customer_Addresses table on 'customer_id'.", "Next, we join the Customer_Addresses table with the Addresses table on 'address_id' to access the address details.", "Finally, we filter the results using a WHERE clause to check if 'address_details' contains 'TN' using the LIKE operator."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "pred_sql": "SELECT Customers.customer_name, Customers.customer_id \nFROM Customers \nJOIN Customer_Addresses ON Customers.customer_id = Customer_Addresses.customer_id \nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id \nWHERE Addresses.address_details LIKE '%TN%';", "hint": "\n"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["Identify the relevant tables: 'Staff' for staff details and 'Staff_Department_Assignments' for assignment dates.", "We need to select the staff names and genders, which are in the 'Staff' table.", "To find the staff assigned in 2016, we will join 'Staff' with 'Staff_Department_Assignments' on 'staff_id'.", "The condition for the assignment date should filter for dates starting with '2016', which can be done using the LIKE operator with '2016%'."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT T1.staff_name, T1.staff_gender FROM Staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id = T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and genders of staff members from the 'Staff' table who have been assigned to a department starting from a specific date. The placeholder in the WHERE clause represents the date of assignment.\",\n        \"virtual_table\": \"SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["Identify the staff members who have been assigned to multiple jobs.", "To do this, we can use the Staff_Department_Assignments table to group by staff_id and count the distinct job_title_code for each staff member.", "We will filter the results to only include those staff members who have a count greater than 1, indicating multiple job assignments.", "Finally, we will join this result with the Staff table to get the names of these staff members."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name FROM Staff WHERE staff_id IN (SELECT staff_id FROM Staff_Department_Assignments GROUP BY staff_id HAVING COUNT(DISTINCT job_title_code) > 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the unique identifiers of staff members who were assigned to a department and whose assignment ended before the most recent assignment date for a specific job title. The placeholder in the subquery represents the job title code to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table: Customers, which contains customer_id, customer_name, customer_address, and payment_method_code.", "Filter customers based on their address containing 'WY'. This can be done using the LIKE operator with a wildcard: '%WY%'.", "Exclude customers who use a credit card for payment by checking that payment_method_code is not equal to 'CREDIT_CARD'.", "Combine these conditions in the WHERE clause of the SQL query to retrieve the desired customer ids and names."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name \nFROM Customers \nWHERE customer_address LIKE '%WY%' \nAND payment_method_code != 'CREDIT_CARD';", "hint": "\n"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["Identify the table that contains product information, which is the 'Products' table.", "Determine the relevant column for price, which is 'product_price'.", "To find the average price, use the AVG() function.", "Filter the products to only include those that are classified as 'clothes' using the 'product_type_code' column."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "pred_sql": "SELECT AVG(product_price) AS average_price\nFROM Products\nWHERE product_type_code = 'clothes';", "hint": "\n"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["Identify the relevant table: Products, which contains product details including name and price.", "Filter the products to only include those of type 'hardware' using the product_type_code column.", "Sort the filtered products by product_price in descending order to get the most expensive product at the top.", "Limit the results to 1 to get only the most expensive hardware product."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "pred_sql": "SELECT product_name FROM Products WHERE product_type_code = 'hardware' ORDER BY product_price DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["Identify the relevant tables: We need to look at the 'product' and 'store_product' tables to find products and their maximum page sizes.", "Join the 'store_product' table with the 'product' table on the product ID to access the product details along with their maximum page sizes.", "Group the results by 'max_page_size' to aggregate the products that share the same page size.", "Use the HAVING clause to filter the groups where the count of products is greater than 3, which indicates that there are more than 3 products listed for that page size."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM store_product JOIN product ON store_product.Product_ID = product.product_id GROUP BY max_page_size HAVING COUNT(store_product.Product_ID) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["Identify the relevant tables: We need to look at the 'store' and 'store_product' tables to find stores with more than 3 products.", "Join the 'store' and 'store_product' tables on 'Store_ID' to associate products with their respective stores.", "Group the results by 'store.Store_ID' to aggregate the products for each store.", "Use the HAVING clause to filter the groups to only include those with a count of products greater than 3.", "Select the 'max_page_size' from the 'product' table by joining it with the 'store_product' table to get the maximum page size for the products sold in those stores."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM store JOIN store_product ON store.Store_ID = store_product.Store_ID GROUP BY store.Store_ID HAVING COUNT(store_product.Product_ID) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["Identify the requirement to find the total number of residents in districts with the largest areas.", "To achieve this, we need to first identify the districts with the three largest areas.", "We can do this by selecting the District_IDs from the district table, ordering them by City_Area in descending order, and limiting the results to 3.", "Once we have the District_IDs of the three largest districts, we can then sum their populations.", "The final SQL query will sum the City_Population for the districts identified in the previous step."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "pred_sql": "SELECT SUM(City_Population) AS Total_Residents \nFROM district \nWHERE District_ID IN (\n    SELECT District_ID \n    FROM district \n    ORDER BY City_Area DESC \n    LIMIT 3\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of stores grouped by the city where their respective districts are headquartered. The placeholders in the query represent the relationships between stores and districts, allowing for aggregation of store counts based on the city names.\",\n        \"virtual_table\": \"SELECT t3.headquartered_city ,  count(*) FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city\"\n    }\n}\n"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the relevant tables: store, store_district, and district are needed to find stores in a specific district.", "Join the store table with the store_district table on Store_ID to link stores to their respective districts.", "Join the resulting table with the district table on District_ID to access district names.", "Filter the results to only include stores located in 'Khanewal District' by using a WHERE clause on the district name.", "Select the Store_Name from the filtered results to get the names of the stores."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT s.Store_Name \nFROM store AS s \nJOIN store_district AS sd ON s.Store_ID = sd.Store_ID \nJOIN district AS d ON sd.District_ID = d.District_ID \nWHERE d.District_name = 'Khanewal';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["Identify the tables involved: store, store_district, and district.", "Join the store table with store_district to link stores to their respective districts.", "Join the resulting table with the district table to access the city information.", "Group the results by the city name to count the number of stores in each city.", "Order the grouped results by the count of stores in descending order to find the city with the most stores.", "Limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT t3.Headquartered_City FROM store AS t1 JOIN store_district AS t2 ON t1.Store_ID = t2.Store_ID JOIN district AS t3 ON t2.District_ID = t3.District_ID GROUP BY t3.Headquartered_City ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities where the headquarters of districts are located, based on the stores associated with those districts. The results are grouped by the city name and ordered by the number of stores in each city, with a limit on the number of cities returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to filter products based on 'max_page_size' and 'pages_per_minute_color'.", "Use the provided hint to structure the SQL query: The hint gives a template for selecting products based on the specified conditions.", "Replace placeholders in the hint with actual values: Set 'max_page_size' to 'A4' and 'pages_per_minute_color' to less than 5.", "Construct the final SQL query: Combine the SELECT statement with the WHERE clause using the specified conditions."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE max_page_size = 'A4' AND pages_per_minute_color < '5'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to find products with a maximum page size of 'A4' or a pages per minute color value smaller than 5.", "Construct the SQL query: Use the SELECT statement to retrieve the 'product' column from the 'product' table, applying the conditions in the WHERE clause using OR to combine them."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < '5'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["Identify the relevant table: The 'product' table contains the product names.", "Determine the condition: We need to find products whose names include the substring 'Scanner'.", "Use the SQL LIKE operator: The condition can be expressed using the LIKE operator with wildcards.", "Construct the SQL query: The final query selects the 'product' column from the 'product' table where the 'product' name matches the condition."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["Identify the relevant table: The 'product' table contains the 'max_page_size' column which is needed to answer the question.", "To find the most common maximum page size, we need to count occurrences of each 'max_page_size'.", "Use the COUNT function to count how many times each 'max_page_size' appears in the 'product' table.", "Group the results by 'max_page_size' to aggregate the counts for each unique size.", "Order the results in descending order based on the count to get the most common size at the top.", "Limit the results to 1 to get only the most common maximum page size."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "pred_sql": "SELECT max_page_size, COUNT(*) as count\nFROM product\nGROUP BY max_page_size\nORDER BY count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that have a specific maximum page size and a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the maximum pages per minute for color output.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] AND pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["Identify the column of interest: max_page_size from the product table.", "Determine the most frequently-used max page size by grouping the products by max_page_size and counting occurrences, ordering by count in descending order, and limiting the result to 1.", "Use a subquery to find the most frequently-used max page size.", "Select products from the product table where the max_page_size is not equal to the most frequently-used max page size."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE max_page_size != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the products from the 'product' table that either have a specific maximum page size or have a print speed in pages per minute for color output that is below a certain threshold. The placeholders in the WHERE clause represent the maximum page size and the print speed limit.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE max_page_size  =  [PLACEHOLDER-TYPE:STRING] OR pages_per_minute_color  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["Identify the table that contains the enrollment numbers, which is the 'College' table.", "To find the average enrollment, we need to use the AVG() function on the 'enr' column.", "The query will select the average of the 'enr' column from the 'College' table."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "pred_sql": "SELECT AVG(enr) AS average_enrollment FROM College;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT cName FROM college WHERE enr  >  (SELECT max(enr) FROM college WHERE state  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["The question asks for the average hours players train, which implies we need to calculate an average from a relevant column.", "The hint provides a virtual table that calculates the average from the 'Player' table, but it mentions 'HS' which stands for high school, not training hours.", "Since there is no direct column for training hours in the provided schema, we can interpret 'HS' as a placeholder for the training hours, assuming it represents some quantifiable metric related to training.", "We will join the 'Player' table with the 'Tryout' table on the player ID to ensure we are only considering players who participated in tryouts.", "Finally, we will use the AVG function to calculate the average of the 'HS' column, which we are interpreting as training hours."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT avg(T1.HS) FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["Identify the relevant tables: Player and Tryout.", "Determine the columns needed: pName from Player and training hours from Tryout.", "Use a subquery to filter players based on their training hours being below 1500.", "Join the Player table with the Tryout table using pID to get the names of players who meet the criteria.", "Ensure the results are ordered by the high school attended by the players in descending order."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE decision = 'Accepted' AND pPos = 'Training' AND hours < 1500) ORDER BY HS DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\",\n        \"virtual_table\": \"SELECT pName FROM Player WHERE yCard  =  [PLACEHOLDER-TYPE:STRING] ORDER BY HS DESC\"\n    }\n}\n"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The question asks for the different types of player positions, which implies we need to retrieve unique values from the 'pPos' column in the 'Tryout' table.", "To get unique player positions, we can use the DISTINCT keyword in our SQL query.", "The relevant table for player positions is the 'Tryout' table, specifically the 'pPos' column.", "Thus, the SQL query will select distinct player positions from the Tryout table."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT pPos FROM Tryout;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["Identify the relevant table: The 'Tryout' table contains the information about players and their decisions after tryouts.", "Determine the specific information needed: We need to count how many students were accepted after the tryout.", "Use the COUNT function: This function will help us count the number of records that meet our criteria.", "Specify the condition: We will filter the records where the decision is 'accepted'.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) AS accepted_students FROM Tryout WHERE decision = 'accepted';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["Identify the tables involved: Player and Tryout.", "Determine the columns needed: We need to calculate the average, maximum, and minimum training hours, which are not directly available in the schema. Assuming HS represents training hours, we will use it for calculations.", "Join the Player table with the Tryout table on the pID column to access player data related to their tryouts.", "Use aggregate functions avg(), max(), and min() to calculate the required statistics on the HS column.", "Construct the SQL query to select the average, maximum, and minimum training hours from the joined tables."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT avg(T1.HS) AS average_training_hours, max(T1.HS) AS max_training_hours, min(T1.HS) AS min_training_hours FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["The question asks for the average, maximum, and minimum hours spent training, which implies we need to calculate these statistics from a relevant column.", "The hint provides a virtual table that calculates average and maximum values from the 'Player' table based on a decision from the 'Tryout' table.", "Since the question does not specify a decision, I will assume we are interested in players who were accepted in their tryouts, hence I will use 'accepted' as the decision in the WHERE clause.", "To get the minimum hours, I will also include the MIN function in the SQL query.", "The final SQL query will join the 'Player' and 'Tryout' tables on the player ID and calculate the average, maximum, and minimum hours based on the specified decision."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT avg(T1.HS) AS average_hours, max(T1.HS) AS max_hours, min(T1.HS) AS min_hours FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'accepted'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average and maximum high school identifier of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["Identify the relevant tables: Player and Tryout.", "Determine the columns needed: pName from Player and a condition on training hours.", "Since the question refers to players, we will focus on the Player table for names.", "The training hours condition suggests we need to filter players based on their participation in tryouts.", "Assuming 'training_hours' is a column in the Player table, we will filter players whose training hours are between 500 and 1500.", "We need to ensure that we are only considering players who have a specific decision in the Tryout table, which is typically 'accepted'.", "Construct the SQL query to select player names from the Player table where their IDs are in the list of accepted players from the Tryout table and their training hours meet the specified range."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE decision = 'accepted') AND training_hours BETWEEN 500 AND 1500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["Identify the relevant tables: Player and Tryout.", "Determine the columns needed: pName from Player.", "Understand the condition: players who train between 500 and 1500 hours, which relates to the pPos in the Tryout table.", "Construct a subquery to find pIDs of players whose pPos is between 500 and 1500.", "Use the subquery to filter the Player table to get the names of those players."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE pPos BETWEEN 500 AND 1500)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["Identify the relevant table: College.", "Determine the columns needed: cName and enr.", "Set the condition for enrollment: enr > 10000.", "Specify the state condition: state = 'Louisiana'.", "Combine these conditions to form the SQL query."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "pred_sql": "SELECT cName, enr FROM College WHERE enr > 10000 AND state = 'Louisiana'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT cName FROM college WHERE enr  >  (SELECT max(enr) FROM college WHERE state  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["Identify the relevant table: The question asks for player names, which are found in the 'Player' table.", "Determine the required columns: We need the 'pName' column from the 'Player' table.", "Ordering the results: The question specifies to order the results by the 'HS' (high school) column in descending order.", "Construct the SQL query: Combine the selected column and the ordering clause to form the complete SQL query."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player ORDER BY HS DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of players from the 'Player' table who have a specific year of eligibility. The results are ordered by the high school attended by the players in descending order. The placeholder in the WHERE clause represents the year of the player's card or eligibility.\",\n        \"virtual_table\": \"SELECT pName FROM Player WHERE yCard  =  [PLACEHOLDER-TYPE:STRING] ORDER BY HS DESC\"\n    }\n}\n"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["We need to find out which position is most popular among players in the tryout.", "To do this, we can count the number of players for each position in the Tryout table.", "We will use the COUNT() function to count the occurrences of each position (pPos).", "We will group the results by position using GROUP BY clause.", "To get the most popular position, we will order the results in descending order based on the count of players for each position using ORDER BY clause.", "Finally, we will limit the results to only the top position using LIMIT 1."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["To find the most popular position at tryouts, we need to count how many players tried out for each position.", "We will use the COUNT function to count the number of players for each position in the Tryout table.", "We will group the results by the position (pPos) to get the count for each position.", "To determine the most popular position, we will order the results in descending order based on the count of players for each position.", "Finally, we will limit the results to just one entry to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["The question asks for the minimum hours of students playing in different positions.", "To find the minimum hours, we need to first calculate the total hours each player has played for each position.", "We can do this by counting the number of tryouts each player has for each position, which can be considered as hours played.", "We will create a subquery that groups the data by player ID (pID) and position (pPos) and counts the number of tryouts for each combination.", "Then, we will use the outer query to select the position and the minimum hours from the results of the subquery, grouping by position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(hours) AS min_hours\nFROM (SELECT pID, pPos, COUNT(*) AS hours\n      FROM Tryout\n      GROUP BY pID, pPos)\nGROUP BY pPos;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the required information: We need to find the minimum time students spent practicing for each position.", "Determine the relevant tables: The 'Practice' table is assumed to contain the practice times for players, which is not explicitly mentioned in the schema but is inferred from the context of the question.", "Use the MIN() function to find the minimum practice time for each position.", "Group the results by position using GROUP BY clause to get the minimum time for each position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(practice_time) AS min_practice_time\nFROM Practice\nGROUP BY pPos;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the tables involved: Player and Tryout.", "We need to retrieve the names of players who received a 'yes' decision in tryouts.", "Join the Player table with the Tryout table on the player ID (pID).", "Select the player's name (pName) and the position (pPos) they tried out for.", "Filter the results to include only those records where the decision is 'yes'."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT Player.pName, Tryout.pPos \nFROM Player \nJOIN Tryout ON Player.pID = Tryout.pID \nWHERE Tryout.decision = 'yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the main goal: to find the names of students who successfully tried out for the position of striker.", "The relevant tables are 'Player' for player names and 'Tryout' for tryout decisions and positions.", "We need to filter the 'Tryout' table for records where the decision is 'successful' and the position is 'striker'.", "Using a subquery, we can select the 'pID' from the 'Tryout' table that meets these criteria.", "Finally, we use the 'pID' from the subquery to select the corresponding 'pName' from the 'Player' table."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE decision = 'successful' AND pPos = 'striker')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["Identify the relevant tables: Player and Tryout.", "Determine the relationship between the tables: Player is linked to Tryout via pID.", "Focus on the decision criteria: we are interested in players who got rejected.", "Use the average function to calculate the average hours spent practicing, which is represented by the HS column in the Player table.", "Construct the SQL query using a JOIN to combine the Player and Tryout tables, filtering for the rejected decision."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT avg(T1.HS) FROM Player AS T1 JOIN Tryout AS T2 ON T1.pID = T2.pID WHERE T2.decision = 'rejected'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average and maximum high school identifiers of players from the 'Player' table who participated in tryouts and received a specific decision. The placeholder in the WHERE clause represents the decision made regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT avg(T1.HS) ,  max(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["Identify the relevant tables: College, Player, and Tryout.", "We need to find colleges that have students who are goalies and have succeeded in their tryouts.", "This requires joining the College table with the Tryout table on the college name (cName) and the Tryout table with the Player table on the player ID (pID).", "We will filter the results where the decision in the Tryout table is 'succeeded' and the position (pPos) is 'goalie'.", "Finally, we select distinct college names to avoid duplicates."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT College.cName \nFROM College \nJOIN Tryout ON College.cName = Tryout.cName \nJOIN Player ON Tryout.pID = Player.pID \nWHERE Tryout.decision = 'succeeded' AND Tryout.pPos = 'goalie';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["Identify the relevant tables: College and Tryout.", "Determine the columns needed: state and enrollment from College.", "Establish the relationship between the tables using the common column cName.", "Filter the results based on the decision column in the Tryout table, specifically looking for players who were accepted."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT T1.state, T1.enr FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName WHERE T2.decision = 'accepted'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["Identify the tables involved: College and Tryout.", "We need to find colleges where students were accepted during tryouts, so we will join the College table with the Tryout table on the college name (cName).", "We need to filter the results to only include tryouts where the decision was 'accepted'.", "We need to sum the enrollment numbers from the College table, which requires converting the enrollment number from text to integer.", "Finally, we will group the results by the state of the colleges to get the total enrollment per state."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT SUM(CAST(c.enr AS INTEGER)) AS total_enrollment, c.state \nFROM College c \nJOIN Tryout t ON c.cName = t.cName \nWHERE t.decision = 'accepted' \nGROUP BY c.state;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["Identify the relevant table: The 'Tryout' table contains information about players and their positions.", "Determine the required information: We need the names of colleges (cName) where players are trying out for the positions 'goalie' and 'mid'.", "Use the DISTINCT keyword to ensure that each college name is listed only once, even if multiple players from the same college are trying out for these positions.", "Construct the SQL query using the SELECT statement to retrieve the college names from the Tryout table, filtering by the specified positions using the IN clause."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT cName FROM Tryout WHERE pPos IN ('goalie', 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find distinct states from the College table.", "Join the College table with the Tryout table on the college name (cName).", "Filter the results based on the positions of the players (goalie and mid).", "Use the DISTINCT keyword to ensure we only get unique state names."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT T1.state FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos IN ('goalie', 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find distinct states from the College table.", "Join the College table with the Tryout table on the college name (cName).", "Filter the results based on the positions of the players (goalie and mid-field).", "Use the DISTINCT keyword to ensure we only get unique state names."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT T1.state FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos IN ('goalie', 'mid-field')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the positions of interest: goalie and mid.", "Use the Tryout table to find entries where players are trying out for either of these positions.", "Count the distinct colleges (cName) from the Tryout table that have players in these positions."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(DISTINCT cName) FROM Tryout WHERE pPos IN ('goalie', 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'Tryout' table where players have received a specific decision regarding their tryout for a particular position. The placeholders in the WHERE clause represent the decision made and the position the player is trying out for.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE decision  =  [PLACEHOLDER-TYPE:STRING] AND pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to count distinct states, so we will use COUNT(DISTINCT state).", "Join the College table with the Tryout table on the college name (cName).", "Filter the results to include only players trying out for the 'mid' position.", "Exclude players who are trying out as goalies by adding a condition that the decision is not 'goalie'.", "Construct the SQL query using the above conditions."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "pred_sql": "SELECT COUNT(DISTINCT T1.state) FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos = 'mid' AND T2.decision != 'goalie';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct states where colleges are located, based on the tryout decisions made for players. The placeholder in the WHERE clause represents the specific decision regarding the player's tryout.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the requirement: We need to find states with colleges that have enrollments less than some other college.", "Determine the comparison: We will compare the enrollment numbers of colleges to the maximum enrollment number of colleges.", "Use a subquery to find the maximum enrollment number from the College table: (SELECT MAX(enr) FROM College).", "Select distinct states from the College table where the enrollment number is less than the maximum enrollment number found in the previous step.", "Construct the final SQL query using the SELECT statement with the appropriate conditions."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE enr < (SELECT MAX(enr) FROM College)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of colleges from the 'College' table that have an enrollment number greater than the maximum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT cName FROM college WHERE enr  >  (SELECT max(enr) FROM college WHERE state  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["Identify the relevant table: Invoices, which contains the Order_Quantity column.", "Use aggregate functions to calculate the minimum, average, and maximum of the Order_Quantity column.", "Construct the SQL query to select the minimum, average, and maximum values from the Order_Quantity column in the Invoices table."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "pred_sql": "SELECT MIN(Order_Quantity) AS Min_Quantity, AVG(Order_Quantity) AS Avg_Quantity, MAX(Order_Quantity) AS Max_Quantity FROM Invoices", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n        \"virtual_table\": \"SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["Identify the relevant table: Invoices contains the payment_method_code and Order_ID.", "Group the results by payment_method_code to count the number of orders associated with each payment method.", "Use COUNT(Order_ID) to count the number of orders for each payment method.", "Order the results in descending order to get the payment method with the most orders at the top.", "Limit the results to 1 to get only the payment method code used by the most orders."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "pred_sql": "SELECT payment_method_code\nFROM Invoices\nGROUP BY payment_method_code\nORDER BY COUNT(Order_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["Identify the relevant table: The question asks for service types, which are found in the Services table.", "Determine the required columns: We need the descriptions of the service types, so we will select the 'Service_Type_Description' column.", "Filter the results: The question specifies that we only want service types that cost more than 100, which means we need to filter based on the 'Product_Price' column.", "Construct the SQL query: Combine the selected column and the filter condition into a complete SQL query."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT Service_Type_Description \nFROM Services \nWHERE Product_Price > 100;", "hint": "\n"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["We need to find the names of workshop groups that offer services related to a product named 'film'.", "The relevant tables are 'Drama_Workshop_Groups' for workshop group names and 'Services' for the services offered.", "We will join the 'Drama_Workshop_Groups' table with the 'Services' table on the 'Workshop_Group_ID' to link the services to their respective workshop groups.", "We will filter the results to only include services where the 'Product_Name' is 'film'.", "Finally, we will select distinct workshop group names to avoid duplicates."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "pred_sql": "SELECT DISTINCT dg.Store_Name\nFROM Drama_Workshop_Groups dg\nJOIN Services s ON dg.Workshop_Group_ID = s.Workshop_Group_ID\nWHERE s.Product_Name = 'film';", "hint": "\n"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["Identify the relevant tables: We need to retrieve order details, which are stored in the 'Order_Items' table, and we also need product information from the 'Products' table.", "Determine the columns to select: We want to get the order ID, product ID, order quantity, product price, and product description.", "Establish the relationship between tables: The 'Order_Items' table has a foreign key 'Product_ID' that links to the 'Products' table, allowing us to join these tables.", "Apply the filter condition: We need to filter products with a price greater than 2000, which is done using a WHERE clause on the 'Product_Price' column in the 'Products' table."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT oi.Order_ID, oi.Product_ID, oi.Order_Quantity, p.Product_Price, p.Product_Description \nFROM Order_Items oi \nJOIN Products p ON oi.Product_ID = p.Product_ID \nWHERE p.Product_Price > 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n        \"virtual_table\": \"SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables: We need to retrieve order details, which are stored in the 'Order_Items' table, and we also need product information, which is in the 'Products' table.", "Determine the columns needed: We want to get the order item ID, order ID, product ID, order quantity, and product price.", "Establish the relationship between tables: The 'Order_Items' table has a foreign key 'Product_ID' that links to the 'Products' table, allowing us to join these tables.", "Formulate the SQL query: We will select the necessary columns from the 'Order_Items' table and join it with the 'Products' table on 'Product_ID'.", "Add the condition for product price: We will filter the results to include only those products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT oi.Order_Item_ID, oi.Order_ID, oi.Product_ID, oi.Order_Quantity, p.Product_Price \nFROM Order_Items oi \nJOIN Products p ON oi.Product_ID = p.Product_ID \nWHERE p.Product_Price > 2000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product IDs from the 'Invoices' table, grouped by product ID and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of product IDs to retrieve.\",\n        \"virtual_table\": \"SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most frequent status of bookings, which means we need to count occurrences of each status code.", "Use the COUNT function: We will count the number of bookings for each status code using COUNT(*) and group the results by 'Status_Code'.", "Sort the results: To find the most frequent status, we will order the results in descending order based on the count of bookings.", "Limit the results: Since we only want the most frequent status, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Frequency\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most common status code, which implies counting occurrences of each status code.", "Use the COUNT function: We will count the number of bookings for each status code.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each unique status code.", "Order the results: To find the most common status code, we will order the results in descending order based on the count.", "Limit the results: Since we only need the most common status code, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Count\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables: Drama_Workshop_Groups and Bookings.", "We need to find the names of workshop groups, which are stored in the Drama_Workshop_Groups table under the Store_Name column.", "We need to filter the bookings based on the status code 'stop', which is found in the Bookings table.", "To link the two tables, we will use the Workshop_Group_ID, which is a common field in both tables.", "We will use a JOIN operation to combine the two tables based on the Workshop_Group_ID.", "Finally, we will select the distinct Store_Name from the Drama_Workshop_Groups table where the corresponding bookings have a status code of 'stop'."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "pred_sql": "SELECT DISTINCT dg.Store_Name\nFROM Drama_Workshop_Groups dg\nJOIN Bookings b ON dg.Workshop_Group_ID = b.Workshop_Group_ID\nWHERE b.Status_Code = 'stop';", "hint": "\n"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["Identify the relevant tables: Ref_Service_Types for service descriptions, Services for linking services to products, and Order_Items for product details.", "Join Ref_Service_Types with Services on Service_Type_Code to get the service descriptions associated with each service.", "Join Services with Order_Items to link services to the products they offer.", "Filter the products to include only those that are 'photo' and 'film' by using a subquery on the Products table.", "Group the results by Service_Type_Description to aggregate the services.", "Use HAVING to ensure that only those service types that offer both products are included, which means counting distinct Product_IDs should equal 2."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT DISTINCT rst.Service_Type_Description\nFROM Ref_Service_Types rst\nJOIN Services s ON rst.Service_Type_Code = s.Service_Type_Code\nJOIN Order_Items oi ON s.Product_ID = oi.Product_ID\nWHERE oi.Product_ID IN (\n    SELECT Product_ID\n    FROM Products\n    WHERE Product_Name IN ('photo', 'film')\n)\nGROUP BY rst.Service_Type_Description\nHAVING COUNT(DISTINCT oi.Product_ID) = 2;", "hint": "\n"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["Identify the table needed: The 'Student' table contains the age and gender information.", "Determine the condition: We need to filter for female students, so we will use the condition 'Sex = 'Female' '.", "Calculate the average age: We will use the AVG() function to calculate the average of the 'Age' column for the filtered results.", "Construct the SQL query: Combine the SELECT statement with the AVG function and the WHERE clause to filter for female students."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "pred_sql": "SELECT avg(Age) FROM Student WHERE Sex = 'Female'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for a specific candidate in the 'Voting_record' table. The placeholders in the WHERE clause represent the gender of the students and the election cycle during which the votes were cast.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["Identify the relevant tables: Student and Voting_record.", "We need to find distinct president votes, so we will select the President_Vote column from the Voting_record table.", "To get the votes on a specific date, we will filter the results based on the Registration_Date column in the Voting_record table.", "We will join the Student table with the Voting_record table on the StuID to ensure we are looking at the correct students' votes.", "The final SQL query will select distinct president votes for the specified date."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT T1.President_Vote FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.President_Vote WHERE T2.Registration_Date = '08/30/2015'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["Identify the relevant tables: Student and Voting_record.", "Determine the columns needed: distinct president votes from Voting_record.", "Join the Student table with Voting_record on the StuID and President_Vote columns.", "Filter the results based on the Registration_Date to match '08/30/2015'.", "Use DISTINCT to ensure only unique president votes are returned."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT T1.President_Vote FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.President_Vote WHERE T2.Registration_Date = '08/30/2015'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["Identify the relevant tables: Student and Voting_record.", "We need to find distinct ages of students, so we will use SELECT DISTINCT on the Age column from the Student table.", "We need to join the Student table with the Voting_record table on the condition that the StuID in the Student table matches the Secretary_Vote in the Voting_record table.", "We need to filter the results to only include records from the fall election cycle, which will be done using a WHERE clause on the Election_Cycle column."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT T1.Age FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Secretary_Vote WHERE T2.Election_Cycle = 'fall'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables: Student and Voting_record.", "Determine the relationship between the tables: Student's StuID is linked to Voting_record's Treasurer_Vote.", "We need to find unique advisors for students who voted for a treasurer in a specific election cycle.", "The hint provides a template for the SQL query, indicating to select distinct advisors from the Student table joined with the Voting_record table on the StuID and Treasurer_Vote.", "Replace the placeholder in the WHERE clause with 'spring' to specify the election cycle."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT T1.Advisor FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Treasurer_Vote WHERE T2.Election_Cycle = 'spring'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "Determine the condition for counting students: they must be male (Sex = 'M').", "Identify the voting record condition: they must have class senator votes in the fall election cycle.", "Use a JOIN to connect the 'Student' table with the 'Voting_record' table on the StuID and Class_Senator_Vote columns.", "Count the number of records that meet both conditions."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT count(*) FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Class_Senator_Vote WHERE T1.Sex = 'M' AND T2.Election_Cycle = 'fall'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are registered to vote in a specific election cycle and belong to a particular gender. The placeholders in the WHERE clause represent the gender of the students and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "Determine the columns needed: average age from 'Student' and filtering based on city code and voting record for secretary.", "Use a JOIN to connect 'Student' and 'Voting_record' on the StuID and Secretary_Vote columns.", "Apply the WHERE clause to filter students by city code 'NYC' and the specific election cycle 'spring'.", "Use the AVG function to calculate the average age of the filtered students."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT avg(T1.Age) FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Secretary_Vote WHERE T1.city_code = 'NYC' AND T2.Election_Cycle = 'spring'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["Identify the tables involved: 'Student' and 'Voting_record'.", "We need to calculate the average age, so we will use the AVG() function on the 'Age' column from the 'Student' table.", "We need to filter for female students, so we will add a WHERE clause to check if 'Sex' is 'F'.", "We also need to ensure that these students have voted for the secretary candidate, which means we will join the 'Student' table with the 'Voting_record' table on the condition that 'StuID' matches 'Secretary_Vote'.", "Finally, we need to filter for the specific election cycle, which is 'spring', by adding another condition in the WHERE clause."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT avg(T1.Age) FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Secretary_Vote WHERE T1.Sex = 'F' AND T2.Election_Cycle = 'spring'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students from the 'Student' table who voted for the secretary candidate in a specific election cycle. The placeholders in the WHERE clause represent the city code where the students reside and the election cycle identifier.\",\n        \"virtual_table\": \"SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  [PLACEHOLDER-TYPE:STRING] AND T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["Identify the requirement to find distinct first names of students who voted for the vice president.", "The relevant table for student information is the 'Student' table, which contains the 'Fname' column.", "The 'Voting_record' table contains the voting information, specifically the 'Vice_President_Vote' column, which indicates if a student voted for the vice president.", "To find students who voted for the vice president, we can use a subquery that selects 'StuID' from 'Voting_record' where 'Vice_President_Vote' is not null.", "We need to ensure that the city code is not 'PIT', which is a condition on the 'Student' table.", "Combine the results by selecting distinct first names from the 'Student' table where the 'StuID' is in the results of the subquery and the city code condition is met."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Fname FROM Student WHERE StuID IN (SELECT StuID FROM Voting_record WHERE Vice_President_Vote IS NOT NULL) AND city_code != 'PIT';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["Identify the requirement to find distinct first names of students.", "Determine that we need to filter students based on their voting record for the vice president.", "Use a subquery to find students who have cast a vote for the vice president (i.e., where Vice_President_Vote is not null).", "Add a condition to ensure that the city code of the students is not 'PIT'.", "Combine these conditions to form the final SQL query."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Fname FROM Student WHERE StuID IN (SELECT StuID FROM Voting_record WHERE Vice_President_Vote IS NOT NULL) AND city_code != 'PIT';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of ages of students who voted for the secretary candidate in a specific election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["Identify the requirement to find distinct last names of students who voted for president.", "The relevant table for student information is 'Student' and for voting records is 'Voting_record'.", "We need to filter students based on their votes for president, which is represented by the 'President_Vote' column in the 'Voting_record' table.", "We also need to ensure that the advisor of the students is not '2192'.", "To achieve this, we will use a subquery to select 'President_Vote' from 'Voting_record' and filter the main query on 'Student' table using 'StuID'.", "Finally, we will select distinct last names from the 'Student' table based on the conditions specified."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student WHERE StuID IN (SELECT President_Vote FROM Voting_record) AND Advisor != '2192';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["Identify the relevant tables: We need to retrieve data from the Student and Voting_record tables.", "Determine the columns needed: We need the distinct last names (LName) of students who voted for a president.", "Establish the relationship: We will join the Student table with the Voting_record table on the StuID and President_Vote columns.", "Apply the conditions: We need to filter the results to include only those students whose advisor is '8741'.", "Construct the SQL query: Combine all the elements into a complete SQL statement."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT LName FROM Student JOIN Voting_record ON Student.StuID = Voting_record.President_Vote WHERE Student.Advisor = '8741';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique academic advisors for students who voted for a specific treasurer in a given election cycle. The placeholder in the WHERE clause represents the election cycle identifier.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and sex.", "Filter the records: We need to focus on female students, so we will add a WHERE clause to filter by Sex = 'F'.", "Group the results: To find the most common major, we will group the results by the Major column.", "Count the occurrences: We will order the grouped results by the count of students in each major in descending order to find the most common one.", "Limit the results: Since we only want the most common major, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student WHERE Sex = 'F' GROUP BY Major ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major field of study. The results are ordered by the number of students in each major in descending order, with a limit on the number of majors returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["We need to find the major studied by the most female students.", "To do this, we will filter the Student table to include only female students by using the condition `WHERE Sex = 'Female'.", "Next, we will group the results by the Major field using `GROUP BY Major` to count the number of female students in each major.", "We will then order the results in descending order based on the count of students in each major using `ORDER BY COUNT(*) DESC`.", "Finally, we will limit the results to only the top major using `LIMIT 1`."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student WHERE Sex = 'Female' GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of academic majors from the 'Student' table, grouped by the major field of study. The results are ordered by the number of students in each major in descending order, with a limit on the number of majors returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT Major FROM STUDENT GROUP BY major ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to count the number of products, so we will use COUNT(*) in the SELECT statement.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to filter by category.", "Add a WHERE clause to filter for products in the 'Spices' category and with a typical selling price greater than 1000."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT COUNT(*) FROM Products AS p JOIN Ref_Product_Categories AS c ON p.product_category_code = c.product_category_code WHERE c.product_category_description = 'Spices' AND p.typical_selling_price > 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "We need to retrieve the product category descriptions, so we will select from Ref_Product_Categories.", "Join the Products table with Ref_Product_Categories on the product_category_code to link products to their categories.", "Filter the products based on their descriptions containing the letter 't' using the LIKE operator.", "Use DISTINCT to ensure that we get unique category descriptions."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description \nFROM Products p \nJOIN Ref_Product_Categories rpc ON p.product_category_code = rpc.product_category_code \nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["Identify the main table to query from, which is the 'Products' table.", "We need to count distinct characteristic names, so we will use the COUNT and DISTINCT functions.", "Join the 'Products' table with the 'Product_Characteristics' table on the product_id to link products with their characteristics.", "Next, join the 'Product_Characteristics' table with the 'Characteristics' table on the characteristic_id to access the characteristic names.", "Filter the results to only include the product with the name 'cumin' using a WHERE clause."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM Products AS t1 JOIN Product_Characteristics AS t2 ON t1.product_id = t2.product_id JOIN Characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id WHERE t1.product_name = 'cumin'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["Identify the tables involved: Products, Product_Characteristics, Characteristics, and Ref_Colors.", "Determine the relationships between the tables using foreign keys: Products to Product_Characteristics, Product_Characteristics to Characteristics, and Products to Ref_Colors.", "Use a JOIN operation to combine these tables based on their relationships.", "Specify the conditions in the WHERE clause to filter products by color description ('white') or characteristic name ('hot').", "Count the number of products that meet either of these conditions using the COUNT function."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT count(*) FROM Products AS t1 JOIN Product_Characteristics AS t2 ON t1.product_id = t2.product_id JOIN Characteristics AS t3 ON t2.characteristic_id = t3.characteristic_id JOIN Ref_Colors AS t4 ON t1.color_code = t4.color_code WHERE t4.color_description = 'white' OR t3.characteristic_name = 'hot'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products that either match a specific color description or have a specific characteristic name. It combines data from multiple tables, including 'Products', 'Product_Characteristics', 'Characteristics', and 'Ref_Colors', using their respective foreign key relationships. The placeholders in the WHERE clause represent the color description and characteristic name that the user can specify.\",\n        \"virtual_table\": \"SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  [PLACEHOLDER-TYPE:STRING] OR t3.characteristic_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: We need to find the unit of measure for 'Herb' products, which involves the Products and Ref_Product_Categories tables.", "Determine the relationship: The Products table has a foreign key relationship with the Ref_Product_Categories table through the product_category_code.", "Find the product category code for 'Herb': We need to first find the product_category_code associated with the product name 'Herb' in the Products table.", "Select the unit of measure: Once we have the product_category_code, we can query the Ref_Product_Categories table to get the unit_of_measure associated with that code."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT unit_of_measure FROM Ref_Product_Categories WHERE product_category_code = (SELECT product_category_code FROM Products WHERE product_name = 'Herb')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the columns needed: unit_of_measure and product_category_code.", "Establish the relationship between Products and Ref_Product_Categories using the product_category_code.", "Filter the results based on the product name 'chervil'.", "Construct the SQL query using JOIN to combine the necessary tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT rpc.product_category_code, rpc.unit_of_measure FROM Products AS p JOIN Ref_Product_Categories AS rpc ON p.product_category_code = rpc.product_category_code WHERE p.product_name = 'chervil';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct characteristic names associated with a specific product from the 'Products' table. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["Identify the tables involved: Products and Ref_Colors.", "We need to join these tables on the color_code to get the color descriptions for the products.", "We will group the results by color_description to count how many products correspond to each color.", "To find the color description for the most products, we will order the results by the count of products in descending order.", "Finally, we will limit the results to 1 to get the top color description."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT t2.color_description FROM Products AS t1 JOIN Ref_Colors AS t2 ON t1.color_code = t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["Identify the tables involved: Products and Ref_Colors.", "We need to join these tables on the color_code to get the color descriptions associated with each product.", "We want to count the number of products for each color, so we will group the results by color description.", "To find the color used by the least products, we will order the results by the count of products in ascending order.", "Finally, we will limit the results to 1 to get the color description used by the least products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT t2.color_description FROM Products AS t1 JOIN Ref_Colors AS t2 ON t1.color_code = t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the color descriptions of products from the 'Products' table, grouped by color and ordered by the count of products for each color. The placeholder in the LIMIT clause represents the maximum number of color descriptions to return.\",\n        \"virtual_table\": \"SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To do this, we will join the 'Product_Characteristics' table with the 'Characteristics' table to get the characteristic names.", "We also need to join the 'Products' table to link characteristics to specific products.", "We will group the results by characteristic name to count how many distinct products each characteristic is associated with.", "Finally, we will use the HAVING clause to filter the results to only include characteristics that are linked to two or more distinct products."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT c.characteristic_name\nFROM Product_Characteristics pc\nJOIN Characteristics c ON pc.characteristic_id = c.characteristic_id\nJOIN Products p ON pc.product_id = p.product_id\nGROUP BY c.characteristic_name\nHAVING COUNT(DISTINCT p.product_id) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of characteristics associated with a specific product from the 'Products' table. The query joins the 'Products', 'Product_Characteristics', and 'Characteristics' tables to filter characteristics based on the product's name and the type of characteristic. The placeholders in the WHERE clause represent the product's name and the characteristic type code.\",\n        \"virtual_table\": \"SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  [PLACEHOLDER-TYPE:STRING] AND t3.characteristic_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to query.", "Select the 'Builder' column: We want to list the builders, so we will select this column.", "Use DISTINCT to avoid duplicate entries: Since multiple railways can have the same builder, we will use DISTINCT to ensure each builder is listed only once.", "Order the results: We need the results in ascending alphabetical order, so we will use ORDER BY Builder ASC.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "pred_sql": "SELECT DISTINCT Builder FROM railway ORDER BY Builder ASC;", "hint": "\n"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables: railway and train.", "We need to find the railway associated with the most trains, so we will join the railway table with the train table on the Railway_ID.", "We will group the results by Railway_ID and Builder to count the number of trains associated with each railway.", "Use COUNT(train.Train_ID) to count the number of trains for each railway.", "Order the results in descending order based on the count of trains to get the railway with the most trains at the top.", "Limit the results to 1 to get only the railway associated with the most trains."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "pred_sql": "SELECT railway.Railway_ID, railway.Builder \nFROM railway \nJOIN train ON railway.Railway_ID = train.Railway_ID \nGROUP BY railway.Railway_ID, railway.Builder \nORDER BY COUNT(train.Train_ID) DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["We need to find the most common builder of railways, which means we will be counting how many railways each builder has constructed.", "To do this, we will select the 'Builder' column from the 'railway' table and count the occurrences of each builder using COUNT(*).", "We will group the results by 'Builder' to aggregate the counts for each builder.", "To find the most common builder, we will order the results in descending order based on the count of railways constructed by each builder.", "Finally, we will limit the results to just one entry to get the most common builder."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "pred_sql": "SELECT Builder, COUNT(*) as BuilderCount \nFROM railway \nGROUP BY Builder \nORDER BY BuilderCount DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the table to query: The relevant table is 'Student' since we need student information.", "Determine the columns needed: We need the 'LName' column for the last names of the students.", "Define the conditions for selection: We need students who are either female, live in a city with the code 'BAL', or are male and under 20 years old.", "Construct the SQL query using the SELECT statement with the WHERE clause to filter based on the defined conditions."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "pred_sql": "SELECT LName FROM Student WHERE (Sex = 'Female') OR (city_code = 'BAL') OR (Sex = 'Male' AND Age < '20');", "hint": "\n"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["Identify the tables needed: Dorm and Has_amenity.", "We need to count the amenities for each dorm, so we will join Dorm and Has_amenity on the dormid.", "We need to filter the dorms that can accommodate more than 100 students, so we will add a WHERE clause for student_capacity > 100.", "We will group the results by dormid to get the count of amenities for each dorm.", "Finally, we will select the dorm name and the count of amenities."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "pred_sql": "SELECT D.dorm_name, COUNT(HA.amenid) AS amenity_count \nFROM Dorm AS D \nJOIN Has_amenity AS HA ON D.dormid = HA.dormid \nWHERE D.student_capacity > 100 \nGROUP BY D.dormid;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table lists the names of amenities available in dormitories, grouped by their identifiers and ordered by the count of occurrences in descending order. The placeholder in the LIMIT clause represents the maximum number of amenities to display.\",\n        \"virtual_table\": \"SELECT T1.amenity_name FROM dorm_amenity AS T1 JOIN has_amenity AS T2 ON T1.amenid  =  T2.amenid GROUP BY T2.amenid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables needed: We need to count students, so we will use the 'Student' table and the 'Lives_in' table to find out where students live.", "Join the 'Student' table with the 'Lives_in' table on the student ID to link students with their dorms.", "Next, we need to filter the dorms based on gender. We will join the 'Dorm' table to access the gender information of the dorms.", "We will apply a WHERE clause to filter for dorms that are designated for males (D.gender = 'male').", "Finally, we will use COUNT(*) to get the total number of students living in male dorms."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(*) FROM Student AS S JOIN Lives_in AS L ON S.StuID = L.stuid JOIN Dorm AS D ON L.dormid = D.dormid WHERE D.gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["Identify the tables involved: Student, Lives_in, Dorm, Has_amenity, and Dorm_amenity.", "We need to find the first names of students living in the dorm with the most amenities.", "Join the Student table with the Lives_in table to link students to their dorms.", "Use a subquery to find the dormid of the dorm with the most amenities.", "In the subquery, join the Dorm table with Has_amenity and Dorm_amenity to count the amenities per dorm.", "Group the results by dormid and order them by the count of amenities in descending order.", "Limit the results of the subquery to 1 to get the dorm with the most amenities."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT T1.Fname FROM Student AS T1 JOIN Lives_in AS T2 ON T1.StuID = T2.stuid WHERE T2.dormid IN (SELECT T3.dormid FROM Dorm AS T3 JOIN Has_amenity AS T4 ON T3.dormid = T4.dormid JOIN Dorm_amenity AS T5 ON T4.amenid = T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the information needed: first name and age of students living in dorms with a TV Lounge.", "Determine the relationships between tables: Students live in dorms, and dorms have amenities.", "Use the Lives_in table to find students associated with dorms.", "Filter dorms based on the presence of the 'TV Lounge' amenity using the Has_amenity and Dorm_amenity tables.", "Construct the SQL query to select the first name and age from the Student table where the student ID matches those found in the nested query."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "pred_sql": "SELECT Fname, Age FROM Student WHERE StuID IN (SELECT stuid FROM Lives_in WHERE dormid IN (SELECT dormid FROM Has_amenity WHERE amenid = (SELECT amenid FROM Dorm_amenity WHERE amenity_name = 'TV Lounge'))))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who reside in dormitories that have the most amenities. The query joins the 'Student' table with the 'Lives_in' table to find students living in specific dorms, and it filters those dorms based on the count of amenities they offer, limited by a specified number placeholder.\",\n        \"virtual_table\": \"SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the main goal: Retrieve the email addresses of customers who have filed complaints about the product with the greatest number of complaints.", "To find the product with the greatest number of complaints, a subquery is needed that counts complaints grouped by product_id and orders them in descending order, limiting the result to the top product.", "Join the Customers table with the Complaints table on customer_id to get the email addresses of customers who have made complaints.", "Use the result of the subquery to filter the complaints to only those related to the product with the highest complaint count."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT t1.email_address FROM Customers AS t1 JOIN Complaints AS t2 ON t1.customer_id = t2.customer_id WHERE t2.product_id = (SELECT product_id FROM Complaints GROUP BY product_id ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["Identify the customer who has filed the least amount of complaints by using a subquery that counts the number of complaints per customer and orders them in ascending order, limiting the result to 1.", "Join the Complaints table with the Products table to find the products associated with the complaints made by the identified customer.", "Select the product names from the Products table where the product_id matches the complaints made by the customer with the least complaints."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT p.product_name FROM Products p JOIN Complaints c ON p.product_id = c.product_id WHERE c.customer_id = (SELECT customer_id FROM Customers c1 JOIN Complaints c2 ON c1.customer_id = c2.customer_id GROUP BY c1.customer_id ORDER BY COUNT(*) ASC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the relevant tables: Staff, Complaints, and Products.", "We need to find the last name of the staff member handling a complaint related to the product with the lowest price.", "Join the Staff table with the Complaints table on staff_id to link staff members to the complaints they handle.", "Join the Complaints table with the Products table on product_id to access product details related to each complaint.", "Use a subquery to find the minimum product price from the Products table.", "Filter the results to only include the staff member associated with the complaint for the product that has the lowest price."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT s.last_name \nFROM Staff s \nJOIN Complaints c ON s.staff_id = c.staff_id \nJOIN Products p ON c.product_id = p.product_id \nWHERE p.product_price = (SELECT MIN(product_price) FROM Products);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["Identify the relevant table: The Complaints table contains the complaint status information.", "Determine the required fields: We need the complaint status code and the count of records for each status.", "Group the results: Use GROUP BY to aggregate the results by complaint status code.", "Filter the results: Use HAVING to filter out complaint statuses that have 3 or fewer records."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "pred_sql": "SELECT complaint_status_code, COUNT(*) as record_count \nFROM Complaints \nGROUP BY complaint_status_code \nHAVING COUNT(*) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the need to count customers based on their type.", "Use the Customers table to access customer data.", "Group the results by customer_type_code to count how many customers belong to each type.", "Order the results in descending order to find the most common customer type.", "Limit the results to 1 to get only the most common customer type."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT count(*) FROM Customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of customers grouped by their type, allowing for an analysis of the distribution of different customer types. The placeholder in the LIMIT clause represents the maximum number of customer types to display, enabling users to specify how many top customer types they wish to see.\",\n        \"virtual_table\": \"SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to find the first names of staff members, so we will select the 'first_name' column from the Staff table.", "To determine how many complaints each staff member has handled, we will join the Staff table with the Complaints table on the 'staff_id' column.", "We will group the results by 'staff_id' to aggregate the number of complaints handled by each staff member.", "We will order the results in descending order based on the count of complaints to get the staff who handled the most complaints at the top.", "Finally, we will limit the results to the top 5 staff members."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT s.first_name FROM Staff s JOIN Complaints c ON s.staff_id = c.staff_id GROUP BY s.staff_id ORDER BY COUNT(c.complaint_id) DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["We need to return the first names of staff members who have handled complaints.", "To find out which staff members have handled complaints, we will join the Staff table with the Complaints table on the staff_id column.", "We will group the results by staff_id to aggregate the number of complaints each staff member has handled.", "Next, we will order the results by the count of complaints in descending order to get the staff members who handled the most complaints at the top.", "Finally, we will limit the results to the top 5 staff members."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT s.first_name FROM Staff s JOIN Complaints c ON s.staff_id = c.staff_id GROUP BY s.staff_id ORDER BY COUNT(c.complaint_id) DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of email addresses of customers who have made complaints, grouped by customer ID. The results are ordered by the number of complaints each customer has made, and the number of results returned can be limited using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The user wants to see all investor details, which means we need to select all columns from the Investors table.", "The SQL query to retrieve all columns from a table is done using 'SELECT *'.", "We specify the table name 'Investors' to get the data from that specific table."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "pred_sql": "SELECT * FROM Investors;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["Identify the main goal: to show details of all investors who have made transactions with a share count greater than 100.", "Determine the relevant tables: Investors and Transactions are the main tables needed for this query.", "Establish the relationship between the tables: Investors are linked to Transactions through the investor_id.", "Construct the SQL query: Select the investor_id and Investor_details from the Investors table, joining it with the Transactions table on investor_id, and filter the results where the share_count in Transactions is greater than 100."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "pred_sql": "SELECT I.investor_id, I.Investor_details \nFROM Investors AS I \nJOIN Transactions AS T ON I.investor_id = T.investor_id \nWHERE T.share_count > 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["Identify the tables involved: Lots, Transactions, and Transactions_Lots.", "We need to retrieve lot details, so we will select 'lot_details' from the Lots table.", "To link lots with transactions, we will use the Transactions_Lots table, which connects the Transactions and Lots tables.", "We need to filter transactions based on the share count being smaller than 50, so we will add a WHERE clause for that condition.", "Construct the SQL query using JOINs to connect the tables and apply the necessary filter."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT L.lot_details \nFROM Lots AS L \nJOIN Transactions_Lots AS TL ON L.lot_id = TL.lot_id \nJOIN Transactions AS T ON TL.transaction_id = T.transaction_id \nWHERE T.share_count < 50;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["Identify the tables needed: We need the Transactions table for transaction amounts and the Ref_Transaction_Types table for transaction type descriptions.", "Join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to get the descriptions of each transaction type.", "Use the AVG() function to calculate the average transaction amount for each transaction type.", "Group the results by transaction type description to get the average for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\",\n        \"virtual_table\": \"SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["Identify the relevant tables: Transactions and Ref_Transaction_Types.", "We need to group the results by transaction type, which is found in the Ref_Transaction_Types table.", "We want to calculate the maximum and minimum share counts for each transaction type, which requires using the MAX() and MIN() functions on the share_count column in the Transactions table.", "Join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to get the descriptions of the transaction types along with their share counts.", "Use GROUP BY to group the results by transaction_type_code to get the max and min share counts for each type."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_code, MAX(t.share_count) AS max_share_count, MIN(t.share_count) AS min_share_count\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the different types of transactions recorded in the 'Transactions' table, grouping them by their unique transaction type codes. The results are ordered by the frequency of each transaction type, allowing users to see the most common transaction types up to a specified limit. The placeholder in the LIMIT clause represents the maximum number of transaction types to return.\",\n        \"virtual_table\": \"SELECT transaction_type_code FROM TRANSACTIONS GROUP BY transaction_type_code ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["Identify the tables needed to get sales and purchases details: Sales and Purchases.", "Determine the columns to select: sales_details from Sales and purchase_details from Purchases.", "Establish a relationship between Sales and Purchases using the transaction_id, which is common in both tables.", "Construct the SQL query to select the desired columns from both tables using a JOIN."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "pred_sql": "SELECT S.sales_details, P.purchase_details \nFROM Sales AS S \nJOIN Purchases AS P ON S.sales_transaction_id = P.purchase_transaction_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the details of lots associated with transactions that involve a specific number of shares and a particular type of transaction. The placeholders in the WHERE clause represent the minimum share count and the transaction type code.\",\n        \"virtual_table\": \"SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON  T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  >  [PLACEHOLDER-TYPE:NUMBER] AND T3.transaction_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5898", "db_id": "cre_Theme_park", "question": "What is the average price range of five star hotels that allow pets?", "rationale": ["Identify the relevant table: The Hotels table contains the necessary information about hotel star ratings and pet policies.", "Determine the criteria: We need to filter for five-star hotels, which corresponds to the star_rating_code '5', and we also need to check if pets are allowed, which is indicated by pets_allowed_yn being 'Yes'.", "Construct the SQL query: Using the average function (avg) to calculate the average price range of the filtered hotels, we can structure the SQL query accordingly."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "pred_sql": "SELECT avg(price_range) FROM Hotels WHERE star_rating_code = '5' AND pets_allowed_yn = 'Yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average price range of hotels from the 'Hotels' table that meet specific criteria. The placeholders in the WHERE clause represent the star rating code and whether pets are allowed, allowing users to specify their desired conditions.\",\n        \"virtual_table\": \"SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  [PLACEHOLDER-TYPE:STRING] AND pets_allowed_yn  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5904", "db_id": "cre_Theme_park", "question": "Find all the locations whose names contain the word \"film\".", "rationale": ["Identify the table that contains location names: Locations.", "Determine the column that holds the names of the locations: Location_Name.", "Use the SQL SELECT statement to retrieve all columns from the Locations table.", "Apply a WHERE clause to filter the results where Location_Name contains the word 'film'.", "Use the LIKE operator with wildcards '%' to match any location names that include 'film'."], "gold_sql": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE '%film%'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name LIKE '%film%';", "hint": "\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["Identify the relevant tables: Museums and Tourist_Attractions.", "Determine the columns needed: Museum_ID and Museum_Details from Museums, and Opening_Hours from Tourist_Attractions.", "Establish the relationship between the tables: Museums are linked to Tourist_Attractions through the Tourist_Attraction_ID.", "Construct the SQL query to select the required details from the joined tables."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museums.Museum_ID, Museums.Museum_Details, Tourist_Attractions.Opening_Hours \nFROM Museums \nJOIN Tourist_Attractions ON Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5916", "db_id": "cre_Theme_park", "question": "Give me the detail and opening hour for each museum.", "rationale": ["Identify the relevant tables: Museums and Tourist_Attractions.", "Determine the columns needed: Museum_Details from Museums and Opening_Hours from Tourist_Attractions.", "Establish the relationship between the tables: Museums are linked to Tourist_Attractions through the Museum_ID and Tourist_Attraction_ID.", "Construct the SQL query to select the required details from the joined tables."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT Museums.Museum_Details, Tourist_Attractions.Opening_Hours \nFROM Museums \nJOIN Tourist_Attractions ON Museums.Museum_ID = Tourist_Attractions.Tourist_Attraction_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Royal_Family.", "Determine the relationship between the tables: Tourist_Attractions has a foreign key linking to Royal_Family.", "Select the required fields: Name, Description, How_to_Get_There, and Other_Details from Tourist_Attractions.", "Construct the SQL query using a JOIN to combine the two tables based on the relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT TA.Name, TA.Description, TA.How_to_Get_There, TA.Other_Details \nFROM Tourist_Attractions AS TA \nJOIN Royal_Family AS RF ON TA.Tourist_Attraction_ID = RF.Royal_Family_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5923", "db_id": "cre_Theme_park", "question": "What are the details of the shops that can be accessed by walk?", "rationale": ["Identify the relevant tables: Shops and Tourist_Attractions.", "Determine the relationship between the tables: Shops are linked to Tourist_Attractions through the Shop_ID and Tourist_Attraction_ID.", "Filter the Tourist_Attractions based on the access method specified in the question, which is 'walk'.", "Construct the SQL query to select the Shop_Details from the Shops table where the corresponding Tourist_Attraction allows access by walking."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT S.Shop_Details FROM Shops AS S JOIN Tourist_Attractions AS T ON S.Shop_ID = T.Tourist_Attraction_ID WHERE T.How_to_Get_There = 'walk'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5931", "db_id": "cre_Theme_park", "question": "Which tourist attractions does the visitor with detail 'Vincent' visit?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Visits, and Visitors.", "We need to find tourist attractions visited by a specific visitor, so we will join the Visits table with the Tourist_Attractions table on the Tourist_Attraction_ID.", "Next, we will join the Visitors table to filter the results based on the visitor's details, specifically looking for 'Vincent'.", "The final query will select the Name and Description of the tourist attractions that match the visitor's details."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT TA.Name, TA.Description FROM Tourist_Attractions AS TA JOIN Visits AS V ON TA.Tourist_Attraction_ID = V.Tourist_Attraction_ID JOIN Visitors AS VI ON V.Tourist_ID = VI.Tourist_ID WHERE VI.Tourist_Details = 'Vincent';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5932", "db_id": "cre_Theme_park", "question": "Show the tourist attractions visited by the tourist whose detail is 'Vincent'.", "rationale": ["Identify the relevant tables: Tourist_Attractions, Visits, and Visitors are needed to find the attractions visited by a specific tourist.", "The Tourist_Attractions table contains the details of the attractions, while the Visits table links tourists to the attractions they visited.", "The Visitors table contains the details of the tourists, including the one we are interested in, whose detail is 'Vincent'.", "Join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID to get the attractions visited.", "Join the resulting table with the Visitors table on Tourist_ID to filter for the tourist with the detail 'Vincent'.", "Select the relevant columns from the Tourist_Attractions table to display the attractions visited by Vincent."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT TA.Name, TA.Description, TA.Opening_Hours, TA.Other_Details \nFROM Tourist_Attractions AS TA \nJOIN Visits AS V ON TA.Tourist_Attraction_ID = V.Tourist_Attraction_ID \nJOIN Visitors AS T ON V.Tourist_ID = T.Tourist_ID \nWHERE T.Tourist_Details = 'Vincent';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5941", "db_id": "cre_Theme_park", "question": "Show the details of the top 3 most expensive hotels.", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "Determine the columns needed: 'other_hotel_details' and 'star_rating_code'.", "To find the most expensive hotels, order the results by 'price_range' in descending order.", "Limit the results to the top 3 entries to get the most expensive hotels."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT other_hotel_details, star_rating_code FROM Hotels ORDER BY price_range DESC LIMIT 3", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "Determine the columns needed: 'other_hotel_details' for additional information and 'star_rating_code' for the star rating.", "To find the most expensive hotels, order the results by 'price_range' in descending order.", "Limit the results to the top 3 entries to get the three most expensive hotels."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT other_hotel_details, star_rating_code FROM Hotels ORDER BY price_range DESC LIMIT 3", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5944", "db_id": "cre_Theme_park", "question": "What are the details and star ratings of the three hotels with the lowest price ranges?", "rationale": ["Identify the relevant table: Hotels contains the necessary information about hotel details and star ratings.", "Select the required columns: other_hotel_details and star_rating_code are needed for the output.", "Order the results: The hotels should be ordered by price_range in ascending order to get the lowest price ranges first.", "Limit the results: We need only the top three hotels, so we use LIMIT 3."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT other_hotel_details, star_rating_code FROM Hotels ORDER BY price_range ASC LIMIT 3", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about hotels, specifically their additional information and star rating codes. The results are ordered by the price range of the hotels in ascending order, and the number of results returned is limited by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["The user wants to know the transportation method most people choose to get to tourist attractions.", "The hint provided mentions a virtual table that links street markets to tourist attractions and filters based on the 'How to Get There' instructions.", "To find the most common transportation methods, I will use the 'How_to_Get_There' column from the Tourist_Attractions table.", "I will assume common methods like 'public transport' and 'walking' as examples to filter the results.", "The SQL query will join the Street_Markets table with the Tourist_Attractions table on the Tourist_Attraction_ID and filter based on the transportation methods."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN Tourist_Attractions AS T2 ON T1.Market_ID = T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There = 'public transport' OR T2.How_to_Get_There = 'walking'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["Identify the relevant table: The question pertains to transportation methods used to reach tourist attractions, which is related to the 'Tourist_Attractions' table and its 'How_to_Get_There' column.", "Count occurrences: We need to count how many times each transportation method appears in the 'How_to_Get_There' column.", "Group by transportation method: To get the count for each method, we will group the results by the 'How_to_Get_There' column.", "Order by count: To find the most frequently used method, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most used method, we will limit the results to 1."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT T2.How_to_Get_There, COUNT(*) AS Method_Count \nFROM Tourist_Attractions AS T2 \nGROUP BY T2.How_to_Get_There \nORDER BY Method_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5955", "db_id": "cre_Theme_park", "question": "Show the names and ids of tourist attractions that are visited at most once.", "rationale": ["Identify the Tourist_Attraction_ID and Name from the Tourist_Attractions table.", "We need to filter attractions that have been visited at most once.", "To do this, we can use a subquery that counts the number of visits for each Tourist_Attraction_ID in the Visits table.", "The subquery groups the visits by Tourist_Attraction_ID and uses HAVING COUNT(Tourist_ID) > 1 to find attractions visited more than once.", "The main query selects attractions whose IDs are not in the result of the subquery, meaning they have been visited at most once."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attraction_ID, Name FROM Tourist_Attractions WHERE Tourist_Attraction_ID NOT IN (SELECT Tourist_Attraction_ID FROM Visits GROUP BY Tourist_Attraction_ID HAVING COUNT(Tourist_ID) > 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5956", "db_id": "cre_Theme_park", "question": "What are the names and ids of the tourist attractions that are visited at most once?", "rationale": ["Identify the relevant table: Tourist_Attractions contains the names and IDs of tourist attractions.", "Determine the criteria: We need to find attractions that are visited at most once, which means we need to count the visits for each attraction.", "Use the Visits table to count the number of visits per Tourist_Attraction_ID.", "Filter the results to include only those attractions that have a visit count of 1 or less.", "Construct the SQL query to select the Tourist_Attraction_ID and Name from Tourist_Attractions where the ID is not in the list of attractions that have more than one visit."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attraction_ID, Name FROM Tourist_Attractions WHERE Tourist_Attraction_ID NOT IN (SELECT Tourist_Attraction_ID FROM Visits GROUP BY Tourist_Attraction_ID HAVING COUNT(Tourist_ID) > 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find the names of tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions with their features.", "Then, join the Features table to get the details of those features.", "Use a WHERE clause to filter the results to only include features that are either 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet the criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Tourist_Attractions \nJOIN Tourist_Attraction_Features ON Tourist_Attractions.Tourist_Attraction_ID = Tourist_Attraction_Features.Tourist_Attraction_ID \nJOIN Features ON Tourist_Attraction_Features.Feature_ID = Features.Feature_ID \nWHERE Features.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find the names of tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions with their features.", "Then, join the Features table to get the details of those features.", "Use a WHERE clause to filter the results to only include attractions that have 'parking' or 'shopping' as their feature details."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Tourist_Attractions \nJOIN Tourist_Attraction_Features ON Tourist_Attractions.Tourist_Attraction_ID = Tourist_Attraction_Features.Tourist_Attraction_ID \nJOIN Features ON Tourist_Attraction_Features.Feature_ID = Features.Feature_ID \nWHERE Features.Feature_Details IN ('parking', 'shopping');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to specific tourist attractions. The query filters the results based on the instructions on how to reach the attractions, allowing users to specify one or two different methods of access.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5963", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions Vincent and Marcelle visit?", "rationale": ["Identify the tables needed: We need to find tourist attractions visited by specific tourists, so we will use the 'Visits', 'Tourist_Attractions', and 'Visitors' tables.", "Join the 'Visits' table with 'Tourist_Attractions' to get the names of the attractions corresponding to each visit.", "Join the 'Visits' table with 'Visitors' to filter the visits by the names of the tourists, Vincent and Marcelle.", "Use a WHERE clause to specify that we are only interested in visits made by Vincent and Marcelle."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT Tourist_Attractions.Name \nFROM Visits \nJOIN Tourist_Attractions ON Visits.Tourist_Attraction_ID = Tourist_Attractions.Tourist_Attraction_ID \nJOIN Visitors ON Visits.Tourist_ID = Visitors.Tourist_ID \nWHERE Visitors.Tourist_Details IN ('Vincent', 'Marcelle');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides details about street markets that are linked to tourist attractions based on specific directions on how to reach them. The placeholders in the WHERE clause represent the different sets of instructions for accessing the attractions.\",\n        \"virtual_table\": \"SELECT T1.Market_Details FROM Street_Markets AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Market_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING] OR  T2.How_to_Get_There  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5985", "db_id": "game_1", "question": "Which game type has most number of games?", "rationale": ["Identify the table that contains the game types, which is the 'Video_Games' table.", "We need to group the results by the game type to count how many games belong to each type.", "Use the COUNT function to count the number of games in each genre.", "Order the results in descending order to get the type with the most games at the top.", "Limit the results to 1 to get only the game type with the highest count."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType FROM Video_Games GROUP BY GType ORDER BY COUNT(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the types or genres of video games from the 'Video_Games' table, grouped by their type. The placeholder in the LIMIT clause allows the user to specify the maximum number of genres to retrieve, sorted by the number of games in each genre in descending order.\",\n        \"virtual_table\": \"SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5988", "db_id": "game_1", "question": "What is the type with the fewest games?", "rationale": ["Identify the table that contains the information about video game types, which is the 'Video_Games' table.", "We need to group the results by the type of video games (GType) to count how many games belong to each type.", "To find the type with the fewest games, we will order the results by the count of games in ascending order.", "Finally, we will limit the results to only one entry to get the type with the fewest games."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType FROM Video_Games GROUP BY GType ORDER BY COUNT(*) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the types or genres of video games from the 'Video_Games' table, grouped by their type. The placeholder in the LIMIT clause allows the user to specify the maximum number of genres to retrieve, sorted by the number of games in each genre in descending order.\",\n        \"virtual_table\": \"SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6001", "db_id": "game_1", "question": "How many students play sports?", "rationale": ["The question asks for the total number of students who play sports.", "To find this, we need to count the unique student identifiers (StuID) in the SportsInfo table, as this table contains information about students participating in sports.", "Using COUNT(*) will give us the total number of entries in the SportsInfo table, which corresponds to the number of students who play sports."], "gold_sql": "SELECT count(DISTINCT StuID) FROM Sportsinfo", "source_tables": ["sportsinfo"], "pred_sql": "SELECT COUNT(*) FROM SportsInfo;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6003", "db_id": "game_1", "question": "List ids for all student who are on scholarship.", "rationale": ["The user wants to list the IDs of students who are on a sports scholarship.", "We need to query the SportsInfo table because it contains information about students participating in sports and their scholarship status.", "We will select the 'StuID' column from the SportsInfo table.", "We will filter the results using a WHERE clause to include only those students who are on a scholarship, which is indicated by the 'OnScholarship' column being equal to 'Yes'."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6004", "db_id": "game_1", "question": "What are the ids for all sporty students who are on scholarship?", "rationale": ["Identify the relevant table: SportsInfo contains information about students involved in sports and their scholarship status.", "Focus on the condition: We need to filter students who are on a sports scholarship, which is indicated by the 'OnScholarship' column.", "Select the unique identifier: We want the ids of these students, which corresponds to the 'StuID' column in the SportsInfo table."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6006", "db_id": "game_1", "question": "What are the last names for all scholarship students?", "rationale": ["Identify the relevant table: We need to find students who are on a sports scholarship, which is stored in the SportsInfo table.", "Determine the condition: We are looking for students who have 'OnScholarship' marked as 'Yes'.", "Select the relevant columns: We need the last names of these students, which are in the Student table under the column 'LName'.", "Use a subquery: To find the last names, we will use a subquery to get the StuID of students who are on a scholarship from the SportsInfo table.", "Combine the results: The main query will select the last names from the Student table where the StuID matches those from the subquery."], "gold_sql": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT LName FROM Student WHERE StuID IN (SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6010", "db_id": "game_1", "question": "What is the total number of all football games played by scholarship students?", "rationale": ["Identify the relevant table: SportsInfo contains information about sports participation and scholarship status.", "Determine the specific sport of interest: The query asks for football games played.", "Filter for scholarship students: We need to include only those students who are on a sports scholarship, indicated by the OnScholarship column.", "Construct the SQL query using the provided virtual table structure, replacing placeholders with actual values: 'football' for SportName and 'yes' for OnScholarship."], "gold_sql": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  'Football' AND onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT sum(GamesPlayed) FROM SportsInfo WHERE SportName = 'football' AND OnScholarship = 'yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6014", "db_id": "game_1", "question": "What are the ids of all students along with how many sports and games did they play?", "rationale": ["Identify the main entities involved: students, sports, and games.", "We need to retrieve the student IDs along with the count of sports and games they are involved in.", "Use the Student table to get the student IDs.", "Join the SportsInfo table to count the number of sports each student is involved in.", "Join the Plays_Games table to count the number of games each student has played.", "Use LEFT JOIN to ensure we include students who may not be involved in sports or games.", "Group the results by Student ID to aggregate the counts of sports and games."], "gold_sql": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID", "source_tables": ["sportsinfo"], "pred_sql": "SELECT Student.StuID, COUNT(DISTINCT SportsInfo.SportName) AS TotalSports, COUNT(DISTINCT Plays_Games.GameID) AS TotalGames\nFROM Student\nLEFT JOIN SportsInfo ON Student.StuID = SportsInfo.StuID\nLEFT JOIN Plays_Games ON Student.StuID = Plays_Games.StuID\nGROUP BY Student.StuID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6019", "db_id": "game_1", "question": "Which sport has most number of students on scholarship?", "rationale": ["We need to find out which sport has the most number of students on scholarship.", "We will focus on the SportsInfo table, which contains information about students participating in sports and their scholarship status.", "We will filter the records to include only those students who are on a sports scholarship (OnScholarship = 'Yes').", "Next, we will group the results by SportName to aggregate the data for each sport.", "To find the sport with the most students on scholarship, we will count the number of students for each sport and order the results in descending order.", "Finally, we will limit the results to just one entry to get the sport with the highest count."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName FROM SportsInfo WHERE OnScholarship = 'Yes' GROUP BY SportName ORDER BY SUM(GamesPlayed) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6020", "db_id": "game_1", "question": "What is the sport with the most scholarship students?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Filter for students on a sports scholarship by using the condition 'OnScholarship = 'Yes' in the WHERE clause.", "Group the results by SportName to aggregate the total number of games played for each sport.", "Use the SUM function to calculate the total games played for each sport.", "Order the results in descending order based on the total games played to find the sport with the most scholarship students.", "Limit the results to 1 to get only the sport with the highest total games played."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName, SUM(GamesPlayed) AS TotalGamesPlayed\nFROM SportsInfo\nWHERE OnScholarship = 'Yes'\nGROUP BY SportName\nORDER BY TotalGamesPlayed DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6024", "db_id": "game_1", "question": "What are the student ids for those on scholarship in major number 600?", "rationale": ["Identify the requirement: We need to find student IDs of those who are on a sports scholarship and have a specific major (number 600).", "The relevant table for scholarship information is 'SportsInfo', which contains the 'OnScholarship' column.", "The 'Student' table contains the 'Major' column, which we need to filter by major number 600.", "We will use a subquery to first filter students by major 600 and then check if they are on a scholarship in the 'SportsInfo' table.", "The final SQL query will select the 'StuID' from 'SportsInfo' where 'OnScholarship' is 'Yes' and the 'StuID' is in the list of IDs from the 'Student' table with major 600."], "gold_sql": "SELECT StuID FROM Student WHERE major  =  600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes' AND StuID IN (SELECT StuID FROM Student WHERE Major = '600')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6025", "db_id": "game_1", "question": "Show student ids who are female and play football.", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for student information and the 'SportsInfo' table for sports participation.", "Determine the conditions: We want female students, which is specified in the 'Sex' column of the 'Student' table, and we want to filter for those who play football, which is specified in the 'SportName' column of the 'SportsInfo' table.", "Join the tables: Since we need information from both the 'Student' and 'SportsInfo' tables, we will perform a JOIN operation on the 'StuID' column, which is common to both tables.", "Construct the SQL query: We will select the 'StuID' from the 'Student' table where the conditions for sex and sport are met."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN SportsInfo ON Student.StuID = SportsInfo.StuID \nWHERE Student.Sex = 'Female' AND SportsInfo.SportName = 'Football';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6026", "db_id": "game_1", "question": "What are the ids of all female students who play football?", "rationale": ["Identify the relevant tables: We need to get information from the Student and SportsInfo tables.", "Determine the criteria: We are looking for female students who play football.", "Join the tables: We will join the Student table with the SportsInfo table on the StuID column to get the necessary information about students and their sports participation.", "Filter the results: We will filter the results to include only female students and those who play football."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT Student.StuID \nFROM Student \nJOIN SportsInfo ON Student.StuID = SportsInfo.StuID \nWHERE Student.Sex = 'Female' AND SportsInfo.SportName = 'Football';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6028", "db_id": "game_1", "question": "What are the ids of all male students who do not play football?", "rationale": ["Identify the target group: male students.", "Filter the Student table for male students by checking the 'Sex' column for 'Male'.", "To find students who do not play football, we need to exclude those who are in the SportsInfo table with 'SportName' as 'Football'.", "Use a subquery to select all StuID from SportsInfo where SportName is 'Football'.", "Combine the conditions using NOT IN to filter out those students from the main query."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male' AND StuID NOT IN (SELECT StuID FROM SportsInfo WHERE SportName = 'Football')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by students involved in a specific sport and who are on a sports scholarship. The placeholders in the WHERE clause represent the sport's name and the scholarship status.\",\n        \"virtual_table\": \"SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING] AND onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6060", "db_id": "customers_and_addresses", "question": "Find the average order quantity per order.", "rationale": ["Identify the relevant table: The 'Order_Items' table contains the 'order_quantity' which we need to average.", "We need to calculate the average order quantity per order, so we will use the AVG() function.", "To get the average per order, we will group the results by 'order_id' to ensure we are averaging the quantities for each specific order."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT AVG(order_quantity) AS average_order_quantity FROM Order_Items GROUP BY order_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6071", "db_id": "customers_and_addresses", "question": "What are the details of all products?", "rationale": ["The user wants to retrieve details of all products.", "To get all details from the 'Products' table, we can use a simple SELECT statement.", "The SQL query will be 'SELECT * FROM Products;' which selects all columns from the Products table."], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "pred_sql": "SELECT * FROM Products;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6075", "db_id": "customers_and_addresses", "question": "Find the detail of products whose detail contains the word \"Latte\" or the word \"Americano\"", "rationale": ["Identify the relevant table: The question asks for product details, so we will focus on the 'Products' table.", "Determine the filtering criteria: We need to find products whose details contain the words 'Latte' or 'Americano'.", "Construct the SQL query: Use the SELECT statement to retrieve 'product_id' and 'product_details' from the 'Products' table, and apply the WHERE clause to filter based on the specified keywords using the LIKE operator."], "gold_sql": "SELECT product_details FROM products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'", "source_tables": ["products"], "pred_sql": "SELECT product_id, product_details FROM Products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: We need to find the city with the most customers, so we will use the Customer_Addresses and Addresses tables.", "Join the tables: We will join Customer_Addresses with Addresses on the address_id to get the city associated with each customer.", "Count distinct customers: We will count the distinct customer_id for each city to avoid counting the same customer multiple times.", "Group by city: We will group the results by city to aggregate the customer counts for each city.", "Order the results: We will order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results: We will limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(DISTINCT customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6086", "db_id": "customers_and_addresses", "question": "Find the city where the most customers live.", "rationale": ["To find the city where the most customers live, we need to count the number of customers associated with each city.", "The relevant tables are Customer_Addresses (which links customers to addresses) and Addresses (which contains city information).", "We will perform a JOIN between Customer_Addresses and Addresses on the address_id to get the city for each customer.", "Next, we will use the COUNT function to count the number of customers for each city.", "We will group the results by city to aggregate the customer counts.", "To find the city with the most customers, we will order the results in descending order based on the customer count.", "Finally, we will limit the results to just one record to get the city with the highest count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6097", "db_id": "customers_and_addresses", "question": "Which contact channel has been used by the customer with name \"Tillman Ernser\"?", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "We need to find the contact channels associated with a specific customer, so we will join these two tables on the customer_id.", "We will filter the results based on the customer's name, which is 'Tillman Ernser'.", "We want distinct contact channels, so we will use the DISTINCT keyword in the SELECT statement."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT DISTINCT channel_code FROM Customers AS t1 JOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id WHERE t1.customer_name = 'Tillman Ernser'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\",\n        \"virtual_table\": \"SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "Join the Customers table with the Customer_Contact_Channels table on customer_id to access contact channel information for a specific customer.", "Filter the results to find the customer named 'Tillman Ernser'.", "Select the 'active_to_date' from the Customer_Contact_Channels table.", "Order the results by 'active_to_date' in descending order to get the latest date.", "Limit the results to 1 to retrieve only the latest contact channel's 'active_to_date'."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT t2.active_to_date FROM Customers AS t1 JOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id WHERE t1.customer_name = 'Tillman Ernser' ORDER BY t2.active_to_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\",\n        \"virtual_table\": \"SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["To find the average time span of contact channels, we need to calculate the duration for each contact channel.", "The duration can be calculated by subtracting the 'active_from_date' from the 'active_to_date'.", "In SQLite, we can use the 'julianday' function to convert date strings into Julian day numbers, which allows us to perform arithmetic on dates.", "We will then use the AVG function to calculate the average of these durations.", "The final SQL query will select the average duration from the 'Customer_Contact_Channels' table."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(julianday(active_to_date) - julianday(active_from_date)) AS average_time_span FROM Customer_Contact_Channels;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\",\n        \"virtual_table\": \"SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6103", "db_id": "customers_and_addresses", "question": "What is the channel code and contact number of the customer contact channel that was active for the longest time?", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the channel_code and contact_number.", "To find the channel that was active for the longest time, we need to calculate the duration of activity for each contact channel. This can be done by subtracting active_from_date from active_to_date.", "Use the ORDER BY clause to sort the results based on the duration of activity in descending order.", "Limit the results to 1 to get the channel with the longest active duration."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number FROM Customer_Contact_Channels ORDER BY (julianday(active_to_date) - julianday(active_from_date)) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of contact channels used by customers from the 'Customers' table based on their name. The placeholder in the WHERE clause represents the specific customer's name.\",\n        \"virtual_table\": \"SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6108", "db_id": "customers_and_addresses", "question": "Find the name of the customer who made the order of the largest amount of goods.", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Order_Items are needed to find the customer who made the largest order.", "Join the Customers table with Customer_Orders on customer_id to link customers to their orders.", "Join the resulting table with Order_Items on order_id to access the quantities of products ordered.", "Group the results by customer_id to aggregate the total quantity of goods ordered by each customer.", "Use SUM(oi.order_quantity) to calculate the total amount of goods ordered by each customer.", "Order the results in descending order to get the customer with the largest total quantity first.", "Limit the results to 1 to get only the top customer."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)", "source_tables": ["customer_orders", "customers", "order_items"], "pred_sql": "SELECT c.customer_name\nFROM Customers c\nJOIN Customer_Orders co ON c.customer_id = co.customer_id\nJOIN Order_Items oi ON co.order_id = oi.order_id\nGROUP BY c.customer_id\nORDER BY SUM(oi.order_quantity) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6123", "db_id": "customers_and_addresses", "question": "What is the total number of products that are in orders with status \"Cancelled\"?", "rationale": ["Identify the relevant tables: We need to look at the 'Customer_Orders' table to find orders with the status 'Cancelled' and the 'Order_Items' table to find the products associated with those orders.", "Join the 'Customer_Orders' table with the 'Order_Items' table on the 'order_id' to link orders to their respective products.", "Filter the results to include only those orders where the 'order_status' is 'Cancelled'.", "Count the distinct 'product_id' from the 'Order_Items' table to get the total number of unique products in cancelled orders."], "gold_sql": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  'Cancelled'", "source_tables": ["customer_orders", "order_items"], "pred_sql": "SELECT COUNT(DISTINCT oi.product_id) AS total_products\nFROM Customer_Orders co\nJOIN Order_Items oi ON co.order_id = oi.order_id\nWHERE co.order_status = 'Cancelled';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6130", "db_id": "customers_and_addresses", "question": "What is the most frequently ordered product? Tell me the detail of the product", "rationale": ["Identify the tables involved: Order_Items and Products.", "We need to join these tables on the product_id to get product details.", "We will group the results by product_id to count how many times each product has been ordered.", "We will order the results in descending order based on the count of orders to find the most frequently ordered product.", "Finally, we will limit the results to 1 to get only the most frequently ordered product."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT t2.product_details FROM Order_Items AS t1 JOIN Products AS t2 ON t1.product_id = t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["Identify the tables involved: We need to retrieve product information, so we will use the 'Products' table and the 'Order_Items' table to get the order quantities.", "Join the tables: We will join 'Order_Items' with 'Products' on the product_id to access product details along with their order quantities.", "Group by product: We need to group the results by product_id to aggregate the order quantities for each product.", "Order by total quantity: We will order the results by the total order quantity in descending order to find the product with the largest total order quantity.", "Limit the results: Since we only want the product with the largest total order quantity, we will limit the results to 1."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT t2.product_id, t2.product_details FROM Order_Items AS t1 JOIN Products AS t2 ON t1.product_id = t2.product_id GROUP BY t1.product_id ORDER BY SUM(t1.order_quantity) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6132", "db_id": "customers_and_addresses", "question": "What are the name and ID of the product bought the most.", "rationale": ["Identify the tables involved: We need to look at the 'Order_Items' table to find out how many times each product was ordered and the 'Products' table to get the product details.", "Join the 'Order_Items' table with the 'Products' table on the product_id to access product details along with the order information.", "Group the results by product_id to aggregate the order counts for each product.", "Order the results by the count of orders in descending order to find the most bought product.", "Limit the results to 1 to get only the top product that was bought the most."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT t2.product_id, t2.product_details FROM Order_Items AS t1 JOIN Products AS t2 ON t1.product_id = t2.product_id GROUP BY t1.product_id ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of product details from the 'Products' table based on the quantity of each product ordered. The query joins the 'Order_Items' table with the 'Products' table to retrieve the product specifications, grouping the results by product ID and ordering them by the count of orders in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of product details to return.\",\n        \"virtual_table\": \"SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The question asks for addresses, so we will use the 'Addresses' table.", "Determine the filtering criteria: We need to find addresses in two specific cities (East Julianaside and Gleasonmouth) and their corresponding states (Texas and Arizona).", "Construct the WHERE clause: We will use the OR operator to combine the conditions for the two cities and their states.", "Formulate the SQL query: We will select all columns from the 'Addresses' table where the specified conditions are met."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT * FROM Addresses WHERE (city = 'East Julianaside' AND state_province_county = 'Texas') OR (city = 'Gleasonmouth' AND state_province_county = 'Arizona');", "hint": "\n"}
{"sample_id": "train.6155", "db_id": "music_4", "question": "What are the category of music festivals with result \"Awarded\"?", "rationale": ["Identify the relevant table: The question pertains to music festivals and their results, so we will focus on the 'music_festival' table.", "Determine the required column: We need the 'Category' of the music festivals, which is a column in the 'music_festival' table.", "Apply the condition: The question specifies that we are only interested in festivals with the result 'Awarded'. This will be included in the WHERE clause of the SQL query.", "Construct the SQL query: Combine the selected column and the condition to form the complete SQL query."], "gold_sql": "SELECT Category FROM music_festival WHERE RESULT  =  'Awarded'", "source_tables": ["music_festival"], "pred_sql": "SELECT Category FROM music_festival WHERE Result = 'Awarded'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the categories of awards or recognitions from the 'music_festival' table based on a specific result. The placeholder in the WHERE clause represents the outcome of the festival participation.\",\n        \"virtual_table\": \"SELECT Category FROM music_festival WHERE RESULT  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6167", "db_id": "music_4", "question": "Please show the songs that have result \"nominated\" at music festivals.", "rationale": ["Identify the relevant tables: music_festival, volume, and artist.", "We need to find songs that have the result 'nominated' in the music_festival table.", "Join the music_festival table with the volume table on the Volume column to link festival results to specific songs.", "Join the volume table with the artist table on the Artist_ID to get artist details for each song.", "Select the Song identifier from the volume table, and the Artist name and Famous_Title from the artist table where the result is 'nominated'."], "gold_sql": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  'Nominated'", "source_tables": ["music_festival", "volume"], "pred_sql": "SELECT volume.Song, artist.Artist, artist.Famous_Title \nFROM music_festival \nJOIN volume ON music_festival.Volume = volume.Volume_ID \nJOIN artist ON volume.Artist_ID = artist.Artist_ID \nWHERE music_festival.Result = 'nominated';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the categories of awards or recognitions from the 'music_festival' table based on a specific result. The placeholder in the WHERE clause represents the outcome of the festival participation.\",\n        \"virtual_table\": \"SELECT Category FROM music_festival WHERE RESULT  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6180", "db_id": "music_4", "question": "Return the famous release date for the oldest artist.", "rationale": ["Identify the table that contains the release dates of the artists' famous songs, which is the 'artist' table.", "To find the oldest artist, we need to sort the artists by their age in ascending order.", "We will select the 'Famous_Release_date' of the artist who is the oldest.", "Using 'ORDER BY Age ASC' will sort the artists from the youngest to the oldest, and 'LIMIT 1' will give us the oldest artist's famous release date."], "gold_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1", "source_tables": ["artist"], "pred_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\",\n        \"virtual_table\": \"SELECT T1.Date_of_ceremony FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6185", "db_id": "music_4", "question": "Please show the categories of the music festivals with count more than 1.", "rationale": ["Identify the relevant table: The question pertains to the 'music_festival' table, specifically the 'Category' column.", "We need to count the occurrences of each category, which requires a GROUP BY clause on the 'Category' column.", "To filter categories that appear more than once, we will use the HAVING clause with COUNT(*) > 1.", "The final SQL query will select the 'Category' from the 'music_festival' table, group the results by 'Category', and apply the HAVING condition."], "gold_sql": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*)  >  1", "source_tables": ["music_festival"], "pred_sql": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the categories of awards or recognitions from the 'music_festival' table based on a specific result. The placeholder in the WHERE clause represents the outcome of the festival participation.\",\n        \"virtual_table\": \"SELECT Category FROM music_festival WHERE RESULT  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6187", "db_id": "music_4", "question": "What is the song in the volume with the maximum weeks on top?", "rationale": ["Identify the table that contains the song information, which is the 'volume' table.", "Determine that we need to find the song associated with the maximum number of weeks on top.", "Use a subquery to find the maximum value of 'Weeks_on_Top' in the 'volume' table.", "Select the 'Song' from the 'volume' table where 'Weeks_on_Top' matches the maximum value found in the subquery."], "gold_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT Song FROM volume WHERE Weeks_on_Top = (SELECT MAX(Weeks_on_Top) FROM volume)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\",\n        \"virtual_table\": \"SELECT T1.Date_of_ceremony FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6195", "db_id": "music_4", "question": "What is the issue date of the volume with the minimum weeks on top?", "rationale": ["Identify the table that contains the issue date and weeks on top, which is the 'volume' table.", "To find the issue date of the volume with the minimum weeks on top, we need to first determine the minimum value of 'Weeks_on_Top' in the 'volume' table.", "We can use a subquery to find the minimum weeks on top: (SELECT MIN(Weeks_on_Top) FROM volume).", "Once we have the minimum weeks on top, we can select the 'Issue_Date' from the 'volume' table where 'Weeks_on_Top' equals this minimum value."], "gold_sql": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT Issue_Date FROM volume WHERE Weeks_on_Top = (SELECT MIN(Weeks_on_Top) FROM volume)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates of ceremonies from the 'music_festival' table for volumes that have songs which stayed at the top for a specified number of weeks. The placeholder in the WHERE clause represents the minimum number of weeks a song must have been at the top.\",\n        \"virtual_table\": \"SELECT T1.Date_of_ceremony FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the relevant tables: We need to find the match ID related to a specific competition.", "The 'match' table contains the match IDs and competition identifiers.", "The 'hosting_city' table links matches to the cities hosting them.", "We need to filter the results based on the competition name '1994 FIFA World Cup qualification'.", "To do this, we will join the 'match' and 'hosting_city' tables on Match_ID and filter by the competition name."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT match.Match_ID FROM match JOIN hosting_city ON match.Match_ID = hosting_city.Match_ID WHERE hosting_city.Host_City = (SELECT City_ID FROM city WHERE City = '1994 FIFA World Cup qualification')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the venue information for matches hosted in a specific city during a particular competition. The placeholders in the WHERE clause represent the city name and the competition identifier.\",\n        \"virtual_table\": \"SELECT T3.venue FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id = T2.host_city JOIN MATCH AS T3 ON T2.match_id = T3.match_id WHERE T1.city = [PLACEHOLDER-TYPE:STRING] AND T3.competition = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6274", "db_id": "city_record", "question": "Which city has hosted the most events?", "rationale": ["Identify the relevant tables: 'city' and 'hosting_city' are needed to find which cities have hosted matches.", "Join the 'city' table with the 'hosting_city' table on the City_ID and Host_City columns to link cities with their hosted matches.", "Group the results by Host_City to count the number of matches hosted by each city.", "Order the results in descending order based on the count of matches to find the city with the most events.", "Limit the results to 1 to get only the city that has hosted the most events."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN hosting_city AS T2 ON T1.City_ID = T2.Host_City GROUP BY T2.Host_City ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables: We need data from the 'city' table for city names and the 'temperature' table for February temperatures.", "Join the 'city' table with the 'temperature' table on the City_ID to combine city names with their corresponding February temperatures.", "Order the results by the February temperature in descending order to get the highest temperature at the top.", "Limit the results to 1 to retrieve only the city with the highest temperature in February."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT city.City, temperature.Feb AS Highest_Temperature\nFROM city\nJOIN temperature ON city.City_ID = temperature.City_ID\nORDER BY temperature.Feb DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6287", "db_id": "city_record", "question": "In February, which city marks the highest temperature?", "rationale": ["Identify the relevant tables: 'city' for city names and 'temperature' for temperature data.", "We need to find the city with the highest temperature in February, so we will focus on the 'Feb' column in the 'temperature' table.", "Join the 'city' table with the 'temperature' table on 'City_ID' to get city names along with their February temperatures.", "Order the results by the February temperature in descending order to get the highest temperature at the top.", "Limit the results to 1 to get only the city with the highest temperature."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT city.City, temperature.Feb AS Highest_Temperature\nFROM city\nJOIN temperature ON city.City_ID = temperature.City_ID\nORDER BY temperature.Feb DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: 'city' for city names and 'temperature' for temperature data.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Use a WHERE clause to filter cities based on the condition that the temperature in March is lower than in July or higher than in October.", "Select the 'City' column from the resulting joined table to get the list of cities that meet the criteria."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City \nFROM city AS c \nJOIN temperature AS t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6289", "db_id": "city_record", "question": "Which cities' temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access city names along with their temperature data.", "Use a WHERE clause to filter cities based on the condition that the temperature in March is lower than in July or higher than in October."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT c.City \nFROM city AS c \nJOIN temperature AS t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Jul OR t.Mar > t.Oct;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6292", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in Dec and which have never been host cities.", "rationale": ["Identify the relevant tables: city, temperature, and hosting_city.", "We need to find cities where the temperature in March (Mar) is lower than in December (Dec). This requires joining the city table with the temperature table.", "We also need to ensure that these cities have never hosted a match. This can be checked by performing a LEFT JOIN with the hosting_city table and ensuring that the Host_City is NULL.", "The final query will select the City names from the city table where the temperature condition is met and there are no corresponding entries in the hosting_city table."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city c \nLEFT JOIN hosting_city h ON c.City_ID = h.Host_City \nJOIN temperature t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND h.Host_City IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the relevant tables: 'city', 'temperature', and 'hosting_city'.", "We need to compare the average temperatures in March and December, so we will join the 'city' table with the 'temperature' table on 'City_ID'.", "The condition for lower temperature in March than in December is specified in the WHERE clause: 't.Mar < t.Dec'.", "To find cities that have never served as host cities, we will use a subquery that selects all 'Host_City' from the 'hosting_city' table and ensure that the 'City_ID' is not in that list using 'NOT IN'.", "Finally, we select the 'City' name from the 'city' table that meets both conditions."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT c.City \nFROM city AS c \nJOIN temperature AS t ON c.City_ID = t.City_ID \nWHERE t.Mar < t.Dec \nAND c.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6298", "db_id": "city_record", "question": "Please give me a list of cities whose regional population is over 8000000 or under 5000000.", "rationale": ["Identify the relevant table: The 'city' table contains the 'Regional_Population' column.", "Determine the conditions for filtering: We need cities with a population greater than 8,000,000 or less than 5,000,000.", "Construct the SQL query: Use a SELECT statement to retrieve the 'City' column from the 'city' table where the 'Regional_Population' meets the specified conditions."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "pred_sql": "SELECT City FROM city WHERE Regional_Population > 8000000 OR Regional_Population < 5000000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the cities that have hosted the most matches, derived from the 'city' and 'hosting_city' tables. The placeholder in the LIMIT clause allows the user to specify the number of top cities to retrieve.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6313", "db_id": "e_government", "question": "What is the name of the party form that is most common?", "rationale": ["Identify the relevant tables: Party_Forms and Forms are needed to get the form names associated with each party.", "Join the Party_Forms table with the Forms table on the form_id to access the form names.", "Group the results by form_name to count how many times each form appears in the Party_Forms table.", "Use COUNT(*) to count the occurrences of each form name.", "Order the results in descending order based on the count to find the most common form.", "Limit the results to 1 to get only the most common party form."], "gold_sql": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["forms", "party_forms"], "pred_sql": "SELECT form_name, COUNT(*) as form_count\nFROM Party_Forms\nJOIN Forms ON Party_Forms.form_id = Forms.form_id\nGROUP BY form_name\nORDER BY form_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6329", "db_id": "e_government", "question": "What are the names of the services that have never been used?", "rationale": ["Identify the table that contains the service names, which is the Services table.", "Determine the relationship between services and their usage, which is found in the Party_Services table.", "To find services that have never been used, we need to select service names from the Services table where the service_id does not exist in the Party_Services table.", "Construct the SQL query using a subquery to filter out the used services from the Services table."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name FROM Services WHERE service_id NOT IN (SELECT service_id FROM Party_Services);", "hint": "\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The question asks for cities and states, which are found in the Addresses table.", "Select the appropriate columns: We need to select 'town_city' for cities and 'state_province_county' for states.", "Use DISTINCT to avoid duplicate entries: Since we want the names of all cities and states, using DISTINCT will ensure that we only get unique combinations.", "Construct the SQL query: Combine the selected columns and the table name into a SQL SELECT statement."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT town_city, state_province_county FROM Addresses;", "hint": "\n"}
{"sample_id": "train.6342", "db_id": "e_government", "question": "Which state can address \"6862 Kaitlyn Knolls\" possibly be in?", "rationale": ["Identify the relevant table: The question pertains to addresses, so we will use the 'Addresses' table.", "Determine the relevant column: We need to find the state, which is stored in the 'state_province_county' column.", "Filter the results: We will filter the addresses to find the one that matches '6862 Kaitlyn Knolls' in the 'line_1_number_building' column.", "Select distinct states: Since we want to know which state this address could possibly be in, we will use DISTINCT to avoid duplicates."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT state_province_county FROM Addresses WHERE line_1_number_building = '6862 Kaitlyn Knolls';", "hint": "\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the tables involved: Organizations, Organization_Contact_Individuals, and Individuals.", "Determine the relationship between these tables: Organizations are linked to Organization_Contact_Individuals through organization_id, and Organization_Contact_Individuals are linked to Individuals through individual_id.", "Select the last name of individuals from the Individuals table, which is represented by the column individual_last_name.", "Join the Organizations table with Organization_Contact_Individuals and then with Individuals to get the required last names.", "The query should return the last names of individuals who have been contact individuals for any organization."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id = t2.organization_id JOIN individuals AS t3 ON t2.individual_id = t3.individual_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the last names of individuals who have contacted a specific organization. The organization is identified by its name, and the results are ordered by the end date of the contact period, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the organization name and the number of results to display.\",\n        \"virtual_table\": \"SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.organization_name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY t2.date_contact_to DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6371", "db_id": "flight_company", "question": "What are the names and types of the companies that have ever operated a flight?", "rationale": ["Identify the relevant tables: We need information from the 'operate_company' table for company names and types, and the 'flight' table to find out which companies have operated flights.", "Determine the relationship: The 'flight' table has a foreign key 'company_id' that links to the 'id' in the 'operate_company' table, allowing us to join these two tables.", "Select the required columns: We need to select the 'name' and 'Type' columns from the 'operate_company' table.", "Use DISTINCT to avoid duplicate entries: Since a company may operate multiple flights, we use DISTINCT to ensure each company is listed only once."], "gold_sql": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id", "source_tables": ["flight", "operate_company"], "pred_sql": "SELECT DISTINCT operate_company.name, operate_company.Type \nFROM operate_company \nJOIN flight ON operate_company.id = flight.company_id;", "hint": "\n"}
{"sample_id": "train.6375", "db_id": "flight_company", "question": "What is the id, name and IATA code of the airport that had most number of flights?", "rationale": ["Identify the relevant tables: 'airport' and 'flight'.", "We need to find the airport with the most flights, so we will join the 'airport' table with the 'flight' table using the foreign key relationship (airport.id = flight.airport_id).", "Select the required fields: airport.id, airport.name, and airport.IATA.", "Group the results by airport.id, airport.name, and airport.IATA to aggregate the flight counts for each airport.", "Count the number of flights for each airport using COUNT(flight.id).", "Order the results in descending order based on the flight count to get the airport with the most flights at the top.", "Limit the results to 1 to get only the airport with the highest number of flights."], "gold_sql": "SELECT T1.id ,  T1.name ,  T1.IATA FROM airport AS T1 JOIN flight AS T2 ON T1.id  =  T2.airport_id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airport", "flight"], "pred_sql": "SELECT airport.id, airport.name, airport.IATA\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nGROUP BY airport.id, airport.name, airport.IATA\nORDER BY COUNT(flight.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6381", "db_id": "flight_company", "question": "How many companies operates airlines in each airport?", "rationale": ["Identify the relevant tables: airport, operate_company, and flight.", "We need to count the number of companies that operate airlines at each airport.", "Join the airport table with the flight table on airport.id and flight.airport_id.", "Join the flight table with the operate_company table on flight.company_id and operate_company.id.", "Filter the results to include only those companies that are of type 'airline'.", "Group the results by the airport name to get the count of airlines per airport."], "gold_sql": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id", "source_tables": ["airport", "flight", "operate_company"], "pred_sql": "SELECT airport.name AS Airport_Name, COUNT(operate_company.id) AS Number_of_Airlines\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nJOIN operate_company ON flight.company_id = operate_company.id\nWHERE operate_company.Type = 'airline'\nGROUP BY airport.name;", "hint": "\n"}
{"sample_id": "train.6517", "db_id": "wine_1", "question": "What is the name of the highest rated wine?", "rationale": ["Identify the relevant table: The question asks for information about wine, so we will focus on the 'wine' table.", "Determine the required columns: We need the 'Name' of the wine and its 'Score' to find the highest rated wine.", "Sort the results: To find the highest rated wine, we will sort the results by 'Score' in descending order.", "Limit the results: Since we only want the highest rated wine, we will limit the results to 1."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n        \"virtual_table\": \"SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6518", "db_id": "wine_1", "question": "Give the name of the wine with the highest score.", "rationale": ["Identify the table that contains the wine names and their scores, which is the 'wine' table.", "To find the wine with the highest score, we need to sort the wines by the 'Score' column in descending order.", "Using 'ORDER BY Score DESC' will arrange the wines from highest to lowest score.", "To get only the top wine, we will use 'LIMIT 1' to restrict the result to just one entry.", "The final SQL query will select the 'Name' of the wine from the 'wine' table, ordered by 'Score' in descending order, and limited to one result."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n        \"virtual_table\": \"SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6520", "db_id": "wine_1", "question": "What is the winery at which the wine with the highest score was made?", "rationale": ["Identify the table that contains the wine information, which is the 'wine' table.", "Determine that we need to find the winery associated with the highest score of wine.", "Use a subquery to find the maximum score from the 'Score' column in the 'wine' table.", "Select the 'Winery' from the 'wine' table where the 'Score' matches the maximum score found in the subquery."], "gold_sql": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Winery FROM wine WHERE Score = (SELECT MAX(Score) FROM wine)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n        \"virtual_table\": \"SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6533", "db_id": "wine_1", "question": "List the names of all distinct wines that are made of red color grape.", "rationale": ["Identify the tables involved: 'grapes' and 'wine'.", "Determine the relationship between the tables: 'grapes.Grape' is linked to 'wine.Grape'.", "Focus on the requirement: list distinct wine names made from red color grapes.", "Use the provided hint to structure the SQL query, replacing the placeholder with 'red'.", "Construct the final SQL query to select distinct names from the wine table where the grape color is red."], "gold_sql": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT T2.Name FROM grapes AS T1 JOIN wine AS T2 ON T1.Grape = T2.Grape WHERE T1.Color = 'red'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6544", "db_id": "wine_1", "question": "Give the names and scores of wines made from white grapes.", "rationale": ["Identify the tables involved: 'grapes' and 'wine'.", "Determine the relationship between the tables: 'grapes.Grape' is linked to 'wine.Grape'.", "Filter the results based on the color of the grapes, which is specified as 'white'.", "Select the desired columns: 'Name' and 'Score' from the 'wine' table.", "Construct the SQL query using a JOIN to combine the two tables and apply the WHERE clause for filtering."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT T2.Name, T2.Score FROM grapes AS T1 JOIN wine AS T2 ON T1.Grape = T2.Grape WHERE T1.Color = 'white'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6547", "db_id": "wine_1", "question": "Find the the grape whose white color grapes are used to produce wines with scores higher than 90.", "rationale": ["Identify the requirement to find grape varieties that are white in color and are used in wines with scores higher than 90.", "Use the provided hint to create a virtual table that selects grape varieties from the 'wine' table where the score is greater than 90.", "Join this virtual table with the 'grapes' table to filter for only those grapes that are white in color.", "Construct the final SQL query to select the grape names from the 'grapes' table that meet the criteria."], "gold_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White' AND T2.score  >  90", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT T1.Grape FROM grapes AS T1 JOIN (SELECT T2.Grape FROM wine AS T2 WHERE T2.Score > 90) AS T3 ON T1.Grape = T3.Grape WHERE T1.Color = 'white';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and scores of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6550", "db_id": "wine_1", "question": "What are the names of wines made from red grapes and with prices above 50?", "rationale": ["Identify the tables involved: 'grapes' for grape varieties and 'wine' for wine details.", "Determine the relationship between the tables: 'grapes.Grape' is linked to 'wine.Grape'.", "Specify the conditions: we need wines made from red grapes, so we filter by 'grapes.Color = 'red'',' and we want wines with prices above 50, so we add 'wine.Price > 50'.", "Construct the SQL query using a JOIN to combine the two tables based on the grape variety, and apply the specified conditions in the WHERE clause."], "gold_sql": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red' AND T2.price  >  50", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT T2.Name FROM grapes AS T1 JOIN wine AS T2 ON T1.Grape = T2.Grape WHERE T1.Color = 'red' AND T2.Price > 50", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n        \"virtual_table\": \"SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6558", "db_id": "wine_1", "question": "What are the distinct names of wines with prices higher than any wine from John Anthony winery.", "rationale": ["Identify the requirement to find distinct names of wines.", "Determine that we need to filter wines based on their price being higher than a certain threshold.", "The threshold is the maximum price of wines produced by 'John Anthony' winery.", "Use a subquery to find the maximum price of wines from 'John Anthony'.", "Select distinct names from the wine table where the price is greater than the result of the subquery."], "gold_sql": "SELECT DISTINCT Name FROM WINE WHERE Price  >  (SELECT min(Price) FROM wine WHERE Winery  =  'John Anthony')", "source_tables": ["wine"], "pred_sql": "SELECT DISTINCT Name FROM wine WHERE Price > (SELECT MAX(Price) FROM wine WHERE Winery = 'John Anthony')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n        \"virtual_table\": \"SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6566", "db_id": "wine_1", "question": "Give the color of the grape whose wine products have the highest average price?", "rationale": ["Identify the relevant tables: 'grapes' for grape color and 'wine' for wine prices.", "Join the 'grapes' table with the 'wine' table on the 'Grape' column to associate each wine with its grape variety.", "Group the results by grape color to calculate the average price of wines for each color.", "Use the AVG() function to compute the average price of wines for each grape color.", "Order the results in descending order based on the average price to find the highest average price.", "Limit the results to 1 to get the color of the grape with the highest average price."], "gold_sql": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT 1", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT g.Color FROM grapes g JOIN wine w ON g.Grape = w.Grape GROUP BY g.Color ORDER BY AVG(w.Price) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of wines made from grape varieties of a specific color and priced above a certain amount. The placeholders in the WHERE clause represent the grape color and the price threshold.\",\n        \"virtual_table\": \"SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6588", "db_id": "wine_1", "question": "Which 3 wineries produce the most wines made from white grapes?", "rationale": ["Identify the relevant tables: 'wine' and 'grapes'.", "We need to filter wines made from white grapes, so we will join the 'wine' table with the 'grapes' table on the grape variety.", "Use the WHERE clause to filter for grapes that are white.", "Group the results by winery to count the number of wines produced by each winery.", "Order the results in descending order based on the count of wines to find the top producers.", "Limit the results to the top 3 wineries."], "gold_sql": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  'White' GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT Winery, COUNT(*) AS WineCount \nFROM wine \nJOIN grapes ON wine.Grape = grapes.Grape \nWHERE grapes.Color = 'white' \nGROUP BY Winery \nORDER BY WineCount DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filtering the results to include only those grapes that match the specified color.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6597", "db_id": "wine_1", "question": "Find the county where produces the most number of wines with score higher than 90.", "rationale": ["Identify the tables needed: 'appellations' for county information and 'wine' for wine details.", "Join the 'appellations' table with the 'wine' table on the 'Appelation' column to link wines to their respective counties.", "Filter the results to include only wines with a score greater than 90.", "Group the results by county to count the number of wines per county.", "Order the results in descending order based on the count of wines to find the county with the most wines.", "Limit the results to 1 to get only the county with the highest count."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1", "source_tables": ["wine", "appellations"], "pred_sql": "SELECT a.County, COUNT(w.No) AS wine_count \nFROM appellations a \nJOIN wine w ON a.Appelation = w.Appelation \nWHERE w.Score > 90 \nGROUP BY a.County \nORDER BY wine_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of wines produced in a specific county, filtered by a price threshold. The placeholders in the WHERE clause represent the county name and the maximum price of the wine.\",\n        \"virtual_table\": \"SELECT T2.Name FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  [PLACEHOLDER-TYPE:STRING] AND T2.price  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6626", "db_id": "driving_school", "question": "Show the detail of vehicle with id 1.", "rationale": ["Identify the table that contains vehicle details, which is the Vehicles table.", "Determine the specific vehicle we want to retrieve details for, which is identified by vehicle_id '1'.", "Construct a SQL SELECT statement to retrieve all columns from the Vehicles table where the vehicle_id matches '1'."], "gold_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;", "source_tables": ["vehicles"], "pred_sql": "SELECT * FROM Vehicles WHERE vehicle_id = '1';", "hint": "\n"}
{"sample_id": "train.6650", "db_id": "driving_school", "question": "How many staff live in state Georgia?", "rationale": ["Identify the relevant tables: Staff and Addresses.", "Determine the relationship between Staff and Addresses using the foreign key (staff_address_id).", "Count the number of staff members who live in Georgia by filtering the Addresses table on the state_province_county column.", "Construct the SQL query using COUNT(*) to get the total number of staff in Georgia."], "gold_sql": "SELECT count(*) FROM Addresses WHERE state_province_county = 'Georgia';", "source_tables": ["addresses"], "pred_sql": "SELECT COUNT(*) AS staff_count \nFROM Staff \nJOIN Addresses ON Staff.staff_address_id = Addresses.address_id \nWHERE Addresses.state_province_county = 'Georgia';", "hint": "\n"}
{"sample_id": "train.6665", "db_id": "driving_school", "question": "What is the status code, phone number, and email address of the customer whose last name is Kohler or whose first name is Marina?", "rationale": ["Identify the relevant table: The question pertains to customer information, so we will use the Customers table.", "Determine the required columns: The question asks for the status code, phone number, and email address of the customer.", "Construct the SELECT statement: We will select customer_status_code, phone_number, and email_address from the Customers table.", "Add the WHERE clause: We need to filter the results to include customers whose last name is 'Kohler' or whose first name is 'Marina'.", "Combine all parts to form the complete SQL query."], "gold_sql": "SELECT customer_status_code ,  cell_mobile_phone_number ,  email_address FROM Customers WHERE first_name = 'Marina' OR last_name  =  'Kohler'", "source_tables": ["customers"], "pred_sql": "SELECT customer_status_code, phone_number, email_address \nFROM Customers \nWHERE last_name = 'Kohler' OR first_name = 'Marina';", "hint": "\n"}
{"sample_id": "train.6676", "db_id": "driving_school", "question": "How many lessons taken by customer with first name as Rylan and last name as Goodwin were completed?", "rationale": ["Identify the relevant tables: Lessons and Customers.", "We need to count the number of lessons, so we will use the COUNT() function.", "We need to filter the lessons based on the customer's first and last name, which requires a JOIN between the Lessons and Customers tables.", "The WHERE clause will specify the conditions for the customer's first name and last name.", "Additionally, we need to filter for completed lessons, which will be done by checking the lesson_status_code in the Lessons table."], "gold_sql": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = 'Rylan' AND T2.last_name = 'Goodwin' AND T1.lesson_status_code = 'Completed';", "source_tables": ["lessons", "customers"], "pred_sql": "SELECT COUNT(*) AS completed_lessons_count\nFROM Lessons\nJOIN Customers ON Lessons.customer_id = Customers.customer_id\nWHERE Customers.first_name = 'Rylan' AND Customers.last_name = 'Goodwin' AND Lessons.lesson_status_code = 'completed';", "hint": "\n"}
{"sample_id": "train.6688", "db_id": "driving_school", "question": "Which city does has most number of customers?", "rationale": ["Identify the tables involved: Customers and Addresses.", "Determine the relationship between Customers and Addresses using the foreign key customer_address_id.", "Join the Customers table with the Addresses table on the customer_address_id and address_id columns.", "Group the results by city to count the number of customers in each city.", "Order the results in descending order based on the count of customers to find the city with the most customers.", "Limit the results to 1 to get only the city with the highest number of customers."], "gold_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "customers"], "pred_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities where customers are located, derived from the 'Customers' and 'Addresses' tables. The results are grouped by city and ordered by the number of customers in each city, with a limit on the number of cities returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.6711", "db_id": "driving_school", "question": "What are the last names that are used by customers and staff?", "rationale": ["Identify the tables that contain last names: Customers and Staff.", "Use the SELECT statement to retrieve last names from both tables.", "Use DISTINCT to ensure unique last names are returned from each table.", "Combine the results from both tables using UNION to get a single list of last names."], "gold_sql": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT DISTINCT last_name FROM Customers UNION SELECT DISTINCT last_name FROM Staff;", "hint": "\n"}
{"sample_id": "train.6714", "db_id": "driving_school", "question": "What is the id and detail of the vehicle used in lessons for most of the times?", "rationale": ["Identify the relevant tables: The question pertains to vehicles used in lessons, so we need to focus on the 'Lessons' and 'Vehicles' tables.", "Determine the required fields: We need the 'vehicle_id' and 'vehicle_details' from the 'Vehicles' table.", "Count the number of times each vehicle is used in lessons: This can be done by grouping the 'Lessons' table by 'vehicle_id' and counting the occurrences.", "Sort the results: To find the vehicle used the most, we will order the results by the count in descending order.", "Limit the results: Since we only want the vehicle used the most, we will limit the results to 1."], "gold_sql": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["lessons", "vehicles"], "pred_sql": "SELECT vehicle_id, vehicle_details\nFROM Lessons\nGROUP BY vehicle_id\nORDER BY COUNT(*) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the table that contains faculty information, which is the Faculty table.", "Determine the relevant column for gender, which is 'Sex'.", "Filter the results to only include male faculty members by using the condition 'Sex = 'Male''.", "Select the unique identifier for faculty members, which is 'FacID', to show their ids."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'Male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6734", "db_id": "activity_1", "question": "What are the first name and last name of all the instructors?", "rationale": ["Identify the relevant table: The question asks for the first and last names of instructors, which corresponds to the 'Faculty' table.", "Select the appropriate columns: We need to retrieve the 'Fname' and 'Lname' columns from the 'Faculty' table.", "Construct the SQL query: Since there are no specific conditions or filters mentioned in the question, we can directly select the names from the Faculty table without any WHERE clause."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "pred_sql": "SELECT Fname, Lname FROM Faculty", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6737", "db_id": "activity_1", "question": "Which building has most faculty members?", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their building locations.", "Count the number of faculty members in each building: Use COUNT(*) to count the number of faculty members grouped by the building they are in.", "Group the results by building: Use GROUP BY Building to aggregate the counts for each building.", "Order the results by the count of faculty members in descending order: Use ORDER BY COUNT(*) DESC to sort the buildings by the number of faculty members.", "Limit the results to the top building: Use LIMIT 1 to return only the building with the most faculty members."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(*) as FacultyCount FROM Faculty GROUP BY Building ORDER BY FacultyCount DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members have their offices, grouped by building name. The results are ordered by the number of faculty members in each building in descending order, and the placeholder allows the user to specify the maximum number of buildings to return.\",\n        \"virtual_table\": \"SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their rank and gender.", "Filter for assistant professors: We need to focus on faculty members with the rank of 'Assistant Professor'.", "Group by gender: To get the count of male and female assistant professors, we will group the results by the 'Sex' column.", "Count the number of professors: We will use the COUNT function to count the number of faculty members in each gender group."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) AS NumberOfProfessors \nFROM Faculty \nWHERE Rank = 'Assistant Professor' \nGROUP BY Sex;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n        \"virtual_table\": \"SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank\"\n    }\n}\n"}
{"sample_id": "train.6748", "db_id": "activity_1", "question": "How many male and female assistant professors do we have?", "rationale": ["Identify the relevant table: We need to focus on the Faculty table since we are interested in faculty members and their ranks.", "Filter for assistant professors: We will filter the Faculty table to include only those faculty members whose Rank is 'Assistant Professor'.", "Group by gender: We need to count the number of assistant professors by their gender, which is represented by the 'Sex' column in the Faculty table.", "Count the number of assistant professors: We will use the COUNT function to get the number of assistant professors for each gender.", "Construct the SQL query: Combine all the above steps into a single SQL query that selects the gender and the count of assistant professors, grouping the results by gender."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) AS count FROM Faculty WHERE Rank = 'Assistant Professor' GROUP BY Sex;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n        \"virtual_table\": \"SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank\"\n    }\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the tables involved: We need to find the advisor of a student named Linda Smith, which involves the Student and Faculty tables.", "Determine the necessary columns: We need the first name and last name of the advisor, so we will select Fname and LName from the Student table.", "Establish the relationship: The Student table has an Advisor column that links to the Faculty table's FacID.", "Construct the subquery: We need to find the FacID of Linda Smith from the Faculty table using a subquery.", "Combine the queries: Use the result of the subquery to filter the Student table for the advisor's details."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT S.Fname, S.LName \nFROM Student S \nWHERE S.Advisor = (SELECT F.FacID \n                   FROM Faculty F \n                   WHERE F.Fname = 'Linda' AND F.Lname = 'Smith');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of faculty members from the 'Faculty' table who hold a specific academic rank. The placeholder in the WHERE clause represents the rank of the faculty member.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Faculty WHERE Rank  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["The query needs to find students whose advisors are professors, which means we need to join the Student table with the Faculty table based on the advisor relationship.", "The hint provides a virtual table that counts the number of students assigned to each faculty member as their advisor. We can use this to ensure that we are only considering faculty members who are advisors.", "We will select the student IDs (StuID) from the Student table where the advisor matches the faculty member's ID from the virtual table.", "The virtual table is created by joining the Faculty table with the Student table on the advisor relationship and grouping by the faculty ID to count the students.", "Finally, we will join this virtual table back to the Student table to get the IDs of the students whose advisors are professors."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT T2.StuID FROM Student AS T2 JOIN (SELECT T1.FacID, count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID = T2.Advisor GROUP BY T1.FacID) AS AdvisorCount ON T2.Advisor = AdvisorCount.FacID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    }\n}\n"}
{"sample_id": "train.6752", "db_id": "activity_1", "question": "Which students have professors as their advisors? Find their student ids.", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table to find student IDs and the 'Faculty' table to find faculty members who are advisors.", "Determine the relationship: The 'Student' table has a column 'Advisor' that references 'FacID' in the 'Faculty' table, indicating which faculty member is the advisor for each student.", "Construct the subquery: We can create a subquery that selects all 'FacID' from the 'Faculty' table, which represents all faculty members.", "Use the subquery in the main query: We will select 'StuID' from the 'Student' table where the 'Advisor' matches any 'FacID' from the subquery. This will give us the IDs of students who have professors as their advisors."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT T2.StuID FROM Student AS T2 WHERE T2.Advisor IN (SELECT T1.FacID FROM Faculty AS T1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    }\n}\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the requirement: We need to find the first name and last name of students advised by Michael Goodrich.", "To find the students advised by Michael Goodrich, we first need to identify his unique identifier (Advisor) from the Faculty table.", "We will use a subquery to select the StuID of Michael Goodrich from the Faculty table where the first name is 'Michael' and the last name is 'Goodrich'.", "Once we have the Advisor's ID, we can select the first name and last name of students from the Student table where the Advisor matches the ID we found in the subquery."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE Advisor = (SELECT StuID FROM Faculty WHERE Fname = 'Michael' AND Lname = 'Goodrich')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6756", "db_id": "activity_1", "question": "What are the faculty id and the number of students each faculty has?", "rationale": ["Identify the tables needed: Faculty, Participates_in, and Faculty_Participates_in.", "We need to count the number of students associated with each faculty member, so we will join the Faculty table with the Faculty_Participates_in table to get the activities each faculty member participates in.", "Next, we join the Participates_in table to link the activities to the students participating in them.", "We will use LEFT JOINs to ensure we include faculty members even if they have no students participating in their activities.", "Finally, we group the results by Faculty.FacID to count the number of students for each faculty member."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Faculty.FacID, COUNT(Participates_in.stuid) AS student_count \nFROM Faculty \nLEFT JOIN Faculty_Participates_in ON Faculty.FacID = Faculty_Participates_in.FacID \nLEFT JOIN Participates_in ON Faculty_Participates_in.actid = Participates_in.actid \nGROUP BY Faculty.FacID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n        \"virtual_table\": \"SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank\"\n    }\n}\n"}
{"sample_id": "train.6758", "db_id": "activity_1", "question": "How many students are advised by each rank of faculty? List the rank and the number of students.", "rationale": ["Identify the tables involved: Faculty and Student.", "Determine the relationship: Faculty members advise students, indicated by the 'Advisor' field in the Student table.", "Join the Faculty table with the Student table on the advisor relationship (Faculty.FacID = Student.Advisor).", "Group the results by the faculty rank to aggregate the number of students per rank.", "Count the number of students for each rank using COUNT(*) and select the rank and the count as the output."], "gold_sql": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank", "source_tables": ["faculty", "student"], "pred_sql": "SELECT T1.Rank, COUNT(*) AS NumberOfStudents FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID = T2.Advisor GROUP BY T1.Rank", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students assigned to each academic rank of faculty members. It joins the 'Faculty' table with the 'Student' table based on the advisor relationship, grouping the results by the faculty rank to count the number of students per rank.\",\n        \"virtual_table\": \"SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank\"\n    }\n}\n"}
{"sample_id": "train.6761", "db_id": "activity_1", "question": "Show the ids for all the faculty members who have at least 2 students.", "rationale": ["We need to find faculty members who have at least 2 students assigned to them as advisors.", "To do this, we can create a virtual table that counts the number of students for each faculty member using a JOIN between the Faculty and Student tables on the advisor field.", "The virtual table will select the FacID and the count of students, grouping by FacID to get the count for each faculty member.", "Next, we will filter this virtual table to only include faculty members where the count of students is 2 or more.", "Finally, we will select the FacID from this filtered result to get the desired output."], "gold_sql": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  2", "source_tables": ["faculty", "student"], "pred_sql": "SELECT FacID FROM (SELECT T1.FacID, count(*) AS student_count FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID = T2.Advisor GROUP BY T1.FacID) AS faculty_student_count WHERE student_count >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of students assigned to each faculty member as their advisor from the 'Faculty' and 'Student' tables. The placeholder in the SELECT statement represents the faculty member's unique identifier.\",\n        \"virtual_table\": \"SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID\"\n    }\n}\n"}
{"sample_id": "train.6777", "db_id": "activity_1", "question": "Show the names of all the activities Mark Giuliano participates in.", "rationale": ["Identify the tables involved: We need to get the activities that a specific student participates in, which involves the 'Activity', 'Participates_in', and 'Student' tables.", "Determine the relationships: The 'Participates_in' table links students to activities, and the 'Student' table provides student details.", "Filter for the specific student: We need to filter the results to only include activities for the student named Mark Giuliano.", "Construct the SQL query: Use JOINs to connect the tables based on their relationships and apply the WHERE clause to filter by the student's name."], "gold_sql": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  'Mark' AND T1.lname  =  'Giuliano'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT Activity.activity_name \nFROM Student \nJOIN Participates_in ON Student.StuID = Participates_in.stuid \nJOIN Activity ON Participates_in.actid = Activity.actid \nWHERE Student.Fname = 'Mark' AND Student.LName = 'Giuliano';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6779", "db_id": "activity_1", "question": "Show the first and last name of all the faculty members who participated in some activity, together with the number of activities they participated in.", "rationale": ["Identify the tables needed: Faculty and Faculty_Participates_in.", "We need to select the first name (Fname) and last name (Lname) of faculty members, so we will select these columns from the Faculty table.", "We also need to count the number of activities each faculty member participated in, which requires a COUNT function on the actid from the Faculty_Participates_in table.", "To link the faculty members to their activities, we will perform a JOIN between the Faculty table and the Faculty_Participates_in table on the FacID column.", "Since we want to group the results by each faculty member to count their activities, we will use GROUP BY on the FacID, Fname, and Lname columns."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname, F.Lname, COUNT(FPI.actid) AS activity_count\nFROM Faculty AS F\nJOIN Faculty_Participates_in AS FPI ON F.FacID = FPI.FacID\nGROUP BY F.FacID, F.Fname, F.Lname;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: Participates_in (for student participation) and Student (for student details).", "We need to select student IDs (stuid) from the Participates_in table.", "Join the Participates_in table with the Student table on the student ID to access student details.", "Apply a filter to only include students who are under 20 years old by checking the Age column in the Student table."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT P.stuid FROM Participates_in AS P JOIN Student AS S ON P.stuid = S.StuID WHERE S.Age < 20;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of faculty members participating in each activity from the 'Activity' table. The placeholder in the GROUP BY clause represents the activity's identifier.\",\n        \"virtual_table\": \"SELECT T1.activity_name ,  count(*) FROM Activity AS T1 JOIN Faculty_participates_in AS T2 ON T1.actID  =  T2.actID GROUP BY T1.actID\"\n    }\n}\n"}
{"sample_id": "train.6797", "db_id": "activity_1", "question": "Find the first names of professors who are not playing Canoeing or Kayaking.", "rationale": ["Identify the main goal: Find the first names of professors who are not participating in Canoeing or Kayaking.", "To achieve this, we need to select the first names from the Faculty table.", "We will use a subquery to find the faculty members who are participating in either Canoeing or Kayaking.", "The subquery will join the Faculty_Participates_in table with the Activity table to filter based on activity names.", "The main query will filter out the faculty IDs that are returned by the subquery using the NOT IN clause."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname \nFROM Faculty AS F \nWHERE F.FacID NOT IN (\n    SELECT T2.FacID \n    FROM Faculty_Participates_in AS T2 \n    JOIN Activity AS T3 ON T2.actid = T3.actid \n    WHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the main table to query from, which is the Faculty table to get the first names of professors.", "We need to filter out professors who participate in Canoeing or Kayaking activities.", "To do this, we will create a subquery that selects the FacID of faculty members who participate in either Canoeing or Kayaking.", "The subquery joins the Faculty table with Faculty_Participates_in and Activity tables to find the relevant activities.", "The main query selects the first names of faculty members whose FacID is not in the list produced by the subquery."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.Fname FROM Faculty AS F WHERE F.FacID NOT IN (SELECT T2.FacID FROM Faculty AS T1 JOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID JOIN Activity AS T3 ON T2.actid = T3.actid WHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6799", "db_id": "activity_1", "question": "Find the first names of the faculty members who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: Faculty, Faculty_Participates_in, and Activity.", "We need to find the first names of faculty members, so we will select the 'Fname' column from the Faculty table.", "To find faculty members who participate in specific activities, we will join the Faculty table with the Faculty_Participates_in table on the 'FacID' column.", "Next, we will join the result with the Activity table on the 'actid' column to filter by activity names.", "We will use a WHERE clause to filter the activities to 'Canoeing' and 'Kayaking'.", "Finally, we will use DISTINCT to ensure that we only get unique first names of faculty members."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT DISTINCT T1.Fname FROM Faculty AS T1 JOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID JOIN Activity AS T3 ON T2.actid = T3.actid WHERE T3.activity_name = 'Canoeing' OR T3.activity_name = 'Kayaking'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct last names of faculty members who participate in specific activities. The activities are filtered based on their names, which are represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] OR T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables involved: We need to find student IDs from the Participates_in table and the activity names from the Activity table.", "Determine the relationship: The Participates_in table has a foreign key actid that links to the Activity table's actid.", "Filter the activities: We are specifically looking for students who participate in 'Canoeing' and 'Kayaking'.", "Construct the SQL query: Use a JOIN to combine the Participates_in and Activity tables on actid, and filter the results based on the activity names."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT p.stuid \nFROM Participates_in p \nJOIN Activity a ON p.actid = a.actid \nWHERE a.activity_name IN ('Canoeing', 'Kayaking');", "hint": "\n"}
{"sample_id": "train.6825", "db_id": "flight_4", "question": "Find the number of routes operated by American Airlines.", "rationale": ["Identify the relevant tables: 'routes' for route information and 'airlines' for airline details.", "We need to count the number of routes operated by a specific airline, which is 'American Airlines'.", "To do this, we will join the 'routes' table with the 'airlines' table on the airline ID ('alid').", "We will filter the results to include only those routes where the airline name is 'American Airlines'.", "Finally, we will use the COUNT function to get the total number of routes for 'American Airlines'."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT COUNT(*) AS number_of_routes \nFROM routes \nJOIN airlines ON routes.alid = airlines.alid \nWHERE airlines.name = 'American Airlines';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6826", "db_id": "flight_4", "question": "How many routes does American Airlines operate?", "rationale": ["Identify the airline of interest, which is 'American Airlines'.", "Find the unique identifier (alid) for 'American Airlines' from the airlines table.", "Count the number of routes in the routes table where the alid matches the one found for 'American Airlines'."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT COUNT(*) FROM routes WHERE alid = (SELECT alid FROM airlines WHERE name = 'American Airlines')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airline names along with their unique identifiers from the 'airlines' table, based on the routes they operate. The results are grouped by airline ID and ordered by the number of routes in descending order, with a limit set by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.name ,  T2.alid FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T2.alid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6831", "db_id": "flight_4", "question": "Find the name, city, and country of the airport that has the highest latitude.", "rationale": ["To find the airport with the highest latitude, we need to look at the 'y' coordinate in the airports table, as it represents the latitude.", "We will select the 'name', 'city', and 'country' columns from the airports table.", "To get the airport with the highest latitude, we will order the results by the 'y' column in descending order.", "Finally, we will limit the results to 1 to get only the airport with the highest latitude."], "gold_sql": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT 1", "source_tables": ["airports"], "pred_sql": "SELECT name, city, country FROM airports ORDER BY y DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    }\n}\n"}
{"sample_id": "train.6834", "db_id": "flight_4", "question": "What is the name and city of the airport that the most routes end at?", "rationale": ["Identify the relevant tables: 'airports' for airport details and 'routes' for route information.", "We need to find the airport that has the most routes ending at it, which means we will join the 'airports' table with the 'routes' table on the destination airport ID ('dst_apid').", "We will group the results by the airport ID ('apid') to count the number of routes that end at each airport.", "To find the airport with the most routes, we will order the results by the count of routes in descending order.", "Finally, we will limit the results to just one record to get the airport with the highest count."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, airports.city FROM airports JOIN routes ON airports.apid = routes.dst_apid GROUP BY airports.apid ORDER BY COUNT(routes.rid) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n        \"virtual_table\": \"SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6838", "db_id": "flight_4", "question": "What is the name and city of the airport from most of the routes start?", "rationale": ["Identify the relevant tables: 'airports' for airport details and 'routes' for route information.", "Join the 'airports' table with the 'routes' table on the source airport ID to get the airport names and cities for routes.", "Group the results by airport name to count how many routes start from each airport.", "Order the results by the count of routes in descending order to find the airport with the most routes starting from it.", "Select the name and city of the airport with the highest count of starting routes, limiting the result to one entry."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT T1.name, T1.city FROM airports AS T1 JOIN routes AS T2 ON T1.apid = T2.src_apid GROUP BY T1.name ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    }\n}\n"}
{"sample_id": "train.6841", "db_id": "flight_4", "question": "Which countries has the most number of airlines?", "rationale": ["Identify the relevant table: The airlines table contains information about airlines and their countries.", "Determine the required information: We need to count the number of airlines per country.", "Use the COUNT function to count the airlines, and GROUP BY to group the results by country.", "Order the results in descending order to find the countries with the most airlines."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country, count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\",\n        \"virtual_table\": \"SELECT country ,  count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC\"\n    }\n}\n"}
{"sample_id": "train.6842", "db_id": "flight_4", "question": "What is the name of the country with the most number of home airlines?", "rationale": ["Identify the relevant table: The question pertains to airlines and their countries, so we will use the 'airlines' table.", "Count the number of airlines per country: We need to group the results by the 'country' column and count the number of airlines in each country.", "Order the results: To find the country with the most airlines, we will order the results in descending order based on the count of airlines.", "Select the appropriate columns: We will select the 'country' and the count of airlines for the final output."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country, count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\",\n        \"virtual_table\": \"SELECT country ,  count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC\"\n    }\n}\n"}
{"sample_id": "train.6858", "db_id": "flight_4", "question": "What are the cities that have more than 2 airports sorted by number of airports?", "rationale": ["We need to find cities with more than 2 airports.", "To do this, we will count the number of airports in each city.", "We will use the GROUP BY clause to group the results by city.", "The HAVING clause will filter the results to include only those cities with more than 2 airports.", "Finally, we will sort the results by the number of airports in descending order."], "gold_sql": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)", "source_tables": ["airports"], "pred_sql": "SELECT city, COUNT(*) as airport_count \nFROM airports \nGROUP BY city \nHAVING COUNT(*) > 2 \nORDER BY airport_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    }\n}\n"}
{"sample_id": "train.6862", "db_id": "flight_4", "question": "For each  airport name, how many routes start at that airport, ordered from most to least?", "rationale": ["We need to count the number of routes that start at each airport.", "To do this, we will join the 'airports' table with the 'routes' table on the airport ID, where the airport ID in the 'airports' table matches the source airport ID in the 'routes' table.", "We will use the COUNT function to count the number of routes for each airport.", "We will group the results by the airport name to get the count for each airport.", "Finally, we will order the results by the count of routes in descending order to show the airports with the most routes first."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC", "source_tables": ["airports", "routes"], "pred_sql": "SELECT count(*) AS route_count, T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid = T2.src_apid GROUP BY T1.name ORDER BY route_count DESC", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    }\n}\n"}
{"sample_id": "train.6867", "db_id": "flight_4", "question": "For each country and airline name, how many routes are there?", "rationale": ["We need to count the number of routes for each country and airline name.", "To achieve this, we will join the 'routes' table with the 'airlines' table using the airline ID (alid) as the foreign key.", "We will select the country from the airlines table and the airline name, along with a count of the routes.", "We will group the results by country and airline name to get the count of routes for each combination.", "Finally, we will order the results by country and the count of routes in descending order."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT a.country, r.airline, COUNT(*) AS route_count \nFROM routes r \nJOIN airlines a ON r.alid = a.alid \nGROUP BY a.country, r.airline \nORDER BY a.country, route_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\",\n        \"virtual_table\": \"SELECT country ,  count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC\"\n    }\n}\n"}
{"sample_id": "train.6868", "db_id": "flight_4", "question": "What is the total number of routes for each country and airline in that country?", "rationale": ["We need to find the total number of routes for each country and the airline operating those routes.", "To achieve this, we will join the 'routes' table with the 'airlines' table using the airline ID (alid) as the foreign key.", "We will select the country from the airlines table and the airline name, along with a count of the route IDs (rid) from the routes table to get the total number of routes.", "We will group the results by country and airline to get the total routes for each combination.", "Finally, we will order the results by country and the total number of routes in descending order."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT a.country, r.airline, COUNT(r.rid) AS total_routes \nFROM routes r \nJOIN airlines a ON r.alid = a.alid \nGROUP BY a.country, r.airline \nORDER BY a.country, total_routes DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of airlines grouped by their country of origin. The placeholder in the SELECT statement allows for dynamic querying of the country and the count of airlines associated with it.\",\n        \"virtual_table\": \"SELECT country ,  count(*) FROM airlines GROUP BY country ORDER BY count(*) DESC\"\n    }\n}\n"}
{"sample_id": "train.6873", "db_id": "flight_4", "question": "Find the number of routes that have destination John F Kennedy International Airport.", "rationale": ["Identify the relevant table: The 'routes' table contains information about routes including destination airports.", "Determine the condition: We need to filter the routes where the destination airport name is 'John F Kennedy International Airport'.", "Use the COUNT function: To find the number of such routes, we will use the COUNT(*) function.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter the results."], "gold_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'", "source_tables": ["airports", "routes"], "pred_sql": "SELECT COUNT(*) FROM routes WHERE dst_ap = 'John F Kennedy International Airport'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of routes originating from each airport, along with the names of those airports. The placeholder in the SELECT statement represents the count of routes, while the GROUP BY clause groups the results by the airport names.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name\"\n    }\n}\n"}
{"sample_id": "train.6880", "db_id": "flight_4", "question": "What is the name of the airline with the most routes?", "rationale": ["Identify the tables involved: 'airlines' for airline names and 'routes' for the routes operated by those airlines.", "Join the 'airlines' table with the 'routes' table on the airline ID (alid) to associate each airline with its routes.", "Group the results by airline name to count the number of routes each airline operates.", "Order the grouped results in descending order based on the count of routes to find the airline with the most routes.", "Limit the results to 1 to get only the airline with the highest count of routes."], "gold_sql": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid = T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n        \"virtual_table\": \"SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6883", "db_id": "flight_4", "question": "Find the busiest destination airport that runs most number of routes in China.", "rationale": ["Identify the relevant tables: 'routes' for route information and 'airports' for airport details.", "We need to find the busiest destination airport in China, so we will focus on the 'dst_ap' (destination airport name) from the 'routes' table.", "Join the 'routes' table with the 'airports' table on the destination airport ID ('dst_apid' in 'routes' and 'apid' in 'airports').", "Filter the results to include only those airports located in China by checking the 'country' column in the 'airports' table.", "Group the results by the destination airport name to count the number of routes for each airport.", "Order the results by the count of routes in descending order to find the busiest airport.", "Limit the results to 1 to get only the busiest destination airport."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT dst_ap, COUNT(*) as route_count \nFROM routes AS r \nJOIN airports AS a ON r.dst_apid = a.apid \nWHERE a.country = 'China' \nGROUP BY dst_ap \nORDER BY route_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n        \"virtual_table\": \"SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6884", "db_id": "flight_4", "question": "What is the name of the airport that is the destination of the most number of routes that start in China?", "rationale": ["Identify the relevant tables: 'routes' for route information and 'airports' for airport details.", "We need to find the destination airport ('dst_ap') that has the most routes originating from China.", "To do this, we will filter the 'routes' table for those routes where the source airport is in China. We can achieve this by using a subquery to select the 'apid' of airports located in China.", "Join the 'routes' table with the 'airports' table to get the destination airport names.", "Group the results by the destination airport name to count the number of routes to each destination.", "Order the results in descending order based on the count of routes to find the most popular destination.", "Limit the results to 1 to get only the top destination airport."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT dst_ap FROM routes AS r JOIN airports AS a ON r.dst_apid = a.apid WHERE r.src_apid IN (SELECT apid FROM airports WHERE country = 'China') GROUP BY r.dst_ap ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of airlines that operate the most routes, based on the data from the 'airlines' and 'routes' tables. The placeholder in the LIMIT clause represents the maximum number of airline names to return.\",\n        \"virtual_table\": \"SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6980", "db_id": "culture_company", "question": "Show all publishers which do not have a book in 1989.", "rationale": ["Identify the requirement to find publishers without books in 1989.", "Use a subquery to find all publishers that have books published in 1989.", "Select distinct publishers from the 'book_club' table.", "Filter the main query to exclude those publishers found in the subquery."], "gold_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989", "source_tables": ["book_club"], "pred_sql": "SELECT DISTINCT publisher FROM book_club WHERE publisher NOT IN (SELECT DISTINCT Publisher FROM book_club WHERE Year = '1989')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of publishers from the 'book_club' table, grouped by the publisher's name. The results are ordered by the number of books published by each publisher in descending order, with a limit on the number of publishers returned based on a specified number.\",\n        \"virtual_table\": \"SELECT publisher FROM book_club GROUP BY publisher ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6990", "db_id": "culture_company", "question": "Show all director names who have a movie in the year 1999 or 2000.", "rationale": ["Identify the table that contains the director information, which is the 'movie' table.", "Determine the relevant column for the director's name, which is 'Director'.", "Identify the column that contains the year of the movie, which is 'Year'.", "Specify the years of interest, which are 1999 and 2000.", "Use the DISTINCT keyword to ensure that each director's name is listed only once, even if they directed multiple movies in those years."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6991", "db_id": "culture_company", "question": "Which directors had a movie in either 1999 or 2000?", "rationale": ["Identify the relevant table: The question pertains to directors and movies, so we will focus on the 'movie' table.", "Determine the columns needed: We need the 'Director' column to answer the question.", "Filter the results: We need to find movies released in either 1999 or 2000, so we will use a WHERE clause with the IN operator to specify these years.", "Use DISTINCT to ensure that each director is listed only once, even if they directed multiple movies in those years."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6996", "db_id": "culture_company", "question": "Show the movie titles and book titles for all companies in China.", "rationale": ["Identify the tables involved: culture_company, movie, and book_club.", "Determine the columns needed: movie titles from the movie table and book titles from the book_club table.", "Establish the relationships between the tables using JOINs: culture_company to movie and culture_company to book_club.", "Filter the results to only include companies based in China using a WHERE clause."], "gold_sql": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  'China'", "source_tables": ["culture_company", "movie", "book_club"], "pred_sql": "SELECT movie.Title AS Movie_Title, book_club.Book_Title AS Book_Title\nFROM culture_company\nJOIN movie ON culture_company.movie_id = movie.movie_id\nJOIN book_club ON culture_company.book_club_id = book_club.book_club_id\nWHERE culture_company.Company_name = 'China';", "hint": "\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: 'cars_data' for horsepower and 'car_names' for car models.", "Join the 'cars_data' table with the 'car_names' table on the 'Id' and 'MakeId' columns to access both horsepower and model name.", "Order the results by horsepower in ascending order to find the minimum value.", "Limit the results to 1 to get only the model with the minimum horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id = T2.MakeId ORDER BY Horsepower ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.103", "db_id": "car_1", "question": "Which distinct car models are the produced after 1980?", "rationale": ["Identify the tables involved: model_list, car_names, and cars_data.", "We need to select distinct car models, so we will use SELECT DISTINCT on the model column from the model_list table.", "To get the car models, we need to join the model_list table with the car_names table on the model column.", "Next, we join the resulting table with the cars_data table on the MakeId to access the manufacturing year.", "Finally, we filter the results to include only those models manufactured after 1980 using a WHERE clause."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "pred_sql": "SELECT DISTINCT T1.Model FROM model_list AS T1 JOIN car_names AS T2 ON T1.Model = T2.Model JOIN cars_data AS T3 ON T2.MakeId = T3.Id WHERE T3.Year > 1980;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.106", "db_id": "car_1", "question": "What is the name of each continent and how many car makers are there in each one?", "rationale": ["Identify the tables needed: continents, countries, and car_makers.", "We need to count the number of car makers for each continent, so we will use the COUNT function.", "Join the continents table with the countries table on the ContId and Continent columns.", "Then, join the countries table with the car_makers table on the CountryId and Country columns.", "Group the results by continent to get the count of car makers for each continent."], "gold_sql": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;", "source_tables": ["countries", "car_makers", "continents"], "pred_sql": "SELECT c.Continent, COUNT(cm.Id) AS CarMakerCount\nFROM continents c\nJOIN countries co ON c.ContId = co.Continent\nJOIN car_makers cm ON co.CountryId = cm.Country\nGROUP BY c.Continent;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: 'cars_data' for car performance data and 'car_names' for car make and model.", "Join the 'cars_data' table with the 'car_names' table on the condition that the 'Id' in 'cars_data' matches the 'MakeId' in 'car_names'.", "Filter the results to only include rows where the 'Model' in 'car_names' is 'amc hornet sportabout (sw)'.", "Select the 'Accelerate' column from the resulting joined table to get the acceleration time for the specified car model."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT T1.Accelerate FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id = T2.MakeId WHERE T2.Model = 'amc hornet sportabout (sw)';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the relevant tables: 'car_makers' and 'countries'.", "We need to count the distinct car makers based in France, so we will use the COUNT function.", "Join the 'car_makers' table with the 'countries' table on the country identifier.", "Filter the results to include only those countries where the CountryName is 'France'.", "Select the count of distinct car makers from the result."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT car_makers.Id) AS NumberOfCarMakers FROM car_makers JOIN countries ON car_makers.Country = countries.CountryId WHERE countries.CountryName = 'France';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.114", "db_id": "car_1", "question": "What is the number of makers of care in France?", "rationale": ["Identify the relevant tables: We need to find the number of car makers in France, so we will use the 'car_makers' and 'countries' tables.", "Determine the relationship: The 'car_makers' table has a foreign key 'Country' that references 'countries.CountryId'. We need to join these two tables on this key.", "Filter for France: We need to filter the results to only include car makers based in France. This is done by checking the 'CountryName' in the 'countries' table.", "Count distinct makers: We want the count of unique car makers, so we will use COUNT(DISTINCT car_makers.Id) to get the number of unique makers in France."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "SELECT COUNT(DISTINCT car_makers.Id) AS NumberOfMakers\nFROM car_makers\nJOIN countries ON car_makers.Country = countries.CountryId\nWHERE countries.CountryName = 'France';", "hint": "\n"}
{"sample_id": "dev.115", "db_id": "car_1", "question": "How many car models are produced in the usa?", "rationale": ["Identify the relevant tables: model_list, car_makers, and countries.", "We need to count distinct car models, so we will use COUNT(DISTINCT T1.Model).", "Join model_list (T1) with car_makers (T2) on the Maker column to get the country of each car maker.", "Join car_makers (T2) with countries (T3) on the Country column to filter for car makers based in the USA.", "Use a WHERE clause to specify that we only want records where the country name is 'USA'."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "pred_sql": "SELECT COUNT(DISTINCT T1.Model) FROM model_list AS T1 JOIN car_makers AS T2 ON T1.Maker = T2.Id JOIN countries AS T3 ON T2.Country = T3.CountryId WHERE T3.CountryName = 'USA';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the relevant tables: countries, car_makers, and continents.", "We need to filter countries that are in Europe, so we will join the countries table with the continents table to get the ContId for Europe.", "Next, we will join the car_makers table to the countries table to find out how many car manufacturers are in each country.", "We will group the results by country name to count the number of car manufacturers per country.", "Finally, we will use the HAVING clause to filter countries that have at least 3 car manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT c.CountryName\nFROM countries AS c\nJOIN car_makers AS cm ON c.CountryId = cm.Country\nWHERE c.Continent = (SELECT ContId FROM continents WHERE Continent = 'Europe')\nGROUP BY c.CountryName\nHAVING COUNT(cm.Id) >= 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the relevant tables: We need data from 'cars_data' for horsepower and cylinders, and 'car_names' for the make of the car.", "We need to filter the results to only include car models with 3 cylinders, which is done using a WHERE clause.", "To find the maximum horsepower, we will use the MAX() function on the 'Horsepower' column from the 'cars_data' table.", "We will join 'cars_data' and 'car_names' on the 'Id' and 'MakeId' columns respectively to get the make of the car along with its horsepower.", "Finally, we will group the results by the car make to ensure we get the maximum horsepower for each make."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(cars_data.Horsepower) AS MaxHorsepower, car_names.Make \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Cylinders = 3 \nGROUP BY car_names.Make;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.133", "db_id": "car_1", "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.", "rationale": ["Identify the relevant tables: 'cars_data' for MPG and 'car_names' for car models.", "Join 'cars_data' and 'car_names' on the common key 'MakeId'.", "Select the 'Model' and 'MPG' columns from the joined tables.", "Order the results by 'MPG' in descending order to find the model with the maximum miles per gallon.", "Limit the results to 1 to get only the top model that saves the most gasoline."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, MPG FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id = T2.MakeId ORDER BY MPG DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["We need to find the names and ids of all car makers that have more than 3 models.", "To do this, we will join the 'car_makers' table with the 'model_list' table on the car maker's ID.", "We will group the results by the car maker's ID and name to aggregate the models associated with each maker.", "Using the HAVING clause, we will filter the groups to include only those with a count of models greater than 3."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "SELECT car_makers.Id, car_makers.Maker \nFROM car_makers \nJOIN model_list ON car_makers.Id = model_list.Maker \nGROUP BY car_makers.Id, car_makers.Maker \nHAVING COUNT(model_list.ModelId) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.158", "db_id": "car_1", "question": "For a volvo model, how many cylinders does the version with least accelerate have?", "rationale": ["Identify the relevant tables: 'cars_data' for car specifications and 'car_names' for car models.", "Join 'cars_data' and 'car_names' on the common key 'MakeId' to access both car specifications and model names.", "Filter the results to only include rows where the model is 'volvo'.", "Order the results by the 'Accelerate' column in ascending order to find the version with the least acceleration time.", "Limit the results to 1 to get only the top entry, which corresponds to the version with the least acceleration."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT T1.Cylinders FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id = T2.MakeId WHERE T2.Model = 'volvo' ORDER BY T1.Accelerate ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.160", "db_id": "car_1", "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?", "rationale": ["Identify the requirement: We need to count the number of cars with an acceleration time greater than the maximum horsepower.", "To find the maximum horsepower, we can use a subquery that selects the maximum value from the 'Horsepower' column in the 'cars_data' table.", "Next, we need to count the number of entries in the 'cars_data' table where the 'Accelerate' value is greater than the result of the subquery.", "The final SQL query combines these elements to count the cars that meet the specified condition."], "gold_sql": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "source_tables": ["cars_data"], "pred_sql": "SELECT COUNT(*) FROM cars_data WHERE Accelerate > (SELECT MAX(Horsepower) FROM cars_data);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables: cars_data for car specifications and car_names for car models.", "We need to filter cars that have 4 cylinders, so we will use a WHERE clause on the Cylinders column in the cars_data table.", "We want to find the model with the largest horsepower, so we will select the Model and Horsepower columns.", "To get the model with the largest horsepower, we will order the results by the Horsepower column in descending order.", "Finally, we will limit the results to 1 to get only the top result."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM cars_data AS cd JOIN car_names AS cn ON cd.Id = cn.MakeId WHERE cd.Cylinders = 4 ORDER BY cd.Horsepower DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.166", "db_id": "car_1", "question": "For all of the 4 cylinder cars, which model has the most horsepower?", "rationale": ["Identify the relevant tables: cars_data and car_names.", "We need to filter cars based on the number of cylinders, specifically 4 cylinders.", "Join the cars_data table with the car_names table on the Id and MakeId columns to access the model names.", "Select the Model and Horsepower columns from the joined tables.", "Order the results by Horsepower in descending order to get the highest horsepower first.", "Limit the results to 1 to get only the model with the most horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id = T2.MakeId WHERE T1.Cylinders = 4 ORDER BY T1.Horsepower DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.168", "db_id": "car_1", "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?", "rationale": ["Identify the minimum horsepower from the cars_data table using a subquery.", "Select the make ids and names from the car_names table where the make id is not equal to the minimum horsepower found in the previous step.", "Additionally, filter the results to include only those cars that have less than 4 cylinders by using another subquery on the cars_data table."], "gold_sql": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT MakeId, Model FROM car_names WHERE MakeId NOT IN (SELECT Id FROM cars_data WHERE Horsepower = (SELECT MIN(Horsepower) FROM cars_data)) AND MakeId IN (SELECT Id FROM cars_data WHERE Cylinders < 4);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the number of cylinders for cars from the 'cars_data' table, filtered by a specific car model from the 'car_names' table. The results are ordered by the acceleration time in ascending order, and the limit on the number of results can be specified using a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.accelerate ASC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the relevant tables: car_makers, model_list, car_names, and cars_data.", "Join the car_makers table with model_list to get the models produced by each maker.", "Join the model_list with car_names to link the models to their respective makes.", "Join car_names with cars_data to count the number of cars produced for each make.", "Group the results by car maker's Id and Maker name to aggregate the counts.", "Use HAVING clause to filter for car makers that produce at least 2 distinct models and have more than 3 cars."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "SELECT cm.Id, cm.Maker\nFROM car_makers AS cm\nJOIN model_list AS ml ON cm.Id = ml.Maker\nJOIN car_names AS cn ON ml.Model = cn.Model\nJOIN cars_data AS cd ON cn.MakeId = cd.Id\nGROUP BY cm.Id, cm.Maker\nHAVING COUNT(DISTINCT ml.Model) >= 2 AND COUNT(cd.Id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that have been manufactured after a specific year. The query joins the 'model_list' table with the 'car_names' table to match car models and then further joins with the 'cars_data' table to filter based on the manufacturing year. The placeholder in the WHERE clause represents the year of manufacture.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.180", "db_id": "flight_2", "question": "What country is Jetblue Airways affiliated with?", "rationale": ["Identify the relevant table: The 'airlines' table contains information about airlines, including their names and associated countries.", "Determine the specific airline of interest: The user is asking about 'Jetblue Airways'.", "Construct the SQL query to select the 'Country' column from the 'airlines' table where the 'Airline' column matches 'Jetblue Airways'."], "gold_sql": "SELECT Country FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "pred_sql": "SELECT Country FROM airlines WHERE Airline = 'Jetblue Airways'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.194", "db_id": "flight_2", "question": "Give the airline with abbreviation 'UAL'.", "rationale": ["Identify the relevant table: The 'airlines' table contains the abbreviation for each airline.", "Determine the condition: We need to filter the results to find the airline with the abbreviation 'UAL'.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'airlines' table where the abbreviation matches 'UAL'."], "gold_sql": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  'UAL'", "source_tables": ["airlines"], "pred_sql": "SELECT * FROM airlines WHERE Abbreviation = 'UAL';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.214", "db_id": "flight_2", "question": "Give the number of Jetblue Airways flights.", "rationale": ["Identify the relevant table: The 'flights' table contains information about the flights, including the airline name.", "Determine the specific airline: The user is interested in 'Jetblue Airways'.", "Construct the SQL query: Use the COUNT() function to count the number of flights where the Airline is 'Jetblue Airways'."], "gold_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'JetBlue Airways'", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT COUNT(*) FROM flights WHERE Airline = 'Jetblue Airways';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.225", "db_id": "flight_2", "question": "What is the code of airport that has the highest number of flights?", "rationale": ["Identify the relevant tables: 'airports' for airport codes and 'flights' for flight information.", "Join the 'airports' table with the 'flights' table on the condition that the airport code is either a source or destination airport.", "Group the results by airport code to aggregate the number of flights associated with each airport.", "Order the results in descending order based on the count of flights to find the airport with the highest number of flights.", "Limit the results to 1 to get only the airport code with the highest number of flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT T1.AirportCode FROM airports AS T1 JOIN flights AS T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.227", "db_id": "flight_2", "question": "What is the code of airport that has fewest number of flights?", "rationale": ["Identify the airports that are either source or destination for flights.", "Count the number of flights associated with each airport.", "Order the airports by the count of flights in ascending order to find the airport with the fewest flights.", "Limit the results to return only the airport code of the airport with the fewest flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT AirportCode FROM airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM flights UNION SELECT DestAirport FROM flights) ORDER BY (SELECT COUNT(*) FROM flights WHERE SourceAirport = airports.AirportCode OR DestAirport = airports.AirportCode) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.229", "db_id": "flight_2", "question": "Which airline has most number of flights?", "rationale": ["Identify the relevant tables: 'airlines' and 'flights'.", "We need to find the airline with the most flights, so we will join the 'airlines' table with the 'flights' table on the airline identifier.", "We will group the results by the airline name to count the number of flights for each airline.", "To find the airline with the most flights, we will order the results by the count of flights in descending order.", "Finally, we will limit the results to only return the top airline."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.232", "db_id": "flight_2", "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?", "rationale": ["Identify the airline with the fewest flights by counting the number of flights for each airline in the 'flights' table.", "Use a subquery to group the flights by airline and count them, ordering the results in ascending order to find the airline with the minimum count.", "Limit the results of the subquery to 1 to get only the airline with the fewest flights.", "Join the result of the subquery with the 'airlines' table to get the abbreviation and country of that airline."], "gold_sql": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT a.Abbreviation, a.Country FROM airlines AS a JOIN (SELECT f.Airline, COUNT(*) AS flight_count FROM flights AS f GROUP BY f.Airline ORDER BY flight_count ASC LIMIT 1) AS min_flights ON a.Airline = min_flights.Airline;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The placeholder in the LIMIT clause represents the maximum number of airport codes to return.\",\n        \"virtual_table\": \"SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.244", "db_id": "flight_2", "question": "Which airlines have less than 200 flights?", "rationale": ["Identify the relevant tables: 'airlines' and 'flights'.", "Join the 'airlines' table with the 'flights' table on the airline identifier (uid).", "Group the results by airline name to aggregate the number of flights for each airline.", "Use the HAVING clause to filter the grouped results to only include airlines with less than 200 flights."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING COUNT(T2.FlightNo) < 200;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airlines from the 'airlines' table that are associated with flights in the 'flights' table. The results are grouped by airline name and ordered by the number of flights in descending order, with a limit on the number of airlines returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.258", "db_id": "flight_2", "question": "Which airports do not have departing or arriving flights?", "rationale": ["Identify the airports from the 'airports' table that do not have any flights associated with them.", "Use a subquery to find all airport codes that are either source or destination airports in the 'flights' table.", "The subquery selects airport codes from the 'airports' table that join with the 'flights' table on the conditions of being either a source or destination airport.", "The main query selects airport codes and names from the 'airports' table where the airport code is not in the list of airport codes returned by the subquery."], "gold_sql": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)", "source_tables": ["airports", "flights"], "pred_sql": "SELECT AirportCode, AirportName FROM airports WHERE AirportCode NOT IN (SELECT T1.AirportCode FROM airports AS T1 JOIN flights AS T2 ON T1.AirportCode = T2.DestAirport OR T1.AirportCode = T2.SourceAirport)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the airport codes from the 'airports' table that are either source or destination airports for flights in the 'flights' table. The results are grouped by airport code and ordered by the number of flights associated with each airport, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.308", "db_id": "cre_Doc_Template_Mgt", "question": "Count the number of documents that use the PPT template type.", "rationale": ["Identify the relevant tables: We need to count documents, so we will use the 'Documents' table.", "Join the 'Documents' table with the 'Templates' table on 'Template_ID' to link documents to their respective templates.", "Filter the results to only include documents that are associated with the 'PPT' template type by using a WHERE clause on 'Template_Type_Code'.", "Use the COUNT function to count the number of documents that meet the criteria."], "gold_sql": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'", "source_tables": ["templates", "documents"], "pred_sql": "SELECT COUNT(*) FROM Documents AS D JOIN Templates AS T ON D.Template_ID = T.Template_ID WHERE T.Template_Type_Code = 'PPT'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\",\n        \"virtual_table\": \"SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code\"\n    }\n}\n"}
{"sample_id": "dev.311", "db_id": "cre_Doc_Template_Mgt", "question": "What is the id and type code for the template used by the most documents?", "rationale": ["The question asks for the ID and type code of the template used by the most documents.", "To find this, we first need to count the number of documents associated with each template type.", "We can use the provided hint to create a virtual table that summarizes the count of documents for each template type.", "Next, we need to join this virtual table back to the Templates table to get the Template_ID and Template_Type_Code.", "Finally, we filter the results to only include the template type(s) that have the maximum document count."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT T1.Template_ID, T1.Template_Type_Code \nFROM Templates AS T1 \nJOIN (\n    SELECT T1.Template_Type_Code, COUNT(*) AS Document_Count \n    FROM Templates AS T1 \n    JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \n    GROUP BY T1.Template_Type_Code \n) AS T3 ON T1.Template_Type_Code = T3.Template_Type_Code \nWHERE T3.Document_Count = (\n    SELECT MAX(Document_Count) \n    FROM (\n        SELECT COUNT(*) AS Document_Count \n        FROM Templates AS T1 \n        JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \n        GROUP BY T1.Template_Type_Code \n    ) AS T4\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\",\n        \"virtual_table\": \"SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code\"\n    }\n}\n"}
{"sample_id": "dev.312", "db_id": "cre_Doc_Template_Mgt", "question": "Return the id and type code of the template that is used for the greatest number of documents.", "rationale": ["The task is to find the template ID and type code that is associated with the greatest number of documents.", "To achieve this, we need to count the number of documents associated with each template type.", "We can use a subquery to count the documents for each template type by joining the Templates and Documents tables.", "The subquery will group the results by Template_Type_Code and count the number of documents for each type.", "Next, we need to find the maximum count of documents from this subquery.", "Finally, we will join this result back to the Templates table to get the Template_ID and Template_Type_Code for the template(s) that have this maximum document count."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT T1.Template_ID, T1.Template_Type_Code \nFROM Templates AS T1 \nJOIN (\n    SELECT T1.Template_Type_Code, COUNT(*) AS Document_Count \n    FROM Templates AS T1 \n    JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \n    GROUP BY T1.Template_Type_Code \n) AS DocCount ON T1.Template_Type_Code = DocCount.Template_Type_Code \nWHERE DocCount.Document_Count = (\n    SELECT MAX(Document_Count) \n    FROM (\n        SELECT COUNT(*) AS Document_Count \n        FROM Templates AS T1 \n        JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \n        GROUP BY T1.Template_Type_Code \n    )\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\",\n        \"virtual_table\": \"SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code\"\n    }\n}\n"}
{"sample_id": "dev.341", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template type codes and the number of documents using each type.", "rationale": ["Identify the tables involved: Templates and Documents.", "Determine the relationship between the tables: Documents are linked to Templates via Template_ID.", "Select the Template_Type_Code from the Templates table.", "Count the number of documents associated with each template type using COUNT(*) function.", "Group the results by Template_Type_Code to get the count for each type."], "gold_sql": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code", "source_tables": ["templates", "documents"], "pred_sql": "SELECT T1.Template_Type_Code, COUNT(*) AS Document_Count \nFROM Templates AS T1 \nJOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID \nGROUP BY T1.Template_Type_Code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\",\n        \"virtual_table\": \"SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code\"\n    }\n}\n"}
{"sample_id": "dev.346", "db_id": "cre_Doc_Template_Mgt", "question": "What are the codes of template types that are not used for any document?", "rationale": ["Identify the template types from the Ref_Template_Types table.", "Use a subquery to find template types that are associated with documents by joining the Templates and Documents tables.", "The subquery counts the number of documents for each template type and groups them by Template_Type_Code.", "Use the NOT IN clause to filter out the template types that are present in the subquery result, leaving only those that are not used for any document."], "gold_sql": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Template_Type_Code FROM Ref_Template_Types WHERE Template_Type_Code NOT IN (SELECT T1.Template_Type_Code FROM Templates AS T1 JOIN Documents AS T2 ON T1.Template_ID = T2.Template_ID GROUP BY T1.Template_Type_Code)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the count of documents associated with each template type from the 'Templates' and 'Documents' tables. The placeholder in the SELECT statement represents the template type code, and the count indicates the number of documents linked to each template type.\",\n        \"virtual_table\": \"SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code\"\n    }\n}\n"}
{"sample_id": "dev.361", "db_id": "cre_Doc_Template_Mgt", "question": "Show paragraph details for paragraph with text 'Korea ' .", "rationale": ["Identify the table that contains paragraph details, which is the 'Paragraphs' table.", "Determine the column that holds the text content of the paragraph, which is 'Paragraph_Text'.", "Formulate a SQL query to select all columns from the 'Paragraphs' table where the 'Paragraph_Text' matches the specified text 'Korea '."], "gold_sql": "select other_details from paragraphs where paragraph_text like 'korea'", "source_tables": ["paragraphs"], "pred_sql": "SELECT * FROM Paragraphs WHERE Paragraph_Text = 'Korea ';", "hint": "\n"}
{"sample_id": "dev.367", "db_id": "cre_Doc_Template_Mgt", "question": "Show all document ids and the number of paragraphs in each document. Order by document id.", "rationale": ["We need to retrieve all document IDs and the count of paragraphs associated with each document.", "To achieve this, we will use the 'Paragraphs' table since it contains the 'Document_ID' and 'Paragraph_ID'.", "We will use the COUNT() function to count the number of paragraphs for each document.", "We will group the results by 'Document_ID' to ensure we get the count for each document separately.", "Finally, we will order the results by 'Document_ID' to meet the requirement of ordering the output."], "gold_sql": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id", "source_tables": ["paragraphs"], "pred_sql": "SELECT Document_ID, COUNT(Paragraph_ID) AS Number_of_Paragraphs \nFROM Paragraphs \nGROUP BY Document_ID \nORDER BY Document_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of documents associated with each template from the 'Documents' table. The placeholder in the SELECT clause represents the unique identifier of the template, while the count function aggregates the total number of documents linked to each template.\",\n        \"virtual_table\": \"SELECT template_id ,  count(*) FROM Documents GROUP BY template_id\"\n    }\n}\n"}
{"sample_id": "dev.439", "db_id": "wta_1", "question": "Find the highest rank of losers in all matches.", "rationale": ["We need to find the highest rank of losers in all matches.", "To do this, we will join the 'matches' table with the 'rankings' table on the loser_id and player_id.", "We will group the results by loser_id to get the minimum ranking for each loser.", "Finally, we will take the minimum of these rankings to find the highest rank among all losers."], "gold_sql": "SELECT min(loser_rank) FROM matches", "source_tables": ["matches"], "pred_sql": "SELECT MIN(ranking) AS highest_rank FROM (SELECT loser_id, MIN(ranking) AS ranking FROM matches JOIN rankings ON matches.loser_id = rankings.player_id GROUP BY loser_id) AS loser_ranks;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\",\n        \"virtual_table\": \"SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name\"\n    }\n}\n"}
{"sample_id": "dev.458", "db_id": "wta_1", "question": "What are the full names of all left handed players, in order of birth date?", "rationale": ["Identify the relevant table: The 'players' table contains the information about players, including their names and handedness.", "Select the required columns: We need the full names of the players, which can be constructed by concatenating 'first_name' and 'last_name'.", "Filter the results: We only want left-handed players, so we will add a WHERE clause to filter by 'hand = 'left' '.", "Order the results: The results should be ordered by 'birth_date', so we will add an ORDER BY clause for 'birth_date'.", "Construct the final SQL query using the above steps."], "gold_sql": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date", "source_tables": ["players"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name\nFROM players\nWHERE hand = 'left'\nORDER BY birth_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\",\n        \"virtual_table\": \"SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name\"\n    }\n}\n"}
{"sample_id": "dev.464", "db_id": "wta_1", "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?", "rationale": ["Identify the relevant tables: We need data from the 'matches', 'players', and 'rankings' tables to answer the question.", "Determine the winner: The 'winner_name' is found in the 'matches' table, linked to the 'players' table via 'winner_id'.", "Count the matches won: We will count the occurrences of each winner in the 'matches' table to determine who has won the most matches.", "Get ranking points: The ranking points for each player can be found in the 'rankings' table, which is linked to the 'players' table via 'player_id'.", "Group the results: We will group the results by 'winner_name' and 'ranking_points' to aggregate the match counts for each winner.", "Order the results: We will order the results by the count of matches won in descending order to find the player with the most wins.", "Limit the results: We will limit the results to 1 to get the top winner."], "gold_sql": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["matches"], "pred_sql": "SELECT winner_name, COUNT(*) AS match_count, r.ranking_points \nFROM matches m \nJOIN players p ON m.winner_id = p.player_id \nJOIN rankings r ON p.player_id = r.player_id \nGROUP BY winner_name, r.ranking_points \nORDER BY match_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\",\n        \"virtual_table\": \"SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name\"\n    }\n}\n"}
{"sample_id": "dev.471", "db_id": "wta_1", "question": "Find the total ranking points for each player and their first name.", "rationale": ["The query needs to find the total ranking points for each player along with their first name.", "To achieve this, we will join the 'players' table with the 'rankings' table on the 'player_id' column.", "We will select the 'first_name' from the 'players' table and the sum of 'ranking_points' from the 'rankings' table.", "We will use the SUM() function to calculate the total ranking points for each player.", "Finally, we will group the results by 'first_name' to ensure we get the total points for each player individually."], "gold_sql": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "pred_sql": "SELECT SUM(ranking_points) AS total_ranking_points, T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id = T2.player_id GROUP BY T1.first_name", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\",\n        \"virtual_table\": \"SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name\"\n    }\n}\n"}
{"sample_id": "dev.479", "db_id": "wta_1", "question": "Find the total number of tours for each ranking date.", "rationale": ["The task is to find the total number of tours for each ranking date.", "We need to select the 'ranking_date' from the 'rankings' table.", "To count the number of tours for each ranking date, we will use the COUNT() function on the 'tours' column.", "We will group the results by 'ranking_date' to get the total tours for each date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(tours) AS total_tours FROM rankings GROUP BY ranking_date", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average ranking of players along with their first names. It combines data from the 'players' and 'rankings' tables, grouping the results by the players' first names to calculate the average ranking for each player.\",\n        \"virtual_table\": \"SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name\"\n    }\n}\n"}
{"sample_id": "dev.480", "db_id": "wta_1", "question": "How many total tours were there for each ranking date?", "rationale": ["Identify the relevant table: The question pertains to the number of tours for each ranking date, which is found in the 'rankings' table.", "Determine the columns needed: We need 'ranking_date' to group the results and 'tours' to count the distinct tours for each date.", "Use COUNT(DISTINCT tours): This will count the unique tours associated with each ranking date.", "Group the results by ranking_date: This will aggregate the counts for each date.", "Construct the SQL query: Combine the SELECT statement with the appropriate GROUP BY clause."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(DISTINCT tours) AS total_tours\nFROM rankings\nGROUP BY ranking_date;", "hint": "\n"}
{"sample_id": "dev.533", "db_id": "student_transcripts_tracking", "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to join the Students table with the Student_Enrolment table to get student details along with their enrolment information.", "To find students enrolled in 2 different degree programs in the same semester, we can join the Student_Enrolment table with itself (self-join) on the student_id and ensure that the degree_program_id is different but the semester_id is the same.", "Use GROUP BY to group the results by student_id and use HAVING to filter those groups to only include students who are enrolled in exactly 2 distinct degree programs."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name, s.student_id\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nJOIN Student_Enrolment se2 ON s.student_id = se2.student_id\nWHERE se.degree_program_id != se2.degree_program_id\nAND se.semester_id = se2.semester_id\nGROUP BY s.student_id\nHAVING COUNT(DISTINCT se.degree_program_id) = 2;", "hint": "\n"}
{"sample_id": "dev.536", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?", "rationale": ["Identify the relevant tables: Students, Student_Enrolment, and Degree_Programs.", "We need to select the first, middle, and last names of students, which are in the Students table.", "To find out which students are enrolled in a Bachelors program, we need to join the Students table with the Student_Enrolment table on student_id.", "Next, we join the Student_Enrolment table with the Degree_Programs table on degree_program_id to filter for Bachelors programs.", "The condition for the Bachelors program is specified in the WHERE clause using a LIKE statement to match any degree summary name that contains 'Bachelors'."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT s.first_name, s.middle_name, s.last_name \nFROM Students s \nJOIN Student_Enrolment se ON s.student_id = se.student_id \nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id \nWHERE dp.degree_summary_name LIKE '%Bachelors%';", "hint": "\n"}
{"sample_id": "dev.537", "db_id": "student_transcripts_tracking", "question": "Find the kind of program which most number of students are enrolled in?", "rationale": ["Identify the relevant tables: We need to find the degree programs and the number of students enrolled in each, so we will use the Student_Enrolment and Degree_Programs tables.", "Join the tables: We will join the Student_Enrolment table with the Degree_Programs table on the degree_program_id to associate each enrolment with its corresponding degree program.", "Count the number of students: We will use the COUNT function to count the number of student enrolment records for each degree program.", "Group the results: We will group the results by the degree program name to get the count of students for each program.", "Order the results: We will order the results in descending order based on the student count to find the program with the most students enrolled.", "Limit the results: Finally, we will limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_summary_name, COUNT(se.student_enrolment_id) AS student_count\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nGROUP BY dp.degree_summary_name\nORDER BY student_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["Identify the relevant tables: Degree_Programs and Student_Enrolment.", "We need to find the degree program with the most students enrolled, so we will join these two tables on the degree_program_id.", "Group the results by degree_program_id and degree_summary_name to count the number of students enrolled in each program.", "Use COUNT(se.student_id) to count the number of students for each program.", "Order the results in descending order based on the count of students to get the program with the most enrollments at the top.", "Limit the results to 1 to get only the program with the highest number of students."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT dp.degree_program_id, dp.degree_summary_name\nFROM Degree_Programs dp\nJOIN Student_Enrolment se ON dp.degree_program_id = se.degree_program_id\nGROUP BY dp.degree_program_id, dp.degree_summary_name\nORDER BY COUNT(se.student_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment.", "We need to count the number of enrollments for each student, so we will join the Students table with the Student_Enrolment table on the student_id.", "Select the required fields: student_id, first_name, middle_name, last_name from the Students table, and count the student_enrolment_id from the Student_Enrolment table to get the number of enrollments.", "Group the results by student_id to aggregate the count of enrollments for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to 1 to get only the top student."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT s.student_id, s.first_name, s.middle_name, s.last_name, COUNT(se.student_enrolment_id) AS number_of_enrollments\nFROM Students s\nJOIN Student_Enrolment se ON s.student_id = se.student_id\nGROUP BY s.student_id\nORDER BY number_of_enrollments DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["Identify the relevant tables: Courses and Student_Enrolment_Courses are needed to find course names and their enrollments.", "Join the Courses table with the Student_Enrolment_Courses table on the course_id to link courses with their enrollments.", "Group the results by course name to aggregate the number of enrollments for each course.", "Order the results by the count of enrollments in descending order to find the course with the most enrollments.", "Limit the results to 1 to get only the top course with the highest number of enrollments."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id = T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of course names from the 'Courses' table that are associated with student enrolments. The results are grouped by course name and ordered by the number of enrolments in descending order, allowing users to see the most popular courses. The placeholder in the LIMIT clause represents the maximum number of course names to return.\",\n        \"virtual_table\": \"SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant tables: Students and Addresses for student information and their addresses, and Student_Enrolment to check for degree program registration.", "Join the Students table with the Addresses table on the permanent_address_id to filter students based on their address.", "Use a LEFT JOIN with the Student_Enrolment table to find students who have not registered for any degree programs.", "Filter the results to include only those students whose address is in North Carolina and who have no associated degree program (i.e., se.degree_program_id IS NULL).", "Select the last names of the filtered students."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT s.last_name \nFROM Students s \nJOIN Addresses a ON s.permanent_address_id = a.address_id \nLEFT JOIN Student_Enrolment se ON s.student_id = se.student_id \nWHERE a.state_province_county = 'North Carolina' AND se.degree_program_id IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table: The 'Students' table contains the information about students, including their names and mobile phone numbers.", "Determine the columns needed: We need the 'cell_mobile_number' column for the mobile phone number of the student.", "Formulate the WHERE clause: We need to filter the results to find the student named 'Timmothy Ward'. This requires checking both the 'first_name' and 'last_name' columns.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to retrieve the desired mobile phone number."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["We need to find the address that holds the most number of students currently.", "To do this, we will join the 'Addresses' table with the 'Students' table on the current address ID.", "We will group the results by the address ID and its lines to count the number of students associated with each address.", "We will order the results by the count of students in descending order to get the address with the most students at the top.", "Finally, we will limit the results to just one address to get the one with the most students."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT a.address_id, a.line_1, a.line_2, a.line_3 \nFROM Addresses a \nJOIN Students s ON s.current_address_id = a.address_id \nGROUP BY a.address_id, a.line_1, a.line_2, a.line_3 \nORDER BY COUNT(s.student_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students from the 'Students' table who either have a permanent address in a specific country or have a specified mobile phone number. The placeholders in the WHERE clause represent the country name and the mobile phone number.\",\n        \"virtual_table\": \"select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  [PLACEHOLDER-TYPE:STRING] or t1.cell_mobile_number  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.576", "db_id": "student_transcripts_tracking", "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?", "rationale": ["Identify the relevant tables: Student_Enrolment and Degree_Programs.", "We need to find semesters that had both Masters and Bachelors students enrolled.", "Join the Student_Enrolment table with the Degree_Programs table on the degree_program_id.", "Filter the results to include only those degree programs that are either 'Masters' or 'Bachelors'.", "Group the results by semester_id to aggregate the data for each semester.", "Use HAVING clause to ensure that both degree types (Masters and Bachelors) are present in the results by counting distinct degree_summary_name and checking if it equals 2."], "gold_sql": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT DISTINCT se.semester_id\nFROM Student_Enrolment se\nJOIN Degree_Programs dp ON se.degree_program_id = dp.degree_program_id\nWHERE dp.degree_summary_name IN ('Masters', 'Bachelors')\nGROUP BY se.semester_id\nHAVING COUNT(DISTINCT dp.degree_summary_name) = 2;", "hint": "\n"}
{"sample_id": "dev.580", "db_id": "student_transcripts_tracking", "question": "What other details can you tell me about students in reverse alphabetical order?", "rationale": ["The question asks for 'other details' about students, which corresponds to the 'other_student_details' column in the Students table.", "To retrieve this information, we will select the 'other_student_details' column from the Students table.", "The question specifies that the results should be in reverse alphabetical order, which means we need to order the results by the last name and first name of the students in descending order.", "Thus, the SQL query will select 'other_student_details' from the Students table and order the results by 'last_name' and 'first_name' in descending order."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "pred_sql": "SELECT other_student_details FROM Students ORDER BY last_name DESC, first_name DESC;", "hint": "\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve information about a section, we need to select all columns from the Sections table.", "We will use a WHERE clause to filter the results to only include the section with the name 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT * FROM Sections WHERE section_name = 'h';", "hint": "\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries and their government forms.", "Determine the specific information needed: We need to count the number of countries with a government form of 'Republic'.", "Construct the SQL query: Use the COUNT function to count the rows in the 'country' table where the GovernmentForm is 'Republic'."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(*) FROM country WHERE GovernmentForm = 'Republic';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.730", "db_id": "world_1", "question": "What is the average GNP and total population in all nations whose government is US territory?", "rationale": ["Identify the required data: average GNP and total population of countries with a specific government form.", "Refer to the provided hint which indicates a virtual table for calculating average GNP and total population based on government form.", "The hint specifies to use 'US territory' as the government form in the WHERE clause.", "Construct the SQL query using the format from the hint, replacing the placeholder with 'US territory'."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT avg(GNP), sum(Population) FROM country WHERE GovernmentForm = 'US territory'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.734", "db_id": "world_1", "question": "How many type of governments are in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and regions.", "Determine the specific requirement: The question asks for the number of types of governments in Africa, which implies we need to filter countries by the African region.", "Use the DISTINCT keyword: To find the unique types of governments, we will use the DISTINCT keyword on the GovernmentForm column.", "Construct the SQL query: Combine the elements identified to form the SQL query that selects distinct government forms from the country table where the region is Africa."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Region = 'Africa';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and regions.", "Determine the specific requirement: We need to find the different forms of government in Africa.", "Use the DISTINCT keyword: This will ensure that we only get unique forms of government.", "Filter by region: We will add a WHERE clause to limit our results to countries in Africa."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Region = 'Africa';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.742", "db_id": "world_1", "question": "Which continent has the most diverse languages?", "rationale": ["We need to find out which continent has the most diverse languages, which means we need to count the number of distinct languages spoken in each continent.", "To do this, we will join the 'country' table with the 'countrylanguage' table on the country code.", "We will group the results by continent to count the distinct languages for each continent.", "We will order the results by the count of distinct languages in descending order to find the continent with the most languages.", "Finally, we will limit the results to 1 to get only the continent with the highest count of languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT T1.Continent, COUNT(DISTINCT T2.Language) AS LanguageCount \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nGROUP BY T1.Continent \nORDER BY LanguageCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.743", "db_id": "world_1", "question": "Which continent speaks the most languages?", "rationale": ["We need to find out which continent speaks the most languages.", "To do this, we will join the 'country' table with the 'countrylanguage' table on the 'CountryCode'.", "We will group the results by 'Continent' to count the distinct languages spoken in each continent.", "We will use COUNT(DISTINCT T2.Language) to get the number of unique languages per continent.", "Finally, we will order the results by the count of languages in descending order and limit the result to 1 to get the continent with the most languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT T1.Continent, COUNT(DISTINCT T2.Language) AS LanguageCount \nFROM country AS T1 \nJOIN countrylanguage AS T2 ON T1.Code = T2.CountryCode \nGROUP BY T1.Continent \nORDER BY LanguageCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.746", "db_id": "world_1", "question": "What are the names of nations speak both English and French?", "rationale": ["Identify the languages of interest: English and French.", "Use the countrylanguage table to find countries that speak English.", "Use a subquery to find countries that also speak French.", "Join the results with the country table to get the names of the countries.", "Select the distinct country names that meet both language criteria."], "gold_sql": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'French'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT cl1.CountryCode, c.Name \nFROM countrylanguage cl1 \nJOIN country c ON cl1.CountryCode = c.Code \nWHERE cl1.Language = 'English' \nAND cl1.CountryCode IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'French') \nGROUP BY cl1.CountryCode;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["Identify the tables needed: We need data from the 'country' and 'countrylanguage' tables.", "Determine the relationship: The 'country' table is linked to the 'countrylanguage' table through the 'Code' and 'CountryCode' columns.", "Filter for official languages: We need to filter the results to include only those languages that are marked as official (IsOfficial = 'T').", "Specify the languages: We are interested in countries where either 'English' or 'Dutch' is an official language.", "Select distinct country names: We want to retrieve the unique names of the countries that meet the criteria."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT DISTINCT c.Name \nFROM country c \nJOIN countrylanguage cl ON c.Code = cl.CountryCode \nWHERE cl.Language IN ('English', 'Dutch') AND cl.IsOfficial = 'T';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the requirement: We need to find the total population of countries that do not use English as an official language.", "Use the countrylanguage table to find the country codes of countries where English is an official language.", "The hint provides a virtual table that can be used to exclude countries where English is an official language.", "Construct a subquery to select CountryCode from countrylanguage where IsOfficial is 'T' and Language is 'English'.", "Use the NOT IN clause to filter out these country codes from the main query.", "In the main query, select the SUM of the Population from the country table where the Code is not in the list of country codes from the subquery."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(Population) FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE IsOfficial = 'T' AND Language = 'English')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.767", "db_id": "world_1", "question": "How many people live in countries that do not speak English?", "rationale": ["Identify the total population of countries that do not speak English.", "To find countries that do not speak English, we can use the provided virtual table hint.", "The virtual table query is: SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = 'English'. This will give us the country codes of countries that do not have English as an official language.", "Next, we need to sum the populations of these countries. We will join the country table with the city table to get the population of each country.", "The final SQL query will select the sum of the population from the country table where the country code is in the result of the virtual table query."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(c.Population) FROM country c WHERE c.Code IN (SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = 'English')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.783", "db_id": "world_1", "question": "Return the codes of countries that do not speak English and do not have Republics for governments.", "rationale": ["Identify the requirement to find country codes that do not speak English and do not have Republics for governments.", "Use the provided hint to create a subquery that selects country codes where English is spoken.", "The subquery will be: SELECT CountryCode FROM countrylanguage WHERE Language = 'English'.", "Use the EXCEPT clause to exclude these country codes from the main query.", "The main query will select from the country table where the Code is not in the results of the subquery.", "Additionally, filter the results to exclude countries with 'Republic' in their GovernmentForm using the NOT LIKE operator."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT Code FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English') AND GovernmentForm NOT LIKE '%Republic%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.784", "db_id": "world_1", "question": "Which cities are in European countries where English is not the official language?", "rationale": ["Identify the cities that are located in European countries.", "To find the relevant countries, filter the countries by continent, specifically 'Europe'.", "Next, we need to exclude countries where English is an official language.", "Using the provided hint, create a subquery that selects country codes from the countrylanguage table, excluding those where English is the official language.", "Join the city table with the country table on the CountryCode to get the city names that meet the criteria."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nWHERE country.Continent = 'Europe' \nAND country.Code IN (SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the WHERE clause represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.785", "db_id": "world_1", "question": "What are the names of cities in Europe for which English is not the official language?", "rationale": ["Identify the cities that are located in Europe by filtering the 'city' table based on the 'CountryCode' that corresponds to countries in Europe.", "Use a subquery to get the 'CountryCode' of countries in Europe from the 'country' table where the 'Continent' is 'Europe'.", "Next, we need to find the countries where English is not an official language. This can be done using the provided virtual table hint.", "The virtual table query provided allows us to select 'CountryCode' from 'countrylanguage' and exclude those where 'Language' is 'English'.", "Combine the results of the two subqueries to filter the 'city' table for cities in Europe where English is not an official language."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT Name FROM city WHERE CountryCode IN (SELECT CountryCode FROM country WHERE Continent = 'Europe') AND CountryCode IN (SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = 'English')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the country codes of countries where a specific language is spoken, excluding those countries where that language is the official language. The placeholder in the query represents the name of the language being queried.\",\n        \"virtual_table\": \"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.788", "db_id": "world_1", "question": "What are the name, independence year, and surface area of the country with the smallest population?", "rationale": ["Identify the required fields: Name, Independence Year, and Surface Area from the country table.", "Determine the condition to find the country with the smallest population, which involves using a subquery to get the minimum population from the country table.", "Construct the main query to select the desired fields from the country table where the population matches the minimum population found in the subquery."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the required fields: Name, year of independence (IndepYear), and surface area (SurfaceArea) from the country table.", "Determine the condition for selecting the country with the lowest population, which involves using a subquery to find the minimum population.", "Construct the main query to select the desired fields from the country table where the population matches the minimum population found in the subquery."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["Identify the relevant tables: We need to use the 'country' table to get country names and the 'countrylanguage' table to count the languages spoken in each country.", "Join the 'country' and 'countrylanguage' tables on the 'Code' and 'CountryCode' columns respectively to associate countries with their languages.", "Group the results by country name to aggregate the count of languages spoken in each country.", "Use the COUNT function to count the number of languages for each country.", "Filter the results using the HAVING clause to only include countries that speak more than 2 languages."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name, COUNT(cl.Language) AS LanguageCount \nFROM country AS c \nJOIN countrylanguage AS cl ON c.Code = cl.CountryCode \nGROUP BY c.Name \nHAVING COUNT(cl.Language) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of languages spoken in a specific country, ordered by the percentage of the population that speaks each language. The placeholders in the WHERE clause represent the country's name, and the LIMIT clause specifies the maximum number of languages to return.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  [PLACEHOLDER-TYPE:STRING] ORDER BY Percentage DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.796", "db_id": "world_1", "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.", "rationale": ["Identify the relevant columns needed: GovernmentForm and Population from the country table.", "Filter the countries based on the condition that their average life expectancy is greater than 72.", "Group the results by GovernmentForm to get the total population for each type of government.", "Use the SUM function to calculate the total population for each government form."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) \nFROM country \nWHERE LifeExpectancy > 72 \nGROUP BY GovernmentForm;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the columns needed: GovernmentForm and Population.", "We need to filter countries based on LifeExpectancy greater than 72.", "We will group the results by GovernmentForm to get the total population for each form of government.", "Use the SUM function to calculate the total population for each government form."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation \nFROM country \nWHERE LifeExpectancy > 72 \nGROUP BY GovernmentForm;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the average Gross National Product (GNP) and the total population of countries from the 'country' table that have a specific form of government. The placeholder in the WHERE clause represents the type of government being queried.\",\n        \"virtual_table\": \"SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.801", "db_id": "world_1", "question": "Return the names and surface areas of the 5 largest countries.", "rationale": ["Identify the required columns: 'Name' and 'SurfaceArea' from the 'country' table.", "Determine the need to sort the countries by their surface area in descending order to find the largest countries.", "Use the LIMIT clause to restrict the results to the top 5 largest countries."], "gold_sql": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5", "source_tables": ["country"], "pred_sql": "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.810", "db_id": "world_1", "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?", "rationale": ["Identify the relevant table: The 'country' table contains the necessary information about countries, including population and surface area.", "Determine the required fields: We need to calculate the total population and the average surface area of countries.", "Apply the conditions: We need to filter countries that are in the continent of 'North America' and have a surface area greater than 3000.", "Construct the SQL query: Use the SUM function to get the total population and the AVG function to get the average surface area, applying the necessary WHERE conditions."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT sum(Population) AS TotalPopulation, avg(SurfaceArea) AS AverageArea FROM country WHERE Continent = 'North America' AND SurfaceArea > 3000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total population and the maximum Gross National Product (GNP) of countries located in a specific continent. The placeholder in the WHERE clause represents the continent's name.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.811", "db_id": "world_1", "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .", "rationale": ["Identify the relevant tables: We need data from the 'country' table for population and surface area.", "Determine the conditions: We are interested in countries in North America with a surface area greater than 3000.", "Calculate total population: Use SUM() function to get the total population of the selected countries.", "Calculate average surface area: Use AVG() function to get the average surface area of the selected countries.", "Construct the SQL query: Combine the above elements into a single SQL query that selects the total population and average surface area from the 'country' table with the specified conditions."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT SUM(c.Population) AS TotalPopulation, AVG(c.SurfaceArea) AS AverageSurfaceArea \nFROM country c \nWHERE c.Continent = 'North America' AND c.SurfaceArea > 3000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that have a surface area greater than the minimum surface area of countries located in a specific continent. The placeholder in the subquery represents the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the relevant table: The 'city' table contains the population data we need.", "Determine the condition: We need to filter cities based on their population being between 160000 and 900000.", "Construct the SQL query: Use the SELECT statement to retrieve the 'Name' and 'Population' columns from the 'city' table, applying the WHERE clause to filter the results based on the specified population range."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT Name, Population FROM city WHERE Population BETWEEN 160000 AND 900000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and populations of cities from the 'city' table that have a specific language spoken, as indicated in the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name, while the placeholder in the LIMIT clause specifies the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Population DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.921", "db_id": "dog_kennels", "question": "Find the average age of the dogs who went through treatments.", "rationale": ["Identify the main goal: Calculate the average age of dogs that have received treatments.", "Determine the relevant tables: The 'Dogs' table contains the age of the dogs, and the 'Treatments' table links dogs to their treatments.", "Use a subquery to find the dog_ids of dogs that have received treatments: SELECT dog_id FROM Treatments.", "Use the IN clause to filter the Dogs table based on the dog_ids obtained from the subquery.", "Calculate the average age using the AVG function on the age column of the Dogs table."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.924", "db_id": "dog_kennels", "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .", "rationale": ["Identify the main table to query: Dogs, since we want to list dog names.", "Determine the condition: We need to find dogs whose treatment costs do not exceed 1000.", "Use a subquery to find dog_ids from the Treatments table where the cost_of_treatment is greater than 1000.", "Use the NOT IN clause to filter out those dog_ids from the Dogs table.", "Select the name column from the Dogs table for the final output."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT name FROM Dogs WHERE dog_id NOT IN ( SELECT dog_id FROM Treatments WHERE cost_of_treatment > 1000 )", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.937", "db_id": "dog_kennels", "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.", "rationale": ["We need to find the owner who spent the most on treatments for their dogs.", "To do this, we will join the Owners table with the Dogs table using the owner_id to link them.", "Next, we will join the Treatments table with the Dogs table using the dog_id to link treatments to the respective dogs.", "We will then group the results by owner_id and last_name to aggregate the treatment costs for each owner.", "Using the SUM function, we will calculate the total cost of treatments for each owner.", "Finally, we will order the results in descending order based on the total treatment costs and limit the results to 1 to get the owner who spent the most."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT O.owner_id, O.last_name \nFROM Owners AS O \nJOIN Dogs AS D ON O.owner_id = D.owner_id \nJOIN Treatments AS T ON D.dog_id = T.dog_id \nGROUP BY O.owner_id, O.last_name \nORDER BY SUM(T.cost_of_treatment) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )\"\n    }\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to find professionals who have administered treatments, so we will join the Professionals table with the Treatments table on the professional_id.", "We want to count the number of distinct treatment types each professional has administered, so we will use COUNT(DISTINCT t.treatment_type_code).", "To ensure we only get professionals who have done at least two types of treatments, we will use the HAVING clause with a condition that the count is greater than or equal to 2.", "Finally, we will select the professional_id and cell_number from the Professionals table."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT p.professional_id, p.cell_number\nFROM Professionals p\nJOIN Treatments t ON p.professional_id = t.professional_id\nGROUP BY p.professional_id\nHAVING COUNT(DISTINCT t.treatment_type_code) >= 2;", "hint": "\n"}
{"sample_id": "dev.943", "db_id": "dog_kennels", "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to find professionals who operate two or more types of treatments, so we will join the Professionals table with the Treatments table on the professional_id.", "We will group the results by professional_id to aggregate the treatment types for each professional.", "Using COUNT(DISTINCT t.treatment_type_code), we can count the number of unique treatment types each professional operates.", "We will filter the results using HAVING to include only those professionals who have two or more unique treatment types."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT p.professional_id, p.cell_number\nFROM Professionals p\nJOIN Treatments t ON p.professional_id = t.professional_id\nGROUP BY p.professional_id\nHAVING COUNT(DISTINCT t.treatment_type_code) >= 2;", "hint": "\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["Identify the tables needed: Owners and Dogs.", "Determine the fields to select: first_name and last_name from Owners, size_code from Dogs.", "Establish the relationship between the tables: Owners and Dogs are linked by owner_id.", "Construct the SQL query using a JOIN to combine the relevant fields from both tables."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT T1.first_name, T1.last_name, T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id\"\n    }\n}\n"}
{"sample_id": "dev.954", "db_id": "dog_kennels", "question": "List the names of the dogs of the rarest breed and the treatment dates of them.", "rationale": ["Identify the tables needed: Dogs, Breeds, and Treatments.", "We need to list the names of the dogs and their treatment dates, so we will select 'd.name' from Dogs and 't.date_of_treatment' from Treatments.", "Join the Dogs table with the Breeds table on 'breed_code' to get the breed information for each dog.", "Join the Dogs table with the Treatments table on 'dog_id' to get the treatment information for each dog.", "To find the rarest breed, we will use a subquery that counts the number of dogs for each breed and orders them by count in ascending order, limiting the result to the first one (the rarest breed).", "The final query will select the dog names and their treatment dates for dogs of the rarest breed."], "gold_sql": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT d.name, t.date_of_treatment \nFROM Dogs d \nJOIN Breeds b ON d.breed_code = b.breed_code \nJOIN Treatments t ON d.dog_id = t.dog_id \nWHERE b.breed_code = (SELECT breed_code \n                      FROM Breeds \n                      GROUP BY breed_code \n                      ORDER BY COUNT(*) ASC \n                      LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need the arriving date and departing date of dogs, which are in the Dogs table.", "We need to filter the dogs that have undergone treatments, which can be found in the Treatments table.", "Use a subquery to select dog_ids from the Treatments table.", "The main query will select date_arrived and date_departed from the Dogs table where the dog_id is in the list of dog_ids from the Treatments subquery."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT date_arrived, date_departed FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of dogs that have received treatments. The placeholder in the WHERE clause represents the specific dog identifiers that have undergone treatments.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.960", "db_id": "dog_kennels", "question": "List the last name of the owner owning the youngest dog.", "rationale": ["Identify the tables involved: Owners and Dogs.", "We need to join these tables on the owner_id to link owners to their dogs.", "To find the youngest dog, we need to filter the Dogs table by the minimum age.", "Use a subquery to find the minimum age of dogs in the Dogs table.", "Select the last name of the owner from the Owners table where the dog's age matches the minimum age found in the subquery."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id WHERE T2.age = (SELECT min(age) FROM Dogs)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of owners who own the oldest dog in the 'Dogs' table. The query joins the 'Owners' and 'Dogs' tables based on the owner ID and filters the results to find the maximum age of dogs, using a subquery to determine which dog is the oldest.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )\"\n    }\n}\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["We need to find distinct combinations of breed types and size types for dogs.", "The relevant tables for this query are 'Breeds', 'Sizes', and 'Dogs'.", "We will join the 'Dogs' table with the 'Breeds' table on the 'breed_code' to get the breed names.", "We will also join the 'Dogs' table with the 'Sizes' table on the 'size_code' to get the size descriptions.", "Finally, we will select distinct combinations of breed names and size descriptions."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT B.breed_name, S.size_description \nFROM Dogs AS D \nJOIN Breeds AS B ON D.breed_code = B.breed_code \nJOIN Sizes AS S ON D.size_code = S.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of dog owners along with the size code of their dogs. It combines data from the 'Owners' table and the 'Dogs' table, linking them through the owner_id. The placeholders represent the relevant fields from each table.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id\"\n    }\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["Identify the required information: professional's first name and treatment description.", "Determine the relevant tables: Professionals and Treatment_Types.", "Recognize that the Treatments table links Professionals and Treatment_Types through their respective IDs.", "Use JOIN statements to connect the tables based on the foreign key relationships.", "Select the desired columns from the joined tables."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT Professionals.first_name, Treatment_Types.treatment_type_description\nFROM Treatments\nJOIN Professionals ON Treatments.professional_id = Professionals.professional_id\nJOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code;", "hint": "\n"}
