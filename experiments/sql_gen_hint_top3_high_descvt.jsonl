{"sample_id": "train.56", "db_id": "student_assessment", "question": "which course has most number of registered students?", "rationale": ["Identify the tables involved: Students, Student_Course_Registrations, and Courses.", "Join the Students table with the Student_Course_Registrations table to link students to their course registrations.", "Join the result with the Courses table to retrieve the course names.", "Group the results by course ID to count the number of students registered for each course.", "Order the results in descending order based on the count of registered students.", "Limit the results to 1 to get the course with the most registered students."], "gold_sql": "SELECT T1.course_name FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_Id GROUP BY T1.course_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT T3.course_name, COUNT(*) AS number_of_students \nFROM Students AS T1 \nJOIN Student_Course_Registrations AS T2 ON T1.student_id = T2.student_id \nJOIN Courses AS T3 ON T2.course_id = T3.course_id \nGROUP BY T2.course_id \nORDER BY number_of_students DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.64", "db_id": "student_assessment", "question": "List the id of students who attended some courses?", "rationale": ["We need to find the IDs of students who have attended courses.", "The relevant table for attendance is 'Student_Course_Attendance', which contains the 'student_id' of students who attended courses.", "To get unique student IDs, we will use the DISTINCT keyword to avoid duplicates in the results."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.65", "db_id": "student_assessment", "question": "What are the ids of all students who have attended at least one course?", "rationale": ["We need to find the IDs of all students who have attended at least one course.", "The relevant table for attendance is 'Student_Course_Attendance', which contains the 'student_id' of students who attended courses.", "To get unique student IDs, we will use the DISTINCT keyword to avoid duplicates in our results."], "gold_sql": "SELECT student_id FROM student_course_attendance", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT DISTINCT student_id FROM Student_Course_Attendance;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.76", "db_id": "student_assessment", "question": "What is the id of the candidate who most recently accessed the course?", "rationale": ["Identify the relevant tables: Candidates, Student_Course_Attendance, and Student_Course_Registrations.", "Join the Candidates table with Student_Course_Attendance on candidate_id and student_id to link candidates with their course attendance.", "Join the result with Student_Course_Registrations to ensure we are looking at the correct course registrations.", "Order the results by date_of_attendance in descending order to get the most recent attendance first.", "Limit the results to 1 to get only the most recent candidate who accessed a course."], "gold_sql": "SELECT candidate_id FROM candidate_assessments ORDER BY assessment_date DESC LIMIT 1", "source_tables": ["candidate_assessments"], "pred_sql": "SELECT DISTINCT c.candidate_id\nFROM Candidates c\nJOIN Student_Course_Attendance sca ON c.candidate_id = sca.student_id\nJOIN Student_Course_Registrations scr ON sca.student_id = scr.student_id AND sca.course_id = scr.course_id\nORDER BY sca.date_of_attendance DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.77", "db_id": "student_assessment", "question": "What is detail of the student who registered the most number of courses?", "rationale": ["Identify the relevant tables: Students and Student_Course_Registrations.", "Join the Students table with the Student_Course_Registrations table to link students to their course registrations.", "Group the results by student_id to count the number of courses each student has registered for.", "Order the results in descending order based on the count of registered courses to find the student with the most registrations.", "Limit the results to 1 to get only the top student who registered for the most courses."], "gold_sql": "SELECT T1.student_details FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_course_registrations", "students"], "pred_sql": "SELECT S.student_id, S.student_details \nFROM Students AS S \nJOIN Student_Course_Registrations AS R ON S.student_id = R.student_id \nGROUP BY S.student_id \nORDER BY COUNT(R.course_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.82", "db_id": "student_assessment", "question": "For each course id, how many students are registered and what are the course names?", "rationale": ["Identify the tables involved: Students, Student_Course_Registrations, and Courses.", "Join the Students table with the Student_Course_Registrations table on student_id to link students to their course registrations.", "Join the result with the Courses table on course_id to retrieve course names.", "Use COUNT(*) to count the number of students registered for each course.", "Group the results by course_id to get the count for each course."], "gold_sql": "SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id", "source_tables": ["courses", "student_course_registrations", "students"], "pred_sql": "SELECT T3.course_name, COUNT(*) AS student_count \nFROM Students AS T1 \nJOIN Student_Course_Registrations AS T2 ON T1.student_id = T2.student_id \nJOIN Courses AS T3 ON T2.course_id = T3.course_id \nGROUP BY T2.course_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.90", "db_id": "student_assessment", "question": "What are the ids of the students who registered for course 301 most recently?", "rationale": ["Identify the relevant table for course registrations, which is 'Student_Course_Registrations'.", "Filter the records to only include those where the 'course_id' is '301'.", "Order the results by 'registration_date' in descending order to get the most recent registration first.", "Limit the results to 1 to get only the most recent student registration for course 301."], "gold_sql": "SELECT student_id FROM student_course_attendance WHERE course_id = 301 ORDER BY date_of_attendance DESC LIMIT 1", "source_tables": ["student_course_attendance"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = '301' ORDER BY registration_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.93", "db_id": "student_assessment", "question": "Find distinct cities of address of students?", "rationale": ["We need to find distinct cities of addresses associated with students.", "To do this, we will need to join the Addresses table with the People_Addresses table to link addresses to people.", "Next, we will join the resulting table with the Students table to filter for only those people who are students.", "Finally, we will select the distinct cities from the Addresses table."], "gold_sql": "SELECT DISTINCT T1.city FROM addresses AS T1 JOIN people_addresses AS T2 ON T1.address_id = T2.address_id JOIN students AS T3 ON T2.person_id = T3.student_id", "source_tables": ["addresses", "people_addresses", "students"], "pred_sql": "SELECT DISTINCT a.city\nFROM Addresses a\nJOIN People_Addresses pa ON a.address_id = pa.address_id\nJOIN Students s ON pa.person_id = s.student_id;", "hint": "\n"}
{"sample_id": "train.104", "db_id": "student_assessment", "question": "What are all details of the students who registered but did not attend any course?", "rationale": ["We need to find students who registered for courses but did not attend any.", "To do this, we will use a LEFT JOIN between the Students table and the Student_Course_Registrations table to get all students and their registrations.", "Next, we will perform another LEFT JOIN with the Student_Course_Attendance table to check if they attended any courses.", "In the WHERE clause, we will filter for students who have a registration (R.student_id IS NOT NULL) but do not have any attendance records (A.student_id IS NULL).", "Finally, we will select the required details from the Students table."], "gold_sql": "SELECT * FROM student_course_registrations WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)", "source_tables": ["student_course_attendance", "student_course_registrations"], "pred_sql": "SELECT S.student_id, S.student_details \nFROM Students AS S \nLEFT JOIN Student_Course_Registrations AS R ON S.student_id = R.student_id \nLEFT JOIN Student_Course_Attendance AS A ON R.student_id = A.student_id AND R.course_id = A.course_id \nWHERE R.student_id IS NOT NULL AND A.student_id IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.105", "db_id": "student_assessment", "question": "List the id of students who registered course statistics in the order of registration date.", "rationale": ["Identify the relevant tables: We need to look at the 'Students' and 'Student_Course_Registrations' tables to find students who registered for a specific course.", "Determine the course: The course we are interested in is 'Statistics'. We will need to find the course_id associated with this course from the 'Courses' table.", "Join the tables: We will join 'Student_Course_Registrations' with 'Students' to get the student_id for those who registered for the course.", "Filter by course: We will filter the registrations to only include those for the course_id that corresponds to 'Statistics'.", "Order by registration date: Finally, we will order the results by the registration_date to meet the requirement of the query."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.106", "db_id": "student_assessment", "question": "What are the ids of the students who registered course statistics by order of registration date?", "rationale": ["Identify the relevant tables: We need to look at the 'Students' and 'Student_Course_Registrations' tables to find student IDs and their course registrations.", "Filter for the specific course: We need to filter the registrations to only include those for the course 'Statistics'.", "Order by registration date: The results should be ordered by the date of registration to meet the requirement of the query.", "Construct the SQL query: Combine the above steps into a single SQL query that selects student IDs from the 'Student_Course_Registrations' table where the course ID corresponds to 'Statistics', and order the results by registration date."], "gold_sql": "SELECT T2.student_id FROM courses AS T1 JOIN student_course_registrations AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = 'statistics' ORDER BY T2.registration_date", "source_tables": ["courses", "student_course_registrations"], "pred_sql": "SELECT student_id FROM Student_Course_Registrations WHERE course_id = (SELECT course_id FROM Courses WHERE course_name = 'Statistics') ORDER BY registration_date;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of students registered for each course from the 'Courses' table. It joins the 'Students' table with the 'Student_Course_Registrations' table to link students to their course registrations, and then further joins with the 'Courses' table to retrieve the course names. The result is grouped by course ID to count the number of students per course.\",\n        \"virtual_table\": \"SELECT T3.course_name ,  count(*) FROM students AS T1 JOIN student_course_registrations AS T2 ON T1.student_id = T2.student_id JOIN courses AS T3 ON T2.course_id = T3.course_id GROUP BY T2.course_id\"\n    }\n}\n"}
{"sample_id": "train.123", "db_id": "bike_1", "question": "For each zip code, return the average mean temperature of August there.", "rationale": ["The task requires calculating the average mean temperature for each zip code specifically for the month of August.", "To achieve this, we will select the 'zip_code' and the average of 'mean_temperature_f' from the 'weather' table.", "We need to filter the records to include only those from August. In SQLite, we can extract the month from the 'date' column using the strftime function, checking if it equals '08'.", "Finally, we will group the results by 'zip_code' to get the average temperature for each zip code."], "gold_sql": "SELECT zip_code  ,  avg(mean_temperature_f) FROM weather WHERE date LIKE '8/%' GROUP BY zip_code", "source_tables": ["weather"], "pred_sql": "SELECT zip_code, AVG(mean_temperature_f) AS average_mean_temperature\nFROM weather\nWHERE strftime('%m', date) = '08'\nGROUP BY zip_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n        \"virtual_table\": \"SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.135", "db_id": "bike_1", "question": "Which bike traveled the most often in zip code 94002?", "rationale": ["Identify the relevant table for trips, which is the 'trip' table.", "Filter the trips based on the specified zip code (94002).", "Group the results by 'bike_id' to count how many times each bike was used.", "Order the results in descending order based on the count of trips to find the most frequently used bike.", "Limit the results to 1 to get only the bike that traveled the most often."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id, COUNT(*) as trip_count \nFROM trip \nWHERE zip_code = '94002' \nGROUP BY bike_id \nORDER BY trip_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n        \"virtual_table\": \"SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.136", "db_id": "bike_1", "question": "What is the id of the bike that traveled the most in 94002?", "rationale": ["Identify the relevant table for trips, which is the 'trip' table.", "Filter the trips based on the zip code '94002'.", "Order the results by the duration of the trips in descending order to find the longest trip.", "Limit the results to 1 to get the bike ID of the trip that traveled the most."], "gold_sql": "SELECT bike_id FROM trip WHERE zip_code  =  94002 GROUP BY bike_id ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["trip"], "pred_sql": "SELECT bike_id FROM trip WHERE zip_code = '94002' ORDER BY duration DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n        \"virtual_table\": \"SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.143", "db_id": "bike_1", "question": "What are the names and ids of stations that had more than 14 bikes available on average or were installed in December?", "rationale": ["Identify the requirement to find station names and ids based on two conditions: average bikes available and installation date.", "Use the 'status' table to calculate the average number of bikes available per station by grouping on 'station_id'.", "Filter the results to include only those stations where the average number of bikes available is greater than 14.", "Use the 'station' table to check for stations installed in December by checking if 'installation_date' contains '-12-'.", "Combine both conditions using an OR clause to get the final list of station ids and names."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT id, name FROM station WHERE id IN (SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available) > 14) OR installation_date LIKE '%-12-%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n        \"virtual_table\": \"SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique station IDs from the 'station' table located in a specific city. It intersects with the 'status' table to find stations that have an average number of available bikes greater than a specified threshold. The placeholders in the WHERE clause and HAVING clause represent the city name and the minimum average bikes available, respectively.\",\n        \"virtual_table\": \"SELECT id FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.144", "db_id": "bike_1", "question": "What are the names and ids of all stations that have more than 14 bikes available on average or had bikes installed in December?", "rationale": ["Identify the requirement to find station names and ids based on two conditions: average bikes available and installation date.", "Use the 'status' table to calculate the average number of bikes available per station by grouping on 'station_id'.", "Filter the results to include only those stations where the average number of bikes available is greater than 14.", "Additionally, check the 'installation_date' in the 'station' table to see if it falls in December (using a LIKE clause to match the date format).", "Combine both conditions using an OR clause to get the final list of station ids and names."], "gold_sql": "SELECT T1.name ,  T1.id FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(T2.bikes_available)  >  14 UNION SELECT name ,  id FROM station WHERE installation_date LIKE '12/%'", "source_tables": ["status", "station"], "pred_sql": "SELECT id, name FROM station WHERE id IN (SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available) > 14) OR installation_date LIKE '____-12-%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n        \"virtual_table\": \"SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique station IDs from the 'station' table located in a specific city. It intersects with the 'status' table to find stations that have an average number of available bikes greater than a specified threshold. The placeholders in the WHERE clause and HAVING clause represent the city name and the minimum average bikes available, respectively.\",\n        \"virtual_table\": \"SELECT id FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT station_id FROM status GROUP BY station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.145", "db_id": "bike_1", "question": "What is the 3 most common cloud cover rates in the region of zip code 94107?", "rationale": ["Identify the relevant table: The 'weather' table contains the cloud cover data.", "Filter by zip code: We need to focus on the region of zip code 94107.", "Group by cloud cover: To find the most common cloud cover rates, we group the results by the 'cloud_cover' column.", "Count occurrences: We order the grouped results by the count of occurrences in descending order to get the most common values.", "Limit the results: We limit the output to the top 3 most common cloud cover rates."], "gold_sql": "SELECT cloud_cover FROM weather WHERE zip_code  =  94107 GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT 3", "source_tables": ["weather"], "pred_sql": "SELECT cloud_cover FROM weather WHERE zip_code = 94107 GROUP BY cloud_cover ORDER BY COUNT(*) DESC LIMIT 3", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n        \"virtual_table\": \"SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n        \"virtual_table\": \"SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.161", "db_id": "bike_1", "question": "For each trip, return its ending station's installation date.", "rationale": ["We need to return the installation date of each trip's ending station.", "To do this, we will join the 'trip' table with the 'station' table on the 'end_station_id' from the 'trip' table and the 'id' from the 'station' table.", "The relevant columns to select are 'end_station_id' from the 'trip' table and 'installation_date' from the 'station' table."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT end_station_id, installation_date FROM station JOIN trip ON station.id = trip.end_station_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.162", "db_id": "bike_1", "question": "What is the installation date for each ending station on all the trips?", "rationale": ["Identify the relevant tables: We need information from the 'trip' table for the ending stations and the 'station' table for the installation dates.", "Join the 'trip' table with the 'station' table on the station identifiers to get the installation dates for each ending station.", "Select the end station names and their corresponding installation dates.", "Group the results by end station name to ensure we get unique entries for each station."], "gold_sql": "SELECT T1.id ,  T2.installation_date FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id", "source_tables": ["trip", "station"], "pred_sql": "SELECT end_station_name, s.installation_date \nFROM trip t \nJOIN station s ON t.end_station_id = s.id \nGROUP BY end_station_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.163", "db_id": "bike_1", "question": "Which trip started from the station with the largest dock count? Give me the trip id.", "rationale": ["Identify the station with the largest dock count by ordering the 'station' table by 'dock_count' in descending order and limiting the result to 1.", "Use the 'id' of this station to filter the 'trip' table for trips that started from this station.", "Select the 'id' of the trip that matches the start station id found in the previous step."], "gold_sql": "SELECT T1.id FROM trip AS T1 JOIN station AS T2 ON T1.start_station_id  =  T2.id ORDER BY T2.dock_count DESC LIMIT 1", "source_tables": ["trip", "station"], "pred_sql": "SELECT id FROM trip WHERE start_station_id = (SELECT id FROM station ORDER BY dock_count DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.165", "db_id": "bike_1", "question": "Count the number of trips that did not end in San Francisco city.", "rationale": ["Identify the requirement to count trips that did not end in San Francisco.", "To achieve this, we need to filter the trips based on the end station name.", "We will use a subquery to get the names of stations located in San Francisco.", "The subquery will select names from the station table where the city is 'San Francisco'.", "The main query will count all trips where the end station name is not in the list returned by the subquery."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip WHERE end_station_name NOT IN (SELECT name FROM station WHERE city = 'San Francisco')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.166", "db_id": "bike_1", "question": "How many trips did not end in San Francisco?", "rationale": ["Identify the relevant table: The 'trip' table contains information about trips, including the end station name.", "Determine the condition: We need to count trips that did not end in San Francisco.", "Construct the SQL query: Use COUNT(*) to count the number of trips where the end_station_name is not 'San Francisco'."], "gold_sql": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != 'San Francisco'", "source_tables": ["trip", "station"], "pred_sql": "SELECT COUNT(*) FROM trip WHERE end_station_name != 'San Francisco';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.167", "db_id": "bike_1", "question": "In zip code 94107, on which day neither Fog nor Rain was not observed?", "rationale": ["Identify the relevant table: The 'weather' table contains the necessary information about weather events and zip codes.", "Filter by zip code: We need to focus on the zip code 94107, so we will include a WHERE clause for this zip code.", "Exclude specific weather events: We need to find days where neither Fog nor Rain was observed. This can be done by checking the 'events' column for the absence of these terms.", "Select distinct dates: We want to know the unique days that meet the criteria, so we will use SELECT DISTINCT to get unique dates from the filtered results."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT date FROM weather WHERE zip_code = 94107 AND events NOT LIKE '%Fog%' AND events NOT LIKE '%Rain%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n        \"virtual_table\": \"SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n        \"virtual_table\": \"SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.168", "db_id": "bike_1", "question": "On which day has it neither been foggy nor rained in the zip code of 94107?", "rationale": ["We need to find days with no fog and no rain in the specified zip code (94107).", "Fog is typically indicated by a high dew point, so we can assume that a maximum dew point below a certain threshold (e.g., 0) indicates no fog.", "Rain can be identified by checking if the total precipitation is zero.", "We will select distinct dates from the weather table where the zip code is 94107, the maximum dew point is below 0, and the precipitation is zero."], "gold_sql": "SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != 'Fog' AND EVENTS != 'Rain'", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT date FROM weather WHERE zip_code = 94107 AND max_dew_point_f < 0 AND precipitation_inches = 0", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n        \"virtual_table\": \"SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n        \"virtual_table\": \"SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.183", "db_id": "bike_1", "question": "List all the cities in a decreasing order of each city's stations' highest latitude.", "rationale": ["Identify the relevant table: The 'station' table contains the necessary information about cities and their corresponding latitude coordinates.", "Select the city and the maximum latitude for each city: Use the MAX function to find the highest latitude for each city.", "Group the results by city: This is necessary to ensure that we get the maximum latitude for each unique city.", "Order the results in decreasing order of latitude: Use the ORDER BY clause to sort the results based on the highest latitude in descending order."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, MAX(lat) as highest_latitude FROM station GROUP BY city ORDER BY highest_latitude DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.184", "db_id": "bike_1", "question": "For each city, list their names in decreasing order by their highest station latitude.", "rationale": ["We need to list the names of bike stations for each city.", "To achieve this, we will select the 'city' and 'name' columns from the 'station' table.", "We want to order the results by the highest latitude of the stations, which is represented by the 'lat' column.", "The ordering should be in decreasing order, so we will use 'ORDER BY lat DESC'."], "gold_sql": "SELECT city FROM station GROUP BY city ORDER BY max(lat) DESC", "source_tables": ["station"], "pred_sql": "SELECT city, name FROM station ORDER BY lat DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.189", "db_id": "bike_1", "question": "For each station, return its longitude and the average duration of trips that started from the station.", "rationale": ["Identify the required data: longitude of each station and the average duration of trips starting from each station.", "The 'station' table contains the longitude (long) and unique identifiers (id) for each station.", "The 'trip' table contains the duration of trips and the start station identifier (start_station_id).", "To get the average duration of trips for each station, we need to join the 'station' table with the 'trip' table on the station ID.", "Use the AVG() function to calculate the average duration of trips for each station.", "Group the results by the station ID to ensure we get one result per station."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT s.long, AVG(t.duration) AS average_duration\nFROM station AS s\nJOIN trip AS t ON s.id = t.start_station_id\nGROUP BY s.id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations that have an average number of bikes available greater than a specified number, excluding those located in a specific city. The query combines data from the 'station' and 'status' tables, grouping by station ID to calculate the average bikes available, and uses placeholders for the average bike count and city name.\",\n        \"virtual_table\": \"SELECT T1.name FROM station AS T1 JOIN status AS T2 ON T1.id  =  T2.station_id GROUP BY T2.station_id HAVING avg(bikes_available)  >  [PLACEHOLDER-TYPE:NUMBER] EXCEPT SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.190", "db_id": "bike_1", "question": "For each start station id, what is its name, longitude and average duration of trips started there?", "rationale": ["Identify the relevant tables: We need data from the 'trip' table for trip durations and start station IDs, and from the 'station' table for station names and longitudes.", "Join the 'trip' table with the 'station' table on the station ID to get the necessary details about each start station.", "Select the start station ID, start station name, longitude from the 'station' table, and calculate the average duration of trips from the 'trip' table.", "Group the results by start station ID, start station name, and longitude to ensure we get one result per station with its average trip duration."], "gold_sql": "SELECT T1.name ,  T1.long ,  avg(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id GROUP BY T2.start_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT start_station_id, start_station_name, station.long, AVG(duration) AS average_duration\nFROM trip\nJOIN station ON trip.start_station_id = station.id\nGROUP BY start_station_id, start_station_name, station.long;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.192", "db_id": "bike_1", "question": "For each end station id, what is its name, latitude, and minimum duration for trips ended there?", "rationale": ["Identify the relevant tables: We need data from the 'trip' table for trip durations and end station details, and from the 'station' table for station names and latitudes.", "Select the required columns: We need the end station id, end station name, latitude (lat), and the minimum duration of trips that ended at each station.", "Join the tables: We will join the 'trip' table with the 'station' table on the condition that the end station id in the trip matches the id in the station.", "Group by end station id and name: To get the minimum duration for each end station, we will group the results by end station id and name.", "Use aggregate function: We will use the MIN() function to find the minimum duration of trips for each group."], "gold_sql": "SELECT T1.name ,  T1.lat ,  min(T2.duration) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.end_station_id GROUP BY T2.end_station_id", "source_tables": ["trip", "station"], "pred_sql": "SELECT end_station_id, end_station_name, lat, MIN(duration) AS min_duration \nFROM trip \nJOIN station ON trip.end_station_id = station.id \nGROUP BY end_station_id, end_station_name, lat;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of bike stations located in a specific city, excluding those stations that have been used as end stations for trips more than a specified number of times. The placeholders in the WHERE clause represent the city name and the count of trips.\",\n        \"virtual_table\": \"SELECT name FROM station WHERE city  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and identifiers of bike stations from which trips started, filtered by a specific start date. The results are grouped by station name and ordered by the number of trips, allowing users to see the most popular starting stations for that date. The placeholders in the WHERE clause represent the start date and the limit for the number of results returned.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of bike stations from which trips started, along with their unique identifiers. The results are filtered by a specific start date pattern, grouped by the station name, and ordered by the number of trips in descending order, limited to a specified number of results. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the date pattern and the number of results to return.\",\n        \"virtual_table\": \"SELECT start_station_name ,  start_station_id FROM trip WHERE start_date LIKE [PLACEHOLDER-TYPE:STRING] GROUP BY start_station_name ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.196", "db_id": "bike_1", "question": "What are all the different zip codes that have a maximum dew point that was always below 70?", "rationale": ["The question asks for unique zip codes with a maximum dew point always below 70.", "To find these zip codes, we can start by selecting all distinct zip codes from the weather table.", "Next, we need to exclude any zip codes that have a maximum dew point of 70 or above.", "This can be achieved using the EXCEPT clause, which will return the zip codes from the first selection that are not present in the second selection where the max_dew_point_f is 70 or more."], "gold_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  70", "source_tables": ["weather"], "pred_sql": "SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f >= 70", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n        \"virtual_table\": \"SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the cloud cover data from the 'weather' table for a specific zip code. The results are grouped by cloud cover values and ordered by the frequency of each cloud cover value, allowing users to see the most common cloud cover conditions for the specified area, limited to a certain number of results.\",\n        \"virtual_table\": \"SELECT cloud_cover FROM weather WHERE zip_code  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY cloud_cover ORDER BY COUNT (*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.205", "db_id": "bike_1", "question": "Give me the zip code where the average mean humidity is below 70 and at least 100 trips took place.", "rationale": ["We need to find zip codes where the average mean humidity is below 70 and at least 100 trips took place.", "To achieve this, we will group the weather data by zip code and calculate the average mean humidity for each zip code.", "We will also count the number of trips associated with each zip code by using a subquery that counts the trip IDs where the trip's zip code matches the weather's zip code.", "Finally, we will use the HAVING clause to filter the results to only include those zip codes where the average mean humidity is below 70 and the count of trips is at least 100."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity) < 70 AND COUNT((SELECT id FROM trip WHERE trip.zip_code = weather.zip_code)) >= 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n        \"virtual_table\": \"SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.206", "db_id": "bike_1", "question": "What are the zip codes that have an average mean humidity below 70 and had at least 100 trips come through there?", "rationale": ["We need to find zip codes with an average mean humidity below 70 and at least 100 trips.", "First, we will group the trips by zip code using GROUP BY zip_code.", "Next, we will count the number of trips for each zip code using COUNT(id) and filter those with at least 100 trips using HAVING COUNT(id) >= 100.", "Then, we will calculate the average mean humidity for each zip code by joining the trip table with the weather table on zip_code and using AVG(mean_humidity).", "Finally, we will filter the results to include only those zip codes where the average mean humidity is below 70 using HAVING AVG(mean_humidity) < 70."], "gold_sql": "SELECT zip_code FROM weather GROUP BY zip_code HAVING avg(mean_humidity)  <  70 INTERSECT SELECT zip_code FROM trip GROUP BY zip_code HAVING count(*)  >=  100", "source_tables": ["weather", "trip"], "pred_sql": "SELECT zip_code FROM trip GROUP BY zip_code HAVING COUNT(id) >= 100 AND AVG((SELECT mean_humidity FROM weather WHERE weather.zip_code = trip.zip_code)) < 70;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique zip codes from the 'weather' table that do not have any weather reports with a maximum dew point above a specified threshold. The placeholder in the query represents the maximum dew point value that is being used to filter the results.\",\n        \"virtual_table\": \"SELECT DISTINCT zip_code FROM weather EXCEPT SELECT DISTINCT zip_code FROM weather WHERE max_dew_point_f  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies unique trip IDs from the 'trip' table for users whose starting zip code corresponds to weather reports with an average mean temperature above a specified threshold. The placeholder in the HAVING clause represents the temperature limit for filtering the results.\",\n        \"virtual_table\": \"SELECT T1.id FROM trip AS T1 JOIN weather AS T2 ON T1.zip_code  =  T2.zip_code GROUP BY T2.zip_code HAVING avg(T2.mean_temperature_f)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.304", "db_id": "product_catalog", "question": "What are the attribute data types with more than 3 attribute definitions?", "rationale": ["Identify the table that contains the attribute definitions, which is 'Attribute_Definitions'.", "Determine the relevant column that contains the data types of the attributes, which is 'attribute_data_type'.", "To find data types with more than 3 definitions, we need to group the results by 'attribute_data_type'.", "Use the HAVING clause to filter groups that have a count of 'attribute_id' greater than 3."], "gold_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING count(*)  >  3", "source_tables": ["attribute_definitions"], "pred_sql": "SELECT attribute_data_type FROM Attribute_Definitions GROUP BY attribute_data_type HAVING COUNT(attribute_id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.316", "db_id": "product_catalog", "question": "Find the entry names of the catalog with the attribute that have the most entries.", "rationale": ["Identify the tables involved: Catalog_Contents for entry names and Catalog_Contents_Additional_Attributes for attributes.", "Join the Catalog_Contents table with Catalog_Contents_Additional_Attributes on catalog_entry_id to link entries with their attributes.", "Use a subquery to find the attribute_value that has the most entries by grouping by attribute_value and ordering by count in descending order, limiting the result to 1 to get the most common attribute.", "Select the catalog_entry_name from the joined tables where the attribute_value matches the most common one found in the subquery."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id = t2.catalog_entry_id WHERE t2.attribute_value = (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table provides the latest revision dates of catalogs from the 'Catalogs' table, grouped by the revision date. The placeholder in the HAVING clause represents the minimum count of catalogs that must share the same revision date.\",\n        \"virtual_table\": \"SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.317", "db_id": "product_catalog", "question": "What is the entry name of the most expensive catalog (in USD)?", "rationale": ["Identify the relevant table: The question asks for the entry name of the most expensive catalog in USD, which relates to the 'Catalog_Contents' table where prices are stored.", "Determine the price column: The price in USD is stored in the 'price_in_dollars' column of the 'Catalog_Contents' table.", "Find the maximum price: To find the most expensive catalog, we need to select the maximum value from the 'price_in_dollars' column.", "Select the entry name: We need to select the 'catalog_entry_name' from the 'Catalog_Contents' table where the price matches the maximum price found in the previous step.", "Construct the SQL query: Combine these steps into a single SQL query that retrieves the catalog entry name corresponding to the highest price."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents ORDER BY price_in_dollars DESC LIMIT 1", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE price_in_dollars = (SELECT MAX(price_in_dollars) FROM Catalog_Contents)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.330", "db_id": "product_catalog", "question": "What are the names of catalog entries with level number 8?", "rationale": ["Identify the relevant table: The question asks for catalog entries, which are found in the 'Catalog_Contents' table.", "Determine the filtering criteria: The level number specified is '8', which corresponds to the 'catalog_level_number' column in the 'Catalog_Contents' table.", "Construct the SQL query: We need to select the 'catalog_entry_name' from 'Catalog_Contents' where 'catalog_level_number' equals '8'."], "gold_sql": "SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.catalog_level_number  =  '8'", "source_tables": ["catalog_contents", "catalog_contents_additional_attributes"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE catalog_level_number = '8'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.331", "db_id": "product_catalog", "question": "Find the names of the products with length smaller than 3 or height greater than 5.", "rationale": ["Identify the table that contains product information, which is the Catalog_Contents table.", "Determine the relevant columns needed for the query: catalog_entry_name for product names, length for the length condition, and height for the height condition.", "Construct the SQL SELECT statement to retrieve catalog_entry_name from Catalog_Contents.", "Add a WHERE clause to filter products based on the conditions: length smaller than 3 or height greater than 5."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name \nFROM Catalog_Contents \nWHERE length < 3 OR height > 5;", "hint": "\n"}
{"sample_id": "train.332", "db_id": "product_catalog", "question": "Which catalog contents have length below 3 or above 5? Find the catalog entry names.", "rationale": ["Identify the relevant table: The question asks about catalog contents, which are stored in the 'Catalog_Contents' table.", "Determine the columns needed: We need the 'catalog_entry_name' and the 'length' of the catalog contents.", "Formulate the condition: The question specifies that we want entries with a length below 3 or above 5.", "Construct the SQL query: Using a SELECT statement to retrieve 'catalog_entry_name' from 'Catalog_Contents' where the length condition is met."], "gold_sql": "SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5", "source_tables": ["catalog_contents"], "pred_sql": "SELECT catalog_entry_name FROM Catalog_Contents WHERE length < 3 OR length > 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table provides the latest revision dates of catalogs from the 'Catalogs' table, grouped by the revision date. The placeholder in the HAVING clause represents the minimum count of catalogs that must share the same revision date.\",\n        \"virtual_table\": \"SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.338", "db_id": "product_catalog", "question": "On which days more than one revisions were made on catalogs.", "rationale": ["Identify the relevant table: The 'Catalogs' table contains the revision dates of catalogs.", "Group by the revision date: We need to group the results by 'date_of_latest_revision' to count how many catalogs share the same revision date.", "Count the number of catalogs: Use the COUNT function to count the number of catalogs for each revision date.", "Filter for more than one revision: Use the HAVING clause to filter the results where the count of catalogs is greater than 1."], "gold_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  1", "source_tables": ["catalogs"], "pred_sql": "SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*) > 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table provides the latest revision dates of catalogs from the 'Catalogs' table, grouped by the revision date. The placeholder in the HAVING clause represents the minimum count of catalogs that must share the same revision date.\",\n        \"virtual_table\": \"SELECT date_of_latest_revision FROM Catalogs GROUP BY date_of_latest_revision HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of catalog entries from the 'Catalog_Contents' table that have a specific attribute value. The query joins the 'Catalog_Contents' table with the 'Catalog_Contents_Additional_Attributes' table to filter entries based on the most common attribute value, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT t1.catalog_entry_name FROM Catalog_Contents AS t1 JOIN Catalog_Contents_Additional_Attributes AS t2 ON t1.catalog_entry_id  =  t2.catalog_entry_id WHERE t2.attribute_value  =  (SELECT attribute_value FROM Catalog_Contents_Additional_Attributes GROUP BY attribute_value ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.388", "db_id": "flight_1", "question": "What are the origins of all flights that are headed to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains information about flight origins and destinations.", "Determine the required information: We need to find the origins of flights that are headed to Honolulu.", "Construct the SQL query: Use a SELECT statement to retrieve the 'origin' column from the 'flight' table where the 'destination' is 'Honolulu'."], "gold_sql": "SELECT origin FROM Flight WHERE destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT origin FROM flight WHERE destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\",\n        \"virtual_table\": \"SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.390", "db_id": "flight_1", "question": "What are the departure and arrival dates of all flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the information about flights, including departure and arrival dates.", "Determine the required columns: We need the 'departure_date' and 'arrival_date' for the flights.", "Specify the conditions: We want flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Using the SELECT statement to retrieve the specified columns from the 'flight' table with the appropriate WHERE clause."], "gold_sql": "SELECT departure_date ,  arrival_date FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT departure_date, arrival_date FROM flight WHERE origin = 'LA' AND destination = 'Honolulu';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\",\n        \"virtual_table\": \"SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.394", "db_id": "flight_1", "question": "What is the average price for flights from LA to Honolulu?", "rationale": ["Identify the relevant table: The 'flight' table contains the necessary information about flights, including their prices and origins.", "Determine the required calculation: We need to calculate the average price of flights, which can be done using the AVG() function in SQL.", "Specify the conditions: We need to filter the results to only include flights that originate from 'LA' and have 'Honolulu' as their destination.", "Construct the SQL query: Using the identified table, calculation, and conditions, we can construct the SQL query to find the average price for flights from LA to Honolulu."], "gold_sql": "SELECT avg(price) FROM Flight WHERE origin  =  'Los Angeles' AND destination  =  'Honolulu'", "source_tables": ["flight"], "pred_sql": "SELECT avg(price) FROM flight WHERE origin = 'LA' AND destination = 'Honolulu'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average distance and average price of flights originating from a specific location. The placeholder in the WHERE clause represents the origin of the flights.\",\n        \"virtual_table\": \"SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.415", "db_id": "flight_1", "question": "Show aircraft names and number of flights for each aircraft.", "rationale": ["Identify the tables needed: We need data from the 'flight' table to count the number of flights and the 'aircraft' table to get the names of the aircraft.", "Join the 'flight' table with the 'aircraft' table on the aircraft ID (aid) to associate each flight with its corresponding aircraft name.", "Use COUNT() function to count the number of flights (flno) for each aircraft.", "Group the results by aircraft ID (aid) to get the count of flights for each aircraft.", "Select the aircraft name and the count of flights in the final output."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT T2.name, COUNT(T1.flno) AS number_of_flights \nFROM flight AS T1 \nJOIN aircraft AS T2 ON T1.aid = T2.aid \nGROUP BY T2.aid;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.416", "db_id": "flight_1", "question": "What is the name of each aircraft and how many flights does each one complete?", "rationale": ["Identify the tables needed: 'aircraft' for aircraft names and 'flight' for counting flights.", "Use a LEFT JOIN to include all aircraft, even those with no flights.", "Count the number of flights associated with each aircraft using COUNT(flight.flno).", "Group the results by aircraft ID to get the count for each aircraft.", "Select the aircraft name and the count of flights as the final output."], "gold_sql": "SELECT T2.name ,  count(*) FROM Flight AS T1 JOIN Aircraft AS T2 ON T1.aid  =  T2.aid GROUP BY T1.aid", "source_tables": ["aircraft", "flight"], "pred_sql": "SELECT aircraft.name, COUNT(flight.flno) AS flight_count FROM aircraft LEFT JOIN flight ON aircraft.aid = flight.aid GROUP BY aircraft.aid;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.430", "db_id": "flight_1", "question": "What are the names of all employees who are not certified to fly Boeing 737-800s?", "rationale": ["Identify the main requirement: to find names of employees not certified to fly a specific aircraft model (Boeing 737-800).", "Use the EXCEPT clause to find employees who are not certified for the specified aircraft.", "The first part of the query selects all employee names from the employee table.", "The second part of the query selects names of employees who are certified to fly the Boeing 737-800 by joining the employee, certificate, and aircraft tables.", "In the second part, filter the results where the aircraft name is 'Boeing 737-800'.", "Combine both parts using EXCEPT to get the final result of employees not certified for that aircraft."], "gold_sql": "SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  'Boeing 737-800'", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT name FROM employee EXCEPT SELECT T1.name FROM employee AS T1 JOIN certificate AS T2 ON T1.eid = T2.eid JOIN aircraft AS T3 ON T3.aid = T2.aid WHERE T3.name = 'Boeing 737-800'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\",\n        \"virtual_table\": \"SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.431", "db_id": "flight_1", "question": "Show the name of aircraft which fewest people have its certificate.", "rationale": ["We need to find the aircraft with the fewest number of certifications.", "To do this, we will join the 'certificate' table with the 'aircraft' table on the aircraft ID (aid).", "We will group the results by the aircraft ID to count the number of certifications for each aircraft.", "Next, we will order the results by the count of certifications in ascending order to get the aircraft with the fewest certifications at the top.", "Finally, we will limit the results to just one entry to get the name of the aircraft with the fewest certifications."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT T2.name FROM certificate AS T1 JOIN aircraft AS T2 ON T2.aid = T1.aid GROUP BY T2.aid ORDER BY COUNT(T1.eid) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\",\n        \"virtual_table\": \"SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.432", "db_id": "flight_1", "question": "What are the names of the aircraft that the least people are certified to fly?", "rationale": ["Identify the tables involved: We need to find aircraft names and their certifications, so we will use the 'aircraft' and 'certificate' tables.", "Join the 'certificate' table with the 'aircraft' table on the aircraft ID (aid) to get the names of the aircraft that have certifications.", "Group the results by aircraft ID to count how many employees are certified for each aircraft.", "Order the results by the count of certifications in ascending order to find the aircraft with the least certifications.", "Limit the results to 1 to get only the aircraft with the least number of certified employees."], "gold_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["aircraft", "certificate"], "pred_sql": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid = T1.aid GROUP BY T2.aid ORDER BY COUNT(T1.eid) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of employees from the 'Employee' table who do not hold a certificate for a specific aircraft model. The placeholder in the query represents the name of the aircraft model.\",\n        \"virtual_table\": \"SELECT name FROM Employee EXCEPT SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.438", "db_id": "flight_1", "question": "What is the salaray and name of the employee with the most certificates to fly planes more than 5000?", "rationale": ["Identify the employees who hold certificates for aircraft that can travel more than 5000 miles.", "Use the provided virtual table structure to create a subquery that counts the number of certificates each employee has for aircraft with a distance greater than 5000.", "Group the results by employee ID and order them by the count of certificates in descending order, limiting the results to the top employee.", "Join this result with the Employee table to get the names and salaries of the employees.", "Select the name and salary of the employee with the most certificates."], "gold_sql": "SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  5000 GROUP BY T1.eid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee", "certificate", "aircraft"], "pred_sql": "SELECT T1.name, E.salary FROM (SELECT T1.eid, COUNT(*) as cert_count FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid = T1.aid WHERE T2.distance > 5000 GROUP BY T1.eid ORDER BY cert_count DESC LIMIT 1) AS C JOIN Employee AS E ON C.eid = E.eid;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of employees who hold certificates for aircraft that can travel a distance greater than a specified value. The results are grouped by employee ID and ordered by the number of certificates held, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM Employee AS T1 JOIN Certificate AS T2 ON T1.eid  =  T2.eid JOIN Aircraft AS T3 ON T3.aid  =  T2.aid WHERE T3.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.eid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of aircraft that have been certified by employees, filtered by the maximum distance the aircraft can travel. The results are grouped by aircraft ID and ordered based on the count of certifications that meet a specified threshold.\",\n        \"virtual_table\": \"SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid WHERE T2.distance  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.aid ORDER BY count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.448", "db_id": "allergy_1", "question": "What are all the different food allergies?", "rationale": ["The user wants to know all the different food allergies.", "To get the list of different allergies, we need to select the 'Allergy' column from the 'Allergy_Type' table.", "Using DISTINCT ensures that we only get unique allergy names, avoiding duplicates."], "gold_sql": "SELECT DISTINCT allergy FROM Allergy_type WHERE allergytype  =  'food'", "source_tables": ["allergy_type"], "pred_sql": "SELECT DISTINCT Allergy FROM Allergy_Type", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.452", "db_id": "allergy_1", "question": "How many animal type allergies exist?", "rationale": ["Identify the relevant table: Allergy_Type contains the allergy names and their types.", "We need to count the distinct allergies that fall under the category of 'Animal'.", "Use the COUNT function to count distinct values in the Allergy column.", "Filter the results by specifying the condition that AllergyType must be 'Animal'."], "gold_sql": "SELECT count(*) FROM Allergy_type WHERE allergytype  =  'animal'", "source_tables": ["allergy_type"], "pred_sql": "SELECT COUNT(DISTINCT Allergy) FROM Allergy_Type WHERE AllergyType = 'Animal';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.455", "db_id": "allergy_1", "question": "Which allergy type has most number of allergies?", "rationale": ["Identify the relevant tables: Allergy_Type and Has_Allergy are needed to find the allergy types and their counts.", "Join the Allergy_Type table with the Has_Allergy table on the Allergy column to associate allergies with their types.", "Group the results by AllergyType to count how many allergies belong to each type.", "Use COUNT(Allergy) to count the number of allergies for each type.", "Order the results in descending order based on the count of allergies to find the type with the most allergies.", "Limit the results to 1 to get only the allergy type with the highest count."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(Allergy) AS AllergyCount FROM Allergy_Type JOIN Has_Allergy ON Allergy_Type.Allergy = Has_Allergy.Allergy GROUP BY AllergyType ORDER BY AllergyCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.458", "db_id": "allergy_1", "question": "Which allergy type is the least common?", "rationale": ["Identify the tables involved: We need to look at the 'Has_Allergy' table to see which allergies students have and the 'Allergy_Type' table to categorize these allergies.", "Join the two tables on the common column 'Allergy' to get the allergy types associated with each student.", "Group the results by 'AllergyType' to count how many students have each type of allergy.", "Use COUNT(*) to count the number of occurrences for each allergy type.", "Order the results in ascending order based on the count to find the least common allergy type.", "Limit the results to 1 to get only the least common allergy type."], "gold_sql": "SELECT allergytype FROM Allergy_type GROUP BY allergytype ORDER BY count(*) ASC LIMIT 1", "source_tables": ["allergy_type"], "pred_sql": "SELECT AllergyType, COUNT(*) AS AllergyCount FROM Has_Allergy AS HA JOIN Allergy_Type AS AT ON HA.Allergy = AT.Allergy GROUP BY AllergyType ORDER BY AllergyCount ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.462", "db_id": "allergy_1", "question": "What are the full names of all students", "rationale": ["Identify the table that contains student names, which is the 'Student' table.", "To get the full names, we need to concatenate the 'Fname' and 'LName' columns.", "Use the SQL SELECT statement to retrieve the concatenated names from the 'Student' table."], "gold_sql": "SELECT Fname ,  Lname FROM Student", "source_tables": ["student"], "pred_sql": "SELECT Fname || ' ' || LName AS FullName FROM Student;", "hint": "\n"}
{"sample_id": "train.472", "db_id": "allergy_1", "question": "What are the student ids for all male students?", "rationale": ["Identify the table that contains student information, which is the 'Student' table.", "Determine the relevant column for filtering male students, which is the 'Sex' column.", "Construct a SQL SELECT statement to retrieve the 'StuID' of students where 'Sex' is equal to 'Male'."], "gold_sql": "SELECT StuID FROM Student WHERE Sex  =  'M'", "source_tables": ["student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male';", "hint": "\n"}
{"sample_id": "train.492", "db_id": "allergy_1", "question": "What is the largest major?", "rationale": ["Identify the table that contains the major information, which is the 'Student' table.", "To find the largest major, we need to count how many students are in each major.", "We will use the COUNT function to count the number of students for each major.", "We will group the results by the 'Major' column to get the count for each major.", "To find the largest major, we will order the results in descending order based on the count of students.", "Finally, we will limit the results to 1 to get only the largest major."], "gold_sql": "SELECT major FROM Student GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major FROM Student GROUP BY Major ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.502", "db_id": "allergy_1", "question": "Give the advisor with the most students.", "rationale": ["Identify the relevant table: The 'Student' table contains the 'Advisor' and 'StuID' columns.", "Count the number of students for each advisor: Use COUNT(StuID) to count the number of students associated with each advisor.", "Group the results by advisor: Use GROUP BY Advisor to aggregate the student counts for each advisor.", "Order the results to find the advisor with the most students: Use ORDER BY StudentCount DESC to sort the advisors by their student count in descending order.", "Limit the results to only one advisor: Use LIMIT 1 to get only the advisor with the highest count."], "gold_sql": "SELECT advisor FROM Student GROUP BY advisor ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Advisor, COUNT(StuID) AS StudentCount\nFROM Student\nGROUP BY Advisor\nORDER BY StudentCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.503", "db_id": "allergy_1", "question": "How many students have cat allergies?", "rationale": ["Identify the relevant table: We need to find students with cat allergies, so we will focus on the Has_Allergy table.", "Determine the condition: We are specifically looking for records where the Allergy column matches 'cat'.", "Count the number of records: We will use the COUNT function to count how many students have this allergy."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT count(*) FROM Has_Allergy WHERE Allergy = 'cat';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.504", "db_id": "allergy_1", "question": "How many students are affected by cat allergies?", "rationale": ["Identify the main goal: Count the number of students affected by cat allergies.", "Determine the relevant tables: We need to use the 'Student' table to get student information and the 'Has_Allergy' table to find students with specific allergies.", "Join the 'Has_Allergy' table with the 'Allergy_Type' table to filter for cat allergies.", "Use a subquery to find all student IDs (StuID) that have a cat allergy.", "Count the number of unique student IDs from the 'Student' table that match the IDs from the subquery."], "gold_sql": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  'Cat'", "source_tables": ["has_allergy"], "pred_sql": "SELECT count(*) FROM Student WHERE StuID IN ( SELECT StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.510", "db_id": "allergy_1", "question": "How many students who are female are allergic to milk or eggs?", "rationale": ["Identify the target group: female students.", "Count the number of female students who have specific allergies (milk or eggs).", "Use a subquery to find students with the specified allergies by joining the Has_Allergy and Allergy_Type tables.", "Filter the results based on the gender of the students in the main query."], "gold_sql": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  'F' AND T1.allergy  =  'Milk' OR T1.allergy  =  'Eggs'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT count(*) FROM Student WHERE Sex = 'Female' AND StuID IN (SELECT StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType IN ('Milk', 'Eggs'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.514", "db_id": "allergy_1", "question": "Which allergy is the most common?", "rationale": ["To find the most common allergy, we need to count the occurrences of each allergy in the Has_Allergy table.", "We will use the COUNT function to count how many times each allergy appears.", "We will group the results by the Allergy column to get the count for each unique allergy.", "To determine which allergy is the most common, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one entry to get the most common allergy."], "gold_sql": "SELECT Allergy FROM Has_allergy GROUP BY Allergy ORDER BY count(*) DESC LIMIT 1", "source_tables": ["has_allergy"], "pred_sql": "SELECT Allergy, COUNT(*) as AllergyCount FROM Has_Allergy GROUP BY Allergy ORDER BY AllergyCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.519", "db_id": "allergy_1", "question": "Find the last name and age of the student who has allergy to both milk and cat.", "rationale": ["Identify the tables needed: We need to retrieve student information from the Student table and allergy information from the Has_Allergy and Allergy_Type tables.", "Determine the required fields: We need the last name (LName) and age of the student.", "Establish the relationship: We will use the StuID to link the Student table with the Has_Allergy table, which in turn links to the Allergy_Type table.", "Filter for students with specific allergies: We need to find students who have both 'milk' and 'cat' allergies. This can be done using an INTERSECT operation to find common StuIDs from two separate queries for each allergy.", "Construct the SQL query: The final query selects LName and Age from the Student table where the StuID is in the result of the INTERSECT query."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT LName, Age FROM Student WHERE StuID IN (SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'milk' INTERSECT SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.520", "db_id": "allergy_1", "question": "What are the last names and ages of the students who are allergic to milk and cat?", "rationale": ["Identify the relevant tables: Student, Has_Allergy, and Allergy_Type.", "We need to find students who have specific allergies (milk and cat).", "Use the Has_Allergy table to find students with these allergies by their StuID.", "Join the Has_Allergy table with the Allergy_Type table to filter by allergy names (milk and cat).", "Use INTERSECT to ensure we get students who have both allergies.", "Select the last names and ages of these students from the Student table using their StuID."], "gold_sql": "SELECT lname ,  age FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' INTERSECT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT LName, Age FROM Student WHERE StuID IN (SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'milk' INTERSECT SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.Allergy = 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.523", "db_id": "allergy_1", "question": "Find the first name and gender of the student who has allergy to milk but not cat.", "rationale": ["Identify the relevant tables: We need to retrieve data from the Student table and filter based on allergies from the Has_Allergy table.", "We want to find students who have an allergy to milk. This requires a subquery that selects StuID from Has_Allergy where Allergy is 'milk'.", "We also want to exclude students who have an allergy to cat. This requires another subquery that selects StuID from Has_Allergy where Allergy is 'cat'.", "Combine these conditions using the IN and NOT IN clauses in the main query to filter the students accordingly.", "Finally, select the first name (Fname) and gender (Sex) of the students who meet these criteria."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'milk') AND StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.524", "db_id": "allergy_1", "question": "What are the first name and gender of the students who have allergy to milk but can put up with cats?", "rationale": ["Identify the required fields: first name (Fname) and gender (Sex) of students.", "Filter students who have an allergy to milk by checking the Has_Allergy table for 'milk'.", "Also, filter out students who have an allergy to cats by checking the Has_Allergy table for 'cats'.", "Combine these conditions using the IN and NOT IN clauses to get the desired results."], "gold_sql": "SELECT fname ,  sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  'Milk' EXCEPT SELECT StuID FROM Has_allergy WHERE Allergy  =  'Cat')", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT Fname, Sex FROM Student WHERE StuID IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'milk') AND StuID NOT IN (SELECT StuID FROM Has_Allergy WHERE Allergy = 'cats')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being checked against the students' allergies.\",\n        \"virtual_table\": \"SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.525", "db_id": "allergy_1", "question": "Find the average age of the students who have allergies with food and animal types.", "rationale": ["Identify the goal: Calculate the average age of students with specific allergy types (food and animal).", "Use the Student table to access student ages.", "Join the Has_Allergy table with the Allergy_Type table to filter students based on their allergies.", "Use the INTERSECT operator to find students who have both food and animal allergies.", "Select the average age from the Student table where the student IDs match those found in the previous step."], "gold_sql": "SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food' INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'animal')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT avg(Age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'food' INTERSECT SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'animal')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the types of allergies to exclude.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.528", "db_id": "allergy_1", "question": "What is the full name of each student who is not allergic to any type of food.", "rationale": ["Identify the requirement: We need the full names of students who are not allergic to any type of food.", "Understand the schema: We have three tables - Student, Has_Allergy, and Allergy_Type.", "We need to filter students based on their allergies, specifically those who do not have any food allergies.", "Using the provided hint, we can see that we can create a subquery that selects student IDs from Has_Allergy where the allergy type is 'Food'.", "The main query will select the first and last names from the Student table where the student ID is not in the list of IDs returned by the subquery.", "Construct the SQL query using the identified tables and conditions."], "gold_sql": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT Fname, LName FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_Allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.AllergyType = 'Food')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being checked against the students' allergies.\",\n        \"virtual_table\": \"SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of students from the 'Student' table who do not have a specific type of allergy. The placeholder in the subquery represents the allergy type that is being filtered out.\",\n        \"virtual_table\": \"SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.530", "db_id": "allergy_1", "question": "How many male students (sex is 'M') are allergic to any type of food?", "rationale": ["Identify the relevant tables: Student, Has_Allergy, and Allergy_Type.", "We need to count the number of male students (sex = 'M').", "We need to check if these students have any type of food allergy.", "Join the Has_Allergy table with the Allergy_Type table to filter allergies by type.", "Use a subquery to find students with food allergies and count them in the main query."], "gold_sql": "SELECT count(*) FROM Student WHERE sex  =  'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  'food')", "source_tables": ["has_allergy", "allergy_type", "student"], "pred_sql": "SELECT count(*) FROM Student WHERE sex = 'M' AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy = T2.Allergy WHERE T2.allergytype = 'Food')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are of a specific gender and have a particular type of allergy. The placeholders in the query represent the gender of the students and the type of allergy they have.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND StuID IN (SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the number of students from the 'Student' table who are older than a specified age and do not have allergies of certain types. The placeholders in the query represent the age limit and the allergy types to be excluded.\",\n        \"virtual_table\": \"SELECT count(*) FROM Student WHERE age  >  [PLACEHOLDER-TYPE:NUMBER] AND StuID NOT IN ( SELECT StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] OR T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.531", "db_id": "allergy_1", "question": "Find the different first names and cities of the students who have allergy to milk or cat.", "rationale": ["Identify the tables needed: We need data from the Student and Has_Allergy tables.", "We want to find students with specific allergies (milk or cat), so we will join the Has_Allergy table with the Student table on StuID.", "We need to select distinct first names and city codes of these students, so we will use SELECT DISTINCT to avoid duplicates.", "The WHERE clause will filter the allergies to only include 'milk' or 'cat'.", "Construct the SQL query using the identified tables, joins, and conditions."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT S.Fname, S.city_code \nFROM Student AS S \nJOIN Has_Allergy AS HA ON S.StuID = HA.StuID \nWHERE HA.Allergy IN ('milk', 'cat');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being checked against the students' allergies.\",\n        \"virtual_table\": \"SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.532", "db_id": "allergy_1", "question": "What are the distinct first names and cities of the students who have allergy either to milk or to cat?", "rationale": ["Identify the tables needed: We need to get student information (first names and city codes) and their allergies, so we will use the Student and Has_Allergy tables.", "We need to join the Student table with the Has_Allergy table on the StuID to link students with their allergies.", "We want distinct first names and cities, so we will use SELECT DISTINCT to avoid duplicate entries.", "The WHERE clause will filter the results to include only those students who have allergies to either 'milk' or 'cat'.", "Finally, we will select the first names and city codes from the joined tables."], "gold_sql": "SELECT DISTINCT T1.fname ,  T1.city_code FROM Student AS T1 JOIN Has_Allergy AS T2 ON T1.stuid  =  T2.stuid WHERE T2.Allergy  =  'Milk' OR T2.Allergy  =  'Cat'", "source_tables": ["has_allergy", "student"], "pred_sql": "SELECT DISTINCT T3.Fname, T3.city_code FROM Student AS T3 JOIN Has_Allergy AS T2 ON T3.StuID = T2.StuID WHERE T2.Allergy IN ('milk', 'cat')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of allergies and their types for students based on their first name. The placeholders in the WHERE clause allow for filtering by a specific student's first name.\",\n        \"virtual_table\": \"SELECT T1.Allergy ,  T1.AllergyType FROM Allergy_type AS T1 JOIN Has_allergy AS T2 ON T1.Allergy  =  T2.Allergy JOIN Student AS T3 ON T3.StuID  =  T2.StuID WHERE T3.Fname  =  [PLACEHOLDER-TYPE:STRING] ORDER BY T1.Allergy\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table calculates the average age of students who have two specific types of allergies. The placeholders in the query represent the categories of allergies that the students have, allowing for flexible input to filter the results based on different allergy types.\",\n        \"virtual_table\": \"SELECT avg(age) FROM Student WHERE StuID IN ( SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first names and majors of students from the 'Student' table who do not have a specific allergy. The placeholder in the subquery represents the name of the allergy that is being checked against the students' allergies.\",\n        \"virtual_table\": \"SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.542", "db_id": "store_1", "question": "What are the names of the countries and average invoice size of the top countries by size?", "rationale": ["We need to find the names of the countries and the average invoice size for each country.", "To do this, we will select the 'billing_country' from the 'invoices' table.", "We will calculate the average of the 'total' column, which represents the invoice size, using the AVG() function.", "We will group the results by 'billing_country' to get the average for each country.", "Finally, we will order the results by the average invoice size in descending order to get the top countries by size."], "gold_sql": "SELECT billing_country ,  AVG(total) FROM invoices GROUP BY billing_country ORDER BY AVG(total) DESC LIMIT 10;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_country, AVG(total) AS average_invoice_size\nFROM invoices\nGROUP BY billing_country\nORDER BY average_invoice_size DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.564", "db_id": "store_1", "question": "How many invoices were billed from each state?", "rationale": ["We need to count the number of invoices for each state.", "The relevant table for this information is the 'invoices' table, which contains the 'billing_state' and 'id' of each invoice.", "To get the count of invoices per state, we will use the COUNT() function and group the results by 'billing_state'.", "The final SQL query will select the 'billing_state' and the count of invoices, grouping by 'billing_state' to aggregate the counts."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) AS invoice_count FROM invoices GROUP BY billing_state;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.566", "db_id": "store_1", "question": "What are the states with the most invoices?", "rationale": ["Identify the relevant table: The 'invoices' table contains the billing information including states.", "Determine the required information: We need to count the number of invoices per state.", "Group the results: Use GROUP BY to aggregate the count of invoices for each state.", "Order the results: Use ORDER BY to sort the states by the count of invoices in descending order."], "gold_sql": "SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  'USA' GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT 1;", "source_tables": ["invoices"], "pred_sql": "SELECT billing_state, COUNT(*) FROM invoices GROUP BY billing_state ORDER BY COUNT(*) DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.568", "db_id": "store_1", "question": "What is the number of invoices and total money billed in them from CA?", "rationale": ["Identify the relevant table: The 'invoices' table contains the necessary information about invoices and their total amounts.", "Determine the required fields: We need to count the number of invoices and sum the total amount billed, which corresponds to COUNT(*) and SUM(total) respectively.", "Apply the filter: We need to filter the results to only include invoices from California (CA), which is done using the WHERE clause.", "Construct the SQL query: Combine the selected fields and the filter into a complete SQL query."], "gold_sql": "SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  'CA';", "source_tables": ["invoices"], "pred_sql": "SELECT COUNT(*) AS number_of_invoices, SUM(total) AS total_billed FROM invoices WHERE billing_state = 'CA';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.575", "db_id": "store_1", "question": "What is Astrid Gruber's email and phone number?", "rationale": ["Identify the relevant table: The 'employees' table contains the information needed (email and phone number).", "Determine the specific employee: The question specifies 'Astrid Gruber', so we need to filter the results based on the first name 'Astrid' and last name 'Gruber'.", "Construct the SQL query: Using the SELECT statement to retrieve the 'email' and 'phone' columns from the 'employees' table, and applying a WHERE clause to filter by the specified first and last names."], "gold_sql": "SELECT email ,  phone FROM customers WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "source_tables": ["customers"], "pred_sql": "SELECT email, phone FROM employees WHERE first_name = 'Astrid' AND last_name = 'Gruber';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles, phone numbers, and hire dates of employees from the 'employees' table who have a specific first and last name. The placeholders in the WHERE clause represent the first and last names of the employee.\",\n        \"virtual_table\": \"SELECT title ,  phone ,  hire_date FROM employees WHERE first_name = [PLACEHOLDER-TYPE:STRING] AND last_name = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.580", "db_id": "store_1", "question": "How many customers are from California?", "rationale": ["Identify the relevant table: The question asks about customers, so we will use the 'customers' table.", "Determine the condition: We need to count customers from California, which means we will filter by the 'state' column.", "Construct the SQL query: We will use the COUNT function to count the number of customers where the state is 'California'."], "gold_sql": "SELECT count(*) FROM customers WHERE state = 'CA';", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) FROM customers WHERE state = 'California';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.593", "db_id": "store_1", "question": "Find the full name of employee who supported the most number of customers.", "rationale": ["Identify the relevant tables: employees and customers.", "Join the employees table with the customers table on the support representative ID.", "Group the results by employee ID to count how many customers each employee supports.", "Order the results in descending order based on the count of customers supported.", "Limit the results to only the top employee who supports the most customers."], "gold_sql": "SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employees", "customers"], "pred_sql": "SELECT T1.first_name, T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id = T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of employees who serve as support representatives for customers. The results are grouped by the employee's unique identifier and ordered by the number of customers they support in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of employees to return.\",\n        \"virtual_table\": \"SELECT T1.first_name , T1.last_name FROM employees AS T1 JOIN customers AS T2 ON T1.id  =  T2.support_rep_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of employees and their managers from the 'employees' table. It lists the first and last names of managers along with the count of employees reporting to each manager. The results are grouped by the manager's identifier and ordered by the number of reports in descending order, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.first_name , T2.last_name ,  count(T1.reports_to) FROM employees AS T1 JOIN employees AS T2 ON T1.reports_to = T2.id GROUP BY T1.reports_to ORDER BY count(T1.reports_to) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.608", "db_id": "store_1", "question": "How many orders does Luca Mancini have in his invoices?", "rationale": ["Identify the customer by name: We need to find the customer ID for Luca Mancini.", "Use a subquery to get the customer ID: We will select the ID from the customers table where the first name is 'Luca' and the last name is 'Mancini'.", "Count the number of invoices: We will count the number of invoices associated with the customer ID obtained from the subquery."], "gold_sql": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini';", "source_tables": ["customers", "invoices"], "pred_sql": "SELECT COUNT(*) FROM invoices WHERE customer_id = (SELECT id FROM customers WHERE first_name = 'Luca' AND last_name = 'Mancini');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of invoices issued per state within a specific country. The placeholder in the WHERE clause represents the country's name, and the placeholder in the LIMIT clause specifies the maximum number of states to return, ordered by the count of invoices in descending order.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) FROM invoices WHERE billing_country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY billing_state ORDER BY COUNT(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of invoices and the total amount billed for a specific billing state from the 'invoices' table. The placeholder in the WHERE clause represents the billing state being queried.\",\n        \"virtual_table\": \"SELECT billing_state ,  COUNT(*) ,  SUM(total) FROM invoices WHERE billing_state  =  [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.623", "db_id": "store_1", "question": "What is title of album which track Balls to the Wall belongs to?", "rationale": ["Identify the tables involved: We need to find the album title for a specific track, so we will use the 'albums' and 'tracks' tables.", "Determine the relationship: The 'tracks' table has a foreign key 'album_id' that references the 'id' in the 'albums' table, allowing us to join these two tables.", "Formulate the SQL query: We will select the 'title' from the 'albums' table where the track name matches 'Balls to the Wall'.", "Use a JOIN clause to connect the 'albums' and 'tracks' tables based on the album ID."], "gold_sql": "SELECT T1.title FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T2.name = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT albums.title \nFROM albums \nJOIN tracks ON albums.id = tracks.album_id \nWHERE tracks.name = 'Balls to the Wall';", "hint": "\n"}
{"sample_id": "train.626", "db_id": "store_1", "question": "What is the name of all tracks in the album named Balls to the Wall?", "rationale": ["Identify the relevant tables: tracks and albums.", "We need to find tracks that belong to a specific album, so we will join the tracks table with the albums table using the album_id foreign key.", "The condition for the join will be that the album's title matches 'Balls to the Wall'.", "Select the name of the tracks from the resulting joined table."], "gold_sql": "SELECT T2.name FROM albums AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id WHERE T1.title = 'Balls to the Wall';", "source_tables": ["albums", "tracks"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN albums ON tracks.album_id = albums.id \nWHERE albums.title = 'Balls to the Wall';", "hint": "\n"}
{"sample_id": "train.630", "db_id": "store_1", "question": "What are the names of all Rock tracks that are stored on MPEG audio files?", "rationale": ["Identify the relevant tables: tracks, media_types, and genres.", "We need to find the names of tracks, so we will select the 'name' column from the tracks table.", "To filter by genre, we will join the genres table on the genre_id column of the tracks table.", "To filter by media type, we will join the media_types table on the media_type_id column of the tracks table.", "The WHERE clause will specify that we want tracks where the genre name is 'Rock' and the media type name is 'MPEG audio'."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' AND T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN media_types ON tracks.media_type_id = media_types.id \nJOIN genres ON tracks.genre_id = genres.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG audio';", "hint": "\n"}
{"sample_id": "train.632", "db_id": "store_1", "question": "What are the names of all tracks that belong to the Rock genre and whose media type is MPEG?", "rationale": ["Identify the tables involved: tracks, genres, and media_types.", "We need to select the track names from the tracks table.", "To filter by genre, we will join the genres table on the genre_id column of the tracks table.", "To filter by media type, we will join the media_types table on the media_type_id column of the tracks table.", "The WHERE clause will specify that we want tracks where the genre name is 'Rock' and the media type name is 'MPEG'."], "gold_sql": "SELECT T2.name FROM genres AS T1 JOIN tracks AS T2 ON T1.id = T2.genre_id JOIN media_types AS T3 ON T3.id = T2.media_type_id WHERE T1.name = 'Rock' OR T3.name = 'MPEG audio file';", "source_tables": ["tracks", "genres", "media_types"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN genres ON tracks.genre_id = genres.id \nJOIN media_types ON tracks.media_type_id = media_types.id \nWHERE genres.name = 'Rock' AND media_types.name = 'MPEG';", "hint": "\n"}
{"sample_id": "train.640", "db_id": "store_1", "question": "What are the tracks that Dean Peeters bought?", "rationale": ["Identify the relevant tables: We need to find tracks that a specific customer (Dean Peeters) bought, so we will use the 'tracks', 'invoice_lines', 'invoices', and 'customers' tables.", "Join the tables: We will join 'tracks' with 'invoice_lines' on the track ID, then join 'invoice_lines' with 'invoices' on the invoice ID, and finally join 'invoices' with 'customers' on the customer ID.", "Filter by customer name: We will filter the results to only include records where the customer's first name is 'Dean' and last name is 'Peeters'.", "Select the track names: Finally, we will select the names of the tracks that match these criteria."], "gold_sql": "SELECT T1.name FROM tracks AS T1 JOIN invoice_lines AS T2 ON T1.id = T2.track_id JOIN invoices AS T3 ON T3.id = T2.invoice_id JOIN customers AS T4 ON T4.id = T3.customer_id WHERE T4.first_name = 'Daan' AND T4.last_name = 'Peeters';", "source_tables": ["tracks", "invoice_lines", "customers", "invoices"], "pred_sql": "SELECT tracks.name \nFROM tracks \nJOIN invoice_lines ON tracks.id = invoice_lines.track_id \nJOIN invoices ON invoice_lines.invoice_id = invoices.id \nJOIN customers ON invoices.customer_id = customers.id \nWHERE customers.first_name = 'Dean' AND customers.last_name = 'Peeters';", "hint": "\n"}
{"sample_id": "train.686", "db_id": "customers_card_transactions", "question": "What are the full names of customers who do not have any accounts?", "rationale": ["Identify the relevant tables: Customers and Accounts.", "We need to find customers who do not have any accounts, which means we need to exclude customer IDs that are present in the Accounts table.", "Use a subquery to select all customer_ids from the Accounts table.", "Use the NOT IN clause to filter out these customer_ids from the Customers table.", "Select the first and last names of the remaining customers."], "gold_sql": "SELECT customer_first_name ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_first_name, customer_last_name FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.688", "db_id": "customers_card_transactions", "question": "What are the full names of customers who have accounts?", "rationale": ["Identify the tables involved: Accounts and Customers.", "Determine the relationship between the tables: Accounts has a foreign key customer_id that links to Customers.", "Select the required fields: customer_first_name and customer_last_name from the Customers table.", "Join the Accounts table with the Customers table on the customer_id field to get the full names of customers who have accounts."], "gold_sql": "SELECT DISTINCT T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Accounts AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT T2.customer_first_name, T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id = T2.customer_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.704", "db_id": "customers_card_transactions", "question": "Return the full name and phone of the customer who has card number 4560596484842.", "rationale": ["Identify the tables needed: Customers and Customers_Cards.", "We need to retrieve the customer's first name, last name, and phone number.", "Join the Customers table with the Customers_Cards table on customer_id to link customers with their cards.", "Filter the results to only include the customer with the specified card number '4560596484842'.", "Select the required fields from the joined tables."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name ,  T2.customer_phone FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.card_number  =  '4560596484842'", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT C.customer_first_name, C.customer_last_name, C.customer_phone \nFROM Customers AS C \nJOIN Customers_Cards AS CC ON C.customer_id = CC.customer_id \nWHERE CC.card_number = '4560596484842';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.717", "db_id": "customers_card_transactions", "question": "What is the customer id, first and last name with least number of accounts.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "Join the Accounts table with the Customers table on customer_id to get customer details associated with each account.", "Group the results by customer_id to count the number of accounts each customer has.", "Order the results by the count of accounts in ascending order to find the customer with the least number of accounts.", "Limit the results to 1 to get only the customer with the least number of accounts."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT T2.customer_id, T2.customer_first_name, T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id = T2.customer_id GROUP BY T1.customer_id ORDER BY COUNT(*) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.718", "db_id": "customers_card_transactions", "question": "Return the id and full name of the customer who has the fewest accounts.", "rationale": ["Identify the tables involved: Accounts and Customers.", "We need to join these tables on the customer_id to get customer details associated with their accounts.", "Group the results by customer_id to count the number of accounts each customer has.", "Order the results by the count of accounts in ascending order to find the customer with the fewest accounts.", "Limit the results to 1 to get only the customer with the fewest accounts.", "Select the customer_id and concatenate first and last names to get the full name of the customer."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["customers", "customers_cards"], "pred_sql": "SELECT T2.customer_id, T2.customer_first_name || ' ' || T2.customer_last_name AS full_name \nFROM Accounts AS T1 \nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id \nGROUP BY T1.customer_id \nORDER BY COUNT(T1.account_id) ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer first and last names along with their associated customer IDs from the 'Accounts' and 'Customers' tables. The data is grouped by customer ID and ordered by the count of accounts associated with each customer in ascending order, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT T2.customer_first_name ,  T2.customer_last_name ,  T1.customer_id FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of customer IDs and their first names from the 'Customers' table, excluding those customers who have a specific type of card. The placeholder in the EXCEPT clause represents the card type code that is used to filter out customers who possess that card type.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_first_name FROM Customers EXCEPT SELECT T1.customer_id ,  T2.customer_first_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE card_type_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.721", "db_id": "customers_card_transactions", "question": "What is the card type code with most number of cards?", "rationale": ["We need to find the card type code with the most number of cards.", "To do this, we will count the number of cards for each card type code in the Customers_Cards table.", "We will use the COUNT function to count the card IDs grouped by card_type_code.", "Next, we will order the results in descending order based on the count of cards.", "Finally, we will limit the results to only one record to get the card type code with the highest count."], "gold_sql": "SELECT card_type_code FROM Customers_cards GROUP BY card_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers_cards"], "pred_sql": "SELECT card_type_code, COUNT(card_id) AS card_count \nFROM Customers_Cards \nGROUP BY card_type_code \nORDER BY card_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of customer IDs along with their first and last names from the 'Customers' table, specifically for customers who have a certain number of cards associated with them. The placeholder in the HAVING clause represents the minimum count of cards a customer must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.735", "db_id": "customers_card_transactions", "question": "Show the number of transaction types.", "rationale": ["Identify the table that contains transaction types, which is the Financial_Transactions table.", "To count the number of each transaction type, we need to use the COUNT() function.", "We will select the transaction_type column and apply the COUNT() function to count occurrences of each type.", "To group the results by transaction type, we will use the GROUP BY clause on the transaction_type column."], "gold_sql": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, COUNT(*) AS transaction_count \nFROM Financial_Transactions \nGROUP BY transaction_type;", "hint": "\n"}
{"sample_id": "train.743", "db_id": "customers_card_transactions", "question": "What is the transaction type that has processed the greatest total amount in transactions?", "rationale": ["Identify the relevant table: Financial_Transactions contains the transaction details including type and amount.", "We need to group the transactions by their type to calculate the total amount for each type.", "Use the SUM function to calculate the total amount for each transaction type.", "Order the results in descending order to find the transaction type with the greatest total amount.", "Limit the results to 1 to get only the top transaction type."], "gold_sql": "SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1", "source_tables": ["financial_transactions"], "pred_sql": "SELECT transaction_type, SUM(transaction_amount) AS total_amount\nFROM Financial_Transactions\nGROUP BY transaction_type\nORDER BY total_amount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.893", "db_id": "insurance_fnol", "question": "What are the customer phone numbers under the policy \"Life Insurance\"?", "rationale": ["Identify the relevant tables: Available_Policies, Customers_Policies, and Services.", "We need to find customer phone numbers, so we will select the 'Customer_Phone' column from the Available_Policies table.", "To link the policies to the customers, we will join the Available_Policies table with the Customers_Policies table on 'Policy_ID'.", "Next, we need to filter the policies to only include those with the name 'Life Insurance', so we will join the Services table to get the policy names.", "Finally, we will use a WHERE clause to filter for 'Life Insurance' and select distinct customer phone numbers."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  'Life Insurance'", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nJOIN Services s ON ap.policy_type_code = s.Service_ID \nWHERE s.Service_name = 'Life Insurance';", "hint": "\n"}
{"sample_id": "train.895", "db_id": "insurance_fnol", "question": "Which policy type has the most records in the database?", "rationale": ["We need to find out which policy type has the most records in the database.", "To do this, we will query the 'Available_Policies' table.", "We will select the 'policy_type_code' and count the number of occurrences of each policy type using COUNT(*).", "We will group the results by 'policy_type_code' to aggregate the counts for each type.", "To find the type with the most records, we will order the results in descending order based on the count.", "Finally, we will limit the results to 1 to get only the top policy type."], "gold_sql": "SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["available_policies"], "pred_sql": "SELECT policy_type_code, COUNT(*) as policy_count \nFROM Available_Policies \nGROUP BY policy_type_code \nORDER BY policy_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.897", "db_id": "insurance_fnol", "question": "What are all the customer phone numbers under the most popular policy type?", "rationale": ["Identify the most popular policy type by counting the number of policies issued for each type.", "Use a subquery to find the policy type with the maximum count.", "Join the Available_Policies table with Customers_Policies to link policies to customer phone numbers.", "Select distinct customer phone numbers associated with the most popular policy type."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT ap.Customer_Phone \nFROM Available_Policies ap \nJOIN Customers_Policies cp ON ap.Policy_ID = cp.Policy_ID \nWHERE ap.policy_type_code = (\n    SELECT policy_type_code \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    HAVING COUNT(*) = (\n        SELECT MAX(policy_count) \n        FROM (\n            SELECT COUNT(*) AS policy_count \n            FROM Available_Policies \n            GROUP BY policy_type_code\n        )\n    )\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.898", "db_id": "insurance_fnol", "question": "Find the phone numbers of customers using the most common policy type among the available policies.", "rationale": ["Identify the relevant tables: Customers, Customers_Policies, and Available_Policies are needed to get customer phone numbers and their associated policies.", "Join the Customers table with Customers_Policies to link customers to their policies.", "Join the result with Available_Policies to access the policy types.", "To find the most common policy type, create a subquery that counts the occurrences of each policy type and selects the maximum count.", "Use this maximum count in another subquery to filter for the policy type(s) that match this count.", "Finally, select distinct customer phone numbers where the policy type matches the most common one."], "gold_sql": "SELECT customer_phone FROM available_policies WHERE policy_type_code  =  (SELECT policy_type_code FROM available_policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["available_policies"], "pred_sql": "SELECT DISTINCT c.Customer_Phone \nFROM Customers c \nJOIN Customers_Policies cp ON c.Customer_ID = cp.Customer_ID \nJOIN Available_Policies ap ON cp.Policy_ID = ap.Policy_ID \nWHERE ap.policy_type_code = (\n    SELECT policy_type_code \n    FROM Available_Policies \n    GROUP BY policy_type_code \n    HAVING COUNT(*) = (\n        SELECT MAX(policy_count) \n        FROM (\n            SELECT COUNT(*) AS policy_count \n            FROM Available_Policies \n            GROUP BY policy_type_code\n        )\n    )\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique policy types from the 'Available_Policies' table that have been issued more than a specified number of times. The placeholder in the HAVING clause represents the minimum count of policies required to be included in the results.\",\n        \"virtual_table\": \"SELECT policy_type_code FROM available_policies GROUP BY policy_type_code HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1060", "db_id": "match_season", "question": "Show the players from college UCLA.", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players and their colleges.", "Determine the condition: We need to filter players based on the college they attended, specifically 'UCLA'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Player' column from the 'match_season' table where the 'College' column matches 'UCLA'."], "gold_sql": "SELECT Player FROM match_season WHERE College  =  'UCLA'", "source_tables": ["match_season"], "pred_sql": "SELECT Player FROM match_season WHERE College = 'UCLA'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\",\n        \"virtual_table\": \"SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1082", "db_id": "match_season", "question": "Show the season, the player, and the name of the team that players belong to.", "rationale": ["Identify the columns needed: Season, Player, and Team Name.", "The Season and Player are from the match_season table.", "The Team Name is from the team table.", "To get the Team Name, we need to join the match_season table with the team table on the Team ID.", "Construct the SQL query using SELECT to retrieve the required columns and JOIN to combine the tables."], "gold_sql": "SELECT T1.Season ,  T1.Player ,  T2.Name FROM match_season AS T1 JOIN team AS T2 ON T1.Team  =  T2.Team_id", "source_tables": ["team", "match_season"], "pred_sql": "SELECT match_season.Season, match_season.Player, team.Name \nFROM match_season \nJOIN team ON match_season.Team = team.Team_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides information about the draft pick number and draft class of players from the 'match_season' table who play in a specific position. The placeholder in the WHERE clause represents the position of the player.\",\n        \"virtual_table\": \"SELECT Draft_Pick_Number ,  Draft_Class FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1092", "db_id": "match_season", "question": "Show the country names and the corresponding number of players.", "rationale": ["The task is to show the country names and the corresponding number of players.", "To achieve this, we need to count the number of players associated with each country.", "We will join the 'country' table with the 'match_season' table on the country identifier.", "Using COUNT(*) will allow us to count the number of entries (players) for each country.", "Finally, we will group the results by country name to get the count for each individual country."], "gold_sql": "SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name", "source_tables": ["country", "match_season"], "pred_sql": "SELECT Country_name, COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id = T2.Country GROUP BY T1.Country_name", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of countries represented by players who occupy a specific position in matches. It uses an intersection to find countries where players in that position are participating in matches, ensuring that only countries with players in that position are returned. The placeholders in the query represent the position of the players being filtered.\",\n        \"virtual_table\": \"SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of matches played by players from each country, by joining the 'country' table with the 'match_season' table. The placeholder in the SELECT clause represents the country names, and the COUNT function aggregates the number of matches for each country.\",\n        \"virtual_table\": \"SELECT Country_name ,  COUNT(*) FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country GROUP BY T1.Country_name\"\n    }\n}\n"}
{"sample_id": "train.1098", "db_id": "match_season", "question": "Show the top 3 most common colleges of players in match seasons.", "rationale": ["The task is to find the top 3 most common colleges of players in match seasons.", "To achieve this, we need to count the occurrences of each college in the match_season table.", "We will use the COUNT function to count how many players attended each college.", "We will group the results by the College column to aggregate the counts for each college.", "To get the most common colleges, we will order the results in descending order based on the count of players from each college.", "Finally, we will limit the results to the top 3 colleges."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as College_Count \nFROM match_season \nGROUP BY College \nORDER BY College_Count DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\",\n        \"virtual_table\": \"SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1099", "db_id": "match_season", "question": "What are the three colleges from which the most players are from?", "rationale": ["Identify the relevant table: The 'match_season' table contains information about players and their colleges.", "We need to count the number of players from each college, so we will use the COUNT() function.", "Group the results by 'College' to aggregate the player counts for each college.", "Order the results in descending order based on the player count to get the colleges with the most players at the top.", "Limit the results to the top three colleges using LIMIT 3."], "gold_sql": "SELECT College FROM match_season GROUP BY College ORDER BY count(*) DESC LIMIT 3", "source_tables": ["match_season"], "pred_sql": "SELECT College, COUNT(*) as Player_Count \nFROM match_season \nGROUP BY College \nORDER BY Player_Count DESC \nLIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\",\n        \"virtual_table\": \"SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1107", "db_id": "match_season", "question": "Return the names of countries that have players that play the Forward position, as well as players who play the Defender position.", "rationale": ["Identify the requirement to find countries with players in specific positions (Forward and Defender).", "Use the provided virtual table structure to create a query that selects country names based on player positions.", "Join the 'country' table with the 'match_season' table on the country ID.", "Filter the results for players in the Forward position in the first part of the INTERSECT query.", "Filter the results for players in the Defender position in the second part of the INTERSECT query."], "gold_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  'Defender'", "source_tables": ["country", "match_season"], "pred_sql": "SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id = T2.Country WHERE T2.Position = 'Forward' INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id = T2.Country WHERE T2.Position = 'Defender'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of countries represented by players who occupy a specific position in matches. It uses an intersection to find countries where players in that position are participating in matches, ensuring that only countries with players in that position are returned. The placeholders in the query represent the position of the players being filtered.\",\n        \"virtual_table\": \"SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\",\n        \"virtual_table\": \"SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1109", "db_id": "match_season", "question": "Return the colleges that have players who play the Midfielder position, as well as players who play the Defender position.", "rationale": ["Identify the positions of interest: Midfielder and Defender.", "Use the provided hint to create a SQL query that retrieves colleges attended by players in these positions.", "Utilize the INTERSECT operator to find common colleges attended by players in both positions.", "Construct the final SQL query using the SELECT statement for colleges with the specified conditions."], "gold_sql": "SELECT College FROM match_season WHERE POSITION  =  'Midfielder' INTERSECT SELECT College FROM match_season WHERE POSITION  =  'Defender'", "source_tables": ["match_season"], "pred_sql": "SELECT College FROM match_season WHERE Position = 'Midfielder' INTERSECT SELECT College FROM match_season WHERE Position = 'Defender'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the colleges attended by players who play in two specified positions during the match season. The placeholders in the WHERE clause represent the positions of the players being compared.\",\n        \"virtual_table\": \"SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT College FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of countries represented by players who occupy a specific position in matches. It uses an intersection to find countries where players in that position are participating in matches, ensuring that only countries with players in that position are returned. The placeholders in the query represent the position of the players being filtered.\",\n        \"virtual_table\": \"SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Country_name FROM country AS T1 JOIN match_season AS T2 ON T1.Country_id  =  T2.Country WHERE T2.Position  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides information about the draft pick number and draft class of players from the 'match_season' table who play in a specific position. The placeholder in the WHERE clause represents the position of the player.\",\n        \"virtual_table\": \"SELECT Draft_Pick_Number ,  Draft_Class FROM match_season WHERE POSITION  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1222", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with type code \"Duplex\"?", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for apartment type.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to link bookings to their respective apartments.", "Filter the results to only include apartments with the type code 'Duplex'.", "Select the booking start and end dates from the joined tables."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.apt_type_code  =  'Duplex'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT ab.booking_start_date, ab.booking_end_date \nFROM Apartment_Bookings ab \nJOIN Apartments a ON ab.apt_id = a.apt_id \nWHERE a.apt_type_code = 'Duplex';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1224", "db_id": "apartment_rentals", "question": "What are the booking start and end dates of the apartments with more than 2 bedrooms?", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "We need to filter apartments based on the number of bedrooms, specifically those with more than 2 bedrooms.", "Use a subquery to select apt_id from the Apartments table where bedroom_count is greater than 2.", "Join this subquery with the Apartment_Bookings table to get the booking start and end dates for those apartments."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT booking_start_date, booking_end_date FROM Apartment_Bookings WHERE apt_id IN (SELECT apt_id FROM Apartments WHERE bedroom_count > 2)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1225", "db_id": "apartment_rentals", "question": "Find the booking start date and end date for the apartments that have more than two bedrooms.", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking dates and Apartments for bedroom count.", "Join the Apartment_Bookings table with the Apartments table on the apt_id to access both booking dates and bedroom counts.", "Filter the results to include only those apartments that have more than two bedrooms using a WHERE clause."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  2", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT booking_start_date, booking_end_date \nFROM Apartment_Bookings \nJOIN Apartments ON Apartment_Bookings.apt_id = Apartments.apt_id \nWHERE bedroom_count > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1229", "db_id": "apartment_rentals", "question": "Which apartments have bookings with status code \"Confirmed\"? Return their apartment numbers.", "rationale": ["Identify the relevant tables: Apartments and Apartment_Bookings are needed to find apartment numbers with confirmed bookings.", "Join the Apartments table with the Apartment_Bookings table on the apt_id to link apartments with their bookings.", "Filter the results to include only those bookings where the booking_status_code is 'Confirmed'.", "Select the apt_number from the filtered results to get the desired output."], "gold_sql": "SELECT DISTINCT T2.apt_number FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  'Confirmed'", "source_tables": ["apartment_bookings", "apartments"], "pred_sql": "SELECT a.apt_number \nFROM Apartments a \nJOIN Apartment_Bookings ab ON a.apt_id = ab.apt_id \nWHERE ab.booking_status_code = 'Confirmed';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1232", "db_id": "apartment_rentals", "question": "Show the guest first names, start dates, and end dates of all the apartment bookings.", "rationale": ["Identify the tables needed: We need data from the 'Apartment_Bookings' table for booking details and the 'Guests' table for guest names.", "Determine the columns to select: We need 'guest_first_name' from the 'Guests' table, and 'booking_start_date' and 'booking_end_date' from the 'Apartment_Bookings' table.", "Establish the relationship between tables: The 'Apartment_Bookings' table has a foreign key 'guest_id' that links to the 'Guests' table's primary key 'guest_id'.", "Construct the SQL query: Use a JOIN to combine the two tables on the guest_id, and select the required columns."], "gold_sql": "SELECT T2.guest_first_name ,  T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT Guests.guest_first_name, Apartment_Bookings.booking_start_date, Apartment_Bookings.booking_end_date \nFROM Apartment_Bookings \nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1234", "db_id": "apartment_rentals", "question": "Show the start dates and end dates of all the apartment bookings made by guests with gender code \"Female\".", "rationale": ["Identify the relevant tables: Apartment_Bookings for booking details and Guests for guest information.", "Determine the columns needed: booking_start_date and booking_end_date from Apartment_Bookings.", "Establish the relationship between tables: Join Apartment_Bookings with Guests on guest_id.", "Filter the results to include only those bookings made by guests with gender code 'Female'."], "gold_sql": "SELECT T1.booking_start_date ,  T1.booking_start_date FROM Apartment_Bookings AS T1 JOIN Guests AS T2 ON T1.guest_id  =  T2.guest_id WHERE T2.gender_code  =  'Female'", "source_tables": ["apartment_bookings", "guests"], "pred_sql": "SELECT booking_start_date, booking_end_date \nFROM Apartment_Bookings \nJOIN Guests ON Apartment_Bookings.guest_id = Guests.guest_id \nWHERE Guests.gender_code = 'Female';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1238", "db_id": "apartment_rentals", "question": "Show the facility codes of apartments with more than 4 bedrooms.", "rationale": ["Identify the relevant tables: We need to access the 'Apartments' table for bedroom counts and the 'Apartment_Facilities' table for facility codes.", "Join the 'Apartments' table with the 'Apartment_Facilities' table on the 'apt_id' to link apartments with their facilities.", "Filter the results to include only those apartments that have more than 4 bedrooms using a WHERE clause.", "Select the distinct facility codes from the joined tables to avoid duplicates."], "gold_sql": "SELECT T1.facility_code FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.bedroom_count  >  4", "source_tables": ["apartments", "apartment_facilities"], "pred_sql": "SELECT DISTINCT af.facility_code \nFROM Apartments a \nJOIN Apartment_Facilities af ON a.apt_id = af.apt_id \nWHERE a.bedroom_count > 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1256", "db_id": "apartment_rentals", "question": "Show the top 3 apartment type codes sorted by the average number of rooms in descending order.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of rooms.", "Determine the required aggregation: We need to calculate the average number of rooms for each apartment type code.", "Group the results: Use GROUP BY to group the results by apt_type_code.", "Sort the results: Use ORDER BY to sort the average number of rooms in descending order.", "Limit the results: Use LIMIT to restrict the output to the top 3 apartment type codes."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY avg(room_count) DESC LIMIT 3", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY AVG(room_count) DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1258", "db_id": "apartment_rentals", "question": "Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.", "rationale": ["Identify the relevant table: The Apartments table contains the necessary columns for apartment type code, number of bathrooms, number of bedrooms, and total number of rooms.", "Group the results by apartment type code: This allows us to aggregate data for each type of apartment.", "Order the results by the total number of rooms: We want to find the apartment type with the largest number of total rooms, so we will order by the sum of room_count in descending order.", "Limit the results to one: Since we only want the apartment type with the largest number of total rooms, we will limit our results to 1."], "gold_sql": "SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, bathroom_count, bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1261", "db_id": "apartment_rentals", "question": "Which apartment type code appears the most often?", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes.", "Determine the goal: We want to find out which apartment type code appears the most often.", "Use the COUNT function: This will count the number of occurrences of each apartment type code.", "Group the results: Use GROUP BY to group the results by apartment type code.", "Order the results: Use ORDER BY to sort the counts in descending order so that the most common type appears first.", "Limit the results: Use LIMIT 1 to return only the top result, which is the most common apartment type code."], "gold_sql": "SELECT apt_type_code FROM Apartments GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code, COUNT(*) as type_count FROM Apartments GROUP BY apt_type_code ORDER BY type_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1262", "db_id": "apartment_rentals", "question": "Show the most common apartment type code among apartments with more than 1 bathroom.", "rationale": ["Identify the relevant table: The Apartments table contains the apartment type codes and the number of bathrooms.", "Filter apartments: We need to filter apartments that have more than 1 bathroom, which is done using the WHERE clause.", "Group by apartment type: To find the most common apartment type code, we group the results by apt_type_code.", "Count occurrences: We order the grouped results by the count of apartments in each type in descending order to find the most common type.", "Limit results: We limit the results to 1 to get only the most common apartment type code."], "gold_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["apartments"], "pred_sql": "SELECT apt_type_code FROM Apartments WHERE bathroom_count > 1 GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1272", "db_id": "apartment_rentals", "question": "Show the apartment numbers of apartments with unit status availability of both 0 and 1.", "rationale": ["Identify the relevant tables: Apartments and View_Unit_Status.", "We need to find apartment numbers, so we will select 'apt_number' from the Apartments table.", "To filter apartments based on their availability status, we will use the View_Unit_Status table.", "The availability status is indicated by the 'available_yn' column in the View_Unit_Status table, where we want to check for both 'Yes' (1) and 'No' (0).", "We will use a subquery to select 'apt_id' from View_Unit_Status where 'available_yn' is either 'Yes' or 'No'.", "Finally, we will use this subquery to filter the main query to get the apartment numbers."], "gold_sql": "SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  0 INTERSECT SELECT T1.apt_number FROM Apartments AS T1 JOIN View_Unit_Status AS T2 ON T1.apt_id  =  T2.apt_id WHERE T2.available_yn  =  1", "source_tables": ["view_unit_status", "apartments"], "pred_sql": "SELECT apt_number FROM Apartments WHERE apt_id IN (SELECT apt_id FROM View_Unit_Status WHERE available_yn IN ('Yes', 'No'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the types of apartments available in the 'Apartments' table, displaying the apartment type code along with the count of bathrooms and bedrooms. The results are grouped by apartment type and ordered by the total number of rooms in descending order, with a limit on the number of results returned based on a specified numeric value.\",\n        \"virtual_table\": \"SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the types of apartments available in the 'Apartments' table that have a specified number of bathrooms. The results are grouped by the apartment type code and ordered by the count of apartments in each type, allowing users to see which types are most common based on the bathroom count. The placeholders in the WHERE clause and LIMIT clause represent the minimum number of bathrooms and the maximum number of results to return, respectively.\",\n        \"virtual_table\": \"SELECT apt_type_code FROM Apartments WHERE bathroom_count  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY apt_type_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1294", "db_id": "soccer_1", "question": "How many leagues are there in England?", "rationale": ["Identify the relevant table: The question asks about leagues, so we will use the 'League' table.", "Determine the condition: We need to filter the leagues to only those in England.", "Construct the SQL query: We will use the COUNT function to count the number of leagues that match the condition."], "gold_sql": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  'England'", "source_tables": ["country", "league"], "pred_sql": "SELECT COUNT(*) AS league_count FROM League WHERE name = 'England';", "hint": "\n"}
{"sample_id": "train.1303", "db_id": "soccer_1", "question": "List all of the player ids with a height of at least 180cm and an overall rating higher than 85.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to select player ids, so we will select 'player_api_id' from the Player table.", "We need to join Player with Player_Attributes on 'player_api_id' to access the height and overall rating.", "Apply the condition for height (at least 180cm) from the Player table.", "Apply the condition for overall rating (higher than 85) from the Player_Attributes table.", "Use DISTINCT to ensure unique player ids are returned."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE overall_rating  >  85", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT DISTINCT P.player_api_id FROM Player AS P JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.height >= 180 AND PA.overall_rating > 85;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have a specific preferred foot and whose overall skill rating falls within a defined range. The placeholders in the WHERE clause represent the preferred foot and the minimum and maximum overall ratings.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING] AND T2.overall_rating  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.overall_rating  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have a crossing ability greater than a specified value and have a preferred foot that matches a given specification. The placeholders in the WHERE clause represent the crossing ability threshold and the preferred foot of the players.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  [PLACEHOLDER-TYPE:NUMBER] AND T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1304", "db_id": "soccer_1", "question": "List all of the ids for left-footed players with a height between 180cm and 190cm.", "rationale": ["Identify the relevant tables: Player and Player_Attributes.", "We need to filter players based on their height, which is in the Player table.", "We also need to filter players based on their preferred foot, which is in the Player_Attributes table.", "The preferred foot condition is that it should be 'left'.", "The height condition is that it should be between 180cm and 190cm.", "To get the ids of left-footed players, we will use a subquery to find player_api_ids from Player_Attributes where preferred_foot is 'left'.", "Finally, we will select distinct player_api_ids from the Player table where height is between 180 and 190 and matches the ids from the subquery."], "gold_sql": "SELECT player_api_id FROM Player WHERE height  >=  180 AND height  <=  190 INTERSECT SELECT player_api_id FROM Player_Attributes WHERE preferred_foot  =  'left'", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT DISTINCT P.player_api_id FROM Player AS P WHERE P.height BETWEEN 180 AND 190 AND P.player_api_id IN (SELECT PA.player_api_id FROM Player_Attributes AS PA WHERE PA.preferred_foot = 'left')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have a specific preferred foot and whose overall skill rating falls within a defined range. The placeholders in the WHERE clause represent the preferred foot and the minimum and maximum overall ratings.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING] AND T2.overall_rating  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.overall_rating  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have a crossing ability greater than a specified value and have a preferred foot that matches a given specification. The placeholders in the WHERE clause represent the crossing ability threshold and the preferred foot of the players.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  [PLACEHOLDER-TYPE:NUMBER] AND T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1306", "db_id": "soccer_1", "question": "List the names and birthdays of the top five players in terms of potential.", "rationale": ["Identify the relevant tables: We need to retrieve player names and birthdays, which are in the 'Player' table, and we need to rank players based on their potential, which is in the 'Player_Attributes' table.", "Determine the criteria for selection: We want the top five players based on their potential rating.", "Construct a subquery to get the top five players by potential: This involves selecting player_api_id from 'Player_Attributes', ordering by potential in descending order, and limiting the results to 5.", "Join the results of the subquery with the 'Player' table to get the names and birthdays of these players: We will use the player_api_id from the subquery to filter the 'Player' table."], "gold_sql": "SELECT DISTINCT T1.player_name ,  T1.birthday FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id  =  T2.player_api_id ORDER BY potential DESC LIMIT 5", "source_tables": ["player_attributes", "player"], "pred_sql": "SELECT player_name, birthday FROM Player WHERE player_api_id IN (SELECT player_api_id FROM Player_Attributes ORDER BY potential DESC LIMIT 5)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have a specific preferred foot and whose overall skill rating falls within a defined range. The placeholders in the WHERE clause represent the preferred foot and the minimum and maximum overall ratings.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING] AND T2.overall_rating  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.overall_rating  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of players from the 'Player' table who have a crossing ability greater than a specified value and have a preferred foot that matches a given specification. The placeholders in the WHERE clause represent the crossing ability threshold and the preferred foot of the players.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.player_name FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.crossing  >  [PLACEHOLDER-TYPE:NUMBER] AND T2.preferred_foot  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.1511", "db_id": "insurance_and_eClaims", "question": "Which type of policy is most frequently used? Give me the policy type code.", "rationale": ["Identify the relevant table: The question asks about policy types, so we will focus on the Policies table.", "Determine the required columns: We need the Policy_Type_Code and a count of how many times each type is used.", "Use the COUNT function: To find out how frequently each policy type is used, we will use COUNT(*) to count the occurrences of each Policy_Type_Code.", "Group the results: We will group the results by Policy_Type_Code to aggregate the counts for each type.", "Order the results: To find the most frequently used policy type, we will order the results in descending order based on the frequency count.", "Limit the results: Since we only want the most frequently used policy type, we will limit the results to 1."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(*) as Frequency\nFROM Policies\nGROUP BY Policy_Type_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1513", "db_id": "insurance_and_eClaims", "question": "Find all the policy types that are used by more than 2 customers.", "rationale": ["Identify the relevant table: The 'Policies' table contains the 'Policy_Type_Code' and 'Customer_ID' which are needed for this query.", "We need to find policy types used by more than 2 customers, so we will group by 'Customer_ID' and count the distinct customers.", "Use a subquery to first find 'Customer_ID's that are associated with more than 2 policies.", "In the main query, select 'Policy_Type_Code' from the 'Policies' table where the 'Customer_ID' is in the result of the subquery.", "Finally, group the results by 'Policy_Type_Code' to get the distinct policy types used by more than 2 customers."], "gold_sql": "SELECT policy_type_code FROM policies GROUP BY policy_type_code HAVING count(*)  >  2", "source_tables": ["policies"], "pred_sql": "SELECT Policy_Type_Code\nFROM Policies\nWHERE Customer_ID IN (\n    SELECT Customer_ID\n    FROM Policies\n    GROUP BY Customer_ID\n    HAVING COUNT(DISTINCT Customer_ID) > 2\n)\nGROUP BY Policy_Type_Code;", "hint": "\n"}
{"sample_id": "train.1516", "db_id": "insurance_and_eClaims", "question": "What are the total amount and average amount paid in claim headers?", "rationale": ["Identify the relevant table: The 'Claim_Headers' table contains the 'Amount_Paid' column which is needed for the calculations.", "Determine the required calculations: We need to calculate both the total and average of the 'Amount_Paid' column.", "Construct the SQL query: Use the SUM() function to get the total amount paid and the AVG() function to get the average amount paid from the 'Claim_Headers' table."], "gold_sql": "SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers", "source_tables": ["claim_headers"], "pred_sql": "SELECT SUM(Amount_Paid) AS Total_Amount_Paid, AVG(Amount_Paid) AS Average_Amount_Paid FROM Claim_Headers;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\",\n        \"virtual_table\": \"SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.1518", "db_id": "insurance_and_eClaims", "question": "How much amount in total were claimed in the most recently created document?", "rationale": ["Identify the relevant tables: Claim_Headers for the amount claimed and Claims_Documents for the document creation date.", "We need to sum the 'Amount_Claimed' from the Claim_Headers table.", "Join Claim_Headers with Claims_Documents on the Claim_ID to link claims with their documents.", "To find the most recently created document, we will order the Claims_Documents by 'Created_Date' in descending order and limit the result to 1.", "Use this date in the WHERE clause to filter the claims that have documents created on that specific date."], "gold_sql": "SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT 1)", "source_tables": ["claims_documents", "claim_headers"], "pred_sql": "SELECT sum(t1.Amount_Claimed) FROM Claim_Headers AS t1 JOIN Claims_Documents AS t2 ON t1.Claim_Header_ID = t2.Claim_ID WHERE t2.Created_Date = (SELECT Created_Date FROM Claims_Documents ORDER BY Created_Date DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\",\n        \"virtual_table\": \"SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.1519", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the largest amount of claim in a single claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers are needed to find the customer details and their claims.", "Join the Customers table with the Policies table on Customer_ID to link customers to their policies.", "Join the resulting table with Claim_Headers on Policy_ID to access the claims made by each customer.", "Use a subquery to find the maximum amount claimed from the Claim_Headers table.", "Filter the results to only include the customer(s) who made a claim equal to this maximum amount."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_claimed  =  (SELECT max(amount_claimed) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details\nFROM Customers AS c\nJOIN Policies AS p ON c.Customer_ID = p.Customer_ID\nJOIN Claim_Headers AS ch ON p.Policy_ID = ch.Policy_ID\nWHERE ch.Amount_Claimed = (\n    SELECT MAX(Amount_Claimed)\n    FROM Claim_Headers\n);\n", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table calculates the total amount claimed from the 'Claim_Headers' table for claims that have associated documents created on a specific date. The placeholder in the subquery represents the limit for selecting the created date of the documents.\",\n        \"virtual_table\": \"SELECT sum(t1.amount_claimed) FROM claim_headers AS t1 JOIN claims_documents AS t2 ON t1.claim_header_id  =  t2.claim_id WHERE t2.created_date  =  (SELECT created_date FROM claims_documents ORDER BY created_date LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.1521", "db_id": "insurance_and_eClaims", "question": "What is the name of the customer who has made the minimum amount of payment in one claim?", "rationale": ["Identify the relevant tables: Customers, Policies, and Claim_Headers.", "We need to find the customer who has made the minimum payment in one claim, which involves joining these tables based on their relationships.", "Join Customers with Policies on Customer_ID to link customers to their policies.", "Join Policies with Claim_Headers on Policy_ID to link policies to their claims.", "Use a subquery to find the minimum Amount_Paid from Claim_Headers.", "Select the Customer_Details from Customers where the Amount_Paid matches the minimum found in the subquery."], "gold_sql": "SELECT t3.customer_details FROM claim_headers AS t1 JOIN policies AS t2 ON t1.policy_id  =  t2.policy_id JOIN customers AS t3 ON t2.customer_id  =  t3.customer_id WHERE t1.amount_piad  =  (SELECT min(amount_piad) FROM claim_headers)", "source_tables": ["policies", "customers", "claim_headers"], "pred_sql": "SELECT c.Customer_Details\nFROM Customers c\nJOIN Policies p ON c.Customer_ID = p.Customer_ID\nJOIN Claim_Headers ch ON p.Policy_ID = ch.Policy_ID\nWHERE ch.Amount_Paid = (\n    SELECT MIN(Amount_Paid)\n    FROM Claim_Headers\n);\n", "hint": "\n"}
{"sample_id": "train.1531", "db_id": "insurance_and_eClaims", "question": "Find the names of the customers who have an deputy policy.", "rationale": ["Identify the relevant tables: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Filter the Policies table for those with a Policy_Type_Code that indicates a deputy policy.", "Select the distinct Customer_Details from the Customers table for those who have a deputy policy."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT DISTINCT Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Policy_Type_Code = 'deputy';", "hint": "\n"}
{"sample_id": "train.1533", "db_id": "insurance_and_eClaims", "question": "Find the names of customers who either have an deputy policy or uniformed policy.", "rationale": ["Identify the tables involved: Customers and Policies.", "Determine the relationship between the tables: Customers are linked to Policies through Customer_ID.", "Select the relevant columns: We need Customer_Details from the Customers table.", "Filter the results based on the Policy_Type_Code: We want policies that are either 'deputy' or 'uniformed'.", "Use a JOIN to combine data from both tables based on the Customer_ID.", "Use DISTINCT to ensure we only get unique customer names."], "gold_sql": "SELECT DISTINCT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.policy_type_code  =  'Deputy' OR t1.policy_type_code  =  'Uniform'", "source_tables": ["policies", "customers"], "pred_sql": "SELECT DISTINCT Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nWHERE Policies.Policy_Type_Code IN ('deputy', 'uniformed');", "hint": "\n"}
{"sample_id": "train.1546", "db_id": "insurance_and_eClaims", "question": "Find the customer who started a policy most recently.", "rationale": ["Identify the relevant tables: Customers and Policies.", "We need to find the customer who started a policy most recently, so we will join the Customers table with the Policies table on Customer_ID.", "We will order the results by the Start_Date of the policies in descending order to get the most recent policy first.", "Finally, we will limit the results to 1 to get only the most recent customer."], "gold_sql": "SELECT t2.customer_details FROM policies AS t1 JOIN customers AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.start_date  =  (SELECT max(start_date) FROM policies)", "source_tables": ["policies", "customers"], "pred_sql": "SELECT Customers.Customer_ID, Customers.Customer_Details \nFROM Customers \nJOIN Policies ON Customers.Customer_ID = Policies.Customer_ID \nORDER BY Policies.Start_Date DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.1553", "db_id": "customers_and_invoices", "question": "Show the id, the account name, and other account details for all accounts by the customer with first name 'Meaghan'.", "rationale": ["Identify the relevant tables: Accounts and Customers.", "We need to join the Accounts table with the Customers table to access customer details.", "Select the required fields: account_id, account_name, and other_account_details from the Accounts table.", "Filter the results to include only those accounts associated with customers whose first name is 'Meaghan'.", "Construct the SQL query using the SELECT statement with JOIN and WHERE clause."], "gold_sql": "SELECT T1.account_id ,  T1.date_account_opened ,  T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT A.account_id, A.account_name, A.other_account_details \nFROM Accounts AS A \nJOIN Customers AS C ON A.customer_id = C.customer_id \nWHERE C.customer_first_name = 'Meaghan';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    }\n}\n"}
{"sample_id": "train.1556", "db_id": "customers_and_invoices", "question": "What are the names and other details for accounts corresponding to the customer named Meaghan Keeling?", "rationale": ["Identify the relevant tables: Accounts and Customers are needed to get account details for a specific customer.", "Join the Accounts table with the Customers table on the customer_id to link accounts to customers.", "Filter the results to only include the customer named Meaghan Keeling by using a WHERE clause that checks both first and last names.", "Select the desired columns from the Accounts table, which include account_id, account_name, date_account_opened, and other_account_details."], "gold_sql": "SELECT T1.account_name ,  T1.other_account_details FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  'Meaghan' AND T2.customer_last_name  =  'Keeling'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT A.account_id, A.account_name, A.date_account_opened, A.other_account_details \nFROM Accounts AS A \nJOIN Customers AS C ON A.customer_id = C.customer_id \nWHERE C.customer_first_name = 'Meaghan' AND C.customer_last_name = 'Keeling';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    }\n}\n"}
{"sample_id": "train.1558", "db_id": "customers_and_invoices", "question": "What are the full names of customers with the account name 900?", "rationale": ["The query needs to find the full names of customers with a specific account name, which is '900'.", "To achieve this, we will join the Accounts table (T1) with the Customers table (T2) using the customer_id as the foreign key.", "We will select the first name and last name from the Customers table and concatenate them to form the full name.", "We will filter the results using a WHERE clause to only include accounts with the name '900'."], "gold_sql": "SELECT T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.account_name  =  '900'", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT T2.customer_first_name || ' ' || T2.customer_last_name AS full_name \nFROM Accounts AS T1 \nJOIN Customers AS T2 ON T1.customer_id = T2.customer_id \nWHERE T1.account_name = '900'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    }\n}\n"}
{"sample_id": "train.1568", "db_id": "customers_and_invoices", "question": "Return the id and full name of the customer with the most accounts.", "rationale": ["The task is to find the customer with the most accounts, which requires counting the number of accounts associated with each customer.", "To achieve this, we can use a subquery that joins the Accounts table with the Customers table to get the customer details along with the count of accounts.", "The subquery will group the results by customer_id and count the number of accounts for each customer.", "After obtaining the counts, we will order the results in descending order based on the account count to get the customer with the most accounts at the top.", "Finally, we will limit the results to just one record to get the customer with the highest account count, and select their customer_id and full name (concatenating first and last names)."], "gold_sql": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["accounts", "customers"], "pred_sql": "SELECT customer_id, customer_first_name || ' ' || customer_last_name AS full_name \nFROM (\n    SELECT T1.customer_id, T2.customer_first_name, T2.customer_last_name, COUNT(*) AS account_count \n    FROM Accounts AS T1 \n    JOIN Customers AS T2 ON T1.customer_id = T2.customer_id \n    GROUP BY T1.customer_id\n) \nORDER BY account_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    }\n}\n"}
{"sample_id": "train.1579", "db_id": "customers_and_invoices", "question": "How many transaction does each account have? Show the number and account id.", "rationale": ["The question asks for the number of transactions associated with each account, along with the account ID.", "To get this information, we need to join the 'Financial_Transactions' table with the 'Accounts' table using the account_id as the common key.", "We will use a COUNT function to count the number of transactions for each account.", "The results should be grouped by account_id to ensure we get a count for each individual account.", "The hint provided a virtual table that summarizes this exact information, which we can use as a template for our SQL query."], "gold_sql": "SELECT count(*) ,  account_id FROM Financial_transactions", "source_tables": ["financial_transactions"], "pred_sql": "SELECT T2.account_name, T1.account_id, count(*) FROM Financial_Transactions AS T1 JOIN Accounts AS T2 ON T1.account_id = T2.account_id GROUP BY T1.account_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    }\n}\n"}
{"sample_id": "train.1589", "db_id": "customers_and_invoices", "question": "Show the account name, id and the number of transactions for each account.", "rationale": ["Identify the tables needed: Accounts and Financial_Transactions.", "We need to select the account name and account ID from the Accounts table.", "We also need to count the number of transactions associated with each account from the Financial_Transactions table.", "Join the Financial_Transactions table with the Accounts table on the account_id field.", "Group the results by account_id to get the count of transactions for each account."], "gold_sql": "SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id", "source_tables": ["accounts", "financial_transactions"], "pred_sql": "SELECT T2.account_name, T1.account_id, COUNT(*) AS number_of_transactions \nFROM Financial_Transactions AS T1 \nJOIN Accounts AS T2 ON T1.account_id = T2.account_id \nGROUP BY T1.account_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    }\n}\n"}
{"sample_id": "train.1599", "db_id": "customers_and_invoices", "question": "Show the invoice number and the number of transactions for each invoice.", "rationale": ["We need to show the invoice number and the number of transactions for each invoice.", "The relevant tables are Invoices and Financial_Transactions.", "We will join these two tables on the invoice_number field, as it is the common field between them.", "We will select the invoice_number from the Invoices table and count the transaction_id from the Financial_Transactions table to get the number of transactions for each invoice.", "Finally, we will group the results by invoice_number to ensure we get a count for each unique invoice."], "gold_sql": "SELECT invoice_number ,  count(*) FROM Financial_transactions GROUP BY invoice_number", "source_tables": ["financial_transactions"], "pred_sql": "SELECT I.invoice_number, COUNT(FT.transaction_id) AS number_of_transactions \nFROM Invoices AS I \nJOIN Financial_Transactions AS FT ON I.invoice_number = FT.invoice_number \nGROUP BY I.invoice_number;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, and last name, along with the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    }\n}\n"}
{"sample_id": "train.1602", "db_id": "customers_and_invoices", "question": "What is the invoice number and invoice date corresponding to the invoice with the greatest number of transactions?", "rationale": ["Identify the need to find the invoice number and date for the invoice with the greatest number of transactions.", "Utilize the Financial_Transactions table to count the number of transactions associated with each invoice.", "Group the results by invoice number and order them in descending order based on the count of transactions.", "Limit the results to get the invoice with the highest transaction count.", "Use a subquery to find the order_id corresponding to that invoice.", "Finally, select the invoice_number and invoice_date from the Invoices table where the order_id matches the one found in the subquery."], "gold_sql": "SELECT T2.invoice_number ,  T2.invoice_date FROM Financial_transactions AS T1 JOIN Invoices AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices", "financial_transactions"], "pred_sql": "SELECT invoice_number, invoice_date FROM Invoices WHERE order_id = (SELECT order_id FROM Financial_Transactions GROUP BY invoice_number ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of financial transactions associated with each account. It displays the account name and account ID from the 'Accounts' table, along with a count of transactions from the 'Financial_Transactions' table, grouped by account ID.\",\n        \"virtual_table\": \"SELECT T2.account_name ,  T1.account_id ,  count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id GROUP BY T1.account_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of order IDs and their corresponding details from the 'Orders' table, specifically for those orders that are associated with invoices. The results are grouped by order ID, and only those orders that have more than a specified number of associated invoices are included. The placeholder in the HAVING clause represents the minimum count of invoices required for an order to be displayed.\",\n        \"virtual_table\": \"SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.1617", "db_id": "customers_and_invoices", "question": "Show the order ids and the number of items in each order.", "rationale": ["The task is to show the order ids and the number of items in each order.", "To achieve this, we need to count the number of items associated with each order.", "The relevant table for this information is 'Order_Items', which contains 'order_id' and 'order_item_id'.", "We will use the COUNT function to count the 'order_item_id' for each 'order_id'.", "We will group the results by 'order_id' to get the count of items for each specific order."], "gold_sql": "SELECT order_id ,  count(*) FROM Order_items GROUP BY order_id", "source_tables": ["order_items"], "pred_sql": "SELECT order_id, COUNT(order_item_id) AS number_of_items FROM Order_Items GROUP BY order_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of distinct products associated with each order from the 'Order_Items' table. The placeholder in the SELECT clause represents the order identifier, while the count function calculates the unique product count for each order.\",\n        \"virtual_table\": \"SELECT order_id ,  count(DISTINCT product_id) FROM Order_items GROUP BY order_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of order IDs and their corresponding details from the 'Orders' table, specifically for those orders that are associated with invoices. The results are grouped by order ID, and only those orders that have more than a specified number of associated invoices are included. The placeholder in the HAVING clause represents the minimum count of invoices required for an order to be displayed.\",\n        \"virtual_table\": \"SELECT T2.order_id ,  T2.order_details FROM Invoices AS T1 JOIN Orders AS T2 ON T1.order_id  =  T2.order_id GROUP BY T2.order_id HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of customers who have accounts, displaying their unique customer ID, first name, last name, and the count of accounts associated with each customer. The placeholders represent the customer details and the count of accounts.\",\n        \"virtual_table\": \"SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name ,  count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id\"\n    }\n}\n"}
{"sample_id": "train.2049", "db_id": "party_people", "question": "Show all ministers who do not belong to Progress Party.", "rationale": ["Identify the relevant table: The 'party' table contains information about political parties and their associated ministers.", "Determine the required information: We need to select ministers who do not belong to the 'Progress Party'.", "Use a SELECT statement to retrieve the 'Minister' column from the 'party' table.", "Apply a WHERE clause to filter out the 'Progress Party' by checking that the 'Party_name' is not equal to 'Progress Party'.", "Use DISTINCT to ensure that each minister is listed only once in the result."], "gold_sql": "SELECT minister FROM party WHERE party_name != 'Progress Party'", "source_tables": ["party"], "pred_sql": "SELECT DISTINCT p.Minister FROM party AS p WHERE p.Party_name != 'Progress Party';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement represents the party's name, and the count function aggregates the total number of members for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    }\n}\n"}
{"sample_id": "train.2058", "db_id": "party_people", "question": "How many members are in each party?", "rationale": ["Identify the tables involved: We need to count members from the 'member' table and associate them with their respective parties from the 'party' table.", "Determine the relationship: The 'member' table has a foreign key 'Party_ID' that links to the 'party' table's 'Party_ID'.", "Use a JOIN operation: We will join the 'member' table (aliased as T1) with the 'party' table (aliased as T2) on the 'Party_ID'.", "Count the members: We will use the COUNT function to count the number of members for each party.", "Group by party: To get the count per party, we will group the results by 'Party_ID' from the 'party' table.", "Select the party name and count: The final output will include the party name and the count of members, which we will alias as 'Member_Count'."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "member"], "pred_sql": "SELECT T2.Party_name, COUNT(*) AS Member_Count FROM member AS T1 JOIN party AS T2 ON T1.Party_ID = T2.Party_ID GROUP BY T2.Party_ID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement represents the party's name, and the count function aggregates the total number of members for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    }\n}\n"}
{"sample_id": "train.2071", "db_id": "party_people", "question": "Show party names and the number of events for each party.", "rationale": ["The task is to show party names and the number of events for each party.", "We need to retrieve data from the 'party_events' table to count the number of events.", "To get the party names, we will join the 'party' table with the 'party_events' table using the Party_ID.", "The SQL query will use the COUNT function to aggregate the total number of events for each party.", "We will group the results by Party_ID to ensure we get a count for each individual party."], "gold_sql": "SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id", "source_tables": ["party", "party_events"], "pred_sql": "SELECT T2.party_name, count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id = T2.party_id GROUP BY T1.party_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the number of members associated with each political party from the 'Member' and 'Party' tables. The placeholder in the SELECT statement represents the party's name, and the count function aggregates the total number of members for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM Member AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    }\n}\n"}
{"sample_id": "train.2081", "db_id": "party_people", "question": "How many Annual Meeting events happened in the United Kingdom region?", "rationale": ["Identify the relevant tables: party_events, party, and region.", "We need to count the number of events, so we will use the COUNT() function.", "Join the party_events table with the party table to get the party names associated with the events.", "Join the resulting table with the region table to filter by the United Kingdom region.", "Add a WHERE clause to filter for events specifically named 'Annual Meeting'.", "Finally, use COUNT(*) to get the total number of Annual Meeting events in the United Kingdom."], "gold_sql": "SELECT count(*) FROM region AS t1 JOIN party AS t2 ON t1.region_id  =  t2.region_id JOIN party_events AS t3 ON t2.party_id  =  t3.party_id WHERE t1.region_name  =  'United Kingdom' AND t3.Event_Name  =  'Annaual Meeting'", "source_tables": ["party", "party_events", "region"], "pred_sql": "SELECT COUNT(*) FROM party_events AS T1 JOIN party AS T2 ON T1.Party_ID = T2.Party_ID JOIN region AS T3 ON T2.Region_ID = T3.Region_ID WHERE T1.Event_Name = 'Annual Meeting' AND T3.Region_name = 'United Kingdom'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of events organized by each political party from the 'party_events' table. It joins the 'party' table to retrieve the party names associated with the events. The placeholder in the SELECT clause represents the party name, while the count function aggregates the total number of events for each party.\",\n        \"virtual_table\": \"SELECT T2.party_name ,  count(*) FROM party_events AS T1 JOIN party AS T2 ON T1.party_id  =  T2.party_id GROUP BY T1.party_id\"\n    }\n}\n"}
{"sample_id": "train.2176", "db_id": "formula_1", "question": "What are the names and years of all races that had a driver with the last name Lewis?", "rationale": ["Identify the tables needed: races, results, and drivers.", "We need to select the names and years of races, so we will select 'races.name' and 'races.year'.", "To find the relevant races, we need to join the 'races' table with the 'results' table on 'raceId'.", "Next, we join the 'results' table with the 'drivers' table on 'driverId' to access driver information.", "We filter the results to include only those where the driver's surname is 'Lewis'."], "gold_sql": "SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = 'Lewis'", "source_tables": ["results", "drivers", "races"], "pred_sql": "SELECT races.name, races.year FROM races JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE drivers.surname = 'Lewis';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2182", "db_id": "formula_1", "question": "What are the first and last names of all drivers who participated in the Australian Grand Prix but not the Chinese Grand Prix?", "rationale": ["Identify the races of interest: Australian Grand Prix and Chinese Grand Prix.", "Use a SQL query to select the first and last names of drivers who participated in the Australian Grand Prix.", "Utilize the EXCEPT clause to exclude those drivers who also participated in the Chinese Grand Prix.", "Join the races, results, and drivers tables to get the required information about the drivers.", "Construct the final SQL query using the provided virtual table structure."], "gold_sql": "SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Chinese Grand Prix'", "source_tables": ["races", "drivers", "results"], "pred_sql": "SELECT T3.forename, T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T1.name = 'Australian Grand Prix' EXCEPT SELECT T3.forename, T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T1.name = 'Chinese Grand Prix'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2183", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who was in position 1 as standing and won?", "rationale": ["We need to find distinct drivers who were in position 1 as standing and won.", "To do this, we will join the 'results' table with the 'drivers' table to get the forenames of the drivers.", "We also need to join the 'driverStandings' table to filter for those who were in position 1 and had wins.", "The condition for position is 'T4.position = 1' and for wins is 'T4.wins > 0'.", "Finally, we select distinct forenames from the results."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT T3.forename FROM results AS T2 JOIN drivers AS T3 ON T2.driverId = T3.driverId JOIN driverStandings AS T4 ON T2.raceId = T4.raceId WHERE T4.position = 1 AND T4.wins > 0;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2185", "db_id": "formula_1", "question": "Find all the forenames of distinct drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["We need to find distinct drivers who won in position 1 and had more than 20 points.", "The relevant table for driver standings is 'driverStandings', which contains the position and points for each driver in a race.", "We will join the 'driverStandings' table with the 'drivers' table to get the forenames of the drivers.", "We filter the results where the position is 1 and points are greater than 20.", "Finally, we select distinct forenames to avoid duplicates."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM driverStandings ds \nJOIN drivers d ON ds.driverId = d.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2186", "db_id": "formula_1", "question": "What are the first names of the different drivers who won in position 1 as driver standing and had more than 20 points?", "rationale": ["We need to find the first names of drivers who won in position 1 as per driver standings and had more than 20 points.", "To achieve this, we will join the 'results' table with the 'driverStandings' table on the driverId to get the standings of each driver.", "Next, we will join the 'drivers' table to get the first names of these drivers.", "We will filter the results where the position in driver standings is 1 and the points are greater than 20.", "Finally, we will select distinct first names to avoid duplicates."], "gold_sql": "SELECT DISTINCT T1.forename FROM drivers AS T1 JOIN driverstandings AS T2 ON T1.driverid = T2.driverid WHERE T2.position = 1 AND T2.wins = 1 AND T2.points > 20", "source_tables": ["drivers", "driverstandings"], "pred_sql": "SELECT DISTINCT d.forename \nFROM results AS r \nJOIN driverStandings AS ds ON r.driverId = ds.driverId \nJOIN drivers AS d ON r.driverId = d.driverId \nWHERE ds.position = 1 AND ds.points > 20;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of drivers who participated in a specific race, excluding those who also participated in another specified race. The placeholders in the WHERE clause represent the names of the races.\",\n        \"virtual_table\": \"SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T3.forename ,  T3.surname FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2189", "db_id": "formula_1", "question": "What are the numbers of races for each constructor id?", "rationale": ["The question asks for the number of races for each constructor id.", "To get this information, we need to count the number of races associated with each constructor.", "The relevant table for this information is 'constructorResults', which links constructors to races.", "We will use the COUNT function to count the occurrences of raceId for each constructorId.", "We will group the results by constructorId to get the count for each constructor."], "gold_sql": "SELECT count(*) ,  constructorid FROM constructorStandings GROUP BY constructorid", "source_tables": ["constructorstandings"], "pred_sql": "SELECT constructorId, COUNT(raceId) AS number_of_races FROM constructorResults GROUP BY constructorId;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table counts the distinct number of drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.\",\n        \"virtual_table\": \"SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "train.2218", "db_id": "formula_1", "question": "What are the names of all the Japanese constructors that have earned more than 5 points?", "rationale": ["Identify the relevant tables: constructors and constructorResults.", "We need to find constructors that are Japanese, so we will filter by nationality in the constructors table.", "We also need to check the points earned by these constructors, which is found in the constructorResults table.", "Join the constructors table with the constructorResults table on the constructorId to access both sets of information.", "Apply the filters for nationality and points in the WHERE clause."], "gold_sql": "SELECT T1.name FROM constructors AS T1 JOIN constructorstandings AS T2 ON T1.constructorid = T2.constructorid WHERE T1.nationality = 'Japanese' AND T2.points > 5", "source_tables": ["constructorstandings", "constructors"], "pred_sql": "SELECT c.name \nFROM constructors AS c \nJOIN constructorResults AS cr ON c.constructorId = cr.constructorId \nWHERE c.nationality = 'Japanese' \nAND cr.points > 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2220", "db_id": "formula_1", "question": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: 'races' for race details and 'results' for fastest lap speeds.", "We need to find the average fastest lap speed for a specific race, which is the Monaco Grand Prix in 2008.", "Join the 'races' table with the 'results' table on the raceId to access both race and result data.", "Filter the results to only include those from the Monaco Grand Prix in 2008 using a WHERE clause.", "Use the AVG() function to calculate the average of the fastest lap speeds from the results."], "gold_sql": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(T2.fastestLapSpeed) AS average_fastest_lap_speed \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nWHERE T1.name = 'Monaco Grand Prix' AND T1.year = 2008;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2221", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?", "rationale": ["Identify the relevant tables: 'races' for race details and 'results' for fastest lap speeds.", "We need to find the maximum fastest lap speed for a specific race, so we will join the 'races' table with the 'results' table on 'raceId'.", "Filter the results to only include the race named 'Monaco Grand Prix' in the year 2008 using a WHERE clause.", "Select the maximum value of 'fastestLapSpeed' from the results of the joined tables."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT max(T2.fastestLapSpeed) FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.name = 'Monaco Grand Prix' AND T1.year = 2008", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2222", "db_id": "formula_1", "question": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?", "rationale": ["Identify the relevant tables: 'races' for race details and 'results' for fastest lap speeds.", "We need to find the maximum fastest lap speed for a specific race, which is the Monaco Grand Prix in 2008.", "Join the 'races' table with the 'results' table on the raceId to access both race and result data.", "Filter the results to only include the Monaco Grand Prix in 2008 using the WHERE clause.", "Select the maximum value of the fastest lap speed from the results table."], "gold_sql": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'", "source_tables": ["races", "results"], "pred_sql": "SELECT max(T2.fastestLapSpeed) AS max_fastest_lap_speed \nFROM races AS T1 \nJOIN results AS T2 ON T1.raceId = T2.raceId \nWHERE T1.name = 'Monaco Grand Prix' AND T1.year = 2008;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2224", "db_id": "formula_1", "question": "For each race name, What is the maximum fastest lap speed for races after 2004 ordered by year?", "rationale": ["Identify the tables needed: 'races' for race names and years, and 'results' for fastest lap speeds.", "Join the 'races' table with the 'results' table on the raceId to access both race names and their corresponding fastest lap speeds.", "Filter the results to include only races that occurred after the year 2004 using a WHERE clause.", "Use the MAX function to find the maximum fastest lap speed for each race.", "Group the results by race name to ensure we get the maximum speed for each race individually.", "Order the final results by year to present them in chronological order."], "gold_sql": "SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT max(T2.fastestLapSpeed), T1.name, T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.year > 2004 GROUP BY T1.name ORDER BY T1.year", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2225", "db_id": "formula_1", "question": "What are the average fastest lap speed in races held after 2004 grouped by race name and ordered by year?", "rationale": ["Identify the tables needed: We need data from the 'races' table for race names and years, and from the 'results' table for fastest lap speeds.", "Join the 'races' table with the 'results' table on the raceId to combine race information with results.", "Filter the results to include only races held after 2004 using a WHERE clause.", "Calculate the average fastest lap speed using AVG() function and group the results by race name and year.", "Order the final results by year to get a chronological list."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(T2.fastestLapSpeed) AS average_fastest_lap_speed, T1.name, T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.year > 2004 GROUP BY T1.name ORDER BY T1.year", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2226", "db_id": "formula_1", "question": "What is the average fastest lap speed for races held after 2004, for each race, ordered by year?", "rationale": ["Identify the tables needed: We need data from the 'races' table for the year and the 'results' table for the fastest lap speed.", "Join the 'races' table with the 'results' table on 'raceId' to combine race information with results.", "Filter the races to include only those held after 2004 using a WHERE clause.", "Calculate the average fastest lap speed using AVG() function and group the results by year to get the average for each year.", "Order the results by year to present them in chronological order."], "gold_sql": "SELECT avg(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > 2014 GROUP BY T1.name ORDER BY T1.year", "source_tables": ["races", "results"], "pred_sql": "SELECT AVG(T2.fastestLapSpeed) AS average_fastest_lap_speed, T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T1.year > 2004 GROUP BY T1.year ORDER BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum fastest lap speed recorded for each race, along with the official name of the race and the year it took place. The placeholder in the WHERE clause represents the year threshold for filtering the races.\",\n        \"virtual_table\": \"SELECT max(T2.fastestlapspeed) ,  T1.name ,  T1.year FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year > [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.name ORDER BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the distinct number of drivers who participated in races, excluding those that took place in a specific year. The placeholder in the WHERE clause represents the year to filter out races.\",\n        \"virtual_table\": \"SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the unique identifiers and first names of drivers who participated in two specific races, identified by their names. The placeholders in the WHERE clause represent the names of the races being queried.\",\n        \"virtual_table\": \"SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.driverid ,  T3.forename FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T2.driverid  =  T3.driverid WHERE T1.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2243", "db_id": "machine_repair", "question": "What is the starting year of the oldest technicians?", "rationale": ["Identify the relevant table: The 'technician' table contains the 'Starting_Year' column which is needed to find the oldest technician.", "Use the MIN() function to find the earliest starting year from the 'Starting_Year' column.", "Construct the SQL query to select the minimum starting year from the 'technician' table."], "gold_sql": "SELECT Starting_Year FROM technician ORDER BY Age DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT MIN(Starting_Year) AS Oldest_Starting_Year FROM technician;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the starting years of technicians from the 'technician' table who belong to two specific teams. The placeholders in the WHERE clause represent the identifiers for the teams being compared.\",\n        \"virtual_table\": \"SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the number of repair assignments handled by each technician. It joins the 'repair_assignment' table with the 'technician' table to associate each assignment with the technician's name. The result is grouped by the technician's name, allowing for a count of assignments per technician.\",\n        \"virtual_table\": \"SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name\"\n    }\n}\n"}
{"sample_id": "train.2248", "db_id": "machine_repair", "question": "What are the teams with the most technicians?", "rationale": ["We need to find the teams with the most technicians.", "To do this, we will count the number of technicians in each team.", "We will use the COUNT() function to count the technicians grouped by their team.", "The GROUP BY clause will be used to group the results by the 'Team' column in the technician table.", "Finally, we will order the results in descending order to show the teams with the most technicians at the top."], "gold_sql": "SELECT Team FROM technician GROUP BY Team ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["technician"], "pred_sql": "SELECT Team, COUNT(*) AS technician_count FROM technician GROUP BY Team ORDER BY technician_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the starting years of technicians from the 'technician' table who belong to two specific teams. The placeholders in the WHERE clause represent the identifiers for the teams being compared.\",\n        \"virtual_table\": \"SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the number of repair assignments handled by each technician. It joins the 'repair_assignment' table with the 'technician' table to associate each assignment with the technician's name. The result is grouped by the technician's name, allowing for a count of assignments per technician.\",\n        \"virtual_table\": \"SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name\"\n    }\n}\n"}
{"sample_id": "train.2258", "db_id": "machine_repair", "question": "What are the names of the technicians  and how many machines are they assigned to repair?", "rationale": ["Identify the tables involved: We need to get technician names and the count of machines they are assigned to repair, which involves the 'technician' and 'repair_assignment' tables.", "Join the tables: We will join the 'repair_assignment' table with the 'technician' table on the technician ID to associate each repair assignment with the technician's name.", "Count the assignments: We will use COUNT(*) to count the number of repair assignments for each technician.", "Group by technician name: To get the count per technician, we will group the results by the technician's name."], "gold_sql": "SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name", "source_tables": ["repair_assignment", "technician"], "pred_sql": "SELECT T2.Name, COUNT(*) AS Machine_Count FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_id = T2.technician_id GROUP BY T2.Name", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the number of repair assignments handled by each technician. It joins the 'repair_assignment' table with the 'technician' table to associate each assignment with the technician's name. The result is grouped by the technician's name, allowing for a count of assignments per technician.\",\n        \"virtual_table\": \"SELECT T2.Name ,  COUNT(*) FROM repair_assignment AS T1 JOIN technician AS T2 ON T1.technician_ID  =  T2.technician_ID GROUP BY T2.Name\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the starting years of technicians from the 'technician' table who belong to two specific teams. The placeholders in the WHERE clause represent the identifiers for the teams being compared.\",\n        \"virtual_table\": \"SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT Starting_Year FROM technician WHERE Team  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.2328", "db_id": "csu_1", "question": "Find all the campuses opened in 1958.", "rationale": ["Identify the relevant table: The question asks about campuses, which are listed in the 'Campuses' table.", "Determine the filtering criteria: The question specifies campuses opened in the year 1958, so we need to filter by the 'Year' column.", "Construct the SQL query: We will select all relevant columns from the 'Campuses' table where the 'Year' is equal to '1958'."], "gold_sql": "SELECT campus FROM campuses WHERE YEAR  =  1958", "source_tables": ["campuses"], "pred_sql": "SELECT Id, Campus, Location, County, Year FROM Campuses WHERE Year = '1958'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2334", "db_id": "csu_1", "question": "Find the name of the campuses that is in Northridge, Los Angeles or in San Francisco, San Francisco.", "rationale": ["Identify the relevant tables: The question pertains to the 'Campuses' table, which contains information about campus names and their locations.", "Determine the conditions: The campuses need to be in either 'Northridge, Los Angeles' or 'San Francisco, San Francisco'.", "Use the UNION operator to combine results from two SELECT statements: One for each location and county combination.", "Construct the first SELECT statement to find campuses in Northridge, Los Angeles: SELECT Campus FROM Campuses WHERE Location = 'Northridge' AND County = 'Los Angeles'.", "Construct the second SELECT statement to find campuses in San Francisco, San Francisco: SELECT Campus FROM Campuses WHERE Location = 'San Francisco' AND County = 'San Francisco'.", "Combine both SELECT statements using UNION to get the final result."], "gold_sql": "SELECT campus FROM campuses WHERE LOCATION  =  'Northridge' AND county  =  'Los Angeles' UNION SELECT campus FROM campuses WHERE LOCATION  =  'San Francisco' AND county  =  'San Francisco'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE Location = 'Northridge' AND County = 'Los Angeles' UNION SELECT Campus FROM Campuses WHERE Location = 'San Francisco' AND County = 'San Francisco'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the names of campuses from the 'Campuses' table that are located in a specific geographical location and county. The query uses placeholders for the location and county to allow for flexible input.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2350", "db_id": "csu_1", "question": "Which campus has the most faculties in year 2003?", "rationale": ["Identify the relevant tables: Campuses and faculty.", "Join the Campuses table with the faculty table on the campus identifier.", "Filter the results for the year 2003 using the WHERE clause.", "Order the results by the number of faculty members in descending order to get the campus with the most faculty.", "Limit the results to 1 to get only the campus with the highest number of faculty."], "gold_sql": "SELECT T1.campus FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  T2.campus WHERE T2.year  =  2003 ORDER BY T2.faculty DESC LIMIT 1", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT T1.Campus, T2.Faculty FROM Campuses AS T1 JOIN faculty AS T2 ON T1.Id = T2.Campus WHERE T2.Year = 2003 ORDER BY T2.Faculty DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2356", "db_id": "csu_1", "question": "report the total number of degrees granted between 1998 and 2002.", "rationale": ["Identify the relevant tables: 'Campuses' and 'degrees'.", "We need to sum the total number of degrees awarded, so we will use the SUM function on the 'Degrees' column from the 'degrees' table.", "We need to filter the results based on the year range from 1998 to 2002, which will be done using a WHERE clause.", "Join the 'Campuses' table with the 'degrees' table on the campus identifier to ensure we are counting degrees awarded at each campus.", "Construct the SQL query to select the sum of degrees for the specified year range."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  1998 AND T2.year  <=  2002 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(T2.Degrees) FROM Campuses AS T1 JOIN degrees AS T2 ON T1.Id = T2.Campus WHERE T2.Year >= '1998' AND T2.Year <= '2002'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2359", "db_id": "csu_1", "question": "What is the total number of degrees granted after 2000 for each Orange county campus?", "rationale": ["Identify the relevant tables: Campuses and degrees.", "We need to join these tables on the campus identifier (Id in Campuses and Campus in degrees).", "Filter the results to include only campuses in Orange county.", "Filter the degrees awarded to include only those granted after the year 2000.", "Group the results by campus to get the total number of degrees for each campus."], "gold_sql": "SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  'Orange' AND T2.year  >=  2000 GROUP BY T1.campus", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT T1.Campus, SUM(T2.Degrees) FROM Campuses AS T1 JOIN degrees AS T2 ON T1.Id = T2.Campus WHERE T1.County = 'Orange' AND T2.Year >= '2000' GROUP BY T1.Campus", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2362", "db_id": "csu_1", "question": "What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?", "rationale": ["Identify the relevant table for total enrollments, which is the 'enrollments' table.", "Filter the records for the year 1956 by using a WHERE clause on the 'Year' column.", "Add conditions to filter campuses with total enrollment greater than 400 and full-time equivalent (FTE) enrollment greater than 200 using additional WHERE clauses."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT e.Campus \nFROM enrollments AS e \nWHERE e.Year = '1956' \nAND e.TotalEnrollment_AY > 400 \nAND e.FTE_AY > 200;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2363", "db_id": "csu_1", "question": "What campus started in year 1956, has more than 200 full time students, and more than 400 students enrolled?", "rationale": ["Identify the relevant tables: Campuses and enrollments.", "We need to filter campuses based on the year they started, which is in the Campuses table.", "We also need to check for the number of full-time students (FTE_AY) and total enrollments (TotalEnrollment_AY) from the enrollments table.", "Join the Campuses table with the enrollments table on the campus identifier.", "Apply the filters: year = 1956, FTE_AY > 200, and TotalEnrollment_AY > 400."], "gold_sql": "SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200", "source_tables": ["enrollments", "campuses"], "pred_sql": "SELECT c.Campus \nFROM Campuses c \nJOIN enrollments e ON c.Id = e.Campus \nWHERE c.Year = '1956' \nAND e.TotalEnrollment_AY > '400' \nAND e.FTE_AY > '200';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2366", "db_id": "csu_1", "question": "List the campuses in Los Angeles county.", "rationale": ["Identify the relevant table: The 'Campuses' table contains information about campuses, including their location and county.", "Determine the filtering criteria: We need to filter campuses based on the county, specifically 'Los Angeles'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Campus' column from the 'Campuses' table where the 'County' matches 'Los Angeles'."], "gold_sql": "SELECT campus FROM campuses WHERE county  =  'Los Angeles'", "source_tables": ["campuses"], "pred_sql": "SELECT Campus FROM Campuses WHERE County = 'Los Angeles'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the names of campuses from the 'Campuses' table that are located in a specific geographical location and county. The query uses placeholders for the location and county to allow for flexible input.\",\n        \"virtual_table\": \"SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT campus FROM campuses WHERE LOCATION  =  [PLACEHOLDER-TYPE:STRING] AND county  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2368", "db_id": "csu_1", "question": "How many degrees were conferred in \"San Jose State University\" in 2000?", "rationale": ["Identify the relevant tables: 'Campuses' for campus information and 'degrees' for degree information.", "Join the 'Campuses' table with the 'degrees' table on the campus identifier.", "Filter the results to include only records for 'San Jose State University'.", "Further filter the results to include only degrees conferred in the year 2000.", "Use the SUM function to calculate the total number of degrees conferred."], "gold_sql": "SELECT degrees FROM campuses AS T1 JOIN degrees AS T2 ON t1.id  =  t2.campus WHERE t1.campus  =  'San Jose State University' AND t2.year  =  2000", "source_tables": ["degrees", "campuses"], "pred_sql": "SELECT SUM(T2.Degrees) FROM Campuses AS T1 JOIN degrees AS T2 ON T1.Id = T2.Campus WHERE T1.Campus = 'San Jose State University' AND T2.Year = '2000'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2374", "db_id": "csu_1", "question": "What is the number of faculty lines in campus \"Long Beach State University\" in 2002?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to filter by campus name.", "Filter the results to only include records for 'Long Beach State University' and the year 2002.", "Count the number of faculty lines for the specified campus and year."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2002 AND T2.campus  =  'Long Beach State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) FROM faculty AS t2 JOIN Campuses AS t1 ON t1.Id = t2.Campus WHERE t1.Campus = 'Long Beach State University' AND t2.Year = 2002;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2376", "db_id": "csu_1", "question": "How many faculty lines are there in \"San Francisco State University\" in year 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus names.", "Join the 'faculty' table with the 'Campuses' table on the campus identifier to filter by campus name.", "Filter the results to only include records for 'San Francisco State University'.", "Further filter the results to only include records for the year 2004.", "Count the number of faculty lines that meet these criteria."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) FROM faculty AS t2 JOIN Campuses AS t1 ON t1.Id = t2.Campus WHERE t1.Campus = 'San Francisco State University' AND t2.Year = 2004;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2377", "db_id": "csu_1", "question": "How many faculty lines are there at San Francisco State University in 2004?", "rationale": ["Identify the relevant tables: 'faculty' for faculty data and 'Campuses' for campus identification.", "We need to filter the faculty data for a specific campus ('San Francisco State University') and a specific year (2004).", "Use a subquery to find the Id of 'San Francisco State University' from the 'Campuses' table.", "Count the number of faculty lines for that specific campus and year using COUNT(*) in the main query."], "gold_sql": "SELECT faculty FROM faculty AS T1 JOIN campuses AS T2 ON T1.campus  =  T2.id WHERE T1.year  =  2004 AND T2.campus  =  'San Francisco State University'", "source_tables": ["faculty", "campuses"], "pred_sql": "SELECT COUNT(*) FROM faculty WHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Francisco State University') AND Year = 2004;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the campuses from the 'Campuses' table that have a number of faculty members within a specified range. The query joins the 'Campuses' table with the 'faculty' table based on the campus identifier, and filters the results based on the number of faculty members and the year of the data record. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the specific year.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2381", "db_id": "csu_1", "question": "How many faculty members did the university that conferred the most degrees in 2002 have?", "rationale": ["Identify the year of interest, which is 2002, for the degrees awarded.", "Determine which campus conferred the most degrees in 2002 by summing the degrees awarded and grouping by campus.", "Use a subquery to find the campus with the maximum number of degrees awarded in 2002.", "Join the faculty table to get the number of faculty members for that specific campus.", "Select the faculty count for the campus that conferred the most degrees in 2002."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2002 ORDER BY t3.degrees DESC LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT f.Faculty \nFROM faculty AS f \nJOIN degrees AS d ON f.Campus = d.Campus \nWHERE d.Year = '2002' \nAND d.Campus = (SELECT d.Campus \n                FROM degrees AS d \n                WHERE d.Year = '2002' \n                GROUP BY d.Campus \n                ORDER BY SUM(d.Degrees) DESC \n                LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2382", "db_id": "csu_1", "question": "How many faculty lines are there in the university that conferred the least number of degrees in year 2001?", "rationale": ["Identify the year of interest, which is 2001.", "Use the degrees table to find the campus that conferred the least number of degrees in 2001.", "Group the results by campus and order them by the sum of degrees in ascending order to find the campus with the least degrees.", "Limit the result to 1 to get only the campus with the least degrees.", "Use the faculty table to count the number of faculty lines for that specific campus."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(*) FROM faculty WHERE campus = (SELECT T1.campus FROM campuses AS T1 JOIN degrees AS T2 ON T1.id = T2.campus WHERE T2.year = 2001 GROUP BY T1.campus ORDER BY SUM(T2.degrees) ASC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2383", "db_id": "csu_1", "question": "How many faculty members are at the university that gave the least number of degrees in 2001?", "rationale": ["Identify the year of interest, which is 2001.", "Use the degrees table to find the total number of degrees awarded by each campus in 2001.", "Group the results by campus and sum the degrees awarded to get the total degrees per campus.", "Order the campuses by the total degrees in ascending order to find the campus with the least degrees awarded.", "Limit the results to 1 to get only the campus with the least degrees.", "Join this result with the faculty table to find the number of faculty members at that campus.", "Count the number of faculty members for the campus that awarded the least degrees."], "gold_sql": "SELECT T2.faculty FROM campuses AS T1 JOIN faculty AS T2 ON T1.id  =  t2.campus JOIN degrees AS T3 ON T1.id  =  t3.campus AND t2.year  =  t3.year WHERE t2.year  =  2001 ORDER BY t3.degrees LIMIT 1", "source_tables": ["faculty", "degrees", "campuses"], "pred_sql": "SELECT COUNT(faculty.Faculty) FROM faculty AS faculty JOIN (SELECT T1.Campus, SUM(T2.Degrees) AS TotalDegrees FROM campuses AS T1 JOIN degrees AS T2 ON T1.Id = T2.Campus WHERE T2.Year = '2001' GROUP BY T1.Campus ORDER BY TotalDegrees ASC LIMIT 1) AS LeastDegrees ON faculty.Campus = LeastDegrees.Campus;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2385", "db_id": "csu_1", "question": "How many undergraduates are there at San Jose State", "rationale": ["Identify the relevant table for undergraduate enrollments, which is 'discipline_enrollments'.", "Determine the specific campus of interest, which is 'San Jose State'.", "Use a subquery to find the 'Id' of 'San Jose State' from the 'Campuses' table.", "Filter the 'discipline_enrollments' table by the campus 'Id' obtained from the subquery.", "Sum the 'Undergraduate' column to get the total number of undergraduates at 'San Jose State'."], "gold_sql": "SELECT sum(t1.undergraduate) FROM discipline_enrollments AS t1 JOIN campuses AS t2 ON t1.campus  =  t2.id WHERE t1.year  =  2004 AND t2.campus  =  'San Jose State University'", "source_tables": ["discipline_enrollments", "campuses"], "pred_sql": "SELECT SUM(Undergraduate) AS Total_Undergraduates FROM discipline_enrollments WHERE Campus = (SELECT Id FROM Campuses WHERE Campus = 'San Jose State')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the campuses that have a number of faculty members within a specified range for a given year. The placeholders in the WHERE clause represent the minimum and maximum number of faculty members, as well as the year of interest.\",\n        \"virtual_table\": \"SELECT T1.campus FROM campuses AS t1 JOIN faculty AS t2 ON t1.id  =  t2.campus WHERE t2.faculty  >=  [PLACEHOLDER-TYPE:NUMBER] AND t2.faculty  <=  [PLACEHOLDER-TYPE:NUMBER] AND T1.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded for each campus over a specified range of years. The placeholders in the WHERE clause represent the start and end years for filtering the degree records.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] AND T2.year  <=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of degrees awarded by campus for a specific county and year range. The placeholders in the WHERE clause represent the county name and the minimum year for filtering the data.\",\n        \"virtual_table\": \"SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  [PLACEHOLDER-TYPE:STRING] AND T2.year  >=  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.campus\"\n    }\n}\n"}
{"sample_id": "train.2397", "db_id": "candidate_poll", "question": "Return the poll resource associated with the most candidates.", "rationale": ["We need to find the poll resource associated with the most candidates.", "To do this, we will select the 'Poll_Source' from the 'candidate' table.", "We will count the number of candidates associated with each 'Poll_Source' using COUNT(*).", "We will group the results by 'Poll_Source' to aggregate the counts for each source.", "Finally, we will order the results in descending order based on the count of candidates and limit the result to 1 to get the source with the most candidates."], "gold_sql": "SELECT poll_source FROM candidate GROUP BY poll_source ORDER BY count(*) DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source, COUNT(*) as Candidate_Count FROM candidate GROUP BY Poll_Source ORDER BY Candidate_Count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n        \"virtual_table\": \"SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n        \"virtual_table\": \"SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate\"\n    }\n}\n"}
{"sample_id": "train.2405", "db_id": "candidate_poll", "question": "Return the poll source corresponding to the candidate who has the oppose rate.", "rationale": ["Identify the relevant table: The 'candidate' table contains the 'Poll_Source' and 'Oppose_rate' columns.", "Determine the condition: We need to find the poll source for candidates who have an oppose rate, which implies we are looking for records where 'Oppose_rate' is not null.", "Construct the SQL query: We will select 'Poll_Source' from the 'candidate' table where 'Oppose_rate' is not null."], "gold_sql": "SELECT poll_source FROM candidate ORDER BY oppose_rate DESC LIMIT 1", "source_tables": ["candidate"], "pred_sql": "SELECT Poll_Source FROM candidate WHERE Oppose_rate IS NOT NULL", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n        \"virtual_table\": \"SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n        \"virtual_table\": \"SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate\"\n    }\n}\n"}
{"sample_id": "train.2417", "db_id": "candidate_poll", "question": "For each sex, what is the name and sex of the candidate with the oppose rate for their sex?", "rationale": ["Identify the relevant tables: 'candidate' for candidate data and 'people' for personal details.", "We need to join the 'candidate' table with the 'people' table using the foreign key 'People_ID'.", "We want to select the name and sex of candidates along with their oppose rate.", "The query should filter candidates based on their sex, so we will use a subquery to get distinct sexes from the 'people' table.", "Finally, we will order the results by sex to group them accordingly."], "gold_sql": "SELECT t1.name ,  t1.sex ,  min(oppose_rate) FROM people AS t1 JOIN candidate AS t2 ON t1.people_id  =  t2.people_id GROUP BY t1.sex", "source_tables": ["candidate", "people"], "pred_sql": "SELECT p.Name, p.Sex, c.Oppose_rate \nFROM candidate c \nJOIN people p ON c.People_ID = p.People_ID \nWHERE p.Sex IN (SELECT DISTINCT Sex FROM people) \nORDER BY p.Sex;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n        \"virtual_table\": \"SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the support, consideration, and opposition rates of candidates from the 'candidate' table, ordered by the rate of respondents who are unsure about the candidates. The placeholders in the SELECT clause represent the respective rates of support, consideration, and opposition.\",\n        \"virtual_table\": \"SELECT Support_rate ,  Consider_rate ,  Oppose_rate FROM candidate ORDER BY unsure_rate\"\n    }\n}\n"}
{"sample_id": "train.2434", "db_id": "movie_1", "question": "Find the titles of all movies directed by steven spielberg.", "rationale": ["Identify the relevant table: The 'Movie' table contains the information about movie titles and directors.", "Determine the required columns: We need the 'title' of the movies directed by 'steven spielberg'.", "Formulate the SQL query: Use a SELECT statement to retrieve the 'title' from the 'Movie' table where the 'director' matches 'steven spielberg'."], "gold_sql": "SELECT title FROM Movie WHERE director = 'Steven Spielberg'", "source_tables": ["movie"], "pred_sql": "SELECT title FROM Movie WHERE director = 'steven spielberg'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the titles and directors of movies from the 'Movie' table that have the same director but different titles. The query uses a self-join on the 'Movie' table to compare movies directed by the same person, ensuring that the titles are not the same. The results are ordered by the director's name and the movie title.\",\n        \"virtual_table\": \"SELECT T1.title ,  T1.director FROM Movie AS T1 JOIN Movie AS T2 ON T1.director  =  T2.director WHERE T1.title != T2.title ORDER BY T1.director ,  T1.title\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2461", "db_id": "movie_1", "question": "What are the different names of all reviewers whose ratings do not have a date field?", "rationale": ["Identify the tables involved: We need to get reviewer names from the Reviewer table and check their ratings in the Rating table.", "We need to find reviewers whose ratings do not have a date field, which means we are looking for records in the Rating table where the ratingDate is NULL.", "To get the names of the reviewers, we will join the Reviewer table with the Rating table on the rID field.", "We will use a SELECT DISTINCT statement to ensure that we only get unique reviewer names."], "gold_sql": "SELECT DISTINCT name FROM Reviewer AS T1 JOIN Rating AS T2 ON T1.rID  =  T2.rID WHERE ratingDate  =  'null'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT DISTINCT R.name \nFROM Reviewer AS R \nJOIN Rating AS T1 ON R.rID = T1.rID \nWHERE T1.ratingDate IS NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the average star ratings of movies from the 'Rating' table, excluding those rated by a specific reviewer. The placeholder in the subquery represents the reviewer's name whose ratings are to be excluded.\",\n        \"virtual_table\": \"SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]) GROUP BY mID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the average star ratings of movies from the 'Rating' table, excluding those rated by a specific reviewer. The placeholder in the subquery represents the reviewer's name whose ratings are to be excluded.\",\n        \"virtual_table\": \"SELECT mID ,  avg(stars) FROM Rating WHERE mID NOT IN (SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING]) GROUP BY mID\"\n    }\n}\n"}
{"sample_id": "train.2476", "db_id": "movie_1", "question": "Find the names of all reviewers who rated Gone with the Wind.", "rationale": ["Identify the tables involved: We need to get reviewer names, so we will use the Reviewer table. We also need to link ratings to movies, so we will use the Rating and Movie tables.", "Determine the relationships: The Reviewer table is linked to the Rating table through rID, and the Rating table is linked to the Movie table through mID.", "Formulate the query: We need to select the names of reviewers from the Reviewer table where their ratings correspond to the movie titled 'Gone with the Wind'.", "Use JOINs to connect the tables: We will join the Reviewer table with the Rating table on rID, and then join the Rating table with the Movie table on mID.", "Add a WHERE clause: We will filter the results to only include ratings for the movie 'Gone with the Wind'."], "gold_sql": "SELECT DISTINCT T3.name FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID WHERE T2.title  =  'Gone with the Wind'", "source_tables": ["rating", "movie", "reviewer"], "pred_sql": "SELECT Reviewer.name FROM Reviewer JOIN Rating ON Reviewer.rID = Rating.rID JOIN Movie ON Rating.mID = Movie.mID WHERE Movie.title = 'Gone with the Wind';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2483", "db_id": "movie_1", "question": "What are the names of all the reviewers and movie names?", "rationale": ["The question asks for the names of all reviewers and the names of movies they reviewed.", "To get this information, we need to join the Reviewer table with the Rating table on the reviewer ID (rID).", "Next, we need to join the resulting table with the Movie table on the movie ID (mID) to get the movie titles.", "The final SQL query will select the reviewer's name from the Reviewer table and the movie title from the Movie table."], "gold_sql": "SELECT name FROM Reviewer UNION SELECT title FROM Movie", "source_tables": ["movie", "reviewer"], "pred_sql": "SELECT Reviewer.name, Movie.title FROM Reviewer JOIN Rating ON Reviewer.rID = Rating.rID JOIN Movie ON Rating.mID = Movie.mID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    }\n}\n"}
{"sample_id": "train.2495", "db_id": "movie_1", "question": "For each director, how many reviews have they received?", "rationale": ["Identify the tables involved: Movie and Rating.", "We need to count the number of reviews for each director, which means we need to aggregate data by the director's name.", "Join the Movie table with the Rating table on the movie ID (mID) to link each review to its corresponding movie.", "Use COUNT() function to count the number of ratings (reviews) for each director.", "Group the results by the director's name to get the count for each director."], "gold_sql": "SELECT count(*) ,  T1.director FROM Movie AS T1 JOIN Rating AS T2 ON T1.mID  =  T2.mID GROUP BY T1.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT M.director, COUNT(R.rID) AS review_count \nFROM Movie AS M \nJOIN Rating AS R ON M.mID = R.mID \nGROUP BY M.director", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2500", "db_id": "movie_1", "question": "What are the names and years of the movies that has the top 3 highest rating star?", "rationale": ["Identify the main goal: to find the names and years of movies with the top 3 highest ratings.", "The relevant tables are Movie and Rating, as we need movie details and their ratings.", "To get the top 3 highest ratings, we can use a subquery on the Rating table to select mID ordered by stars in descending order and limit the results to 3.", "Once we have the top 3 mIDs, we can join this result with the Movie table to get the title and year of these movies.", "The final SQL query selects the title and year from the Movie table where the mID is in the list of top 3 mIDs from the subquery."], "gold_sql": "SELECT T2.title ,  T2.year FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID ORDER BY T1.stars DESC LIMIT 3", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title, year FROM Movie WHERE mID IN (SELECT mID FROM Rating ORDER BY stars DESC LIMIT 3)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    }\n}\n"}
{"sample_id": "train.2502", "db_id": "movie_1", "question": "For each director, return the director's name together with the title of the movie they directed that received the highest rating among all of their movies, and the value of that rating. Ignore movies whose director is NULL.", "rationale": ["We need to find the highest-rated movie for each director.", "First, we join the Movie table with the Rating table on the movie ID (mID) to access both movie titles and their ratings.", "We filter out any movies where the director is NULL using the WHERE clause.", "Next, we group the results by director and movie title to aggregate the ratings for each movie directed by the same director.", "To find the highest rating for each director, we use the MAX function on the stars column.", "Finally, we use a HAVING clause to ensure that we only return the movie with the maximum rating for each director. We achieve this by comparing the maximum stars of each movie to the maximum stars of all movies directed by that director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT M.director, M.title, MAX(R.stars) AS highest_rating\nFROM Movie AS M\nJOIN Rating AS R ON M.mID = R.mID\nWHERE M.director IS NOT NULL\nGROUP BY M.director, M.title\nHAVING MAX(R.stars) = (SELECT MAX(stars) FROM Rating WHERE mID IN (SELECT mID FROM Movie WHERE director = M.director))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the titles and directors of movies from the 'Movie' table that have the same director but different titles. The query uses a self-join on the 'Movie' table to compare movies directed by the same person, ensuring that the titles are not the same. The results are ordered by the director's name and the movie title.\",\n        \"virtual_table\": \"SELECT T1.title ,  T1.director FROM Movie AS T1 JOIN Movie AS T2 ON T1.director  =  T2.director WHERE T1.title != T2.title ORDER BY T1.director ,  T1.title\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the unique movie identifiers along with the average star ratings from the 'Rating' table. It groups the results by movie ID and filters to include only those movies that have received a minimum number of ratings, as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2503", "db_id": "movie_1", "question": "For each director, what are the titles and ratings for all the movies they reviewed?", "rationale": ["The question asks for the titles and ratings of movies reviewed by each director.", "To get this information, we need to join the Rating table with the Movie table using the movie ID (mID).", "The Rating table contains the ratings (stars) given by reviewers, and the Movie table contains the titles and directors of the movies.", "We will select the title of the movie, the stars given in the rating, and the director's name from the joined tables.", "The SQL query will be structured as a SELECT statement that retrieves these columns from the joined tables."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  max(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE director != 'null' GROUP BY director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title, T1.stars, T2.director FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2505", "db_id": "movie_1", "question": "For each reviewer id, what is the title and rating for the movie with the smallest rating?", "rationale": ["We need to find the title and rating for the movie with the smallest rating for each reviewer.", "To achieve this, we will join the Rating table with the Movie table to get the movie titles along with their ratings.", "We will use a subquery to find the minimum stars given by each reviewer. This subquery will select the minimum stars from the Rating table where the reviewer ID matches the current row's reviewer ID.", "The main query will select the title of the movie, the reviewer ID, and the stars from the Rating table where the stars are equal to the minimum stars found in the subquery."], "gold_sql": "SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title, T1.rID, T1.stars FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID = T2.mID WHERE T1.stars = (SELECT MIN(stars) FROM Rating WHERE rID = T1.rID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2507", "db_id": "movie_1", "question": "For each director, what is the title and score of their most poorly rated movie?", "rationale": ["We need to find the title and score of the most poorly rated movie for each director.", "To do this, we will join the Rating table with the Movie table on the movie ID (mID).", "We will group the results by director and title to aggregate the ratings for each movie directed by the same individual.", "We will use the MIN function to find the lowest star rating for each movie.", "To ensure we only get the most poorly rated movie for each director, we will use a HAVING clause that compares the minimum stars of each movie to the overall minimum stars for that director."], "gold_sql": "SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.director, T2.title, MIN(T1.stars) AS min_stars \nFROM Rating AS T1 \nJOIN Movie AS T2 ON T1.mID = T2.mID \nGROUP BY T2.director, T2.title \nHAVING MIN(T1.stars) = (SELECT MIN(stars) \n                         FROM Rating AS T3 \n                         JOIN Movie AS T4 ON T3.mID = T4.mID \n                         WHERE T4.director = T2.director)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2508", "db_id": "movie_1", "question": "What is the name of the movie that is rated by most of times?", "rationale": ["Identify the goal: We need to find the name of the movie that has been rated the most times.", "To achieve this, we will count the number of ratings for each movie using the Rating table.", "We will group the results by movie ID (mID) to get the count of ratings for each movie.", "Next, we will order these counts in descending order to find the movie with the highest count.", "Finally, we will limit the results to just one movie to get the top-rated movie.", "We will then join this result with the Movie table to get the title of that movie."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title FROM Movie WHERE mID IN (SELECT mID FROM Rating GROUP BY mID ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    }\n}\n"}
{"sample_id": "train.2509", "db_id": "movie_1", "question": "What is the name of the movie that has been reviewed the most?", "rationale": ["Identify the goal: We need to find the name of the movie that has been reviewed the most.", "To determine which movie has been reviewed the most, we need to count the number of reviews for each movie.", "We can achieve this by grouping the ratings by movie ID (mID) and counting the number of reviewer IDs (rID) for each movie.", "Next, we will order these counts in descending order to get the movie with the highest number of reviews at the top.", "Finally, we will limit our results to just one movie to get the top-reviewed movie.", "We will then select the title of this movie from the Movie table using its mID."], "gold_sql": "SELECT T2.title ,  T1.mID FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.mID ORDER BY count(*) DESC LIMIT 1", "source_tables": ["rating", "movie"], "pred_sql": "SELECT title FROM Movie WHERE mID IN (SELECT mID FROM Rating GROUP BY mID ORDER BY COUNT(rID) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    }\n}\n"}
{"sample_id": "train.2517", "db_id": "movie_1", "question": "What are the ids of all moviest hat have not been reviewed by Britanny Harris?", "rationale": ["Identify the movies that have not been reviewed by Britanny Harris.", "To find this, we need to select all movie IDs from the Movie table.", "We will use a subquery to find all movie IDs that have been reviewed by Britanny Harris.", "The subquery will join the Rating table with the Reviewer table to filter ratings by Britanny Harris.", "The main query will select movie IDs from the Movie table that are not in the list of IDs returned by the subquery."], "gold_sql": "SELECT mID FROM Rating EXCEPT SELECT T1.mID FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T2.name  =  'Brittany Harris'", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT mID FROM Movie WHERE mID NOT IN (SELECT mID FROM Rating JOIN Reviewer ON Rating.rID = Reviewer.rID WHERE Reviewer.name = 'Britanny Harris');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the unique movie identifiers along with the average star ratings from the 'Rating' table. It groups the results by movie ID and filters to include only those movies that have received a minimum number of ratings, as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2518", "db_id": "movie_1", "question": "Find the average rating star for each movie that received at least 2 ratings.", "rationale": ["The task is to find the average rating star for each movie that received at least 2 ratings.", "We need to calculate the average stars for each movie, which can be done using the AVG() function on the 'stars' column from the 'Rating' table.", "To ensure we only include movies with at least 2 ratings, we will use the HAVING clause with COUNT(*) to filter the results after grouping by movie ID (mID).", "The provided virtual table in the hint already outlines the necessary structure for this query, indicating that we should select mID and the average of stars, grouping by mID and applying a count filter."], "gold_sql": "SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2", "source_tables": ["rating"], "pred_sql": "SELECT mID, avg(stars) FROM Rating GROUP BY mID HAVING count(*) >= 2", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the unique movie identifiers along with the average star ratings from the 'Rating' table. It groups the results by movie ID and filters to include only those movies that have received a minimum number of ratings, as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    }\n}\n"}
{"sample_id": "train.2528", "db_id": "movie_1", "question": "What are the names of reviewers who had rated 3 star and 4 star?", "rationale": ["The question asks for the names of reviewers who rated movies with 3 stars and 4 stars.", "To find reviewers who rated both, we can use the INTERSECT operation, which will return only those reviewers who appear in both sets of results.", "We need to join the Rating table with the Reviewer table to get the names of the reviewers based on their ratings.", "The first part of the query selects reviewer names who rated movies with 3 stars.", "The second part of the query selects reviewer names who rated movies with 4 stars.", "By using INTERSECT, we ensure that only reviewers who rated both 3 stars and 4 stars are returned."], "gold_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  3 INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  4", "source_tables": ["rating", "reviewer"], "pred_sql": "SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID = T2.rID WHERE T1.stars = '3' INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID = T2.rID WHERE T1.stars = '4'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of reviewers who have given a specific number of stars to movies. The query uses an INTERSECT operation to find reviewers who rated two different movies with the same star rating. The placeholders in the WHERE clause represent the number of stars given in the ratings.\",\n        \"virtual_table\": \"SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.name FROM Rating AS T1 JOIN Reviewer AS T2 ON T1.rID  =  T2.rID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.2530", "db_id": "movie_1", "question": "What are the names of movies that get 3 star and 4 star?", "rationale": ["The user wants to find movie titles that received both 3-star and 4-star ratings.", "To achieve this, we can use the INTERSECT operator, which allows us to find common results from two separate queries.", "The first part of the query selects movie titles from the Movie table where the rating is 3 stars.", "The second part of the query selects movie titles from the Movie table where the rating is 4 stars.", "By using INTERSECT, we ensure that only movie titles that appear in both result sets (i.e., movies rated 3 stars and 4 stars) are returned."], "gold_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "source_tables": ["rating", "movie"], "pred_sql": "SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  3 INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  4", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the titles of movies that have received a specific number of stars from two different reviewers. The placeholders in the WHERE clause represent the star ratings given by the reviewers.\",\n        \"virtual_table\": \"SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T2.title FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID WHERE T1.stars  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of movie ratings by reviewers. It displays the title of the movie, the unique identifier of the reviewer, the number of stars given in the rating, and the minimum stars given by each reviewer. The placeholders represent the relevant identifiers and ratings.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.rID ,  T1.stars ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T1.rID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of movie ratings, displaying the title of each movie, the number of stars given, the director's name, and the minimum star rating for each director. The data is aggregated by director, allowing for a comparison of the lowest ratings received by movies directed by the same individual.\",\n        \"virtual_table\": \"SELECT T2.title ,  T1.stars ,  T2.director ,  min(T1.stars) FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID GROUP BY T2.director\"\n    }\n}\n"}
{"sample_id": "train.2576", "db_id": "inn_1", "question": "Find the most popular room in the hotel. The most popular room is the room that had seen the largest number of reservations.", "rationale": ["To find the most popular room, we need to count the number of reservations for each room.", "We will join the Reservations table (T1) with the Rooms table (T2) on the RoomId.", "We will group the results by the Room identifier to get the count of reservations for each room.", "We will order the results by the count of reservations in descending order to get the most popular room at the top.", "Finally, we will limit the results to 1 to get only the most popular room."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.roomName, COUNT(*) AS reservation_count \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nGROUP BY T1.Room \nORDER BY reservation_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n        \"virtual_table\": \"SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    }\n}\n"}
{"sample_id": "train.2577", "db_id": "inn_1", "question": "Which room has the largest number of reservations?", "rationale": ["Identify the tables involved: Reservations and Rooms.", "We need to count the number of reservations for each room, so we will join the Reservations table with the Rooms table on the Room identifier.", "Use COUNT(*) to count the number of reservations for each room.", "Group the results by the Room identifier to get the count per room.", "Order the results in descending order based on the count of reservations to find the room with the largest number of reservations.", "Limit the results to 1 to get only the room with the highest count."], "gold_sql": "SELECT T2.roomName FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.roomName, COUNT(*) AS reservation_count \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nGROUP BY T1.Room \nORDER BY reservation_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n        \"virtual_table\": \"SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    }\n}\n"}
{"sample_id": "train.2578", "db_id": "inn_1", "question": "How many kids stay in the rooms reserved by ROY SWEAZY?", "rationale": ["Identify the relevant table for the query, which is the Reservations table since it contains information about guests and their reservations.", "We need to sum the number of kids from the Reservations table for a specific guest, identified by their first and last name.", "The SQL query will use the SUM function to calculate the total number of kids for the specified guest.", "The WHERE clause will filter the results to include only those reservations made by ROY SWEAZY."], "gold_sql": "SELECT kids FROM Reservations WHERE FirstName = 'ROY' AND LastName  =  'SWEAZY';", "source_tables": ["reservations"], "pred_sql": "SELECT SUM(Kids) AS TotalKids \nFROM Reservations \nWHERE LastName = 'SWEAZY' AND FirstName = 'ROY';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n        \"virtual_table\": \"SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    }\n}\n"}
{"sample_id": "train.2582", "db_id": "inn_1", "question": "Which room has the highest rate? List the room's full name, rate, check in and check out date.", "rationale": ["Identify the relevant tables: Rooms and Reservations.", "We need to find the room with the highest rate, which is stored in the Reservations table under the Rate column.", "Join the Rooms table with the Reservations table on the RoomId to get room details along with reservation details.", "Select the room name, rate, check-in date, and check-out date from the joined tables.", "Order the results by the Rate in descending order to get the highest rate at the top.", "Limit the results to 1 to get only the room with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT R.roomName, R.basePrice AS Rate, Res.CheckIn, Res.CheckOut \nFROM Rooms AS R \nJOIN Reservations AS Res ON R.RoomId = Res.Room \nORDER BY Res.Rate DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n        \"virtual_table\": \"SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    }\n}\n"}
{"sample_id": "train.2583", "db_id": "inn_1", "question": "Return the name, rate, check in and check out date for the room with the highest rate.", "rationale": ["Identify the required fields: room name, rate, check-in date, and check-out date.", "Determine the tables involved: Rooms and Reservations.", "Join the Rooms table with the Reservations table on the RoomId to access room details along with reservation details.", "Use a subquery to find the maximum rate from the Reservations table.", "Filter the results to only include the reservation(s) with the highest rate."], "gold_sql": "SELECT T2.roomName ,  T1.Rate ,  T1.CheckIn ,  T1.CheckOut FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room ORDER BY T1.Rate DESC LIMIT 1;", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.roomName, T1.Rate, T1.CheckIn, T1.CheckOut \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nWHERE T1.Rate = (SELECT MAX(Rate) FROM Reservations)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n        \"virtual_table\": \"SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    }\n}\n"}
{"sample_id": "train.2589", "db_id": "inn_1", "question": "Find the total number of king beds available.", "rationale": ["The user wants to find the total number of king beds available.", "To achieve this, we need to count the number of rooms that have a bed type of 'king'.", "We will use the Rooms table, specifically filtering for rows where the bedType column equals 'king'.", "The SQL query will use the COUNT function to get the total number of such rooms."], "gold_sql": "SELECT sum(beds) FROM Rooms WHERE bedtype  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT count(*) FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n        \"virtual_table\": \"SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room\"\n    }\n}\n"}
{"sample_id": "train.2590", "db_id": "inn_1", "question": "List the names and decor of rooms that have a king bed. Sort the list by their price.", "rationale": ["Identify the required information: room names and decor of rooms with a king bed.", "Refer to the provided hint for the virtual table that matches the requirement.", "The hint specifies a SELECT statement that retrieves roomName and decor from the Rooms table where bedType is 'king'.", "The results should be ordered by basePrice as specified in the user query.", "Construct the SQL query using the identified elements."], "gold_sql": "SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  'King' ORDER BY basePrice;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName, decor FROM Rooms WHERE bedType = 'king' ORDER BY basePrice;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    }\n}\n"}
{"sample_id": "train.2594", "db_id": "inn_1", "question": "What is the decor of room Recluse and defiance?", "rationale": ["Identify the relevant table: The 'Rooms' table contains the decor information.", "Determine the required columns: We need the 'decor' column for the specified rooms.", "Specify the condition: We want to filter the results to include only the rooms named 'Recluse' and 'defiance'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'decor' for the specified room names."], "gold_sql": "SELECT decor FROM Rooms WHERE roomName  =  'Recluse and defiance';", "source_tables": ["rooms"], "pred_sql": "SELECT decor FROM Rooms WHERE roomName IN ('Recluse', 'defiance');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;\"\n    }\n}\n"}
{"sample_id": "train.2604", "db_id": "inn_1", "question": "Find the first and last names of people who payed more than the rooms' base prices.", "rationale": ["Identify the relevant tables: Reservations and Rooms.", "We need to find the first and last names of guests from the Reservations table.", "We need to compare the Rate in Reservations with the basePrice in Rooms.", "To do this, we will use a subquery to select the basePrice from Rooms where the RoomId matches the Room in Reservations.", "The final query will select FirstName and LastName from Reservations where the Rate is greater than the basePrice from the subquery."], "gold_sql": "SELECT T1.firstname ,  T1.lastname FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId WHERE T1.Rate - T2.basePrice  >  0", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT FirstName, LastName FROM Reservations WHERE Rate > (SELECT basePrice FROM Rooms WHERE Rooms.RoomId = Reservations.Room);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;\"\n    }\n}\n"}
{"sample_id": "train.2609", "db_id": "inn_1", "question": "How many rooms have a king bed?", "rationale": ["The user wants to know how many rooms have a king bed.", "To find this, we need to count the number of entries in the 'Rooms' table where the 'bedType' column is equal to 'king'.", "The SQL query will use the COUNT() function to get the total number of rooms that meet this condition."], "gold_sql": "SELECT count(*) FROM Rooms WHERE bedType  =  'King';", "source_tables": ["rooms"], "pred_sql": "SELECT COUNT(*) FROM Rooms WHERE bedType = 'king';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;\"\n    }\n}\n"}
{"sample_id": "train.2612", "db_id": "inn_1", "question": "Find the name of the room with the maximum occupancy.", "rationale": ["Identify the table that contains room information, which is the 'Rooms' table.", "Determine the relevant column for maximum occupancy, which is 'maxOccupancy'.", "To find the room with the maximum occupancy, we need to select the room name where the maximum occupancy equals the highest value in the 'maxOccupancy' column.", "Use a subquery to find the maximum value of 'maxOccupancy' from the 'Rooms' table.", "Construct the final SQL query to select the 'roomName' from 'Rooms' where 'maxOccupancy' matches the maximum value found."], "gold_sql": "SELECT roomName FROM Rooms ORDER BY maxOccupancy DESC LIMIT 1;", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE maxOccupancy = (SELECT MAX(maxOccupancy) FROM Rooms);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n        \"virtual_table\": \"SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    }\n}\n"}
{"sample_id": "train.2621", "db_id": "inn_1", "question": "What is the average minimum and price of the rooms for each different decor.", "rationale": ["Identify the required information: average minimum price of rooms for each different decor.", "The average price can be calculated using the AVG() function in SQL.", "We need to group the results by the decor type, which can be done using the GROUP BY clause.", "Select the decor column and the average of the basePrice column from the Rooms table."], "gold_sql": "SELECT decor , avg(basePrice) ,  min(basePrice) FROM Rooms GROUP BY decor;", "source_tables": ["rooms"], "pred_sql": "SELECT decor, AVG(basePrice) AS averagePrice FROM Rooms GROUP BY decor;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    }\n}\n"}
{"sample_id": "train.2628", "db_id": "inn_1", "question": "List the name of rooms with king or queen bed.", "rationale": ["The user wants to list the names of rooms with specific bed types: king or queen.", "We need to filter the 'Rooms' table based on the 'bedType' column.", "The SQL query should select the 'roomName' from the 'Rooms' table where 'bedType' is either 'king' or 'queen'.", "Using the IN clause allows us to specify multiple values for the 'bedType' condition."], "gold_sql": "SELECT roomName FROM Rooms WHERE bedType  =  'King' OR bedType  =  'Queen';", "source_tables": ["rooms"], "pred_sql": "SELECT roomName FROM Rooms WHERE bedType IN ('king', 'queen');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and decor descriptions of rooms from the 'Rooms' table that have a specific type of bed. The results are ordered by the base price of the rooms. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT roomName ,  decor FROM Rooms WHERE bedtype  =  [PLACEHOLDER-TYPE:STRING] ORDER BY basePrice;\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    }\n}\n"}
{"sample_id": "train.2639", "db_id": "inn_1", "question": "For each room, find its name and the number of times reservations were made for it.", "rationale": ["Identify the tables involved: Rooms and Reservations.", "We need to find the room name and the count of reservations for each room.", "Join the Rooms table with the Reservations table on the RoomId to get the room names associated with each reservation.", "Use COUNT(*) to count the number of reservations for each room.", "Group the results by the Room identifier to aggregate the counts for each room."], "gold_sql": "SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room", "source_tables": ["rooms", "reservations"], "pred_sql": "SELECT T2.roomName, COUNT(*) AS reservation_count \nFROM Reservations AS T1 \nJOIN Rooms AS T2 ON T1.Room = T2.RoomId \nGROUP BY T1.Room;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of room reservations, showing the room names along with the count of reservations for each room. The placeholders in the query allow for dynamic filtering based on room identifiers.\",\n        \"virtual_table\": \"SELECT T2.roomName ,  count(*) ,  T1.Room FROM Reservations AS T1 JOIN Rooms AS T2 ON T1.Room  =  T2.RoomId GROUP BY T1.Room\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the type of bed being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of rooms grouped by their decor style from the 'Rooms' table, specifically filtering for rooms that have a certain type of bed. The placeholder in the WHERE clause represents the bed type being queried.\",\n        \"virtual_table\": \"SELECT decor ,  count(*) FROM Rooms WHERE bedType = [PLACEHOLDER-TYPE:STRING] GROUP BY decor;\"\n    }\n}\n"}
{"sample_id": "train.2846", "db_id": "customer_deliveries", "question": "Show the details of all trucks in the order of their license number.", "rationale": ["Identify the table needed: The question asks for details of trucks, so we will use the 'Trucks' table.", "Select all columns: We need all details, so we will use SELECT *.", "Order by license number: The question specifies to order the results by the truck's license number, so we will add ORDER BY truck_licence_number."], "gold_sql": "SELECT truck_details FROM trucks ORDER BY truck_licence_number", "source_tables": ["trucks"], "pred_sql": "SELECT * FROM Trucks ORDER BY truck_licence_number;", "hint": "\n"}
{"sample_id": "train.2848", "db_id": "customer_deliveries", "question": "Find the names of customers who are not living in the state of California.", "rationale": ["Identify the tables involved: Customers, Customer_Addresses, and Addresses.", "We need to find customer names, so we will select 'customer_name' from the Customers table.", "To filter customers based on their addresses, we need to join the Customers table with the Customer_Addresses table using 'customer_id'.", "Next, we join the Customer_Addresses table with the Addresses table using 'address_id' to access the state information.", "We apply a WHERE clause to filter out customers whose state is 'California'.", "Use DISTINCT to ensure that we only get unique customer names in case of multiple addresses."], "gold_sql": "SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id WHERE t3.state_province_county  =  'California'", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT DISTINCT c.customer_name \nFROM Customers c \nJOIN Customer_Addresses ca ON c.customer_id = ca.customer_id \nJOIN Addresses a ON ca.address_id = a.address_id \nWHERE a.state_province_county != 'California';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the count of customer addresses grouped by state, province, or county from the 'Customer_Addresses' and 'Addresses' tables. The placeholder in the SELECT statement represents the state, province, or county being counted.\",\n        \"virtual_table\": \"SELECT t2.state_province_county ,  count(*) FROM customer_addresses AS t1 JOIN addresses AS t2 ON t1.address_id  =  t2.address_id GROUP BY t2.state_province_county\"\n    }\n}\n"}
{"sample_id": "train.2856", "db_id": "customer_deliveries", "question": "Find the name of route that has the highest number of deliveries.", "rationale": ["Identify the relevant tables: Delivery_Routes, Delivery_Route_Locations, and Order_Deliveries are needed to find the route with the highest number of deliveries.", "Join the Delivery_Routes table with Delivery_Route_Locations on route_id to link routes to their locations.", "Join the resulting table with Order_Deliveries on location_code to associate deliveries with their respective routes.", "Group the results by route_name to count the number of deliveries for each route.", "Order the results in descending order based on the count of deliveries to find the route with the highest number.", "Limit the results to 1 to get only the top route."], "gold_sql": "SELECT t1.route_name FROM Delivery_Routes AS t1 JOIN Delivery_Route_Locations AS t2 ON t1.route_id  =  t2.route_id GROUP BY t1.route_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["delivery_route_locations", "delivery_routes"], "pred_sql": "SELECT route_name\nFROM Delivery_Routes\nJOIN Delivery_Route_Locations ON Delivery_Routes.route_id = Delivery_Route_Locations.route_id\nJOIN Order_Deliveries ON Delivery_Route_Locations.location_code = Order_Deliveries.location_code\nGROUP BY route_name\nORDER BY COUNT(Order_Deliveries.actual_order_id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3175", "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["Identify the relevant tables: We need to find professors and their associated classes, so we will use the PROFESSOR and CLASS tables.", "Determine the relationship: The PROFESSOR table is linked to the CLASS table through the PROF_NUM column in CLASS, which corresponds to EMP_NUM in PROFESSOR.", "Formulate the query: We want to count the number of distinct professors teaching a specific class, which is identified by the CLASS_CODE 'ACCT-211'.", "Use COUNT(DISTINCT) to ensure we count unique professors only, as one professor may teach multiple sections of the same class.", "Construct the SQL query using JOIN to connect the PROFESSOR and CLASS tables, applying the WHERE clause to filter for the specific class code."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT T1.EMP_NUM) FROM professor AS T1 JOIN class AS T2 ON T1.EMP_NUM = T2.PROF_NUM WHERE T2.CLASS_CODE = 'ACCT-211'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3176", "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: We need to find professors and their associated classes, so we will use the PROFESSOR and CLASS tables.", "Determine the relationship: The PROFESSOR table is linked to the CLASS table through the PROF_NUM column in CLASS, which corresponds to EMP_NUM in PROFESSOR.", "Specify the condition: We are interested in classes with the code 'ACCT-211'.", "Count the distinct professors: We need to count how many unique professors are teaching this class, which requires a COUNT function on the EMP_NUM from the PROFESSOR table after joining with the CLASS table."], "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"], "pred_sql": "SELECT COUNT(DISTINCT T1.EMP_NUM) FROM professor AS T1 JOIN class AS T2 ON T1.EMP_NUM = T2.PROF_NUM WHERE T2.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3179", "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the tables needed: We need information from the EMPLOYEE table for professors and the CLASS table to link professors to courses.", "Join the EMPLOYEE table with the CLASS table on the professor's identifier (EMP_NUM) and the professor's number in the CLASS table (PROF_NUM).", "Filter the results to only include classes that match the course code 'ACCT-211'.", "Select the distinct first names (EMP_FNAME) and dates of birth (EMP_DOB) of the professors who teach this course."], "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"], "pred_sql": "SELECT DISTINCT T1.EMP_FNAME, T1.EMP_DOB FROM EMPLOYEE AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM = T2.PROF_NUM WHERE T2.CRS_CODE = 'ACCT-211'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3188", "db_id": "college_1", "question": "Where is the history department?", "rationale": ["Identify the relevant table: The DEPARTMENT table contains information about department names and codes.", "Determine the required information: We need to find the location of the History department, which implies we need the department name and possibly its address or other identifying information.", "Construct the SQL query: We will select the DEPT_NAME and DEPT_CODE from the DEPARTMENT table where the DEPT_NAME matches 'History'."], "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"], "pred_sql": "SELECT DEPT_NAME, DEPT_CODE FROM DEPARTMENT WHERE DEPT_NAME = 'History'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3190", "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the table that contains the school locations, which is the DEPARTMENT table.", "Determine the relevant column for the location, which is DEPT_ADDRESS.", "Filter the results based on the SCHOOL_CODE, specifically for the code 'BUS'.", "Use DISTINCT to ensure that only unique locations are returned."], "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "hint": "\n"}
{"sample_id": "train.3201", "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["The question asks for the total credit offered by each department.", "To find this, we need to sum the credit hours from the COURSE table, which contains the CRS_CREDIT column.", "We will group the results by DEPT_CODE to get the total credit for each department.", "The final SQL query will select the DEPT_CODE and the sum of CRS_CREDIT, aliased as TOTAL_CREDIT."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT DEPT_CODE, SUM(CRS_CREDIT) AS TOTAL_CREDIT FROM COURSE GROUP BY DEPT_CODE", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3202", "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["To find out how many credits the department offers, we need to sum the credit hours from the COURSE table.", "The COURSE table contains a column 'CRS_CREDIT' which represents the number of credit hours for each course.", "We need to join the COURSE table with the DEPARTMENT table to ensure we are considering courses offered by departments.", "The join is done on the DEPT_CODE column which is present in both tables.", "Finally, we use the SUM function to calculate the total credits offered by all courses in the department."], "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"], "pred_sql": "SELECT SUM(CRS_CREDIT) AS total_credits FROM COURSE JOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3213", "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["We need to find the school with the smallest number of professors.", "To do this, we will join the PROFESSOR table with the DEPARTMENT table using the DEPT_CODE.", "We will group the results by SCHOOL_CODE to count the number of professors in each school.", "We will use COUNT(T1.EMP_NUM) to count the number of professors for each school.", "Finally, we will order the results in ascending order based on the count of professors and limit the result to 1 to get the school with the smallest number of professors."], "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"], "pred_sql": "SELECT T2.SCHOOL_CODE, COUNT(T1.EMP_NUM) AS professor_count \nFROM PROFESSOR AS T1 \nJOIN DEPARTMENT AS T2 ON T1.DEPT_CODE = T2.DEPT_CODE \nGROUP BY T2.SCHOOL_CODE \nORDER BY professor_count ASC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes from the 'professor' and 'department' tables. It filters the results based on the highest degree obtained by professors, using a placeholder for the degree type. The results are grouped by department code and ordered by the number of professors in each department, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3215", "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors, including their highest degree and department code.", "Determine the condition: We need to filter professors who have a Ph.D. degree, which is specified in the WHERE clause.", "Count the number of professors: We will use the COUNT function to count the number of professors for each department.", "Group the results: We will group the results by department code to get the count of professors in each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"], "pred_sql": "SELECT dept_code, count(*) AS num_professors FROM professor WHERE prof_high_degree = 'Ph.D.' GROUP BY dept_code", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes from the 'professor' and 'department' tables. It filters the results based on the highest degree obtained by professors, using a placeholder for the degree type. The results are grouped by department code and ordered by the number of professors in each department, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3217", "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["Identify the relevant tables: The STUDENT table contains information about students, including their department code.", "Determine the required information: We need to count the number of students in each department.", "Use the COUNT function to count the number of students (STU_NUM) for each department (DEPT_CODE).", "Group the results by DEPT_CODE to get the count for each department."], "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT DEPT_CODE, COUNT(STU_NUM) AS student_count FROM STUDENT GROUP BY DEPT_CODE", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes from the 'professor' and 'department' tables. It filters the results based on the highest degree obtained by professors, using a placeholder for the degree type. The results are grouped by department code and ordered by the number of professors in each department, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3219", "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["We need to find the total number of hours completed by students in each department.", "The relevant table for student information is the STUDENT table, which contains the 'STU_HRS' column representing the total credit hours completed by each student.", "To get the total hours for each department, we will group the results by 'DEPT_CODE'.", "We will use the SUM function to calculate the total hours for each department.", "The final SQL query will select the department code and the sum of student hours, grouping by department code."], "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"], "pred_sql": "SELECT dept_code, SUM(stu_hrs) AS total_hours FROM student GROUP BY dept_code", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3240", "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE are needed to find the total credits offered by each department.", "Join the DEPARTMENT table with the COURSE table on the DEPT_CODE to associate courses with their respective departments.", "Use the SUM function to calculate the total credits for each department by summing the CRS_CREDIT from the COURSE table.", "Group the results by DEPARTMENT.DEPT_CODE to aggregate the total credits for each department.", "Order the results in descending order based on the total credits to find the department with the most credits.", "Limit the results to 1 to get only the department that offers the most credits."], "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"], "pred_sql": "SELECT DEPARTMENT.DEPT_CODE, SUM(COURSE.CRS_CREDIT) AS TOTAL_CREDITS\nFROM DEPARTMENT\nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_CODE\nORDER BY TOTAL_CREDITS DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3243", "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the tables needed: STUDENT, ENROLL, and CLASS.", "We need to find the first names of students, so we will select the 'STU_FNAME' column from the STUDENT table.", "To find students enrolled in a specific class, we will join the ENROLL table on 'STU_NUM' to link students to their enrollments.", "Next, we join the CLASS table on 'CLASS_CODE' to filter for the specific class 'ACCT-211'.", "Finally, we use a WHERE clause to specify that we only want records where CLASS_CODE is 'ACCT-211'.", "We use DISTINCT to ensure that we only get unique first names in case a student is enrolled in the same class multiple times."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT DISTINCT T1.STU_FNAME \nFROM STUDENT AS T1 \nJOIN ENROLL AS T2 ON T1.STU_NUM = T2.STU_NUM \nJOIN CLASS AS T3 ON T2.CLASS_CODE = T3.CLASS_CODE \nWHERE T3.CLASS_CODE = 'ACCT-211';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3245", "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["Identify the tables needed: STUDENT, ENROLL, and CLASS are required to get the first names of students enrolled in a specific class and their grades.", "Join the STUDENT table with the ENROLL table on STU_NUM to link students with their enrollments.", "Join the resulting table with the CLASS table on CLASS_CODE to filter by the specific class (ACCT-211).", "Add a WHERE clause to filter for students who received a grade of 'C' in that class.", "Select the first names of the students from the resulting joined table."], "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"], "pred_sql": "SELECT T1.STU_FNAME \nFROM STUDENT AS T1 \nJOIN ENROLL AS T2 ON T1.STU_NUM = T2.STU_NUM \nJOIN CLASS AS T3 ON T2.CLASS_CODE = T3.CLASS_CODE \nWHERE T3.CLASS_CODE = 'ACCT-211' AND T2.ENROLL_GRADE = 'C';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA of students grouped by their respective department codes. The placeholders in the SELECT statement represent the GPA metrics and department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3254", "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["Identify the relevant tables: We need to find the department with the most students enrolled, which involves the ENROLL and DEPARTMENT tables.", "Count the number of students enrolled in each department: We can use the ENROLL table to group by department code and count the number of enrollments.", "Order the results by the count of enrollments in descending order to find the department with the most students.", "Limit the results to 1 to get only the top department.", "Join the DEPARTMENT table to get the name of the department corresponding to the department code with the most enrollments."], "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"], "pred_sql": "SELECT dept_name FROM department WHERE dept_code IN (SELECT dept_code FROM enroll GROUP BY dept_code ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the academic performance of students by department. It calculates the maximum, average, and minimum GPA for students in each department, grouping the results by the department code.\",\n        \"virtual_table\": \"SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3257", "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including the room where they are held and the course code associated with each class.", "Determine the specific requirement: We need to find all course codes (CRS_CODE) for classes that take place in room KLR209.", "Construct the SQL query: Use a SELECT statement to retrieve distinct course codes from the CLASS table where the CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE \nFROM CLASS \nWHERE CLASS.CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3258", "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about classes, including their room assignments.", "Determine the required columns: We need the CRS_CODE, which is the course code associated with each class.", "Specify the condition: We want to filter the results to only include classes that are held in room 'KLR209'.", "Construct the SQL query: Use SELECT DISTINCT to get unique course codes from the CLASS table where the CLASS_ROOM matches 'KLR209'."], "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"], "pred_sql": "SELECT DISTINCT CRS_CODE FROM CLASS WHERE CLASS_ROOM = 'KLR209';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3267", "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the tables needed: STUDENT, ENROLL, and CLASS.", "We need to find students who received a grade of 'C'. This requires joining the ENROLL table with the STUDENT table to get student names and grades.", "The ENROLL table contains the grades, so we filter for those with a grade of 'C'.", "We select the first names of the students, which is in the STUDENT table under the column STU_FNAME.", "Using DISTINCT ensures that we do not have duplicate names in the result."], "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nWHERE ENROLL.ENROLL_GRADE = 'C';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3273", "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["Identify the table that contains professor information, which is the EMPLOYEE table.", "We need to find professors who do not teach any class, so we will look for professors whose EMP_NUM is not present in the CLASS table's PROF_NUM column.", "To achieve this, we can use a subquery that selects all PROF_NUM from the CLASS table.", "The main query will select the EMP_FNAME from the EMPLOYEE table where the EMP_NUM is not in the list of PROF_NUM obtained from the subquery."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME FROM EMPLOYEE WHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3274", "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the table that contains professor information, which is the EMPLOYEE table.", "We need to find professors who are not teaching any classes, so we will look for professors whose EMP_NUM is not present in the CLASS table's PROF_NUM column.", "To achieve this, we can use a subquery that selects all PROF_NUM from the CLASS table.", "The main query will select the first names (EMP_FNAME) of professors from the EMPLOYEE table where their EMP_NUM is not in the list of PROF_NUM from the CLASS table."], "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"], "pred_sql": "SELECT EMP_FNAME FROM EMPLOYEE WHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3288", "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the relevant table: The PROFESSOR table contains information about professors and their highest degrees.", "Determine the condition: We need to count professors who have either a Ph.D. or a Masters degree.", "Use the COUNT function: This will give us the total number of professors meeting the criteria.", "Construct the SQL query: Use a SELECT statement with COUNT(*) and a WHERE clause to filter for the specified degrees."], "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"], "pred_sql": "SELECT COUNT(*) FROM professor WHERE prof_high_degree IN ('Ph.D.', 'Masters')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes from the 'professor' and 'department' tables. It filters the results based on the highest degree obtained by professors, using a placeholder for the degree type. The results are grouped by department code and ordered by the number of professors in each department, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3292", "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the tables needed: We need the EMPLOYEE table to get the professor's first name and the CLASS table to find out which professors are teaching specific courses.", "Join the EMPLOYEE table with the CLASS table on the professor's identifier (PROF_NUM) to link professors with their classes.", "Filter the results based on the course codes 'CIS-220' and 'QM-261' using the WHERE clause with an IN condition to include both courses.", "Select distinct first names of professors to avoid duplicates in case a professor teaches both courses."], "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"], "pred_sql": "SELECT DISTINCT T1.EMP_FNAME \nFROM EMPLOYEE AS T1 \nJOIN CLASS AS T2 ON T1.EMP_NUM = T2.PROF_NUM \nWHERE T2.CRS_CODE IN ('CIS-220', 'QM-261')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3293", "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the tables involved: STUDENT, ENROLL, CLASS, COURSE, and DEPARTMENT.", "Determine the relationships: STUDENT is linked to ENROLL, which is linked to CLASS, which is linked to COURSE, which is linked to DEPARTMENT.", "Use JOINs to connect these tables based on their relationships.", "Filter the results based on the department names 'Accounting' and 'Computer Info. Systems'.", "Use INTERSECT to find students who are enrolled in classes from both departments."], "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"], "pred_sql": "SELECT T1.stu_fname \nFROM student AS T1 \nJOIN enroll AS T2 ON T1.stu_num = T2.stu_num \nJOIN CLASS AS T3 ON T2.class_code = T3.class_code \nJOIN course AS T4 ON T3.crs_code = T4.crs_code \nJOIN department AS T5 ON T5.dept_code = T4.dept_code \nWHERE T5.dept_name = 'Accounting' \nINTERSECT \nSELECT T1.stu_fname \nFROM student AS T1 \nJOIN enroll AS T2 ON T1.stu_num = T2.stu_num \nJOIN CLASS AS T3 ON T2.class_code = T3.class_code \nJOIN course AS T4 ON T3.crs_code = T4.crs_code \nJOIN department AS T5 ON T5.dept_code = T4.dept_code \nWHERE T5.dept_name = 'Computer Info. Systems'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3308", "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["Identify the tables needed: PROFESSOR and DEPARTMENT.", "We need to select the first names and office locations of professors, so we will select EMP_FNAME and PROF_OFFICE from the PROFESSOR table.", "To filter professors by department, we will join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE.", "We need to filter for professors in the History department, so we will add a WHERE clause for DEPT_NAME = 'History'.", "Additionally, we need to filter for professors who have a Ph.D., so we will add another condition in the WHERE clause for PROF_HIGH_DEGREE = 'Ph.D.'", "Combine all these elements to form the final SQL query."], "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"], "pred_sql": "SELECT EMP_FNAME, PROF_OFFICE \nFROM PROFESSOR AS P \nJOIN DEPARTMENT AS D ON P.DEPT_CODE = D.DEPT_CODE \nWHERE D.DEPT_NAME = 'History' AND P.PROF_HIGH_DEGREE = 'Ph.D.';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of first names and dates of birth of professors from the 'employee' table who are teaching classes associated with a specific course code. The placeholder in the WHERE clause represents the course code for which the professors are being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3319", "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["We need to find the names of students who took some course and received either an A or a C grade.", "To do this, we will join the STUDENT table with the ENROLL table to get the grades of each student.", "Next, we will join the ENROLL table with the CLASS table to ensure we are looking at the correct classes.", "We will filter the results using a WHERE clause to include only those records where the ENROLL_GRADE is either 'A' or 'C'.", "Finally, we will select the distinct first and last names of the students from the result set to avoid duplicates."], "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"], "pred_sql": "SELECT DISTINCT S.STU_FNAME, S.STU_LNAME \nFROM STUDENT AS S \nJOIN ENROLL AS E ON S.STU_NUM = E.STU_NUM \nJOIN CLASS AS C ON E.CLASS_CODE = C.CLASS_CODE \nWHERE E.ENROLL_GRADE IN ('A', 'C');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names of students who are enrolled in classes offered by a specific department. The query uses an INTERSECT operation to find students who are enrolled in classes from two instances of the same department, ensuring that the results include only those students who meet the criteria in both cases. The placeholder in the WHERE clause represents the department's name.\",\n        \"virtual_table\": \"SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3324", "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the tables needed: CLASS, EMPLOYEE, PROFESSOR, and DEPARTMENT.", "We need to join these tables to get the first names of professors and their highest degrees.", "The join conditions are based on the foreign keys: CLASS.PROF_NUM = EMPLOYEE.EMP_NUM, EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM, and PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE.", "We filter the results by the department name 'Computer Information Systems'.", "We select distinct first names and highest degrees to avoid duplicates."], "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"], "pred_sql": "SELECT DISTINCT T2.emp_fname, T3.prof_high_degree \nFROM CLASS AS T1 \nJOIN EMPLOYEE AS T2 ON T1.prof_num = T2.emp_num \nJOIN PROFESSOR AS T3 ON T2.emp_num = T3.emp_num \nJOIN DEPARTMENT AS T4 ON T4.dept_code = T3.dept_code \nWHERE T4.dept_name = 'Computer Information Systems'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a distinct list of first names of employees and their highest degrees from the 'CLASS', 'EMPLOYEE', 'PROFESSOR', and 'DEPARTMENT' tables. The results are filtered based on a specific department name provided as a placeholder.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    }\n}\n"}
{"sample_id": "train.3333", "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: DEPARTMENT, COURSE, and CLASS are needed to find the department name based on class description.", "The DEPARTMENT table contains the department names and codes.", "The COURSE table contains course descriptions and is linked to the DEPARTMENT table via DEPT_CODE.", "The CLASS table contains class information and is linked to the COURSE table via CRS_CODE.", "To find classes with descriptions containing 'Statistics', a WHERE clause with a LIKE condition is necessary on the COURSE table's CRS_DESCRIPTION column.", "Join the tables appropriately to connect DEPARTMENT to CLASS through COURSE, ensuring we can retrieve the department name for classes that match the description criteria."], "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"], "pred_sql": "SELECT D.DEPT_NAME \nFROM DEPARTMENT D \nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE \nJOIN CLASS CL ON C.CRS_CODE = CL.CRS_CODE \nWHERE C.CRS_DESCRIPTION LIKE '%Statistics%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes for professors who hold a specific highest degree. The results are grouped by department code and ordered by the number of professors in each department, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the degree type and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of professors grouped by their department code, specifically for those professors who hold a certain highest degree. The placeholder in the WHERE clause represents the degree level being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY dept_code\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of department names and their corresponding department codes from the 'professor' and 'department' tables. It filters the results based on the highest degree obtained by professors, using a placeholder for the degree type. The results are grouped by department code and ordered by the number of professors in each department, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3343", "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["The user wants to know the types and countries of competitions.", "To get the types of competitions, we need to select the 'Competition_type' column from the 'competition' table.", "To get the countries where these competitions were held, we need to select the 'Country' column from the same table.", "We can use DISTINCT to ensure that we get unique combinations of competition types and countries.", "The final SQL query will select both 'Competition_type' and 'Country' from the 'competition' table."], "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"], "pred_sql": "SELECT DISTINCT Competition_type, Country FROM competition;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared.\",\n        \"virtual_table\": \"SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the countries that hosted competitions of a specific type, by finding the intersection of countries from two separate queries for the same competition type. The placeholders in the WHERE clause represent the type of competition being queried.\",\n        \"virtual_table\": \"SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the countries where competitions were held, excluding those countries that hosted competitions of a specific type. The placeholder in the WHERE clause represents the type of competition to be excluded.\",\n        \"virtual_table\": \"SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3355", "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["Identify the tables needed: 'club' for club names and 'player' for player names.", "Determine the relationship between the tables: 'player' has a foreign key 'Club_ID' that references 'club'.", "Use a JOIN operation to combine data from both tables based on the 'Club_ID'.", "Select the desired columns: club name from 'club' and player name from 'player'."], "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"], "pred_sql": "SELECT c.name AS club_name, p.name AS player_name \nFROM club c \nJOIN player p ON c.Club_ID = p.Club_ID;", "hint": "\n"}
{"sample_id": "train.3364", "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["We need to find the positions of players whose average points scored is greater than 20.", "To do this, we will select the 'Position' column from the 'player' table.", "We will group the results by 'Position' to calculate the average points for each position.", "We will use the HAVING clause to filter the groups where the average points (calculated using AVG(Points)) is greater than 20."], "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"], "pred_sql": "SELECT Position\nFROM player\nGROUP BY Position\nHAVING AVG(Points) > 20;", "hint": "\n"}
{"sample_id": "train.3374", "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant column for player positions, which is 'Position'.", "Identify the column that contains the points scored by players, which is 'Points'.", "Formulate the condition to filter players based on their points: greater than 20 or less than 10.", "Construct the SQL query to select the 'Position' from the 'player' table where the points meet the specified conditions."], "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"], "pred_sql": "SELECT Position FROM player WHERE Points > 20 OR Points < 10;", "hint": "\n"}
{"sample_id": "train.3383", "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competitions, including their type and country.", "Filter for tournament competitions: We need to focus on rows where the competition_type is 'tournament'.", "Count the number of tournaments per country: Use COUNT(*) to count the number of tournaments for each country.", "Group the results by country: Use GROUP BY to aggregate the counts by country.", "Order the results: Use ORDER BY to sort the countries by the count of tournaments in descending order.", "Limit the results to the top country: Use LIMIT 1 to get only the country with the most tournaments."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT Country, COUNT(*) as Tournament_Count \nFROM competition \nWHERE competition_type = 'tournament' \nGROUP BY Country \nORDER BY Tournament_Count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared.\",\n        \"virtual_table\": \"SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the countries that hosted competitions of a specific type, by finding the intersection of countries from two separate queries for the same competition type. The placeholders in the WHERE clause represent the type of competition being queried.\",\n        \"virtual_table\": \"SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the countries where competitions were held, excluding those countries that hosted competitions of a specific type. The placeholder in the WHERE clause represents the type of competition to be excluded.\",\n        \"virtual_table\": \"SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3384", "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competitions, including the type and country.", "Filter for tournament competitions: We need to focus on rows where the competition_type is 'tournament'.", "Count the occurrences: We will count how many times each country appears in the tournament competitions.", "Group by country: To get the count per country, we will use GROUP BY on the country column.", "Order by count: We want the country with the most tournaments, so we will order the results in descending order of the count.", "Limit to one result: Finally, we will limit the output to just one row to get the country with the highest count."], "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"], "pred_sql": "SELECT country, COUNT(*) as tournament_count \nFROM competition \nWHERE competition_type = 'tournament' \nGROUP BY country \nORDER BY tournament_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared.\",\n        \"virtual_table\": \"SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the countries that hosted competitions of a specific type, by finding the intersection of countries from two separate queries for the same competition type. The placeholders in the WHERE clause represent the type of competition being queried.\",\n        \"virtual_table\": \"SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the countries where competitions were held, excluding those countries that hosted competitions of a specific type. The placeholder in the WHERE clause represents the type of competition to be excluded.\",\n        \"virtual_table\": \"SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3388", "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["Identify the countries that have hosted competitions by selecting the 'country' from the 'competition' table.", "Use the EXCEPT clause to exclude countries that have hosted friendly-type competitions.", "The placeholder in the hint is replaced with 'friendly' to specify the type of competition to be excluded."], "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"], "pred_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type = 'friendly'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the countries where competitions were held, excluding those countries that hosted competitions of a specific type. The placeholder in the WHERE clause represents the type of competition to be excluded.\",\n        \"virtual_table\": \"SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the countries that hosted competitions of two specific types. The placeholders in the query represent the types of competitions being compared.\",\n        \"virtual_table\": \"SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the countries that hosted competitions of a specific type, by finding the intersection of countries from two separate queries for the same competition type. The placeholders in the WHERE clause represent the type of competition being queried.\",\n        \"virtual_table\": \"SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT country FROM competition WHERE competition_type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3407", "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["The task is to list the full name (first and last name) and salary of employees earning below 6000.", "We need to select the columns 'first_name', 'last_name', and 'salary' from the 'employees' table.", "To filter the employees based on their salary, we will use a WHERE clause that specifies 'salary < 6000'.", "The final SQL query combines these elements to retrieve the desired information."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, salary FROM employees WHERE salary < 6000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3418", "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: full name (first and last name), hire date, salary, and department id.", "The data is sourced from the 'employees' table.", "To get the full name, we will select both 'first_name' and 'last_name'.", "We need to include 'hire_date', 'salary', and 'department_id' in the SELECT clause as well.", "To filter out employees whose first names contain the letter 'M', we will use a WHERE clause with the condition 'first_name NOT LIKE '%M%'.", "Combine all these elements into a single SQL SELECT statement."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, hire_date, salary, department_id FROM employees WHERE first_name NOT LIKE '%M%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3419", "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the required fields: first name, last name, hire date, salary, and department number from the employees table.", "Filter the employees whose first name does not contain the letter 'M'. This is done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by department number using ORDER BY clause."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, hire_date, salary, department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3420", "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the required fields: full name (first and last name), hire date, salary, and department ID.", "To create the full name, concatenate first_name and last_name with a space in between.", "Filter employees whose first name does not contain the letter 'M' using the NOT LIKE clause.", "Order the results by department_id in ascending order."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name, hire_date, salary, department_id \nFROM employees \nWHERE first_name NOT LIKE '%M%' \nORDER BY department_id ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3442", "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The question pertains to job titles and salaries, so we will focus on the 'jobs' table.", "Determine the condition: We need to find jobs with salaries over 9000, which corresponds to the 'MAX_SALARY' column in the 'jobs' table.", "Construct the SQL query: We will select the 'JOB_TITLE' from the 'jobs' table where 'MAX_SALARY' is greater than 9000."], "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MAX_SALARY > 9000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3444", "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The question asks for job titles and salary ranges, which are found in the 'jobs' table.", "Determine the columns needed: We need 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY' from the 'jobs' table.", "Apply the condition: The question specifies that we want jobs with a maximum salary between 12000 and 18000.", "Construct the SQL query: Using the SELECT statement to retrieve the required columns and applying the WHERE clause to filter based on the maximum salary."], "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY FROM jobs WHERE MAX_SALARY BETWEEN 12000 AND 18000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3448", "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["We need to find the employee IDs and the final dates of employment at their last job.", "The relevant tables are 'employees' and 'job_history'.", "We will join the 'employees' table with the 'job_history' table on the EMPLOYEE_ID column to get the necessary information.", "To find the last job's end date for each employee, we will use a subquery that selects the maximum END_DATE from the job_history table for each employee.", "The final SQL query will select the EMPLOYEE_ID from the employees table and the corresponding maximum END_DATE from the job_history table."], "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"], "pred_sql": "SELECT e.EMPLOYEE_ID, j.END_DATE\nFROM employees e\nJOIN job_history j ON e.EMPLOYEE_ID = j.EMPLOYEE_ID\nWHERE j.END_DATE = (SELECT MAX(END_DATE) FROM job_history WHERE EMPLOYEE_ID = e.EMPLOYEE_ID)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3453", "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["Identify the tables needed: 'employees' for employee data and 'departments' for department information.", "We need to calculate the average salary, so we will use the AVG() function on the SALARY column from the 'employees' table.", "We need to filter employees who receive a commission, which means we will check for non-null values in the COMMISSION_PCT column.", "To relate employees to their respective departments, we will perform a JOIN between 'employees' and 'departments' on the DEPARTMENT_ID column.", "Finally, we will group the results by DEPARTMENT_ID to get the average salary for each department."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT d.DEPARTMENT_ID, AVG(e.SALARY) AS average_salary\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nWHERE e.COMMISSION_PCT IS NOT NULL\nGROUP BY d.DEPARTMENT_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\",\n        \"virtual_table\": \"SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifier, first name, last name, and salary, from the 'employees' table. It filters the results to show only those employees whose salary is greater than the average salary of all employees and belong to departments where the first name of at least one employee matches a specified pattern.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3454", "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["Identify the table that contains salary information, which is the 'employees' table.", "Determine the condition for filtering employees, which is that the 'COMMISSION_PCT' should not be null.", "Use the AVG() function to calculate the average salary of the filtered employees.", "Construct the SQL query to select the average salary from the 'employees' table with the specified condition."], "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT AVG(SALARY) AS average_salary FROM employees WHERE COMMISSION_PCT IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\",\n        \"virtual_table\": \"SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifier, first name, last name, and salary, from the 'employees' table. It filters the results to show only those employees whose salary is greater than the average salary of all employees and belong to departments where the first name of at least one employee matches a specified pattern.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3455", "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["Identify the required columns: COUNTRY_ID from the countries table and the count of cities from the locations table.", "To get the number of cities for each country, we need to join the countries table with the locations table on the COUNTRY_ID.", "Use COUNT function to count the number of cities for each country.", "Group the results by COUNTRY_ID to ensure we get a count for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT countries.COUNTRY_ID, COUNT(locations.CITY) AS number_of_cities\nFROM countries\nJOIN locations ON countries.COUNTRY_ID = locations.COUNTRY_ID\nGROUP BY countries.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3456", "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["Identify the tables needed: 'countries' for country information and 'locations' for city information.", "Determine the relationship between the tables: 'countries' and 'locations' are linked by 'COUNTRY_ID'.", "Use a JOIN operation to combine data from both tables based on 'COUNTRY_ID'.", "Count the number of cities (from the 'locations' table) for each country (from the 'countries' table).", "Group the results by 'COUNTRY_ID' to get the count of cities for each country."], "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"], "pred_sql": "SELECT c.COUNTRY_ID, COUNT(l.CITY) AS CITY_COUNT\nFROM countries c\nJOIN locations l ON c.COUNTRY_ID = l.COUNTRY_ID\nGROUP BY c.COUNTRY_ID;", "hint": "\n"}
{"sample_id": "train.3465", "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["Identify the requirement: We need to return all detailed information about jobs done by employees earning a salary of 12000 or more.", "Determine the relevant tables: The 'jobs' table contains the job details, and the 'employees' table contains employee salary information.", "We need to filter jobs based on the employees' salaries. This requires a subquery that selects job IDs from the 'employees' table where the salary is 12000 or more.", "The subquery will return a list of JOB_IDs from the 'employees' table that meet the salary condition.", "The main query will select all columns from the 'jobs' table where the JOB_ID is in the list returned by the subquery."], "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"], "pred_sql": "SELECT jobs.* FROM jobs WHERE jobs.JOB_ID IN (SELECT employees.JOB_ID FROM employees WHERE employees.SALARY >= 12000)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifier, first name, last name, and salary, from the 'employees' table. It filters the results to show only those employees whose salary is greater than the average salary of all employees and belong to departments where the first name of at least one employee matches a specified pattern.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3482", "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the employees who are managers by checking the 'manager_id' in the 'employees' table.", "Use a subquery to select distinct 'manager_id' values from the 'employees' table, ensuring that we only consider non-null values.", "Select all information from the 'employees' table where the 'EMPLOYEE_ID' matches any of the 'manager_id' values identified in the subquery."], "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"], "pred_sql": "SELECT e.* FROM employees e WHERE e.EMPLOYEE_ID IN (SELECT DISTINCT manager_id FROM employees WHERE manager_id IS NOT NULL)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifier, first name, last name, and salary, from the 'employees' table. It filters the results to show only those employees whose salary is greater than the average salary of all employees and belong to departments where the first name of at least one employee matches a specified pattern.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3487", "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["Identify the relevant table: The 'employees' table contains information about employees and their associated departments and managers.", "Group the results by department_id and manager_id: This allows us to count the number of employees managed by each manager in each department.", "Use the COUNT function: We need to count the number of employees (employee_id) in each group to determine how many employees each manager is managing.", "Filter the results with HAVING clause: We only want departments where the count of employees is 4 or more, so we use HAVING COUNT(employee_id) >= 4.", "Select distinct department_id: To get unique department identifiers that meet the criteria, we use SELECT DISTINCT."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id, manager_id HAVING COUNT(employee_id) >= 4", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\",\n        \"virtual_table\": \"SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3488", "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["The task requires us to find distinct department IDs where a manager oversees 4 or more employees.", "We will use the 'employees' table, which contains information about employees and their respective departments and managers.", "To achieve this, we will group the results by 'department_id' and 'manager_id' to count the number of employees in each department managed by each manager.", "We will use the HAVING clause to filter the groups to only include those with a count of employees greater than or equal to 4.", "Finally, we will select distinct 'department_id' from these filtered results."], "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"], "pred_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id, manager_id HAVING COUNT(employee_id) >= 4", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\",\n        \"virtual_table\": \"SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3496", "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["Identify the relevant table: The 'employees' table contains the information about employees and their salaries.", "Determine the conditions for filtering: We need employees with salaries above the minimum salary and below 2500.", "Use a subquery to get the minimum salary from the 'jobs' table: This will allow us to compare each employee's salary against the minimum salary for their job.", "Construct the SQL query: Select all columns from the 'employees' table where the salary is greater than the minimum salary and less than 2500."], "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"], "pred_sql": "SELECT * FROM employees WHERE salary > (SELECT MIN_SALARY FROM jobs) AND salary < 2500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3500", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara?", "rationale": ["Identify the requirement: We need the full names and hire dates of employees in the same department as someone named Clara.", "To find Clara's department, we will use a subquery that selects the department_id from the employees table where the first name is 'Clara'.", "The main query will select the first name, last name, and hire date from the employees table where the department_id matches the one found in the subquery.", "Combine both queries to form a complete SQL statement."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, hire_date FROM employees WHERE department_id IN (SELECT department_id FROM employees WHERE first_name = 'Clara')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.3502", "db_id": "hr_1", "question": "What are the full names and hire dates for employees in the same department as someone with the first name Clara, not including Clara?", "rationale": ["Identify the requirement to find full names and hire dates of employees in the same department as Clara.", "Use a subquery to find the department_id of the employee named Clara.", "Filter the main query to select first names, last names, and hire dates from the employees table where the department_id matches Clara's department_id.", "Exclude Clara from the results by adding a condition to ensure first_name is not Clara."], "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  ( SELECT department_id FROM employees WHERE first_name  =  'Clara') AND first_name != 'Clara'", "source_tables": ["employees"], "pred_sql": "SELECT first_name, last_name, hire_date \nFROM employees \nWHERE department_id = (SELECT department_id FROM employees WHERE first_name = 'Clara') \nAND first_name != 'Clara';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3503", "db_id": "hr_1", "question": "display the employee number and name( first name and last name ) for all employees who work in a department with any employee whose name contains a \u2019T\u2019.", "rationale": ["Identify the requirement to display employee number and name for employees in departments with any employee whose name contains 'T'.", "Use a subquery to find department IDs of employees whose first or last name contains 'T'.", "The subquery will select department_id from employees where first_name or last_name matches the pattern '%T%'.", "The outer query will select employee_id, first_name, and last_name from employees where their department_id is in the list returned by the subquery."], "gold_sql": "SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' )", "source_tables": ["employees"], "pred_sql": "SELECT employee_id, first_name, last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE '%T%' OR last_name LIKE '%T%' )", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3507", "db_id": "hr_1", "question": "display the employee number and job id for all employees whose salary is smaller than any salary of those employees whose job title is MK_MAN.", "rationale": ["Identify the main requirement: we need to display employee number (EMPLOYEE_ID) and job id (JOB_ID) for employees whose salary is smaller than any salary of those with the job title 'MK_MAN'.", "To find the salaries of employees with the job title 'MK_MAN', we need to first get the JOB_ID associated with that title from the jobs table.", "Next, we will use this JOB_ID to find the minimum salary of employees holding that job title.", "Finally, we will select the EMPLOYEE_ID and JOB_ID from the employees table where their salary is less than the minimum salary found in the previous step."], "gold_sql": "SELECT employee_id ,  job_id FROM employees WHERE salary  <  ( SELECT min(salary) FROM employees WHERE job_id  =  'MK_MAN' )", "source_tables": ["employees"], "pred_sql": "SELECT EMPLOYEE_ID, JOB_ID FROM employees WHERE SALARY < (SELECT MIN(SALARY) FROM employees WHERE JOB_ID = (SELECT JOB_ID FROM jobs WHERE JOB_TITLE = 'MK_MAN'))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifiers, first names, last names, and job identifiers, who earn a salary greater than the maximum salary for a specified job. The placeholder in the subquery represents the job identifier for which the maximum salary is being compared.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  job_id FROM employees WHERE salary  >  ( SELECT max(salary) FROM employees WHERE job_id  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3512", "db_id": "hr_1", "question": "What are total salaries and department id for each department that has more than 2 employees?", "rationale": ["We need to find the total salaries and department IDs for each department with more than 2 employees.", "To achieve this, we will use the 'employees' table which contains the necessary information about employees and their salaries.", "We will group the results by 'DEPARTMENT_ID' to aggregate the salaries for each department.", "We will use the SUM function to calculate the total salary for each department.", "To filter departments with more than 2 employees, we will use the HAVING clause with COUNT(EMPLOYEE_ID) > 2."], "gold_sql": "SELECT department_id ,  SUM(salary) FROM employees GROUP BY department_id HAVING count(*)  >=  2", "source_tables": ["employees"], "pred_sql": "SELECT DEPARTMENT_ID, SUM(SALARY) AS TOTAL_SALARY \nFROM employees \nGROUP BY DEPARTMENT_ID \nHAVING COUNT(EMPLOYEE_ID) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3515", "db_id": "hr_1", "question": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.", "rationale": ["We need to display the department ID, full name (first and last name), and salary of employees who have the highest salary in each department.", "To achieve this, we will first create a subquery that groups employees by their department ID and selects the maximum salary for each department.", "The subquery will look like: SELECT DEPARTMENT_ID, MAX(SALARY) AS MAX_SALARY FROM employees GROUP BY DEPARTMENT_ID.", "Next, we will join this subquery with the employees table on both the DEPARTMENT_ID and the condition that the employee's salary matches the maximum salary from the subquery.", "Finally, we will select the required fields: DEPARTMENT_ID, concatenated first and last names as FULL_NAME, and SALARY from the joined result."], "gold_sql": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id", "source_tables": ["employees"], "pred_sql": "SELECT e.DEPARTMENT_ID, e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.SALARY \nFROM employees e \nJOIN (SELECT DEPARTMENT_ID, MAX(SALARY) AS MAX_SALARY \n      FROM employees \n      GROUP BY DEPARTMENT_ID) AS max_salaries \nON e.DEPARTMENT_ID = max_salaries.DEPARTMENT_ID AND e.SALARY = max_salaries.MAX_SALARY;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifier, first name, last name, and salary, from the 'employees' table. It filters the results to show only those employees whose salary is greater than the average salary of all employees and belong to departments where the first name of at least one employee matches a specified pattern.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3520", "db_id": "hr_1", "question": "What are the full names and cities of employees who have the letter Z in their first names?", "rationale": ["Identify the relevant tables: employees, departments, and locations are needed to get employee names and their corresponding cities.", "To get the full names of employees, concatenate first_name and last_name from the employees table.", "To find the city of each employee, join the employees table with the departments table on DEPARTMENT_ID, and then join with the locations table on LOCATION_ID.", "Filter the results to include only those employees whose first names contain the letter 'Z' using the LIKE operator."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T3.city FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id WHERE T1.first_name LIKE '%z%'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name, city \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID \nWHERE first_name LIKE '%Z%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3523", "db_id": "hr_1", "question": "display the full name (first and last name ) of employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the tables needed: employees, departments, locations, and countries.", "We need to join these tables to get the employee's full name and the country they are currently working in.", "Join employees with departments on DEPARTMENT_ID to get department information.", "Join departments with locations on LOCATION_ID to get location information.", "Join locations with countries on COUNTRY_ID to get the country name.", "Select the first name and last name from employees and the country name from countries.", "Use a WHERE clause to filter by the specific employee ID provided."], "gold_sql": "SELECT T1.first_name ,  T1.last_name , T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, c.COUNTRY_NAME \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE e.EMPLOYEE_ID = ?", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the employee ID, first name, and last name of employees from the 'employees' table who belong to the same department as a specified employee. The placeholder in the WHERE clause allows for filtering based on the first name of the employee.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name FROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    }\n}\n"}
{"sample_id": "train.3525", "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["We need to display the department name and the number of employees in each department.", "To achieve this, we will select the 'DEPARTMENT_NAME' from the 'departments' table.", "We will also count the number of employees associated with each department using the 'employees' table.", "To link the two tables, we will use a LEFT JOIN on 'DEPARTMENT_ID'.", "Finally, we will group the results by 'DEPARTMENT_NAME' to get the count of employees per department."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the identifiers of departments from the 'employees' table that have more than a specified number of employees receiving a commission. The placeholder in the HAVING clause represents the minimum count of employees with a commission percentage.\",\n        \"virtual_table\": \"SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3526", "db_id": "hr_1", "question": "What are the department names and how many employees work in each of them?", "rationale": ["We need to retrieve the names of departments and the count of employees in each department.", "The relevant tables are 'departments' for department names and 'employees' for employee information.", "We will use a LEFT JOIN to connect the 'departments' table with the 'employees' table on the DEPARTMENT_ID column, ensuring we include all departments even if they have no employees.", "We will use COUNT() to count the number of employees in each department, grouping the results by department name to get the desired output."], "gold_sql": "SELECT department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY department_name", "source_tables": ["employees", "departments"], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS employee_count \nFROM departments d \nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_NAME;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists unique department identifiers from the 'employees' table, grouped by department and manager. It filters the results to include only those departments that have a specified minimum number of employees, represented by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3527", "db_id": "hr_1", "question": "display the full name (first and last name), and salary of those employees who working in any department located in London.", "rationale": ["Identify the required fields: first name, last name, and salary of employees.", "Determine the relevant tables: employees, departments, and locations.", "Establish relationships between the tables: employees are linked to departments via DEPARTMENT_ID, and departments are linked to locations via LOCATION_ID.", "Filter the results to include only those employees who work in departments located in London by using a WHERE clause on the CITY field in the locations table."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of employees along with their department identifiers from the 'employees' table, specifically targeting those employees who earn the minimum salary within their respective departments. The subquery identifies the minimum salary for each department, and the placeholder in the WHERE clause allows for dynamic filtering based on salary criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)\"\n    }\n}\n"}
{"sample_id": "train.3528", "db_id": "hr_1", "question": "What are full names and salaries of employees working in the city of London?", "rationale": ["Identify the relevant tables: employees, departments, locations, and countries.", "We need to retrieve the first name, last name, and salary of employees.", "To get the city information, we need to join the employees table with the departments table (to get department IDs), then with the locations table (to get location IDs), and finally with the countries table (to link to the city).", "The join conditions will be based on the foreign keys: employees.DEPARTMENT_ID = departments.DEPARTMENT_ID, departments.LOCATION_ID = locations.LOCATION_ID, and locations.COUNTRY_ID = countries.COUNTRY_ID.", "Filter the results to only include employees who work in the city of London using a WHERE clause."], "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN  locations AS T3 ON T2.location_id  =  T3.location_id WHERE  T3.city  =  'London'", "source_tables": ["employees", "departments", "locations"], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, e.SALARY \nFROM employees e \nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID \nJOIN locations l ON d.LOCATION_ID = l.LOCATION_ID \nJOIN countries c ON l.COUNTRY_ID = c.COUNTRY_ID \nWHERE l.CITY = 'London';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names, last names, salaries, and department IDs of employees from the 'employees' table, grouped by department. The placeholder in the SELECT clause represents the maximum salary within each department.\",\n        \"virtual_table\": \"SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of employees' first names, last names, hire dates, salaries, and their department identifiers from the 'employees' table, excluding those whose first names match a specific pattern. The placeholder in the WHERE clause allows for filtering based on the first name criteria.\",\n        \"virtual_table\": \"SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of employees, including their unique identifier, first name, last name, and salary, from the 'employees' table. It filters the results to show only those employees whose salary is greater than the average salary of all employees and belong to departments where the first name of at least one employee matches a specified pattern.\",\n        \"virtual_table\": \"SELECT employee_id ,  first_name ,  last_name ,  salary FROM employees WHERE salary  >  ( SELECT AVG (salary) FROM employees ) AND department_id IN ( SELECT department_id FROM employees WHERE first_name LIKE [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.3532", "db_id": "music_1", "question": "Find the id of the song that lasts the longest.", "rationale": ["Identify the tables involved: We need to find the song with the longest duration, which involves the 'files' and 'song' tables.", "Determine the relevant columns: We need the 'duration' from the 'files' table and the 'f_id' from the 'song' table.", "Find the maximum duration: We can use a subquery to find the maximum duration from the 'files' table.", "Join the tables: We will join the 'files' and 'song' tables on 'f_id' to get the corresponding song for the maximum duration.", "Select the song ID: Finally, we will select the 'f_id' of the song that has the maximum duration."], "gold_sql": "SELECT f_id FROM files ORDER BY duration DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT T2.f_id FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id WHERE T1.duration = (SELECT max(duration) FROM files)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of song titles from the 'files' and 'song' tables based on specific criteria. It retrieves song names associated with files that match a certain duration and also includes song names that are available in a specified language. The placeholders in the WHERE clause represent the duration format and the language of the songs.\",\n        \"virtual_table\": \"SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING] UNION SELECT song_name FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of song titles from the 'files' and 'song' tables based on specific criteria. It retrieves song names associated with files that match a certain duration and also includes song names from the 'song' table that are available in a specified language. The placeholders in the WHERE clause represent the duration format and the language of the songs.\",\n        \"virtual_table\": \"SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING] UNION SELECT song_name FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3542", "db_id": "music_1", "question": "What are the names of the artists who sang the shortest song?", "rationale": ["Identify the relevant table: The 'song' table contains information about songs, including their duration and the artist who performed them.", "Determine the requirement: We need to find the names of artists who sang the shortest song, which means we need to order the songs by their duration in ascending order.", "Construct the SQL query: We will select the 'artist_name' from the 'song' table, order the results by 'duration' in ascending order, and limit the results to 1 to get the shortest song.", "Final SQL query: SELECT artist_name FROM song ORDER BY duration ASC LIMIT 1."], "gold_sql": "SELECT T1.artist_name FROM song AS T1 JOIN files AS T2 ON T1.f_id  =  T2.f_id ORDER BY T2.duration LIMIT 1", "source_tables": ["files", "song"], "pred_sql": "SELECT artist_name FROM song ORDER BY duration ASC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3545", "db_id": "music_1", "question": "How many songs have 4 minute duration?", "rationale": ["Identify the tables involved: We need to count songs based on their duration, so we will use the 'files' and 'song' tables.", "Determine the relationship: The 'files' table contains the duration of the audio files, and the 'song' table contains the song details. They are linked by the 'f_id' column.", "Formulate the query: We will join the 'files' and 'song' tables on 'f_id' and filter for songs with a duration of 4 minutes (formatted as '4:00').", "Count the number of songs that meet this criteria using COUNT()."], "gold_sql": "SELECT count(*) FROM files WHERE duration LIKE '4:%'", "source_tables": ["files"], "pred_sql": "SELECT COUNT(T2.song_name) FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id WHERE T1.duration = '4:00'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n        \"virtual_table\": \"SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of song titles from the 'files' and 'song' tables based on specific criteria. It retrieves song names associated with files that match a certain duration and also includes song names that are available in a specified language. The placeholders in the WHERE clause represent the duration format and the language of the songs.\",\n        \"virtual_table\": \"SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING] UNION SELECT song_name FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3549", "db_id": "music_1", "question": "What is the average rating of songs produced by female artists?", "rationale": ["Identify the tables needed: We need data from the 'artist' table to filter by gender and from the 'song' table to get the ratings.", "We want to calculate the average rating of songs, so we will use the AVG() function on the 'rating' column from the 'song' table.", "To link the two tables, we will join them on the 'artist_name' column, which is common to both tables.", "We need to filter the results to include only female artists, so we will add a WHERE clause to specify that the gender must be 'female'.", "Finally, we will select the average rating using AVG() and alias it as 'average_rating'."], "gold_sql": "SELECT avg(T2.rating) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female'", "source_tables": ["artist", "song"], "pred_sql": "SELECT AVG(T2.rating) AS average_rating\nFROM artist AS T1\nJOIN song AS T2 ON T1.artist_name = T2.artist_name\nWHERE T1.gender = 'female';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n        \"virtual_table\": \"SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3552", "db_id": "music_1", "question": "Find the file format that is used by the most files.", "rationale": ["To find the file format used by the most files, we need to count the occurrences of each format in the 'files' table.", "We will use the COUNT() function to count how many times each format appears.", "We will group the results by the 'formats' column to aggregate the counts for each format.", "To get the format that is used the most, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one entry to get the most used format."], "gold_sql": "SELECT formats FROM files GROUP BY formats ORDER BY COUNT (*) DESC LIMIT 1", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(*) as file_count FROM files GROUP BY formats ORDER BY file_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n        \"virtual_table\": \"SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of song titles from the 'files' and 'song' tables based on specific criteria. It retrieves song names associated with files that match a certain duration and also includes song names that are available in a specified language. The placeholders in the WHERE clause represent the duration format and the language of the songs.\",\n        \"virtual_table\": \"SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING] UNION SELECT song_name FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3556", "db_id": "music_1", "question": "What is the id of the files that are available in the format of mp4 and a resolution smaller than 1000?", "rationale": ["Identify the relevant table: The 'files' table contains the 'f_id', 'formats', and 'resolution' columns needed for the query.", "Determine the conditions: We need to filter files that are in the 'mp4' format and have a resolution smaller than 1000.", "Construct the SQL query: Use a SELECT statement to retrieve 'f_id' from the 'files' table, applying the WHERE clause to filter based on the specified conditions."], "gold_sql": "SELECT f_id FROM files WHERE formats  =  'mp4' INTERSECT SELECT f_id FROM song WHERE resolution  <  1000", "source_tables": ["files", "song"], "pred_sql": "SELECT f_id FROM files WHERE formats LIKE '%mp4%' AND resolution < 1000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n        \"virtual_table\": \"SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3557", "db_id": "music_1", "question": "What is the country of origin of the artist who is female and produced a song in Bangla?", "rationale": ["Identify the relevant tables: 'artist' and 'song'.", "We need to find the country of origin of female artists who produced songs in Bangla.", "Join the 'artist' table with the 'song' table on the artist's name to access both artists' information and their songs.", "Filter the results to include only female artists by checking the 'gender' column in the 'artist' table.", "Further filter the results to include only songs that are in Bangla by checking the 'languages' column in the 'song' table.", "Select the 'country' column from the 'artist' table to get the desired output."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE artist.gender = 'female' AND song.languages = 'Bangla';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3558", "db_id": "music_1", "question": "What countries are the female artists who sung in the language Bangla from?", "rationale": ["Identify the relevant tables: We need information from the 'artist' table for the country and gender, and from the 'song' table for the language.", "Filter the 'artist' table to only include female artists.", "Use a subquery to find artists who have songs in the Bangla language by joining the 'artist' and 'song' tables on artist_name.", "Select the country of these female artists who sing in Bangla."], "gold_sql": "SELECT T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T1.gender  =  'Female' AND T2.languages  =  'bangla'", "source_tables": ["artist", "song"], "pred_sql": "SELECT country FROM artist WHERE gender = 'female' AND artist_name IN (SELECT artist_name FROM song WHERE languages = 'Bangla')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3566", "db_id": "music_1", "question": "What is the gender and name of the artist who sang the song with the smallest resolution?", "rationale": ["Identify the tables needed: We need information from the 'artist' table for gender and name, and from the 'song' table for resolution.", "Join the 'artist' table with the 'song' table on the artist's name to get the relevant details together.", "Use a subquery to find the minimum resolution from the 'song' table.", "Filter the results to only include artists whose songs have this minimum resolution."], "gold_sql": "SELECT T1.gender ,  T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name ORDER BY T2.resolution LIMIT 1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.gender, artist.artist_name \nFROM artist \nJOIN song ON artist.artist_name = song.artist_name \nWHERE song.resolution = (SELECT MIN(resolution) FROM song)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    }\n}\n"}
{"sample_id": "train.3567", "db_id": "music_1", "question": "For each file format, return the number of artists who released songs in that format.", "rationale": ["We need to count the number of distinct artists for each file format.", "To do this, we will join the 'files' table with the 'song' table on the 'f_id' column, which is the unique identifier for the file associated with the song.", "Next, we will select the 'formats' column from the 'files' table and count the distinct 'artist_name' from the 'song' table.", "Finally, we will group the results by 'formats' to get the count of artists for each format."], "gold_sql": "SELECT count(*) ,  formats FROM files GROUP BY formats", "source_tables": ["files"], "pred_sql": "SELECT formats, COUNT(DISTINCT artist_name) AS artist_count FROM files JOIN song ON files.f_id = song.f_id GROUP BY formats;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3576", "db_id": "music_1", "question": "What are the names and genders of all artists who released songs in the month of March?", "rationale": ["Identify the relevant tables: We need information from the 'artist' table for names and genders, and from the 'song' table to filter by release date.", "Join the 'artist' and 'song' tables on the artist's name to combine the necessary information.", "Use the strftime function to extract the month from the 'releasedate' column in the 'song' table and filter for March (03).", "Select the artist's name and gender from the joined tables."], "gold_sql": "SELECT T1.artist_name ,  T1.gender FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.releasedate LIKE '%Mar%'", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.gender FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE strftime('%m', song.releasedate) = '03';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3586", "db_id": "music_1", "question": "What are the languages that are used most often in songs?", "rationale": ["The question asks for the languages used most often in songs, which implies we need to count occurrences of each language in the 'song' table.", "To achieve this, we will select the 'languages' column from the 'song' table and count how many times each language appears.", "We will group the results by 'languages' to aggregate the counts for each language.", "Finally, we will order the results in descending order based on the count of songs for each language to identify the most frequently used languages."], "gold_sql": "SELECT languages FROM song GROUP BY languages ORDER BY count(*) DESC LIMIT 1", "source_tables": ["song"], "pred_sql": "SELECT languages, COUNT(*) as song_count FROM song GROUP BY languages ORDER BY song_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3590", "db_id": "music_1", "question": "What are the names of all male British artists?", "rationale": ["Identify the relevant table: The 'artist' table contains information about artists, including their country and gender.", "Determine the filtering criteria: We need to filter for artists who are from Britain and are male.", "Construct the SQL query: Use a SELECT statement to retrieve the 'artist_name' from the 'artist' table, applying the necessary WHERE conditions for country and gender."], "gold_sql": "SELECT artist_name FROM artist WHERE country  =  'UK' AND gender  =  'Male'", "source_tables": ["artist"], "pred_sql": "SELECT artist_name FROM artist WHERE country = 'Britain' AND gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3598", "db_id": "music_1", "question": "What is the average rating and resolution of all bangla songs?", "rationale": ["Identify the tables needed: We need data from the 'song' table for ratings and the 'files' table for resolution.", "We need to calculate the average rating of songs that belong to the Bangla genre, so we will filter the 'song' table by genre_is = 'Bangla'.", "To get the resolution, we will join the 'song' table with the 'files' table on the f_id column.", "We will use AVG() function to calculate the average rating and MAX() function to get the maximum resolution for Bangla songs.", "Finally, we will select these calculated values in our SQL query."], "gold_sql": "SELECT avg(rating) ,  avg(resolution) FROM song WHERE languages  =  'bangla'", "source_tables": ["song"], "pred_sql": "SELECT AVG(s.rating) AS average_rating, MAX(f.resolution) AS max_resolution \nFROM song AS s \nJOIN files AS f ON s.f_id = f.f_id \nWHERE s.genre_is = 'Bangla';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3599", "db_id": "music_1", "question": "What are the maximum and minimum resolution of songs whose duration is 3 minutes?", "rationale": ["Identify the relevant tables: We need to look at the 'song' table for song details including duration and resolution.", "Filter songs based on the duration: We want songs that have a duration of exactly 3 minutes, which is represented as '3:00'.", "Select the maximum and minimum resolution: We will use the MAX() and MIN() functions to get the highest and lowest resolution of the filtered songs.", "Construct the SQL query: Combine all the elements into a single SQL query that selects the maximum and minimum resolution from the 'song' table where the duration is '3:00'."], "gold_sql": "SELECT max(T2.resolution) ,  min(T2.resolution) FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE '3:%'", "source_tables": ["files", "song"], "pred_sql": "SELECT max(resolution) AS max_resolution, min(resolution) AS min_resolution FROM song WHERE duration = '3:00'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n        \"virtual_table\": \"SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3601", "db_id": "music_1", "question": "What are the maximum duration and resolution of songs grouped and ordered by languages?", "rationale": ["The question asks for the maximum duration and resolution of songs, which indicates the need for aggregation functions like MAX().", "We need to join the 'files' table and the 'song' table to access both duration and resolution, which are in different tables.", "The join condition is based on the foreign key relationship where 'files.f_id' matches 'song.f_id'.", "We will group the results by 'languages' from the 'song' table to get the maximum values for each language category.", "Finally, we will order the results by 'languages' to present them in a sorted manner."], "gold_sql": "SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "source_tables": ["files", "song"], "pred_sql": "SELECT max(T1.duration), max(T2.resolution), T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id GROUP BY T2.languages ORDER BY T2.languages", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3603", "db_id": "music_1", "question": "What are the shortest duration and lowest rating of songs grouped by genre and ordered by genre?", "rationale": ["Identify the tables needed: We need data from the 'files' table for duration and from the 'song' table for rating and genre.", "Use the JOIN clause to combine 'files' and 'song' tables on the foreign key 'f_id'.", "Select the minimum duration from the 'files' table and the minimum rating from the 'song' table, along with the genre from the 'song' table.", "Group the results by genre to get the shortest duration and lowest rating for each genre.", "Order the results by genre to meet the requirement of the query."], "gold_sql": "SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "source_tables": ["files", "song"], "pred_sql": "SELECT min(T1.duration) AS shortest_duration, min(T2.rating) AS lowest_rating, T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id = T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n        \"virtual_table\": \"SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3607", "db_id": "music_1", "question": "Find the name and country of origin for all artists who have release at least one song of resolution above 900.", "rationale": ["Identify the tables needed: We need information from the 'artist' table (artist_name and country) and the 'song' table (resolution).", "Determine the relationship: The 'artist' table and 'song' table are related through the artist_name column.", "Filter the songs: We need to filter songs based on the resolution being greater than 900.", "Join the tables: Use an INNER JOIN to combine the 'artist' and 'song' tables on the artist_name column.", "Select the required columns: We need to select artist_name and country from the 'artist' table."], "gold_sql": "SELECT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.resolution  >  900 GROUP BY T2.artist_name HAVING count(*)  >=  1", "source_tables": ["artist", "song"], "pred_sql": "SELECT artist.artist_name, artist.country FROM artist JOIN song ON artist.artist_name = song.artist_name WHERE song.resolution > 900;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3619", "db_id": "music_1", "question": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.", "rationale": ["Identify the tables involved: 'artist' and 'song'.", "We need to find artists who have songs in the Bangla language, so we will join the 'artist' table with the 'song' table on the artist's name.", "Filter the results to include only those songs where the language is 'Bangla'.", "Group the results by artist name to count the number of songs each artist has in Bangla.", "Order the results by the count of songs in descending order to get the artists with the most songs first.", "Limit the results to the top 3 artists."], "gold_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  'bangla' GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3", "source_tables": ["artist", "song"], "pred_sql": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name = T2.artist_name WHERE T2.languages = 'Bangla' GROUP BY T1.artist_name ORDER BY count(*) DESC LIMIT 3", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of artists from the 'artist' table who have songs available in a specific language. The query joins the 'artist' and 'song' tables on the artist's name, filters the results based on the specified language, groups the results by artist name, and orders them by the number of songs in descending order, limiting the output to a specified number of artists.\",\n        \"virtual_table\": \"SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, sorted in descending order based on the count of songs per language, and limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of artists from the 'song' table whose songs have a resolution greater than a specified value. The results are grouped by the languages in which the songs are available, and ordered by the count of songs in descending order, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT artist_name FROM song WHERE resolution  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY languages ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3623", "db_id": "music_1", "question": "List the duration, file size and format of songs whose genre is pop, ordered by title?", "rationale": ["Identify the relevant tables: 'files' and 'song' are needed to get the duration, file size, and format of songs.", "Determine the columns to select: We need 'duration' from the 'song' table, and 'file_size' and 'formats' from the 'files' table.", "Establish the join condition: The 'files' table is joined with the 'song' table on the 'f_id' column, which is common to both tables.", "Add a WHERE clause to filter for songs of the genre 'pop'.", "Order the results by the song title, which corresponds to the 'song_name' column in the 'song' table."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT T2.duration, T1.file_size, T1.formats \nFROM files AS T1 \nJOIN song AS T2 ON T1.f_id = T2.f_id \nWHERE T2.genre_is = 'pop' \nORDER BY T2.song_name;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n        \"virtual_table\": \"SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of song titles from the 'files' and 'song' tables based on specific criteria. It retrieves song names associated with files that match a certain duration and also includes song names that are available in a specified language. The placeholders in the WHERE clause represent the duration format and the language of the songs.\",\n        \"virtual_table\": \"SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING] UNION SELECT song_name FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    }\n}\n"}
{"sample_id": "train.3624", "db_id": "music_1", "question": "What is the duration, file size, and song format for every pop song, ordered by title alphabetically?", "rationale": ["Identify the relevant tables: 'files' and 'song' are needed to get the duration, file size, and format of songs.", "Join the 'files' table with the 'song' table on the foreign key 'f_id' to access both file and song details.", "Filter the results to include only those songs that belong to the 'pop' genre by using a WHERE clause.", "Select the required columns: duration from the 'song' table, and file_size and formats from the 'files' table.", "Order the results alphabetically by song title using ORDER BY clause on 'song_name'."], "gold_sql": "SELECT T1.duration ,  T1.file_size ,  T1.formats FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T2.genre_is  =  'pop' ORDER BY T2.song_name", "source_tables": ["files", "song"], "pred_sql": "SELECT T2.duration, T1.file_size, T1.formats \nFROM files AS T1 \nJOIN song AS T2 ON T1.f_id = T2.f_id \nWHERE T2.genre_is = 'pop' \nORDER BY T2.song_name ASC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum duration and resolution of audio files, along with the languages in which the songs are available. The data is aggregated by languages, allowing users to see the longest audio files and their highest resolutions for each language category.\",\n        \"virtual_table\": \"SELECT max(T1.duration) ,  max(T2.resolution) ,  T2.languages FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.languages ORDER BY T2.languages\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of song titles from the 'files' and 'song' tables based on specific criteria. It retrieves song names associated with files that match a certain duration and also includes song names that are available in a specified language. The placeholders in the WHERE clause represent the duration format and the language of the songs.\",\n        \"virtual_table\": \"SELECT T2.song_name FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id WHERE T1.duration LIKE [PLACEHOLDER-TYPE:STRING] UNION SELECT song_name FROM song WHERE languages  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the minimum duration of audio files and the minimum rating of songs grouped by their genre. The placeholders represent the necessary fields from the 'files' and 'song' tables, allowing users to analyze the relationship between audio file durations and song ratings across different genres.\",\n        \"virtual_table\": \"SELECT min(T1.duration) ,  min(T2.rating) ,  T2.genre_is FROM files AS T1 JOIN song AS T2 ON T1.f_id  =  T2.f_id GROUP BY T2.genre_is ORDER BY T2.genre_is\"\n    }\n}\n"}
{"sample_id": "train.3631", "db_id": "baseball_1", "question": "What is average salary of the players in the team named 'Boston Red Stockings' ?", "rationale": ["Identify the relevant tables: salary and team.", "We need to calculate the average salary, so we will use the AVG() function on the salary column from the salary table.", "Join the salary table with the team table on the team_id to filter salaries by team.", "Use a WHERE clause to specify the team name as 'Boston Red Stockings'.", "Select the average salary from the resulting joined table."], "gold_sql": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", "source_tables": ["team", "salary"], "pred_sql": "SELECT AVG(salary) AS average_salary \nFROM salary AS T1 \nJOIN team AS T2 ON T1.team_id = T2.team_id \nWHERE T2.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3650", "db_id": "baseball_1", "question": "What are the three countries that the least players are from?", "rationale": ["Identify the relevant table: The 'player' table contains information about players, including their birth countries.", "Select the 'birth_country' column and count the number of players from each country using COUNT(player_id).", "Group the results by 'birth_country' to aggregate the player counts for each country.", "Order the results in ascending order based on the count of players to find the countries with the least players.", "Limit the results to 3 to get only the three countries with the least players."], "gold_sql": "SELECT birth_country FROM player GROUP BY birth_country ORDER BY count(*) ASC LIMIT 3;", "source_tables": ["player"], "pred_sql": "SELECT birth_country, COUNT(player_id) AS player_count\nFROM player\nGROUP BY birth_country\nORDER BY player_count ASC\nLIMIT 3;", "hint": "\n"}
{"sample_id": "train.3657", "db_id": "baseball_1", "question": "What is the highest salary among each team? List the team name, id and maximum salary.", "rationale": ["Identify the relevant tables: We need the 'salary' table for salary information and the 'team' table for team names and IDs.", "Join the 'salary' table with the 'team' table on the 'team_id' to associate salaries with their respective teams.", "Use the MAX() function to find the highest salary for each team.", "Group the results by 'team_id' to ensure we get the maximum salary for each team.", "Select the team name, team ID, and the maximum salary in the final output."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T3.name, T3.team_id, MAX(T1.salary) AS max_salary \nFROM salary AS T1 \nJOIN team AS T3 ON T1.team_id = T3.team_id \nGROUP BY T3.team_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3658", "db_id": "baseball_1", "question": "For each team, return the team name, id and the maximum salary among the team.", "rationale": ["Identify the tables needed: 'team' for team names and IDs, and 'salary' for salary information.", "Join the 'team' table with the 'salary' table on the team ID to associate salaries with their respective teams.", "Use the MAX() function to find the maximum salary for each team.", "Group the results by team ID to ensure we get one result per team, which includes the team name, ID, and maximum salary."], "gold_sql": "SELECT T1.name ,  T1.team_id ,  max(T2.salary) FROM team AS T1 JOIN salary AS T2 ON T1.team_id  =  T2.team_id GROUP BY T1.team_id;", "source_tables": ["team", "salary"], "pred_sql": "SELECT T.name, T.team_id, MAX(S.salary) AS max_salary\nFROM team AS T\nJOIN salary AS S ON T.team_id = S.team_id\nGROUP BY T.team_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3659", "db_id": "baseball_1", "question": "What are the name and id of the team offering the lowest average salary?", "rationale": ["Identify the relevant tables: We need to use the 'salary' table to get salary information and the 'team' table to get team names and IDs.", "Join the 'salary' table with the 'team' table on 'team_id' to associate salaries with their respective teams.", "Group the results by 'team_id' to calculate the average salary for each team.", "Use the AVG() function to compute the average salary for each team.", "Order the results in ascending order of average salary to find the lowest average salary.", "Limit the results to 1 to get only the team with the lowest average salary."], "gold_sql": "SELECT T1.name ,  T1.team_id FROM team AS T1 JOIN salary AS T2 ON T1.team_id = T2.team_id GROUP BY T1.team_id ORDER BY avg(T2.salary) ASC LIMIT 1;", "source_tables": ["team", "salary"], "pred_sql": "SELECT team.team_id, team.name FROM salary JOIN team ON salary.team_id = team.team_id GROUP BY team.team_id ORDER BY AVG(salary.salary) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3661", "db_id": "baseball_1", "question": "Find the players' first name and last name who won award both in 1960 and in 1961.", "rationale": ["Identify the tables needed: We need the 'player' table for player names and the 'player_award' table for award information.", "Join the 'player' table with the 'player_award' table to get the names of players who won awards.", "Use the INTERSECT operator to find players who won awards in both 1960 and 1961.", "Construct the SQL query using the identified tables and conditions."], "gold_sql": "SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1960 INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  1961", "source_tables": ["player_award", "player"], "pred_sql": "SELECT T1.name_first, T1.name_last \nFROM player AS T1 \nJOIN player_award AS T2 ON T1.player_id = T2.player_id \nWHERE T2.year = 1960 \nINTERSECT \nSELECT T1.name_first, T1.name_last \nFROM player AS T1 \nJOIN player_award AS T2 ON T1.player_id = T2.player_id \nWHERE T2.year = 1961;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of players along with their first and last names from the 'player' table, who have received awards. The results are grouped by player ID to ensure uniqueness and are ordered by the number of awards received in descending order. The placeholder in the LIMIT clause allows the user to specify the maximum number of players to return.\",\n        \"virtual_table\": \"SELECT T1.name_first ,  T1.name_last ,  T1.player_id FROM player AS T1 JOIN player_award AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.player_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3663", "db_id": "baseball_1", "question": "List players' first name and last name who have weight greater than 220 or height shorter than 75.", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the conditions: We need to filter players based on their weight being greater than 220 or their height being less than 75.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table with the specified conditions in the WHERE clause."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3664", "db_id": "baseball_1", "question": "What are the first name and last name of the players who have weight above 220 or height below 75?", "rationale": ["Identify the relevant table: The 'player' table contains the first name, last name, weight, and height of players.", "Determine the conditions: We need to find players with a weight greater than 220 or a height less than 75.", "Construct the SQL query: Use a SELECT statement to retrieve 'name_first' and 'name_last' from the 'player' table where the specified conditions are met."], "gold_sql": "SELECT name_first ,  name_last FROM player WHERE weight  >  220 OR height  <  75", "source_tables": ["player"], "pred_sql": "SELECT name_first, name_last FROM player WHERE weight > 220 OR height < 75;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3665", "db_id": "baseball_1", "question": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the winning scores of the team Boston Red Stockings in the postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Group the results by year to get the count of wins for each year.", "Select the count of wins as max_scores and the year from the grouped results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT count(*) AS max_scores, T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' GROUP BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year\"\n    }\n}\n"}
{"sample_id": "train.3666", "db_id": "baseball_1", "question": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?", "rationale": ["Identify the relevant tables: postseason and team.", "We need to find the maximum scores (wins) for the team Boston Red Stockings when they won in postseason.", "Join the postseason table with the team table on the winning team ID.", "Filter the results to only include rows where the team name is 'Boston Red Stockings'.", "Group the results by year to get the wins for each year.", "Use the MAX function to get the maximum wins from the grouped results."], "gold_sql": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';", "source_tables": ["postseason", "team"], "pred_sql": "SELECT MAX(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner = T2.team_id_br WHERE T2.name = 'Boston Red Stockings' GROUP BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year\"\n    }\n}\n"}
{"sample_id": "train.3672", "db_id": "baseball_1", "question": "For each year, return the year and the number of times the team Boston Red Stockings won in the postseasons.", "rationale": ["Identify the relevant tables: 'postseason' for postseason results and 'team' for team names.", "Join the 'postseason' table with the 'team' table on the winning team ID to get the team names.", "Filter the results to only include wins by the 'Boston Red Stockings'.", "Group the results by year to count the number of wins for each year.", "Select the count of wins and the year from the grouped results."], "gold_sql": "SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' GROUP BY T1.year", "source_tables": ["postseason", "team"], "pred_sql": "SELECT count(*) AS wins, T1.year \nFROM postseason AS T1 \nJOIN team AS T2 ON T1.team_id_winner = T2.team_id_br \nWHERE T2.name = 'Boston Red Stockings' \nGROUP BY T1.year;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year\"\n    }\n}\n"}
{"sample_id": "train.3677", "db_id": "baseball_1", "question": "What is the total salary paid by team Boston Red Stockings in 2010?", "rationale": ["Identify the relevant tables: salary and team.", "We need to sum the salary for players from the Boston Red Stockings in 2010.", "Join the salary table with the team table on team_id to filter by team name.", "Use a WHERE clause to specify the year (2010) and the team name ('Boston Red Stockings').", "Select the sum of salaries as total_salary."], "gold_sql": "SELECT sum(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2010", "source_tables": ["team", "salary"], "pred_sql": "SELECT SUM(salary) AS total_salary \nFROM salary AS T1 \nJOIN team AS T2 ON T1.team_id = T2.team_id \nWHERE T1.year = 2010 AND T2.name = 'Boston Red Stockings';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3681", "db_id": "baseball_1", "question": "List the 3 highest salaries of the players in 2001?", "rationale": ["Identify the relevant table for salary records, which is the 'salary' table.", "Filter the records for the year 2001 using the WHERE clause.", "Order the results by salary in descending order to get the highest salaries.", "Limit the results to the top 3 entries to get the three highest salaries."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3682", "db_id": "baseball_1", "question": "How much salary did the top 3 well-paid players get in 2001?", "rationale": ["Identify the relevant table for salary information, which is the 'salary' table.", "We need to filter the records for the year 2001, so we will use a WHERE clause to specify this year.", "To find the top 3 well-paid players, we will order the results by salary in descending order.", "Finally, we will limit the results to the top 3 entries using LIMIT 3."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2001 ORDER BY salary DESC LIMIT 3;", "source_tables": ["salary"], "pred_sql": "SELECT player_id, salary FROM salary WHERE year = 2001 ORDER BY salary DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3683", "db_id": "baseball_1", "question": "What were all the salary values of players in 2010 and 2001?", "rationale": ["Identify the relevant table for salary records, which is the 'salary' table.", "Determine the years of interest, which are 2010 and 2001.", "Construct a SQL query that selects the salary from the 'salary' table for each of the specified years.", "Use the UNION operator to combine the results from both years into a single result set."], "gold_sql": "SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001", "source_tables": ["salary"], "pred_sql": "SELECT salary FROM salary WHERE year = 2010 UNION SELECT salary FROM salary WHERE year = 2001", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3685", "db_id": "baseball_1", "question": "In which year did the least people enter hall of fame?", "rationale": ["We need to find the year with the least number of players inducted into the Hall of Fame.", "The 'hall_of_fame' table contains the relevant data, specifically the 'yearid' and 'inducted' columns.", "We will count the number of players inducted (where 'inducted' is 'Y') for each year using COUNT(*) and group the results by 'yearid'.", "To find the year with the least inductees, we will order the results in ascending order based on the count and limit the output to 1, which will give us the year with the least inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid, COUNT(*) as num_inducted FROM hall_of_fame WHERE inducted = 'Y' GROUP BY yearid ORDER BY num_inducted ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3686", "db_id": "baseball_1", "question": "Find the year in which the least people enter hall of fame.", "rationale": ["To find the year in which the least number of players entered the Hall of Fame, we need to count the number of players inducted each year.", "We will use the 'hall_of_fame' table, which contains the 'yearid' (year of induction) and 'player_id' (identifier for each player).", "We will group the results by 'yearid' to count how many players were inducted in each year.", "Next, we will order the results by the count of 'player_id' in ascending order to get the year with the least inductees at the top.", "Finally, we will limit the results to 1 to get only the year with the least number of inductees."], "gold_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY count(*) ASC LIMIT 1;", "source_tables": ["hall_of_fame"], "pred_sql": "SELECT yearid FROM hall_of_fame GROUP BY yearid ORDER BY COUNT(player_id) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3689", "db_id": "baseball_1", "question": "How many games were played in park \"Columbia Park\" in 1907?", "rationale": ["Identify the relevant tables: home_game for games played and park for park details.", "We need to filter the home_game table for the year 1907 and the specific park name 'Columbia Park'.", "To do this, we will first find the park_id for 'Columbia Park' from the park table.", "Then, we will sum the games played in that park for the year 1907 using the SUM function on the games column in the home_game table."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(games) FROM home_game WHERE year = '1907' AND park_id = (SELECT park_id FROM park WHERE park_name = 'Columbia Park');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3690", "db_id": "baseball_1", "question": "Count the number of games taken place in park \"Columbia Park\" in 1907.", "rationale": ["Identify the relevant tables: 'home_game' for home games and 'park' for park details.", "We need to count the number of games, so we will use COUNT(*) in the SELECT statement.", "Join the 'home_game' table with the 'park' table on the park_id to filter by park name.", "Add a WHERE clause to filter for the year 1907 and the park name 'Columbia Park'.", "Construct the final SQL query using the identified elements."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT COUNT(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T1.year = '1907' AND T2.park_name = 'Columbia Park';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3691", "db_id": "baseball_1", "question": "How many games were played in city Atlanta in 2000?", "rationale": ["Identify the relevant tables: We need to find the total number of games played in Atlanta in 2000, which involves the 'home_game' table for game data and the 'team' table for city information.", "Join the tables: We will join 'home_game' (T1) with 'team' (T2) on the team_id to access both game and city information.", "Filter by year and city: We will filter the results to only include games from the year 2000 and where the city is Atlanta.", "Calculate the total games: We will use the SUM function to calculate the total number of games played in Atlanta in 2000."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(T1.games) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id WHERE T1.year = 2000 AND T2.city = 'Atlanta';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3692", "db_id": "baseball_1", "question": "Find the number of games taken place in city Atlanta in 2000.", "rationale": ["Identify the relevant tables: home_game for games played and park for city information.", "Join the home_game table with the park table on the park_id to access city information.", "Filter the results for the year 2000 and the city of Atlanta.", "Use SUM to count the total number of games played in Atlanta in 2000."], "gold_sql": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';", "source_tables": ["park", "home_game"], "pred_sql": "SELECT SUM(T1.games) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id = T2.park_id WHERE T1.year = 2000 AND T2.city = 'Atlanta';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3693", "db_id": "baseball_1", "question": "What is the total home game attendance of team Boston Red Stockings from 2000 to 2010?", "rationale": ["Identify the relevant table for home game attendance, which is the 'home_game' table.", "To find the total attendance for the Boston Red Stockings, we need to filter the records in the 'home_game' table by the team ID associated with that name.", "The team ID can be found by querying the 'team' table where the name is 'Boston Red Stockings'.", "We also need to restrict the years to between 2000 and 2010, which can be done using a WHERE clause with a BETWEEN condition.", "Finally, we will use the SUM function to calculate the total attendance for the specified team and years."], "gold_sql": "SELECT sum(T1.attendance) FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year BETWEEN 2000 AND 2010;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT SUM(attendance) AS total_attendance \nFROM home_game \nWHERE team_id = (SELECT team_id FROM team WHERE name = 'Boston Red Stockings') \nAND year BETWEEN 2000 AND 2010;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of postseason wins for a specific team across different years. The placeholder in the WHERE clause represents the name of the team for which the postseason wins are being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.year FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.year\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3698", "db_id": "baseball_1", "question": "What are the first name and last name of the players who were paid salary by team Washington Nationals in both 2005 and 2007?", "rationale": ["Identify the relevant tables: We need to retrieve player names based on salary records, so we will use the 'salary' and 'player' tables, along with the 'team' table to filter by team name.", "Use JOINs to connect the tables: We will join the 'salary' table with the 'player' table on 'player_id' and with the 'team' table on 'team_id'.", "Filter by year and team name: We will filter the results for the years 2005 and 2007 specifically for the 'Washington Nationals'.", "Use INTERSECT to find common players: Since we want players who were paid in both years, we will use the INTERSECT operator to find players that appear in both queries for 2005 and 2007."], "gold_sql": "SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2005 AND T3.name = 'Washington Nationals' INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "source_tables": ["team", "player", "salary"], "pred_sql": "SELECT T2.name_first, T2.name_last \nFROM salary AS T1 \nJOIN player AS T2 ON T1.player_id = T2.player_id \nJOIN team AS T3 ON T3.team_id_br = T1.team_id \nWHERE T1.year = 2005 AND T3.name = 'Washington Nationals' \nINTERSECT \nSELECT T2.name_first, T2.name_last \nFROM salary AS T1 \nJOIN player AS T2 ON T1.player_id = T2.player_id \nJOIN team AS T3 ON T3.team_id_br = T1.team_id \nWHERE T1.year = 2007 AND T3.name = 'Washington Nationals'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the first and last names of players who were associated with a specific team during a particular year, based on their salary records. The placeholders in the query represent the year and the team's name, allowing users to specify the desired year and team for their query.\",\n        \"virtual_table\": \"SELECT T2.name_first ,  T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.name_first , T2.name_last FROM salary AS T1 JOIN player AS T2 ON T1.player_id = T2.player_id JOIN team AS T3 ON T3.team_id_br = T1.team_id WHERE T1.year = [PLACEHOLDER-TYPE:NUMBER] AND T3.name = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of players who received awards in two specific years. The placeholders in the WHERE clause represent the years for which the awards were given.\",\n        \"virtual_table\": \"SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.name_first , T1.name_last FROM player AS T1 JOIN player_award AS T2 WHERE T2.year  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the salary records for players in two specific years from the 'salary' table. The placeholders in the WHERE clause represent the years for which the salary data is being queried.\",\n        \"virtual_table\": \"SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT salary FROM salary WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3702", "db_id": "baseball_1", "question": "Find the team that attended the least number of home games in 1980.", "rationale": ["Identify the relevant tables: 'home_game' for home games and 'team' for team details.", "Join the 'home_game' table with the 'team' table on 'team_id' to get team information for the year 1980.", "Filter the results to only include records from the year 1980.", "Group the results by 'team_id' to aggregate the number of home games played by each team.", "Order the results by the total number of home games in ascending order to find the team with the least number of home games.", "Limit the results to 1 to get only the team with the least number of home games."], "gold_sql": "SELECT T2.name FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id_br WHERE T1.year = 1980 ORDER BY T1.attendance ASC LIMIT 1;", "source_tables": ["team", "home_game"], "pred_sql": "SELECT T2.team_id FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id WHERE T1.year = 1980 GROUP BY T1.team_id ORDER BY SUM(T1.games) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding identifiers from the postseason table for a specific year. The results are grouped by the winning team identifier and ordered by the count of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of the winning teams and their corresponding team IDs from the postseason table for a specific year. The results are grouped by the winning team ID and ordered by the number of wins in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T2.name ,  T1.team_id_winner FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id_winner ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3709", "db_id": "baseball_1", "question": "Which park had most attendances in 2008?", "rationale": ["Identify the relevant tables: 'home_game' for attendance data and 'team' for team information.", "We need to find the park with the most attendance in 2008, so we filter the 'home_game' table for the year 2008.", "Join the 'home_game' table with the 'team' table to get team details associated with each home game.", "Group the results by team ID to aggregate attendance data for each team.", "Order the results by average attendance in descending order to find the team with the highest attendance.", "Limit the results to 1 to get only the top team."], "gold_sql": "SELECT T2.park_name FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 2008 ORDER BY T1.attendance DESC LIMIT 1;", "source_tables": ["park", "home_game"], "pred_sql": "SELECT T2.team_id, T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id = T2.team_id WHERE T1.year = 2008 GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the team IDs and their ranks for teams that hosted home games in a specific year. The results are grouped by team ID and ordered by the average attendance of the home games in descending order, with a limit on the number of results returned. The placeholders represent the year of the home games and the maximum number of teams to display.\",\n        \"virtual_table\": \"SELECT T2.team_id ,  T2.rank FROM home_game AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id WHERE T1.year  =  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.team_id ORDER BY avg(T1.attendance) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.3857", "db_id": "insurance_policies", "question": "Find the settlement amount of the claim with the largest claim amount. Show both the settlement amount and claim amount.", "rationale": ["Identify the relevant tables: Claims and Settlements are needed to get the claim and settlement amounts.", "We need to find the claim with the largest claim amount, so we will use a subquery to get the maximum Amount_Claimed from the Claims table.", "Join the Claims table with the Settlements table on Claim_ID to access both the claim amount and the settlement amount.", "Select the Amount_Settled from Settlements and Amount_Claimed from Claims where the Amount_Claimed matches the maximum amount found in the subquery."], "gold_sql": "SELECT Amount_Settled ,  Amount_Claimed FROM Claims ORDER BY Amount_Claimed DESC LIMIT 1", "source_tables": ["claims"], "pred_sql": "SELECT S.Amount_Settled, C.Amount_Claimed\nFROM Claims C\nJOIN Settlements S ON C.Claim_ID = S.Claim_ID\nWHERE C.Amount_Claimed = (SELECT MAX(Amount_Claimed) FROM Claims);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n        \"virtual_table\": \"SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3862", "db_id": "insurance_policies", "question": "Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find settlements where the claimed amount is no more than the average claimed amount across all claims.", "Join the Claims table with the Settlements table on Claim_ID to access both claims and their corresponding settlements.", "Use a subquery to calculate the average claimed amount from the Claims table.", "Filter the results to include only those settlements where the Amount_Claimed is less than or equal to the average amount calculated."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT C.Date_Claim_Made FROM Claims C JOIN Settlements S ON C.Claim_ID = S.Claim_ID WHERE S.Amount_Claimed <= (SELECT avg(Amount_Claimed) FROM Claims)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n        \"virtual_table\": \"SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3863", "db_id": "insurance_policies", "question": "Return the claim start date for the claims whose claimed amount is no more than the average", "rationale": ["Identify the relevant table: The 'Claims' table contains the information about claims, including the claimed amounts and the dates when claims were made.", "Determine the condition: We need to find claims where the claimed amount is no more than the average claimed amount across all claims.", "Calculate the average claimed amount: This can be done using a subquery that selects the average of 'Amount_Claimed' from the 'Claims' table.", "Construct the SQL query: We will select 'Date_Claim_Made' from the 'Claims' table where 'Amount_Claimed' is less than or equal to the average amount calculated in the subquery."], "gold_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )", "source_tables": ["claims"], "pred_sql": "SELECT Date_Claim_Made FROM Claims WHERE Amount_Claimed <= (SELECT avg(Amount_Claimed) FROM Claims)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n        \"virtual_table\": \"SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3868", "db_id": "insurance_policies", "question": "How many settlements were made on the claim with the most recent claim settlement date? List the number and the claim id.", "rationale": ["Identify the most recent claim settlement date by using a subquery to find the maximum 'Date_Claim_Settled' from the 'Claims' table.", "Join the 'Claims' table with the 'Settlements' table on 'Claim_ID' to link claims with their settlements.", "Filter the results to only include claims that have the most recent settlement date using a WHERE clause.", "Count the number of settlements associated with that claim using COUNT(S.Settlement_ID).", "Group the results by 'Claim_ID' to get the count of settlements for each claim."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT COUNT(S.Settlement_ID) AS Number_of_Settlements, C.Claim_ID \nFROM Claims AS C \nJOIN Settlements AS S ON C.Claim_ID = S.Claim_ID \nWHERE C.Date_Claim_Settled = (SELECT MAX(Date_Claim_Settled) FROM Claims) \nGROUP BY C.Claim_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n        \"virtual_table\": \"SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )\"\n    }\n}\n"}
{"sample_id": "train.3869", "db_id": "insurance_policies", "question": "Find the claim id and the number of settlements made for the claim with the most recent settlement date.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to find the claim ID and the number of settlements for the claim with the most recent settlement date.", "Join the Claims table with the Settlements table on Claim_ID to link claims with their settlements.", "Use a subquery to find the maximum settlement date from the Settlements table.", "Group the results by Claim_ID to count the number of settlements for each claim.", "Select the Claim_ID and the count of settlements as Number_of_Settlements."], "gold_sql": "SELECT count(*) ,  T1.claim_id FROM Claims AS T1 JOIN Settlements AS T2 ON T1.claim_id  =  T2.claim_id GROUP BY T1.claim_id ORDER BY T1.Date_Claim_Settled DESC LIMIT 1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT T1.Claim_ID, COUNT(T2.Settlement_ID) AS Number_of_Settlements \nFROM Claims AS T1 \nJOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID \nWHERE T2.Date_Claim_Settled = (SELECT MAX(Date_Claim_Settled) FROM Settlements) \nGROUP BY T1.Claim_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n        \"virtual_table\": \"SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )\"\n    }\n}\n"}
{"sample_id": "train.3878", "db_id": "insurance_policies", "question": "What is the most popular payment method?", "rationale": ["Identify the relevant table: The Payments table contains information about payment transactions, including the payment method.", "Determine the required information: We need to find the most popular payment method, which implies counting the occurrences of each payment method.", "Use the COUNT function: To find out how many times each payment method was used, we will use the COUNT function on the Payment_Method_Code column.", "Group the results: We will group the results by Payment_Method_Code to aggregate the counts for each method.", "Order the results: To find the most popular method, we will order the results in descending order based on the count of payments.", "Limit the results: Since we only want the most popular payment method, we will limit the results to 1."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Payment_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Payment_Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3879", "db_id": "insurance_policies", "question": "Which payment method is used the most often?", "rationale": ["Identify the relevant table: The question is about payment methods, so we will focus on the Payments table.", "Determine the required information: We need to find out which payment method is used the most often, which implies counting the occurrences of each payment method.", "Use the COUNT function: We will count the number of times each Payment_Method_Code appears in the Payments table.", "Group the results: To get the count for each payment method, we will use GROUP BY on Payment_Method_Code.", "Order the results: To find the most frequently used payment method, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most used payment method, we will limit the results to 1."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Method_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Method_Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3880", "db_id": "insurance_policies", "question": "With which kind of payment method were the least number of payments processed?", "rationale": ["The question asks for the payment method with the least number of payments processed.", "To find this, we need to count the number of payments for each payment method.", "We will use the COUNT() function to count the number of payments grouped by 'Payment_Method_Code'.", "Next, we will order the results in ascending order based on the count of payments to get the least processed payment method at the top.", "Finally, we will limit the results to 1 to get only the payment method with the least number of payments."], "gold_sql": "SELECT Payment_Method_Code FROM Payments GROUP BY Payment_Method_Code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["payments"], "pred_sql": "SELECT Payment_Method_Code, COUNT(*) AS Payment_Count\nFROM Payments\nGROUP BY Payment_Method_Code\nORDER BY Payment_Count ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3886", "db_id": "insurance_policies", "question": "Which kind of policy type was chosen by the most customers?", "rationale": ["Identify the relevant table: The question pertains to the types of policies chosen by customers, so we will focus on the 'Customer_Policies' table.", "Count distinct customers: We need to count how many distinct customers chose each policy type. This requires using the COUNT function with DISTINCT on 'Customer_ID'.", "Group by policy type: To get the count of customers for each policy type, we will group the results by 'Policy_Type_Code'.", "Order by customer count: To find out which policy type was chosen by the most customers, we will order the results in descending order based on the count of customers.", "Limit the results: Since we only want the policy type chosen by the most customers, we will limit the results to 1."], "gold_sql": "SELECT Policy_Type_Code FROM Customer_Policies GROUP BY Policy_Type_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customer_policies"], "pred_sql": "SELECT Policy_Type_Code, COUNT(DISTINCT Customer_ID) AS Customer_Count\nFROM Customer_Policies\nGROUP BY Policy_Type_Code\nORDER BY Customer_Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3893", "db_id": "insurance_policies", "question": "Which customers do not have any policies? Find the details of these customers.", "rationale": ["Identify the Customers table as the primary source of customer information.", "To find customers without policies, we need to check which Customer_IDs are present in the Customer_Policies table.", "Use a subquery to select all Customer_IDs from the Customer_Policies table.", "Use the NOT IN clause to filter out those Customer_IDs from the Customers table, thus identifying customers without any policies."], "gold_sql": "SELECT customer_details FROM Customers EXCEPT SELECT T1.customer_details FROM Customers AS T1 JOIN Customer_Policies AS T2 ON T1.customer_id  =  T2.customer_id", "source_tables": ["customer_policies", "customers"], "pred_sql": "SELECT * FROM Customers WHERE Customer_ID NOT IN (SELECT Customer_ID FROM Customer_Policies);", "hint": "\n"}
{"sample_id": "train.3895", "db_id": "insurance_policies", "question": "Which claims had exactly one settlement? For each, tell me the the date the claim was made, the date it was settled and the amount settled.", "rationale": ["Identify the relevant tables: Claims and Settlements.", "We need to join these two tables on the Claim_ID to get the necessary information about claims and their settlements.", "We want to group the results by Claim_ID to count the number of settlements associated with each claim.", "Using the HAVING clause, we filter the groups to include only those claims that have exactly one settlement (COUNT(T2.Settlement_ID) = 1).", "Select the required fields: Claim_ID, Date_Claim_Made, Date_Claim_Settled from Claims and Amount_Settled from Settlements."], "gold_sql": "SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  1", "source_tables": ["claims", "settlements"], "pred_sql": "SELECT T1.Claim_ID, T1.Date_Claim_Made, T1.Date_Claim_Settled, T2.Amount_Settled \nFROM Claims AS T1 \nJOIN Settlements AS T2 ON T1.Claim_ID = T2.Claim_ID \nGROUP BY T1.Claim_ID \nHAVING COUNT(T2.Settlement_ID) = 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of claims and their settlement dates from the 'Claims' table, specifically focusing on claims that have a certain number of associated settlements. The placeholders in the HAVING clause represent the count of settlements that must match for the claims to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.claim_id ,  T1.date_claim_made ,  T1.Date_Claim_Settled FROM Claims AS T1 JOIN Settlements AS T2 ON T1.Claim_id  =  T2.Claim_id GROUP BY T1.claim_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the dates when claims were made and settled from the 'Claims' table for those claims where the amount claimed exceeds the average amount claimed across all claims. The placeholder in the WHERE clause represents a condition based on the average amount claimed.\",\n        \"virtual_table\": \"SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Claims WHERE Amount_Claimed  >  ( SELECT avg(Amount_Claimed) FROM Claims )\"\n    }\n}\n"}
{"sample_id": "train.3898", "db_id": "hospital_1", "question": "Which department has the largest number of employees?", "rationale": ["Identify the relevant tables: Department and Physician.", "We need to count the number of employees in each department, which requires joining the Department table with the Physician table.", "Use a LEFT JOIN to include all departments even if they have no physicians.", "Group the results by department name to count the number of employees in each department.", "Order the results by the count of employees in descending order to find the department with the largest number of employees.", "Limit the results to 1 to get only the department with the largest number of employees."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT d.Name, COUNT(p.EmployeeID) AS EmployeeCount\nFROM Department d\nLEFT JOIN Physician p ON d.Head = p.EmployeeID\nGROUP BY d.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3899", "db_id": "hospital_1", "question": "Find the department with the most employees.", "rationale": ["To find the department with the most employees, we need to count the number of physicians affiliated with each department.", "We will join the 'Department' table with the 'Affiliated_With' table on the department ID.", "We will group the results by department name to count the number of physicians in each department.", "We will use the COUNT function to count the number of physicians for each department.", "To get the department with the most employees, we will order the results by the count of employees in descending order.", "Finally, we will limit the results to 1 to get only the department with the highest count."], "gold_sql": "SELECT name FROM department GROUP BY departmentID ORDER BY count(departmentID) DESC LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Name, COUNT(Affiliated_With.Physician) AS EmployeeCount\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.Name\nORDER BY EmployeeCount DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3901", "db_id": "hospital_1", "question": "Tell me the employee id of the head of the department with the least employees.", "rationale": ["We need to find the head of the department with the least employees.", "To do this, we will join the Department table with the Affiliated_With table to count the number of physicians in each department.", "We will group the results by DepartmentID to get the count of physicians per department.", "Next, we will order the results by the count of physicians in ascending order to find the department with the least employees.", "Finally, we will limit the results to 1 to get only the head of that department."], "gold_sql": "SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["department"], "pred_sql": "SELECT Department.Head\nFROM Department\nJOIN Affiliated_With ON Department.DepartmentID = Affiliated_With.Department\nGROUP BY Department.DepartmentID\nORDER BY COUNT(Affiliated_With.Physician) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.3902", "db_id": "hospital_1", "question": "what is the name and position of the head whose department has least number of employees?", "rationale": ["Identify the head of the department by joining the Physician and Department tables on the condition that the Physician's EmployeeID matches the Department's Head.", "To find the department with the least number of employees, we need to count the number of physicians affiliated with each department. This can be done using a subquery that groups by the department and counts the number of physicians.", "The subquery will order the departments by the count of affiliated physicians in ascending order and limit the result to 1, which gives us the department with the least number of employees.", "Finally, we use this result in the main query to filter for the head of that specific department, retrieving their name and position."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Physician \nJOIN Department ON Physician.EmployeeID = Department.Head \nWHERE Department.DepartmentID = \n    (SELECT Affiliated_With.Department \n     FROM Affiliated_With \n     GROUP BY Affiliated_With.Department \n     ORDER BY COUNT(Affiliated_With.Physician) ASC \n     LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3903", "db_id": "hospital_1", "question": "Find the name and position of the head of the department with the least employees.", "rationale": ["Identify the head of the department with the least employees.", "To find the department with the least employees, we need to count the number of physicians affiliated with each department.", "We can use a subquery to group by DepartmentID in the Affiliated_With table and count the number of physicians in each department.", "Order the results of this subquery by the count of physicians in ascending order and limit the result to 1 to get the department with the least employees.", "Join the Department table with the Physician table on the Head column to get the name and position of the head of that department."], "gold_sql": "SELECT T2.name ,  T2.position FROM department AS T1 JOIN physician AS T2 ON T1.head  =  T2.EmployeeID GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;", "source_tables": ["physician", "department"], "pred_sql": "SELECT Physician.Name, Physician.Position \nFROM Department \nJOIN Physician ON Department.Head = Physician.EmployeeID \nWHERE Department.DepartmentID = \n    (SELECT DepartmentID \n     FROM Affiliated_With \n     GROUP BY DepartmentID \n     ORDER BY COUNT(Physician) ASC \n     LIMIT 1);", "hint": "\n"}
{"sample_id": "train.3904", "db_id": "hospital_1", "question": "What are names of patients who made an appointment?", "rationale": ["We need to find the names of patients who made an appointment.", "The relevant tables are 'Appointment' and 'Patient'.", "We will join these two tables on the condition that the Patient's SSN in the 'Patient' table matches the Patient identifier in the 'Appointment' table.", "To get unique patient names, we will use DISTINCT to avoid duplicates in case a patient has multiple appointments."], "gold_sql": "SELECT name FROM appointment AS T1 JOIN patient AS T2 ON T1.patient  =  T2.ssn", "source_tables": ["patient", "appointment"], "pred_sql": "SELECT DISTINCT T2.Name FROM Appointment AS T1 JOIN Patient AS T2 ON T1.Patient = T2.SSN;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3914", "db_id": "hospital_1", "question": "Find the names of all physicians and their primary affiliated departments' names.", "rationale": ["Identify the tables involved: Physician, Department, and Affiliated_With.", "We need to join the Physician table with the Affiliated_With table to link physicians to their departments.", "Next, we join the result with the Department table to get the names of the departments.", "We need to filter the results to only include primary affiliations, which is indicated in the Affiliated_With table.", "The final query selects the names of physicians and their affiliated department names."], "gold_sql": "SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  1", "source_tables": ["physician", "department", "affiliated_with"], "pred_sql": "SELECT T1.Name, T3.Name \nFROM Physician AS T1 \nJOIN Affiliated_With AS T2 ON T1.EmployeeID = T2.Physician \nJOIN Department AS T3 ON T2.Department = T3.DepartmentID \nWHERE T2.PrimaryAffiliation = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\",\n        \"virtual_table\": \"SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of physicians along with their associated departments from the 'Affiliated_With' table, filtered by whether the affiliation is marked as primary. The placeholder in the WHERE clause represents the primary affiliation status.\",\n        \"virtual_table\": \"SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    }\n}\n"}
{"sample_id": "train.3928", "db_id": "hospital_1", "question": "How many patients do each physician take care of? List their names and number of patients they take care of.", "rationale": ["Identify the tables involved: Physician and Patient.", "Determine the relationship: A physician can be a primary care physician (PCP) for multiple patients.", "Join the Physician table with the Patient table on the condition that the EmployeeID of the Physician matches the PCP of the Patient.", "Count the number of patients for each physician using COUNT(*) and group the results by the physician's EmployeeID to aggregate patient counts.", "Select the physician's name and the count of patients they take care of."], "gold_sql": "SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid", "source_tables": ["physician", "patient"], "pred_sql": "SELECT T1.Name, COUNT(*) AS NumberOfPatients \nFROM Physician AS T1 \nJOIN Patient AS T2 ON T1.EmployeeID = T2.PCP \nGROUP BY T1.EmployeeID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\",\n        \"virtual_table\": \"SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3930", "db_id": "hospital_1", "question": "Find the name of physicians who are in charge of more than one patient.", "rationale": ["Identify the relevant tables: Physician and Patient.", "Determine the relationship: A physician can be a primary care physician (PCP) for multiple patients.", "Join the Physician table with the Patient table on the condition that the EmployeeID of the Physician matches the PCP of the Patient.", "Group the results by the EmployeeID of the Physician to count how many patients each physician is responsible for.", "Use the HAVING clause to filter out physicians who are in charge of more than one patient."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  1", "source_tables": ["physician", "patient"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Patient AS T2 ON T1.EmployeeID = T2.PCP GROUP BY T1.EmployeeID HAVING COUNT(*) > 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\",\n        \"virtual_table\": \"SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3940", "db_id": "hospital_1", "question": "What is the names of the physicians who prescribe medication Thesisin?", "rationale": ["Identify the relevant tables: Physician, Prescribes, and Medication.", "We need to find the names of physicians who have prescribed a specific medication, which is 'Thesisin'.", "Join the Physician table with the Prescribes table on the EmployeeID and Physician columns respectively.", "Then, join the resulting table with the Medication table on the Medication code.", "Filter the results where the medication name is 'Thesisin'.", "Select the Name of the physicians from the final result."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT T1.Name \nFROM Physician AS T1 \nJOIN Prescribes AS T2 ON T1.EmployeeID = T2.Physician \nJOIN Medication AS T3 ON T2.Medication = T3.Code \nWHERE T3.Name = 'Thesisin';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\",\n        \"virtual_table\": \"SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3941", "db_id": "hospital_1", "question": "List the names of all the physicians who prescribe Thesisin as medication.", "rationale": ["Identify the tables involved: Physician, Prescribes, and Medication.", "We need to find the names of physicians who prescribe a specific medication, which is 'Thesisin'.", "Join the Physician table with the Prescribes table on the EmployeeID and Physician columns respectively.", "Then, join the resulting table with the Medication table on the Medication code.", "Filter the results where the medication name is 'Thesisin'.", "Select the Name of the physicians from the final result."], "gold_sql": "SELECT DISTINCT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician JOIN medication AS T3 ON T3.code = T2.medication WHERE T3.name  =  'Thesisin'", "source_tables": ["physician", "prescribes", "medication"], "pred_sql": "SELECT T1.Name \nFROM Physician AS T1 \nJOIN Prescribes AS T2 ON T1.EmployeeID = T2.Physician \nJOIN Medication AS T3 ON T2.Medication = T3.Code \nWHERE T3.Name = 'Thesisin';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\",\n        \"virtual_table\": \"SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3944", "db_id": "hospital_1", "question": "Find the number of medications prescribed for each brand.", "rationale": ["The task is to find the number of medications prescribed for each brand.", "We need to count the number of prescriptions for each brand of medication.", "To do this, we will join the 'Medication' table with the 'Prescribes' table on the medication code.", "We will select the count of prescriptions and the brand name from the 'Medication' table.", "Finally, we will group the results by the brand name to get the count for each brand."], "gold_sql": "SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand", "source_tables": ["prescribes", "medication"], "pred_sql": "SELECT count(*), T1.Brand FROM Medication AS T1 JOIN Prescribes AS T2 ON T1.Code = T2.Medication GROUP BY T1.Brand", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    }\n}\n"}
{"sample_id": "train.3948", "db_id": "hospital_1", "question": "Find the patient who has the most recent undergoing treatment?", "rationale": ["To find the patient who has the most recent undergoing treatment, we need to look at the 'Undergoes' table, which contains information about patients undergoing procedures.", "The 'Undergoes' table includes the 'Patient' identifier and the 'DateUndergoes' which indicates when the treatment was performed.", "We will sort the results by 'DateUndergoes' in descending order to get the most recent date at the top.", "Finally, we will limit the results to just one entry to get the patient with the most recent treatment."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT U.Patient, U.DateUndergoes FROM Undergoes AS U ORDER BY U.DateUndergoes DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.3949", "db_id": "hospital_1", "question": "Which patient is undergoing the most recent treatment?", "rationale": ["Identify the relevant tables: Patient and Undergoes are needed to find patients undergoing treatments.", "Join the Patient table with the Undergoes table on the patient identifier (SSN).", "Order the results by the date of the procedures in descending order to get the most recent treatment.", "Limit the results to 1 to get only the most recent patient undergoing treatment."], "gold_sql": "SELECT patient FROM undergoes ORDER BY dateundergoes LIMIT 1", "source_tables": ["undergoes"], "pred_sql": "SELECT P.Name\nFROM Patient AS P\nJOIN Undergoes AS U ON P.SSN = U.Patient\nORDER BY U.DateUndergoes DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3959", "db_id": "hospital_1", "question": "Find the physician who prescribed the highest dose. What is his or her name?", "rationale": ["Identify the relevant tables: Physician and Prescribes.", "We need to find the physician who prescribed the highest dose, so we will join the Physician table with the Prescribes table on the physician's identifier.", "We will select the physician's name from the Physician table.", "To find the highest dose prescribed, we will order the results by the Dose column in descending order.", "Finally, we will limit the results to 1 to get only the physician with the highest dose."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN prescribes AS T2 ON T1.employeeid = T2.physician ORDER BY T2.dose DESC LIMIT 1", "source_tables": ["physician", "prescribes"], "pred_sql": "SELECT P.Name \nFROM Physician P \nJOIN Prescribes R ON P.EmployeeID = R.Physician \nORDER BY R.Dose DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3960", "db_id": "hospital_1", "question": "List the physicians' employee ids together with their primary affiliation departments' ids.", "rationale": ["Identify the relevant tables: Physician and Affiliated_With.", "Determine the columns needed: EmployeeID from Physician and Department from Affiliated_With.", "Establish the relationship between the tables: Join Physician and Affiliated_With on EmployeeID and Physician respectively.", "Filter the results to include only primary affiliations by adding a WHERE clause for PrimaryAffiliation.", "Construct the SQL query using the SELECT statement to retrieve the desired columns."], "gold_sql": "SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  1", "source_tables": ["affiliated_with"], "pred_sql": "SELECT T1.EmployeeID, T2.Department FROM Physician AS T1 JOIN Affiliated_With AS T2 ON T1.EmployeeID = T2.Physician WHERE T2.PrimaryAffiliation = 'yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of physicians along with their associated departments from the 'Affiliated_With' table, filtered by whether the affiliation is marked as primary. The placeholder in the WHERE clause represents the primary affiliation status.\",\n        \"virtual_table\": \"SELECT physician ,  department FROM affiliated_with WHERE primaryaffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of physicians along with the names of their affiliated departments from the 'Physician' and 'Department' tables. The join condition links physicians to their departments through the 'Affiliated_With' table, and the placeholder in the WHERE clause indicates whether the affiliation is primary.\",\n        \"virtual_table\": \"SELECT T1.name ,  T3.name FROM physician AS T1 JOIN affiliated_with AS T2 ON T1.EmployeeID  =  T2.physician JOIN department AS T3 ON T2.department  =  T3.DepartmentID WHERE T2.PrimaryAffiliation  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    }\n}\n"}
{"sample_id": "train.3971", "db_id": "hospital_1", "question": "What are the three most costly procedures?", "rationale": ["The task is to find the three most costly procedures.", "To achieve this, we need to select the 'Name' from the 'Procedures' table.", "We will order the results by the 'Cost' column in descending order to get the most expensive procedures first.", "Finally, we will limit the results to 3 to get only the top three costly procedures."], "gold_sql": "SELECT name FROM procedures ORDER BY cost LIMIT 3", "source_tables": ["procedures"], "pred_sql": "SELECT Name FROM Procedures ORDER BY Cost DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3972", "db_id": "hospital_1", "question": "Find the physicians who are trained in a procedure that costs more than 5000.", "rationale": ["Identify the relevant tables: Physician, Trained_In, and Procedures.", "Join the Physician table with the Trained_In table on the EmployeeID and Physician columns respectively to get the physicians and their trained procedures.", "Join the resulting table with the Procedures table on the Treatment and Code columns to access the cost of each procedure.", "Filter the results to include only those procedures where the cost is greater than 5000."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T3.cost  >  5000", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT T1.Name FROM Physician AS T1 JOIN Trained_In AS T2 ON T1.EmployeeID = T2.Physician JOIN Procedures AS T3 ON T3.Code = T2.Treatment WHERE T3.Cost > 5000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3974", "db_id": "hospital_1", "question": "Find the physician who was trained in the most expensive procedure?", "rationale": ["Identify the tables involved: Physician, Trained_In, and Procedures.", "We need to find the physician who is trained in the most expensive procedure.", "To do this, we will join the Physician table with the Trained_In table on the physician's identifier, and then join with the Procedures table on the treatment code.", "We will filter the results to only include those procedures that have the maximum cost.", "The subquery (SELECT MAX(cost) FROM procedures) will give us the highest cost of any procedure.", "Finally, we select the name of the physician who is trained in that most expensive procedure."], "gold_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment ORDER BY T3.cost DESC LIMIT 1", "source_tables": ["physician", "procedures", "trained_in"], "pred_sql": "SELECT T1.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid = T2.physician JOIN procedures AS T3 ON T3.code = T2.treatment WHERE T3.cost = (SELECT MAX(cost) FROM procedures)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3980", "db_id": "hospital_1", "question": "Find all procedures which cost more than 1000 or which physician John Wen was trained in.", "rationale": ["Identify the requirement to find procedures with a cost greater than 1000 or those that a specific physician (John Wen) is trained in.", "Use the first virtual table provided in the hint, which allows for selecting procedure names based on cost and physician training.", "The first part of the query selects procedure names from the 'Procedures' table where the cost is greater than 1000.", "The second part of the query uses a UNION to combine results from a join between the 'Physician', 'Trained_In', and 'Procedures' tables to find procedures that John Wen is trained in.", "Replace the placeholders in the virtual table with the actual values: cost threshold of 1000 and physician name 'John Wen'."], "gold_sql": "SELECT name FROM procedures WHERE cost  >  1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  'John Wen'", "source_tables": ["procedures", "physician", "trained_in"], "pred_sql": "SELECT name FROM procedures WHERE cost > 1000 UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid = T2.physician JOIN procedures AS T3 ON T3.code = T2.treatment WHERE T1.name = 'John Wen'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of procedure names from the 'Procedures' table that have a cost greater than a specified amount. Additionally, it includes names of procedures that a specific physician is trained in, by joining the 'Physician', 'Trained_In', and 'Procedures' tables. The placeholders represent the cost threshold and the physician's name respectively.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of medical procedures that are less expensive than a specified cost and are also treatments that a specific physician is certified to perform. The placeholders in the query represent the cost limit and the physician's name.\",\n        \"virtual_table\": \"SELECT name FROM procedures WHERE cost  <  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T3.name FROM physician AS T1 JOIN trained_in AS T2 ON T1.employeeid  =  T2.physician JOIN procedures AS T3 ON T3.code  =  T2.treatment WHERE T1.name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.3993", "db_id": "hospital_1", "question": "How many patients are not using Procrastin-X as medication?", "rationale": ["Identify the patients who have been prescribed medications by checking the 'Prescribes' table.", "Filter out the patients who have been prescribed 'Procrastin-X' by using a subquery to find the medication code for 'Procrastin-X' in the 'Medication' table.", "Count the total number of patients in the 'Patient' table whose SSN is not in the list of patients who have been prescribed 'Procrastin-X'."], "gold_sql": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )", "source_tables": ["patient", "prescribes", "medication"], "pred_sql": "SELECT COUNT(*) FROM Patient WHERE SSN NOT IN (SELECT Patient FROM Prescribes WHERE Medication = (SELECT Code FROM Medication WHERE Name = 'Procrastin-X'));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of prescribed medications grouped by their brand names. It combines data from the 'medication' table and the 'prescribes' table, allowing users to see how many times each brand of medication has been prescribed.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.name FROM medication AS T1 JOIN prescribes AS T2 ON T1.code = T2.medication GROUP BY T1.brand\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of physicians who are primary care physicians (PCP) for a number of patients exceeding a specified threshold. The placeholder in the HAVING clause represents the minimum number of patients a physician must have to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.name FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of physicians along with the count of patients for whom they are the primary care physician (PCP). The data is retrieved by joining the 'Physician' table with the 'Patient' table based on the physician's employee ID and the patient's PCP identifier. The results are grouped by the physician's employee ID to aggregate the patient counts.\",\n        \"virtual_table\": \"SELECT T1.name ,  count(*) FROM physician AS T1 JOIN patient AS T2 ON T1.employeeid  =  T2.PCP GROUP BY T1.employeeid\"\n    }\n}\n"}
{"sample_id": "train.4256", "db_id": "club_1", "question": "What are the first names of all the students?", "rationale": ["Identify the table that contains the first names of students, which is the 'Student' table.", "Determine the specific column needed, which is 'Fname' for first names.", "Construct the SQL query to select the 'Fname' column from the 'Student' table."], "gold_sql": "SELECT DISTINCT fname FROM student", "source_tables": ["student"], "pred_sql": "SELECT Fname FROM Student;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n        \"virtual_table\": \"SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  [PLACEHOLDER-TYPE:STRING] AND t3.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4271", "db_id": "club_1", "question": "Give me the first name and last name for all the female members of the club \"Bootup Baltimore\".", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "Determine the columns needed: first name (Fname) and last name (LName) of female students.", "Use JOINs to connect the tables based on their relationships: Club to Member_of_club on ClubID, and Member_of_club to Student on StuID.", "Filter the results to include only those members of the club 'Bootup Baltimore' and only female students by using a WHERE clause."], "gold_sql": "SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  'Bootup Baltimore' AND t3.sex  =  'F'", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT t3.Fname, t3.LName FROM Club AS t1 JOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID JOIN Student AS t3 ON t2.StuID = t3.StuID WHERE t1.ClubName = 'Bootup Baltimore' AND t3.Sex = 'Female'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n        \"virtual_table\": \"SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  [PLACEHOLDER-TYPE:STRING] AND t3.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4277", "db_id": "club_1", "question": "Find the club which has the largest number of members majoring in \"600\".", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "We need to find clubs with members majoring in '600'.", "Join the Club table with Member_of_club and Student tables using their respective IDs.", "Filter the results where the Major of the student is '600'.", "Group the results by ClubName to count the number of members in each club.", "Order the results by the count of members in descending order to find the club with the most members.", "Limit the results to 1 to get only the club with the largest number of members."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  '600' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT t1.ClubName FROM Club AS t1 JOIN Member_of_club AS t2 ON t1.ClubID = t2.ClubID JOIN Student AS t3 ON t2.StuID = t3.StuID WHERE t3.Major = '600' GROUP BY t1.ClubName ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of clubs that students with a specific major are members of. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of clubs returned. The placeholders in the WHERE clause and LIMIT clause represent the major of the students and the maximum number of clubs to display, respectively.\",\n        \"virtual_table\": \"SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n        \"virtual_table\": \"SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  [PLACEHOLDER-TYPE:STRING] AND t3.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4278", "db_id": "club_1", "question": "Find the name of the club that has the most female students.", "rationale": ["Identify the tables involved: Club, Member_of_club, and Student.", "We need to find clubs with female students, so we will filter by the 'Sex' column in the Student table.", "Join the Club table with Member_of_club and then with Student to get the necessary information about club memberships and student genders.", "Group the results by club name to count the number of female members in each club.", "Order the results by the count of female members in descending order to find the club with the most female students.", "Limit the results to 1 to get only the top club."], "gold_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  'F' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid = t2.clubid JOIN student AS t3 ON t2.stuid = t3.stuid WHERE t3.sex = 'Female' GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n        \"virtual_table\": \"SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  [PLACEHOLDER-TYPE:STRING] AND t3.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of clubs that students with a specific major are members of. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of clubs returned. The placeholders in the WHERE clause and LIMIT clause represent the major of the students and the maximum number of clubs to display, respectively.\",\n        \"virtual_table\": \"SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4312", "db_id": "club_1", "question": "List the clubs that have at least a member with advisor \"1121\".", "rationale": ["Identify the tables involved: We need to get club names, so we will use the 'Club' table. We also need to check which students are members of these clubs, so we will use the 'Member_of_club' table. Finally, we need to filter students based on their advisor, which requires the 'Student' table.", "Join the tables: We will join the 'Club' table with the 'Member_of_club' table on ClubID, and then join the result with the 'Student' table on StuID to get access to the advisor information.", "Filter by advisor: We will add a WHERE clause to filter students whose advisor is '1121'.", "Select distinct club names: Since multiple students can belong to the same club, we will use DISTINCT to ensure that each club name is listed only once."], "gold_sql": "SELECT DISTINCT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.advisor  =  1121", "source_tables": ["club", "member_of_club", "student"], "pred_sql": "SELECT DISTINCT c.ClubName \nFROM Club AS c \nJOIN Member_of_club AS m ON c.ClubID = m.ClubID \nJOIN Student AS s ON m.StuID = s.StuID \nWHERE s.Advisor = '1121';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of clubs that students with a specific major are members of. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of clubs returned. The placeholders in the WHERE clause and LIMIT clause represent the major of the students and the maximum number of clubs to display, respectively.\",\n        \"virtual_table\": \"SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.major  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first and last names of students who are members of a specific club and belong to a certain gender. The placeholders in the WHERE clause represent the club's name and the student's gender.\",\n        \"virtual_table\": \"SELECT t3.fname ,  t3.lname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  [PLACEHOLDER-TYPE:STRING] AND t3.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of club names from the 'Club' table that are associated with students of a specific gender. The query joins the 'Club', 'Member_of_club', and 'Student' tables to filter clubs based on the gender of the students. The results are grouped by club name and ordered by the number of members in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT t1.clubname FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t3.sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY t1.clubname ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4324", "db_id": "tracking_grants_for_research", "question": "What is the total grant amount of the organisations described as research?", "rationale": ["Identify the relevant tables: Grants and Organisations are needed to get the grant amounts and their associated organisations.", "Join the Grants table with the Organisations table on the organisation_id to link grants to their respective organisations.", "Filter the results to include only those organisations that are described as 'research'. This requires a subquery to find the organisation_type corresponding to 'research' in the Organisation_Types table.", "Use the SUM function to calculate the total grant amount for the filtered organisations."], "gold_sql": "SELECT sum(grant_amount) FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id JOIN organisation_Types AS T3 ON T2.organisation_type  =  T3.organisation_type WHERE T3.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations"], "pred_sql": "SELECT SUM(grant_amount) AS total_grant_amount \nFROM Grants AS G \nJOIN Organisations AS O ON G.organisation_id = O.organisation_id \nWHERE O.organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'research');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n        \"virtual_table\": \"SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4327", "db_id": "tracking_grants_for_research", "question": "From what date and to what date do the staff work on a project that has the most staff and has staff in a leader role?", "rationale": ["Identify the requirement to find the dates of staff involvement in a project with the most staff members and specifically those in a leader role.", "Use a subquery to find the project_id of the project that has the most staff members by grouping Project_Staff by project_id and ordering by the count of staff members, limiting the result to 1.", "Use a UNION to combine results from two queries: one for the project with the most staff and another for staff members with a specific role code (in this case, 'leader').", "Select the date_from and date_to from both sets of results to get the required information."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1 ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'leader'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to FROM Project_Staff WHERE project_id IN (SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 1) UNION SELECT date_from, date_to FROM Project_Staff WHERE role_code = 'leader'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4328", "db_id": "tracking_grants_for_research", "question": "Find the organisation ids and details of the organisations which are involved in", "rationale": ["The user wants to find the organisation ids and details of the organisations involved in some context, which is not specified but implies a general query about organisations.", "To retrieve the organisation ids and their details, we need to select the relevant columns from the Organisations table.", "The relevant columns are 'organisation_id' and 'organisation_details'.", "Thus, the SQL query will be a simple SELECT statement that fetches these columns from the Organisations table."], "gold_sql": "SELECT T2.organisation_id ,  T2.organisation_details FROM Grants AS T1 JOIN Organisations AS T2 ON T1.organisation_id  =  T2.organisation_id GROUP BY T2.organisation_id HAVING sum(T1.grant_amount)  >  6000", "source_tables": ["grants", "organisations"], "pred_sql": "SELECT organisation_id, organisation_details FROM Organisations;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4330", "db_id": "tracking_grants_for_research", "question": "What is the organisation type and id of the organisation which has the most number of research staff?", "rationale": ["Identify the relevant tables: Research_Staff, Organisations, and Organisation_Types.", "We need to find the organisation with the most research staff, so we will count the number of staff members in the Research_Staff table grouped by organisation.", "Join the Research_Staff table with the Organisations table on the employer_organisation_id to get the organisation details.", "Join the Organisations table with the Organisation_Types table to get the organisation type description.", "Group the results by organisation ID and organisation type to count the number of research staff per organisation.", "Order the results by the count of research staff in descending order to get the organisation with the most staff at the top.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_id, Organisation_Types.organisation_type \nFROM Research_Staff \nJOIN Organisations ON Research_Staff.employer_organisation_id = Organisations.organisation_id \nJOIN Organisation_Types ON Organisations.organisation_type = Organisation_Types.organisation_type \nGROUP BY Organisations.organisation_id, Organisation_Types.organisation_type \nORDER BY COUNT(Research_Staff.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4331", "db_id": "tracking_grants_for_research", "question": "What is the type and id of the organization that has the most research staff?", "rationale": ["Identify the relevant tables: We need to find information about organizations and their associated research staff, so we will use the Organisations and Research_Staff tables.", "Join the tables: We will join the Organisations table with the Research_Staff table on the organisation_id to link each research staff member to their respective organization.", "Group by organization: To find out how many research staff each organization has, we will group the results by organisation_id and organisation_type.", "Count the research staff: We will count the number of staff members for each organization using COUNT(Research_Staff.staff_id).", "Order by count: To find the organization with the most research staff, we will order the results in descending order based on the count of research staff.", "Limit to one result: Finally, we will limit the results to just one organization, which will be the one with the most research staff."], "gold_sql": "SELECT T1.organisation_type ,  T1.organisation_id FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT Organisations.organisation_type, Organisations.organisation_id\nFROM Organisations\nJOIN Research_Staff ON Organisations.organisation_id = Research_Staff.employer_organisation_id\nGROUP BY Organisations.organisation_id, Organisations.organisation_type\nORDER BY COUNT(Research_Staff.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4333", "db_id": "tracking_grants_for_research", "question": "What is the type of the organization with the most research staff?", "rationale": ["Identify the table that contains information about organizations and their types, which is the Organisations table.", "Determine the relationship between Research_Staff and Organisations to find out which organization has the most research staff. This is done by grouping Research_Staff by employer_organisation_id and counting the number of staff members for each organization.", "Use a subquery to find the organisation_id with the maximum count of research staff members.", "Once we have the organisation_id, we can find the corresponding organisation_type from the Organisations table.", "Finally, we need to get the description of that organisation type from the Organisation_Types table using the organisation_type found in the previous step."], "gold_sql": "SELECT T1.organisation_type FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_type ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT organisation_type_description FROM Organisation_Types WHERE organisation_type = (SELECT organisation_type FROM Organisations WHERE organisation_id IN (SELECT employer_organisation_id FROM Research_Staff GROUP BY employer_organisation_id ORDER BY COUNT(*) DESC LIMIT 1))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4334", "db_id": "tracking_grants_for_research", "question": "Find out the send dates of the documents with the grant amount of more than 5000 were granted by organisation type described", "rationale": ["Identify the relevant tables: Documents, Grants, Organisations, and Organisation_Types.", "We need to find the sent dates of documents, so we will select the 'sent_date' from the Documents table.", "To filter documents based on grant amounts, we will join the Documents table with the Grants table on 'grant_id'.", "We need to ensure that the grants have an amount greater than 5000, so we will add a WHERE clause for this condition.", "To include information about the organisation type, we will join the Grants table with the Organisations table and then with the Organisation_Types table.", "Finally, we will construct the SQL query to select the 'sent_date' from the Documents table where the grant amount is greater than 5000."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT T2.sent_date \nFROM Documents AS T2 \nJOIN Grants AS T1 ON T1.grant_id = T2.grant_id \nJOIN Organisations AS T3 ON T1.organisation_id = T3.organisation_id \nJOIN Organisation_Types AS T4 ON T3.organisation_type = T4.organisation_type \nWHERE T1.grant_amount > 5000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n        \"virtual_table\": \"SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4335", "db_id": "tracking_grants_for_research", "question": "What are the send dates for all documents that have a grant amount of more than 5000 and are involved in research?", "rationale": ["Identify the relevant tables: Documents and Grants.", "We need to retrieve the 'sent_date' from the Documents table.", "We need to filter documents based on the grant amount from the Grants table, specifically those greater than 5000.", "Join the Documents table with the Grants table on the 'grant_id' to access the grant amount for each document.", "Construct the SQL query to select 'sent_date' from Documents where the associated grant amount is greater than 5000."], "gold_sql": "SELECT T1.sent_date FROM documents AS T1 JOIN Grants AS T2 ON T1.grant_id  =  T2.grant_id JOIN Organisations AS T3 ON T2.organisation_id  =  T3.organisation_id JOIN organisation_Types AS T4 ON T3.organisation_type  =  T4.organisation_type WHERE T2.grant_amount  >  5000 AND T4.organisation_type_description  =  'Research'", "source_tables": ["grants", "organisation_types", "organisations", "documents"], "pred_sql": "SELECT T2.sent_date \nFROM Documents AS T2 \nJOIN Grants AS T1 ON T1.grant_id = T2.grant_id \nWHERE T1.grant_amount > 5000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n        \"virtual_table\": \"SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4343", "db_id": "tracking_grants_for_research", "question": "When did researchers start and stop working?", "rationale": ["The question asks for the start and stop dates of researchers working on projects.", "To find this information, we need to look at the Project_Staff table, which contains the dates of staff involvement in projects.", "We can use a subquery to get the top N projects with the most staff members, which will help us filter the relevant projects.", "The hint provides a virtual table structure that combines two sets of data: one for the top projects and another for filtering by role code.", "We will replace the placeholders in the hint with specific values: we will limit to the top 5 projects and filter by the role code for researchers.", "The final SQL query will select the start and end dates from the Project_Staff table based on these criteria."], "gold_sql": "SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  'researcher'", "source_tables": ["project_staff"], "pred_sql": "SELECT date_from, date_to FROM Project_Staff WHERE project_id IN ( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT 5 ) UNION SELECT date_from, date_to FROM Project_Staff WHERE role_code = 'researcher'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4349", "db_id": "tracking_grants_for_research", "question": "What are the details for the project whose research has been published?", "rationale": ["The question asks for details of projects whose research has been published.", "To find this information, we need to join the Projects table with the Project_Outcomes table based on the project_id.", "We will filter the results based on the outcome_code that indicates the research has been published.", "Assuming 'published' is the outcome code representing published research, we will use it in the WHERE clause to filter the results."], "gold_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id JOIN Research_outcomes AS T3 ON T2.outcome_code  =  T3.outcome_code WHERE T3.outcome_description LIKE '%Published%'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT T1.project_details FROM Projects AS T1 JOIN Project_Outcomes AS T2 ON T1.project_id = T2.project_id WHERE T2.outcome_code = 'published'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4356", "db_id": "tracking_grants_for_research", "question": "Which project made the most number of outcomes? List the project details and the project id.", "rationale": ["Identify the relevant tables: Projects and Project_Outcomes are needed to get project details and their outcomes.", "Join the Projects table with the Project_Outcomes table on the project_id to associate projects with their outcomes.", "Group the results by project_id and project_details to aggregate the outcomes for each project.", "Count the number of outcomes for each project using COUNT(PO.outcome_code).", "Order the results in descending order to get the project with the most outcomes at the top.", "Limit the results to 1 to get only the project with the highest count of outcomes."], "gold_sql": "SELECT T1.project_details ,  T1.project_id FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.project_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT P.project_id, P.project_details \nFROM Projects AS P \nJOIN Project_Outcomes AS PO ON P.project_id = PO.project_id \nGROUP BY P.project_id, P.project_details \nORDER BY COUNT(PO.outcome_code) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4360", "db_id": "tracking_grants_for_research", "question": "Which organisation hired the most number of research staff? List the organisation id, type and detail.", "rationale": ["Identify the relevant tables: Organisations and Research_Staff.", "We need to join these tables on the organisation_id to get the details of the organisations that hired research staff.", "Count the number of research staff for each organisation using COUNT(rs.staff_id).", "Group the results by organisation_id to aggregate the counts for each organisation.", "Order the results in descending order to find the organisation with the most research staff.", "Limit the results to 1 to get only the top organisation."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details\nFROM Organisations o\nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id\nGROUP BY o.organisation_id\nORDER BY COUNT(rs.staff_id) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4361", "db_id": "tracking_grants_for_research", "question": "What are the ids, types, and details of the organization with the most research staff?", "rationale": ["Identify the relevant tables: Organisations and Research_Staff are needed to get the organization details and the count of research staff.", "Join the Organisations table with the Research_Staff table on the organisation_id to link organizations with their respective research staff.", "Group the results by organisation_id to count the number of research staff per organization.", "Order the results in descending order based on the count of research staff to find the organization with the most staff.", "Limit the results to 1 to get only the organization with the highest count of research staff."], "gold_sql": "SELECT T1.organisation_id ,  T1.organisation_type ,  T1.organisation_details FROM Organisations AS T1 JOIN Research_Staff AS T2 ON T1.organisation_id  =  T2.employer_organisation_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["organisations", "research_staff"], "pred_sql": "SELECT o.organisation_id, o.organisation_type, o.organisation_details \nFROM Organisations o \nJOIN Research_Staff rs ON o.organisation_id = rs.employer_organisation_id \nGROUP BY o.organisation_id \nORDER BY COUNT(rs.staff_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4363", "db_id": "tracking_grants_for_research", "question": "For each staff id, what is the description of the role that is involved with the most number of projects?", "rationale": ["Identify the relevant tables: Project_Staff for staff involvement in projects and Staff_Roles for role descriptions.", "We need to find the staff ID and the role description of the role involved with the most number of projects.", "To find the role involved with the most projects, we can use a subquery that counts the number of staff members per project and orders them in descending order, limiting the result to the top project.", "Join the Project_Staff table with the Staff_Roles table to get the role descriptions based on the role code.", "Select the staff ID and the corresponding role description from the joined tables."], "gold_sql": "SELECT T1.role_description ,  T2.staff_id FROM Staff_Roles AS T1 JOIN Project_Staff AS T2 ON T1.role_code  =  T2.role_code JOIN Project_outcomes AS T3 ON T2.project_id  =  T3.project_id GROUP BY T2.staff_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "project_staff", "staff_roles"], "pred_sql": "SELECT ps.staff_id, sr.role_description\nFROM Project_Staff ps\nJOIN Staff_Roles sr ON ps.role_code = sr.role_code\nWHERE ps.project_id IN (\n    SELECT project_id\n    FROM Project_Staff\n    GROUP BY project_id\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4367", "db_id": "tracking_grants_for_research", "question": "For grants that have descriptions of Regular and Initial Applications, what are their start dates?", "rationale": ["Identify the relevant document types by querying the Document_Types table for descriptions 'Regular Applications' and 'Initial Applications'.", "Use the resulting document_type_code to filter the Documents table to find grants associated with these document types.", "Select the grant_id from the Documents table based on the filtered document_type_code.", "Finally, use the grant_id to retrieve the grant_start_date from the Grants table."], "gold_sql": "SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Regular' INTERSECT SELECT T1.grant_start_date FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id JOIN Document_Types AS T3 ON T2.document_type_code  =  T3.document_type_code WHERE T3.document_description  =  'Initial Application'", "source_tables": ["grants", "document_types", "documents"], "pred_sql": "SELECT grant_start_date FROM Grants WHERE grant_id IN (SELECT grant_id FROM Documents WHERE document_type_code IN (SELECT document_type_code FROM Document_Types WHERE document_description IN ('Regular Applications', 'Initial Applications')));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n        \"virtual_table\": \"SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4369", "db_id": "tracking_grants_for_research", "question": "For each grant id, how many documents does it have, and which one has the most?", "rationale": ["Identify the relevant tables: Grants and Documents.", "We need to count the number of documents associated with each grant, so we will use a LEFT JOIN between Grants and Documents on the grant_id.", "Use COUNT() to count the number of documents for each grant.", "Group the results by grant_id to get the count for each grant.", "To find which grant has the most documents, we will order the results by the document count in descending order.", "Limit the results to 1 to get the grant with the most documents."], "gold_sql": "SELECT grant_id ,  count(*) FROM Documents GROUP BY grant_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT g.grant_id, COUNT(d.document_id) AS document_count, d.document_id AS most_documents\nFROM Grants g\nLEFT JOIN Documents d ON g.grant_id = d.grant_id\nGROUP BY g.grant_id\nORDER BY document_count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the grant amounts from the 'Grants' table that are associated with documents sent before a specific date and grants that are still active after a certain end date. The placeholders in the WHERE clause represent the dates for filtering the documents and grants.\",\n        \"virtual_table\": \"SELECT T1.grant_amount FROM Grants AS T1 JOIN Documents AS T2 ON T1.grant_id  =  T2.grant_id WHERE T2.sent_date  <  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT grant_amount FROM grants WHERE grant_end_date  >  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4372", "db_id": "tracking_grants_for_research", "question": "What are all the details of the organisations described as 'Sponsor'? Sort the result in an ascending order.", "rationale": ["Identify the relevant table: Organisations.", "Determine the condition to filter organisations: organisation_type should match the type described as 'Sponsor'.", "To find the organisation_type corresponding to 'Sponsor', a subquery is needed to select it from the Organisation_Types table.", "Construct the SQL query to select all columns from Organisations where the organisation_type matches the result of the subquery, and sort the results in ascending order by organisation_id."], "gold_sql": "SELECT organisation_details FROM Organisations AS T1 JOIN organisation_Types AS T2 ON T1.organisation_type  =  T2.organisation_type WHERE T2.organisation_type_description  =  'Sponsor' ORDER BY organisation_details", "source_tables": ["organisation_types", "organisations"], "pred_sql": "SELECT * FROM Organisations WHERE organisation_type = (SELECT organisation_type FROM Organisation_Types WHERE organisation_type_description = 'Sponsor') ORDER BY organisation_id ASC;", "hint": "\n"}
{"sample_id": "train.4380", "db_id": "tracking_grants_for_research", "question": "What are the result description of the project whose detail is 'sint'?", "rationale": ["Identify the relevant table: The question asks for project details, which are stored in the 'Projects' table.", "Determine the specific condition: The user is looking for projects with a specific detail, which is 'sint'.", "Construct the SQL query: Use a SELECT statement to retrieve 'project_details' from the 'Projects' table where 'project_details' matches 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT project_details FROM Projects WHERE project_details = 'sint';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4381", "db_id": "tracking_grants_for_research", "question": "What is the description for the results whose project detail is 'sint'?", "rationale": ["Identify the relevant table: The question asks for a description related to project details, which is found in the 'Projects' table.", "Determine the specific condition: The user is looking for projects with a specific detail, which is 'sint'.", "Construct the SQL query: Use a SELECT statement to retrieve 'project_details' from the 'Projects' table where 'project_details' matches 'sint'."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code JOIN Projects AS T3 ON T2.project_id  =  T3.project_id WHERE T3.project_details  =  'sint'", "source_tables": ["project_outcomes", "projects", "research_outcomes"], "pred_sql": "SELECT project_details FROM Projects WHERE project_details = 'sint'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4383", "db_id": "tracking_grants_for_research", "question": "What is the id of the organization with the maximum number of outcomes and how many outcomes are there?", "rationale": ["We need to find the organization with the maximum number of outcomes.", "To do this, we will join the Project_Outcomes table with the Projects table using the project_id.", "Next, we will join the Projects table with the Organisations table using the organisation_id.", "We will count the number of outcomes for each organization using COUNT(outcome_code).", "We will group the results by organisation_id to get the count for each organization.", "To find the organization with the maximum outcomes, we will order the results by outcome_count in descending order.", "Finally, we will limit the results to 1 to get only the organization with the maximum outcomes."], "gold_sql": "SELECT T1.organisation_id ,  count(*) FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id GROUP BY T1.organisation_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_outcomes", "projects"], "pred_sql": "SELECT organisation_id, COUNT(outcome_code) AS outcome_count\nFROM Project_Outcomes\nJOIN Projects ON Project_Outcomes.project_id = Projects.project_id\nJOIN Organisations ON Projects.organisation_id = Organisations.organisation_id\nGROUP BY organisation_id\nORDER BY outcome_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4384", "db_id": "tracking_grants_for_research", "question": "List the project details of the projects launched by the organisation", "rationale": ["Identify the relevant table for project details, which is the 'Projects' table.", "Determine the relationship between projects and organisations, which is through the 'organisation_id'.", "Select the 'organisation_id' from the 'Organisations' table to filter projects launched by those organisations.", "Construct the SQL query to select 'project_details' from the 'Projects' table where the 'organisation_id' matches those in the 'Organisations' table."], "gold_sql": "SELECT project_details FROM Projects WHERE organisation_id IN ( SELECT organisation_id FROM Projects GROUP BY organisation_id ORDER BY count(*) DESC LIMIT 1 )", "source_tables": ["projects"], "pred_sql": "SELECT project_details FROM Projects WHERE organisation_id IN (SELECT organisation_id FROM Organisations)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of project details from the 'Projects' table for projects that do not have any associated staff members with a specific role. The placeholder in the WHERE clause represents the role code that is being filtered out.\",\n        \"virtual_table\": \"SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING] )\"\n    }\n}\n"}
{"sample_id": "train.4392", "db_id": "tracking_grants_for_research", "question": "What are the staff roles of the staff who", "rationale": ["Identify the relevant tables: Project_Staff and Staff_Roles are needed to get the staff roles.", "Project_Staff contains the role_code which links to Staff_Roles for the role descriptions.", "Join Project_Staff with Staff_Roles on role_code to get the descriptions of the roles.", "Select the role_code and role_description to provide a clear output of staff roles."], "gold_sql": "SELECT role_code FROM Project_Staff WHERE date_from  >  '2003-04-19 15:06:20' AND date_to  <  '2016-03-15 00:33:18'", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, role_description FROM Project_Staff JOIN Staff_Roles ON Project_Staff.role_code = Staff_Roles.role_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4394", "db_id": "tracking_grants_for_research", "question": "What are the descriptions of all the project outcomes?", "rationale": ["The user wants to retrieve descriptions of all project outcomes, which suggests querying the Project_Outcomes table.", "The relevant columns for the descriptions are 'outcome_code' and 'outcome_details'.", "The SQL query will select these columns from the Project_Outcomes table without any filtering conditions, as we want all outcomes."], "gold_sql": "SELECT T1.outcome_description FROM Research_outcomes AS T1 JOIN Project_outcomes AS T2 ON T1.outcome_code  =  T2.outcome_code", "source_tables": ["project_outcomes", "research_outcomes"], "pred_sql": "SELECT outcome_code, outcome_details FROM Project_Outcomes;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have specific outcomes. It retrieves project details for projects that have two different specified outcome codes, ensuring that only projects meeting both criteria are included in the results. The placeholders in the WHERE clause represent the outcome codes being queried.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the project details from the 'Projects' table that have two specific outcomes. The query uses an INTERSECT operation to find projects that meet both outcome criteria, represented by placeholders for the outcome codes.\",\n        \"virtual_table\": \"SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.project_details FROM Projects AS T1 JOIN Project_outcomes AS T2 ON T1.project_id  =  T2.project_id WHERE T2.outcome_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4397", "db_id": "tracking_grants_for_research", "question": "What is the most common role for the staff?", "rationale": ["Identify the relevant table: The question pertains to staff roles, so we will focus on the Project_Staff table.", "Determine the information needed: We need to find the most common role, which implies counting occurrences of each role.", "Group by role_code: To count how many times each role appears, we will use GROUP BY on the role_code column.", "Count occurrences: We will use COUNT(*) to count the number of staff members for each role.", "Order by count: To find the most common role, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most common role, we will limit the results to 1."], "gold_sql": "SELECT role_code FROM Project_Staff GROUP BY role_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["project_staff"], "pred_sql": "SELECT role_code, COUNT(*) as role_count \nFROM Project_Staff \nGROUP BY role_code \nORDER BY role_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the start and end dates of staff involvement in projects. It combines two sets of data: the first set includes dates for the top N projects with the most staff members, while the second set includes dates for staff members with a specific role. The placeholders represent the number of top projects to retrieve and the role code for filtering staff members.\",\n        \"virtual_table\": \"SELECT date_from ,  date_to FROM Project_Staff WHERE project_id IN( SELECT project_id FROM Project_Staff GROUP BY project_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER] ) UNION SELECT date_from ,  date_to FROM Project_Staff WHERE role_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4410", "db_id": "network_2", "question": "Who is the oldest person whose job is student?", "rationale": ["Identify the table to query: The relevant table is 'Person' as it contains information about individuals including their job and age.", "Filter the results: We need to find individuals whose job is 'student'. This will be done using a WHERE clause.", "Sort the results: To find the oldest person, we will sort the results by age in descending order using ORDER BY age DESC.", "Limit the results: Since we only want the oldest person, we will limit the results to 1 using LIMIT 1."], "gold_sql": "SELECT name FROM Person WHERE job  =  'student' AND age  =  (SELECT max(age) FROM person WHERE job  =  'student' )", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE job = 'student' ORDER BY age DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4439", "db_id": "network_2", "question": "What is the name and age of every male? Order the results by age.", "rationale": ["Identify the relevant table: The 'Person' table contains the information we need about individuals, including their name, age, and gender.", "Filter the results: We need to select only those individuals whose gender is 'male'.", "Select the required columns: We need to retrieve the 'name' and 'age' of these individuals.", "Order the results: The final output should be ordered by the 'age' column in ascending order."], "gold_sql": "SELECT name FROM Person WHERE gender  =  'male' ORDER BY age", "source_tables": ["person"], "pred_sql": "SELECT name, age FROM Person WHERE gender = 'male' ORDER BY age;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4441", "db_id": "network_2", "question": "What are the names and ages of every person who is a friend of both Dan and Alice?", "rationale": ["Identify the requirement: We need names and ages of persons who are friends with both Dan and Alice.", "Use the 'Person' table to get names and ages.", "Join the 'Person' table with the 'PersonFriend' table to access friendship data.", "To find mutual friends, we can use the INTERSECT operator to get names and ages of persons who are friends with Dan and also friends with Alice.", "Construct the first part of the query to find friends of Dan.", "Construct the second part of the query to find friends of Alice.", "Combine both parts using INTERSECT to get the final result."], "gold_sql": "SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Alice'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name, T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend = 'Dan' INTERSECT SELECT T1.name, T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend = 'Alice'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4444", "db_id": "network_2", "question": "Find the name of the person who has friends with age above 40 and under age 30?", "rationale": ["Identify the requirement: We need to find names of persons who have friends older than 40 and younger than 30.", "Use the provided virtual table structure to create the SQL query.", "The first part of the query will select names of persons who have friends older than 40.", "The second part of the query will exclude those who have friends younger than 30 using the EXCEPT clause.", "Combine these two parts into a single SQL query."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  > 40) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  < 30)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4445", "db_id": "network_2", "question": "What are the names of every person who has a friend over 40 and under 30?", "rationale": ["Identify the requirement: We need names of persons who have friends over 40 and under 30.", "Use the provided virtual table structure to filter friends based on age criteria.", "The first part of the query selects names of persons whose friends are older than 40.", "The second part of the query excludes names of persons whose friends are younger than 30 using the EXCEPT clause.", "Combine these two parts to form the final SQL query."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  40) INTERSECT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  30)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age > 40) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age < 30)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4449", "db_id": "network_2", "question": "What are the names of the people who have no friends who are students?", "rationale": ["Identify the requirement: We need the names of people who have no friends who are students.", "Use the 'Person' table to get all names.", "Use the 'PersonFriend' table to find friends of each person.", "Filter out those who have friends with the job title 'student'.", "The SQL query will use the EXCEPT clause to exclude names of people who have friends that are students."], "gold_sql": "SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  'student'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT name FROM Person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.friend WHERE T1.job = 'student'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who do not have any friends that work in a specific occupation. The placeholder in the query allows for the specification of the job title to filter out those individuals accordingly.\",\n        \"virtual_table\": \"SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4454", "db_id": "network_2", "question": "Find the name of persons who are friends with Bob.", "rationale": ["Identify the tables involved: We need to get names from the 'Person' table and check friendships from the 'PersonFriend' table.", "Determine the relationship: We will join the 'Person' table with the 'PersonFriend' table on the name column.", "Specify the condition: We want to find friends of 'Bob', so we will filter the results where the friend column in 'PersonFriend' is 'Bob'.", "Use DISTINCT to ensure we get unique names of persons who are friends with Bob."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend = 'Bob'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] OR T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4455", "db_id": "network_2", "question": "What are the names of all of Bob's friends?", "rationale": ["Identify the main entity of the query, which is Bob.", "We need to find Bob's friends, which are listed in the PersonFriend table.", "Join the Person table with the PersonFriend table on the name column to access Bob's friends.", "Filter the results where the name in the Person table is 'Bob'.", "Select the friend names from the PersonFriend table where they are friends with Bob."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Bob'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T1.name = 'Bob'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] OR T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4456", "db_id": "network_2", "question": "Find the names of females who are friends with Zach", "rationale": ["Identify the relevant tables: We need to use the 'Person' table to get the names and gender of individuals, and the 'PersonFriend' table to find friends.", "We are looking for females who are friends with Zach, so we will join the 'Person' table (aliased as T1) with the 'PersonFriend' table (aliased as T2) on the name column.", "In the WHERE clause, we specify that we want to find records where T2.friend is 'Zach' to filter for friends of Zach.", "Additionally, we need to filter for females, so we add another condition in the WHERE clause that T1.gender must be 'female'.", "The final SQL query selects the names of individuals who meet both criteria."], "gold_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Zach' AND T1.gender  =  'female'", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend = 'Zach' AND T1.gender = 'female'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] OR T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4465", "db_id": "network_2", "question": "What are the different names of friends who are younger than the average age for a friend?", "rationale": ["Identify the average age of friends from the 'Person' table.", "Filter friends who are younger than this average age.", "Use a JOIN between 'Person' and 'PersonFriend' to get the names of friends.", "Select distinct names of friends who meet the age criteria."], "gold_sql": "SELECT DISTINCT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  <  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT DISTINCT T2.friend FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE (SELECT AVG(age) FROM Person WHERE name = T2.friend) > (SELECT age FROM Person WHERE name = T2.friend)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4466", "db_id": "network_2", "question": "Who has friends that are older than the average age? Print their friends and their ages as well", "rationale": ["First, we need to find the average age of all persons in the 'Person' table.", "Next, we will identify individuals who have friends that are older than this average age.", "We will use a subquery to select names from the 'Person' table where the age is greater than the average age.", "We also need to ensure that these individuals do not have friends who are younger than the average age, which can be done using an EXCEPT clause with another subquery.", "Finally, we will join the 'PersonFriend' table to get the names of these friends and their ages from the 'Person' table."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T2.friend, P.age FROM PersonFriend AS T2 JOIN Person AS P ON T2.friend = P.name WHERE T2.name IN (SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age > (SELECT AVG(age) FROM Person)) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age < (SELECT AVG(age) FROM Person)))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4467", "db_id": "network_2", "question": "Whare the names, friends, and ages of all people who are older than the average age of a person?", "rationale": ["Identify the columns needed: names, friends, and ages of people.", "We need to join the 'Person' table with the 'PersonFriend' table to get the friends of each person.", "We need to filter the results to include only those people whose age is greater than the average age of all persons.", "To find the average age, we can use a subquery: (SELECT AVG(age) FROM Person).", "Construct the SQL query using the SELECT statement with the necessary JOIN and WHERE clauses."], "gold_sql": "SELECT DISTINCT T2.name ,  T2.friend ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.age  >  (SELECT avg(age) FROM person)", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT P.name, PF.friend, P.age FROM Person AS P JOIN PersonFriend AS PF ON P.name = PF.name WHERE P.age > (SELECT AVG(age) FROM Person)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4473", "db_id": "network_2", "question": "What are the names of all people who are friends with Alice for the shortest amount of time?", "rationale": ["Identify the main subject of the query: we need to find people who are friends with Alice.", "We need to join the 'Person' table with the 'PersonFriend' table to access the names of Alice's friends.", "The condition for friendship is that the 'name' in 'PersonFriend' should be 'Alice'.", "To find the friends with the shortest friendship duration, we need to look for the minimum year in which the friendship was established.", "We will use a subquery to find the minimum year of friendship for Alice and filter the results based on that year."], "gold_sql": "SELECT name FROM PersonFriend WHERE friend =  'Alice' AND YEAR  =  (SELECT min(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.friend WHERE T2.name = 'Alice' AND T2.year = (SELECT MIN(year) FROM PersonFriend WHERE name = 'Alice')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a distinct list of names and ages of individuals from the 'Person' table who have specific friends listed in the 'PersonFriend' table. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] OR T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4475", "db_id": "network_2", "question": "What are the names, ages, and jobs of all people who are friends with Alice for the longest amount of time?", "rationale": ["Identify the required information: names, ages, and jobs of people who are friends with Alice.", "Use the 'Person' table to get the names, ages, and jobs.", "Join the 'Person' table with the 'PersonFriend' table on the name column to link friends with their details.", "Filter the results to include only those who are friends with Alice by using a WHERE clause.", "To find the friends who have been friends with Alice for the longest time, we need to find the maximum year of friendship established with Alice.", "Use a subquery to get the maximum year from the 'PersonFriend' table where the friend is Alice."], "gold_sql": "SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  'Alice' AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  'Alice')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name, T1.age, T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name = T2.name WHERE T2.friend = 'Alice' AND T2.year = (SELECT max(year) FROM PersonFriend WHERE friend = 'Alice')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and ages of persons from the 'Person' table who have mutual friendships with a specific friend. The placeholders in the WHERE clause represent the names of the friends being queried.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.name ,   T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4478", "db_id": "network_2", "question": "Which person whose friends have the oldest average age?", "rationale": ["Identify the need to find the person whose friends have the oldest average age.", "To achieve this, we need to calculate the average age of friends for each person.", "Join the 'PersonFriend' table with the 'Person' table to get the ages of friends.", "Group the results by the person's name to calculate the average age of their friends.", "Order the results by average age in descending order to find the oldest average age.", "Limit the results to 1 to get only the top person with the oldest average age."], "gold_sql": "SELECT T2.name ,  avg(T1.age) FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend GROUP BY T2.name ORDER BY avg(T1.age) DESC LIMIT 1", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT T1.name FROM Person AS T1 JOIN (SELECT T2.name, AVG(CAST(T3.age AS INTEGER)) AS avg_age FROM PersonFriend AS T2 JOIN Person AS T3 ON T2.friend = T3.name GROUP BY T2.name) AS avg_friends ON T1.name = avg_friends.name ORDER BY avg_friends.avg_age DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names, ages, and job titles of individuals from the 'Person' table who have a specific friend, along with the most recent year the friendship was established. The placeholders in the WHERE clause represent the friend's name.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.age ,  T1.job FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend =  [PLACEHOLDER-TYPE:STRING] AND T2.year  =  (SELECT max(YEAR) FROM PersonFriend WHERE friend =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "train.4480", "db_id": "network_2", "question": "What is the total number of people who has no friend living in the city of Austin.", "rationale": ["Identify the requirement: We need to count the number of distinct people who have no friends living in Austin.", "Use the PersonFriend table to find names of people and their friends.", "Filter out friends who live in Austin by using a subquery that selects names from the Person table where city is 'Austin'.", "Count the distinct names from the PersonFriend table where the friend is not in the list of friends living in Austin."], "gold_sql": "SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  'Austin')", "source_tables": ["personfriend", "person"], "pred_sql": "SELECT COUNT(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM Person WHERE city = 'Austin')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the number of distinct persons from the 'PersonFriend' table who have friends that do not reside in a specified city. The placeholder in the WHERE clause represents the name of the city to filter out friends.\",\n        \"virtual_table\": \"SELECT count(DISTINCT name) FROM PersonFriend WHERE friend NOT IN (SELECT name FROM person WHERE city  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who do not have any friends that work in a specific occupation. The placeholder in the query allows for the specification of the job title to filter out those individuals accordingly.\",\n        \"virtual_table\": \"SELECT name FROM person EXCEPT SELECT T2.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.friend WHERE T1.job  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the names of individuals from the 'Person' table who have friends that are older than a specified age, excluding those who have friends that are younger than that same age. The placeholders in the query represent the age criteria for filtering friends.\",\n        \"virtual_table\": \"SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  >  [PLACEHOLDER-TYPE:NUMBER]) EXCEPT SELECT T1.name FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend IN (SELECT name FROM Person WHERE age  <  [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4503", "db_id": "document_management", "question": "Find the types of documents with more than 4 documents.", "rationale": ["Identify the relevant table: The question pertains to documents, so we will use the 'Documents' table.", "Determine the required information: We need to find the types of documents, which corresponds to the 'document_type_code' column.", "Count the number of documents for each type: We will use the COUNT() function to count the number of documents for each 'document_type_code'.", "Group the results by document type: We will use GROUP BY on 'document_type_code' to aggregate the counts for each type.", "Filter the results: We need to include only those document types that have more than 4 documents, which can be done using the HAVING clause."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code, COUNT(*) AS document_count\nFROM Documents\nGROUP BY document_type_code\nHAVING COUNT(*) > 4;", "hint": "\n"}
{"sample_id": "train.4504", "db_id": "document_management", "question": "What are the codes of types of documents of which there are for or more?", "rationale": ["Identify the table that contains the document types, which is the 'Documents' table.", "We need to select the 'document_type_code' from the 'Documents' table.", "To find the document types that have four or more documents, we will group the results by 'document_type_code'.", "We will use the HAVING clause to filter the groups to only include those with a count of 'document_code' that is greater than or equal to 4."], "gold_sql": "SELECT document_type_code FROM documents GROUP BY document_type_code HAVING count(*)  >  4", "source_tables": ["documents"], "pred_sql": "SELECT document_type_code\nFROM Documents\nGROUP BY document_type_code\nHAVING COUNT(document_code) >= 4;", "hint": "\n"}
{"sample_id": "train.4505", "db_id": "document_management", "question": "Find the total access count of all documents in the most popular document type.", "rationale": ["We need to find the total access count of all documents in the most popular document type.", "First, we need to identify the most popular document type. This can be done by grouping the documents by their type code and summing their access counts.", "We will order the results by the summed access count in descending order to get the most popular document type at the top.", "To get only the most popular document type, we will limit our results to 1.", "Once we have the most popular document type, we can then sum the access counts of all documents that match this type code."], "gold_sql": "SELECT sum(access_count) FROM documents GROUP BY document_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["documents"], "pred_sql": "SELECT SUM(access_count) AS total_access_count\nFROM Documents\nWHERE document_type_code = (\n    SELECT document_type_code\n    FROM Documents\n    GROUP BY document_type_code\n    ORDER BY SUM(access_count) DESC\n    LIMIT 1\n);", "hint": "\n"}
{"sample_id": "train.4525", "db_id": "document_management", "question": "Find names of the document without any images.", "rationale": ["We need to find documents that do not have any associated images.", "To do this, we will select the document names from the Documents table.", "We will perform a LEFT JOIN with the Document_Sections table to get sections related to each document.", "Next, we will perform another LEFT JOIN with the Document_Sections_Images table to find images associated with those sections.", "Finally, we will filter the results where the image_id in Document_Sections_Images is NULL, indicating that there are no images associated with those documents."], "gold_sql": "SELECT document_name FROM documents EXCEPT SELECT t1.document_name FROM documents AS t1 JOIN document_sections AS t2 ON t1.document_code  =  t2.document_code JOIN document_sections_images AS t3 ON t2.section_id  =  t3.section_id", "source_tables": ["document_sections", "document_sections_images", "documents"], "pred_sql": "SELECT d.document_name \nFROM Documents d \nLEFT JOIN Document_Sections ds ON d.document_code = ds.document_code \nLEFT JOIN Document_Sections_Images dsi ON ds.section_id = dsi.section_id \nWHERE dsi.image_id IS NULL;", "hint": "\n"}
{"sample_id": "train.4532", "db_id": "document_management", "question": "Count the number of users that are logged in.", "rationale": ["The task is to count the number of users that are logged in.", "To achieve this, we need to count the total entries in the 'Users' table, as each entry represents a user.", "The SQL function COUNT(*) will be used to count all rows in the 'Users' table.", "The final SQL query will be 'SELECT COUNT(*) AS number_of_users FROM Users;' which gives us the total number of users."], "gold_sql": "SELECT count(*) FROM users WHERE user_login  =  1", "source_tables": ["users"], "pred_sql": "SELECT COUNT(*) AS number_of_users FROM Users;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of user names and their corresponding passwords from the 'Users' table, grouped by their role codes. The results are ordered by the number of users in each role, showing the top roles based on user count, with a limit specified by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of user names and their corresponding passwords from the 'Users' table, grouped by their role codes. The results are ordered by the number of users in each role, showing the most populated roles first, with a limit on the number of results returned as specified by the placeholder.\",\n        \"virtual_table\": \"SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.4733", "db_id": "department_store", "question": "Return the distinct name of customers whose order status is Pending, in the order of customer id.", "rationale": ["Identify the tables needed: Customers and Customer_Orders.", "We need to retrieve customer names, so we will select from the Customers table.", "We need to filter based on the order status, which is found in the Customer_Orders table.", "Join the Customers table with the Customer_Orders table on the customer_id field to link customers with their orders.", "Filter the results to include only those orders where the order status code is 'Pending'.", "Use DISTINCT to ensure that we only get unique customer names.", "Order the results by customer_id to meet the requirement of ordering by customer id."], "gold_sql": "SELECT DISTINCT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending' ORDER BY T2.customer_id", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT DISTINCT C.customer_name FROM Customers AS C JOIN Customer_Orders AS O ON C.customer_id = O.customer_id WHERE O.order_status_code = 'Pending' ORDER BY C.customer_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\",\n        \"virtual_table\": \"SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4736", "db_id": "department_store", "question": "What are the names and addressed of customers who have both New and Pending orders?", "rationale": ["Identify the tables involved: Customers and Customer_Orders.", "Determine the required fields: customer_name and customer_address from the Customers table.", "Establish the relationship between Customers and Customer_Orders using customer_id.", "Filter the orders based on their status: 'New' and 'Pending'.", "Use INTERSECT to find customers who have both New and Pending orders."], "gold_sql": "SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'New' INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  'Pending'", "source_tables": ["customer_orders", "customers"], "pred_sql": "SELECT T1.customer_name, T1.customer_address \nFROM Customers AS T1 \nJOIN Customer_Orders AS T2 ON T1.customer_id = T2.customer_id \nWHERE T2.order_status_code = 'New' \nINTERSECT \nSELECT T1.customer_name, T1.customer_address \nFROM Customers AS T1 \nJOIN Customer_Orders AS T2 ON T1.customer_id = T2.customer_id \nWHERE T2.order_status_code = 'Pending'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\",\n        \"virtual_table\": \"SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4749", "db_id": "department_store", "question": "Find the id and name of the staff who has been assigned for the shortest period.", "rationale": ["Identify the relevant table: Staff_Department_Assignments contains the staff assignments and their duration.", "To find the shortest assignment period, calculate the difference between date_assigned_to and date_assigned_from.", "Sort the results by the calculated duration in ascending order to get the shortest period first.", "Select the staff_id and staff_name from the sorted results.", "Limit the output to 1 to get only the staff with the shortest assignment period."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name\nFROM Staff_Department_Assignments\nORDER BY (date_assigned_to - date_assigned_from) ASC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4750", "db_id": "department_store", "question": "What is the id and name of the staff who has been assigned for the least amount of time?", "rationale": ["Identify the relevant table: The question asks for information about staff assignments, so we will use the Staff_Department_Assignments table.", "Select the required columns: We need the staff_id and staff_name, but staff_name is in the Staff table, so we will need to join it with the Staff table.", "Determine the ordering: We want to find the staff member who has been assigned for the least amount of time, which means we should order by the date_assigned_from column in ascending order.", "Limit the results: Since we only want the staff member with the least assignment time, we will limit the results to 1."], "gold_sql": "SELECT T1.staff_id ,  T1.staff_name FROM staff AS T1 JOIN Staff_Department_Assignments AS T2 ON T1.staff_id  =  T2.staff_id ORDER BY date_assigned_to - date_assigned_from LIMIT 1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_id, staff_name \nFROM Staff_Department_Assignments \nORDER BY date_assigned_from ASC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.4753", "db_id": "department_store", "question": "Find the ids of all distinct customers who made order after some orders that were Cancelled.", "rationale": ["Identify the relevant tables: Customers and Customer_Orders.", "We need to find distinct customer IDs, so we will select from the Customers table.", "Join the Customers table with the Customer_Orders table on customer_id to link customers with their orders.", "We need to filter customers who made orders after some orders that were cancelled. This means we need to find orders that have a status of 'Cancelled'.", "Use a subquery to select order_ids from Customer_Orders where the order_status_code is 'Cancelled'.", "The main query will select distinct customer_ids from Customers where their order_ids are in the list of cancelled order_ids."], "gold_sql": "SELECT DISTINCT customer_id FROM Customer_Orders WHERE order_date  >  (SELECT min(order_date) FROM Customer_Orders WHERE order_status_code  =  'Cancelled')", "source_tables": ["customer_orders"], "pred_sql": "SELECT DISTINCT C.customer_id \nFROM Customers C \nJOIN Customer_Orders CO ON C.customer_id = CO.customer_id \nWHERE CO.order_id IN (\n    SELECT CO2.order_id \n    FROM Customer_Orders CO2 \n    WHERE CO2.order_status_code = 'Cancelled'\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\",\n        \"virtual_table\": \"SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4755", "db_id": "department_store", "question": "What is id of the staff who had a Staff Department Assignment earlier than any Clerical Staff?", "rationale": ["Identify the relevant table: Staff_Department_Assignments contains the staff assignments and their dates.", "Determine the condition: We need to find staff who were assigned to a department earlier than any Clerical Staff.", "Use a subquery to find the earliest assignment date of Clerical Staff: SELECT MIN(date_assigned_from) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical'.", "Construct the main query to select staff_id from Staff_Department_Assignments where their assignment date is earlier than the result of the subquery."], "gold_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_to  <  (SELECT max(date_assigned_to) FROM Staff_Department_Assignments WHERE job_title_code  =  'Clerical Staff')", "source_tables": ["staff_department_assignments"], "pred_sql": "SELECT staff_id FROM Staff_Department_Assignments WHERE date_assigned_from < (SELECT MIN(date_assigned_from) FROM Staff_Department_Assignments WHERE job_title_code = 'Clerical')", "hint": "\n"}
{"sample_id": "train.4758", "db_id": "department_store", "question": "Return the names and ids of customers who have TN in their address.", "rationale": ["Identify the relevant table: The 'Customers' table contains the customer information including their addresses.", "Determine the required fields: We need to retrieve 'customer_id' and 'customer_name'.", "Formulate the WHERE clause: We need to filter customers based on their address containing 'TN'.", "Use the LIKE operator to search for 'TN' in the 'customer_address' field, ensuring to use wildcards (%) to match any characters before or after 'TN'.", "Combine these elements into a complete SQL SELECT statement."], "gold_sql": "SELECT customer_name ,  customer_id FROM customers WHERE customer_address LIKE '%TN%'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name FROM Customers WHERE customer_address LIKE '%TN%'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\",\n        \"virtual_table\": \"SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4760", "db_id": "department_store", "question": "What are the names and genders of staff who were assigned in 2016?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to retrieve the names and genders of staff members, which are in the Staff table.", "To find out which staff were assigned in 2016, we need to join the Staff table with the Staff_Department_Assignments table on staff_id.", "Filter the results based on the date range for the year 2016, using the date_assigned_from and date_assigned_to columns."], "gold_sql": "SELECT T1.staff_name ,  T1.staff_gender FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.date_assigned_from LIKE '2016%'", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name, staff_gender \nFROM Staff \nJOIN Staff_Department_Assignments ON Staff.staff_id = Staff_Department_Assignments.staff_id \nWHERE date_assigned_from >= '2016-01-01' AND date_assigned_to <= '2016-12-31';", "hint": "\n"}
{"sample_id": "train.4762", "db_id": "department_store", "question": "What are the names of staff who have been assigned multiple jobs?", "rationale": ["Identify the relevant tables: Staff and Staff_Department_Assignments.", "We need to find staff members who have been assigned multiple jobs, which implies looking for staff members with multiple distinct job titles.", "Join the Staff table with the Staff_Department_Assignments table on staff_id to get the job assignments for each staff member.", "Group the results by staff_id to aggregate the job assignments for each staff member.", "Use the HAVING clause to filter groups where the count of distinct job titles (job_title_code) is greater than 1."], "gold_sql": "SELECT T1.staff_name FROM staff AS T1 JOIN staff_department_assignments AS T2 ON T1.staff_id  =  T2.staff_id GROUP BY T2.staff_id HAVING COUNT (*)  >  1", "source_tables": ["staff_department_assignments", "staff"], "pred_sql": "SELECT staff_name\nFROM Staff\nJOIN Staff_Department_Assignments ON Staff.staff_id = Staff_Department_Assignments.staff_id\nGROUP BY Staff.staff_id\nHAVING COUNT(DISTINCT job_title_code) > 1;", "hint": "\n"}
{"sample_id": "train.4792", "db_id": "department_store", "question": "What are the ids and names of customers with addressed that contain WY and who do not use a credit card for payment?", "rationale": ["Identify the relevant table: Customers, which contains customer_id, customer_name, and payment_method_code.", "Filter customers based on their address: Use the LIKE operator to find addresses containing 'WY'.", "Exclude customers using a credit card: Use the NOT EQUAL operator to filter out those with payment_method_code as 'CREDIT_CARD'.", "Combine these conditions in the WHERE clause of the SQL query."], "gold_sql": "SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'Credit Card'", "source_tables": ["customers"], "pred_sql": "SELECT customer_id, customer_name FROM Customers WHERE customer_address LIKE '%WY%' AND payment_method_code != 'CREDIT_CARD'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the unique identifiers and names of customers from the 'Customers' table who have a specific address pattern and do not use a certain payment method. The placeholders in the WHERE clause represent the address pattern and the payment method code.\",\n        \"virtual_table\": \"SELECT customer_id ,  customer_name FROM customers WHERE customer_address LIKE [PLACEHOLDER-TYPE:STRING] AND payment_method_code != [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names and addresses of customers who have placed orders with a specific status. The query retrieves customer information from the 'Customers' table and filters it based on the order status from the 'Customer_Orders' table. The placeholders in the WHERE clause represent the order status codes that can be specified by the user.\",\n        \"virtual_table\": \"SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.customer_name ,  T1.customer_address FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.order_status_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4793", "db_id": "department_store", "question": "Find the average price of all product clothes.", "rationale": ["Identify the table that contains product information, which is the 'Products' table.", "Determine the relevant column for price, which is 'product_price'.", "To find the average price, use the AVG() function.", "Filter the products to only include those that are classified as clothes by using a WHERE clause on 'product_type_code'.", "Assume 'clothes' is represented by a specific code in 'product_type_code', which I will use as 'clothes' for this query."], "gold_sql": "SELECT avg(product_price) FROM products WHERE product_type_code  =  'Clothes'", "source_tables": ["products"], "pred_sql": "SELECT AVG(product_price) AS average_price\nFROM Products\nWHERE product_type_code = 'clothes';", "hint": "\n"}
{"sample_id": "train.4795", "db_id": "department_store", "question": "Find the name of the most expensive hardware product.", "rationale": ["Identify the relevant table: Products, which contains product information including name and price.", "Filter the products to only include those that are classified as 'hardware'.", "Sort the filtered products by price in descending order to get the most expensive one at the top.", "Limit the results to 1 to retrieve only the most expensive hardware product."], "gold_sql": "SELECT product_name FROM products WHERE product_type_code  =  'Hardware' ORDER BY product_price DESC LIMIT 1", "source_tables": ["products"], "pred_sql": "SELECT product_name FROM Products WHERE product_type_code = 'hardware' ORDER BY product_price DESC LIMIT 1;", "hint": "\n"}
{"sample_id": "train.4902", "db_id": "store_product", "question": "Find the list of page size which have more than 3 product listed", "rationale": ["We need to find the maximum page sizes that have more than 3 products listed.", "To do this, we will group the results by 'max_page_size' from the 'product' table.", "We will use the HAVING clause to filter groups that have a count of products greater than 3."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING COUNT(product_id) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4903", "db_id": "store_product", "question": "What is the maximum page size for everything that has more than 3 products listed?", "rationale": ["Identify the requirement: We need to find the maximum page size for products that have more than 3 listings in stores.", "To achieve this, we will first identify products that are listed in more than 3 stores. This can be done using the 'store_product' table, grouping by 'Product_ID' and using the HAVING clause to filter those with a count of Store_ID greater than 3.", "Next, we will select the 'max_page_size' from the 'product' table for those identified products. We will use a subquery to get the list of product IDs that meet the criteria from the 'store_product' table.", "The final SQL query combines these steps to retrieve the maximum page size for the relevant products."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size HAVING count(*)  >  3", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM product WHERE product_id IN (SELECT Product_ID FROM store_product GROUP BY Product_ID HAVING COUNT(Store_ID) > 3)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4913", "db_id": "store_product", "question": "What is the total number of residents for the districts with the 3 largest areas?", "rationale": ["Identify the requirement: We need to find the total number of residents in the districts with the 3 largest areas.", "To achieve this, we will first need to identify the districts with the largest areas. This can be done by ordering the districts based on the 'City_Area' column in descending order and limiting the results to the top 3.", "Once we have the top 3 districts, we can then sum their populations. This requires a subquery that selects the 'District_ID' of these top districts.", "Finally, we will use the SUM function to calculate the total population from the 'City_Population' column for these districts."], "gold_sql": "SELECT sum(city_population) FROM district ORDER BY city_area DESC LIMIT 3", "source_tables": ["district"], "pred_sql": "SELECT SUM(City_Population) AS Total_Residents\nFROM district\nWHERE District_ID IN (\n    SELECT District_ID\n    FROM district\n    ORDER BY City_Area DESC\n    LIMIT 3\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\",\n        \"virtual_table\": \"SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4917", "db_id": "store_product", "question": "What are the names of all the stores located in Khanewal District?", "rationale": ["Identify the relevant tables: store, store_district, and district are needed to find store names based on district.", "Join the store table with the store_district table on Store_ID to link stores with their respective districts.", "Join the resulting table with the district table on District_ID to access district names.", "Filter the results where the district name is 'Khanewal' to get only the stores located in that district."], "gold_sql": "SELECT t1.store_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t3.district_name  =  'Khanewal District'", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT s.Store_Name \nFROM store AS s \nJOIN store_district AS sd ON s.Store_ID = sd.Store_ID \nJOIN district AS d ON sd.District_ID = d.District_ID \nWHERE d.District_name = 'Khanewal';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\",\n        \"virtual_table\": \"SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of districts that have stores of a specific type, ensuring that only districts with stores of the same type are returned. The placeholders in the WHERE clause represent the type of store being queried.\",\n        \"virtual_table\": \"SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4924", "db_id": "store_product", "question": "Find the city with the most number of stores.", "rationale": ["To find the city with the most number of stores, we need to join the relevant tables: district, store_district, and store.", "We will join the store_district table with the district table to get the district names associated with each store.", "Next, we will join the store table to count the number of stores in each district.", "We will group the results by district name to aggregate the count of stores per district.", "Finally, we will order the results in descending order based on the count of stores and limit the result to 1 to get the district with the most stores."], "gold_sql": "SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id GROUP BY t3.headquartered_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["store_district", "store", "district"], "pred_sql": "SELECT d.District_name\nFROM district AS d\nJOIN store_district AS sd ON d.District_ID = sd.District_ID\nJOIN store AS s ON sd.Store_ID = s.Store_ID\nGROUP BY d.District_name\nORDER BY COUNT(s.Store_ID) DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\",\n        \"virtual_table\": \"SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of districts that have stores of a specific type, ensuring that only districts with stores of the same type are returned. The placeholders in the WHERE clause represent the type of store being queried.\",\n        \"virtual_table\": \"SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4930", "db_id": "store_product", "question": "Find products with max page size as \"A4\" and pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to filter products based on two conditions: max_page_size should be 'A4' and pages_per_minute_color should be less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table where the specified conditions are met."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' AND pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' AND pages_per_minute_color < '5';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4932", "db_id": "store_product", "question": "Find products with max page size as \"A4\" or pages per minute color smaller than 5.", "rationale": ["Identify the relevant table: The 'product' table contains the necessary columns for the query.", "Determine the conditions: We need to find products where the max page size is 'A4' or the pages per minute for color is less than 5.", "Construct the SQL query: Use a SELECT statement to retrieve all columns from the 'product' table that meet either of the specified conditions."], "gold_sql": "SELECT product FROM product WHERE max_page_size  =  'A4' OR pages_per_minute_color  <  5", "source_tables": ["product"], "pred_sql": "SELECT * FROM product WHERE max_page_size = 'A4' OR pages_per_minute_color < 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4935", "db_id": "store_product", "question": "What are all of the products whose name includes the substring \"Scanner\"?", "rationale": ["Identify the table that contains product names: the 'product' table.", "Determine the condition to filter products based on their names: we need to find products whose names include the substring 'Scanner'.", "Use the SQL LIKE operator with wildcards (%) to match any characters before and after 'Scanner'.", "Construct the SQL query using the SELECT statement to retrieve the product names that meet the condition."], "gold_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%'", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE product LIKE '%Scanner%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the names of districts that have stores of a specific type, intersecting the results for two different types of stores. The placeholders in the WHERE clause represent the types of stores being queried.\",\n        \"virtual_table\": \"SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT t3.District_name FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.Type  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4937", "db_id": "store_product", "question": "What is the most common maximum page size?", "rationale": ["Identify the column of interest: 'max_page_size' from the 'product' table.", "To find the most common maximum page size, we need to group the results by 'max_page_size'.", "Use the COUNT function to count occurrences of each 'max_page_size'.", "Order the results in descending order based on the count to get the most common size at the top.", "Limit the results to 1 to get only the most common maximum page size."], "gold_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1", "source_tables": ["product"], "pred_sql": "SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY COUNT(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4938", "db_id": "store_product", "question": "Find the name of the products that are not using the most frequently-used max page size.", "rationale": ["Identify the most frequently-used max page size by grouping the products by 'max_page_size' and counting occurrences.", "Order the results by count in descending order to find the most common max page size.", "Limit the results to 1 to get only the most frequently-used max page size.", "Select products from the 'product' table where their 'max_page_size' is not equal to the most common one identified in the subquery."], "gold_sql": "SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["product"], "pred_sql": "SELECT product FROM product WHERE max_page_size != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names or descriptions of products from the 'product' table that do not have the most common maximum page size. The placeholder in the subquery represents a numeric value used to limit the results of the maximum page size.\",\n        \"virtual_table\": \"SELECT product FROM product WHERE product != (SELECT max_page_size FROM product GROUP BY max_page_size ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.4947", "db_id": "soccer_2", "question": "How many students, on average, does each college have enrolled?", "rationale": ["The question asks for the average number of students enrolled in each college.", "To find the average enrollment, we can use the AVG() function on the 'enr' column from the 'College' table.", "We need to select the average enrollment without grouping by college since we want the overall average across all colleges.", "The final SQL query will be: SELECT AVG(enr) AS average_enrollment FROM College."], "gold_sql": "SELECT avg(enr) FROM College", "source_tables": ["college"], "pred_sql": "SELECT AVG(enr) AS average_enrollment FROM College", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the names of colleges located in a specific state that have an enrollment number either less than or greater than a specified value. The placeholders in the WHERE clauses represent the enrollment numbers and the state name.\",\n        \"virtual_table\": \"SELECT cName FROM College WHERE enr  <  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING] UNION SELECT cName FROM College WHERE enr  >  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4955", "db_id": "soccer_2", "question": "How many hours do the players train on average?", "rationale": ["The question asks for the average training hours of players.", "To calculate the average, we need to use the AVG() function in SQL.", "We assume there is a column 'training_hours' in the Player table that stores the training hours for each player.", "The SQL query will select the average of the 'training_hours' column from the Player table."], "gold_sql": "SELECT avg(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_training_hours FROM Player", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4956", "db_id": "soccer_2", "question": "Find the name and training hours of players whose hours are below 1500.", "rationale": ["Identify the relevant tables: Player table contains player information including names and hours.", "Determine the columns needed: We need the player's name (pName) and their training hours.", "Apply the condition: We need to filter players whose training hours are below 1500.", "Construct the SQL query using SELECT to retrieve the required columns from the Player table with the specified condition."], "gold_sql": "SELECT pName ,  HS FROM Player WHERE HS  <  1500", "source_tables": ["player"], "pred_sql": "SELECT pName, hours FROM Player WHERE hours < 1500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4961", "db_id": "soccer_2", "question": "What are the different types of player positions?", "rationale": ["The question asks for the different types of player positions.", "To find the unique player positions, we can use the DISTINCT keyword.", "We will select the 'pPos' column from the 'Tryout' table, which contains the player positions."], "gold_sql": "SELECT count(DISTINCT pPos) FROM tryout", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT pPos FROM Tryout", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4962", "db_id": "soccer_2", "question": "How many students got accepted after the tryout?", "rationale": ["The question asks for the number of students accepted after the tryout.", "To find this, we need to count the entries in the Tryout table where the decision is 'accepted'.", "The SQL query uses the COUNT() function to count the number of rows that meet this condition."], "gold_sql": "SELECT count(*) FROM tryout WHERE decision  =  'yes'", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(*) FROM Tryout WHERE decision = 'accepted';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.4966", "db_id": "soccer_2", "question": "Find the max, average and min training hours of all players.", "rationale": ["The task is to find the maximum, average, and minimum training hours of all players.", "Since the schema does not explicitly mention a 'training_hours' column, we assume it is a derived or calculated field based on player data.", "To calculate these statistics, we will use aggregate functions: MAX(), AVG(), and MIN().", "We will select these aggregate values from the Player table, as it contains the relevant player data."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT MAX(training_hours) AS max_hours, AVG(training_hours) AS avg_hours, MIN(training_hours) AS min_hours FROM Player", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4967", "db_id": "soccer_2", "question": "What is the average, maximum, and minimum for the number of hours spent training?", "rationale": ["The question asks for the average, maximum, and minimum hours spent training.", "To calculate these statistics, we need to use aggregate functions: AVG() for average, MAX() for maximum, and MIN() for minimum.", "We assume there is a table named 'training_data' that contains a column 'training_hours' which records the hours spent training by players.", "The SQL query will select the average, maximum, and minimum of the 'training_hours' column from the 'training_data' table."], "gold_sql": "SELECT avg(HS) ,  max(HS) ,  min(HS) FROM Player", "source_tables": ["player"], "pred_sql": "SELECT AVG(training_hours) AS average_hours, MAX(training_hours) AS max_hours, MIN(training_hours) AS min_hours FROM training_data;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    }\n}\n"}
{"sample_id": "train.4970", "db_id": "soccer_2", "question": "What are the names of players whose training hours is between 500 and 1500?", "rationale": ["Identify the relevant table: The question asks for player names, so we will focus on the Player table.", "Determine the condition: The question specifies a range for training hours (between 500 and 1500).", "Assume there is a column for training hours in the Player table, which is not explicitly mentioned in the schema provided. We will use 'training_hours' as a placeholder.", "Construct the SQL query using the SELECT statement to retrieve player names that meet the training hours condition."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE training_hours BETWEEN 500 AND 1500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4971", "db_id": "soccer_2", "question": "What are the names of players who train between 500 and 1500 hours?", "rationale": ["Identify the relevant table for player information, which is the Player table.", "Determine the criteria for filtering players based on training hours, which is between 500 and 1500 hours.", "Since the training hours are not directly available in the schema, assume that there is a way to filter players based on their tryout decisions (e.g., accepted players).", "Construct a subquery to select player IDs from the Tryout table where the decision is 'Accepted'.", "Combine the results of the subquery with the Player table to get the names of players who meet the criteria."], "gold_sql": "SELECT pName FROM Player WHERE HS BETWEEN 500 AND 1500", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player WHERE pID IN (SELECT pID FROM Tryout WHERE decision = 'Accepted') AND hours BETWEEN 500 AND 1500;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4975", "db_id": "soccer_2", "question": "What are the names and enrollment numbers for colleges that have more than 10000 enrolled and are located in Louisiana?", "rationale": ["Identify the relevant table: The 'College' table contains the necessary information about college names and enrollment numbers.", "Determine the conditions: We need colleges with an enrollment number greater than 10000 and located in Louisiana.", "Construct the SQL query: Use a SELECT statement to retrieve 'cName' and 'enr' from the 'College' table, applying the specified conditions in the WHERE clause."], "gold_sql": "SELECT cName ,  enr FROM College WHERE enr  >  10000 AND state = 'LA'", "source_tables": ["college"], "pred_sql": "SELECT cName, enr FROM College WHERE enr > 10000 AND state = 'Louisiana'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of colleges located in a specific state that have an enrollment number either less than or greater than a specified value. The placeholders in the WHERE clauses represent the enrollment numbers and the state name.\",\n        \"virtual_table\": \"SELECT cName FROM College WHERE enr  <  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING] UNION SELECT cName FROM College WHERE enr  >  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the distinct names of colleges from the 'College' table that have an enrollment number greater than the minimum enrollment number of colleges located in a specific state. The placeholder in the WHERE clause represents the state name.\",\n        \"virtual_table\": \"SELECT DISTINCT cName FROM college WHERE enr  >  (SELECT min(enr) FROM college WHERE state  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    }\n}\n"}
{"sample_id": "train.4981", "db_id": "soccer_2", "question": "What are the name of the players who received a card in descending order of the hours of training?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to select the names of players, which is in the Player table under the column 'pName'.", "The players' eligibility or card year is not directly needed for this query, but we will join the Player table with the Tryout table to access the decision made regarding their tryout.", "The join condition is based on the player ID (pID) which is common in both tables.", "To get the names of players in descending order, we will use the ORDER BY clause on the decision column from the Tryout table."], "gold_sql": "SELECT pName FROM Player WHERE yCard  =  'yes' ORDER BY HS DESC", "source_tables": ["player"], "pred_sql": "SELECT pName FROM Player JOIN Tryout ON Player.pID = Tryout.pID ORDER BY Tryout.decision DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4984", "db_id": "soccer_2", "question": "Which position is most popular among players in the tryout?", "rationale": ["To find the most popular position among players in the tryout, we need to count how many players are trying out for each position.", "We will use the COUNT function to count the number of players for each position in the Tryout table.", "We will group the results by the position (pPos) to get the count for each position.", "Finally, we will order the results in descending order based on the count and limit the results to 1 to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count FROM Tryout GROUP BY pPos ORDER BY position_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4985", "db_id": "soccer_2", "question": "What was the most popular position at tryouts?", "rationale": ["To find the most popular position at tryouts, we need to count how many players tried out for each position.", "We will use the COUNT function to count the number of occurrences of each position in the Tryout table.", "We will group the results by the position (pPos) to get the count for each position.", "To determine which position is the most popular, we will order the results in descending order based on the count.", "Finally, we will limit the results to just one entry to get the most popular position."], "gold_sql": "SELECT pPos FROM tryout GROUP BY pPos ORDER BY count(*) DESC LIMIT 1", "source_tables": ["tryout"], "pred_sql": "SELECT pPos, COUNT(*) as position_count \nFROM Tryout \nGROUP BY pPos \nORDER BY position_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4988", "db_id": "soccer_2", "question": "What is minimum hours of the students playing in different position?", "rationale": ["The question asks for the minimum hours of students playing in different positions.", "To find the minimum hours, we need to count the number of tryouts (which can be considered as hours played) for each player in each position.", "We can achieve this by grouping the tryout records by player ID and position, and counting the number of records for each group.", "Next, we need to find the minimum count of hours for each position.", "This can be done by wrapping the previous query in another SELECT statement that groups by position and uses the MIN function."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(hours) AS min_hours FROM (SELECT pPos, COUNT(*) AS hours FROM tryout GROUP BY pID, pPos) GROUP BY pPos;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.4989", "db_id": "soccer_2", "question": "For each position, what is the minimum time students spent practicing?", "rationale": ["Identify the relevant tables: We need to find the minimum time students spent practicing for each position, which suggests we need a table that records practice times and player positions.", "Assume there is a table named 'practice_sessions' that records practice times along with player positions. This table would likely have columns like 'pID', 'pPos', and 'practice_time'.", "To find the minimum practice time for each position, we can use the MIN() function in SQL.", "We will group the results by 'pPos' to get the minimum practice time for each position.", "The final SQL query will select the position and the minimum practice time from the 'practice_sessions' table, grouped by position."], "gold_sql": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pPos, MIN(practice_time) AS min_practice_time FROM practice_sessions GROUP BY pPos", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    }\n}\n"}
{"sample_id": "train.5003", "db_id": "soccer_2", "question": "What are the names and hours spent practicing of every student who received a yes at tryouts?", "rationale": ["Identify the tables involved: Player and Tryout.", "We need the names of students, which are in the Player table under the column pName.", "We also need to check the decision made during tryouts, which is in the Tryout table under the column decision.", "To get the names of students who received a 'yes' at tryouts, we will join the Player and Tryout tables on the pID column.", "The final query will select the pName from the Player table and filter results where the decision in the Tryout table is 'yes'."], "gold_sql": "SELECT T1.pName ,  T1.HS FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT Player.pName, Tryout.decision FROM Player JOIN Tryout ON Player.pID = Tryout.pID WHERE Tryout.decision = 'yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5007", "db_id": "soccer_2", "question": "What are the names of all students who successfully tried out for the position of striker?", "rationale": ["Identify the relevant tables: Player and Tryout.", "We need to find the names of students (players) who successfully tried out for a specific position, which is 'striker'.", "Join the Player table with the Tryout table on the player ID (pID) to access player names and their tryout details.", "Filter the results where the position (pPos) is 'striker' and the decision indicates a successful tryout.", "Select the player names (pName) from the filtered results."], "gold_sql": "SELECT T1.pName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes' AND T2.pPos  =  'striker'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT pName \nFROM Player AS P \nJOIN Tryout AS T ON P.pID = T.pID \nWHERE T.pPos = 'striker' AND T.decision = 'successful';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.5013", "db_id": "soccer_2", "question": "What is the average number of hours spent practicing for students who got rejected?", "rationale": ["Identify the requirement: We need to find the average number of hours spent practicing by students who got rejected.", "Determine the relevant tables: The 'practice' table (not explicitly mentioned in the schema but assumed to exist for this context) will hold the hours spent practicing, and the 'tryout' table will provide the decision status of players.", "Use a subquery to filter players who were rejected: We will select pIDs from the 'tryout' table where the decision is 'rejected'.", "Calculate the average hours: We will use the AVG function on the hours column from the 'practice' table, filtering it by the pIDs obtained from the subquery."], "gold_sql": "SELECT avg(T1.HS) FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'no'", "source_tables": ["player", "tryout"], "pred_sql": "SELECT AVG(hours) FROM practice WHERE pID IN (SELECT pID FROM tryout WHERE decision = 'rejected')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    }\n}\n"}
{"sample_id": "train.5018", "db_id": "soccer_2", "question": "Which college has any student who is a goalie and succeeded in the tryout.", "rationale": ["Identify the relevant tables: We need to look at the 'Tryout' table since it contains information about players, their positions, and the decisions made during tryouts.", "Filter for the specific position: We are interested in players who are goalies, so we will filter the results where pPos = 'goalie'.", "Filter for successful tryouts: We also need to ensure that we only consider players who succeeded in their tryouts, so we will add a condition for decision = 'succeeded'.", "Select distinct colleges: We want to know which colleges have at least one player who meets the above criteria, so we will select distinct college names (cName) from the Tryout table."], "gold_sql": "SELECT cName FROM  tryout WHERE decision  =  'yes' AND pPos  =  'goalie'", "source_tables": ["tryout"], "pred_sql": "SELECT DISTINCT cName \nFROM Tryout \nWHERE pPos = 'goalie' AND decision = 'succeeded';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.5022", "db_id": "soccer_2", "question": "What is the state and enrollment of the colleges where have any students who got accepted in the tryout decision.", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find the state and enrollment of colleges where students got accepted in the tryout decision.", "This requires a JOIN between the College and Tryout tables on the college name (cName).", "We filter the results to include only those records from Tryout where the decision is 'accepted'.", "Select the state and enrollment number from the College table."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT C.state, C.enr FROM College AS C JOIN Tryout AS T ON C.cName = T.cName WHERE T.decision = 'accepted'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5023", "db_id": "soccer_2", "question": "How many students are enrolled in colleges that have student accepted during tryouts, and in which states are those colleges?", "rationale": ["Identify the requirement: We need to find the total number of students enrolled in colleges that have accepted students during tryouts, along with the states of those colleges.", "We will use the College table to get the enrollment numbers and states.", "We need to filter the colleges based on whether they have accepted students during tryouts. This can be done by checking the Tryout table for decisions that are 'accepted'.", "To achieve this, we will create a subquery that selects distinct college names from the Tryout table where the decision is 'accepted'.", "The main query will then sum the enrollment numbers from the College table for those colleges returned by the subquery, grouping the results by state."], "gold_sql": "SELECT DISTINCT T1.state ,  T1.enr FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.decision  =  'yes'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT SUM(enr) AS total_enrollment, state FROM College WHERE cName IN (SELECT DISTINCT cName FROM Tryout WHERE decision = 'accepted') GROUP BY state;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5026", "db_id": "soccer_2", "question": "Find the names of schools that have some students playing in goalie and mid positions.", "rationale": ["Identify the positions of interest: goalie and mid.", "Use the INTERSECT operator to find colleges that have players trying out for both positions.", "Construct the SQL query to select the college names (cName) from the Tryout table where the position (pPos) is 'goalie' and intersect it with another selection from the same table where the position is 'mid'."], "gold_sql": "SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid'", "source_tables": ["tryout"], "pred_sql": "SELECT cName FROM tryout WHERE pPos = 'goalie' INTERSECT SELECT cName FROM tryout WHERE pPos = 'mid'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.5028", "db_id": "soccer_2", "question": "Find the names of states that have some college students playing in goalie and mid positions.", "rationale": ["Identify the relevant tables: College and Tryout.", "We need to find states where colleges have students trying out for specific positions: goalie and mid.", "Use a JOIN operation to connect the College and Tryout tables based on the college name (cName).", "Filter the results by the positions using the IN clause to include both 'goalie' and 'mid'.", "Select distinct states to avoid duplicates in the results."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT DISTINCT T1.state FROM College AS T1 JOIN Tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos IN ('goalie', 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    }\n}\n"}
{"sample_id": "train.5029", "db_id": "soccer_2", "question": "What are the names of the states that have some college students playing in the positions of goalie and mid-field?", "rationale": ["Identify the positions of interest: goalie and mid-field.", "Use the provided virtual table structure to find colleges hosting tryouts for the position of goalie.", "Use the provided virtual table structure to find colleges hosting tryouts for the position of mid-field.", "Combine the results of both queries using INTERSECT to find states that have colleges with players trying out for both positions.", "Join the College and Tryout tables on the college name to get the corresponding states for the colleges that hosted tryouts for both positions."], "gold_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid'", "source_tables": ["tryout", "college"], "pred_sql": "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos = 'goalie' INTERSECT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos = 'mid-field'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    }\n}\n"}
{"sample_id": "train.5030", "db_id": "soccer_2", "question": "How many schools have some students playing in goalie and mid positions.", "rationale": ["Identify the positions of interest: goalie and mid.", "Use the 'tryout' table to find colleges where players are trying out for these positions.", "Filter the results to include only those colleges that have players in either goalie or mid positions.", "Count the distinct colleges that meet the criteria."], "gold_sql": "SELECT COUNT(*) FROM (SELECT cName FROM  tryout WHERE pPos  =  'goalie' INTERSECT SELECT cName FROM  tryout WHERE pPos  =  'mid')", "source_tables": ["tryout"], "pred_sql": "SELECT COUNT(DISTINCT cName) FROM tryout WHERE pPos IN ('goalie', 'mid')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school identifier.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the maximum high school attended by players grouped by their position during tryouts. The placeholder in the WHERE clause represents a numeric value that filters players based on their high school attendance ranking.\",\n        \"virtual_table\": \"SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T2.pPos\"\n    }\n}\n"}
{"sample_id": "train.5037", "db_id": "soccer_2", "question": "What is the count of states with college students playing in the mid position but not as goalies?", "rationale": ["Identify the states where colleges have students trying out for the 'mid' position.", "Use a JOIN between the College and Tryout tables to filter by the 'mid' position.", "Use the EXCEPT clause to exclude states where colleges have students trying out for the 'goalie' position.", "Count the distinct states that remain after the exclusion."], "gold_sql": "SELECT COUNT(*) FROM (SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'mid' EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  'goalie')", "source_tables": ["tryout", "college"], "pred_sql": "SELECT COUNT(DISTINCT T1.state) FROM college AS T1 JOIN tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos = 'mid' EXCEPT SELECT DISTINCT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName = T2.cName WHERE T2.pPos = 'goalie';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names of colleges where players are trying out for two specific positions. The placeholders in the query represent the positions for which the players are trying out, allowing users to specify different positions to find common colleges for those tryouts.\",\n        \"virtual_table\": \"SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT cName FROM  tryout WHERE pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of states where colleges are located, specifically focusing on the states of colleges that have hosted tryouts for a particular position. The query uses a JOIN operation to connect the 'College' and 'Tryout' tables based on the college name, filtering the results by the player's position. The EXCEPT clause is used to exclude states from the second selection that also hosted tryouts for the same position, ensuring that only unique states are returned.\",\n        \"virtual_table\": \"SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName WHERE T2.pPos  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    }\n}\n"}
{"sample_id": "train.5039", "db_id": "soccer_2", "question": "What are the states with colleges that have enrollments less than the some other college?", "rationale": ["Identify the requirement: We need to find states with colleges that have enrollments less than some other college.", "Use the second virtual table provided in the hint, which summarizes the minimum enrollment numbers of colleges grouped by their respective states.", "To find states with colleges having enrollments less than the minimum enrollment, we can use a subquery to get the minimum enrollment from the College table.", "The final SQL query selects distinct states from the College table where the enrollment number is less than the minimum enrollment number found in the subquery."], "gold_sql": "SELECT DISTINCT state FROM college WHERE enr  <  (SELECT max(enr) FROM college)", "source_tables": ["college"], "pred_sql": "SELECT DISTINCT state FROM College WHERE enr < (SELECT MIN(enr) FROM College)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of colleges located in a specific state that have an enrollment number either less than or greater than a specified value. The placeholders in the WHERE clauses represent the enrollment numbers and the state name.\",\n        \"virtual_table\": \"SELECT cName FROM College WHERE enr  <  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING] UNION SELECT cName FROM College WHERE enr  >  [PLACEHOLDER-TYPE:NUMBER] AND state = [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the minimum enrollment numbers of colleges grouped by their respective states. The placeholder in the SELECT statement represents the college's name, state, and the minimum enrollment number.\",\n        \"virtual_table\": \"SELECT cName ,  state ,  min(enr) FROM college GROUP BY state\"\n    }\n}\n"}
{"sample_id": "train.5102", "db_id": "cre_Drama_Workshop_Groups", "question": "Show the minimum, average, maximum order quantity of all invoices.", "rationale": ["Identify the relevant table: The task requires information about invoices, specifically the order quantities, which are found in the Invoice_Items table.", "Determine the required calculations: We need to calculate the minimum, average, and maximum order quantity of all invoices.", "Construct the SQL query: Use the SELECT statement to retrieve the minimum, average, and maximum values of the Order_Quantity column from the Invoice_Items table."], "gold_sql": "SELECT min(Order_Quantity) ,  avg(Order_Quantity) ,  max(Order_Quantity) FROM INVOICES", "source_tables": ["invoices"], "pred_sql": "SELECT MIN(Order_Quantity) AS Min_Quantity, AVG(Order_Quantity) AS Avg_Quantity, MAX(Order_Quantity) AS Max_Quantity\nFROM Invoice_Items;", "hint": "\n"}
{"sample_id": "train.5118", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the payment method code used by the most orders?", "rationale": ["Identify the relevant table: Invoices contains the payment_method_code and Order_ID.", "Group the results by payment_method_code to count how many orders are associated with each payment method.", "Order the results in descending order based on the count of Order_ID to find the most used payment method.", "Limit the results to 1 to get only the top payment method code."], "gold_sql": "SELECT payment_method_code FROM INVOICES GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["invoices"], "pred_sql": "SELECT payment_method_code\nFROM Invoices\nGROUP BY payment_method_code\nORDER BY COUNT(Order_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5127", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the descriptions of the service types that cost more than 100.", "rationale": ["Identify the relevant tables: Ref_Service_Types and Services are needed to get service type descriptions and their associated prices.", "Join the two tables on the Service_Type_Code to link service descriptions with their prices.", "Filter the results to only include services where the Product_Price is greater than 100."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Price  >  100", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT T1.Service_Type_Description \nFROM Ref_Service_Types AS T1 \nJOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code \nWHERE T2.Product_Price > 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the descriptions of service types associated with a specific product name from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders represent the product name that the user can specify to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5134", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of workshop groups in which services with product name \"film\" are performed?", "rationale": ["Identify the relevant tables: Drama_Workshop_Groups and Services.", "Determine the relationship between the tables: Drama_Workshop_Groups is linked to Services through Workshop_Group_ID.", "Filter the Services table for entries where Product_Name is 'film'.", "Select the Store_Name from Drama_Workshop_Groups that corresponds to the filtered services."], "gold_sql": "SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "drama_workshop_groups"], "pred_sql": "SELECT T1.Store_Name FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID = T2.Workshop_Group_ID WHERE T2.Product_Name = 'film'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table retrieves the descriptions of service types associated with a specific product name from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders represent the product name that the user can specify to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5142", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the order details of the products with price higher than 2000?", "rationale": ["Identify the relevant tables: We need to look at the 'Order_Items' table for order details and the 'Products' table for product prices.", "Determine the columns needed: We want order item ID, order ID, product ID, order quantity from 'Order_Items', and product name and price from 'Products'.", "Establish the relationship between tables: 'Order_Items' has a foreign key 'Product_ID' that links to 'Products'.", "Filter the results: We need to include only those products where the price is greater than 2000.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses to retrieve the desired information."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_Items.Order_Item_ID, Order_Items.Order_ID, Order_Items.Product_ID, Order_Items.Order_Quantity, Products.Product_Name, Products.Product_Price \nFROM Order_Items \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nWHERE Products.Product_Price > 2000;", "hint": "\n"}
{"sample_id": "train.5143", "db_id": "cre_Drama_Workshop_Groups", "question": "Find the order detail for the products with price above 2000.", "rationale": ["Identify the relevant tables: We need to look at the 'Order_Items' table for order details and the 'Products' table for product prices.", "Determine the columns needed: We want to retrieve order item ID, order ID, product ID, order quantity, product name, and product price.", "Join the tables: We need to join 'Order_Items' with 'Products' on the 'Product_ID' to access product details related to each order item.", "Apply the filter: We need to filter the results to include only those products with a price greater than 2000."], "gold_sql": "SELECT T1.Other_Item_Details FROM ORDER_ITEMS AS T1 JOIN Products AS T2 ON T1.Product_ID  =  T2.Product_ID WHERE T2.Product_price  >  2000", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Order_Items.Order_Item_ID, Order_Items.Order_ID, Order_Items.Product_ID, Order_Items.Order_Quantity, Products.Product_Name, Products.Product_Price \nFROM Order_Items \nJOIN Products ON Order_Items.Product_ID = Products.Product_ID \nWHERE Products.Product_Price > 2000;", "hint": "\n"}
{"sample_id": "train.5160", "db_id": "cre_Drama_Workshop_Groups", "question": "What is the most frequent status of bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most frequent status of bookings, which means we need to count occurrences of each status code.", "Use the COUNT function: We will count how many times each 'Status_Code' appears in the 'Bookings' table.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each status.", "Order the results: To find the most frequent status, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most frequent status, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Frequency\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Frequency DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5161", "db_id": "cre_Drama_Workshop_Groups", "question": "Which status code is the most common of all the bookings?", "rationale": ["Identify the relevant table: The question pertains to bookings, so we will use the 'Bookings' table.", "Determine the required information: We need to find the most common status code, which implies counting occurrences of each status code.", "Use the COUNT function: We will count how many times each status code appears in the 'Bookings' table.", "Group the results: We will group the results by 'Status_Code' to aggregate the counts for each unique status code.", "Order the results: To find the most common status code, we will order the results in descending order based on the count.", "Limit the results: Since we only want the most common status code, we will limit the results to 1."], "gold_sql": "SELECT Status_Code FROM BOOKINGS GROUP BY Status_Code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["bookings"], "pred_sql": "SELECT Status_Code, COUNT(*) as Count\nFROM Bookings\nGROUP BY Status_Code\nORDER BY Count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5162", "db_id": "cre_Drama_Workshop_Groups", "question": "What are the names of the workshop groups that have bookings with status code \"stop\"?", "rationale": ["Identify the relevant tables: We need to find workshop groups and their bookings, so we will use the Drama_Workshop_Groups and Bookings tables.", "Determine the relationship: The Drama_Workshop_Groups table is linked to the Bookings table through the Workshop_Group_ID.", "Specify the condition: We are interested in bookings with a status code of 'stop'.", "Select the desired output: We want the names of the workshop groups, which can be found in the Store_Name column of the Drama_Workshop_Groups table."], "gold_sql": "SELECT T2.Store_Name FROM Bookings AS T1 JOIN Drama_Workshop_Groups AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T1.Status_Code  =  'stop'", "source_tables": ["drama_workshop_groups", "bookings"], "pred_sql": "SELECT DW.Store_Name \nFROM Drama_Workshop_Groups AS DW \nJOIN Bookings AS B ON DW.Workshop_Group_ID = B.Workshop_Group_ID \nWHERE B.Status_Code = 'stop';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5171", "db_id": "cre_Drama_Workshop_Groups", "question": "Give me the description of the service type that offers not only the photo product but also the film product.", "rationale": ["Identify the tables involved: Ref_Service_Types and Services.", "Determine the relationship between the tables: Ref_Service_Types is linked to Services via Service_Type_Code.", "Use the provided hint to create a virtual table that retrieves service type descriptions based on product names.", "The query needs to find service types that offer both 'photo' and 'film' products, which can be achieved using the INTERSECT operator to ensure both conditions are met.", "Construct the SQL query using the structure from the hint, replacing the placeholders with 'photo' and 'film' respectively."], "gold_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  'film'", "source_tables": ["services", "ref_service_types"], "pred_sql": "SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code WHERE T2.Product_Name = 'photo' INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code = T2.Service_Type_Code WHERE T2.Product_Name = 'film'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the descriptions of service types associated with a specific product name from the 'Services' table, ensuring that the same product name is used in both parts of the query. The placeholders represent the product name that the user can specify to filter the results accordingly.\",\n        \"virtual_table\": \"SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Service_Type_Description FROM Ref_Service_Types AS T1 JOIN Services AS T2 ON T1.Service_Type_Code  =  T2.Service_Type_Code WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the phone number and email address of stores associated with specific drama workshop groups that offer a particular product. The placeholder in the WHERE clause represents the name of the product being queried.\",\n        \"virtual_table\": \"SELECT T1.Store_Phone ,  T1.Store_Email_Address FROM Drama_Workshop_Groups AS T1 JOIN Services AS T2 ON T1.Workshop_Group_ID  =  T2.Workshop_Group_ID WHERE T2.Product_Name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5459", "db_id": "voter_2", "question": "Find the average age of female students.", "rationale": ["Identify the table that contains the age of students, which is the 'Student' table.", "Determine the condition needed to filter for female students, which is 'Sex = 'Female' '.", "Use the AVG() function to calculate the average age of the filtered results.", "Construct the SQL query to select the average age from the 'Student' table where the sex is female."], "gold_sql": "SELECT avg(Age) FROM STUDENT WHERE Sex  =  'F'", "source_tables": ["student"], "pred_sql": "SELECT AVG(Age) AS Average_Age FROM Student WHERE Sex = 'Female';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5466", "db_id": "voter_2", "question": "What are the distinct president votes on 08/30/2015?", "rationale": ["Identify the relevant tables: We need to look at the Student and Voting_record tables to find the president votes.", "Determine the columns needed: We need the distinct president votes, which are in the Voting_record table under the column President_Vote.", "Join the tables: We will join the Student table with the Voting_record table on the StuID column, which is common to both tables.", "Filter by date: We need to filter the results to only include records where the Registration_Date is '2015-08-30'.", "Use DISTINCT: Since we want distinct president votes, we will use the DISTINCT keyword in our SELECT statement."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT T1.President_Vote FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.StuID WHERE T2.Registration_Date = '2015-08-30'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5467", "db_id": "voter_2", "question": "Show all the distinct president votes made on 08/30/2015.", "rationale": ["Identify the tables involved: We need to retrieve data from the Student and Voting_record tables.", "Determine the relevant columns: We want distinct president votes, which means we will focus on the President_Vote column in the Voting_record table and the StuID from the Student table.", "Join the tables: We will join the Student table with the Voting_record table on the StuID, which is common in both tables.", "Filter by date: We need to filter the results to only include records where the Registration_Date is '08/30/2015'.", "Select distinct values: Since we want distinct president votes, we will use the DISTINCT keyword in our SELECT statement."], "gold_sql": "SELECT DISTINCT PRESIDENT_Vote FROM VOTING_RECORD WHERE Registration_Date  =  '08/30/2015'", "source_tables": ["voting_record"], "pred_sql": "SELECT DISTINCT T1.StuID FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.President_Vote WHERE T2.Registration_Date = '08/30/2015'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5476", "db_id": "voter_2", "question": "Find the distinct ages of students who have secretary votes in the fall election cycle.", "rationale": ["Identify the relevant tables: We need to use the 'Student' table to get student ages and the 'Voting_record' table to check for secretary votes.", "Join the two tables on the StuID column since it is the common identifier for students in both tables.", "Filter the results to only include records from the fall election cycle by checking the 'Election_Cycle' column in the Voting_record table.", "Additionally, we need to ensure that we only consider students who have cast a vote for secretary, which can be checked by ensuring 'Secretary_Vote' is not null.", "Select distinct ages from the filtered results to avoid duplicates."], "gold_sql": "SELECT DISTINCT T1.Age FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Secretary_Vote WHERE T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT S.Age \nFROM Student AS S \nJOIN Voting_record AS V ON S.StuID = V.StuID \nWHERE V.Election_Cycle = 'fall' AND V.Secretary_Vote IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5479", "db_id": "voter_2", "question": "Who served as an advisor for students who have treasurer votes in the spring election cycle?", "rationale": ["Identify the relevant tables: We need to look at the Student table for advisors and the Voting_record table for voting information.", "Determine the condition: We want to find students who have treasurer votes in the spring election cycle.", "Use a subquery: We will create a subquery to select the StuID of students who voted for treasurer in the specified election cycle.", "Join the results: We will then use this list of StuIDs to filter the Student table to get the advisors for these students."], "gold_sql": "SELECT DISTINCT T1.Advisor FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.Treasurer_Vote WHERE T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT Advisor FROM Student WHERE StuID IN (SELECT StuID FROM Voting_record WHERE Treasurer_Vote IS NOT NULL AND Election_Cycle = 'spring')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5486", "db_id": "voter_2", "question": "How many male (sex is M) students have class senator votes in the fall election cycle?", "rationale": ["Identify the tables involved: We need to use the 'Student' table to filter by gender and the 'Voting_record' table to check for class senator votes.", "Determine the condition for male students: We will filter the 'Sex' column in the 'Student' table for 'M'.", "Identify the voting record for class senator: We will join the 'Student' table with the 'Voting_record' table on the 'StuID' and 'Class_Senator_Vote' columns.", "Specify the election cycle: We need to filter the records for the fall election cycle in the 'Voting_record' table.", "Count the number of male students who meet these criteria: We will use COUNT(*) to get the total number of records that match our conditions."], "gold_sql": "SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.Sex  =  'M' AND T2.Election_Cycle  =  'Fall'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT COUNT(*) FROM Student AS S JOIN Voting_record AS V ON S.StuID = V.Class_Senator_Vote WHERE S.Sex = 'M' AND V.Election_Cycle = 'fall';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first and last names of students from the 'Student' table who have voted for a presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5491", "db_id": "voter_2", "question": "What is the average age of students who have city code \"NYC\" and have secretary votes for the spring election cycle?", "rationale": ["Identify the tables involved: We need data from the 'Student' table for student details and the 'Voting_record' table for voting details.", "Determine the conditions: We are looking for students with a city code of 'NYC', who have voted in the spring election cycle, and specifically have a record for secretary votes.", "Calculate the average age: We need to compute the average age of the filtered students, which requires casting the 'Age' column to an integer for accurate calculation.", "Join the tables: We will join the 'Student' table with the 'Voting_record' table on the StuID to correlate students with their voting records.", "Construct the SQL query: Using the identified conditions and calculations, we will construct the SQL query to retrieve the average age."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.city_code  =  'NYC' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(CAST(Age AS INTEGER)) AS Average_Age \nFROM Student AS S \nJOIN Voting_record AS V ON S.StuID = V.StuID \nWHERE S.city_code = 'NYC' \nAND V.Election_Cycle = 'spring' \nAND V.Secretary_Vote IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5492", "db_id": "voter_2", "question": "Find the average age of female (sex is F) students who have secretary votes in the spring election cycle.", "rationale": ["Identify the tables involved: We need data from the Student table and the Voting_record table.", "Determine the columns needed: We need the Age from the Student table and we want to calculate the average age of female students who have voted for secretary.", "Filter conditions: We need to filter for female students (Sex = 'F') and those who have participated in the spring election cycle and have a non-null Secretary_Vote.", "Join the tables: We will join the Student table with the Voting_record table on StuID to correlate students with their voting records.", "Calculate the average age: Use the AVG function on the Age column, ensuring to cast it to an integer for accurate calculation."], "gold_sql": "SELECT avg(T1.Age) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  SECRETARY_Vote WHERE T1.Sex  =  'F' AND T2.Election_Cycle  =  'Spring'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT AVG(CAST(Age AS INTEGER)) AS Average_Age \nFROM Student AS S \nJOIN Voting_record AS V ON S.StuID = V.StuID \nWHERE S.Sex = 'F' \nAND V.Election_Cycle = 'spring' \nAND V.Secretary_Vote IS NOT NULL;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5494", "db_id": "voter_2", "question": "Find the distinct first names of all the students who have vice president votes and whose city code is not PIT.", "rationale": ["Identify the tables involved: We need to retrieve data from the Student and Voting_record tables.", "Determine the columns needed: We need distinct first names (Fname) from the Student table.", "Establish the join condition: We will join the Student table with the Voting_record table on the StuID and Vice_President_Vote columns.", "Add the filtering condition: We need to filter out students whose city_code is 'PIT'.", "Construct the SQL query using SELECT DISTINCT to ensure unique first names are returned."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT T1.Fname FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.Vice_President_Vote WHERE T1.city_code != 'PIT'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5495", "db_id": "voter_2", "question": "What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?", "rationale": ["Identify the relevant tables: We need to retrieve data from the Student and Voting_record tables.", "Determine the columns needed: We want distinct first names of students, so we will select T1.Fname.", "Establish the join condition: We need to join the Student table (T1) with the Voting_record table (T2) on the condition that the StuID in Student matches the Vice_President_Vote in Voting_record.", "Add the filtering condition: We need to filter out students whose city_code is 'PIT'.", "Construct the SQL query using the SELECT statement with DISTINCT to ensure unique first names are returned."], "gold_sql": "SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  'PIT'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT T1.Fname \nFROM Student AS T1 \nJOIN Voting_record AS T2 ON T1.StuID = T2.Vice_President_Vote \nWHERE T1.city_code != 'PIT';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5496", "db_id": "voter_2", "question": "Find the distinct last names of all the students who have president votes and whose advisor is not 2192.", "rationale": ["Identify the relevant tables: Student and Voting_record.", "We need to find distinct last names of students, so we will use SELECT DISTINCT on the LName column from the Student table.", "We need to join the Student table with the Voting_record table to access the voting information, specifically the President_Vote column.", "The join condition will be on the StuID from the Student table and the President_Vote from the Voting_record table.", "We need to filter out students whose advisor is '2192', so we will add a WHERE clause to exclude these records."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '2192'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT T1.LName FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.President_Vote WHERE T1.Advisor != '2192'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5499", "db_id": "voter_2", "question": "What are the distinct last names of the students who have president votes and have 8741 as the advisor?", "rationale": ["Identify the relevant tables: Student and Voting_record.", "We need to find distinct last names of students who voted for a presidential candidate, which involves joining the Student table with the Voting_record table on the StuID and President_Vote columns.", "We need to filter the results to only include students whose advisor is '8741'.", "The final SQL query selects distinct last names from the joined tables with the specified conditions."], "gold_sql": "SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  '8741'", "source_tables": ["student", "voting_record"], "pred_sql": "SELECT DISTINCT T1.LName FROM Student AS T1 JOIN Voting_record AS T2 ON T1.StuID = T2.President_Vote WHERE T1.Advisor = '8741'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique last names of students who voted for a presidential candidate, excluding those who have a specific academic advisor. The placeholders in the query represent the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote EXCEPT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the distinct first and last names of students who have voted for the vice president, filtered by a specific age. The placeholders in the query allow for dynamic input of the age value.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_President_VOTE WHERE T1.age  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5510", "db_id": "voter_2", "question": "What is the most common major among female (sex is F) students?", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter for female students: We need to include a condition to filter the results where the 'Sex' column is 'F'.", "Count occurrences of each major: We will use the COUNT function to count how many female students are in each major.", "Group by major: To get the count of female students per major, we will use the GROUP BY clause on the 'Major' column.", "Order by count in descending order: To find the most common major, we will order the results by the count of students in descending order.", "Limit the results to one: Since we only want the most common major, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as MajorCount \nFROM Student \nWHERE Sex = 'F' \nGROUP BY Major \nORDER BY MajorCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first and last names of students from the 'Student' table who have voted for a presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5511", "db_id": "voter_2", "question": "Find the major that is studied by the most female students.", "rationale": ["Identify the relevant table: The 'Student' table contains information about students, including their major and gender.", "Filter for female students: We need to count only female students, so we will add a WHERE clause to filter by Sex = 'Female'.", "Group by major: To find out how many female students are studying each major, we will use GROUP BY on the Major column.", "Count the number of female students per major: We will use COUNT(*) to count the number of female students in each major.", "Order the results: To find the major with the most female students, we will order the results in descending order based on the count.", "Limit the results: Since we only want the major with the most female students, we will limit the results to 1."], "gold_sql": "SELECT Major FROM STUDENT WHERE Sex  =  'F' GROUP BY major ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student"], "pred_sql": "SELECT Major, COUNT(*) as FemaleCount \nFROM Student \nWHERE Sex = 'Female' \nGROUP BY Major \nORDER BY FemaleCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first and last names of students who voted for the presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first and last names of students from the 'Student' table who have voted for a presidential candidate, filtered by their gender. The placeholder in the WHERE clause represents the gender of the students.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Fname ,  T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.President_VOTE WHERE T1.sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of students who have voted for a presidential candidate and are being advised by a specific academic advisor. The placeholder in the WHERE clause represents the advisor's name.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.LName FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  PRESIDENT_Vote INTERSECT SELECT DISTINCT LName FROM STUDENT WHERE Advisor  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5534", "db_id": "products_gen_characteristics", "question": "Find the number of products with category \"Spices\" and typically sold above 1000.", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the condition for product category: We need to find the product category code for 'Spices'.", "Use a subquery to get the product_category_code from Ref_Product_Categories where the description is 'Spices'.", "Set the condition for typical selling price to be greater than 1000.", "Combine these conditions in a SELECT statement to count the number of products that meet both criteria."], "gold_sql": "SELECT count(*) FROM products WHERE product_category_code  =  'Spices' AND typical_buying_price  >  1000", "source_tables": ["products"], "pred_sql": "SELECT count(*) FROM Products WHERE product_category_code = (SELECT product_category_code FROM Ref_Product_Categories WHERE product_category_description = 'Spices') AND typical_selling_price > 1000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5543", "db_id": "products_gen_characteristics", "question": "What are the descriptions of the categories that products with product descriptions that contain the letter t are in?", "rationale": ["Identify the relevant tables: We need to get product category descriptions, which are in the Ref_Product_Categories table, and we need to filter products based on their descriptions, which are in the Products table.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to access the category descriptions for each product.", "Use a WHERE clause to filter products whose descriptions contain the letter 't'. This can be done using the LIKE operator with a wildcard.", "Select distinct product category descriptions to avoid duplicates in the results."], "gold_sql": "SELECT T1.product_category_description FROM ref_product_categories AS T1 JOIN products AS T2 ON T1.product_category_code  =  T2.product_category_code WHERE T2.product_description LIKE '%t%'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT DISTINCT rpc.product_category_description \nFROM Products p \nJOIN Ref_Product_Categories rpc ON p.product_category_code = rpc.product_category_code \nWHERE p.product_description LIKE '%t%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n        \"virtual_table\": \"SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5556", "db_id": "products_gen_characteristics", "question": "How many distinct characteristic names does the product \"cumin\" have?", "rationale": ["Identify the relevant tables: Products, Product_Characteristics, and Characteristics are needed to find the distinct characteristic names for the product 'cumin'.", "Join the Products table with Product_Characteristics on product_id to link products with their characteristics.", "Join the resulting table with Characteristics on characteristic_id to access the characteristic names.", "Filter the results to only include the product where the product_name is 'cumin'.", "Use COUNT(DISTINCT c.characteristic_name) to count the number of unique characteristic names associated with the product 'cumin'."], "gold_sql": "SELECT count(DISTINCT t3.characteristic_name) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  'sesame'", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(DISTINCT c.characteristic_name) AS distinct_characteristic_names\nFROM Products p\nJOIN Product_Characteristics pc ON p.product_id = pc.product_id\nJOIN Characteristics c ON pc.characteristic_id = c.characteristic_id\nWHERE p.product_name = 'cumin';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n        \"virtual_table\": \"SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5577", "db_id": "products_gen_characteristics", "question": "How many products have their color described as 'white' or have a characteristic with the name 'hot'?", "rationale": ["Identify the tables involved: Products, Ref_Colors, Product_Characteristics, and Characteristics.", "We need to count products that either have a color described as 'white' or have a characteristic with the name 'hot'.", "Join the Products table with the Ref_Colors table to filter by color description.", "Join the Products table with the Product_Characteristics table to access characteristics of each product.", "Join the Product_Characteristics table with the Characteristics table to filter by characteristic name.", "Use a WHERE clause to specify the conditions for color description and characteristic name.", "Use COUNT(*) to get the total number of products that meet either condition."], "gold_sql": "SELECT count(*) FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id JOIN ref_colors AS t4 ON t1.color_code  =  t4.color_code WHERE t4.color_description  =  'white' OR t3.characteristic_name  =  'hot'", "source_tables": ["products", "ref_colors", "characteristics", "product_characteristics"], "pred_sql": "SELECT COUNT(*) FROM Products p JOIN Ref_Colors c ON p.color_code = c.color_code JOIN Product_Characteristics pc ON p.product_id = pc.product_id JOIN Characteristics ch ON pc.characteristic_id = ch.characteristic_id WHERE c.color_description = 'white' OR ch.characteristic_name = 'hot';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n        \"virtual_table\": \"SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5579", "db_id": "products_gen_characteristics", "question": "Return the unit of measure for 'Herb' products.", "rationale": ["Identify the relevant tables: We need to find the unit of measure for 'Herb' products, which involves the Products table and the Ref_Product_Categories table.", "Join the Products table with the Ref_Product_Categories table on the product_category_code to access the unit_of_measure.", "Filter the results to only include products that have 'Herb' in their product name using a LIKE clause.", "Select the unit_of_measure from the Ref_Product_Categories table."], "gold_sql": "SELECT unit_of_measure FROM ref_product_categories WHERE product_category_code  =  'Herbs'", "source_tables": ["ref_product_categories"], "pred_sql": "SELECT t2.unit_of_measure FROM Ref_Product_Categories AS t2 JOIN Products AS t1 ON t1.product_category_code = t2.product_category_code WHERE t1.product_name LIKE '%Herb%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n        \"virtual_table\": \"SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5586", "db_id": "products_gen_characteristics", "question": "Find the unit of measurement and product category code of product named \"chervil\".", "rationale": ["Identify the relevant tables: Products and Ref_Product_Categories.", "Determine the columns needed: product_category_code and unit_of_measure from Ref_Product_Categories.", "Establish the relationship between Products and Ref_Product_Categories using the product_category_code.", "Filter the results based on the product name 'chervil'.", "Construct the SQL query to select the required columns with the appropriate JOIN and WHERE clause."], "gold_sql": "SELECT t2.unit_of_measure ,  t2.product_category_code FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code WHERE t1.product_name  =  'chervil'", "source_tables": ["products", "ref_product_categories"], "pred_sql": "SELECT rpc.product_category_code, rpc.unit_of_measure \nFROM Products AS p \nJOIN Ref_Product_Categories AS rpc ON p.product_category_code = rpc.product_category_code \nWHERE p.product_name = 'chervil';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n        \"virtual_table\": \"SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5590", "db_id": "products_gen_characteristics", "question": "What is the description of the color for most products?", "rationale": ["We need to find the description of the color for most products.", "To do this, we will join the Products table with the Ref_Colors table on the color_code.", "We will group the results by color_description to count how many products are associated with each color.", "We will use COUNT(*) to count the number of products for each color.", "Finally, we will order the results in descending order based on the product count and limit the result to 1 to get the color with the most products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT color_description, COUNT(*) as product_count FROM Products AS p JOIN Ref_Colors AS c ON p.color_code = c.color_code GROUP BY c.color_description ORDER BY product_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n        \"virtual_table\": \"SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5592", "db_id": "products_gen_characteristics", "question": "What is the description of the color used by least products?", "rationale": ["Identify the relevant tables: We need to look at the 'Ref_Colors' table for color descriptions and the 'Products' table to find out how many products are associated with each color.", "Join the 'Ref_Colors' table with the 'Products' table on the 'color_code' to link colors with their respective products.", "Group the results by 'color_code' to count how many products are associated with each color.", "Order the results by the count of products in ascending order to find the color used by the least products.", "Limit the results to 1 to get only the color with the least number of associated products."], "gold_sql": "SELECT t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code GROUP BY t2.color_description ORDER BY count(*) ASC LIMIT 1", "source_tables": ["products", "ref_colors"], "pred_sql": "SELECT rc.color_description\nFROM Ref_Colors rc\nJOIN Products p ON rc.color_code = p.color_code\nGROUP BY rc.color_code\nORDER BY COUNT(p.product_id) ASC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n        \"virtual_table\": \"SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5599", "db_id": "products_gen_characteristics", "question": "Give the names of characteristics that are in two or more products?", "rationale": ["We need to find the names of characteristics that are associated with two or more products.", "To do this, we will join the 'Characteristics' table with the 'Product_Characteristics' table on the 'characteristic_id'.", "Next, we will group the results by 'characteristic_name' to aggregate the data for each characteristic.", "We will use the HAVING clause to filter the groups, ensuring that we only include those characteristics that are linked to two or more distinct products (using COUNT(DISTINCT pc.product_id))."], "gold_sql": "SELECT t3.characteristic_name FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id GROUP BY t3.characteristic_name HAVING count(*)  >= 2", "source_tables": ["products", "characteristics", "product_characteristics"], "pred_sql": "SELECT c.characteristic_name \nFROM Characteristics AS c \nJOIN Product_Characteristics AS pc ON c.characteristic_id = pc.characteristic_id \nGROUP BY c.characteristic_name \nHAVING COUNT(DISTINCT pc.product_id) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of products from the 'Products' table that are associated with a specific color and do not belong to a certain unit of measure. The placeholders in the WHERE clause represent the color description and the unit of measure respectively.\",\n        \"virtual_table\": \"SELECT t1.product_name FROM products AS t1 JOIN ref_product_categories AS t2 ON t1.product_category_code  =  t2.product_category_code JOIN ref_colors AS t3 ON t1.color_code  =  t3.color_code WHERE t3.color_description  =  [PLACEHOLDER-TYPE:STRING] AND t2.unit_of_measure != [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of products from the 'Products' table that belong to a specific product category and have a typical buying price above a certain threshold. The placeholders in the WHERE clause represent the product category code and the minimum buying price.\",\n        \"virtual_table\": \"SELECT count(*) FROM products WHERE product_category_code  =  [PLACEHOLDER-TYPE:STRING] AND typical_buying_price  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5633", "db_id": "railway", "question": "List the builders of railways in ascending alphabetical order.", "rationale": ["Identify the relevant table: The 'railway' table contains the 'Builder' column which we need to query.", "Select the 'Builder' column: We want to list the builders, so we will select this column.", "Use DISTINCT to avoid duplicate entries: Since multiple railways can have the same builder, we will use DISTINCT to ensure each builder is listed only once.", "Order the results: We need the results in ascending alphabetical order, so we will use ORDER BY Builder ASC.", "Construct the SQL query: Combine all these elements into a complete SQL query."], "gold_sql": "SELECT Builder FROM railway ORDER BY Builder ASC", "source_tables": ["railway"], "pred_sql": "SELECT DISTINCT Builder FROM railway ORDER BY Builder ASC;", "hint": "\n"}
{"sample_id": "train.5643", "db_id": "railway", "question": "Show the id and builder of the railway that are associated with the most trains.", "rationale": ["Identify the relevant tables: 'railway' and 'train'.", "We need to find the railway associated with the most trains, so we will join the 'railway' table with the 'train' table on 'Railway_ID'.", "We will group the results by 'Railway_ID' and 'Builder' to count the number of trains associated with each railway.", "Use COUNT(train.Train_ID) to count the number of trains for each railway.", "Order the results in descending order based on the count of trains to get the railway with the most trains at the top.", "Limit the results to 1 to get only the railway associated with the most trains."], "gold_sql": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["train", "railway"], "pred_sql": "SELECT railway.Railway_ID, railway.Builder\nFROM railway\nJOIN train ON railway.Railway_ID = train.Railway_ID\nGROUP BY railway.Railway_ID, railway.Builder\nORDER BY COUNT(train.Train_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5645", "db_id": "railway", "question": "Show the most common builder of railways.", "rationale": ["We need to find the most common builder of railways, which means we will be counting how many railways each builder has constructed.", "To do this, we will select the 'Builder' column from the 'railway' table and count the occurrences of each builder using COUNT(*).", "We will group the results by 'Builder' to aggregate the counts for each unique builder.", "Next, we will order the results in descending order based on the count of railways built by each builder, so that the most common builder appears first.", "Finally, we will limit the results to just one entry to get the most common builder."], "gold_sql": "SELECT Builder FROM railway GROUP BY Builder ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["railway"], "pred_sql": "SELECT Builder, COUNT(*) as BuilderCount \nFROM railway \nGROUP BY Builder \nORDER BY BuilderCount DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.5707", "db_id": "dorm_1", "question": "What is the last name of every student who is either female or living in a city with the code BAL or male and under 20?", "rationale": ["Identify the criteria for selecting students: female students, students living in a city with code 'BAL', and male students under the age of 20.", "Use the first part of the virtual table to select last names of female students or students living in city 'BAL'.", "Use the second part of the virtual table to select last names of male students under 20.", "Combine both selections using UNION to ensure all qualifying last names are included."], "gold_sql": "SELECT lname FROM student WHERE sex  =  'F' AND city_code  =  'BAL' UNION SELECT lname FROM student WHERE sex  =  'M' AND age  <  20", "source_tables": ["student"], "pred_sql": "SELECT LName FROM Student WHERE Sex = 'Female' OR city_code = 'BAL' UNION SELECT LName FROM Student WHERE Sex = 'Male' AND Age < '20'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of last names of students from the 'Student' table based on specific criteria. It includes students of a certain gender residing in a specific city, as well as students of the same gender who are younger than a specified age. The placeholders in the WHERE clauses represent the gender, city code, and age criteria.\",\n        \"virtual_table\": \"SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND city_code  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT lname FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] AND age  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city_code\"\n    }\n}\n"}
{"sample_id": "train.5738", "db_id": "dorm_1", "question": "Find the number of amenities for each of the dorms that can accommodate more than 100 students.", "rationale": ["Identify the tables involved: Dorm and Has_amenity.", "We need to count the number of amenities for each dormitory.", "Join the Dorm table with the Has_amenity table on the dormid to link dormitories with their amenities.", "Filter the dormitories to include only those with a student capacity greater than 100.", "Group the results by dormid to get the count of amenities for each dormitory."], "gold_sql": "SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  100 GROUP BY T1.dormid", "source_tables": ["has_amenity", "dorm"], "pred_sql": "SELECT count(*), T1.dormid FROM Dorm AS T1 JOIN Has_amenity AS T2 ON T1.dormid = T2.dormid WHERE T1.student_capacity > 100 GROUP BY T1.dormid", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] OR student_capacity  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5747", "db_id": "dorm_1", "question": "What are the total number of students who are living in a male dorm?", "rationale": ["Identify the tables involved: We need to count students living in male dorms, so we will use the 'Lives_in' and 'Dorm' tables.", "Join the 'Lives_in' table with the 'Dorm' table on the dormid to link students to their respective dorms.", "Filter the results to include only those dorms where the gender is 'male'.", "Count the total number of students that meet the criteria using COUNT(*) function."], "gold_sql": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'", "source_tables": ["student", "lives_in", "dorm"], "pred_sql": "SELECT COUNT(*) FROM Lives_in AS L JOIN Dorm AS D ON L.dormid = D.dormid WHERE D.gender = 'male';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] OR student_capacity  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city_code\"\n    }\n}\n"}
{"sample_id": "train.5756", "db_id": "dorm_1", "question": "Find the first name of students who are living in the dorm that has most number of amenities.", "rationale": ["Identify the requirement: We need to find the first names of students living in the dorm with the most amenities.", "Use the provided hint to create a virtual table that counts the number of amenities per dormitory. This is done by joining the Dorm and Has_amenity tables and grouping by dormid.", "Sort the results of the count in descending order and limit to 1 to get the dorm with the most amenities.", "Next, we need to find the students living in that dorm. We will use a subquery to get the dormid from the previous step.", "Finally, we select the first names of students from the Student table where their StuID matches those living in the identified dorm."], "gold_sql": "SELECT T1.fname FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid IN (SELECT T2.dormid FROM dorm AS T3 JOIN has_amenity AS T4 ON T3.dormid  =  T4.dormid JOIN dorm_amenity AS T5 ON T4.amenid  =  T5.amenid GROUP BY T3.dormid ORDER BY count(*) DESC LIMIT 1)", "source_tables": ["has_amenity", "lives_in", "student", "dorm_amenity", "dorm"], "pred_sql": "SELECT Fname FROM Student WHERE StuID IN (SELECT stuid FROM Lives_in WHERE dormid = (SELECT dormid FROM (SELECT count(*) AS amenity_count, T1.dormid FROM Dorm AS T1 JOIN Has_amenity AS T2 ON T1.dormid = T2.dormid GROUP BY T1.dormid ORDER BY amenity_count DESC LIMIT 1)))", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] OR student_capacity  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5765", "db_id": "dorm_1", "question": "What is the first name and age of every student who lives in a dorm with a TV Lounge?", "rationale": ["Identify the information needed: first name and age of students living in a dorm with a TV Lounge.", "Determine the relationship between students and dorms: Students live in dorms as indicated by the Lives_in table.", "Identify which dorms have a TV Lounge: Use the Has_amenity table to find dorms that have the amenity identified by the Dorm_amenity table.", "Join these tables to filter students based on their dorms: Use a subquery to find student IDs (stuid) from the Lives_in table where the dormid matches those that have a TV Lounge."], "gold_sql": "SELECT T1.fname ,  T1.age FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid WHERE T2.dormid NOT IN (SELECT T3.dormid FROM has_amenity AS T3 JOIN dorm_amenity AS T4 ON T3.amenid  =  T4.amenid WHERE T4.amenity_name  =  'TV Lounge')", "source_tables": ["has_amenity", "student", "lives_in", "dorm_amenity"], "pred_sql": "SELECT Fname, Age FROM Student WHERE StuID IN (SELECT stuid FROM Lives_in WHERE dormid IN (SELECT dormid FROM Has_amenity WHERE amenid = (SELECT amenid FROM Dorm_amenity WHERE amenity_name = 'TV Lounge')));", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names and gender designations of dormitories from the 'Dorm' table that have a student capacity exceeding or falling below a specified number. The placeholders in the WHERE clause represent the capacity limits for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT dorm_name ,  gender FROM dorm WHERE student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] OR student_capacity  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of amenities available in dormitories that can accommodate more than a specified number of students. The placeholder in the WHERE clause represents the minimum student capacity for filtering the dormitories.\",\n        \"virtual_table\": \"SELECT count(*) ,  T1.dormid FROM dorm AS T1 JOIN has_amenity AS T2 ON T1.dormid  =  T2.dormid WHERE T1.student_capacity  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.dormid\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of the number of students and their average age, grouped by the city code, for a specific gender. The placeholder in the WHERE clause represents the gender of the students being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,  avg(age) ,  city_code FROM student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city_code\"\n    }\n}\n"}
{"sample_id": "train.5777", "db_id": "customer_complaints", "question": "What are the emails of customers who have filed complaints on the product which has had the greatest number of complaints?", "rationale": ["Identify the goal: We need to find the emails of customers who have filed complaints on the product with the greatest number of complaints.", "To achieve this, we will first need to determine which product has the greatest number of complaints. This can be done by grouping the Complaints table by product_id and counting the number of complaints for each product.", "We will order the results by the count of complaints in descending order and limit the results to 1 to get the product with the highest number of complaints.", "Next, we will join the Customers table with the Complaints table to get the email addresses of customers who filed complaints about that specific product.", "Finally, we will construct the SQL query to select the email addresses from the Customers table where the product_id matches the one identified in the previous step."], "gold_sql": "SELECT t1.email_address FROM customers AS t1 JOIN complaints AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "customers"], "pred_sql": "SELECT c.email_address \nFROM Customers c \nJOIN Complaints comp ON c.customer_id = comp.customer_id \nWHERE comp.product_id = (\n    SELECT product_id \n    FROM Complaints \n    GROUP BY product_id \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5778", "db_id": "customer_complaints", "question": "Which products has been complained by the customer who has filed least amount of complaints?", "rationale": ["Identify the products that have been complained about by customers.", "Join the Products table with the Complaints table to link products to complaints.", "Join the resulting table with the Customers table to access customer information.", "Use a subquery to find the customer who has filed the least amount of complaints by grouping complaints by customer_id and ordering by the count of complaints in ascending order, limiting the result to 1.", "Filter the main query to only include products associated with the identified customer."], "gold_sql": "SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT 1", "source_tables": ["complaints", "products", "customers"], "pred_sql": "SELECT DISTINCT p.product_name \nFROM Products AS p \nJOIN Complaints AS c ON p.product_id = c.product_id \nJOIN Customers AS cu ON c.customer_id = cu.customer_id \nWHERE cu.customer_id IN (\n    SELECT customer_id \n    FROM Complaints \n    GROUP BY customer_id \n    ORDER BY COUNT(*) ASC \n    LIMIT 1\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5795", "db_id": "customer_complaints", "question": "What is the last name of the staff member in charge of the complaint on the product with the lowest price?", "rationale": ["Identify the tables involved: Staff, Complaints, and Products.", "We need to find the last name of the staff member handling a complaint related to the product with the lowest price.", "Join the Staff table with the Complaints table on staff_id to link staff members to complaints.", "Join the Complaints table with the Products table on product_id to link complaints to products.", "Use a subquery to find the minimum product price from the Products table.", "Filter the results to only include complaints related to the product with this minimum price.", "Select the last name of the staff member from the resulting joined tables."], "gold_sql": "SELECT t1.last_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id JOIN products AS t3 ON t2.product_id  =  t3.product_id ORDER BY t3.product_price LIMIT 1", "source_tables": ["complaints", "products", "staff"], "pred_sql": "SELECT s.last_name \nFROM Staff s \nJOIN Complaints c ON s.staff_id = c.staff_id \nJOIN Products p ON c.product_id = p.product_id \nWHERE p.product_price = (SELECT MIN(product_price) FROM Products)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5796", "db_id": "customer_complaints", "question": "Which complaint status has more than 3 records on file?", "rationale": ["Identify the relevant table: The question pertains to the 'Complaints' table, specifically focusing on the 'complaint_status_code'.", "We need to count the number of records for each complaint status. This requires a GROUP BY clause on 'complaint_status_code'.", "To filter the results to only those statuses with more than 3 records, we will use the HAVING clause with COUNT(*) > 3.", "The final SQL query will select the 'complaint_status_code' and the count of complaints for each status, applying the necessary grouping and filtering."], "gold_sql": "SELECT complaint_status_code FROM complaints GROUP BY complaint_status_code HAVING count(*)  >  3", "source_tables": ["complaints"], "pred_sql": "SELECT complaint_status_code, COUNT(*) as complaint_count \nFROM Complaints \nGROUP BY complaint_status_code \nHAVING COUNT(*) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the distinct product names from the 'Products' table that are associated with complaints made by customers. It joins the 'Products' table with the 'Complaints' table based on the product identifier and groups the results by customer identifier to count the number of complaints per customer. The placeholder in the LIMIT clause represents the maximum number of distinct product names to return.\",\n        \"virtual_table\": \"SELECT DISTINCT t1.product_name FROM products AS t1 JOIN complaints AS t2 ON t1.product_id  =  t2.product_id JOIN customers AS t3 GROUP BY t3.customer_id ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5801", "db_id": "customer_complaints", "question": "Count the number of customers that have the customer type that is most common.", "rationale": ["Identify the need to count customers based on the most common customer type.", "Use a subquery to find the most common customer type by grouping the 'customer_type_code' in the 'Customers' table and ordering by the count of each type in descending order.", "Limit the subquery to return only the top result, which represents the most common customer type.", "Use the result of the subquery to filter the main query that counts the total number of customers with that specific customer type."], "gold_sql": "SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["customers"], "pred_sql": "SELECT COUNT(*) FROM Customers WHERE customer_type_code = (SELECT customer_type_code FROM Customers GROUP BY customer_type_code ORDER BY COUNT(*) DESC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique town or city names from the 'Customers' table, filtered by a specific customer type code. The results are grouped by town or city and ordered by the count of occurrences, with a limit on the number of results returned. The placeholders in the WHERE clause and LIMIT clause allow for dynamic input of the customer type code and the maximum number of results to display.\",\n        \"virtual_table\": \"SELECT town_city FROM customers WHERE customer_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY town_city ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.5810", "db_id": "customer_complaints", "question": "What is first names of the top 5 staff who have handled the greatest number of complaints?", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to find the first names of staff members, so we will select the 'first_name' column from the Staff table.", "To determine how many complaints each staff member has handled, we will join the Staff table with the Complaints table on the 'staff_id' column.", "We will group the results by 'staff_id' to aggregate the number of complaints handled by each staff member.", "We will use the COUNT function to count the number of complaints for each staff member.", "To get the top 5 staff members who handled the greatest number of complaints, we will order the results in descending order based on the count of complaints and limit the results to 5."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name \nFROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nGROUP BY Staff.staff_id \nORDER BY COUNT(Complaints.complaint_id) DESC \nLIMIT 5;", "hint": "\n"}
{"sample_id": "train.5811", "db_id": "customer_complaints", "question": "Return the first names of the 5 staff members who have handled the most complaints.", "rationale": ["Identify the relevant tables: Staff and Complaints.", "We need to join these tables on the staff_id to link staff members with the complaints they handled.", "We want to count the number of complaints each staff member has handled, so we will use COUNT(Complaints.complaint_id).", "Group the results by staff_id to aggregate the complaint counts for each staff member.", "Order the results in descending order based on the count of complaints to get the staff members who handled the most complaints at the top.", "Limit the results to the top 5 staff members."], "gold_sql": "SELECT t1.first_name FROM staff AS t1 JOIN complaints AS t2 ON t1.staff_id  =  t2.staff_id GROUP BY t2.staff_id ORDER BY count(*) LIMIT 5", "source_tables": ["complaints", "staff"], "pred_sql": "SELECT first_name FROM Staff \nJOIN Complaints ON Staff.staff_id = Complaints.staff_id \nGROUP BY Staff.staff_id \nORDER BY COUNT(Complaints.complaint_id) DESC \nLIMIT 5;", "hint": "\n"}
{"sample_id": "train.5845", "db_id": "tracking_share_transactions", "question": "Show all investor details.", "rationale": ["The user wants to see all investor details, which means we need to select all columns from the Investors table.", "The SQL query to retrieve all columns from a table is done using 'SELECT * FROM table_name'.", "In this case, the table name is 'Investors', so the query becomes 'SELECT * FROM Investors'."], "gold_sql": "SELECT Investor_details FROM INVESTORS", "source_tables": ["investors"], "pred_sql": "SELECT * FROM Investors;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY investor_id\"\n    }\n}\n"}
{"sample_id": "train.5858", "db_id": "tracking_share_transactions", "question": "Show details of all investors if they make any transaction with share count greater than 100.", "rationale": ["The query needs to show details of all investors who have made transactions with a share count greater than 100.", "To achieve this, we need to select the relevant columns from the Investors table, specifically 'investor_id' and 'Investor_details'.", "We will join the Investors table with the Transactions table on the 'investor_id' column to link investors with their transactions.", "The condition for filtering is that the 'share_count' in the Transactions table must be greater than 100."], "gold_sql": "SELECT T1.Investor_details FROM  INVESTORS AS T1 JOIN TRANSACTIONS AS T2 ON T1.investor_id  =  T2.investor_id WHERE T2.share_count  >  100", "source_tables": ["transactions", "investors"], "pred_sql": "SELECT Investors.investor_id, Investors.Investor_details \nFROM Investors \nJOIN Transactions ON Investors.investor_id = Transactions.investor_id \nWHERE Transactions.share_count > 100;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY investor_id\"\n    }\n}\n"}
{"sample_id": "train.5864", "db_id": "tracking_share_transactions", "question": "What are the lot details of lots associated with transactions with share count smaller than 50?", "rationale": ["Identify the relevant tables: We need to get lot details, which are in the 'Lots' table, and we need to filter based on transactions, which are in the 'Transactions' table.", "Determine the relationship between tables: The 'Lots' table is linked to the 'Transactions' table through the 'Transactions_Lots' table. We will need to join these tables to access the required data.", "Construct the SQL query: Start with selecting 'lot_details' from the 'Lots' table. Then, join 'Transactions_Lots' on 'lot_id' and 'Transactions' on 'transaction_id'.", "Add the filter condition: We need to filter transactions where the 'share_count' is less than 50. This will be added in the WHERE clause of the SQL query."], "gold_sql": "SELECT T1.lot_details FROM LOTS AS T1 JOIN TRANSACTIONS_LOTS AS T2 ON T1.lot_id  =  T2.transaction_id JOIN TRANSACTIONS AS T3 ON T2.transaction_id  =  T3.transaction_id WHERE T3.share_count  <  50", "source_tables": ["lots", "transactions_lots", "transactions"], "pred_sql": "SELECT Lots.lot_details \nFROM Lots \nJOIN Transactions_Lots ON Lots.lot_id = Transactions_Lots.lot_id \nJOIN Transactions ON Transactions_Lots.transaction_id = Transactions.transaction_id \nWHERE Transactions.share_count < 50;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY investor_id\"\n    }\n}\n"}
{"sample_id": "train.5866", "db_id": "tracking_share_transactions", "question": "Show the average transaction amount for different transaction types.", "rationale": ["We need to calculate the average transaction amount for different transaction types.", "To do this, we will select the transaction type description from the Ref_Transaction_Types table and the amount of transaction from the Transactions table.", "We will join the Transactions table with the Ref_Transaction_Types table on the transaction_type_code to get the corresponding descriptions for each transaction type.", "Next, we will use the AVG() function to calculate the average of the amount_of_transaction for each transaction type.", "Finally, we will group the results by transaction_type_description to get the average amounts for each type."], "gold_sql": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT rt.transaction_type_description, AVG(t.amount_of_transaction) AS average_transaction_amount\nFROM Transactions t\nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code\nGROUP BY rt.transaction_type_description;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY investor_id\"\n    }\n}\n"}
{"sample_id": "train.5867", "db_id": "tracking_share_transactions", "question": "Show the maximum and minimum share count of different transaction types.", "rationale": ["We need to find the maximum and minimum share count for different transaction types.", "To do this, we will select the maximum and minimum of the 'share_count' column from the 'Transactions' table.", "We also need to include the transaction type description, which is found in the 'Ref_Transaction_Types' table.", "We will join the 'Transactions' table with the 'Ref_Transaction_Types' table on the 'transaction_type_code' to get the descriptions.", "Finally, we will group the results by the transaction type description to get the max and min share counts for each type."], "gold_sql": "SELECT transaction_type_code ,  max(share_count) ,  min(share_count) FROM TRANSACTIONS GROUP BY transaction_type_code", "source_tables": ["transactions"], "pred_sql": "SELECT MAX(share_count) AS max_share_count, MIN(share_count) AS min_share_count, rt.transaction_type_description \nFROM Transactions t \nJOIN Ref_Transaction_Types rt ON t.transaction_type_code = rt.transaction_type_code \nGROUP BY rt.transaction_type_description;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY investor_id\"\n    }\n}\n"}
{"sample_id": "train.5883", "db_id": "tracking_share_transactions", "question": "What are the details of all sales and purchases?", "rationale": ["The user wants details of all sales and purchases, which means we need to retrieve data from both the Sales and Purchases tables.", "We will select the relevant columns from both tables: sales_transaction_id and sales_details from the Sales table, and purchase_transaction_id and purchase_details from the Purchases table.", "Since we want to combine the results from both tables, we can use a FULL OUTER JOIN to ensure we get all records from both tables, even if there are no matching records in one of them."], "gold_sql": "SELECT sales_details FROM sales UNION SELECT purchase_details FROM purchases", "source_tables": ["sales", "purchases"], "pred_sql": "SELECT Sales.sales_transaction_id, Sales.sales_details, Purchases.purchase_transaction_id, Purchases.purchase_details \nFROM Sales \nFULL OUTER JOIN Purchases ON Sales.sales_transaction_id = Purchases.purchase_transaction_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the number of transactions for each investor from the 'Transactions' table, filtered by a specific transaction type. The placeholder in the WHERE clause represents the transaction type code.\",\n        \"virtual_table\": \"SELECT investor_id ,  COUNT(*) FROM TRANSACTIONS WHERE transaction_type_code  =  [PLACEHOLDER-TYPE:STRING] GROUP BY investor_id\"\n    }\n}\n"}
{"sample_id": "train.5898", "db_id": "cre_Theme_park", "question": "What is the average price range of five star hotels that allow pets?", "rationale": ["Identify the relevant table: The Hotels table contains information about hotel star ratings and whether pets are allowed.", "Filter for five-star hotels: We need to filter the Hotels table for entries where star_rating_code is '5'.", "Check for pet-friendly hotels: Additionally, we need to ensure that the hotels allow pets, which is indicated by pets_allowed_yn being 'Yes'.", "Calculate the average price range: We will use the AVG() function to calculate the average of the price_range column for the filtered hotels."], "gold_sql": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  '5' AND pets_allowed_yn  =  1", "source_tables": ["hotels"], "pred_sql": "SELECT AVG(price_range) AS average_price_range FROM Hotels WHERE star_rating_code = '5' AND pets_allowed_yn = 'Yes';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5904", "db_id": "cre_Theme_park", "question": "Find all the locations whose names contain the word \"film\".", "rationale": ["Identify the table that contains location names: Locations.", "Determine the column that holds the names of the locations: Location_Name.", "Use the SQL SELECT statement to retrieve all columns from the Locations table.", "Apply a WHERE clause to filter results where Location_Name contains the word 'film', using the LIKE operator with wildcards."], "gold_sql": "SELECT Location_Name FROM LOCATIONS WHERE Location_Name LIKE '%film%'", "source_tables": ["locations"], "pred_sql": "SELECT * FROM Locations WHERE Location_Name LIKE '%film%';", "hint": "\n"}
{"sample_id": "train.5915", "db_id": "cre_Theme_park", "question": "What are the details and opening hours of the museums?", "rationale": ["The user is asking for details and opening hours of museums.", "We need to retrieve data from the Museums table for museum details.", "We also need to get the opening hours from the Tourist_Attractions table, as museums are a type of tourist attraction.", "To combine these two pieces of information, we will join the Museums table with the Tourist_Attractions table on the common identifier, which is the Tourist_Attraction_ID.", "The final SQL query will select the Museum_ID, Museum_Details from the Museums table and Opening_Hours from the Tourist_Attractions table."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT M.Museum_ID, M.Museum_Details, T.Opening_Hours \nFROM Museums AS M \nJOIN Tourist_Attractions AS T ON M.Museum_ID = T.Tourist_Attraction_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5916", "db_id": "cre_Theme_park", "question": "Give me the detail and opening hour for each museum.", "rationale": ["The user wants details and opening hours for each museum.", "We need to select the relevant columns: Museum_ID and Museum_Details from the Museums table, and Opening_Hours from the Tourist_Attractions table.", "To get the opening hours for each museum, we will join the Museums table with the Tourist_Attractions table on the common identifier, which is Museum_ID in Museums and Tourist_Attraction_ID in Tourist_Attractions."], "gold_sql": "SELECT T1.Museum_Details ,  T2.Opening_Hours FROM MUSEUMS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Museum_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["tourist_attractions", "museums"], "pred_sql": "SELECT M.Museum_ID, M.Museum_Details, T.Opening_Hours \nFROM Museums AS M \nJOIN Tourist_Attractions AS T ON M.Museum_ID = T.Tourist_Attraction_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5922", "db_id": "cre_Theme_park", "question": "Which tourist attractions are related to royal family? Tell me their details and how we can get there.", "rationale": ["Identify the relevant tables: Tourist_Attractions and Royal_Family.", "Determine the relationship between the tables: Royal_Family entries are linked to Tourist_Attractions via the Tourist_Attraction_ID.", "Select the desired columns: Name, Description, and How_to_Get_There from the Tourist_Attractions table.", "Construct the SQL query using a JOIN to combine data from both tables based on their relationship."], "gold_sql": "SELECT T1.Royal_Family_Details ,  T2.How_to_Get_There FROM ROYAL_FAMILY AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Royal_Family_ID  =  T2.Tourist_Attraction_ID", "source_tables": ["royal_family", "tourist_attractions"], "pred_sql": "SELECT TA.Name, TA.Description, TA.How_to_Get_There \nFROM Tourist_Attractions AS TA \nJOIN Royal_Family AS RF ON TA.Tourist_Attraction_ID = RF.Royal_Family_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5923", "db_id": "cre_Theme_park", "question": "What are the details of the shops that can be accessed by walk?", "rationale": ["Identify the relevant tables: Shops and Tourist_Attractions.", "Determine the relationship between the tables: Shops are linked to Tourist_Attractions through the Shop_ID and Tourist_Attraction_ID.", "Focus on the requirement: details of shops that can be accessed by walking.", "Use a WHERE clause to filter the Tourist_Attractions based on the 'How_to_Get_There' column, looking for entries that mention 'walk'.", "Select the necessary columns from the Shops table."], "gold_sql": "SELECT T1.Shop_Details FROM SHOPS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Shop_ID  =  T2.Tourist_Attraction_ID WHERE T2.How_to_Get_There  =  'walk'", "source_tables": ["shops", "tourist_attractions"], "pred_sql": "SELECT Shops.Shop_ID, Shops.Shop_Details \nFROM Shops \nJOIN Tourist_Attractions ON Shops.Shop_ID = Tourist_Attractions.Tourist_Attraction_ID \nWHERE Tourist_Attractions.How_to_Get_There LIKE '%walk%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5931", "db_id": "cre_Theme_park", "question": "Which tourist attractions does the visitor with detail 'Vincent' visit?", "rationale": ["Identify the tables involved: Tourist_Attractions, Visitors, and Visits.", "Join the Tourist_Attractions table with the Visits table to get the attractions visited.", "Join the Visitors table to filter by the specific tourist's details, which is 'Vincent'.", "Use the EXCEPT clause to exclude any attractions that have also been visited by another tourist with the same details, although in this case, we are only filtering for 'Vincent'.", "Construct the SQL query using the identified tables and conditions."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Visitors AS T2 JOIN Visits AS T3 ON T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID AND T2.Tourist_ID = T3.Tourist_ID WHERE T2.Tourist_Details = 'Vincent' EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Visitors AS T2 JOIN Visits AS T3 ON T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID AND T2.Tourist_ID = T3.Tourist_ID WHERE T2.Tourist_Details = 'Vincent'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5932", "db_id": "cre_Theme_park", "question": "Show the tourist attractions visited by the tourist whose detail is 'Vincent'.", "rationale": ["Identify the tables involved: Tourist_Attractions, Visitors, and Visits.", "We need to find the names of tourist attractions visited by a specific tourist identified by their details, which is 'Vincent'.", "Join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID, and then join with the Visitors table on Tourist_ID.", "Filter the results where the Tourist_Details in the Visitors table matches 'Vincent'.", "Construct the SQL query using the identified tables and conditions."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID JOIN VISITORS AS T3 ON T2.Tourist_ID  =  T3.Tourist_ID WHERE T3.Tourist_Details  =  'Vincent'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Visitors AS T2 JOIN Visits AS T3 ON T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID AND T2.Tourist_ID = T3.Tourist_ID WHERE T2.Tourist_Details = 'Vincent'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5941", "db_id": "cre_Theme_park", "question": "Show the details of the top 3 most expensive hotels.", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "To find the most expensive hotels, we need to sort the hotels by their price range in descending order.", "We will limit the results to the top 3 hotels to get only the most expensive ones.", "The final SQL query selects all columns from the 'Hotels' table, orders them by 'price_range' in descending order, and limits the output to 3 records."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5942", "db_id": "cre_Theme_park", "question": "What are the details of the three most expensive hotels?", "rationale": ["Identify the table that contains hotel details, which is the 'Hotels' table.", "Determine the relevant columns needed to retrieve the details of the hotels, which are all columns in this case.", "To find the most expensive hotels, we need to sort the hotels by their price range in descending order.", "Use the ORDER BY clause to sort the results by 'price_range' in descending order.", "Limit the results to the top three entries using the LIMIT clause."], "gold_sql": "SELECT other_hotel_details FROM HOTELS ORDER BY price_range DESC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT * FROM Hotels ORDER BY price_range DESC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5944", "db_id": "cre_Theme_park", "question": "What are the details and star ratings of the three hotels with the lowest price ranges?", "rationale": ["Identify the relevant tables: Hotels and Ref_Hotel_Star_Ratings.", "We need to select hotel details and their star ratings, so we will select columns from both tables: hotel_id and price_range from Hotels, and star_rating_description from Ref_Hotel_Star_Ratings.", "Join the Hotels table with the Ref_Hotel_Star_Ratings table on the star_rating_code to get the star rating descriptions for each hotel.", "Order the results by price_range in ascending order to get the hotels with the lowest price ranges first.", "Limit the results to 3 to get only the three hotels with the lowest price ranges."], "gold_sql": "SELECT other_hotel_details ,  star_rating_code FROM HOTELS ORDER BY price_range ASC LIMIT 3", "source_tables": ["hotels"], "pred_sql": "SELECT H.hotel_id, H.price_range, R.star_rating_description FROM Hotels AS H JOIN Ref_Hotel_Star_Ratings AS R ON H.star_rating_code = R.star_rating_code ORDER BY H.price_range ASC LIMIT 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5945", "db_id": "cre_Theme_park", "question": "Show the transportation method most people choose to get to tourist attractions.", "rationale": ["The question asks for the transportation method most people choose to get to tourist attractions, which implies we need to find out which tourist attraction has the highest number of visits.", "To achieve this, we can use the third virtual table provided in the hint, which summarizes tourist attractions along with the count of visits for each attraction.", "We will select the name of the tourist attraction and count the number of visits by joining the 'Tourist_Attractions' table with the 'Visits' table on the 'Tourist_Attraction_ID'.", "We will group the results by 'Tourist_Attraction_ID' to get the count of visits for each attraction.", "Finally, we will order the results by the visit count in descending order and limit the output to 1 to get the most visited attraction."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT T1.Name, COUNT(*) AS Visit_Count FROM Tourist_Attractions AS T1 JOIN Visits AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID GROUP BY T1.Tourist_Attraction_ID ORDER BY Visit_Count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders in the SELECT statement represent the name of the attraction and its corresponding visit count.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5946", "db_id": "cre_Theme_park", "question": "Which transportation method is used the most often to get to tourist attractions?", "rationale": ["The question asks for the transportation method used the most often to get to tourist attractions, which implies we need to analyze the visits to attractions.", "We can utilize the Visits table to count how many times each tourist attraction has been visited.", "We will join the Tourist_Attractions table with the Visits table on the Tourist_Attraction_ID to get the names of the attractions along with their visit counts.", "We will group the results by Tourist_Attraction_ID to aggregate the visit counts for each attraction.", "Finally, we will order the results by the visit count in descending order and limit the output to 1 to get the most visited attraction."], "gold_sql": "SELECT How_to_Get_There FROM Tourist_Attractions GROUP BY How_to_Get_There ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["tourist_attractions"], "pred_sql": "SELECT Name, COUNT(*) as Visit_Count FROM Tourist_Attractions AS T1 JOIN Visits AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID GROUP BY T1.Tourist_Attraction_ID ORDER BY Visit_Count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5955", "db_id": "cre_Theme_park", "question": "Show the names and ids of tourist attractions that are visited at most once.", "rationale": ["We need to find tourist attractions that have been visited at most once.", "To do this, we will join the 'Tourist_Attractions' table with the 'Visits' table on the 'Tourist_Attraction_ID'.", "We will group the results by 'Tourist_Attraction_ID' to count the number of visits for each attraction.", "Using COUNT(*), we can determine how many times each attraction has been visited.", "Finally, we will filter the results to include only those attractions where the visit count is less than or equal to 1."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Name, Tourist_Attraction_ID FROM (SELECT T1.Name, T1.Tourist_Attraction_ID, COUNT(*) as Visit_Count FROM Tourist_Attractions AS T1 JOIN Visits AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID GROUP BY T1.Tourist_Attraction_ID) WHERE Visit_Count <= 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5956", "db_id": "cre_Theme_park", "question": "What are the names and ids of the tourist attractions that are visited at most once?", "rationale": ["We need to find tourist attractions that are visited at most once.", "To achieve this, we will join the 'Tourist_Attractions' table with the 'Visits' table on the 'Tourist_Attraction_ID'.", "We will group the results by 'Tourist_Attraction_ID' and count the number of visits for each attraction.", "Finally, we will filter the results to include only those attractions with a visit count of 1 or less."], "gold_sql": "SELECT T1.Name ,  T1.Tourist_Attraction_ID FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID HAVING count(*)  <=  1", "source_tables": ["visits", "tourist_attractions"], "pred_sql": "SELECT Name, Tourist_Attraction_ID FROM (SELECT T1.Name, T1.Tourist_Attraction_ID, COUNT(*) as Visit_Count FROM Tourist_Attractions AS T1 JOIN Visits AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID GROUP BY T1.Tourist_Attraction_ID) WHERE Visit_Count <= 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5959", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions that have parking or shopping as their feature details?", "rationale": ["Identify the relevant tables: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find the names of tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions with their features.", "Then, join the Features table to access the feature details.", "Use a WHERE clause to filter for features that are either 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet these criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT T1.Name \nFROM Tourist_Attractions AS T1 \nJOIN Tourist_Attraction_Features AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nJOIN Features AS T3 ON T2.Feature_ID = T3.Feature_ID \nWHERE T3.Feature_Details IN ('parking', 'shopping')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5960", "db_id": "cre_Theme_park", "question": "Find the tourist attractions that have parking or shopping as their feature details. What are the names of the attractions?", "rationale": ["Identify the tables involved: Tourist_Attractions, Tourist_Attraction_Features, and Features.", "We need to find the names of tourist attractions that have specific features (parking or shopping).", "Join the Tourist_Attractions table with the Tourist_Attraction_Features table to link attractions with their features.", "Then, join with the Features table to access the feature details.", "Use a WHERE clause to filter for features that are either 'parking' or 'shopping'.", "Select the Name of the tourist attractions that meet these criteria."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'park' UNION SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Tourist_Attraction_Features AS T2 ON T1.tourist_attraction_id  =  T2.tourist_attraction_id JOIN Features AS T3 ON T2.Feature_ID  =  T3.Feature_ID WHERE T3.feature_Details  =  'shopping'", "source_tables": ["features", "tourist_attractions", "tourist_attraction_features"], "pred_sql": "SELECT T1.Name \nFROM Tourist_Attractions AS T1 \nJOIN Tourist_Attraction_Features AS T2 ON T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID \nJOIN Features AS T3 ON T2.Feature_ID = T3.Feature_ID \nWHERE T3.Feature_Details IN ('parking', 'shopping')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5963", "db_id": "cre_Theme_park", "question": "What are the names of the tourist attractions Vincent and Marcelle visit?", "rationale": ["Identify the tables involved: Tourist_Attractions, Visits, and Visitors.", "We need to find the names of tourist attractions visited by both Vincent and Marcelle.", "Use the INTERSECT operator to find common attractions visited by both tourists.", "Construct the first part of the query to select attractions visited by Vincent.", "Construct the second part of the query to select attractions visited by Marcelle.", "Combine both parts using INTERSECT to get the final result."], "gold_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  'Marcelle'", "source_tables": ["visits", "visitors", "tourist_attractions"], "pred_sql": "SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Visits AS T3 ON T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID JOIN Visitors AS T2 ON T2.Tourist_ID = T3.Tourist_ID WHERE T2.Tourist_Details = 'Vincent' INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN Visits AS T3 ON T1.Tourist_Attraction_ID = T3.Tourist_Attraction_ID JOIN Visitors AS T2 ON T2.Tourist_ID = T3.Tourist_ID WHERE T2.Tourist_Details = 'Marcelle'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the names of tourist attractions that have been visited by two different tourists, identified by their specific details. The placeholders in the WHERE clause represent the details of each tourist.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of tourist attractions that have been visited by a specific tourist, identified by their details, while excluding those attractions that have also been visited by another tourist with the same details. The placeholders in the query represent the tourist's details for filtering purposes.\",\n        \"virtual_table\": \"SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT T1.Name FROM Tourist_Attractions AS T1 JOIN VISITORS AS T2 JOIN VISITS AS T3 ON T1.Tourist_Attraction_ID  =  T3.Tourist_Attraction_ID AND T2.Tourist_ID  =  T3.Tourist_ID WHERE T2.Tourist_Details  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of tourist attractions along with the count of visits for each attraction. It combines data from the 'Tourist_Attractions' table and the 'Visits' table, grouping the results by the unique identifier of each tourist attraction. The placeholders represent the specific details of the attractions and the count of visits associated with them.\",\n        \"virtual_table\": \"SELECT T1.Name ,  T2.Tourist_Attraction_ID ,   COUNT(*) FROM Tourist_Attractions AS T1 JOIN VISITS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID GROUP BY T2.Tourist_Attraction_ID\"\n    }\n}\n"}
{"sample_id": "train.5985", "db_id": "game_1", "question": "Which game type has most number of games?", "rationale": ["Identify the relevant table: The question is about video game types and their counts, so we will use the 'Video_Games' table.", "Determine the required columns: We need the 'GType' (game type) and a count of how many games fall into each type.", "Use the COUNT function: We will count the number of games for each game type using COUNT(*).", "Group the results: We will group the results by 'GType' to get the count for each type.", "Order the results: To find the game type with the most games, we will order the results in descending order based on the count.", "Limit the results: Since we only want the game type with the most games, we will limit the results to 1."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType, COUNT(*) AS NumberOfGames FROM Video_Games GROUP BY GType ORDER BY NumberOfGames DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\",\n        \"virtual_table\": \"SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by the first and last names of the students from the 'Student' table. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.Fname  =  [PLACEHOLDER-TYPE:STRING] AND T2.Lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.5988", "db_id": "game_1", "question": "What is the type with the fewest games?", "rationale": ["Identify the table that contains the type of games, which is the 'Video_Games' table.", "We need to count the number of games for each type, so we will use the COUNT() function on 'GameID'.", "Group the results by 'GType' to get the count of games for each type.", "Order the results in ascending order based on the count of games to find the type with the fewest games.", "Limit the results to 1 to get only the type with the fewest games."], "gold_sql": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) LIMIT 1", "source_tables": ["video_games"], "pred_sql": "SELECT GType, COUNT(GameID) AS GameCount FROM Video_Games GROUP BY GType ORDER BY GameCount ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\",\n        \"virtual_table\": \"SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by the first and last names of the students from the 'Student' table. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.Fname  =  [PLACEHOLDER-TYPE:STRING] AND T2.Lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6001", "db_id": "game_1", "question": "How many students play sports?", "rationale": ["The question asks for the number of students who play sports.", "To find this, we need to count the unique student identifiers (StuID) in the SportsInfo table.", "We can use the COUNT() function to get the total number of entries in the SportsInfo table, which represents the students participating in sports."], "gold_sql": "SELECT count(DISTINCT StuID) FROM Sportsinfo", "source_tables": ["sportsinfo"], "pred_sql": "SELECT COUNT(*) AS NumberOfStudents FROM SportsInfo;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by the first and last names of the students from the 'Student' table. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.Fname  =  [PLACEHOLDER-TYPE:STRING] AND T2.Lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\",\n        \"virtual_table\": \"SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID\"\n    }\n}\n"}
{"sample_id": "train.6003", "db_id": "game_1", "question": "List ids for all student who are on scholarship.", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Focus on the column 'OnScholarship' to filter students who are on a scholarship.", "Construct the SQL query to select 'StuID' from the SportsInfo table where 'OnScholarship' is equal to 'Yes'."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE major  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6004", "db_id": "game_1", "question": "What are the ids for all sporty students who are on scholarship?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "We need to filter students who are on a sports scholarship, which is indicated by the 'OnScholarship' column in the SportsInfo table.", "The query will select the 'StuID' from the SportsInfo table where 'OnScholarship' is equal to 'Yes'."], "gold_sql": "SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE major  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of students who participate in sports, along with the count of their participation. The query joins the 'SportsInfo' table with the 'Student' table based on the unique student identifier. The results are grouped by student ID and ordered by the number of sports they participate in, with a limit on the number of results returned, specified by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6006", "db_id": "game_1", "question": "What are the last names for all scholarship students?", "rationale": ["Identify the requirement: We need the last names of students who are on a sports scholarship.", "Refer to the SportsInfo table to find students who are on a scholarship. We will filter this table by the 'OnScholarship' column.", "We need to extract the 'StuID' of those students from the SportsInfo table where 'OnScholarship' is 'Yes'.", "Next, we will use this list of 'StuID's to find the corresponding last names in the Student table.", "The final SQL query will select the 'LName' from the Student table where the 'StuID' is in the list obtained from the SportsInfo table."], "gold_sql": "SELECT T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T1.onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT LName FROM Student WHERE StuID IN (SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE major  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6010", "db_id": "game_1", "question": "What is the total number of all football games played by scholarship students?", "rationale": ["Identify the relevant table: SportsInfo contains information about sports participation.", "Focus on the condition: We need to filter for students who are on a sports scholarship, which is indicated by the 'OnScholarship' column.", "Specify the sport: We are interested in football games, so we will filter by 'SportName' = 'Football'.", "Use the SUM function to calculate the total number of games played by these scholarship students."], "gold_sql": "SELECT sum(gamesplayed) FROM Sportsinfo WHERE sportname  =  'Football' AND onscholarship  =  'Y'", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SUM(GamesPlayed) FROM SportsInfo WHERE OnScholarship = 'Yes' AND SportName = 'Football'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\",\n        \"virtual_table\": \"SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE major  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by the first and last names of the students from the 'Student' table. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.Fname  =  [PLACEHOLDER-TYPE:STRING] AND T2.Lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6014", "db_id": "game_1", "question": "What are the ids of all students along with how many sports and games did they play?", "rationale": ["We need to retrieve the IDs of all students along with the count of sports and games they play.", "To achieve this, we will use the 'Student' table as the base table since we want all students' IDs.", "We will perform a LEFT JOIN with a subquery that counts the number of sports each student is involved in from the 'SportsInfo' table. This subquery will group by 'StuID' and count the entries for each student.", "Next, we will perform another LEFT JOIN with a subquery that counts the number of games each student plays from the 'Plays_Games' table. This subquery will also group by 'StuID' and count the entries for each student.", "We will use COALESCE to ensure that if a student has no entries in either the sports or games tables, they will still appear in the results with a count of 0 for that category."], "gold_sql": "SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID", "source_tables": ["sportsinfo"], "pred_sql": "SELECT S.StuID, COALESCE(SP.sports_count, 0) AS sports_count, COALESCE(G.games_count, 0) AS games_count\nFROM Student S\nLEFT JOIN (\n    SELECT StuID, COUNT(*) AS sports_count\n    FROM SportsInfo\n    GROUP BY StuID\n) SP ON S.StuID = SP.StuID\nLEFT JOIN (\n    SELECT StuID, COUNT(*) AS games_count\n    FROM Plays_Games\n    GROUP BY StuID\n) G ON S.StuID = G.StuID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\",\n        \"virtual_table\": \"SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total hours per week dedicated to sports and the total number of games played by students from the 'SportsInfo' table, filtered by the first and last names of the students from the 'Student' table. The placeholders in the WHERE clause represent the student's first and last names.\",\n        \"virtual_table\": \"SELECT sum(hoursperweek) ,  sum(gamesplayed) FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.Fname  =  [PLACEHOLDER-TYPE:STRING] AND T2.Lname  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6019", "db_id": "game_1", "question": "Which sport has most number of students on scholarship?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Filter the records to include only those students who are on a scholarship by using the condition 'OnScholarship = 'Yes' in the WHERE clause.", "Group the results by SportName to count the number of students in each sport using GROUP BY.", "Count the number of students for each sport using COUNT(StuID) and alias it as NumberOfStudents.", "Order the results in descending order based on the count of students using ORDER BY NumberOfStudents DESC.", "Limit the results to only the top entry using LIMIT 1 to find the sport with the most students on scholarship."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName, COUNT(StuID) AS NumberOfStudents\nFROM SportsInfo\nWHERE OnScholarship = 'Yes'\nGROUP BY SportName\nORDER BY NumberOfStudents DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE major  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total number of games played by each student from the 'SportsInfo' table. It includes the unique student identifier and counts the number of entries for each student, as well as the total games played, using placeholders for the respective values.\",\n        \"virtual_table\": \"SELECT StuID ,  count(*) ,  sum(gamesplayed) FROM Sportsinfo GROUP BY StuID\"\n    }\n}\n"}
{"sample_id": "train.6020", "db_id": "game_1", "question": "What is the sport with the most scholarship students?", "rationale": ["Identify the relevant table: SportsInfo contains information about students participating in sports and their scholarship status.", "Filter the records to include only those students who are on a sports scholarship by using the condition 'OnScholarship = 'Yes'.", "Group the results by 'SportName' to count how many scholarship students are in each sport.", "Use COUNT(*) to count the number of scholarship students for each sport.", "Order the results in descending order based on the count of scholarship students to find the sport with the most scholarship students.", "Limit the results to 1 to get only the sport with the highest count."], "gold_sql": "SELECT sportname FROM Sportsinfo WHERE onscholarship  =  'Y' GROUP BY sportname ORDER BY count(*) DESC LIMIT 1", "source_tables": ["sportsinfo"], "pred_sql": "SELECT SportName, COUNT(*) AS ScholarshipCount \nFROM SportsInfo \nWHERE OnScholarship = 'Yes' \nGROUP BY SportName \nORDER BY ScholarshipCount DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE major  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of students who participate in sports, along with the count of their participation. The query joins the 'SportsInfo' table with the 'Student' table based on the unique student identifier. The results are grouped by student ID and ordered by the number of sports they participate in, with a limit on the number of results returned, specified by a placeholder for numeric values.\",\n        \"virtual_table\": \"SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6024", "db_id": "game_1", "question": "What are the student ids for those on scholarship in major number 600?", "rationale": ["Identify the requirement: We need to find student IDs for those who are on a sports scholarship and majoring in number 600.", "Refer to the provided hint about the virtual table that combines major and scholarship status.", "The first part of the query selects student IDs from the Student table where the Major is '600'.", "The second part of the query selects student IDs from the SportsInfo table where OnScholarship is 'Yes'.", "Use the INTERSECT operator to find common student IDs from both queries, which gives us students who meet both criteria."], "gold_sql": "SELECT StuID FROM Student WHERE major  =  600 INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  'Y'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM Student WHERE Major = '600' INTERSECT SELECT StuID FROM SportsInfo WHERE OnScholarship = 'Yes'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE major  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6025", "db_id": "game_1", "question": "Show student ids who are female and play football.", "rationale": ["Identify the requirement to find student IDs who are female and play football.", "Use the 'Student' table to filter for female students by checking the 'Sex' column.", "Use the 'SportsInfo' table to filter for students who play football by checking the 'SportName' column.", "Combine the two conditions using the INTERSECT operator to get student IDs that meet both criteria."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Female' INTERSECT SELECT StuID FROM SportsInfo WHERE SportName = 'Football'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who are of a specific gender and are not participating in a specified sport. The placeholders in the WHERE clause represent the gender and the sport's name.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE major  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6026", "db_id": "game_1", "question": "What are the ids of all female students who play football?", "rationale": ["Identify the relevant tables: We need to look at the 'Student' table for student details and the 'SportsInfo' table for sports participation.", "We need to filter for female students, so we will use a WHERE clause on the 'Sex' column in the 'Student' table.", "We also need to filter for students who play football, which requires a condition on the 'SportName' column in the 'SportsInfo' table.", "To get the IDs of these students, we will select the 'StuID' from the 'Student' table, joining it with the 'SportsInfo' table on 'StuID'.", "The final SQL query will combine these conditions to return the desired results."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'F' INTERSECT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT S.StuID \nFROM Student S \nJOIN SportsInfo SI ON S.StuID = SI.StuID \nWHERE S.Sex = 'Female' AND SI.SportName = 'Football';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who are of a specific gender and are not participating in a specified sport. The placeholders in the WHERE clause represent the gender and the sport's name.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE major  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6028", "db_id": "game_1", "question": "What are the ids of all male students who do not play football?", "rationale": ["Identify the requirement: We need the IDs of all male students who do not play football.", "From the schema, we see that the 'Student' table contains the gender information and the 'SportsInfo' table contains the sports participation details.", "We will first select the IDs of male students from the 'Student' table where Sex = 'Male'.", "Next, we need to exclude those students who play football. We can do this by selecting the IDs from the 'SportsInfo' table where SportName = 'Football'.", "To combine these two requirements, we can use the EXCEPT clause to get male students who are not in the list of students playing football."], "gold_sql": "SELECT StuID FROM Student WHERE sex  =  'M' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  'Football'", "source_tables": ["sportsinfo", "student"], "pred_sql": "SELECT StuID FROM Student WHERE Sex = 'Male' EXCEPT SELECT StuID FROM SportsInfo WHERE SportName = 'Football'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students from the 'Student' table who are of a specific gender and are not participating in a specified sport. The placeholders in the WHERE clause represent the gender and the sport's name.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE sex  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of students who participate in sports, along with a count of their participation. The results are grouped by student ID and ordered by the number of sports they are involved in, with a limit on the number of results returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies students who are majoring in a specific field of study and are also participating in sports on a scholarship. The placeholders in the query represent the major and the scholarship status.\",\n        \"virtual_table\": \"SELECT StuID FROM Student WHERE major  =  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT StuID FROM Sportsinfo WHERE onscholarship  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6060", "db_id": "customers_and_addresses", "question": "Find the average order quantity per order.", "rationale": ["Identify the relevant table: The 'Order_Items' table contains the 'order_quantity' which we need to calculate the average from.", "Use the AVG() function: This function will help us calculate the average of the 'order_quantity'.", "Group by order_id: To find the average order quantity per order, we need to group the results by 'order_id'.", "Construct the SQL query: Combine these elements into a complete SQL query."], "gold_sql": "SELECT avg(order_quantity) FROM order_items", "source_tables": ["order_items"], "pred_sql": "SELECT AVG(order_quantity) AS average_order_quantity\nFROM Order_Items\nGROUP BY order_id;", "hint": "\n"}
{"sample_id": "train.6071", "db_id": "customers_and_addresses", "question": "What are the details of all products?", "rationale": ["The user wants to retrieve details of all products.", "To get all details from a table, we use the SELECT statement with a wildcard (*) to select all columns.", "The table we need to query is 'Products'.", "Thus, the SQL query will be 'SELECT * FROM Products;'"], "gold_sql": "SELECT DISTINCT product_details FROM products", "source_tables": ["products"], "pred_sql": "SELECT * FROM Products;", "hint": "\n"}
{"sample_id": "train.6075", "db_id": "customers_and_addresses", "question": "Find the detail of products whose detail contains the word \"Latte\" or the word \"Americano\"", "rationale": ["Identify the table to query: The question asks for product details, so we will query the Products table.", "Determine the condition: We need to find products whose details contain either 'Latte' or 'Americano'.", "Use the SQL LIKE operator: To search for a substring within a text field, we use the LIKE operator with wildcards ('%').", "Construct the SQL query: We will select all columns from the Products table where product_details matches either condition."], "gold_sql": "SELECT product_details FROM products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%'", "source_tables": ["products"], "pred_sql": "SELECT * FROM Products WHERE product_details LIKE '%Latte%' OR product_details LIKE '%Americano%';", "hint": "\n"}
{"sample_id": "train.6085", "db_id": "customers_and_addresses", "question": "Which city has the most customers living in?", "rationale": ["Identify the relevant tables: We need to find the city with the most customers, so we will use the Customer_Addresses and Addresses tables.", "Join the tables: We will join Customer_Addresses with Addresses on the address_id to get the city associated with each customer.", "Count distinct customers: We will count the distinct customer_id for each city to avoid counting the same customer multiple times.", "Group by city: We will group the results by city to aggregate the customer counts for each city.", "Order by customer count: We will order the results in descending order based on the customer count to find the city with the most customers.", "Limit the results: We will limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(DISTINCT customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6086", "db_id": "customers_and_addresses", "question": "Find the city where the most customers live.", "rationale": ["To find the city where the most customers live, we need to count the number of customers associated with each city.", "The relevant tables are 'Customer_Addresses' which links customers to their addresses, and 'Addresses' which contains the city information.", "We will perform a JOIN between 'Customer_Addresses' and 'Addresses' on the address_id to get the city for each customer.", "Next, we will use GROUP BY to group the results by city and COUNT to count the number of customers in each city.", "To find the city with the most customers, we will order the results in descending order based on the customer count.", "Finally, we will limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT t3.city FROM customers AS t1 JOIN customer_addresses AS t2 ON t1.customer_id  =  t2.customer_id JOIN addresses AS t3 ON t2.address_id  =  t3.address_id GROUP BY t3.city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "customers", "customer_addresses"], "pred_sql": "SELECT city, COUNT(customer_id) AS customer_count\nFROM Customer_Addresses\nJOIN Addresses ON Customer_Addresses.address_id = Addresses.address_id\nGROUP BY city\nORDER BY customer_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6097", "db_id": "customers_and_addresses", "question": "Which contact channel has been used by the customer with name \"Tillman Ernser\"?", "rationale": ["Identify the relevant tables: Customers and Customer_Contact_Channels.", "Join the Customers table with the Customer_Contact_Channels table using the customer_id as the linking key.", "Filter the results to find the specific customer by name, which is 'Tillman Ernser'.", "Select the desired fields: channel_code and contact_number from the Customer_Contact_Channels table."], "gold_sql": "SELECT DISTINCT channel_code FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT t2.channel_code, t2.contact_number FROM Customers AS t1 JOIN Customer_Contact_Channels AS t2 ON t1.customer_id = t2.customer_id WHERE t1.customer_name = 'Tillman Ernser'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n        \"virtual_table\": \"SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n        \"virtual_table\": \"SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the channel codes and contact numbers of customer contact channels that have the longest active duration. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n        \"virtual_table\": \"SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    }\n}\n"}
{"sample_id": "train.6100", "db_id": "customers_and_addresses", "question": "Return the the \"active to date\" of the latest contact channel used by the customer named \"Tillman Ernser\".", "rationale": ["Identify the customer ID for 'Tillman Ernser' from the Customers table.", "Use the identified customer ID to find the contact channels in the Customer_Contact_Channels table.", "Order the results by active_from_date in descending order to get the latest contact channel.", "Limit the results to 1 to get only the latest contact channel's active_to_date."], "gold_sql": "SELECT max(t2.active_to_date) FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t1.customer_name  =  'Tillman Ernser'", "source_tables": ["customer_contact_channels", "customers"], "pred_sql": "SELECT active_to_date FROM customer_contact_channels WHERE customer_id = (SELECT customer_id FROM customers WHERE customer_name = 'Tillman Ernser') ORDER BY active_from_date DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the channel codes and contact numbers of customer contact channels that have the longest active duration. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n        \"virtual_table\": \"SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n        \"virtual_table\": \"SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n        \"virtual_table\": \"SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6101", "db_id": "customers_and_addresses", "question": "What is the average time span of contact channels in the database?", "rationale": ["Identify the relevant table: The 'Customer_Contact_Channels' table contains the active duration of contact channels.", "Calculate the duration: The duration can be calculated by subtracting 'active_from_date' from 'active_to_date'.", "Use the AVG function: To find the average duration, we can use the AVG function on the calculated duration.", "Construct the SQL query: Combine these elements into a single SQL query that selects the average duration from the 'Customer_Contact_Channels' table."], "gold_sql": "SELECT avg(active_to_date - active_from_date) FROM customer_contact_channels", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT AVG(active_to_date - active_from_date) AS average_duration FROM customer_contact_channels;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the channel codes and contact numbers of customer contact channels that have the longest active duration. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n        \"virtual_table\": \"SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n        \"virtual_table\": \"SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n        \"virtual_table\": \"SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6103", "db_id": "customers_and_addresses", "question": "What is the channel code and contact number of the customer contact channel that was active for the longest time?", "rationale": ["Identify the relevant table: Customer_Contact_Channels contains the channel codes and contact numbers.", "Determine the requirement: We need to find the channel code and contact number of the customer contact channel that was active for the longest time.", "Calculate the duration of activity: This can be done by subtracting active_from_date from active_to_date.", "Use a subquery to find the maximum duration of activity: SELECT MAX(active_to_date - active_from_date) FROM Customer_Contact_Channels will give us the longest active duration.", "Filter the main query using this maximum duration to get the corresponding channel code and contact number."], "gold_sql": "SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT 1)", "source_tables": ["customer_contact_channels"], "pred_sql": "SELECT channel_code, contact_number FROM Customer_Contact_Channels WHERE (active_to_date - active_from_date) = (SELECT MAX(active_to_date - active_from_date) FROM Customer_Contact_Channels)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the channel codes and contact numbers of customer contact channels that have the longest active duration. The placeholder in the LIMIT clause allows for specifying the number of records to retrieve based on the longest active duration.\",\n        \"virtual_table\": \"SELECT channel_code ,  contact_number FROM customer_contact_channels WHERE active_to_date - active_from_date  =  (SELECT active_to_date - active_from_date FROM customer_contact_channels ORDER BY (active_to_date - active_from_date) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n        \"virtual_table\": \"SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the names of customers along with the activation dates of their preferred contact channels. The data is sourced from the 'Customers' table and the 'Customer_Contact_Channels' table, linked by the customer identifier. The placeholder in the WHERE clause represents the specific contact channel code being queried.\",\n        \"virtual_table\": \"SELECT t1.customer_name ,  t2.active_from_date FROM customers AS t1 JOIN customer_contact_channels AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.channel_code  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6108", "db_id": "customers_and_addresses", "question": "Find the name of the customer who made the order of the largest amount of goods.", "rationale": ["Identify the relevant tables: Customers, Customer_Orders, and Order_Items are needed to find the customer who made the largest order.", "Join the Customers table with Customer_Orders on customer_id to link customers to their orders.", "Join the resulting table with Order_Items on order_id to access the quantities of items ordered.", "Group the results by customer_id to aggregate the total quantity of items ordered by each customer.", "Use SUM(oi.order_quantity) to calculate the total amount of goods ordered by each customer.", "Order the results in descending order based on the total quantity ordered to find the customer with the largest order.", "Limit the results to 1 to get only the top customer."], "gold_sql": "SELECT t1.customer_name FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t3.order_quantity  =  ( SELECT max(order_quantity) FROM order_items)", "source_tables": ["customer_orders", "customers", "order_items"], "pred_sql": "SELECT c.customer_name\nFROM Customers c\nJOIN Customer_Orders co ON c.customer_id = co.customer_id\nJOIN Order_Items oi ON co.order_id = oi.order_id\nGROUP BY c.customer_id\nORDER BY SUM(oi.order_quantity) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6123", "db_id": "customers_and_addresses", "question": "What is the total number of products that are in orders with status \"Cancelled\"?", "rationale": ["Identify the relevant tables: We need to look at the Customer_Orders table for order status and the Order_Items table for product information.", "We are interested in orders with a status of 'Cancelled'.", "To find the total number of products in these cancelled orders, we will join the Customer_Orders table with the Order_Items table on the order_id.", "We will count the distinct product_id from the Order_Items table where the corresponding order in Customer_Orders has a status of 'Cancelled'."], "gold_sql": "SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_status  =  'Cancelled'", "source_tables": ["customer_orders", "order_items"], "pred_sql": "SELECT COUNT(DISTINCT oi.product_id) AS total_cancelled_products\nFROM Customer_Orders co\nJOIN Order_Items oi ON co.order_id = oi.order_id\nWHERE co.order_status = 'Cancelled';", "hint": "\n"}
{"sample_id": "train.6130", "db_id": "customers_and_addresses", "question": "What is the most frequently ordered product? Tell me the detail of the product", "rationale": ["Identify the relevant tables: We need to find the most frequently ordered product, which involves the 'Order_Items' and 'Products' tables.", "Count the occurrences of each product in the 'Order_Items' table: We will use COUNT() to count how many times each product has been ordered.", "Join the 'Order_Items' table with the 'Products' table: This will allow us to get the product details along with the order count.", "Group the results by product_id: This is necessary to aggregate the counts for each product.", "Order the results by the count in descending order: This will help us find the most frequently ordered product at the top.", "Limit the results to 1: Since we only want the most frequently ordered product."], "gold_sql": "SELECT t2.product_details FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT Products.product_id, Products.product_details, COUNT(Order_Items.product_id) AS order_count\nFROM Order_Items\nJOIN Products ON Order_Items.product_id = Products.product_id\nGROUP BY Order_Items.product_id\nORDER BY order_count DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6131", "db_id": "customers_and_addresses", "question": "Find the name and ID of the product whose total order quantity is the largest.", "rationale": ["Identify the relevant tables: Products and Order_Items.", "We need to find the product with the largest total order quantity, so we will join the Products table with the Order_Items table on product_id.", "We will group the results by product_id and product_details to aggregate the order quantities for each product.", "Use the SUM function to calculate the total order quantity for each product.", "Order the results in descending order based on the total order quantity to get the product with the largest quantity at the top.", "Limit the results to 1 to get only the product with the largest total order quantity."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT P.product_id, P.product_details\nFROM Products P\nJOIN Order_Items OI ON P.product_id = OI.product_id\nGROUP BY P.product_id, P.product_details\nORDER BY SUM(OI.order_quantity) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6132", "db_id": "customers_and_addresses", "question": "What are the name and ID of the product bought the most.", "rationale": ["Identify the relevant tables: We need to look at the Order_Items table to find out which products were bought and the Products table to get the product details.", "Count the quantity of each product ordered: We will use COUNT() to sum up the order quantities for each product.", "Join the Order_Items table with the Products table: This will allow us to get the product details along with the product ID.", "Group the results by product ID: This is necessary to aggregate the order quantities for each product.", "Order the results by total quantity in descending order: This will help us find the product that was bought the most easily.", "Limit the results to 1: Since we only want the product that was bought the most, we will limit our results to just one entry."], "gold_sql": "SELECT t2.product_details ,  t2.product_id FROM order_items AS t1 JOIN products AS t2 ON t1.product_id  =  t2.product_id GROUP BY t1.product_id ORDER BY sum(t1.order_quantity) LIMIT 1", "source_tables": ["products", "order_items"], "pred_sql": "SELECT oi.product_id, p.product_details, COUNT(oi.order_quantity) AS total_quantity\nFROM Order_Items oi\nJOIN Products p ON oi.product_id = p.product_id\nGROUP BY oi.product_id\nORDER BY total_quantity DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6133", "db_id": "customers_and_addresses", "question": "Find all the addresses in East Julianaside, Texas or in Gleasonmouth, Arizona.", "rationale": ["Identify the relevant table: The question asks for addresses, so we will use the 'Addresses' table.", "Determine the filtering criteria: We need to filter addresses based on two specific cities and their corresponding states: East Julianaside, Texas and Gleasonmouth, Arizona.", "Construct the SQL query: We will use a UNION to combine results from two SELECT statements, one for each city and state combination.", "Use the provided hint to structure the query correctly, ensuring we select 'address_content' from the 'Addresses' table for both conditions."], "gold_sql": "SELECT address_content FROM addresses WHERE city  =  'East Julianaside' AND state_province_county  =  'Texas' UNION SELECT address_content FROM addresses WHERE city  =  'Gleasonmouth' AND state_province_county  =  'Arizona'", "source_tables": ["addresses"], "pred_sql": "SELECT address_content FROM Addresses WHERE city = 'East Julianaside' AND state_province_county = 'Texas' UNION SELECT address_content FROM Addresses WHERE city = 'Gleasonmouth' AND state_province_county = 'Arizona'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the detailed address content from the 'Addresses' table for specific cities and states, allowing for the combination of results from two different queries based on the same criteria. The placeholders in the WHERE clauses represent the city and state names.\",\n        \"virtual_table\": \"SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING] UNION SELECT address_content FROM addresses WHERE city  =  [PLACEHOLDER-TYPE:STRING] AND state_province_county  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6155", "db_id": "music_4", "question": "What are the category of music festivals with result \"Awarded\"?", "rationale": ["Identify the relevant table: The question asks about music festivals and their categories, so we will focus on the 'music_festival' table.", "Determine the required columns: We need the 'Category' column from the 'music_festival' table.", "Apply the filter: We need to filter the results where the 'Result' column is equal to 'Awarded'.", "Construct the SQL query: Combine the selected column and the filter condition into a complete SQL query."], "gold_sql": "SELECT Category FROM music_festival WHERE RESULT  =  'Awarded'", "source_tables": ["music_festival"], "pred_sql": "SELECT Category FROM music_festival WHERE Result = 'Awarded';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\",\n        \"virtual_table\": \"SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6167", "db_id": "music_4", "question": "Please show the songs that have result \"nominated\" at music festivals.", "rationale": ["Identify the tables involved: artist, volume, and music_festival.", "Determine the relationship between the tables: artist is linked to volume via Artist_ID, and volume is linked to music_festival via Volume.", "Select the relevant columns: we need the Famous_Title from the artist table.", "Filter the results based on the condition that the Result in the music_festival table is 'nominated'.", "Use JOINs to combine the tables based on their relationships and apply the WHERE clause for filtering."], "gold_sql": "SELECT T2.Song FROM music_festival AS T1 JOIN volume AS T2 ON T1.Volume  =  T2.Volume_ID WHERE T1.Result  =  'Nominated'", "source_tables": ["music_festival", "volume"], "pred_sql": "SELECT DISTINCT T1.Famous_Title \nFROM artist AS T1 \nJOIN volume AS T2 ON T1.Artist_ID = T2.Artist_ID \nJOIN music_festival AS T3 ON T2.Volume_ID = T3.Volume \nWHERE T3.Result = 'nominated';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\",\n        \"virtual_table\": \"SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6180", "db_id": "music_4", "question": "Return the famous release date for the oldest artist.", "rationale": ["Identify the table that contains the release date of the famous title, which is the 'artist' table.", "Determine that we need to find the oldest artist, which requires sorting the artists by age.", "Use the ORDER BY clause to sort the results by the 'Age' column in ascending order to get the oldest artist first.", "Limit the results to only one entry using LIMIT 1 to get the oldest artist's famous release date."], "gold_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age DESC LIMIT 1", "source_tables": ["artist"], "pred_sql": "SELECT Famous_Release_date FROM artist ORDER BY Age ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\",\n        \"virtual_table\": \"SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6185", "db_id": "music_4", "question": "Please show the categories of the music festivals with count more than 1.", "rationale": ["Identify the table that contains the categories of music festivals, which is the 'music_festival' table.", "To count the occurrences of each category, we will use the COUNT() function and group the results by the 'Category' column.", "We need to filter the results to only include categories that have a count greater than 1, which can be done using the HAVING clause after grouping."], "gold_sql": "SELECT Category FROM music_festival GROUP BY Category HAVING COUNT(*)  >  1", "source_tables": ["music_festival"], "pred_sql": "SELECT Category, COUNT(*) as Count FROM music_festival GROUP BY Category HAVING COUNT(*) > 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\",\n        \"virtual_table\": \"SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6187", "db_id": "music_4", "question": "What is the song in the volume with the maximum weeks on top?", "rationale": ["Identify the table that contains the information about songs and their weeks on top, which is the 'volume' table.", "To find the song in the volume with the maximum weeks on top, we need to select the 'Song' from the 'volume' table.", "We will use a subquery to find the maximum value of 'Weeks_on_Top' from the 'volume' table.", "The main query will select the 'Song' where 'Weeks_on_Top' equals this maximum value."], "gold_sql": "SELECT Song FROM volume ORDER BY Weeks_on_Top DESC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT T2.Song FROM volume AS T2 WHERE T2.Weeks_on_Top = (SELECT MAX(Weeks_on_Top) FROM volume)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\",\n        \"virtual_table\": \"SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6195", "db_id": "music_4", "question": "What is the issue date of the volume with the minimum weeks on top?", "rationale": ["Identify the table that contains the issue date and weeks on top, which is the 'volume' table.", "To find the issue date of the volume with the minimum weeks on top, we need to first determine the minimum value of 'Weeks_on_Top' in the 'volume' table.", "We can use a subquery to select the minimum 'Weeks_on_Top' value.", "Once we have the minimum weeks on top, we can select the corresponding 'Issue_Date' from the 'volume' table where 'Weeks_on_Top' matches this minimum value."], "gold_sql": "SELECT Issue_Date FROM volume ORDER BY Weeks_on_Top ASC LIMIT 1", "source_tables": ["volume"], "pred_sql": "SELECT Issue_Date FROM volume WHERE Weeks_on_Top = (SELECT MIN(Weeks_on_Top) FROM volume);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the famous titles of songs by artists who have had varying success on the charts. It retrieves titles of songs that have spent more than a certain number of weeks at the top of the charts and also those that have spent less than a different specified number of weeks. The placeholders in the WHERE clause represent the numeric values for the weeks spent at the top.\",\n        \"virtual_table\": \"SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  >  [PLACEHOLDER-TYPE:NUMBER] INTERSECT SELECT T1.Famous_Title FROM artist AS T1 JOIN volume AS T2 ON T1.Artist_ID  =  T2.Artist_ID WHERE T2.Weeks_on_Top  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6271", "db_id": "city_record", "question": "What is the match id of the competition called \"1994 FIFA World Cup qualification\"?", "rationale": ["Identify the table that contains the competition information, which is the 'match' table.", "Determine the column that holds the competition name, which is 'Competition'.", "Formulate a subquery to find the Match_ID associated with the competition '1994 FIFA World Cup qualification'.", "Use the outer query to select the Match_ID from the match table where the competition matches the result of the subquery."], "gold_sql": "SELECT match_id FROM MATCH WHERE competition = '1994 FIFA World Cup qualification'", "source_tables": ["match"], "pred_sql": "SELECT Match_ID FROM match WHERE Competition = (SELECT Match_ID FROM match WHERE Competition = '1994 FIFA World Cup qualification')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6274", "db_id": "city_record", "question": "Which city has hosted the most events?", "rationale": ["To find out which city has hosted the most events, we need to count the number of matches hosted by each city.", "The 'hosting_city' table contains the 'Host_City' and 'Match_ID', which we can use to group by city and count the matches.", "We will use the COUNT function to count the number of matches for each city.", "We will group the results by 'Host_City' to get the total number of events hosted by each city.", "Finally, we will order the results in descending order based on the count of events and limit the result to 1 to get the city with the most events."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN hosting_city AS T2 ON T1.city_id  =  T2.host_city GROUP BY T2.host_city ORDER BY count(*) DESC LIMIT 1", "source_tables": ["hosting_city", "city"], "pred_sql": "SELECT Host_City, COUNT(*) as Event_Count FROM hosting_city GROUP BY Host_City ORDER BY Event_Count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6286", "db_id": "city_record", "question": "Which city has the highest temperature in February?", "rationale": ["Identify the relevant tables: We need data from the 'city' table for city names and the 'temperature' table for February temperatures.", "Join the 'city' table with the 'temperature' table on 'City_ID' to combine city names with their corresponding February temperatures.", "Order the results by the February temperature in descending order to get the highest temperature at the top.", "Limit the results to 1 to retrieve only the city with the highest temperature in February."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID ORDER BY T2.Feb DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6287", "db_id": "city_record", "question": "In February, which city marks the highest temperature?", "rationale": ["Identify the relevant tables: We need to look at the 'city' table for city names and the 'temperature' table for temperature data.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access both city names and their February temperatures.", "Order the results by the February temperature in descending order to get the highest temperature at the top.", "Limit the results to 1 to get only the city with the highest temperature in February."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id ORDER BY T2.Feb DESC LIMIT 1", "source_tables": ["city", "temperature"], "pred_sql": "SELECT City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID ORDER BY T2.Feb DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6288", "db_id": "city_record", "question": "Give me a list of cities whose temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: We need data from the 'city' and 'temperature' tables.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Formulate the condition: We want cities where the average temperature in March is lower than in July or higher than in October.", "Use the SQL 'SELECT' statement to retrieve the city names that meet these conditions."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID WHERE T2.Mar < T2.Jul OR T2.Mar > T2.Oct", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6289", "db_id": "city_record", "question": "Which cities' temperature in March is lower than that in July or higher than that in Oct?", "rationale": ["Identify the relevant tables: We need to use the 'city' and 'temperature' tables to get the city names and their temperature data.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Apply the conditions: We need to find cities where the average temperature in March (T2.Mar) is lower than that in July (T2.Jul) or higher than that in October (T2.Oct).", "Construct the SQL query using the SELECT statement to retrieve the city names that meet the specified temperature conditions."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul OR T2.Mar  >  T2.Oct", "source_tables": ["city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID WHERE T2.Mar < T2.Jul OR T2.Mar > T2.Oct", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6292", "db_id": "city_record", "question": "Give me a list of cities whose temperature in Mar is lower than that in Dec and which have never been host cities.", "rationale": ["Identify the cities from the 'city' table that we want to retrieve.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data.", "Filter the results to include only those cities where the average temperature in March (T2.Mar) is lower than the average temperature in December (T2.Dec).", "Additionally, we need to ensure that these cities have never hosted a match, which means their 'City_ID' should not be present in the 'hosting_city' table.", "Use a subquery to select all 'Host_City' from the 'hosting_city' table and exclude those from our main query using NOT IN."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID WHERE T2.Mar < T2.Dec AND T1.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6293", "db_id": "city_record", "question": "Which cities have lower temperature in March than in Dec and have never served as host cities?", "rationale": ["Identify the cities from the 'city' table that have a lower average temperature in March compared to December.", "Join the 'city' table with the 'temperature' table on 'City_ID' to access temperature data for each city.", "Use a WHERE clause to filter cities where the average temperature in March (T2.Mar) is less than the average temperature in December (T2.Dec).", "Additionally, ensure that these cities have never served as host cities by using a NOT IN clause that checks against the 'hosting_city' table for any matching 'Host_City'.", "The final SQL query combines these conditions to retrieve the desired list of cities."], "gold_sql": "SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Dec EXCEPT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city", "source_tables": ["hosting_city", "city", "temperature"], "pred_sql": "SELECT T1.City FROM city AS T1 JOIN temperature AS T2 ON T1.City_ID = T2.City_ID WHERE T2.Mar < T2.Dec AND T1.City_ID NOT IN (SELECT Host_City FROM hosting_city)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies cities that have a lower average temperature in March compared to July and have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies cities where the average temperature in March is lower than in July and that have hosted a match. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Mar  <  T2.Jul INTERSECT SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6298", "db_id": "city_record", "question": "Please give me a list of cities whose regional population is over 8000000 or under 5000000.", "rationale": ["The user wants a list of cities based on their regional population.", "We need to filter cities where the regional population is greater than 8000000 or less than 5000000.", "The SQL query will use the UNION operator to combine results from two SELECT statements: one for populations greater than 8000000 and another for populations less than 5000000.", "The final SQL query selects the 'City' column from the 'city' table with the specified conditions."], "gold_sql": "SELECT city FROM city WHERE regional_population  >  10000000 UNION SELECT city FROM city WHERE regional_population  <  5000000", "source_tables": ["city"], "pred_sql": "SELECT City FROM city WHERE Regional_Population > 8000000 UNION SELECT City FROM city WHERE Regional_Population < 5000000", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the names of cities from the 'city' table where the regional population is either greater than or less than specified numeric values. The placeholders in the WHERE clauses represent the population thresholds for filtering the cities.\",\n        \"virtual_table\": \"SELECT city FROM city WHERE regional_population  >  [PLACEHOLDER-TYPE:NUMBER] UNION SELECT city FROM city WHERE regional_population  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of cities based on specific temperature conditions and hosting events. It retrieves cities where the average temperature in February is greater than in June, and also includes cities that have hosted matches. The placeholders in the query represent the necessary identifiers for the cities and their temperature data.\",\n        \"virtual_table\": \"SELECT T1.city FROM city AS T1 JOIN temperature AS T2 ON T1.city_id  =  T2.city_id WHERE T2.Feb  >  T2.Jun UNION SELECT T3.city FROM city AS T3 JOIN hosting_city AS T4 ON T3.city_id  =  T4.host_city\"\n    }\n}\n"}
{"sample_id": "train.6313", "db_id": "e_government", "question": "What is the name of the party form that is most common?", "rationale": ["Identify the relevant tables: Party_Forms and Forms are needed to get the form names.", "Join the Party_Forms table with the Forms table on the form_id to access the form names.", "Group the results by form_name to count how many times each form appears in Party_Forms.", "Use COUNT(*) to count the occurrences of each form name.", "Order the results in descending order based on the count to find the most common form.", "Limit the results to 1 to get only the most common party form."], "gold_sql": "SELECT t1.form_name FROM forms AS t1 JOIN party_forms AS t2 ON t1.form_id  =  t2.form_id GROUP BY t2.form_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["forms", "party_forms"], "pred_sql": "SELECT form_name, COUNT(*) as form_count \nFROM Party_Forms \nJOIN Forms ON Party_Forms.form_id = Forms.form_id \nGROUP BY form_name \nORDER BY form_count DESC \nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6329", "db_id": "e_government", "question": "What are the names of the services that have never been used?", "rationale": ["Identify the relevant table: The question asks about services, so we will focus on the Services table.", "Determine the condition: We need to find services that have never been used, which means we need to check for services that do not have any entries in the Party_Services table.", "Construct the subquery: We will create a subquery that selects all service_ids from the Party_Services table, as these represent services that have been used.", "Use the NOT IN clause: In the main query, we will select service_name from the Services table where the service_id is not in the list of used service_ids from the subquery."], "gold_sql": "SELECT service_name FROM services EXCEPT SELECT t1.service_name FROM services AS t1 JOIN party_services AS t2 ON t1.service_id  =  t2.service_id", "source_tables": ["services", "party_services"], "pred_sql": "SELECT service_name FROM Services WHERE service_id NOT IN (SELECT service_id FROM Party_Services);", "hint": "\n"}
{"sample_id": "train.6330", "db_id": "e_government", "question": "Find the name of all the cities and states.", "rationale": ["Identify the relevant table: The 'Addresses' table contains the columns for town/city and state/province/county.", "Determine the required columns: We need to retrieve 'town_city' and 'state_province_county'.", "Use UNION to combine the results from both columns to ensure unique entries.", "Construct the SQL query to select 'town_city' from 'Addresses' and then use UNION to select 'state_province_county' from the same table."], "gold_sql": "SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses", "source_tables": ["addresses"], "pred_sql": "SELECT town_city FROM Addresses UNION SELECT state_province_county FROM Addresses", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a combined list of town/city names and state/province/county names from the 'Addresses' table. The use of UNION allows for the retrieval of unique entries from both columns, ensuring that the results do not contain duplicates.\",\n        \"virtual_table\": \"SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses\"\n    }\n}\n"}
{"sample_id": "train.6342", "db_id": "e_government", "question": "Which state can address \"6862 Kaitlyn Knolls\" possibly be in?", "rationale": ["Identify the relevant table: The 'Addresses' table contains the information needed for the query.", "Determine the specific address to search for: The address in question is '6862 Kaitlyn Knolls'.", "Select the state/province/county associated with the specified address: We need to retrieve the 'state_province_county' for the given address.", "Use DISTINCT to ensure that we only get unique state/province/county names, in case there are duplicates."], "gold_sql": "SELECT state_province_county FROM addresses WHERE line_1_number_building LIKE '%6862 Kaitlyn Knolls%'", "source_tables": ["addresses"], "pred_sql": "SELECT DISTINCT state_province_county FROM Addresses WHERE line_1_number_building = '6862 Kaitlyn Knolls'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a combined list of town/city names and state/province/county names from the 'Addresses' table. The use of UNION allows for the retrieval of unique entries from both columns, ensuring that the results do not contain duplicates.\",\n        \"virtual_table\": \"SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses\"\n    }\n}\n"}
{"sample_id": "train.6346", "db_id": "e_government", "question": "Find the last name of the individuals that have been contact individuals of an organization.", "rationale": ["Identify the tables involved: Organizations, Organization_Contact_Individuals, and Individuals.", "Determine the relationship between these tables: Organization_Contact_Individuals links individuals to organizations.", "Select the last name of individuals from the Individuals table.", "Join the Organizations table to get the organization details and the Organization_Contact_Individuals table to link individuals to organizations.", "The query should retrieve all individuals who have contacted any organization, not limited to those with the highest VAT number, so we will not include the WHERE clause for max VAT number."], "gold_sql": "SELECT DISTINCT t1.individual_last_name FROM individuals AS t1 JOIN organization_contact_individuals AS t2 ON t1.individual_id  =  t2.individual_id", "source_tables": ["organization_contact_individuals", "individuals"], "pred_sql": "SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id = t2.organization_id JOIN individuals AS t3 ON t2.individual_id = t3.individual_id", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table retrieves the last names of individuals who have contacted the organization with the highest VAT number. The query joins the 'organizations', 'organization_contact_individuals', and 'individuals' tables to filter the results based on the maximum VAT number and orders the results by the contact end date. The placeholder in the LIMIT clause represents the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT t3.individual_last_name FROM organizations AS t1 JOIN organization_contact_individuals AS t2 ON t1.organization_id  =  t2.organization_id JOIN individuals AS t3 ON t2.individual_id  =  t3.individual_id WHERE t1.uk_vat_number  =  (SELECT max(uk_vat_number) FROM organizations) ORDER BY t2.date_contact_to ASC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6371", "db_id": "flight_company", "question": "What are the names and types of the companies that have ever operated a flight?", "rationale": ["Identify the relevant tables: We need information from the 'operate_company' table for company names and types, and from the 'flight' table to ensure the companies have operated flights.", "Determine the relationship: The 'flight' table has a foreign key 'company_id' that links to the 'operate_company' table's 'id'. This means we can join these two tables on this key.", "Select the required columns: We need to select the 'name' and 'Type' columns from the 'operate_company' table.", "Use DISTINCT to avoid duplicate entries: Since a company may operate multiple flights, we use DISTINCT to ensure each company is listed only once."], "gold_sql": "SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id", "source_tables": ["flight", "operate_company"], "pred_sql": "SELECT DISTINCT oc.name, oc.Type FROM operate_company AS oc JOIN flight AS f ON oc.id = f.company_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the pilots operating flights from companies that engage in specific principal activities. The query uses an INTERSECT operation to find pilots from two different sets of operating companies that share the same principal activities, represented by placeholders in the WHERE clause.\",\n        \"virtual_table\": \"SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T2.pilot FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id WHERE T1.principal_activities  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6375", "db_id": "flight_company", "question": "What is the id, name and IATA code of the airport that had most number of flights?", "rationale": ["Identify the relevant tables: 'airport' and 'flight'.", "We need to find the airport with the most flights, so we will join the 'airport' table with the 'flight' table using the foreign key relationship (airport.id = flight.airport_id).", "Select the required columns: 'id', 'name', and 'IATA' from the 'airport' table.", "Group the results by the airport's id, name, and IATA code to aggregate the flight counts.", "Count the number of flights for each airport using COUNT(flight.id).", "Order the results in descending order based on the flight count to get the airport with the most flights at the top.", "Limit the results to 1 to get only the airport with the highest number of flights."], "gold_sql": "SELECT T1.id ,  T1.name ,  T1.IATA FROM airport AS T1 JOIN flight AS T2 ON T1.id  =  T2.airport_id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airport", "flight"], "pred_sql": "SELECT airport.id, airport.name, airport.IATA\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nGROUP BY airport.id, airport.name, airport.IATA\nORDER BY COUNT(flight.id) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "train.6381", "db_id": "flight_company", "question": "How many companies operates airlines in each airport?", "rationale": ["Identify the relevant tables: airport, operate_company, and flight.", "We need to count the number of companies that operate airlines at each airport.", "Join the airport table with the flight table on airport.id and flight.airport_id.", "Join the resulting table with the operate_company table on flight.company_id and operate_company.id.", "Filter the results to include only those companies that are of type 'airline'.", "Group the results by airport name to get the count of airlines for each airport."], "gold_sql": "SELECT T3.id ,  count(*) FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id JOIN airport AS T3 ON T2.airport_id  =  T3.id GROUP BY T3.id", "source_tables": ["airport", "flight", "operate_company"], "pred_sql": "SELECT airport.name AS Airport_Name, COUNT(operate_company.id) AS Number_of_Airlines\nFROM airport\nJOIN flight ON airport.id = flight.airport_id\nJOIN operate_company ON flight.company_id = operate_company.id\nWHERE operate_company.Type = 'airline'\nGROUP BY airport.name;", "hint": "\n"}
{"sample_id": "train.6517", "db_id": "wine_1", "question": "What is the name of the highest rated wine?", "rationale": ["Identify the table that contains wine information, which is the 'wine' table.", "To find the highest rated wine, we need to order the wines by their score in descending order.", "We will select the 'Name' of the wine from the 'wine' table.", "To get only the highest rated wine, we will limit the results to 1 using 'LIMIT 1'."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n        \"virtual_table\": \"SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.County ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n        \"virtual_table\": \"SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6518", "db_id": "wine_1", "question": "Give the name of the wine with the highest score.", "rationale": ["Identify the table that contains the wine names and their scores, which is the 'wine' table.", "To find the wine with the highest score, we need to order the results by the 'Score' column in descending order.", "Using 'LIMIT 1' will ensure that we only get the top result, which is the wine with the highest score."], "gold_sql": "SELECT Name FROM WINE ORDER BY Score LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Name FROM wine ORDER BY Score DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n        \"virtual_table\": \"SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.County ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n        \"virtual_table\": \"SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6520", "db_id": "wine_1", "question": "What is the winery at which the wine with the highest score was made?", "rationale": ["Identify the table that contains the winery information, which is the 'wine' table.", "Determine that we need to find the wine with the highest score.", "Use a subquery to find the maximum score from the 'wine' table.", "Select the winery from the 'wine' table where the score matches the maximum score found in the subquery."], "gold_sql": "SELECT Winery FROM WINE ORDER BY SCORE LIMIT 1", "source_tables": ["wine"], "pred_sql": "SELECT Winery FROM wine WHERE Score = (SELECT MAX(Score) FROM wine)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n        \"virtual_table\": \"SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.County ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n        \"virtual_table\": \"SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6533", "db_id": "wine_1", "question": "List the names of all distinct wines that are made of red color grape.", "rationale": ["Identify the tables involved: 'wine' and 'grapes'.", "Determine the relationship between the tables: 'wine' table has a foreign key 'Grape' that references 'grapes' table.", "We need to filter wines based on the color of the grape, which is specified in the 'grapes' table.", "Use a JOIN to combine the 'wine' and 'grapes' tables on the grape variety.", "Filter the results where the color of the grape is 'red'.", "Select distinct names of wines from the resulting dataset."], "gold_sql": "SELECT DISTINCT T2.Name FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT T2.Name FROM WINE AS T2 JOIN GRAPES AS T1 ON T1.Grape = T2.Grape WHERE T1.Color = 'red'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n        \"virtual_table\": \"SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of counties from the 'appellations' table that are associated with a specific number of wines produced, as indicated by the placeholder. The query joins the 'appellations' and 'wine' tables on the appellation name, groups the results by appellation, and filters the groups to include only those with a count of wines less than or equal to the specified number.\",\n        \"virtual_table\": \"SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation GROUP BY T2.Appelation HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6544", "db_id": "wine_1", "question": "Give the names and scores of wines made from white grapes.", "rationale": ["Identify the relevant tables: 'grapes' for grape varieties and 'wine' for wine details.", "Determine the required columns: names and scores of wines, which are in the 'wine' table.", "Filter the results based on the color of the grape, which is specified as 'white'.", "Join the 'grapes' table with the 'wine' table on the grape variety to access both tables' data.", "Construct the SQL query to select the wine names and scores where the grape color is white."], "gold_sql": "SELECT T2.Name ,   T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White'", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT T2.Name, T2.Score FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape = T2.Grape WHERE T1.Color = 'white'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n        \"virtual_table\": \"SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n        \"virtual_table\": \"SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.County ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6547", "db_id": "wine_1", "question": "Find the the grape whose white color grapes are used to produce wines with scores higher than 90.", "rationale": ["Identify the relevant tables: 'grapes' for grape varieties and 'wine' for wine scores.", "We need to find grape varieties that are white in color and are used in wines with scores higher than 90.", "Use a JOIN operation to connect the 'grapes' table with the 'wine' table based on the grape variety.", "Filter the results to include only those grapes that are white and have associated wines with scores greater than 90.", "Select distinct grape varieties to avoid duplicates in the results."], "gold_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'White' AND T2.score  >  90", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape = T2.Grape WHERE T1.Color = 'white' AND T2.Score > 90", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n        \"virtual_table\": \"SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n        \"virtual_table\": \"SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.County ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6550", "db_id": "wine_1", "question": "What are the names of wines made from red grapes and with prices above 50?", "rationale": ["Identify the relevant tables: 'wine' and 'grapes'.", "We need to find wines made from red grapes, so we will filter the 'grapes' table by Color = 'red'.", "We also need to filter wines with prices above 50, so we will add a condition for Price > '50' in the 'wine' table.", "Join the 'wine' table with the 'grapes' table on the Grape column to combine the relevant information.", "Select the distinct names of the wines that meet both conditions."], "gold_sql": "SELECT T2.Name FROM Grapes AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  'Red' AND T2.price  >  50", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT DISTINCT T2.Name FROM WINE AS T2 JOIN GRAPES AS T1 ON T1.Grape = T2.Grape WHERE T1.Color = 'red' AND T2.Price > '50'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n        \"virtual_table\": \"SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n        \"virtual_table\": \"SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.County ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6558", "db_id": "wine_1", "question": "What are the distinct names of wines with prices higher than any wine from John Anthony winery.", "rationale": ["Identify the requirement to find distinct names of wines with prices higher than those from John Anthony winery.", "To achieve this, we need to use a subquery to find the maximum price of wines produced by John Anthony winery.", "The main query will select distinct wine names from the 'wine' table where the price is greater than the result of the subquery.", "The subquery will be structured as: SELECT MAX(Price) FROM wine WHERE Winery = 'John Anthony'.", "Finally, we combine these elements into a complete SQL query."], "gold_sql": "SELECT DISTINCT Name FROM WINE WHERE Price  >  (SELECT min(Price) FROM wine WHERE Winery  =  'John Anthony')", "source_tables": ["wine"], "pred_sql": "SELECT DISTINCT Name FROM wine WHERE Price > (SELECT MAX(Price) FROM wine WHERE Winery = 'John Anthony')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n        \"virtual_table\": \"SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.County ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n        \"virtual_table\": \"SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6566", "db_id": "wine_1", "question": "Give the color of the grape whose wine products have the highest average price?", "rationale": ["Identify the tables involved: 'grapes' for grape color and 'wine' for wine prices.", "Join the 'grapes' table with the 'wine' table on the grape variety to access both grape color and wine price.", "Group the results by grape color to calculate the average price of wines for each grape color.", "Order the results by the average price in descending order to find the highest average price.", "Limit the results to 1 to get only the grape color with the highest average price."], "gold_sql": "SELECT T1.Color FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape GROUP BY T2.Grape ORDER BY AVG(Price) DESC LIMIT 1", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT T1.Color FROM grapes AS T1 JOIN wine AS T2 ON T1.Grape = T2.Grape GROUP BY T1.Color ORDER BY AVG(T2.Price) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n        \"virtual_table\": \"SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n        \"virtual_table\": \"SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.County ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6588", "db_id": "wine_1", "question": "Which 3 wineries produce the most wines made from white grapes?", "rationale": ["Identify the relevant tables: 'grapes' for grape color and 'wine' for wineries.", "Join the 'grapes' table with the 'wine' table on the grape variety.", "Filter the results to include only white grapes by specifying 'WHERE T1.Color = 'white' '.", "Group the results by winery name to count the number of wines produced by each winery.", "Order the results in descending order based on the count of wines produced.", "Limit the output to the top 3 wineries that produce the most wines."], "gold_sql": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  'White' GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3", "source_tables": ["wine", "grapes"], "pred_sql": "SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE = T2.GRAPE WHERE T1.Color = 'white' GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT 3", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of wineries that produce wines made from grape varieties of a specific color. The query joins the 'grapes' and 'wine' tables based on the grape variety, filters the results by the specified grape color, groups the results by winery name, and orders them by the number of wines produced, limiting the output to a specified number of wineries.\",\n        \"virtual_table\": \"SELECT T2.Winery FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.GRAPE  =  T2.GRAPE WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Winery ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n        \"virtual_table\": \"SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.County ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6597", "db_id": "wine_1", "question": "Find the county where produces the most number of wines with score higher than 90.", "rationale": ["Identify the tables involved: 'appellations' for county information and 'wine' for wine scores.", "Join the 'appellations' table with the 'wine' table on the appellation field to correlate counties with their wines.", "Filter the results to include only wines with a score greater than 90 using a WHERE clause.", "Group the results by county to count the number of wines per county.", "Order the results in descending order based on the count of wines to find the county with the most high-scoring wines.", "Limit the results to 1 to get only the top county."], "gold_sql": "SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1", "source_tables": ["wine", "appellations"], "pred_sql": "SELECT T1.County FROM appellations AS T1 JOIN wine AS T2 ON T1.Appelation = T2.Appelation WHERE T2.Score > 90 GROUP BY T1.County ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of counties where wines have received a score above a specified threshold. The results are grouped by county and ordered by the number of wines that meet the score criteria, allowing users to identify the most prolific counties for high-scoring wines. The placeholders in the WHERE clause and LIMIT clause represent the score threshold and the maximum number of counties to return, respectively.\",\n        \"virtual_table\": \"SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T2.Score  >  [PLACEHOLDER-TYPE:NUMBER] GROUP BY T1.County ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists distinct grape varieties from the 'grapes' table that have a specific color and are associated with wines that have a score above a certain threshold. The placeholders in the WHERE clause represent the color of the grape and the minimum score for the wine.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.Grape FROM GRAPES AS T1 JOIN WINE AS T2 ON T1.Grape  =  T2.Grape WHERE T1.Color  =  [PLACEHOLDER-TYPE:STRING] AND T2.score  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of counties from the 'appellations' table that are associated with a specific number of wines produced, as indicated by the placeholder. The query joins the 'appellations' and 'wine' tables on the appellation name, groups the results by appellation, and filters the groups to include only those with a count of wines less than or equal to the specified number.\",\n        \"virtual_table\": \"SELECT T1.County FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation GROUP BY T2.Appelation HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6626", "db_id": "driving_school", "question": "Show the detail of vehicle with id 1.", "rationale": ["Identify the table that contains vehicle details, which is the Vehicles table.", "Determine the specific vehicle we want to retrieve details for, which is identified by vehicle_id '1'.", "Construct a SQL SELECT statement to retrieve all columns from the Vehicles table where the vehicle_id matches '1'."], "gold_sql": "SELECT vehicle_details FROM Vehicles WHERE vehicle_id = 1;", "source_tables": ["vehicles"], "pred_sql": "SELECT * FROM Vehicles WHERE vehicle_id = '1';", "hint": "\n"}
{"sample_id": "train.6650", "db_id": "driving_school", "question": "How many staff live in state Georgia?", "rationale": ["Identify the relevant tables: Staff and Addresses.", "Determine the relationship between the tables: Staff has a foreign key linking to Addresses via staff_address_id.", "We need to count the number of staff members, so we will use COUNT(*) function.", "Filter the results to only include staff members who live in the state of Georgia by adding a WHERE clause that checks the state_province_county column in the Addresses table."], "gold_sql": "SELECT count(*) FROM Addresses WHERE state_province_county = 'Georgia';", "source_tables": ["addresses"], "pred_sql": "SELECT COUNT(*) FROM Staff AS T1 JOIN Addresses AS T2 ON T1.staff_address_id = T2.address_id WHERE T2.state_province_county = 'Georgia';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the number of staff members located in each city, derived from the 'Addresses' and 'Staff' tables. The placeholder in the LIMIT clause allows the user to specify the maximum number of cities to display based on the count of staff members.\",\n        \"virtual_table\": \"SELECT T1.city ,  count(*) FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY T1.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.6665", "db_id": "driving_school", "question": "What is the status code, phone number, and email address of the customer whose last name is Kohler or whose first name is Marina?", "rationale": ["Identify the relevant table: The question asks for customer information, so we will use the Customers table.", "Determine the required columns: We need to retrieve the status code, phone number, and email address of the customer.", "Formulate the WHERE clause: The condition specifies that we are looking for customers with the last name 'Kohler' or the first name 'Marina'.", "Construct the SQL query: Combine the selected columns and the WHERE clause to form the complete SQL query."], "gold_sql": "SELECT customer_status_code ,  cell_mobile_phone_number ,  email_address FROM Customers WHERE first_name = 'Marina' OR last_name  =  'Kohler'", "source_tables": ["customers"], "pred_sql": "SELECT customer_status_code, phone_number, email_address FROM Customers WHERE last_name = 'Kohler' OR first_name = 'Marina';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of lessons attended by a specific customer identified by their first and last name, along with the status of those lessons. The placeholders in the WHERE clause represent the customer's first name, last name, and the lesson status code.\",\n        \"virtual_table\": \"SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = [PLACEHOLDER-TYPE:STRING] AND T2.last_name = [PLACEHOLDER-TYPE:STRING] AND T1.lesson_status_code = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.6676", "db_id": "driving_school", "question": "How many lessons taken by customer with first name as Rylan and last name as Goodwin were completed?", "rationale": ["Identify the tables involved: Lessons and Customers.", "Determine the relationship between the tables: Lessons has a foreign key referencing Customers.", "We need to count the number of lessons, so we will use the COUNT function.", "Filter the results based on the customer's first name and last name, which are provided in the input.", "Additionally, filter the lessons by their status to only include completed lessons."], "gold_sql": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = 'Rylan' AND T2.last_name = 'Goodwin' AND T1.lesson_status_code = 'Completed';", "source_tables": ["lessons", "customers"], "pred_sql": "SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = 'Rylan' AND T2.last_name = 'Goodwin' AND T1.lesson_status_code = 'completed';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of lessons attended by a specific customer identified by their first and last name, along with the status of those lessons. The placeholders in the WHERE clause represent the customer's first name, last name, and the lesson status code.\",\n        \"virtual_table\": \"SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = [PLACEHOLDER-TYPE:STRING] AND T2.last_name = [PLACEHOLDER-TYPE:STRING] AND T1.lesson_status_code = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.6688", "db_id": "driving_school", "question": "Which city does has most number of customers?", "rationale": ["Identify the relevant tables: Customers and Addresses.", "We need to count the number of customers in each city, so we will join the Customers table with the Addresses table on the address_id.", "Use COUNT(*) to count the number of customers for each city.", "Group the results by city to get the count per city.", "Order the results in descending order based on the count of customers to find the city with the most customers.", "Limit the results to 1 to get only the city with the highest count."], "gold_sql": "SELECT T2.city FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id GROUP BY T2.city ORDER BY count(*) DESC LIMIT 1;", "source_tables": ["addresses", "customers"], "pred_sql": "SELECT T1.city, COUNT(*) AS customer_count FROM Addresses AS T1 JOIN Customers AS T2 ON T1.address_id = T2.customer_address_id GROUP BY T1.city ORDER BY customer_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the number of staff members located in each city, derived from the 'Addresses' and 'Staff' tables. The placeholder in the LIMIT clause allows the user to specify the maximum number of cities to display based on the count of staff members.\",\n        \"virtual_table\": \"SELECT T1.city ,  count(*) FROM Addresses AS T1 JOIN Staff AS T2 ON T1.address_id = T2.staff_address_id GROUP BY T1.city ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "train.6711", "db_id": "driving_school", "question": "What are the last names that are used by customers and staff?", "rationale": ["Identify the tables that contain last names: Customers and Staff.", "Use the SELECT statement to retrieve last names from both tables.", "Use DISTINCT to ensure unique last names are returned from each table.", "Combine the results from both tables using UNION to get a single list of last names."], "gold_sql": "SELECT last_name FROM Customers INTERSECT SELECT last_name FROM Staff", "source_tables": ["staff", "customers"], "pred_sql": "SELECT DISTINCT last_name FROM Customers UNION SELECT DISTINCT last_name FROM Staff;", "hint": "\n"}
{"sample_id": "train.6714", "db_id": "driving_school", "question": "What is the id and detail of the vehicle used in lessons for most of the times?", "rationale": ["We need to find the vehicle used in lessons the most times.", "To do this, we will count the number of lessons for each vehicle.", "We will group the results by vehicle_id to get the count of lessons for each vehicle.", "Then, we will order the results in descending order based on the count of lessons.", "Finally, we will limit the results to get only the vehicle with the highest count of lessons.", "We will select the vehicle_id and vehicle_details from the Vehicles table for the identified vehicle."], "gold_sql": "SELECT T1.vehicle_id ,  T1.vehicle_details FROM Vehicles AS T1 JOIN Lessons AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T1.vehicle_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["lessons", "vehicles"], "pred_sql": "SELECT vehicle_id, vehicle_details FROM Vehicles WHERE vehicle_id IN (SELECT vehicle_id FROM Lessons GROUP BY vehicle_id ORDER BY COUNT(*) DESC LIMIT 1);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of lessons attended by a specific customer identified by their first and last name, along with the status of those lessons. The placeholders in the WHERE clause represent the customer's first name, last name, and the lesson status code.\",\n        \"virtual_table\": \"SELECT count(*) FROM Lessons AS T1 JOIN Customers AS T2 ON T1.customer_id  = T2.customer_id WHERE T2.first_name = [PLACEHOLDER-TYPE:STRING] AND T2.last_name = [PLACEHOLDER-TYPE:STRING] AND T1.lesson_status_code = [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "train.6725", "db_id": "activity_1", "question": "Show ids for all the male faculty.", "rationale": ["Identify the table that contains faculty information, which is the 'Faculty' table.", "Determine the relevant column for gender, which is 'Sex'.", "Specify the condition to filter for male faculty members by using 'WHERE Sex = 'Male' '.", "Select the unique identifier for faculty members, which is 'FacID'.", "Combine these elements to form the SQL query."], "gold_sql": "SELECT FacID FROM Faculty WHERE Sex  =  'M'", "source_tables": ["faculty"], "pred_sql": "SELECT FacID FROM Faculty WHERE Sex = 'Male'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6734", "db_id": "activity_1", "question": "What are the first name and last name of all the instructors?", "rationale": ["Identify the table that contains the first and last names of instructors, which is the Faculty table.", "Select the columns Fname and Lname from the Faculty table to get the first and last names of all instructors.", "No filtering conditions are needed since we want all instructors, so we will not use a WHERE clause."], "gold_sql": "SELECT fname ,  lname FROM Faculty WHERE Rank  =  'Instructor'", "source_tables": ["faculty"], "pred_sql": "SELECT Fname, Lname FROM Faculty", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6737", "db_id": "activity_1", "question": "Which building has most faculty members?", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their building location.", "Count the number of faculty members in each building: Use COUNT(*) to count faculty members grouped by their building.", "Order the results: Use ORDER BY to sort the buildings by the count of faculty members in descending order.", "Limit the results: Use LIMIT 1 to get only the building with the most faculty members."], "gold_sql": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1", "source_tables": ["faculty"], "pred_sql": "SELECT Building, COUNT(*) as FacultyCount FROM Faculty GROUP BY Building ORDER BY FacultyCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n        \"virtual_table\": \"SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n        \"virtual_table\": \"SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6747", "db_id": "activity_1", "question": "Show the number of male and female assistant professors.", "rationale": ["Identify the relevant table: The Faculty table contains information about faculty members, including their rank and sex.", "Filter for assistant professors: We need to focus on faculty members whose rank is 'Assistant Professor'.", "Group by gender: To get the count of male and female assistant professors, we will group the results by the 'Sex' column.", "Count the number of faculty members in each gender group: We will use the COUNT() function to count the number of faculty members in each gender group."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) as count FROM Faculty WHERE Rank = 'Assistant Professor' GROUP BY Sex;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6748", "db_id": "activity_1", "question": "How many male and female assistant professors do we have?", "rationale": ["Identify the relevant table: We need to look at the Faculty table to find assistant professors and their gender.", "Filter for assistant professors: We will add a condition to select only those faculty members whose Rank is 'Assistant Professor'.", "Group by gender: To count the number of male and female assistant professors, we will group the results by the Sex column.", "Count the number of faculty members: We will use the COUNT() function to get the number of assistant professors for each gender."], "gold_sql": "SELECT sex ,  count(*) FROM Faculty WHERE rank  =  'AsstProf' GROUP BY sex", "source_tables": ["faculty"], "pred_sql": "SELECT Sex, COUNT(*) as count FROM Faculty WHERE Rank = 'Assistant Professor' GROUP BY Sex", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6750", "db_id": "activity_1", "question": "Who is the advisor of Linda Smith? Give me the first name and last name.", "rationale": ["Identify the student by their first and last name, which are 'Linda' and 'Smith'.", "Query the Student table to find the unique identifier (StuID) for Linda Smith.", "Once we have the StuID, we can find the advisor by looking up the advisor field in the Student table.", "The advisor field contains the FacID of the faculty member who is the advisor for Linda Smith."], "gold_sql": "SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T2.fname  =  'Linda' AND T2.lname  =  'Smith'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT Fname, Lname FROM Student WHERE Fname = 'Linda' AND Lname = 'Smith'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6751", "db_id": "activity_1", "question": "Show the ids of students whose advisors are professors.", "rationale": ["Identify the relevant tables: We need to find students and their advisors, which involves the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references the 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the subquery: We need to select the 'FacID' from the Faculty table to find all faculty members who can be advisors.", "Use the subquery in the main query: We will select 'StuID' from the Student table where the 'Advisor' matches any 'FacID' from the Faculty table."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT StuID FROM Student WHERE Advisor IN (SELECT FacID FROM Faculty)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n        \"virtual_table\": \"SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n        \"virtual_table\": \"SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6752", "db_id": "activity_1", "question": "Which students have professors as their advisors? Find their student ids.", "rationale": ["Identify the relevant tables: We need to find students and their advisors, so we will use the Student and Faculty tables.", "Determine the relationship: The Student table has a column 'Advisor' that references the 'FacID' in the Faculty table, indicating which faculty member is the advisor for each student.", "Construct the subquery: We need to select the 'FacID' from the Faculty table to ensure we are only considering valid faculty members as advisors.", "Use the subquery in the main query: We will select 'StuID' from the Student table where the 'Advisor' is in the list of 'FacID' from the Faculty table."], "gold_sql": "SELECT T2.StuID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.rank  =  'Professor'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT StuID FROM Student WHERE Advisor IN (SELECT FacID FROM Faculty)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    }\n}\n"}
{"sample_id": "train.6753", "db_id": "activity_1", "question": "Show first name and last name for all the students advised by Michael Goodrich.", "rationale": ["Identify the tables needed: We need data from the Student table for student names and the Faculty table to find the advisor's name.", "Join the Student table with the Faculty table on the advisor's ID (Advisor in Student table and FacID in Faculty table).", "Filter the results to only include students whose advisor's first name is 'Michael' and last name is 'Goodrich'.", "Select the first name and last name of the students from the joined tables."], "gold_sql": "SELECT T2.fname ,  T2.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor WHERE T1.fname  =  'Michael' AND T1.lname  =  'Goodrich'", "source_tables": ["faculty", "student"], "pred_sql": "SELECT S.Fname, S.LName \nFROM Student AS S \nJOIN Faculty AS F ON S.Advisor = F.FacID \nWHERE F.Fname = 'Michael' AND F.Lname = 'Goodrich';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the first names, last names, and contact phone numbers of faculty members from the 'Faculty' table who belong to a specific gender. The placeholder in the WHERE clause represents the gender of the faculty members.\",\n        \"virtual_table\": \"SELECT Fname ,  Lname ,  phone FROM Faculty WHERE Sex  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6756", "db_id": "activity_1", "question": "What are the faculty id and the number of students each faculty has?", "rationale": ["Identify the relevant tables: Faculty, Student, and Participates_in.", "We need to count the number of students associated with each faculty member, which involves joining the Faculty table with the Student table on the advisor relationship.", "Next, we join the Student table with the Participates_in table to count how many students participate in activities.", "Use LEFT JOIN to ensure we include faculty members even if they have no students advising them.", "Group the results by Faculty ID to get the count of students for each faculty member."], "gold_sql": "SELECT T1.FacID ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID", "source_tables": ["faculty", "student"], "pred_sql": "SELECT F.FacID, COUNT(P.stuid) AS student_count \nFROM Faculty AS F \nLEFT JOIN Student AS S ON F.FacID = S.Advisor \nLEFT JOIN Participates_in AS P ON S.StuID = P.stuid \nGROUP BY F.FacID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n        \"virtual_table\": \"SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6758", "db_id": "activity_1", "question": "How many students are advised by each rank of faculty? List the rank and the number of students.", "rationale": ["Identify the tables involved: Faculty and Student.", "Determine the relationship: Faculty members advise students, which is indicated by the Advisor field in the Student table.", "We need to count the number of students for each rank of faculty, so we will join the Faculty table with the Student table on the advisor relationship.", "Select the Rank from the Faculty table and count the number of students from the Student table.", "Group the results by faculty rank to get the count of students advised by each rank."], "gold_sql": "SELECT T1.rank ,  count(*) FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.rank", "source_tables": ["faculty", "student"], "pred_sql": "SELECT F.Rank, COUNT(S.StuID) AS NumberOfStudents\nFROM Faculty AS F\nJOIN Student AS S ON F.FacID = S.Advisor\nGROUP BY F.Rank;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n        \"virtual_table\": \"SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n        \"virtual_table\": \"SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6761", "db_id": "activity_1", "question": "Show the ids for all the faculty members who have at least 2 students.", "rationale": ["Identify the relevant tables: Faculty and Student.", "We need to find faculty members who are advisors to students, so we will join the Faculty table with the Student table on the advisor ID.", "Group the results by faculty ID to count how many students each faculty member advises.", "Use the HAVING clause to filter the groups to only include those with at least 2 students."], "gold_sql": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID HAVING count(*)  >=  2", "source_tables": ["faculty", "student"], "pred_sql": "SELECT T1.FacID FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID = T2.Advisor GROUP BY T1.FacID HAVING COUNT(T2.StuID) >= 2", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of buildings where faculty members of a specific academic rank are located. The query groups the results by building and filters to include only those buildings that have a certain number of faculty members, as indicated by the placeholders.\",\n        \"virtual_table\": \"SELECT building FROM Faculty WHERE rank  =  [PLACEHOLDER-TYPE:STRING] GROUP BY building HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6777", "db_id": "activity_1", "question": "Show the names of all the activities Mark Giuliano participates in.", "rationale": ["Identify the relevant tables: Activity, Participates_in, and Student.", "We need to join these tables to get the activity names associated with the student named Mark Giuliano.", "Join Activity with Participates_in on actid to link activities with student participation.", "Join Participates_in with Student on stuid to filter by the specific student.", "Use a WHERE clause to specify the first name as 'Mark' and last name as 'Giuliano'.", "Select the activity_name from the resulting joined table."], "gold_sql": "SELECT T3.activity_name FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN Activity AS T3 ON T3.actid  =  T2.actid WHERE T1.fname  =  'Mark' AND T1.lname  =  'Giuliano'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT T1.activity_name \nFROM Activity AS T1 \nJOIN Participates_in AS T2 ON T1.actid = T2.actid \nJOIN Student AS T3 ON T2.stuid = T3.StuID \nWHERE T3.Fname = 'Mark' AND T3.LName = 'Giuliano';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clauses represent the names of the activities being queried.\",\n        \"virtual_table\": \"SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to ensure that only faculty members who are involved in the same activity are selected. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6779", "db_id": "activity_1", "question": "Show the first and last name of all the faculty members who participated in some activity, together with the number of activities they participated in.", "rationale": ["Identify the tables needed: Faculty and Faculty_Participates_in.", "Select the first name (Fname) and last name (Lname) from the Faculty table.", "Count the number of activities each faculty member participated in using COUNT() on the actid from Faculty_Participates_in.", "Join the Faculty table with Faculty_Participates_in on the FacID to link faculty members with their activities.", "Group the results by FacID to ensure we get a count of activities per faculty member."], "gold_sql": "SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID", "source_tables": ["faculty", "faculty_participates_in"], "pred_sql": "SELECT T1.Fname, T1.Lname, COUNT(T2.actid) AS activity_count \nFROM Faculty AS T1 \nJOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID \nGROUP BY T1.FacID", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to ensure that only faculty members who are involved in the same activity are selected. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6789", "db_id": "activity_1", "question": "Show the ids for all the students who participate in an activity and are under 20.", "rationale": ["Identify the relevant tables: We need to find students who participate in activities, so we will use the 'Participates_in' and 'Student' tables.", "Determine the join condition: We will join 'Participates_in' with 'Student' on the student ID (stuid = StuID).", "Apply the age filter: We need to filter students who are under 20 years old, which means we will add a condition in the WHERE clause to check if Student.Age < 20.", "Select the required field: We only need the student IDs (stuid), so we will select that field from the result."], "gold_sql": "SELECT StuID FROM Participates_in INTERSECT SELECT StuID FROM Student WHERE age  <  20", "source_tables": ["student", "participates_in"], "pred_sql": "SELECT stuid FROM Participates_in JOIN Student ON Participates_in.stuid = Student.StuID WHERE Student.Age < 20;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clauses represent the names of the activities being queried.\",\n        \"virtual_table\": \"SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    }\n}\n"}
{"sample_id": "train.6797", "db_id": "activity_1", "question": "Find the first names of professors who are not playing Canoeing or Kayaking.", "rationale": ["Identify the main goal: Find first names of professors who are not participating in Canoeing or Kayaking.", "To achieve this, we need to select the first names from the Faculty table.", "We will use a subquery to find faculty members who are participating in either Canoeing or Kayaking.", "The subquery will join the Faculty_Participates_in table with the Activity table to filter by activity names.", "We will use the NOT IN clause to exclude those faculty members from our main query."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.fname \nFROM Faculty AS F \nWHERE F.FacID NOT IN (\n    SELECT FP.FacID \n    FROM Faculty_Participates_in AS FP \n    JOIN Activity AS A ON FP.actid = A.actid \n    WHERE A.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to ensure that only faculty members who are involved in the same activity are selected. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6798", "db_id": "activity_1", "question": "What are the first names of the professors who do not play Canoeing or Kayaking as activities?", "rationale": ["Identify the table that contains faculty information, which is the 'Faculty' table.", "We need to select the first names of faculty members, so we will select 'F.fname' from the 'Faculty' table.", "To find faculty who do not participate in Canoeing or Kayaking, we will use a subquery to filter out those faculty members.", "The subquery will select the 'FacID' from the 'Faculty_Participates_in' table, joining it with the 'Activity' table to check for activities named 'Canoeing' or 'Kayaking'.", "We will use the NOT IN clause to exclude those faculty members from our main query."], "gold_sql": "SELECT lname FROM faculty WHERE rank  =  'Professor' EXCEPT SELECT DISTINCT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' OR T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT F.fname \nFROM Faculty AS F \nWHERE F.FacID NOT IN (\n    SELECT FP.FacID \n    FROM Faculty_Participates_in AS FP \n    JOIN Activity AS A ON FP.actid = A.actid \n    WHERE A.activity_name IN ('Canoeing', 'Kayaking')\n);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to ensure that only faculty members who are involved in the same activity are selected. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6799", "db_id": "activity_1", "question": "Find the first names of the faculty members who participate in Canoeing and Kayaking.", "rationale": ["Identify the tables needed: Faculty, Faculty_Participates_in, and Activity.", "We need to join these tables to get the first names of faculty members who participate in specific activities.", "Join Faculty with Faculty_Participates_in on FacID to link faculty members to their activities.", "Join the result with Activity on actid to filter by activity names.", "Use a WHERE clause to specify the activities of interest: 'Canoeing' and 'Kayaking'.", "Select the first names (fname) of the faculty members from the Faculty table."], "gold_sql": "SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Canoeing' INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  'Kayaking'", "source_tables": ["activity", "faculty", "faculty_participates_in"], "pred_sql": "SELECT T1.fname FROM Faculty AS T1 JOIN Faculty_Participates_in AS T2 ON T1.FacID = T2.FacID JOIN Activity AS T3 ON T2.actid = T3.actid WHERE T3.activity_name IN ('Canoeing', 'Kayaking')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table summarizes the first names and last names of faculty members along with the count of activities they participate in. The data is retrieved from the 'Faculty' table and is grouped by each faculty member's unique identifier. The placeholders represent the faculty member's first name, last name, and the count of their participation in activities.\",\n        \"virtual_table\": \"SELECT  T1.fname ,  T1.lname ,  count(*) ,  T1.FacID FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID GROUP BY T1.FacID\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the last names of faculty members who participate in a specific activity. The query uses an INTERSECT operation to ensure that only faculty members who are involved in the same activity are selected. The placeholders in the WHERE clause represent the name of the activity.\",\n        \"virtual_table\": \"SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.lname FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID JOIN activity AS T3 ON T2.actid  =  T2.actid WHERE T3.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "train.6801", "db_id": "activity_1", "question": "Find the ids of the students who participate in Canoeing and Kayaking.", "rationale": ["Identify the activities of interest: Canoeing and Kayaking.", "Use the virtual table structure provided to create a query that finds students participating in both activities.", "Join the Participates_in table with the Activity table to filter by activity names.", "Use the INTERSECT operator to find students who are in both activity results."], "gold_sql": "SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Canoeing' INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  'Kayaking'", "source_tables": ["activity", "participates_in"], "pred_sql": "SELECT T1.stuid FROM Participates_in AS T1 JOIN Activity AS T2 ON T1.actid = T2.actid WHERE T2.activity_name = 'Canoeing' INTERSECT SELECT T1.stuid FROM Participates_in AS T1 JOIN Activity AS T2 ON T1.actid = T2.actid WHERE T2.activity_name = 'Kayaking'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies students who participate in two specific activities from the 'Activity' table. The placeholders in the WHERE clauses represent the names of the activities being queried.\",\n        \"virtual_table\": \"SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT T1.stuid FROM participates_in AS T1 JOIN activity AS T2 ON T2.actid  =  T2.actid WHERE T2.activity_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first and last names of faculty members who serve as advisors to students. The results are grouped by faculty ID and ordered by the number of students they advise, with a limit on the number of faculty members returned based on a specified number.\",\n        \"virtual_table\": \"SELECT T1.fname ,  T1.lname FROM Faculty AS T1 JOIN Student AS T2 ON T1.FacID  =  T2.advisor GROUP BY T1.FacID ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6825", "db_id": "flight_4", "question": "Find the number of routes operated by American Airlines.", "rationale": ["Identify the relevant table: The 'routes' table contains information about the routes operated by airlines.", "Determine the specific airline: The query is focused on 'American Airlines'.", "Count the number of routes: Use the COUNT() function to count the number of entries in the 'routes' table where the airline is 'American Airlines'.", "Construct the SQL query: Combine these elements into a SQL query that counts the routes for American Airlines."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT COUNT(*) AS number_of_routes FROM routes WHERE airline = 'American Airlines';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6826", "db_id": "flight_4", "question": "How many routes does American Airlines operate?", "rationale": ["Identify the relevant table: The 'routes' table contains information about the routes operated by airlines.", "Determine the specific airline: The question asks about 'American Airlines'.", "Count the number of routes: Use the COUNT() function to count the number of entries in the 'routes' table where the airline is 'American Airlines'.", "Construct the SQL query: Combine these elements into a SQL query that counts the routes for American Airlines."], "gold_sql": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT COUNT(*) AS route_count FROM routes WHERE airline = 'American Airlines';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6831", "db_id": "flight_4", "question": "Find the name, city, and country of the airport that has the highest latitude.", "rationale": ["Identify the relevant table: The 'airports' table contains the necessary information about airport names, cities, and countries.", "Determine the criteria for selection: We need to find the airport with the highest latitude, which corresponds to the highest value in the 'y' coordinate column.", "Construct the SQL query: We will select the 'name', 'city', and 'country' columns from the 'airports' table.", "Order the results by the 'y' column in descending order to get the highest latitude first.", "Limit the results to 1 to get only the airport with the highest latitude."], "gold_sql": "SELECT name ,  city ,  country FROM airports ORDER BY elevation DESC LIMIT 1", "source_tables": ["airports"], "pred_sql": "SELECT name, city, country FROM airports ORDER BY y DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of cities from the 'airports' table that are located in a specific country. The results are grouped by city, and only those cities with more than a specified number of airports are included. The placeholders in the WHERE clause represent the country's name, and the HAVING clause represents the minimum count of airports required for a city to be included in the results.\",\n        \"virtual_table\": \"SELECT city FROM airports WHERE country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6834", "db_id": "flight_4", "question": "What is the name and city of the airport that the most routes end at?", "rationale": ["Identify the relevant tables: 'airports' for airport details and 'routes' for route information.", "We need the name and city of the airport where the most routes end, which means we will focus on the destination airports in the 'routes' table.", "Join the 'airports' table with the 'routes' table on the destination airport ID (T1.apid = T2.dst_apid).", "Group the results by destination airport ID to aggregate the count of routes for each destination airport.", "Order the results by the count of routes in descending order to get the airport with the most routes at the top.", "Limit the results to 1 to get only the top result."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT T1.name, T1.city FROM airports AS T1 JOIN routes AS T2 ON T1.apid = T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6838", "db_id": "flight_4", "question": "What is the name and city of the airport from most of the routes start?", "rationale": ["Identify the relevant tables: 'airports' for airport details and 'routes' for route information.", "Join the 'airports' table with the 'routes' table on the source airport ID to get the names and cities of source airports.", "Group the results by the source airport ID to aggregate the number of routes starting from each airport.", "Order the results by the count of routes in descending order to find the airport with the most routes starting from it.", "Limit the results to 1 to get only the top airport with the most routes."], "gold_sql": "SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT T1.name, T1.city FROM airports AS T1 JOIN routes AS T2 ON T1.apid = T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6841", "db_id": "flight_4", "question": "Which countries has the most number of airlines?", "rationale": ["The question asks for countries with the most number of airlines.", "We need to count the number of active airlines in each country.", "The airlines table has a column 'country' and a column 'active' to filter for active airlines.", "We will group the results by 'country' and count the number of airlines in each group.", "Finally, we will order the results in descending order based on the count of airlines."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country, COUNT(*) as airline_count FROM airlines WHERE active = 1 GROUP BY country ORDER BY airline_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, sorted by the number of active airlines in descending order.\",\n        \"virtual_table\": \"SELECT country FROM airlines WHERE active  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, ordered by the number of active airlines in descending order.\",\n        \"virtual_table\": \"SELECT country FROM airlines WHERE active  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of cities from the 'airports' table that are located in a specific country. The results are grouped by city, and only those cities with more than a specified number of airports are included. The placeholders in the WHERE clause represent the country's name, and the HAVING clause represents the minimum count of airports required for a city to be included in the results.\",\n        \"virtual_table\": \"SELECT city FROM airports WHERE country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6842", "db_id": "flight_4", "question": "What is the name of the country with the most number of home airlines?", "rationale": ["The question asks for the country with the most number of home airlines.", "We need to filter for active airlines, which is indicated by the 'active' column in the airlines table.", "We will group the results by country to count the number of airlines in each country.", "To find the country with the most airlines, we will order the results by the count of airlines in descending order.", "Finally, we will limit the results to only return the top country, which is done using LIMIT 1."], "gold_sql": "SELECT country FROM airlines GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airlines"], "pred_sql": "SELECT country FROM airlines WHERE active = '1' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, sorted by the number of active airlines in descending order.\",\n        \"virtual_table\": \"SELECT country FROM airlines WHERE active  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, ordered by the number of active airlines in descending order.\",\n        \"virtual_table\": \"SELECT country FROM airlines WHERE active  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6858", "db_id": "flight_4", "question": "What are the cities that have more than 2 airports sorted by number of airports?", "rationale": ["Identify the requirement to find cities with more than 2 airports.", "Use the 'airports' table to group by 'city'.", "Count the number of airports in each city using the COUNT function.", "Filter the results to include only those cities where the count of airports is greater than 2 using the HAVING clause.", "Sort the results by the number of airports in descending order using the ORDER BY clause."], "gold_sql": "SELECT city FROM airports GROUP BY city HAVING count(*)  >  2 ORDER BY count(*)", "source_tables": ["airports"], "pred_sql": "SELECT city FROM airports GROUP BY city HAVING count(*) > 2 ORDER BY count(*) DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of cities that have more than a specified number of airports. The placeholder in the HAVING clause represents the minimum count of airports required for a city to be included in the results.\",\n        \"virtual_table\": \"SELECT city FROM airports GROUP BY city HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER] ORDER BY count(*)\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of cities from the 'airports' table that are located in a specific country. The results are grouped by city, and only those cities with more than a specified number of airports are included. The placeholders in the WHERE clause represent the country's name, and the HAVING clause represents the minimum count of airports required for a city to be included in the results.\",\n        \"virtual_table\": \"SELECT city FROM airports WHERE country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY city HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6862", "db_id": "flight_4", "question": "For each  airport name, how many routes start at that airport, ordered from most to least?", "rationale": ["We need to count the number of routes that start at each airport.", "To do this, we will join the 'airports' table with the 'routes' table on the source airport ID ('src_apid').", "We will select the airport name and count the number of routes (using COUNT(routes.rid)).", "We will group the results by airport name to get the count for each airport.", "Finally, we will order the results by the count of routes in descending order to show the airports with the most routes first."], "gold_sql": "SELECT count(*) ,  T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T1.name ORDER BY count(*) DESC", "source_tables": ["airports", "routes"], "pred_sql": "SELECT airports.name, COUNT(routes.rid) AS route_count \nFROM airports \nJOIN routes ON airports.apid = routes.src_apid \nGROUP BY airports.name \nORDER BY route_count DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6867", "db_id": "flight_4", "question": "For each country and airline name, how many routes are there?", "rationale": ["The question asks for the number of routes for each country and airline name.", "To get this information, we need to join the 'routes' table with the 'airlines' table on the airline ID (alid).", "We will select the country from the airlines table and the airline name, along with a count of the route IDs (rid) from the routes table.", "We will group the results by country and airline name to get the count of routes for each combination.", "Finally, we will use COUNT() to count the number of routes for each group."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT a.country, r.airline, COUNT(r.rid) AS route_count \nFROM routes AS r \nJOIN airlines AS a ON r.alid = a.alid \nGROUP BY a.country, r.airline;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, sorted by the number of active airlines in descending order.\",\n        \"virtual_table\": \"SELECT country FROM airlines WHERE active  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, ordered by the number of active airlines in descending order.\",\n        \"virtual_table\": \"SELECT country FROM airlines WHERE active  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6868", "db_id": "flight_4", "question": "What is the total number of routes for each country and airline in that country?", "rationale": ["We need to find the total number of routes for each country and airline in that country.", "To achieve this, we will join the 'routes' table with the 'airlines' table to get the airline names and with the 'airports' table to get the country information.", "We will select the country from the airports table, the airline name from the airlines table, and count the number of routes (using the route ID) from the routes table.", "We will group the results by country and airline name to get the total routes for each combination.", "Finally, we will order the results by country and total routes in descending order."], "gold_sql": "SELECT T1.country ,  T1.name ,  count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.country ,  T1.name", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT a.country, al.name AS airline, COUNT(r.rid) AS total_routes \nFROM routes r \nJOIN airlines al ON r.alid = al.alid \nJOIN airports a ON r.src_apid = a.apid \nGROUP BY a.country, al.name \nORDER BY a.country, total_routes DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, sorted by the number of active airlines in descending order.\",\n        \"virtual_table\": \"SELECT country FROM airlines WHERE active  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of countries where active airlines are based, grouped by country. The placeholder in the WHERE clause indicates whether to filter for active airlines, and the LIMIT placeholder specifies the maximum number of countries to return, ordered by the number of active airlines in descending order.\",\n        \"virtual_table\": \"SELECT country FROM airlines WHERE active  =  [PLACEHOLDER-TYPE:STRING] GROUP BY country ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6873", "db_id": "flight_4", "question": "Find the number of routes that have destination John F Kennedy International Airport.", "rationale": ["Identify the relevant table: The 'routes' table contains information about routes including destination airports.", "Determine the condition: We need to filter the routes where the destination airport name is 'John F Kennedy International Airport'.", "Use the COUNT function: To find the number of routes, we will use the COUNT(*) function to count all rows that meet the condition.", "Construct the SQL query: Combine the elements into a complete SQL query that counts the number of routes with the specified destination."], "gold_sql": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'", "source_tables": ["airports", "routes"], "pred_sql": "SELECT COUNT(*) FROM routes WHERE dst_ap = 'John F Kennedy International Airport';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6880", "db_id": "flight_4", "question": "What is the name of the airline with the most routes?", "rationale": ["Identify the table that contains airline information and routes, which is the 'routes' table.", "To find the airline with the most routes, we need to count the number of routes for each airline.", "We will use the COUNT() function to count the number of routes grouped by the airline name.", "The results should be ordered in descending order based on the count of routes to get the airline with the most routes at the top.", "Finally, we will limit the results to 1 to get only the top airline."], "gold_sql": "SELECT T1.name FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["routes", "airlines"], "pred_sql": "SELECT airline, COUNT(*) as route_count FROM routes GROUP BY airline ORDER BY route_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6883", "db_id": "flight_4", "question": "Find the busiest destination airport that runs most number of routes in China.", "rationale": ["Identify the destination airports in China by filtering the airports table based on the country.", "Join the routes table to count the number of routes for each destination airport.", "Group the results by destination airport ID to aggregate the route counts.", "Order the results in descending order to find the busiest destination airport with the most routes.", "Limit the results to 1 to get only the busiest destination airport."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT T1.dst_ap, COUNT(*) as route_count \nFROM airports AS T1 \nJOIN routes AS T2 ON T1.apid = T2.dst_apid \nWHERE T1.country = 'China' \nGROUP BY T1.dst_apid \nORDER BY route_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6884", "db_id": "flight_4", "question": "What is the name of the airport that is the destination of the most number of routes that start in China?", "rationale": ["Identify the destination airports from the routes table that have the most routes originating from airports in China.", "Use a subquery to find all airport IDs (apid) in China from the airports table.", "Join the routes table with the airports table to get the names of destination airports (dst_ap) where the source airport (src_apid) is in the list of Chinese airports.", "Group the results by destination airport name and count the number of routes to each destination airport.", "Order the results in descending order based on the count of routes and limit the output to the top result."], "gold_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.country  =  'China' GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "routes"], "pred_sql": "SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid = T2.dst_apid WHERE T2.src_apid IN (SELECT T3.apid FROM airports AS T3 WHERE T3.country = 'China') GROUP BY T1.name ORDER BY count(*) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"The virtual table describes the names and cities of airports that serve as source airports for routes, along with their unique identifiers. The results are grouped by the source airport ID and ordered by the number of routes originating from each airport, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.src_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid GROUP BY T2.src_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of destination airport names and their corresponding cities from the 'airports' table, along with the destination airport IDs from the 'routes' table. The results are grouped by destination airport ID and ordered by the count of routes to each destination, limited to a specified number of results.\",\n        \"virtual_table\": \"SELECT T1.name ,  T1.city ,  T2.dst_apid FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid GROUP BY T2.dst_apid ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of airport names from the 'airports' table that are located in a specific country. It joins the 'airports' table with the 'routes' table to filter the airports based on their country and counts the number of routes originating from each airport. The results are grouped by airport name and ordered by the number of routes in descending order, with a limit on the number of results returned.\",\n        \"virtual_table\": \"SELECT T1.name FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.src_apid WHERE T1.country  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.name ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6980", "db_id": "culture_company", "question": "Show all publishers which do not have a book in 1989.", "rationale": ["Identify the requirement to find publishers without books in 1989.", "Use the EXCEPT clause to exclude publishers that have books published in 1989.", "Construct the first part of the query to select all publishers from the book_club table.", "Construct the second part of the query to select publishers from the book_club table where the Year is 1989.", "Combine both parts using the EXCEPT clause to get the desired result."], "gold_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  1989", "source_tables": ["book_club"], "pred_sql": "SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE Year = '1989'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the publishers of books discussed in the 'book_club' table, excluding those publishers whose books were published in a specific year. The placeholder in the WHERE clause represents the year to be excluded.\",\n        \"virtual_table\": \"SELECT publisher FROM book_club EXCEPT SELECT publisher FROM book_club WHERE YEAR  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "train.6990", "db_id": "culture_company", "question": "Show all director names who have a movie in the year 1999 or 2000.", "rationale": ["Identify the table that contains the information about movies, which is the 'movie' table.", "Determine the relevant column that contains the director's names, which is 'Director'.", "Identify the column that contains the year of release, which is 'Year'.", "Use a WHERE clause to filter the results for the years 1999 and 2000.", "Use DISTINCT to ensure that each director's name is listed only once, even if they directed multiple movies in those years."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6991", "db_id": "culture_company", "question": "Which directors had a movie in either 1999 or 2000?", "rationale": ["Identify the relevant table: The question pertains to movies and their directors, so we will focus on the 'movie' table.", "Determine the columns needed: We need the 'Director' column to answer the question about which directors had movies in the specified years.", "Filter the results: We need to filter the movies based on the years 1999 and 2000. This can be done using a WHERE clause with an IN condition to specify the years.", "Use DISTINCT: Since a director may have multiple movies in these years, we will use DISTINCT to ensure each director is listed only once."], "gold_sql": "SELECT director FROM movie WHERE YEAR  =  1999 OR YEAR  =  2000", "source_tables": ["movie"], "pred_sql": "SELECT DISTINCT Director FROM movie WHERE Year IN (1999, 2000);", "hint": "\n"}
{"sample_id": "train.6996", "db_id": "culture_company", "question": "Show the movie titles and book titles for all companies in China.", "rationale": ["Identify the tables involved: culture_company, movie, and book_club.", "Determine the columns needed: movie titles from the movie table and book titles from the book_club table.", "Establish relationships between the tables using JOINs based on foreign keys: culture_company.movie_id to movie.movie_id and culture_company.book_club_id to book_club.book_club_id.", "Filter the results to include only companies located in China by adding a WHERE clause that checks the Company_name column."], "gold_sql": "SELECT T1.title ,  T3.book_title FROM movie AS T1 JOIN culture_company AS T2 ON T1.movie_id  =  T2.movie_id JOIN book_club AS T3 ON T3.book_club_id  =  T2.book_club_id WHERE T2.incorporated_in  =  'China'", "source_tables": ["culture_company", "movie", "book_club"], "pred_sql": "SELECT movie.Title AS Movie_Title, book_club.Book_Title AS Book_Title\nFROM culture_company\nJOIN movie ON culture_company.movie_id = movie.movie_id\nJOIN book_club ON culture_company.book_club_id = book_club.book_club_id\nWHERE culture_company.Company_name = 'China';", "hint": "\n"}
{"sample_id": "dev.95", "db_id": "car_1", "question": "Which model of the car has the minimum horsepower?", "rationale": ["Identify the relevant tables: We need to find the car model with the minimum horsepower, so we will use the 'cars_data' table for horsepower and the 'car_names' table for the car model.", "Join the tables: We will join 'cars_data' and 'car_names' on the 'Id' and 'MakeId' columns respectively to get access to both horsepower and model name.", "Select the necessary columns: We need to select the 'Model' from 'car_names' and 'Horsepower' from 'cars_data'.", "Order the results: To find the minimum horsepower, we will order the results by 'Horsepower' in ascending order.", "Limit the results: Since we only want the model with the minimum horsepower, we will limit the results to 1."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM cars_data AS T1 JOIN car_names AS T2 ON T1.Id = T2.MakeId ORDER BY Horsepower ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n        \"virtual_table\": \"SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that meet specific criteria. It filters the results based on the weight of the cars from the 'cars_data' table, ensuring that only cars lighter than a specified weight are included. Additionally, it excludes car makers based on their full name from the 'car_makers' table, using a placeholder for the name to be excluded.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  [PLACEHOLDER-TYPE:NUMBER] AND T4.FullName != [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.103", "db_id": "car_1", "question": "Which distinct car models are the produced after 1980?", "rationale": ["Identify the relevant tables: model_list, car_names, and cars_data are needed to get car models and their manufacturing years.", "Use JOIN to connect model_list with car_names and cars_data based on their relationships.", "Filter the results to include only those cars manufactured after 1980 using the WHERE clause.", "Select distinct car models to avoid duplicates in the results."], "gold_sql": "SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;", "source_tables": ["model_list", "car_names", "cars_data"], "pred_sql": "SELECT DISTINCT T1.Model \nFROM model_list AS T1 \nJOIN car_names AS T2 ON T1.Model = T2.Model \nJOIN cars_data AS T3 ON T2.MakeId = T3.Id \nWHERE T3.Year > 1980;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n        \"virtual_table\": \"SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that meet specific criteria. It filters the results based on the weight of the cars from the 'cars_data' table, ensuring that only cars lighter than a specified weight are included. Additionally, it excludes car makers based on their full name from the 'car_makers' table, using a placeholder for the name to be excluded.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  [PLACEHOLDER-TYPE:NUMBER] AND T4.FullName != [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.106", "db_id": "car_1", "question": "What is the name of each continent and how many car makers are there in each one?", "rationale": ["We need to find the name of each continent and the count of car makers in each one.", "Start by selecting the continent name from the 'continents' table.", "Join the 'countries' table to link countries to their respective continents using the ContId.", "Next, join the 'car_makers' table to associate car makers with their respective countries using the CountryId.", "Use COUNT() to count the number of car makers for each continent.", "Group the results by continent to get the count for each one."], "gold_sql": "SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;", "source_tables": ["countries", "car_makers", "continents"], "pred_sql": "SELECT c.Continent, COUNT(cm.Id) AS CarMakerCount\nFROM continents AS c\nLEFT JOIN countries AS co ON c.ContId = co.Continent\nLEFT JOIN car_makers AS cm ON co.CountryId = cm.Country\nGROUP BY c.Continent;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries from the 'countries' table that belong to a specific continent. It joins the 'continents' table to filter countries by continent and the 'car_makers' table to ensure that the countries have car makers associated with them. The placeholders in the WHERE clause represent the continent's name and the minimum count of car makers per country.\",\n        \"virtual_table\": \"SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.CountryName HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.111", "db_id": "car_1", "question": "What is the accelerate of the car make amc hornet sportabout (sw)?", "rationale": ["Identify the relevant tables: We need to find the accelerate of a specific car make, which involves the 'cars_data', 'car_names', 'model_list', and 'car_makers' tables.", "Join the tables: We will join 'cars_data' with 'car_names' on the MakeId, then join 'car_names' with 'model_list' on the Model, and finally join 'model_list' with 'car_makers' on the Maker.", "Filter by the specific car make: We will add a WHERE clause to filter the results for the car make 'amc hornet sportabout (sw)'.", "Select the accelerate value: We will select the 'Accelerate' column from the 'cars_data' table."], "gold_sql": "SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT cars_data.Accelerate \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nJOIN model_list ON car_names.Model = model_list.Model \nJOIN car_makers ON model_list.Maker = car_makers.Id \nWHERE car_names.Make = 'amc hornet sportabout (sw)';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n        \"virtual_table\": \"SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);\"\n    }\n}\n"}
{"sample_id": "dev.113", "db_id": "car_1", "question": "How many car makers are there in france?", "rationale": ["Identify the relevant tables: countries and car_makers.", "Join the countries table with the car_makers table on the country identifier.", "Group the results by country to count the number of car makers per country.", "Filter the results to only include France by using a subquery to get the CountryId for France."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.countryid = t2.country group by t1.countryid having t1.countryid = (select CountryId from countries where CountryName = 'France')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. It filters the results to show only those countries that have more than a specified number of car makers, represented by a placeholder in the HAVING clause.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.114", "db_id": "car_1", "question": "What is the number of makers of care in France?", "rationale": ["Identify the relevant tables: countries and car_makers.", "We need to count the number of car makers in France, so we will join the countries table with the car_makers table on the country identifier.", "We will group the results by the country identifier to get the count of car makers for each country.", "To filter for France specifically, we will use a HAVING clause that checks if the country is France."], "gold_sql": "SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';", "source_tables": ["car_makers", "countries"], "pred_sql": "select count(*) from countries as t1 join car_makers as t2 on t1.CountryId = t2.Country group by t1.CountryId having t1.Country = (select CountryId from countries where CountryName = 'France');", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. It filters the results to show only those countries that have more than a specified number of car makers, represented by a placeholder in the HAVING clause.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    }\n}\n"}
{"sample_id": "dev.115", "db_id": "car_1", "question": "How many car models are produced in the usa?", "rationale": ["Identify the relevant tables: car_makers, countries, and model_list are needed to find car models produced in the USA.", "Join the car_makers table with the countries table to filter for car makers based in the USA.", "Join the model_list table to get the car models associated with those car makers.", "Use COUNT(DISTINCT ml.Model) to count the unique car models produced by these makers in the USA."], "gold_sql": "SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';", "source_tables": ["car_makers", "model_list", "countries"], "pred_sql": "SELECT COUNT(DISTINCT ml.Model) AS ModelCount \nFROM car_makers AS cm \nJOIN countries AS c ON cm.Country = c.CountryId \nJOIN model_list AS ml ON cm.Id = ml.Maker \nWHERE c.CountryName = 'USA';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n        \"virtual_table\": \"SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.129", "db_id": "car_1", "question": "Which countries in europe have at least 3 car manufacturers?", "rationale": ["Identify the relevant tables: countries, continents, and car_makers.", "Join the countries table with the continents table to filter for European countries.", "Join the car_makers table to count the number of car manufacturers in each country.", "Group the results by country name to aggregate the count of car manufacturers.", "Use the HAVING clause to filter countries that have at least 3 car manufacturers."], "gold_sql": "SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;", "source_tables": ["continents", "car_makers", "countries"], "pred_sql": "SELECT T1.CountryName \nFROM countries AS T1 \nJOIN continents AS T2 ON T1.Continent = T2.ContId \nJOIN car_makers AS T3 ON T1.CountryId = T3.Country \nWHERE T2.Continent = 'Europe' \nGROUP BY T1.CountryName \nHAVING COUNT(*) >= 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries from the 'countries' table that belong to a specific continent. It joins the 'continents' table to filter countries by continent and the 'car_makers' table to ensure that the countries have car makers associated with them. The placeholders in the WHERE clause represent the continent's name and the minimum count of car makers per country.\",\n        \"virtual_table\": \"SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T1.CountryName HAVING count(*)  >=  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.131", "db_id": "car_1", "question": "What is the maximum horsepower and the make of the car models with 3 cylinders?", "rationale": ["Identify the tables needed: We need data from 'cars_data' for horsepower and cylinders, and 'car_names' for the make of the car.", "We need to filter the results to only include car models with 3 cylinders, which will be done using a WHERE clause.", "To find the maximum horsepower, we will use the MAX() function on the 'Horsepower' column from the 'cars_data' table.", "We will join 'cars_data' and 'car_names' on the 'Id' and 'MakeId' columns respectively to get the make of the car along with its horsepower.", "Finally, we will group the results by the make of the car to ensure we get the maximum horsepower for each make."], "gold_sql": "SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT MAX(cars_data.Horsepower) AS MaxHorsepower, car_names.Make\nFROM cars_data\nJOIN car_names ON cars_data.Id = car_names.MakeId\nWHERE cars_data.Cylinders = 3\nGROUP BY car_names.Make;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n        \"virtual_table\": \"SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.133", "db_id": "car_1", "question": "Which model saves the most gasoline? That is to say, have the maximum miles per gallon.", "rationale": ["Identify the relevant tables: 'cars_data' for MPG and 'car_names' for car models.", "Join 'cars_data' with 'car_names' on the MakeId to associate car models with their MPG.", "Select the Model and MPG columns from the joined tables.", "Order the results by MPG in descending order to get the highest MPG at the top.", "Limit the results to 1 to get only the model that saves the most gasoline."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, MPG FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId ORDER BY MPG DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n        \"virtual_table\": \"SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct car models from the 'model_list' table that meet specific criteria. It filters the results based on the weight of the cars from the 'cars_data' table, ensuring that only cars lighter than a specified weight are included. Additionally, it excludes car makers based on their full name from the 'car_makers' table, using a placeholder for the name to be excluded.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  [PLACEHOLDER-TYPE:NUMBER] AND T4.FullName != [PLACEHOLDER-TYPE:STRING];\"\n    }\n}\n"}
{"sample_id": "dev.150", "db_id": "car_1", "question": "What are the names and ids of all makers with more than 3 models?", "rationale": ["We need to find car makers with more than 3 models.", "We will join the 'car_makers' table with the 'model_list' table on the maker ID.", "We will group the results by the maker ID to count the number of models for each maker.", "Finally, we will use the HAVING clause to filter out makers that have 3 or fewer models."], "gold_sql": "SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "model_list"], "pred_sql": "select t1.id, t1.maker from car_makers as t1 join model_list as t2 on t1.id = t2.maker group by t1.id having count(*) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. It filters the results to show only those countries that have more than a specified number of car makers, represented by a placeholder in the HAVING clause.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n        \"virtual_table\": \"SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);\"\n    }\n}\n"}
{"sample_id": "dev.158", "db_id": "car_1", "question": "For a volvo model, how many cylinders does the version with least accelerate have?", "rationale": ["Identify the relevant tables: cars_data, car_names, model_list, and car_makers.", "We need to filter for the car maker 'Volvo'.", "Join the tables on their respective foreign keys to access the necessary columns: Cylinders and Accelerate.", "Order the results by the Accelerate column in ascending order to find the version with the least accelerate.", "Limit the results to 1 to get only the top result, which will be the version with the least accelerate."], "gold_sql": "SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT Cylinders FROM cars_data AS cd JOIN car_names AS cn ON cd.Id = cn.MakeId JOIN model_list AS ml ON cn.Model = ml.Model JOIN car_makers AS cm ON ml.Maker = cm.Id WHERE cm.Maker = 'Volvo' ORDER BY Accelerate ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n        \"virtual_table\": \"SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);\"\n    }\n}\n"}
{"sample_id": "dev.160", "db_id": "car_1", "question": "What is the number of cars with a greater accelerate than the one with the most horsepower?", "rationale": ["Identify the requirement: We need to count the number of cars with an 'Accelerate' value greater than the maximum 'Horsepower' of any car.", "To find the maximum horsepower, we can use a subquery: SELECT MAX(Horsepower) FROM cars_data.", "The main query will count the number of cars in the 'cars_data' table where 'Accelerate' is greater than the result of the subquery.", "Combine these two parts into a single SQL query that counts the cars based on the condition."], "gold_sql": "SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );", "source_tables": ["cars_data"], "pred_sql": "SELECT COUNT(*) \nFROM cars_data \nWHERE Accelerate > (SELECT MAX(Horsepower) \n                    FROM cars_data);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. It filters the results to show only those countries that have more than a specified number of car makers, represented by a placeholder in the HAVING clause.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.165", "db_id": "car_1", "question": "For the cars with 4 cylinders, which model has the largest horsepower?", "rationale": ["Identify the relevant tables: cars_data for car specifications and car_names for car model names.", "We need to filter the cars based on the number of cylinders, specifically those with 4 cylinders.", "We want to retrieve the model name and its horsepower, so we will select these columns.", "To find the model with the largest horsepower, we will order the results by horsepower in descending order.", "Finally, we will limit the results to only the top entry to get the model with the largest horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM cars_data AS cd JOIN car_names AS cn ON cd.Id = cn.MakeId WHERE cd.Cylinders = 4 ORDER BY cd.Horsepower DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n        \"virtual_table\": \"SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.166", "db_id": "car_1", "question": "For all of the 4 cylinder cars, which model has the most horsepower?", "rationale": ["Identify the relevant tables: cars_data for car specifications and car_names for car models.", "We need to filter the cars based on the number of cylinders, specifically looking for 4 cylinder cars.", "We will join the cars_data table with the car_names table to get the model names associated with each car entry.", "To find the model with the most horsepower, we will order the results by horsepower in descending order.", "Finally, we will limit the results to only one entry to get the model with the highest horsepower."], "gold_sql": "SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;", "source_tables": ["car_names", "cars_data"], "pred_sql": "SELECT Model, Horsepower FROM cars_data AS cd JOIN car_names AS cn ON cd.Id = cn.MakeId WHERE cd.Cylinders = 4 ORDER BY cd.Horsepower DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n        \"virtual_table\": \"SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.168", "db_id": "car_1", "question": "Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?", "rationale": ["Identify the relevant tables: We need to use the 'cars_data' and 'car_names' tables to get the make ids and names of the cars.", "Determine the conditions: We need to find cars that have horsepower less than the minimum horsepower in the 'cars_data' table and have less than 4 cylinders.", "Construct the subquery: The subquery will find the minimum horsepower from the 'cars_data' table.", "Join the tables: We will join 'cars_data' with 'car_names' on the appropriate foreign key to get the make ids and names.", "Apply the filters: Use the WHERE clause to filter cars based on horsepower and cylinder count."], "gold_sql": "select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;", "source_tables": ["cars_data", "car_names"], "pred_sql": "SELECT car_names.MakeId, car_names.Model \nFROM cars_data \nJOIN car_names ON cars_data.Id = car_names.MakeId \nWHERE cars_data.Horsepower < (SELECT MIN(Horsepower) FROM cars_data) \nAND cars_data.Cylinders < 4;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. The placeholder in the HAVING clause represents the minimum number of car makers required for a country to be included in the results.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n        \"virtual_table\": \"SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);\"\n    }\n}\n"}
{"sample_id": "dev.176", "db_id": "car_1", "question": "What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?", "rationale": ["Identify the tables involved: car_makers, model_list, and car_names.", "We need to find car makers that produce at least 2 models. This requires a join between car_makers and model_list, grouping by car maker id and counting distinct models.", "The first part of the query will be: `select t1.id, t1.maker from car_makers as t1 join model_list as t2 on t1.id = t2.maker group by t1.id having count(distinct t2.model) >= 2`", "Next, we need to ensure that these makers have more than 3 cars. This requires another join with car_names to count the distinct makes associated with the models.", "The second part of the query will be: `select t1.id, t1.maker from car_makers as t1 join model_list as t2 on t1.id = t2.maker join car_names as t3 on t2.model = t3.model group by t1.id having count(distinct t3.make) > 3`", "To combine both conditions, we can use an INTERSECT to find car makers that meet both criteria."], "gold_sql": "SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;", "source_tables": ["car_makers", "car_names", "model_list"], "pred_sql": "select t1.id, t1.maker from car_makers as t1 join model_list as t2 on t1.id = t2.maker group by t1.id having count(distinct t2.model) >= 2 intersect select t1.id, t1.maker from car_makers as t1 join model_list as t2 on t1.id = t2.maker join car_names as t3 on t2.model = t3.model group by t1.id having count(distinct t3.make) > 3;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies car makers who have produced a significant number of car models and have those models associated with specific car names. The placeholders in the HAVING clauses represent the minimum counts of models and names that must be met for the car makers to be included in the results.\",\n        \"virtual_table\": \"select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  [PLACEHOLDER-TYPE:NUMBER] intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  [PLACEHOLDER-TYPE:NUMBER];\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the count of car makers for each country from the 'countries' and 'car_makers' tables. It filters the results to show only those countries that have more than a specified number of car makers, represented by a placeholder in the HAVING clause.\",\n        \"virtual_table\": \"select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the make of the car and the year it was manufactured from the 'cars_data' and 'car_names' tables. The query filters the results to show only the car models that were manufactured in the earliest year recorded in the 'cars_data' table.\",\n        \"virtual_table\": \"SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);\"\n    }\n}\n"}
{"sample_id": "dev.180", "db_id": "flight_2", "question": "What country is Jetblue Airways affiliated with?", "rationale": ["Identify the relevant table: The question pertains to the airline 'Jetblue Airways', so we will focus on the 'airlines' table.", "Determine the required information: We need to find out the country associated with 'Jetblue Airways'.", "Construct the SQL query: We will select the 'Country' column from the 'airlines' table where the 'Airline' column matches 'Jetblue Airways'."], "gold_sql": "SELECT Country FROM AIRLINES WHERE Airline  =  'JetBlue Airways'", "source_tables": ["airlines"], "pred_sql": "SELECT Country FROM airlines WHERE Airline = 'Jetblue Airways'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.194", "db_id": "flight_2", "question": "Give the airline with abbreviation 'UAL'.", "rationale": ["Identify the relevant table: The 'airlines' table contains the abbreviation and other details of airlines.", "Determine the specific requirement: We need to find the airline with the abbreviation 'UAL'.", "Construct the SQL query: Use a SELECT statement to retrieve the 'Abbreviation' from the 'airlines' table where the 'Abbreviation' matches 'UAL'."], "gold_sql": "SELECT Airline FROM AIRLINES WHERE Abbreviation  =  'UAL'", "source_tables": ["airlines"], "pred_sql": "SELECT Abbreviation FROM airlines WHERE Abbreviation = 'UAL'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of airlines from the 'airlines' table that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.214", "db_id": "flight_2", "question": "Give the number of Jetblue Airways flights.", "rationale": ["The user wants to know the number of flights operated by Jetblue Airways.", "To get this information, we need to count the number of entries in the 'flights' table where the 'Airline' column matches 'Jetblue Airways'.", "The SQL query will use the COUNT() function to count these entries and a WHERE clause to filter for Jetblue Airways."], "gold_sql": "SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = 'JetBlue Airways'", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT COUNT(*) FROM flights WHERE Airline = 'Jetblue Airways';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of airlines from the 'airlines' table that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of airlines from the 'airlines' table that operate fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can operate.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.225", "db_id": "flight_2", "question": "What is the code of airport that has the highest number of flights?", "rationale": ["To find the airport code with the highest number of flights, we need to count the number of flights for each source airport.", "We will use the 'flights' table, specifically the 'SourceAirport' column, to group the results by each airport code.", "We will count the number of flights for each airport using COUNT(*) and alias it as 'FlightCount'.", "To get the airport with the highest number of flights, we will order the results in descending order based on 'FlightCount'.", "Finally, we will limit the results to 1 to get only the airport code with the highest number of flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT SourceAirport, COUNT(*) as FlightCount FROM flights GROUP BY SourceAirport ORDER BY FlightCount DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.227", "db_id": "flight_2", "question": "What is the code of airport that has fewest number of flights?", "rationale": ["Identify the relevant table: The 'flights' table contains information about flights, including the source airport.", "Group the results by the source airport to count the number of flights for each airport.", "Order the grouped results in ascending order based on the count of flights to find the airport with the fewest flights.", "Limit the results to 1 to get only the airport with the fewest number of flights."], "gold_sql": "SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1", "source_tables": ["airports", "flights"], "pred_sql": "SELECT SourceAirport FROM flights GROUP BY SourceAirport ORDER BY COUNT(*) ASC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of airlines from the 'airlines' table that operate fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can operate.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.229", "db_id": "flight_2", "question": "Which airline has most number of flights?", "rationale": ["Identify the relevant tables: airlines and flights.", "Join the airlines table with the flights table on the airline identifier.", "Group the results by airline to aggregate the number of flights for each airline.", "Order the results by the count of flights in descending order to get the airline with the most flights at the top.", "Limit the results to 1 to get only the airline with the most flights."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of airlines from the 'airlines' table that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.232", "db_id": "flight_2", "question": "What is the abbreviation of the airilne has the fewest flights and what country is it in?", "rationale": ["Identify the relevant tables: airlines and flights.", "We need to join the airlines table with the flights table to get the airline abbreviation and country along with the count of flights.", "Use GROUP BY to aggregate the results by airline, which allows us to count the number of flights for each airline.", "Order the results by the count of flights in ascending order to find the airline with the fewest flights.", "Limit the results to 1 to get only the airline with the fewest flights."], "gold_sql": "SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT T1.Abbreviation, T1.Country FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline GROUP BY T1.Airline ORDER BY count(*) ASC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a summary of the abbreviations and countries of airlines that operate flights. The data is aggregated by airline, showing the most frequently operating airlines based on the number of flights. The placeholder in the LIMIT clause allows the user to specify the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of airlines from the 'airlines' table that operate fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can operate.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.244", "db_id": "flight_2", "question": "Which airlines have less than 200 flights?", "rationale": ["The question asks for airlines with less than 200 flights.", "We need to join the 'airlines' table with the 'flights' table to count the number of flights for each airline.", "Using GROUP BY on the airline name allows us to aggregate the flight counts for each airline.", "The HAVING clause is used to filter the results based on the aggregated flight counts, specifically looking for those with fewer than 200 flights."], "gold_sql": "SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200", "source_tables": ["flights", "airlines"], "pred_sql": "SELECT T1.Airline FROM airlines AS T1 JOIN flights AS T2 ON T1.uid = T2.Airline GROUP BY T1.Airline HAVING count(*) < 200", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of airlines from the 'airlines' table that operate fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can operate.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of airlines from the 'airlines' table that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.258", "db_id": "flight_2", "question": "Which airports do not have departing or arriving flights?", "rationale": ["Identify the airports from the 'airports' table that do not have any departing flights (SourceAirport) or arriving flights (DestAirport).", "To achieve this, we can use a subquery to find all SourceAirport and DestAirport codes from the 'flights' table.", "We will use the UNION operator to combine both SourceAirport and DestAirport into a single list of airport codes that have flights.", "Finally, we will select all airports from the 'airports' table where the AirportCode is not in the list generated by the subquery."], "gold_sql": "SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)", "source_tables": ["airports", "flights"], "pred_sql": "SELECT AirportCode, AirportName FROM airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM flights UNION SELECT DestAirport FROM flights);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of airlines from the 'airlines' table that operate fewer flights than a specified number. The placeholder in the HAVING clause represents the maximum number of flights an airline can operate.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of airlines that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of airlines from the 'airlines' table that operate more than a specified number of flights. The placeholder in the HAVING clause represents the minimum number of flights an airline must operate to be included in the results.\",\n        \"virtual_table\": \"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.308", "db_id": "cre_Doc_Template_Mgt", "question": "Count the number of documents that use the PPT template type.", "rationale": ["Identify the tables involved: We need to count documents, so we will use the 'Documents' table.", "We need to filter documents based on the template type, which requires joining the 'Templates' table using the 'Template_ID'.", "To get the template type description, we will join the 'Ref_Template_Types' table using 'Template_Type_Code'.", "We will filter the results where the 'Template_Type_Description' is 'PPT'.", "Finally, we will count the distinct 'Document_ID's to get the number of documents that use the PPT template type."], "gold_sql": "SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT'", "source_tables": ["templates", "documents"], "pred_sql": "SELECT COUNT(DISTINCT D.Document_ID) \nFROM Documents D \nJOIN Templates T ON D.Template_ID = T.Template_ID \nJOIN Ref_Template_Types R ON T.Template_Type_Code = R.Template_Type_Code \nWHERE R.Template_Type_Description = 'PPT';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of paragraphs associated with each document from the 'Paragraphs' table. The results are grouped by the document identifier, allowing users to see how many paragraphs belong to each document, sorted by the document ID.\",\n        \"virtual_table\": \"SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of documents along with the count of paragraphs associated with each document. It retrieves the unique document identifier and the document name from the 'Documents' table, while counting the number of paragraphs linked to each document from the 'Paragraphs' table. The grouping is done based on the document identifier to ensure that the count reflects the number of paragraphs per document.\",\n        \"virtual_table\": \"SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of documents along with the count of paragraphs associated with each document. It retrieves the document ID and document name from the 'Documents' table and counts the number of paragraphs linked to each document from the 'Paragraphs' table. The grouping is done by document ID to aggregate the paragraph counts for each document.\",\n        \"virtual_table\": \"SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id\"\n    }\n}\n"}
{"sample_id": "dev.311", "db_id": "cre_Doc_Template_Mgt", "question": "What is the id and type code for the template used by the most documents?", "rationale": ["Identify the relevant tables: Templates and Documents.", "We need to find the Template_ID and Template_Type_Code from the Templates table.", "To determine which template is used by the most documents, we will join the Templates table with the Documents table on Template_ID.", "We will group the results by Template_ID and Template_Type_Code to count how many documents are associated with each template.", "We will order the results in descending order based on the count of Document_IDs to find the template used by the most documents.", "Finally, we will limit the results to 1 to get only the top template."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Templates.Template_ID, Templates.Template_Type_Code\nFROM Templates\nJOIN Documents ON Templates.Template_ID = Documents.Template_ID\nGROUP BY Templates.Template_ID, Templates.Template_Type_Code\nORDER BY COUNT(Documents.Document_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.312", "db_id": "cre_Doc_Template_Mgt", "question": "Return the id and type code of the template that is used for the greatest number of documents.", "rationale": ["We need to find the template that is used for the greatest number of documents.", "To do this, we will join the Templates table with the Documents table on the Template_ID column.", "Next, we will group the results by Template_ID and Template_Type_Code to count how many documents are associated with each template.", "We will use the COUNT function to count the number of Document_IDs for each template.", "Finally, we will order the results in descending order based on the count of documents and limit the result to 1 to get the template with the greatest number of documents."], "gold_sql": "SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Templates.Template_ID, Templates.Template_Type_Code\nFROM Templates\nJOIN Documents ON Templates.Template_ID = Documents.Template_ID\nGROUP BY Templates.Template_ID, Templates.Template_Type_Code\nORDER BY COUNT(Documents.Document_ID) DESC\nLIMIT 1;", "hint": "\n"}
{"sample_id": "dev.341", "db_id": "cre_Doc_Template_Mgt", "question": "Show all template type codes and the number of documents using each type.", "rationale": ["Identify the tables involved: Ref_Template_Types, Templates, and Documents.", "We need to count the number of documents associated with each template type code.", "Join Ref_Template_Types with Templates on Template_Type_Code to get the templates for each type.", "Join the resulting table with Documents on Template_ID to get the documents for each template.", "Use COUNT() to count the number of Document_IDs for each Template_Type_Code.", "Group the results by Template_Type_Code to get the count for each type."], "gold_sql": "SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Ref_Template_Types.Template_Type_Code, COUNT(Documents.Document_ID) AS Document_Count\nFROM Ref_Template_Types\nLEFT JOIN Templates ON Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code\nLEFT JOIN Documents ON Templates.Template_ID = Documents.Template_ID\nGROUP BY Ref_Template_Types.Template_Type_Code;", "hint": "\n"}
{"sample_id": "dev.346", "db_id": "cre_Doc_Template_Mgt", "question": "What are the codes of template types that are not used for any document?", "rationale": ["We need to find template types that are not used for any document.", "To do this, we will start by selecting the 'Template_Type_Code' from the 'Ref_Template_Types' table.", "Next, we will perform a LEFT JOIN with the 'Templates' table on 'Template_Type_Code' to include all template types, even those that do not have corresponding templates.", "Then, we will perform another LEFT JOIN with the 'Documents' table on 'Template_ID' to include all templates, even those that do not have corresponding documents.", "Finally, we will filter the results where 'Document_ID' is NULL, which indicates that there are no documents associated with those templates."], "gold_sql": "SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id", "source_tables": ["templates", "documents"], "pred_sql": "SELECT Ref_Template_Types.Template_Type_Code\nFROM Ref_Template_Types\nLEFT JOIN Templates ON Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code\nLEFT JOIN Documents ON Templates.Template_ID = Documents.Template_ID\nWHERE Documents.Document_ID IS NULL;", "hint": "\n"}
{"sample_id": "dev.361", "db_id": "cre_Doc_Template_Mgt", "question": "Show paragraph details for paragraph with text 'Korea ' .", "rationale": ["The task is to show paragraph details for a specific paragraph with the text 'Korea'.", "To find the relevant paragraph, we need to query the 'Paragraphs' table where the 'Paragraph_Text' contains 'Korea'.", "We also want to include details from the 'Documents' table, so we will join the 'Paragraphs' table with the 'Documents' table on the 'Document_ID'.", "The SQL query will select the 'Paragraph_ID', 'Paragraph_Text', 'Document_Name', and 'Document_Description' from the joined tables.", "We will use a WHERE clause to filter paragraphs that contain the text 'Korea', using the LIKE operator to allow for partial matches."], "gold_sql": "select other_details from paragraphs where paragraph_text like 'korea'", "source_tables": ["paragraphs"], "pred_sql": "SELECT P.Paragraph_ID, P.Paragraph_Text, D.Document_Name, D.Document_Description \nFROM Paragraphs AS P \nJOIN Documents AS D ON P.Document_ID = D.Document_ID \nWHERE P.Paragraph_Text LIKE '%Korea%';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of paragraphs associated with each document from the 'Paragraphs' table. The results are grouped by the document identifier, allowing users to see how many paragraphs belong to each document, sorted by the document ID.\",\n        \"virtual_table\": \"SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of documents along with the count of paragraphs associated with each document. It retrieves the unique document identifier and the document name from the 'Documents' table, while counting the number of paragraphs linked to each document from the 'Paragraphs' table. The grouping is done based on the document identifier to ensure that the count reflects the number of paragraphs per document.\",\n        \"virtual_table\": \"SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of documents along with the count of paragraphs associated with each document. It retrieves the document ID and document name from the 'Documents' table and counts the number of paragraphs linked to each document from the 'Paragraphs' table. The grouping is done by document ID to aggregate the paragraph counts for each document.\",\n        \"virtual_table\": \"SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id\"\n    }\n}\n"}
{"sample_id": "dev.367", "db_id": "cre_Doc_Template_Mgt", "question": "Show all document ids and the number of paragraphs in each document. Order by document id.", "rationale": ["The task requires showing all document IDs and the number of paragraphs in each document.", "To achieve this, we need to count the number of paragraphs associated with each document.", "We will use the 'Paragraphs' table to count the paragraphs, grouping by 'Document_ID' to get the count for each document.", "Finally, we will order the results by 'Document_ID' to meet the requirement of ordering the output."], "gold_sql": "SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id", "source_tables": ["paragraphs"], "pred_sql": "SELECT T1.Document_ID, COUNT(*) AS Number_of_Paragraphs \nFROM Paragraphs AS T1 \nGROUP BY T1.Document_ID \nORDER BY T1.Document_ID;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a count of paragraphs associated with each document from the 'Paragraphs' table. The results are grouped by the document identifier, allowing users to see how many paragraphs belong to each document, sorted by the document ID.\",\n        \"virtual_table\": \"SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a summary of documents along with the count of paragraphs associated with each document. It retrieves the document ID and document name from the 'Documents' table and counts the number of paragraphs linked to each document from the 'Paragraphs' table. The grouping is done by document ID to aggregate the paragraph counts for each document.\",\n        \"virtual_table\": \"SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a summary of documents along with the count of paragraphs associated with each document. It retrieves the unique document identifier and the document name from the 'Documents' table, while counting the number of paragraphs linked to each document from the 'Paragraphs' table. The grouping is done based on the document identifier to ensure that the count reflects the number of paragraphs per document.\",\n        \"virtual_table\": \"SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id\"\n    }\n}\n"}
{"sample_id": "dev.439", "db_id": "wta_1", "question": "Find the highest rank of losers in all matches.", "rationale": ["Identify the relevant table: The 'matches' table contains information about the matches, including the ranks of the losers.", "Determine the required information: We need to find the highest rank of losers, which means we need to look at the 'loser_rank' column in the 'matches' table.", "Use the MAX function: To find the highest rank, we can use the MAX function on the 'loser_rank' column.", "Construct the SQL query: The final SQL query will select the maximum value from the 'loser_rank' column in the 'matches' table."], "gold_sql": "SELECT min(loser_rank) FROM matches", "source_tables": ["matches"], "pred_sql": "SELECT MAX(loser_rank) AS highest_rank FROM matches;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct names of winners from the 'matches' table who participated in a specific tournament and played with a specified hand. The placeholders in the WHERE clause represent the tournament's name and the winning player's hand.\",\n        \"virtual_table\": \"SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  [PLACEHOLDER-TYPE:STRING] AND winner_hand  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the distinct names of winners from the 'matches' table who participated in a specific tournament and played with a specified hand. The placeholders in the WHERE clause represent the tournament's name and the winning player's hand.\",\n        \"virtual_table\": \"SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  [PLACEHOLDER-TYPE:STRING] AND winner_hand  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.458", "db_id": "wta_1", "question": "What are the full names of all left handed players, in order of birth date?", "rationale": ["Identify the table needed: The 'players' table contains the information about players, including their names and handedness.", "Select the columns needed: We need the 'first_name' and 'last_name' columns to create the full name.", "Use string concatenation to combine 'first_name' and 'last_name' into a single column called 'full_name'.", "Filter the results to include only left-handed players by using a WHERE clause on the 'hand' column.", "Order the results by 'birth_date' to get the players in chronological order of their birth."], "gold_sql": "SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date", "source_tables": ["players"], "pred_sql": "SELECT first_name || ' ' || last_name AS full_name\nFROM players\nWHERE hand = 'left'\nORDER BY birth_date;", "hint": "\n"}
{"sample_id": "dev.464", "db_id": "wta_1", "question": "What is the name of the winner who has won the most matches, and how many rank points does this player have?", "rationale": ["Identify the relevant tables: players, matches, and rankings.", "We need to find the winner's name and their rank points, so we will join the players table with the matches table on the winner_id.", "Next, we will join the rankings table to get the ranking points for each player.", "We will group the results by winner_name to count how many matches each player has won.", "To find the player with the most wins, we will order the results by the count of matches in descending order.", "Finally, we will limit the results to 1 to get only the top winner."], "gold_sql": "SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["matches"], "pred_sql": "SELECT winner_name, ranking_points FROM players JOIN matches ON players.player_id = matches.winner_id JOIN rankings ON players.player_id = rankings.player_id GROUP BY winner_name ORDER BY COUNT(matches.winner_id) DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table counts the distinct names of winners from the 'matches' table who participated in a specific tournament and played with a specified hand. The placeholders in the WHERE clause represent the tournament's name and the winning player's hand.\",\n        \"virtual_table\": \"SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  [PLACEHOLDER-TYPE:STRING] AND winner_hand  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table counts the distinct names of winners from the 'matches' table who participated in a specific tournament and played with a specified hand. The placeholders in the WHERE clause represent the tournament's name and the winning player's hand.\",\n        \"virtual_table\": \"SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  [PLACEHOLDER-TYPE:STRING] AND winner_hand  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.471", "db_id": "wta_1", "question": "Find the total ranking points for each player and their first name.", "rationale": ["Identify the columns needed: first name of the player and total ranking points.", "The 'first_name' column is from the 'players' table.", "The 'ranking_points' column is from the 'rankings' table, which needs to be summed up for each player.", "To get the total ranking points for each player, a JOIN between 'players' and 'rankings' tables is necessary on the player_id.", "Use GROUP BY to aggregate the results by player_id and first_name to ensure we get total points per player."], "gold_sql": "SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name", "source_tables": ["rankings", "players"], "pred_sql": "SELECT players.first_name, SUM(rankings.ranking_points) AS total_ranking_points\nFROM players\nJOIN rankings ON players.player_id = rankings.player_id\nGROUP BY players.player_id, players.first_name;", "hint": "\n"}
{"sample_id": "dev.479", "db_id": "wta_1", "question": "Find the total number of tours for each ranking date.", "rationale": ["Identify the relevant table: The 'rankings' table contains the 'ranking_date' and 'tours' columns.", "Determine the aggregation needed: We need to count the number of tours for each ranking date.", "Use GROUP BY to group the results by 'ranking_date' so that we can count the tours for each date.", "Construct the SQL query to select 'ranking_date' and the count of 'tours', using COUNT() function, and group by 'ranking_date'."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(tours) AS total_tours\nFROM rankings\nGROUP BY ranking_date;", "hint": "\n"}
{"sample_id": "dev.480", "db_id": "wta_1", "question": "How many total tours were there for each ranking date?", "rationale": ["Identify the relevant table: The question pertains to the number of tours for each ranking date, which is found in the 'rankings' table.", "Determine the columns needed: We need 'ranking_date' to group the results and 'tours' to count the distinct tours for each date.", "Use COUNT(DISTINCT tours): This will count the unique tours associated with each ranking date.", "Group by ranking_date: This will aggregate the results for each unique ranking date."], "gold_sql": "SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date", "source_tables": ["rankings"], "pred_sql": "SELECT ranking_date, COUNT(DISTINCT tours) AS total_tours\nFROM rankings\nGROUP BY ranking_date;", "hint": "\n"}
{"sample_id": "dev.533", "db_id": "student_transcripts_tracking", "question": "Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.", "rationale": ["We need to find students enrolled in 2 degree programs in one semester.", "First, we will join the Students table with the Student_Enrolment table to get the enrollment details of each student.", "Next, we will join with the Degree_Programs table to link each enrollment to its corresponding degree program.", "To find students enrolled in 2 degree programs, we will use a subquery that counts the distinct degree programs for each student and filters those with a count of 2.", "The subquery will group by student_id and use HAVING COUNT(DISTINCT degree_program_id) = 2 to ensure we only get students enrolled in exactly 2 programs.", "Finally, we will select the first name, middle name, last name, and student_id of those students who meet the criteria."], "gold_sql": "SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT T1.first_name, T1.middle_name, T1.last_name, T1.student_id \nFROM Students AS T1 \nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id \nJOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id \nWHERE T2.semester_id IN (\n    SELECT DISTINCT T2.semester_id \n    FROM Degree_Programs AS T1 \n    JOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id \n    GROUP BY T2.student_id \n    HAVING COUNT(DISTINCT T1.degree_program_id) = 2\n)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. The placeholders in the query represent the name of the degree program, allowing users to specify which program they are interested in to retrieve the relevant semesters.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first name, middle name, last name, and unique identifier of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.536", "db_id": "student_transcripts_tracking", "question": "What are the first, middle, and last names for everybody enrolled in a Bachelors program?", "rationale": ["Identify the tables needed: Students, Student_Enrolment, and Degree_Programs.", "We need to join these tables to get the names of students enrolled in a specific degree program.", "Use the JOIN clause to connect Students to Student_Enrolment on student_id, and Student_Enrolment to Degree_Programs on degree_program_id.", "Filter the results using a WHERE clause to specify that we want students enrolled in a Bachelors program.", "Select distinct first_name, middle_name, and last_name to avoid duplicate entries."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs", "students"], "pred_sql": "SELECT DISTINCT T1.first_name, T1.middle_name, T1.last_name \nFROM Students AS T1 \nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id \nJOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id \nWHERE T3.degree_summary_name = 'Bachelors'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first name, middle name, last name, and unique identifier of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.537", "db_id": "student_transcripts_tracking", "question": "Find the kind of program which most number of students are enrolled in?", "rationale": ["To find the degree program with the most students enrolled, we need to count the number of students enrolled in each degree program.", "We will join the Student_Enrolment table with the Degree_Programs table using the degree_program_id to associate students with their respective programs.", "We will group the results by degree_summary_name to get the count of students for each program.", "We will order the results by the count of students in descending order to get the program with the highest enrollment at the top.", "Finally, we will limit the results to 1 to get only the program with the most students enrolled."], "gold_sql": "SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT T3.degree_summary_name, COUNT(T2.student_id) AS student_count \nFROM Student_Enrolment AS T2 \nJOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id \nGROUP BY T3.degree_summary_name \nORDER BY student_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. The placeholders in the query represent the name of the degree program, allowing users to specify which program they are interested in to retrieve the relevant semesters.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.539", "db_id": "student_transcripts_tracking", "question": "Find the program which most number of students are enrolled in. List both the id and the summary.", "rationale": ["To find the program with the most number of students enrolled, we need to count the number of enrolments for each degree program.", "We will join the Student_Enrolment table with the Degree_Programs table on the degree_program_id to get the program details along with the enrolment counts.", "We will group the results by degree_program_id and degree_summary_name to aggregate the counts for each program.", "We will order the results by the count of students in descending order to get the program with the highest enrolment at the top.", "Finally, we will limit the results to 1 to get only the program with the most students enrolled."], "gold_sql": "SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT T3.degree_program_id, T3.degree_summary_name, COUNT(T2.student_enrolment_id) AS student_count \nFROM Student_Enrolment AS T2 \nJOIN Degree_Programs AS T3 ON T2.degree_program_id = T3.degree_program_id \nGROUP BY T3.degree_program_id, T3.degree_summary_name \nORDER BY student_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a count of how many times each student course appears in the transcripts, grouped by the course identifier. The results are ordered by the count in descending order, allowing users to see the most frequently recorded courses. The placeholder in the LIMIT clause represents the maximum number of results to return.\",\n        \"virtual_table\": \"SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.541", "db_id": "student_transcripts_tracking", "question": "Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.", "rationale": ["Identify the relevant tables: Students and Student_Enrolment are needed to get student details and their enrollment counts.", "Join the Students table with the Student_Enrolment table on the student_id to link students with their enrollments.", "Use COUNT(*) to count the number of enrollments for each student.", "Group the results by student_id to aggregate the counts for each student.", "Order the results by the count of enrollments in descending order to find the student with the most enrollments.", "Limit the results to 1 to get only the top student."], "gold_sql": "SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["student_enrolment", "students"], "pred_sql": "SELECT T1.student_id, T1.first_name, T1.middle_name, T1.last_name, COUNT(*) AS number_of_enrollments \nFROM Students AS T1 \nJOIN Student_Enrolment AS T2 ON T1.student_id = T2.student_id \nGROUP BY T1.student_id \nORDER BY number_of_enrollments DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first name, middle name, last name, and unique identifier of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.547", "db_id": "student_transcripts_tracking", "question": "What's the name of the course with most number of enrollments?", "rationale": ["Identify the relevant tables: Courses, Sections, and Student_Enrolment_Courses are needed to find the course with the most enrollments.", "Join the Courses table with the Sections table on course_id to get sections for each course.", "Join the resulting table with Student_Enrolment_Courses on section_id to count how many students are enrolled in each section.", "Group the results by course_id to aggregate the enrollments for each course.", "Count the number of enrollments for each course and order the results in descending order to find the course with the most enrollments.", "Limit the results to 1 to get only the top course."], "gold_sql": "SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1", "source_tables": ["courses", "student_enrolment_courses"], "pred_sql": "SELECT C.course_name, COUNT(SEC.student_course_id) AS enrollment_count\nFROM Courses AS C\nJOIN Sections AS SEC ON C.course_id = SEC.course_id\nJOIN Student_Enrolment_Courses AS SEC_C ON SEC.section_id = SEC_C.student_course_id\nGROUP BY C.course_id\nORDER BY enrollment_count DESC\nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides the first name, middle name, last name, and unique identifier of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.550", "db_id": "student_transcripts_tracking", "question": "What are the last name of the students who live in North Carolina but have not registered in any degree programs?", "rationale": ["Identify the relevant tables: Students and Addresses for student information and their current address, and Student_Enrolment to check for degree program registration.", "Join the Students table with the Addresses table on the current_address_id to filter students based on their current state of residence.", "Use a WHERE clause to specify that we are interested in students living in 'North Carolina'.", "To find students who have not registered in any degree programs, use an EXCEPT clause to exclude those students who appear in the Student_Enrolment table.", "The final query selects the last names of students from the first part and excludes those found in the second part."], "gold_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id", "source_tables": ["addresses", "student_enrolment", "students"], "pred_sql": "SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id = T2.address_id WHERE T2.state_province_county = 'North Carolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id = T4.student_id;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.554", "db_id": "student_transcripts_tracking", "question": "What is the mobile phone number of the student named Timmothy Ward ?", "rationale": ["Identify the relevant table: The question pertains to student information, so we will use the 'Students' table.", "Determine the required fields: We need the 'cell_mobile_number' of the student.", "Filter criteria: The student is identified by their first name 'Timmothy' and last name 'Ward'.", "Construct the SQL query: We will select the 'cell_mobile_number' from the 'Students' table where the first and last names match the given names."], "gold_sql": "select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward'", "source_tables": ["students"], "pred_sql": "SELECT cell_mobile_number FROM Students WHERE first_name = 'Timmothy' AND last_name = 'Ward';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.561", "db_id": "student_transcripts_tracking", "question": "Which address holds the most number of students currently? List the address id and all lines.", "rationale": ["Identify the relevant tables: We need to use the 'Addresses' table to get address details and the 'Students' table to count the number of students at each address.", "Join the 'Addresses' table with the 'Students' table on the current address ID to associate students with their addresses.", "Group the results by address ID to count how many students are associated with each address.", "Order the results by the count of students in descending order to find the address with the most students.", "Limit the results to 1 to get only the address with the highest count of students."], "gold_sql": "SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["addresses", "students"], "pred_sql": "SELECT A.address_id, A.line_1, A.line_2, A.line_3 \nFROM Addresses AS A \nJOIN Students AS S ON S.current_address_id = A.address_id \nGROUP BY A.address_id \nORDER BY COUNT(S.student_id) DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.576", "db_id": "student_transcripts_tracking", "question": "What is the id of the semester that had both Masters and Bachelors students enrolled?", "rationale": ["Identify the need to find semesters with both Masters and Bachelors students enrolled.", "Use the provided virtual table structure to create a query that selects distinct semester_ids for each degree program.", "The first part of the query selects semester_ids for the Masters program.", "The second part of the query selects semester_ids for the Bachelors program.", "Use the INTERSECT operator to find common semester_ids from both queries, which indicates semesters that had both types of students enrolled."], "gold_sql": "SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor'", "source_tables": ["student_enrolment", "degree_programs"], "pred_sql": "SELECT DISTINCT T2.semester_id \nFROM Degree_Programs AS T1 \nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id \nWHERE T1.degree_summary_name = 'Masters' \nINTERSECT \nSELECT DISTINCT T2.semester_id \nFROM Degree_Programs AS T1 \nJOIN Student_Enrolment AS T2 ON T1.degree_program_id = T2.degree_program_id \nWHERE T1.degree_summary_name = 'Bachelors';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the distinct semesters in which students are enrolled in a specific degree program. The placeholders in the query represent the name of the degree program, allowing users to specify which program they are interested in to retrieve the relevant semesters.\",\n        \"virtual_table\": \"SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING] INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the first name, middle name, last name, and unique identifier of students from the 'Students' table who are enrolled in a specific number of courses. The placeholder in the HAVING clause represents the count of courses the students are enrolled in.\",\n        \"virtual_table\": \"SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.580", "db_id": "student_transcripts_tracking", "question": "What other details can you tell me about students in reverse alphabetical order?", "rationale": ["The user wants to retrieve details about students.", "To get all details, we will select all columns from the Students table.", "The results need to be in reverse alphabetical order, which means we will order by last_name first, then by first_name, and finally by middle_name in descending order."], "gold_sql": "SELECT other_student_details FROM Students ORDER BY other_student_details DESC", "source_tables": ["students"], "pred_sql": "SELECT * FROM Students ORDER BY last_name DESC, first_name DESC, middle_name DESC;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct first, middle, and last names of students who are enrolled in a specific degree program. The placeholders in the WHERE clause represent the name of the degree program being queried.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of students along with their first, middle, and last names, and the count of their enrolments in courses. The results are grouped by each student's unique identifier and ordered by the number of enrolments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of students to return.\",\n        \"virtual_table\": \"SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the last names of students who currently reside in a specific state, excluding those who are enrolled in any degree program. The query joins the 'Students' table with the 'Addresses' table to filter by the current address's state, and uses an EXCEPT clause to remove students who are found in the 'Student_Enrolment' table.\",\n        \"virtual_table\": \"SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id\"\n    }\n}\n"}
{"sample_id": "dev.581", "db_id": "student_transcripts_tracking", "question": "Describe the section h.", "rationale": ["The user wants to describe a specific section identified by the name 'h'.", "To retrieve the description of the section, we need to select the relevant columns from the 'Sections' table.", "We will filter the results using a WHERE clause to match the section name with 'h'."], "gold_sql": "SELECT section_description FROM Sections WHERE section_name  =  'h'", "source_tables": ["sections"], "pred_sql": "SELECT T2.section_name, T2.section_description FROM Sections AS T2 WHERE T2.section_name = 'h';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of course names and their corresponding identifiers from the 'Courses' table, specifically for those courses that have a number of sections less than or equal to a specified threshold. The placeholder in the HAVING clause represents the maximum number of sections allowed for the courses listed.\",\n        \"virtual_table\": \"SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.705", "db_id": "world_1", "question": "How many countries have governments that are republics?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries and their government forms.", "Determine the specific condition: We need to count countries where the government form is 'Republic'.", "Construct the SQL query: Use the COUNT function to count the number of rows in the 'country' table that meet the specified condition."], "gold_sql": "SELECT count(*) FROM country WHERE GovernmentForm  =  'Republic'", "source_tables": ["country"], "pred_sql": "SELECT COUNT(*) FROM country WHERE GovernmentForm = 'Republic';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of languages spoken in those countries.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.730", "db_id": "world_1", "question": "What is the average GNP and total population in all nations whose government is US territory?", "rationale": ["Identify the required data: average GNP and total population of countries with a specific government form.", "Determine the relevant table: the 'country' table contains both GNP and population data, as well as government form information.", "Construct the SQL query to select the average GNP and sum of the population from the 'country' table.", "Add a WHERE clause to filter the results to only include countries where the government form is 'US territory'."], "gold_sql": "SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  'US Territory'", "source_tables": ["country"], "pred_sql": "SELECT avg(GNP) AS Average_GNP, sum(Population) AS Total_Population FROM country WHERE GovernmentForm = 'US territory'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.734", "db_id": "world_1", "question": "How many type of governments are in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and continent.", "Filter for Africa: We need to focus on countries located in Africa, which can be done by adding a WHERE clause that specifies the continent as 'Africa'.", "Select distinct government forms: To find out how many types of governments are present, we will use the DISTINCT keyword to ensure we only get unique government forms from the filtered results."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Continent = 'Africa';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of languages spoken in those countries.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.735", "db_id": "world_1", "question": "How many different forms of governments are there in Africa?", "rationale": ["Identify the relevant table: The 'country' table contains information about countries, including their government forms and continent.", "Filter for Africa: We need to focus on countries located in Africa, which can be done by adding a WHERE clause that specifies the continent as 'Africa'.", "Select distinct government forms: To find out how many different forms of governments there are, we will use the DISTINCT keyword to ensure we only get unique government forms from the filtered results."], "gold_sql": "SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  'Africa'", "source_tables": ["country"], "pred_sql": "SELECT DISTINCT GovernmentForm FROM country WHERE Continent = 'Africa'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of languages spoken in those countries.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.742", "db_id": "world_1", "question": "Which continent has the most diverse languages?", "rationale": ["To determine which continent has the most diverse languages, we need to count the distinct languages spoken in each continent.", "We will join the 'countrylanguage' table with the 'country' table using the 'CountryCode' to get the continent information.", "We will group the results by continent and count the distinct languages for each continent.", "Finally, we will order the results in descending order based on the count of distinct languages and limit the output to 1 to get the continent with the most diverse languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT continent, COUNT(DISTINCT language) AS language_count FROM countrylanguage AS cl JOIN country AS c ON cl.CountryCode = c.Code GROUP BY continent ORDER BY language_count DESC LIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in countries where a specific language is spoken officially. The query filters the results based on whether the language is official, the name of the language, and the continent the country belongs to. The placeholders in the WHERE clause represent the official status of the language, the language name, and the continent name.\",\n        \"virtual_table\": \"select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  [PLACEHOLDER-TYPE:STRING] and t2.language  =  [PLACEHOLDER-TYPE:STRING] and t1.continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n        \"virtual_table\": \"select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING] union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.743", "db_id": "world_1", "question": "Which continent speaks the most languages?", "rationale": ["Identify the relevant tables: We need to look at the 'country' and 'countrylanguage' tables to find out which continent speaks the most languages.", "Count the distinct languages spoken in each continent: We will use COUNT(DISTINCT language) to count the number of different languages spoken in each continent.", "Filter for official languages: We will only consider languages that are marked as official (IsOfficial = 'T').", "Group the results by continent: We will use GROUP BY continent to aggregate the counts of languages for each continent.", "Order the results: We will order the results in descending order based on the count of languages.", "Limit the results to the top entry: We will use LIMIT 1 to get the continent with the most languages."], "gold_sql": "SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT continent, COUNT(DISTINCT language) AS language_count \nFROM countrylanguage \nJOIN country ON countrylanguage.CountryCode = country.Code \nWHERE countrylanguage.IsOfficial = 'T' \nGROUP BY continent \nORDER BY language_count DESC \nLIMIT 1;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n        \"virtual_table\": \"select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING] union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in countries where a specific language is spoken officially. The query filters the results based on whether the language is official, the name of the language, and the continent the country belongs to. The placeholders in the WHERE clause represent the official status of the language, the language name, and the continent name.\",\n        \"virtual_table\": \"select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  [PLACEHOLDER-TYPE:STRING] and t2.language  =  [PLACEHOLDER-TYPE:STRING] and t1.continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.746", "db_id": "world_1", "question": "What are the names of nations speak both English and French?", "rationale": ["Identify the languages of interest: English and French.", "Use the provided virtual table structure to create a query that selects country names based on the languages spoken.", "Join the 'country' table with the 'countrylanguage' table on the country code.", "Filter for countries where English is an official language.", "Use a UNION to combine results with countries where French is an official language."], "gold_sql": "SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'French'", "source_tables": ["country", "countrylanguage"], "pred_sql": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  = 'English' and isofficial  = 'T' union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  = 'French' and isofficial  = 'T'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n        \"virtual_table\": \"select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING] union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in countries where a specific language is spoken officially. The query filters the results based on whether the language is official, the name of the language, and the continent the country belongs to. The placeholders in the WHERE clause represent the official status of the language, the language name, and the continent name.\",\n        \"virtual_table\": \"select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  [PLACEHOLDER-TYPE:STRING] and t2.language  =  [PLACEHOLDER-TYPE:STRING] and t1.continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.755", "db_id": "world_1", "question": "Which countries have either English or Dutch as an official language?", "rationale": ["Identify the tables involved: We need to look at the 'country' and 'countrylanguage' tables to find countries with specific official languages.", "Determine the languages of interest: The question specifies 'English' and 'Dutch' as the languages we are interested in.", "Use the provided virtual table structure: The hint provides a template for querying countries based on official languages. We will use this template to construct our query.", "Construct the SQL query: We will create two SELECT statements, one for each language, and combine them using UNION to get a list of countries that have either English or Dutch as an official language.", "Specify the conditions: For each SELECT statement, we will check if the language is either 'English' or 'Dutch' and if it is marked as official (IsOfficial = 'T')."], "gold_sql": "SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English' AND IsOfficial  =  'T' UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'Dutch' AND IsOfficial  =  'T'", "source_tables": ["country", "countrylanguage"], "pred_sql": "select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'English' and isofficial  =  'T' union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  'Dutch' and isofficial  =  'T'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n        \"virtual_table\": \"select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING] union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in countries where a specific language is spoken officially. The query filters the results based on whether the language is official, the name of the language, and the continent the country belongs to. The placeholders in the WHERE clause represent the official status of the language, the language name, and the continent name.\",\n        \"virtual_table\": \"select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  [PLACEHOLDER-TYPE:STRING] and t2.language  =  [PLACEHOLDER-TYPE:STRING] and t1.continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.766", "db_id": "world_1", "question": "What is the total number of people living in the nations that do not use English?", "rationale": ["Identify the countries that do not use English as an official language.", "Use a subquery to select the CountryCode from the countrylanguage table where the language is English and is official.", "Use the NOT IN clause to filter out these countries from the main query.", "Select the total population from the country table for the remaining countries."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(Population) FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n        \"virtual_table\": \"select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING] union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides the count of countries and the maximum percentage of speakers for a specific language from the 'countrylanguage' table. The placeholder in the WHERE clause represents the language name being queried.\",\n        \"virtual_table\": \"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING] GROUP BY CountryCode\"\n    }\n}\n"}
{"sample_id": "dev.767", "db_id": "world_1", "question": "How many people live in countries that do not speak English?", "rationale": ["Identify the requirement: We need to find the total population of countries that do not speak English.", "To achieve this, we need to first identify the countries that have English as an official language.", "We can use a subquery to select the CountryCode from the countrylanguage table where the Language is 'English' and IsOfficial is 'T'.", "Next, we will select the total population from the country table where the Code is not in the list of CountryCodes returned by the subquery.", "Finally, we will sum the population of these countries to get the desired result."], "gold_sql": "SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  'English')", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT SUM(Population) FROM country WHERE Code NOT IN (SELECT CountryCode FROM countrylanguage WHERE Language = 'English' AND IsOfficial = 'T')", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n        \"virtual_table\": \"select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING] union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.783", "db_id": "world_1", "question": "Return the codes of countries that do not speak English and do not have Republics for governments.", "rationale": ["Identify the requirement to find countries that do not speak English and do not have Republics for governments.", "Use the provided virtual table structure to create a query that selects country codes from the 'country' table where the government form is not 'Republic'.", "Use the EXCEPT clause to exclude countries from the result that have 'English' as an official language by selecting from the 'countrylanguage' table.", "Combine these two parts into a single SQL query."], "gold_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  'English'", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT Code FROM country WHERE GovernmentForm != 'Republic' EXCEPT SELECT CountryCode FROM countrylanguage WHERE Language = 'English'", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n        \"virtual_table\": \"select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING] union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.784", "db_id": "world_1", "question": "Which cities are in European countries where English is not the official language?", "rationale": ["Identify the relevant tables: We need to use the 'city', 'country', and 'countrylanguage' tables to answer the question.", "Determine the relationships: The 'city' table is linked to the 'country' table through the 'CountryCode', and the 'countrylanguage' table is also linked to the 'country' table through the 'CountryCode'.", "Filter for European countries: We need to ensure that we are only looking at countries in Europe, which can be done by checking the 'Continent' column in the 'country' table.", "Filter for English language: We need to find countries where English is spoken, but it should not be an official language. This can be done by checking the 'IsOfficial' column in the 'countrylanguage' table.", "Select distinct city names: Finally, we want to select distinct city names from the 'city' table that meet the above criteria."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT DISTINCT t3.Name FROM country AS t1 JOIN countrylanguage AS t2 ON t1.Code = t2.CountryCode JOIN city AS t3 ON t1.Code = t3.CountryCode WHERE t2.IsOfficial = 'False' AND t2.Language = 'English' AND t1.Continent = 'Europe';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n        \"virtual_table\": \"select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING] union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in countries where a specific language is spoken officially. The query filters the results based on whether the language is official, the name of the language, and the continent the country belongs to. The placeholders in the WHERE clause represent the official status of the language, the language name, and the continent name.\",\n        \"virtual_table\": \"select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  [PLACEHOLDER-TYPE:STRING] and t2.language  =  [PLACEHOLDER-TYPE:STRING] and t1.continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.785", "db_id": "world_1", "question": "What are the names of cities in Europe for which English is not the official language?", "rationale": ["Identify the requirement: We need the names of cities in Europe where English is not the official language.", "Use the provided hint to find relevant virtual tables: The third virtual table is useful as it provides a way to get city names based on language and continent.", "Join the 'country', 'countrylanguage', and 'city' tables to filter cities based on the language spoken and the continent.", "Filter for cities in Europe by checking the continent in the country table.", "Check that English is not an official language by filtering with IsOfficial = 'No' and Language = 'English'.", "Select distinct city names to avoid duplicates."], "gold_sql": "SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English')", "source_tables": ["country", "city", "countrylanguage"], "pred_sql": "SELECT DISTINCT t3.Name FROM country AS t1 JOIN countrylanguage AS t2 ON t1.Code = t2.CountryCode JOIN city AS t3 ON t1.Code = t3.CountryCode WHERE t2.IsOfficial = 'No' AND t2.Language = 'English' AND t1.Continent = 'Europe';", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n        \"virtual_table\": \"select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING] union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of distinct city names from the 'city' table that are located in countries where a specific language is spoken officially. The query filters the results based on whether the language is official, the name of the language, and the continent the country belongs to. The placeholders in the WHERE clause represent the official status of the language, the language name, and the continent name.\",\n        \"virtual_table\": \"select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  [PLACEHOLDER-TYPE:STRING] and t2.language  =  [PLACEHOLDER-TYPE:STRING] and t1.continent  =  [PLACEHOLDER-TYPE:STRING]\"\n    }\n}\n"}
{"sample_id": "dev.788", "db_id": "world_1", "question": "What are the name, independence year, and surface area of the country with the smallest population?", "rationale": ["Identify the required fields: name, independence year, and surface area of the country.", "Determine that we need to find the country with the smallest population.", "Use a subquery to find the minimum population from the country table.", "Select the name, independence year, and surface area of the country where the population matches the minimum population found in the subquery."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.789", "db_id": "world_1", "question": "Give the name, year of independence, and surface area of the country that has the lowest population.", "rationale": ["Identify the required fields: Name, year of independence (IndepYear), and surface area (SurfaceArea) from the country table.", "Determine the condition for selecting the country with the lowest population, which involves finding the minimum population in the country table.", "Use a subquery to find the minimum population: (SELECT MIN(Population) FROM country).", "Combine the selected fields and the condition into a complete SQL query to retrieve the desired information."], "gold_sql": "SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1", "source_tables": ["country"], "pred_sql": "SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.793", "db_id": "world_1", "question": "What are the names of countries that speak more than 2 languages, as well as how many languages they speak?", "rationale": ["Identify the relevant tables: We need to use the 'country' table to get country names and the 'countrylanguage' table to count the languages spoken in each country.", "Join the 'country' table with the 'countrylanguage' table on the country code to associate each country with its languages.", "Group the results by country name to aggregate the language counts for each country.", "Use the COUNT function to count the number of languages spoken in each country.", "Apply a HAVING clause to filter the results to only include countries that speak more than 2 languages."], "gold_sql": "SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2", "source_tables": ["country", "countrylanguage"], "pred_sql": "SELECT c.Name, COUNT(cl.Language) AS LanguageCount \nFROM country AS c \nJOIN countrylanguage AS cl ON c.Code = cl.CountryCode \nGROUP BY c.Name \nHAVING COUNT(cl.Language) > 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries where a specific language is spoken as an official language. The placeholders in the query represent the language name and the official status of the language.\",\n        \"virtual_table\": \"select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING] union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  [PLACEHOLDER-TYPE:STRING] and isofficial  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of countries that speak each language.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table describes the languages spoken in countries that have a specific form of government. The query retrieves the languages from the 'countrylanguage' table by joining it with the 'country' table based on the country code. The placeholder in the WHERE clause represents the type of government, and the placeholder in the HAVING clause indicates the required count of languages spoken in those countries.\",\n        \"virtual_table\": \"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  [PLACEHOLDER-TYPE:STRING] GROUP BY T2.Language HAVING COUNT(*)  =  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.796", "db_id": "world_1", "question": "Find the government form name and total population for each government form whose average life expectancy is longer than 72.", "rationale": ["Identify the relevant tables: We need to gather information from the 'country' table, which contains the government form and population, as well as the life expectancy.", "Determine the columns needed: We need 'GovernmentForm' and the total 'Population'.", "Apply the condition: We want to filter countries where the average 'LifeExpectancy' is greater than 72.", "Group the results: Since we want the total population for each government form, we will group by 'GovernmentForm'.", "Construct the SQL query: Combine all the elements into a complete SQL statement."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation \nFROM country \nWHERE LifeExpectancy > 72 \nGROUP BY GovernmentForm;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.797", "db_id": "world_1", "question": "What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?", "rationale": ["Identify the relevant columns needed for the query: GovernmentForm and Population from the country table, and LifeExpectancy also from the country table.", "We need to filter the results to include only those government forms where the average life expectancy is greater than 72.", "Use the SUM function to calculate the total population for each government form.", "Group the results by GovernmentForm to get the total population for each distinct government form."], "gold_sql": "SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72", "source_tables": ["country"], "pred_sql": "SELECT GovernmentForm, SUM(Population) AS TotalPopulation \nFROM country \nWHERE LifeExpectancy > 72 \nGROUP BY GovernmentForm;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table identifies the unique codes of countries that do not have a specific form of government and do not have a particular language as an official language. The placeholders in the query represent the government form and the language to be excluded.\",\n        \"virtual_table\": \"SELECT Code FROM country WHERE GovernmentForm != [PLACEHOLDER-TYPE:STRING] EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  [PLACEHOLDER-TYPE:STRING]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.801", "db_id": "world_1", "question": "Return the names and surface areas of the 5 largest countries.", "rationale": ["The task is to return the names and surface areas of the 5 largest countries.", "To find the largest countries, we need to order the countries by their surface area in descending order.", "We will select the 'Name' and 'SurfaceArea' columns from the 'country' table.", "To limit the results to only the top 5 largest countries, we will use the LIMIT clause."], "gold_sql": "SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5", "source_tables": ["country"], "pred_sql": "SELECT Name, SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.810", "db_id": "world_1", "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?", "rationale": ["Identify the relevant table: The 'country' table contains the necessary information about countries, including their population and surface area.", "Determine the required fields: We need to calculate the total population and average surface area of countries in North America.", "Apply the necessary filters: We need to filter for countries in the continent of North America and those with a surface area greater than 3000.", "Construct the SQL query: Use the SUM function to calculate the total population and the AVG function to calculate the average surface area, applying the filters in the WHERE clause."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT SUM(Population) AS TotalPopulation, AVG(SurfaceArea) AS AverageArea FROM country WHERE Continent = 'North America' AND SurfaceArea > 3000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.811", "db_id": "world_1", "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .", "rationale": ["Identify the relevant tables: We need data from the 'country' table for population and surface area.", "Determine the required calculations: We need to calculate the total population and average surface area.", "Filter the results: We only want countries in North America with a surface area greater than 3000.", "Construct the SQL query: Use SUM() for total population and AVG() for average surface area, applying the necessary WHERE clause for filtering."], "gold_sql": "select sum(population) ,  avg(surfacearea) from country where continent  =  'north america' and surfacearea  >  3000", "source_tables": ["country"], "pred_sql": "SELECT sum(c.Population) AS TotalPopulation, avg(c.SurfaceArea) AS AverageSurfaceArea \nFROM country c \nWHERE c.Continent = 'North America' \nAND c.SurfaceArea > 3000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table summarizes the total population and average life expectancy of countries grouped by continent. It filters the results to only include continents where the average life expectancy is below a specified threshold. The placeholder in the HAVING clause represents the life expectancy limit.\",\n        \"virtual_table\": \"SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.812", "db_id": "world_1", "question": "What are the cities whose population is between 160000 and 900000?", "rationale": ["Identify the table that contains city population data, which is the 'city' table.", "Determine the specific columns needed for the query: 'Name' for the city name and 'Population' for filtering.", "Use the SQL BETWEEN operator to filter cities with a population between 160000 and 900000.", "Construct the SQL query to select the city names from the 'city' table where the population falls within the specified range."], "gold_sql": "SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000", "source_tables": ["city"], "pred_sql": "SELECT Name FROM city WHERE Population BETWEEN 160000 AND 900000;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population less than the maximum population of any country within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of countries from the 'country' table that are located in a specific continent and have a population greater than the minimum population of countries within the same continent. The placeholders in the WHERE clause represent the continent's name.\",\n        \"virtual_table\": \"SELECT Name FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING]  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  [PLACEHOLDER-TYPE:STRING])\"\n    }\n}\n"}
{"sample_id": "dev.921", "db_id": "dog_kennels", "question": "Find the average age of the dogs who went through treatments.", "rationale": ["Identify the relevant table: The 'Dogs' table contains the age of the dogs.", "Determine the condition: We need to find dogs that have gone through treatments, which can be identified by checking if their 'dog_id' exists in the 'Treatments' table.", "Construct the SQL query: Use the AVG() function to calculate the average age of the dogs that meet the condition."], "gold_sql": "SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT AVG(age) AS average_age FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\",\n        \"virtual_table\": \"select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.924", "db_id": "dog_kennels", "question": "Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .", "rationale": ["Identify the main table to query from, which is the 'Dogs' table, to get the names of the dogs.", "We need to filter out dogs that have incurred treatment costs exceeding 1000.", "To do this, we will use a subquery that selects dog_ids from the 'Treatments' table, grouping by dog_id and summing the cost_of_treatment.", "The HAVING clause in the subquery will ensure we only select dog_ids where the total treatment cost is greater than 1000.", "The main query will then select the names of dogs whose dog_id is not in the list returned by the subquery."], "gold_sql": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT name FROM Dogs WHERE dog_id NOT IN (SELECT dog_id FROM Treatments GROUP BY dog_id HAVING SUM(cost_of_treatment) > 1000)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\",\n        \"virtual_table\": \"select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.937", "db_id": "dog_kennels", "question": "Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.", "rationale": ["Identify the relevant tables: Owners, Dogs, and Treatments are needed to find the owner who spent the most on treatments.", "Join the Owners table with the Dogs table on owner_id to link each dog to its owner.", "Join the resulting table with the Treatments table on dog_id to access treatment costs associated with each dog.", "Group the results by owner_id to aggregate treatment costs for each owner.", "Use SUM() to calculate the total treatment cost for each owner.", "Order the results in descending order based on the total treatment cost to find the highest spender.", "Limit the results to 1 to get only the owner who spent the most."], "gold_sql": "SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["owners", "dogs", "treatments"], "pred_sql": "SELECT T1.owner_id, T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id = T2.owner_id JOIN Treatments AS T3 ON T2.dog_id = T3.dog_id GROUP BY T1.owner_id ORDER BY SUM(T3.cost_of_treatment) DESC LIMIT 1", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\",\n        \"virtual_table\": \"select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.942", "db_id": "dog_kennels", "question": "Which professionals have done at least two types of treatments? List the professional id and cell phone.", "rationale": ["Identify the relevant tables: Professionals and Treatments.", "We need to find professionals who have administered at least two types of treatments, which means we will focus on the Treatments table to count distinct treatment types per professional.", "Use a subquery to group the Treatments by professional_id and count the distinct treatment_type_code for each professional.", "Filter the results in the subquery to only include professionals with a count of 2 or more.", "Select the professional_id and cell_number from the Professionals table where the professional_id matches those found in the subquery."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT professional_id, cell_number FROM Professionals WHERE professional_id IN (SELECT professional_id FROM Treatments GROUP BY professional_id HAVING COUNT(DISTINCT treatment_type_code) >= 2);", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average treatment cost. The query joins the 'Professionals' table with the 'Treatments' table to filter based on the treatment cost, using a subquery to calculate the average cost of treatments.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.943", "db_id": "dog_kennels", "question": "Find the id and cell phone of the professionals who operate two or more types of treatments.", "rationale": ["Identify the tables involved: Professionals and Treatments.", "We need to find professionals who operate two or more types of treatments, which means we need to count the distinct treatment types associated with each professional.", "Join the Professionals table with the Treatments table on the professional_id to link treatments to their respective professionals.", "Group the results by professional_id to aggregate the treatment types for each professional.", "Use the HAVING clause to filter the groups where the count of distinct treatment types is two or more."], "gold_sql": "SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2", "source_tables": ["professionals", "treatments"], "pred_sql": "SELECT P.professional_id, P.cell_number\nFROM Professionals AS P\nJOIN Treatments AS T ON P.professional_id = T.professional_id\nGROUP BY P.professional_id\nHAVING COUNT(DISTINCT T.treatment_type_code) >= 2;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average treatment cost. The query joins the 'Professionals' table with the 'Treatments' table to filter based on the treatment cost, using a subquery to calculate the average cost of treatments.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.950", "db_id": "dog_kennels", "question": "List each owner's first name, last name, and the size of his for her dog.", "rationale": ["Identify the tables needed: Owners, Dogs, and Sizes.", "We need to select the first name and last name from the Owners table.", "We also need the size of the dog, which is in the Sizes table.", "Join the Owners table with the Dogs table on owner_id to link owners to their dogs.", "Join the Dogs table with the Sizes table on size_code to get the size description of each dog.", "Select the required fields: owner's first name, last name, and dog's size description."], "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT O.first_name, O.last_name, S.size_description \nFROM Owners AS O \nJOIN Dogs AS D ON O.owner_id = D.owner_id \nJOIN Sizes AS S ON D.size_code = S.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    }\n}\n"}
{"sample_id": "dev.954", "db_id": "dog_kennels", "question": "List the names of the dogs of the rarest breed and the treatment dates of them.", "rationale": ["Identify the rarest breed by counting the occurrences of each breed in the Breeds table and selecting the one with the least count.", "Join the Dogs table with the Breeds table to filter dogs belonging to the rarest breed.", "Join the Treatments table to get the treatment dates for those dogs.", "Select the names of the dogs and their corresponding treatment dates."], "gold_sql": "SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT D.name, T.date_of_treatment \nFROM Dogs AS D \nJOIN Breeds AS B ON D.breed_code = B.breed_code \nJOIN Treatments AS T ON D.dog_id = T.dog_id \nWHERE B.breed_code = (SELECT breed_code FROM Breeds GROUP BY breed_code ORDER BY COUNT(*) ASC LIMIT 1)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\",\n        \"virtual_table\": \"select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.958", "db_id": "dog_kennels", "question": "What are the arriving date and the departing date of the dogs who have gone through a treatment?", "rationale": ["Identify the relevant tables: Dogs and Treatments.", "We need the arriving and departing dates of dogs, which are in the Dogs table.", "We need to filter the dogs that have gone through a treatment, which can be identified by checking if their dog_id exists in the Treatments table.", "Construct a subquery to select dog_ids from the Treatments table.", "Use the main query to select date_arrived and date_departed from the Dogs table where the dog_id is in the result of the subquery."], "gold_sql": "SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id", "source_tables": ["dogs", "treatments"], "pred_sql": "SELECT date_arrived, date_departed FROM Dogs WHERE dog_id IN (SELECT dog_id FROM Treatments)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\",\n        \"virtual_table\": \"select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"2\": {\n        \"description\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )\"\n    }\n}\n"}
{"sample_id": "dev.960", "db_id": "dog_kennels", "question": "List the last name of the owner owning the youngest dog.", "rationale": ["Identify the relevant tables: Owners and Dogs.", "We need to find the last name of the owner, so we will select the 'last_name' column from the Owners table.", "To link the owners to their dogs, we will join the Owners table with the Dogs table on 'owner_id'.", "To find the youngest dog, we need to determine the minimum age from the Dogs table using a subquery.", "The final query will select the last name of the owner whose dog has the minimum age."], "gold_sql": "SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs )", "source_tables": ["owners", "dogs"], "pred_sql": "SELECT O.last_name \nFROM Owners O \nJOIN Dogs D ON O.owner_id = D.owner_id \nWHERE D.age = (SELECT MIN(age) FROM Dogs)", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\",\n        \"virtual_table\": \"select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "dev.997", "db_id": "dog_kennels", "question": "Find the distinct breed type and size type combinations for dogs.", "rationale": ["We need to find distinct combinations of breed types and size types for dogs.", "To do this, we will select from the Dogs table, which contains the breed and size codes.", "We will join the Breeds table to get the breed names using the breed_code.", "We will also join the Sizes table to get the size descriptions using the size_code.", "Finally, we will use SELECT DISTINCT to ensure that we only get unique combinations of breed names and size descriptions."], "gold_sql": "SELECT DISTINCT breed_code ,  size_code FROM dogs", "source_tables": ["dogs"], "pred_sql": "SELECT DISTINCT B.breed_name, S.size_description \nFROM Dogs AS D \nJOIN Breeds AS B ON D.breed_code = B.breed_code \nJOIN Sizes AS S ON D.size_code = S.size_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of owners along with their last names who have had dogs treated, sorted by the number of treatments in descending order. The placeholder in the LIMIT clause allows for specifying the maximum number of owners to display.\",\n        \"virtual_table\": \"SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT [PLACEHOLDER-TYPE:NUMBER]\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table lists the names of dogs from the 'Dogs' table that have not received treatments exceeding a specified total cost. The placeholder in the HAVING clause represents the maximum treatment cost threshold.\",\n        \"virtual_table\": \"select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  [PLACEHOLDER-TYPE:NUMBER] )\"\n    }\n}\n"}
{"sample_id": "dev.999", "db_id": "dog_kennels", "question": "What are each professional's first name and description of the treatment they have performed?", "rationale": ["Identify the required information: first name of professionals and description of treatments they performed.", "The relevant tables are 'Professionals' for professional details, 'Treatments' for treatment records, and 'Treatment_Types' for treatment descriptions.", "Join the 'Professionals' table with the 'Treatments' table on the professional_id to link professionals to their treatments.", "Join the resulting table with the 'Treatment_Types' table on treatment_type_code to get the treatment descriptions.", "Select the first name from the 'Professionals' table and the treatment description from the 'Treatment_Types' table."], "gold_sql": "SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code", "source_tables": ["professionals", "treatments", "treatment_types"], "pred_sql": "SELECT P.first_name, TT.treatment_type_description \nFROM Professionals AS P \nJOIN Treatments AS T ON P.professional_id = T.professional_id \nJOIN Treatment_Types AS TT ON T.treatment_type_code = TT.treatment_type_code;", "hint": "Descriptions and Virtual Tables:\n{\n    \"0\": {\n        \"description\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average cost of treatments recorded in the database. The placeholders in the query allow for dynamic filtering based on treatment costs.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )\"\n    },\n    \"1\": {\n        \"description\": \"This virtual table provides a list of unique first and last names of professionals who have administered treatments that cost less than the average treatment cost. The query joins the 'Professionals' table with the 'Treatments' table to filter based on the treatment cost, using a subquery to calculate the average cost of treatments.\",\n        \"virtual_table\": \"SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )\"\n    }\n}\n"}
