{"sample_id": 3000, "db_id": "sakila_1", "question": "What is the largest payment amount?", "rationale": ["Identify the table that contains the payment information, which is the 'payment' table.", "Determine the column that holds the payment amounts, which is 'amount'.", "To find the largest payment amount, use the SQL aggregate function MAX() on the 'amount' column.", "Construct the SQL query to select the maximum amount from the 'payment' table."], "pred_sql": "SELECT MAX(amount) AS largest_payment FROM payment;", "gold_sql": "SELECT amount FROM payment ORDER BY amount DESC LIMIT 1", "source_tables": ["payment"]}
{"sample_id": 3001, "db_id": "sakila_1", "question": "Return the amount of the largest payment.", "rationale": ["Identify the table that contains the payment information, which is the 'payment' table.", "Determine the column that holds the payment amounts, which is 'amount'.", "To find the largest payment, use the SQL aggregate function MAX() on the 'amount' column.", "Construct the SQL query to select the maximum amount from the 'payment' table."], "pred_sql": "SELECT MAX(amount) AS largest_payment FROM payment;", "gold_sql": "SELECT amount FROM payment ORDER BY amount DESC LIMIT 1", "source_tables": ["payment"]}
{"sample_id": 3002, "db_id": "sakila_1", "question": "Where does the staff member with the first name Elsa live?", "rationale": ["Identify the relevant tables: staff, address, city, and country are needed to find where a staff member lives.", "The staff table contains the first name of the staff member, so we will filter by 'first_name' = 'Elsa'.", "The address table contains the address details, which we will join with the staff table using 'address_id'.", "The city table contains the city information, which we will join with the address table using 'city_id'.", "The country table contains the country information, which we will join with the city table using 'country_id'.", "Select the relevant address fields (address, address2, district), city name, and country name to provide a complete location."], "pred_sql": "SELECT address.address, address.address2, address.district, city.city, country.country \nFROM staff \nJOIN address ON staff.address_id = address.address_id \nJOIN city ON address.city_id = city.city_id \nJOIN country ON city.country_id = country.country_id \nWHERE staff.first_name = 'Elsa';", "gold_sql": "SELECT T2.address FROM staff AS T1 JOIN address AS T2 ON T1.address_id  =  T2.address_id WHERE T1.first_name  =  'Elsa'", "source_tables": ["staff", "address"]}
{"sample_id": 3003, "db_id": "sakila_1", "question": "Give the address of the staff member who has the first name Elsa.", "rationale": ["Identify the relevant tables: We need information from the 'address' table and the 'staff' table.", "Determine the relationship: The 'staff' table has a foreign key 'address_id' that links to the 'address' table.", "Specify the condition: We are looking for staff members with the first name 'Elsa'.", "Construct the SQL query: Use a JOIN to combine the 'address' and 'staff' tables, and select the address details where the staff member's first name is 'Elsa'."], "pred_sql": "SELECT address.* FROM address JOIN staff ON address.address_id = staff.address_id WHERE staff.first_name = 'Elsa';", "gold_sql": "SELECT T2.address FROM staff AS T1 JOIN address AS T2 ON T1.address_id  =  T2.address_id WHERE T1.first_name  =  'Elsa'", "source_tables": ["staff", "address"]}
{"sample_id": 3004, "db_id": "sakila_1", "question": "What are the first names of customers who have not rented any films after '2005-08-23 02:06:01'?", "rationale": ["Identify the relevant tables: We need to look at the 'customer' table for customer information and the 'rental' table to check rental activity.", "We want the first names of customers, so we will select 'first_name' from the 'customer' table.", "We need to find customers who have not rented any films after a specific date ('2005-08-23 02:06:01'). This means we need to join the 'customer' table with the 'rental' table on 'customer_id'.", "To find customers who have not rented any films after the specified date, we can use a LEFT JOIN. This will allow us to include customers who have no rental records (i.e., have never rented a film).", "In the WHERE clause, we check for two conditions: either the rental date is NULL (indicating no rentals) or the rental date is less than or equal to '2005-08-23 02:06:01'.", "Finally, we use DISTINCT to ensure that we only get unique first names in the result."], "pred_sql": "SELECT DISTINCT c.first_name \nFROM customer c \nLEFT JOIN rental r ON c.customer_id = r.customer_id \nWHERE r.rental_date IS NULL OR r.rental_date <= '2005-08-23 02:06:01';", "gold_sql": "SELECT first_name FROM customer WHERE customer_id NOT IN( SELECT customer_id FROM rental WHERE rental_date  >  '2005-08-23 02:06:01' )", "source_tables": ["customer", "rental"]}
{"sample_id": 3005, "db_id": "sakila_1", "question": "Return the first names of customers who did not rented a film after the date '2005-08-23 02:06:01'.", "rationale": ["We need to find customers who have not rented any films after a specific date.", "The relevant tables are 'customer' and 'rental'.", "We will perform a LEFT JOIN between 'customer' and 'rental' on 'customer_id'.", "We will add a condition to the JOIN to only consider rentals that occurred after '2005-08-23 02:06:01'.", "To find customers who did not rent any films after this date, we will check for NULL values in the 'rental_id' from the 'rental' table after the JOIN.", "Finally, we will select the distinct first names of these customers."], "pred_sql": "SELECT DISTINCT c.first_name \nFROM customer c \nLEFT JOIN rental r ON c.customer_id = r.customer_id AND r.rental_date > '2005-08-23 02:06:01' \nWHERE r.rental_id IS NULL;", "gold_sql": "SELECT first_name FROM customer WHERE customer_id NOT IN( SELECT customer_id FROM rental WHERE rental_date  >  '2005-08-23 02:06:01' )", "source_tables": ["customer", "rental"]}
{"sample_id": 3006, "db_id": "loan_1", "question": "How many bank branches are there?", "rationale": ["Identify the table that contains information about bank branches, which is the 'bank' table.", "To find out how many bank branches there are, we need to count the number of entries in the 'bank' table.", "Use the COUNT() function to count all rows in the 'bank' table.", "Select the count with an alias 'total_branches' for clarity."], "pred_sql": "SELECT COUNT(*) AS total_branches FROM bank;", "gold_sql": "SELECT count(*) FROM bank", "source_tables": ["bank"]}
{"sample_id": 3007, "db_id": "loan_1", "question": "Count the number of bank branches.", "rationale": ["Identify the table that contains the information about bank branches, which is the 'bank' table.", "To count the number of bank branches, we need to use the COUNT() function in SQL.", "The SQL query should select the count of all records from the 'bank' table.", "The final SQL query is constructed as 'SELECT COUNT(*) AS branch_count FROM bank;' to get the total number of branches."], "pred_sql": "SELECT COUNT(*) AS branch_count FROM bank;", "gold_sql": "SELECT count(*) FROM bank", "source_tables": ["bank"]}
{"sample_id": 3008, "db_id": "loan_1", "question": "How many customers are there?", "rationale": ["The user wants to know the total number of customers.", "To get the total number of customers, we need to count the entries in the 'customer' table.", "We will use the COUNT() function to count all rows in the 'customer' table.", "The SQL query will be: SELECT COUNT(*) AS total_customers FROM customer;"], "pred_sql": "SELECT COUNT(*) AS total_customers FROM customer;", "gold_sql": "SELECT sum(no_of_customers) FROM bank", "source_tables": ["bank"]}
{"sample_id": 3009, "db_id": "loan_1", "question": "What is the total number of customers across banks?", "rationale": ["Identify the relevant table: The 'bank' table contains the 'no_of_customers' column which holds the number of customers for each bank branch.", "Determine the operation needed: We need to calculate the total number of customers across all banks, which requires summing the 'no_of_customers' column.", "Construct the SQL query: Use the SUM() function to add up all values in the 'no_of_customers' column and select it as 'total_customers'.", "Write the final SQL query: SELECT SUM(no_of_customers) AS total_customers FROM bank;"], "pred_sql": "SELECT SUM(no_of_customers) AS total_customers FROM bank;", "gold_sql": "SELECT sum(no_of_customers) FROM bank", "source_tables": ["bank"]}
{"sample_id": 3010, "db_id": "loan_1", "question": "Find the number of customers in the banks at New York City.", "rationale": ["Identify the relevant table: The 'bank' table contains information about bank branches, including the number of customers and their locations.", "Determine the specific condition: The query specifies 'New York City', so we need to filter the results based on the 'city' column.", "Calculate the total number of customers: We need to sum the 'no_of_customers' column for all branches located in 'New York City'.", "Construct the SQL query: Use the SELECT statement to sum the 'no_of_customers' and apply the WHERE clause to filter by city."], "pred_sql": "SELECT SUM(no_of_customers) AS total_customers FROM bank WHERE city = 'New York City';", "gold_sql": "SELECT sum(no_of_customers) FROM bank WHERE city  =  'New York City'", "source_tables": ["bank"]}
{"sample_id": 3011, "db_id": "loan_1", "question": "What is the total number of customers who use banks in New York City?", "rationale": ["Identify the relevant table: The 'bank' table contains information about bank branches and the number of customers.", "Determine the specific information needed: We need the total number of customers in banks located in New York City.", "Formulate the SQL query: Use the SUM function to aggregate the 'no_of_customers' column from the 'bank' table where the 'city' is 'New York City'."], "pred_sql": "SELECT SUM(no_of_customers) AS total_customers FROM bank WHERE city = 'New York City';", "gold_sql": "SELECT sum(no_of_customers) FROM bank WHERE city  =  'New York City'", "source_tables": ["bank"]}
{"sample_id": 3012, "db_id": "loan_1", "question": "Find the average number of customers in all banks of Utah state.", "rationale": ["Identify the table that contains the relevant data: the 'bank' table holds information about bank branches, including the number of customers and their state.", "Determine the specific column needed: we need the 'no_of_customers' column to calculate the average.", "Apply the aggregate function: to find the average, we will use the AVG() function on the 'no_of_customers' column.", "Filter the results: we only want the branches located in Utah, so we will add a WHERE clause to filter by the 'state' column.", "Construct the SQL query: combine all the elements into a complete SQL statement that selects the average number of customers from the bank table where the state is Utah."], "pred_sql": "SELECT AVG(no_of_customers) AS average_customers FROM bank WHERE state = 'Utah';", "gold_sql": "SELECT avg(no_of_customers) FROM bank WHERE state  =  'Utah'", "source_tables": ["bank"]}
{"sample_id": 3013, "db_id": "loan_1", "question": "What is the average number of customers across banks in the state of Utah?", "rationale": ["Identify the table that contains the relevant data: the 'bank' table has the 'no_of_customers' and 'state' columns.", "We need to calculate the average number of customers, which requires the use of the AVG() function.", "Filter the results to only include banks located in the state of Utah by using a WHERE clause.", "Construct the SQL query to select the average number of customers from the bank table where the state is Utah."], "pred_sql": "SELECT AVG(no_of_customers) AS average_customers FROM bank WHERE state = 'Utah';", "gold_sql": "SELECT avg(no_of_customers) FROM bank WHERE state  =  'Utah'", "source_tables": ["bank"]}
{"sample_id": 3014, "db_id": "loan_1", "question": "Find the average number of customers cross all banks.", "rationale": ["Identify the table that contains the relevant data: the 'bank' table holds the number of customers.", "Determine the specific column needed: 'no_of_customers' is the column that contains the total number of customers for each bank branch.", "Use the AVG() function to calculate the average of the 'no_of_customers' column across all records in the 'bank' table.", "Construct the SQL query to select the average number of customers from the 'bank' table."], "pred_sql": "SELECT AVG(no_of_customers) AS average_customers FROM bank;", "gold_sql": "SELECT avg(no_of_customers) FROM bank", "source_tables": ["bank"]}
{"sample_id": 3015, "db_id": "loan_1", "question": "What is the average number of bank customers?", "rationale": ["Identify the table that contains the relevant data: the 'bank' table holds the number of customers.", "Determine the specific column that represents the number of customers: 'no_of_customers'.", "Use the AVG() function to calculate the average of the 'no_of_customers' column.", "Construct the SQL query to select the average number of customers from the 'bank' table."], "pred_sql": "SELECT AVG(no_of_customers) AS average_customers FROM bank;", "gold_sql": "SELECT avg(no_of_customers) FROM bank", "source_tables": ["bank"]}
{"sample_id": 3016, "db_id": "loan_1", "question": "Find the city and state of the bank branch named morningside.", "rationale": ["Identify the table that contains the information about bank branches, which is the 'bank' table.", "Determine the columns needed for the output, which are 'city' and 'state'.", "Formulate the SQL query to select 'city' and 'state' from the 'bank' table.", "Add a condition to filter the results to only include the bank branch with the name 'morningside'."], "pred_sql": "SELECT city, state FROM bank WHERE bname = 'morningside';", "gold_sql": "SELECT city ,  state FROM bank WHERE bname  =  'morningside'", "source_tables": ["bank"]}
{"sample_id": 3017, "db_id": "loan_1", "question": "What city and state is the bank with the name morningside in?", "rationale": ["Identify the table that contains the bank information, which is the 'bank' table.", "Determine the columns needed for the output, which are 'city' and 'state'.", "Specify the condition to filter the results, which is the bank name 'morningside'.", "Construct the SQL query using the SELECT statement to retrieve the desired columns from the 'bank' table with the specified condition."], "pred_sql": "SELECT city, state FROM bank WHERE bname = 'morningside';", "gold_sql": "SELECT city ,  state FROM bank WHERE bname  =  'morningside'", "source_tables": ["bank"]}
{"sample_id": 3018, "db_id": "loan_1", "question": "Find the branch names of banks in the New York state.", "rationale": ["Identify the table that contains the branch names, which is the 'bank' table.", "Determine the column that holds the branch names, which is 'bname'.", "Identify the condition needed to filter the results, which is the state being 'New York'.", "Construct the SQL query to select the 'bname' from the 'bank' table where the 'state' is 'New York'."], "pred_sql": "SELECT bname FROM bank WHERE state = 'New York';", "gold_sql": "SELECT bname FROM bank WHERE state  =  'New York'", "source_tables": ["bank"]}
{"sample_id": 3019, "db_id": "loan_1", "question": "What are the names of banks in the state of New York?", "rationale": ["Identify the table that contains the bank names, which is the 'bank' table.", "Determine the relevant column for the bank names, which is 'bname'.", "Identify the condition needed to filter the results, which is the state being 'New York'.", "Construct the SQL query to select the 'bname' from the 'bank' table where the 'state' is 'New York'."], "pred_sql": "SELECT bname FROM bank WHERE state = 'New York';", "gold_sql": "SELECT bname FROM bank WHERE state  =  'New York'", "source_tables": ["bank"]}
{"sample_id": 3020, "db_id": "loan_1", "question": "List the name of all customers sorted by their account balance in ascending order.", "rationale": ["Identify the table that contains customer names, which is the 'customer' table.", "Determine the column that holds the customer names, which is 'cust_name'.", "Identify the column that holds the account balances, which is 'acc_bal'.", "Construct the SQL query to select 'cust_name' from the 'customer' table.", "Add an ORDER BY clause to sort the results by 'acc_bal' in ascending order."], "pred_sql": "SELECT cust_name FROM customer ORDER BY acc_bal ASC;", "gold_sql": "SELECT cust_name FROM customer ORDER BY acc_bal", "source_tables": ["customer"]}
{"sample_id": 3021, "db_id": "loan_1", "question": "What are the names of all customers, ordered by account balance?", "rationale": ["Identify the table that contains customer names, which is the 'customer' table.", "Select the 'cust_name' column to retrieve the names of all customers.", "To order the results by account balance, use the 'ORDER BY' clause on the 'acc_bal' column.", "Construct the SQL query to select customer names and order them by account balance."], "pred_sql": "SELECT cust_name FROM customer ORDER BY acc_bal;", "gold_sql": "SELECT cust_name FROM customer ORDER BY acc_bal", "source_tables": ["customer"]}
{"sample_id": 3022, "db_id": "loan_1", "question": "List the name of all different customers who have some loan sorted by their total loan amount.", "rationale": ["Identify the tables involved: We need to retrieve customer names and their loan amounts, so we will use the 'customer' and 'loan' tables.", "Determine the relationship: The 'customer' table has a foreign key 'cust_ID' that relates to the 'loan' table's 'cust_ID'. This means we can join these two tables on 'cust_ID'.", "Select the required fields: We need the customer name ('cust_name') from the 'customer' table and the total loan amount from the 'loan' table.", "Calculate the total loan amount: We will use the SUM function to calculate the total loan amount for each customer.", "Group the results: We need to group the results by customer name to get the total loan amount per customer.", "Sort the results: Finally, we will sort the results by the total loan amount in ascending order."], "pred_sql": "SELECT c.cust_name, SUM(l.amount) AS total_loan_amount\nFROM customer c\nJOIN loan l ON c.cust_ID = l.cust_ID\nGROUP BY c.cust_name\nORDER BY total_loan_amount;", "gold_sql": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name ORDER BY sum(T2.amount)", "source_tables": ["customer", "loan"]}
{"sample_id": 3023, "db_id": "loan_1", "question": "What are the names of the different customers who have taken out a loan, ordered by the total amount that they have taken?", "rationale": ["Identify the relevant tables: We need to retrieve customer names and loan amounts, so we will use the 'customer' and 'loan' tables.", "Determine the relationship: The 'customer' table has a foreign key 'cust_ID' that relates to the 'loan' table's 'cust_ID'. We will join these tables on this key.", "Select the required fields: We need the customer names from the 'customer' table, so we will select 'cust_name'.", "Ensure uniqueness: Since we want the names of different customers, we will use DISTINCT to avoid duplicates.", "Order the results: We need to order the results by the total amount of loans taken, which is found in the 'loan' table under 'amount'.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "pred_sql": "SELECT DISTINCT c.cust_name FROM customer c JOIN loan l ON c.cust_ID = l.cust_ID ORDER BY l.amount DESC;", "gold_sql": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name ORDER BY sum(T2.amount)", "source_tables": ["customer", "loan"]}
{"sample_id": 3024, "db_id": "loan_1", "question": "Find the state, account type, and credit score of the customer whose number of loan is 0.", "rationale": ["Identify the relevant table: The 'customer' table contains the information about customers, including their state, account type, and number of loans.", "Determine the columns needed: We need to select 'state', 'acc_type', and 'credit_score' from the 'customer' table.", "Specify the condition: We want to filter the results to include only those customers whose 'no_of_loans' is 0.", "Construct the SQL query: Using the SELECT statement to retrieve the specified columns from the 'customer' table with the appropriate WHERE clause."], "pred_sql": "SELECT state, acc_type, credit_score FROM customer WHERE no_of_loans = 0;", "gold_sql": "SELECT state ,  acc_type ,  credit_score FROM customer WHERE no_of_loans  =  0", "source_tables": ["customer"]}
{"sample_id": 3025, "db_id": "loan_1", "question": "What are the states, account types, and credit scores for customers who have 0 loans?", "rationale": ["Identify the relevant table: The 'customer' table contains the information about customers, including their state, account type, and number of loans.", "Determine the columns needed: We need to select 'state', 'acc_type', and 'credit_score' from the 'customer' table.", "Set the condition: We want to filter customers who have 0 loans, which corresponds to the 'no_of_loans' column being equal to 0.", "Construct the SQL query: Using the SELECT statement to retrieve the specified columns from the 'customer' table with the appropriate WHERE clause."], "pred_sql": "SELECT c.state, c.acc_type, c.credit_score FROM customer c WHERE c.no_of_loans = 0;", "gold_sql": "SELECT state ,  acc_type ,  credit_score FROM customer WHERE no_of_loans  =  0", "source_tables": ["customer"]}
{"sample_id": 3026, "db_id": "loan_1", "question": "Find the number of different cities which banks are located at.", "rationale": ["Identify the table that contains the city information, which is the 'bank' table.", "To find the number of different cities, we need to count distinct entries in the 'city' column.", "Use the COUNT function to count the distinct cities.", "The final SQL query selects the count of distinct cities from the 'bank' table."], "pred_sql": "SELECT COUNT(DISTINCT city) AS number_of_cities FROM bank;", "gold_sql": "SELECT count(DISTINCT city) FROM bank", "source_tables": ["bank"]}
{"sample_id": 3027, "db_id": "loan_1", "question": "In how many different cities are banks located?", "rationale": ["Identify the table that contains the city information, which is the 'bank' table.", "To find out how many different cities banks are located in, we need to count distinct entries in the 'city' column.", "The SQL query will use the COUNT function along with DISTINCT to ensure we only count unique cities.", "The final SQL query will select the count of distinct cities from the 'bank' table."], "pred_sql": "SELECT COUNT(DISTINCT city) AS number_of_cities FROM bank;", "gold_sql": "SELECT count(DISTINCT city) FROM bank", "source_tables": ["bank"]}
{"sample_id": 3028, "db_id": "loan_1", "question": "Find the number of different states which banks are located at.", "rationale": ["Identify the table that contains the information about bank branches, which is the 'bank' table.", "Determine the column that specifies the state where each bank branch is located, which is the 'state' column in the 'bank' table.", "To find the number of different states, we need to count distinct values in the 'state' column.", "Construct the SQL query using the COUNT function along with DISTINCT to get the unique states from the 'state' column."], "pred_sql": "SELECT COUNT(DISTINCT state) AS number_of_states FROM bank;", "gold_sql": "SELECT count(DISTINCT state) FROM bank", "source_tables": ["bank"]}
{"sample_id": 3029, "db_id": "loan_1", "question": "In how many different states are banks located?", "rationale": ["Identify the table that contains the information about bank locations, which is the 'bank' table.", "Determine the relevant column that indicates the state of each bank branch, which is the 'state' column.", "To find out how many different states banks are located in, we need to count the distinct values in the 'state' column.", "Construct the SQL query to select the count of distinct states from the 'bank' table."], "pred_sql": "SELECT COUNT(DISTINCT state) AS number_of_states FROM bank;", "gold_sql": "SELECT count(DISTINCT state) FROM bank", "source_tables": ["bank"]}
{"sample_id": 3030, "db_id": "loan_1", "question": "How many distinct types of accounts are there?", "rationale": ["Identify the relevant table: The 'customer' table contains the 'acc_type' column which holds the types of accounts.", "Determine the requirement: We need to find the distinct types of accounts, which means we need to count unique values in the 'acc_type' column.", "Construct the SQL query: Use the COUNT function along with DISTINCT to count the unique account types from the 'acc_type' column in the 'customer' table."], "pred_sql": "SELECT COUNT(DISTINCT acc_type) AS distinct_account_types FROM customer;", "gold_sql": "SELECT count(DISTINCT acc_type) FROM customer", "source_tables": ["customer"]}
{"sample_id": 3031, "db_id": "loan_1", "question": "Count the number of different account types.", "rationale": ["Identify the requirement to count different account types.", "The relevant table for account types is the 'customer' table.", "Use the COUNT function to count distinct values in the 'acc_type' column.", "Formulate the SQL query to select the count of distinct account types from the customer table."], "pred_sql": "SELECT COUNT(DISTINCT acc_type) AS different_account_types FROM customer;", "gold_sql": "SELECT count(DISTINCT acc_type) FROM customer", "source_tables": ["customer"]}
{"sample_id": 3032, "db_id": "loan_1", "question": "Find the name and account balance of the customer whose name includes the letter \u2018a\u2019.", "rationale": ["Identify the table that contains customer information, which is the 'customer' table.", "Determine the columns needed for the output: 'cust_name' and 'acc_bal'.", "Formulate a condition to filter customers whose names include the letter 'a'.", "Use the SQL LIKE operator with wildcards to match any customer name containing 'a'.", "Combine these elements into a complete SQL SELECT statement."], "pred_sql": "SELECT cust_name, acc_bal FROM customer WHERE cust_name LIKE '%a%';", "gold_sql": "SELECT cust_name ,  acc_bal FROM customer WHERE cust_name LIKE '%a%'", "source_tables": ["customer"]}
{"sample_id": 3033, "db_id": "loan_1", "question": "What are the names and account balances of customers with the letter a in their names?", "rationale": ["Identify the relevant table: The 'customer' table contains the information about customers, including their names and account balances.", "Determine the required columns: We need to select 'cust_name' and 'acc_bal' from the 'customer' table.", "Apply the filtering condition: We want to find customers whose names contain the letter 'a'. This can be done using the SQL LIKE operator with wildcards.", "Construct the SQL SELECT statement: Combine the selected columns and the filtering condition to form the complete SQL query."], "pred_sql": "SELECT cust_name, acc_bal FROM customer WHERE cust_name LIKE '%a%';", "gold_sql": "SELECT cust_name ,  acc_bal FROM customer WHERE cust_name LIKE '%a%'", "source_tables": ["customer"]}
{"sample_id": 3034, "db_id": "loan_1", "question": "Find the total account balance of each customer from Utah or Texas.", "rationale": ["Identify the relevant table: The 'customer' table contains the account balance and state information.", "Determine the columns needed: We need the account balance (acc_bal) and the customer name (cust_name).", "Filter the records: We want customers from either Utah or Texas, so we will use a WHERE clause with the IN operator.", "Calculate the total account balance: We will use the SUM function to get the total account balance for each customer.", "Group the results: Since we want the total balance for each customer, we will group the results by customer name."], "pred_sql": "SELECT SUM(acc_bal) AS total_account_balance, cust_name FROM customer WHERE state IN ('Utah', 'Texas') GROUP BY cust_name;", "gold_sql": "SELECT sum(acc_bal) FROM customer WHERE state  =  'Utah' OR state  =  'Texas'", "source_tables": ["customer"]}
{"sample_id": 3035, "db_id": "loan_1", "question": "What are the total account balances for each customer from Utah or Texas?", "rationale": ["Identify the relevant table: The 'customer' table contains the account balances and state information.", "Determine the columns needed: We need 'cust_name' for the customer's name and 'acc_bal' for the account balance.", "Filter the results: We want customers from either Utah or Texas, so we will use a WHERE clause with the IN operator to specify these states.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE clause to form the complete SQL query."], "pred_sql": "SELECT cust_name, acc_bal FROM customer WHERE state IN ('Utah', 'Texas');", "gold_sql": "SELECT sum(acc_bal) FROM customer WHERE state  =  'Utah' OR state  =  'Texas'", "source_tables": ["customer"]}
{"sample_id": 3036, "db_id": "loan_1", "question": "Find the name of customers who have both saving and checking account types.", "rationale": ["Identify the relevant table: The 'customer' table contains information about customers and their account types.", "Determine the required fields: We need the 'cust_name' of customers who have both saving and checking account types.", "Use the WHERE clause to filter customers: We will filter the records where 'acc_type' is either 'saving' or 'checking'.", "Group the results by customer name: This allows us to aggregate the account types for each customer.", "Use the HAVING clause to ensure that only customers with both account types are selected: We will check that the count of distinct account types for each customer is 2."], "pred_sql": "SELECT cust_name FROM customer WHERE acc_type IN ('saving', 'checking') GROUP BY cust_name HAVING COUNT(DISTINCT acc_type) = 2;", "gold_sql": "SELECT cust_name FROM customer WHERE acc_type  =  'saving' INTERSECT SELECT cust_name FROM customer WHERE acc_type  =  'checking'", "source_tables": ["customer"]}
{"sample_id": 3037, "db_id": "loan_1", "question": "What are the names of customers who have both savings and checking accounts?", "rationale": ["Identify the relevant table: The 'customer' table contains information about customers and their account types.", "Determine the condition: We need to find customers who have both 'savings' and 'checking' accounts.", "Use the 'acc_type' column to filter for 'savings' and 'checking' accounts.", "Group the results by 'cust_name' to aggregate the account types for each customer.", "Use the HAVING clause to ensure that only customers with both account types are included, which means counting distinct account types should equal 2."], "pred_sql": "SELECT cust_name FROM customer WHERE acc_type IN ('savings', 'checking') GROUP BY cust_name HAVING COUNT(DISTINCT acc_type) = 2;", "gold_sql": "SELECT cust_name FROM customer WHERE acc_type  =  'saving' INTERSECT SELECT cust_name FROM customer WHERE acc_type  =  'checking'", "source_tables": ["customer"]}
{"sample_id": 3038, "db_id": "loan_1", "question": "Find the name of customers who do not have an saving account.", "rationale": ["Identify the table that contains customer information, which is the 'customer' table.", "Determine the relevant column for customer names, which is 'cust_name'.", "Identify the column that indicates the type of account held by the customer, which is 'acc_type'.", "Formulate a condition to filter out customers who do not have a savings account, which can be expressed as 'acc_type != 'savings'.", "Combine the selected columns and the condition into a SQL SELECT statement."], "pred_sql": "SELECT cust_name FROM customer WHERE acc_type != 'savings';", "gold_sql": "SELECT cust_name FROM customer EXCEPT SELECT cust_name FROM customer WHERE acc_type  =  'saving'", "source_tables": ["customer"]}
{"sample_id": 3039, "db_id": "loan_1", "question": "What are the names of customers who do not have saving accounts?", "rationale": ["Identify the table that contains customer information, which is the 'customer' table.", "Determine the relevant column for customer names, which is 'cust_name'.", "Identify the column that indicates the type of account, which is 'acc_type'.", "Formulate a condition to filter out customers who do not have a savings account, which can be expressed as 'acc_type != 'savings'.", "Combine the selected columns and the condition into a SQL SELECT statement."], "pred_sql": "SELECT cust_name FROM customer WHERE acc_type != 'savings';", "gold_sql": "SELECT cust_name FROM customer EXCEPT SELECT cust_name FROM customer WHERE acc_type  =  'saving'", "source_tables": ["customer"]}
{"sample_id": 3040, "db_id": "loan_1", "question": "Find the name of customers who do not have a loan with a type of Mortgages.", "rationale": ["Identify the relevant tables: We need to retrieve customer names from the 'customer' table and check their loan status from the 'loan' table.", "Determine the condition: We want customers who do not have a loan of type 'Mortgages'. This means we need to find customers who either have no loans at all or have loans of other types.", "Use a LEFT JOIN: To find customers without a specific type of loan, we can use a LEFT JOIN between the 'customer' table and the 'loan' table on the customer ID.", "Filter the results: We will filter the results to include only those customers where the loan ID is NULL for the 'Mortgages' loan type, indicating they do not have that loan type."], "pred_sql": "SELECT cust.cust_name \nFROM customer cust \nLEFT JOIN loan l ON cust.cust_ID = l.cust_ID AND l.loan_type = 'Mortgages' \nWHERE l.loan_ID IS NULL;", "gold_sql": "SELECT cust_name FROM customer EXCEPT SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE T2.loan_type  =  'Mortgages'", "source_tables": ["customer", "loan"]}
{"sample_id": 3041, "db_id": "loan_1", "question": "What are the names of customers who have not taken a Mortage loan?", "rationale": ["Identify the relevant table: We need to retrieve customer names, so we will focus on the 'customer' table.", "Determine the condition: We want customers who have not taken a Mortgage loan.", "To find customers who have taken a Mortgage loan, we will use a subquery on the 'loan' table to get the 'cust_ID' of customers with a loan_type of 'Mortgage'.", "Use the NOT IN clause to filter out those customers from the main query that selects 'cust_name' from the 'customer' table."], "pred_sql": "SELECT cust_name FROM customer WHERE cust_ID NOT IN (SELECT cust_ID FROM loan WHERE loan_type = 'Mortgage');", "gold_sql": "SELECT cust_name FROM customer EXCEPT SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE T2.loan_type  =  'Mortgages'", "source_tables": ["customer", "loan"]}
{"sample_id": 3042, "db_id": "loan_1", "question": "Find the name of customers who have loans of both Mortgages and Auto.", "rationale": ["Identify the tables involved: We need to retrieve customer names and their loans, so we will use the 'customer' and 'loan' tables.", "Determine the relationship: The 'customer' table has a foreign key 'cust_ID' that relates to the 'loan' table's 'cust_ID'. We will join these tables on this key.", "Filter for specific loan types: We need to find customers who have loans of both 'Mortgages' and 'Auto'. This requires filtering the loan types in the WHERE clause.", "Group by customer: Since we want to count the distinct loan types per customer, we will group the results by 'cust_ID'.", "Count distinct loan types: To ensure that a customer has both types of loans, we will use the HAVING clause to count distinct loan types and check that it equals 2."], "pred_sql": "SELECT DISTINCT c.cust_name \nFROM customer c \nJOIN loan l ON c.cust_ID = l.cust_ID \nWHERE l.loan_type IN ('Mortgages', 'Auto') \nGROUP BY c.cust_ID \nHAVING COUNT(DISTINCT l.loan_type) = 2;", "gold_sql": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE loan_type  =  'Mortgages' INTERSECT SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE loan_type  =  'Auto'", "source_tables": ["customer", "loan"]}
{"sample_id": 3043, "db_id": "loan_1", "question": "What are the names of customers who have taken both Mortgage and Auto loans?", "rationale": ["Identify the relevant tables: We need to access the 'customer' and 'loan' tables to get customer names and their loan types.", "We need to find customers who have taken both Mortgage and Auto loans. This requires joining the 'loan' table twice to check for both loan types for the same customer.", "Use a JOIN operation to link the 'customer' table with the 'loan' table based on the customer ID.", "Filter the results to include only those customers who have a loan type of 'Mortgage' in one join and 'Auto' in the other join.", "Select distinct customer names to avoid duplicates in the result."], "pred_sql": "SELECT DISTINCT c.cust_name \nFROM customer c \nJOIN loan l1 ON c.cust_ID = l1.cust_ID \nJOIN loan l2 ON c.cust_ID = l2.cust_ID \nWHERE l1.loan_type = 'Mortgage' AND l2.loan_type = 'Auto';", "gold_sql": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE loan_type  =  'Mortgages' INTERSECT SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE loan_type  =  'Auto'", "source_tables": ["customer", "loan"]}
{"sample_id": 3044, "db_id": "loan_1", "question": "Find the name of customers whose credit score is below the average credit scores of all customers.", "rationale": ["Identify the relevant table: The 'customer' table contains the 'cust_name' and 'credit_score' columns needed for the query.", "Determine the condition: We need to find customers whose credit score is below the average credit score of all customers.", "Calculate the average credit score: Use a subquery to calculate the average credit score from the 'customer' table using AVG(credit_score).", "Formulate the main query: Select 'cust_name' from the 'customer' table where 'credit_score' is less than the average calculated in the subquery."], "pred_sql": "SELECT cust_name FROM customer WHERE credit_score < (SELECT AVG(credit_score) FROM customer);", "gold_sql": "SELECT cust_name FROM customer WHERE credit_score  <  (SELECT avg(credit_score) FROM customer)", "source_tables": ["customer"]}
{"sample_id": 3045, "db_id": "loan_1", "question": "What are the names of customers with credit score less than the average credit score across customers?", "rationale": ["Identify the relevant table: The 'customer' table contains the information about customers, including their names and credit scores.", "Determine the condition: We need to find customers with a credit score less than the average credit score.", "Calculate the average credit score: Use a subquery to calculate the average credit score from the 'customer' table using AVG(credit_score).", "Formulate the main query: Select the 'cust_name' from the 'customer' table where the 'credit_score' is less than the average calculated in the subquery."], "pred_sql": "SELECT cust_name FROM customer WHERE credit_score < (SELECT AVG(credit_score) FROM customer);", "gold_sql": "SELECT cust_name FROM customer WHERE credit_score  <  (SELECT avg(credit_score) FROM customer)", "source_tables": ["customer"]}
{"sample_id": 3046, "db_id": "loan_1", "question": "Find the branch name of the bank that has the most number of customers.", "rationale": ["Identify the table that contains the branch names and the number of customers, which is the 'bank' table.", "To find the branch with the most customers, we need to sort the results by the 'no_of_customers' column in descending order.", "We will limit the results to 1 to get only the branch with the highest number of customers.", "The final SQL query selects the branch name ('bname') from the 'bank' table, orders the results by 'no_of_customers' in descending order, and limits the output to the top result."], "pred_sql": "SELECT b.bname FROM bank b ORDER BY b.no_of_customers DESC LIMIT 1;", "gold_sql": "SELECT bname FROM bank ORDER BY no_of_customers DESC LIMIT 1", "source_tables": ["bank"]}
{"sample_id": 3047, "db_id": "loan_1", "question": "What is the name of the bank branch with the greatest number of customers?", "rationale": ["Identify the table that contains the bank branch information, which is the 'bank' table.", "Determine the relevant column that holds the name of the bank branch, which is 'bname'.", "Identify the column that indicates the number of customers associated with each branch, which is 'no_of_customers'.", "To find the branch with the greatest number of customers, we need to sort the results in descending order based on 'no_of_customers'.", "Since we only need the branch with the greatest number of customers, we will limit the results to 1 using 'LIMIT 1'.", "Combine these elements to form the SQL query: SELECT bname FROM bank ORDER BY no_of_customers DESC LIMIT 1."], "pred_sql": "SELECT bname FROM bank ORDER BY no_of_customers DESC LIMIT 1;", "gold_sql": "SELECT bname FROM bank ORDER BY no_of_customers DESC LIMIT 1", "source_tables": ["bank"]}
{"sample_id": 3048, "db_id": "loan_1", "question": "Find the name of customer who has the lowest credit score.", "rationale": ["Identify the relevant table: The 'customer' table contains the information about customers including their credit scores.", "Determine the requirement: We need to find the customer with the lowest credit score.", "Use the MIN function to find the lowest credit score from the 'credit_score' column in the 'customer' table.", "Use a subquery to get the minimum credit score and then select the customer name from the 'customer' table where the credit score matches this minimum value."], "pred_sql": "SELECT cust_name FROM customer WHERE credit_score = (SELECT MIN(credit_score) FROM customer);", "gold_sql": "SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1", "source_tables": ["customer"]}
{"sample_id": 3049, "db_id": "loan_1", "question": "What is the name of the customer with the worst credit score?", "rationale": ["Identify the relevant table: The 'customer' table contains the information about customers including their credit scores.", "Determine the required information: We need the name of the customer with the worst credit score, which means we need to sort the customers by their credit score in ascending order.", "Construct the SQL query: Use a SELECT statement to get the 'cust_name' from the 'customer' table, and order the results by 'credit_score' in ascending order.", "Limit the results to 1 to get only the customer with the worst credit score."], "pred_sql": "SELECT cust_name FROM customer ORDER BY credit_score ASC LIMIT 1;", "gold_sql": "SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1", "source_tables": ["customer"]}
{"sample_id": 3050, "db_id": "loan_1", "question": "Find the name, account type, and account balance of the customer who has the highest credit score.", "rationale": ["Identify the columns needed: cust_name, acc_type, and acc_bal from the customer table.", "Determine the condition to find the customer with the highest credit score, which requires using the MAX function on the credit_score column.", "Use a subquery to find the maximum credit score from the customer table.", "Select the desired columns from the customer table where the credit_score matches the maximum value found in the subquery."], "pred_sql": "SELECT cust_name, acc_type, acc_bal FROM customer WHERE credit_score = (SELECT MAX(credit_score) FROM customer);", "gold_sql": "SELECT cust_name ,  acc_type ,  acc_bal FROM customer ORDER BY credit_score DESC LIMIT 1", "source_tables": ["customer"]}
{"sample_id": 3051, "db_id": "loan_1", "question": "What is the name, account type, and account balance corresponding to the customer with the highest credit score?", "rationale": ["Identify the columns needed: cust_name, acc_type, and acc_bal from the customer table.", "Determine the condition to find the customer with the highest credit score, which requires using the MAX function on the credit_score column.", "Use a subquery to find the maximum credit score from the customer table.", "Select the desired columns from the customer table where the credit_score matches the maximum value found in the subquery."], "pred_sql": "SELECT cust_name, acc_type, acc_bal FROM customer WHERE credit_score = (SELECT MAX(credit_score) FROM customer);", "gold_sql": "SELECT cust_name ,  acc_type ,  acc_bal FROM customer ORDER BY credit_score DESC LIMIT 1", "source_tables": ["customer"]}
{"sample_id": 3052, "db_id": "loan_1", "question": "Find the name of customer who has the highest amount of loans.", "rationale": ["Identify the table that contains customer names, which is the 'customer' table.", "Determine that we need to find the customer with the highest amount of loans, which requires us to look at the 'loan' table.", "To find the customer with the highest amount of loans, we will need to group the loans by 'cust_ID' and sum the 'amount' of loans for each customer.", "We will order the results of this sum in descending order to get the customer with the highest total loan amount at the top.", "Finally, we will limit the results to just one customer and use their 'cust_ID' to retrieve their name from the 'customer' table."], "pred_sql": "SELECT cust_name FROM customer WHERE cust_ID = (SELECT cust_ID FROM loan GROUP BY cust_ID ORDER BY SUM(amount) DESC LIMIT 1);", "gold_sql": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name ORDER BY sum(T2.amount) DESC LIMIT 1", "source_tables": ["customer", "loan"]}
{"sample_id": 3053, "db_id": "loan_1", "question": "What is the name of the customer who has greatest total loan amount?", "rationale": ["Identify the relevant tables: We need to look at the 'customer' table for customer names and the 'loan' table for loan amounts.", "Join the 'customer' and 'loan' tables on the 'cust_ID' to associate customers with their loans.", "Group the results by customer ID to aggregate the total loan amount for each customer.", "Use the SUM function to calculate the total loan amount for each customer.", "Order the results in descending order based on the total loan amount to find the customer with the greatest total loan amount.", "Limit the results to 1 to get only the top customer."], "pred_sql": "SELECT c.cust_name FROM customer c JOIN loan l ON c.cust_ID = l.cust_ID GROUP BY c.cust_ID ORDER BY SUM(l.amount) DESC LIMIT 1;", "gold_sql": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name ORDER BY sum(T2.amount) DESC LIMIT 1", "source_tables": ["customer", "loan"]}
{"sample_id": 3054, "db_id": "loan_1", "question": "Find the state which has the most number of customers.", "rationale": ["Identify the relevant table: The 'customer' table contains information about customers and their associated states.", "Group the data by state: We need to count the number of customers in each state, so we will use the GROUP BY clause on the 'state' column.", "Count the number of customers: Use the COUNT function to count the number of 'cust_ID' entries for each state.", "Order the results: To find the state with the most customers, we will order the results in descending order based on the count of customers.", "Limit the results: Since we only want the state with the most customers, we will limit the results to 1."], "pred_sql": "SELECT state FROM customer GROUP BY state ORDER BY COUNT(cust_ID) DESC LIMIT 1;", "gold_sql": "SELECT state FROM bank GROUP BY state ORDER BY sum(no_of_customers) DESC LIMIT 1", "source_tables": ["bank"]}
{"sample_id": 3055, "db_id": "loan_1", "question": "Which state has the greatest total number of bank customers?", "rationale": ["Identify the relevant table: The 'bank' table contains the information about bank branches and the number of customers associated with each branch.", "Determine the required information: We need to find the total number of customers grouped by state.", "Use the SUM function to calculate the total number of customers for each state.", "Group the results by the 'state' column to aggregate the customer counts.", "Order the results in descending order to find the state with the greatest total number of customers.", "Limit the results to 1 to get only the state with the highest total."], "pred_sql": "SELECT state, SUM(no_of_customers) AS total_customers FROM bank GROUP BY state ORDER BY total_customers DESC LIMIT 1;", "gold_sql": "SELECT state FROM bank GROUP BY state ORDER BY sum(no_of_customers) DESC LIMIT 1", "source_tables": ["bank"]}
{"sample_id": 3056, "db_id": "loan_1", "question": "For each account type, find the average account balance of customers with credit score lower than 50.", "rationale": ["Identify the relevant table: The 'customer' table contains the account type and account balance information, as well as the credit score.", "Filter the customers: We need to focus on customers with a credit score lower than 50, so we will use a WHERE clause to filter these records.", "Calculate the average balance: We need to calculate the average account balance for each account type, which can be done using the AVG() function.", "Group the results: Since we want the average balance for each account type, we will use the GROUP BY clause on the 'acc_type' column."], "pred_sql": "SELECT acc_type, AVG(acc_bal) AS average_balance \nFROM customer \nWHERE credit_score < 50 \nGROUP BY acc_type;", "gold_sql": "SELECT avg(acc_bal) ,  acc_type FROM customer WHERE credit_score  <  50 GROUP BY acc_type", "source_tables": ["customer"]}
{"sample_id": 3057, "db_id": "loan_1", "question": "What is the average account balance of customers with credit score below 50 for the different account types?", "rationale": ["Identify the relevant table: The 'customer' table contains the necessary information about account types and account balances.", "Determine the conditions: We need to filter customers with a credit score below 50.", "Select the required fields: We need to select 'acc_type' and the average of 'acc_bal'.", "Use the AVG() function to calculate the average account balance for the filtered customers.", "Group the results by 'acc_type' to get the average balance for each account type."], "pred_sql": "SELECT acc_type, AVG(acc_bal) AS average_balance FROM customer WHERE credit_score < 50 GROUP BY acc_type;", "gold_sql": "SELECT avg(acc_bal) ,  acc_type FROM customer WHERE credit_score  <  50 GROUP BY acc_type", "source_tables": ["customer"]}
{"sample_id": 3058, "db_id": "loan_1", "question": "For each state, find the total account balance of customers whose credit score is above 100.", "rationale": ["Identify the relevant table: The 'customer' table contains the account balance and credit score information.", "Select the required columns: We need the state and the total account balance, so we will select 'c.state' and use the SUM function on 'c.acc_bal'.", "Apply the condition: We need to filter customers whose credit score is above 100, so we will add a WHERE clause for 'c.credit_score > 100'.", "Group the results: Since we want the total account balance for each state, we will use GROUP BY on 'c.state'.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "pred_sql": "SELECT c.state, SUM(c.acc_bal) AS total_account_balance\nFROM customer c\nWHERE c.credit_score > 100\nGROUP BY c.state;", "gold_sql": "SELECT sum(acc_bal) ,  state FROM customer WHERE credit_score  >  100 GROUP BY state", "source_tables": ["customer"]}
{"sample_id": 3059, "db_id": "loan_1", "question": "What is the total account balance for customers with a credit score of above 100 for the different states?", "rationale": ["Identify the relevant table: The 'customer' table contains the account balance and credit score information.", "Select the required columns: We need the state and the total account balance, so we will select 'c.state' and use the SUM function on 'c.acc_bal'.", "Apply the condition: We need to filter customers with a credit score above 100, so we will add a WHERE clause for 'c.credit_score > 100'.", "Group the results: Since we want the total account balance for different states, we will use GROUP BY on 'c.state'.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "pred_sql": "SELECT c.state, SUM(c.acc_bal) AS total_account_balance \nFROM customer c \nWHERE c.credit_score > 100 \nGROUP BY c.state;", "gold_sql": "SELECT sum(acc_bal) ,  state FROM customer WHERE credit_score  >  100 GROUP BY state", "source_tables": ["customer"]}
{"sample_id": 3060, "db_id": "loan_1", "question": "Find the total amount of loans offered by each bank branch.", "rationale": ["Identify the tables involved: We need data from the 'bank' and 'loan' tables.", "Determine the relationship: The 'loan' table has a foreign key 'branch_ID' that relates to the 'bank' table's 'branch_ID'.", "Select the required fields: We need the bank branch name ('bname') and the total amount of loans ('amount').", "Use the SUM function to calculate the total amount of loans for each branch.", "Group the results by bank branch name to get the total loans per branch."], "pred_sql": "SELECT bank.bname, SUM(loan.amount) AS total_loans FROM bank JOIN loan ON bank.branch_ID = loan.branch_ID GROUP BY bank.bname;", "gold_sql": "SELECT sum(amount) ,  T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id  =  T2.branch_id GROUP BY T1.bname", "source_tables": ["bank", "loan"]}
{"sample_id": 3061, "db_id": "loan_1", "question": "What are the names of the different bank branches, and what are their total loan amounts?", "rationale": ["Identify the tables needed: We need data from the 'bank' table for branch names and the 'loan' table for loan amounts.", "Determine the relationship: The 'bank' and 'loan' tables are related through the 'branch_ID' column.", "Select the required columns: We need the branch name ('bname') from the 'bank' table and the total loan amount, which requires summing the 'amount' from the 'loan' table.", "Use JOIN to combine the two tables on 'branch_ID'.", "Group the results by branch name to get the total loan amount for each branch."], "pred_sql": "SELECT b.bname, SUM(l.amount) AS total_loan_amount\nFROM bank b\nJOIN loan l ON b.branch_ID = l.branch_ID\nGROUP BY b.bname;", "gold_sql": "SELECT sum(amount) ,  T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id  =  T2.branch_id GROUP BY T1.bname", "source_tables": ["bank", "loan"]}
{"sample_id": 3062, "db_id": "loan_1", "question": "Find the name of customers who have more than one loan.", "rationale": ["Identify the relevant table: We need to find customer names, so we will primarily work with the 'customer' table.", "Determine the condition: We are looking for customers who have more than one loan. This means we need to count the loans associated with each customer.", "Use the 'loan' table: We will group the loans by 'cust_ID' and count the number of loans for each customer.", "Apply the HAVING clause: We will filter the grouped results to only include those customers who have a count greater than 1.", "Select the customer names: Finally, we will select the 'cust_name' from the 'customer' table where the 'cust_ID' matches those who have more than one loan."], "pred_sql": "SELECT cust_name FROM customer WHERE cust_ID IN (SELECT cust_ID FROM loan GROUP BY cust_ID HAVING COUNT(loan_ID) > 1);", "gold_sql": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name HAVING count(*)  >  1", "source_tables": ["customer", "loan"]}
{"sample_id": 3063, "db_id": "loan_1", "question": "What are the names of customers who have taken out more than one loan?", "rationale": ["Identify the relevant tables: We need to look at the 'customer' table for customer names and the 'loan' table to find out how many loans each customer has taken.", "Join the 'customer' table with the 'loan' table on the 'cust_ID' field to associate customers with their loans.", "Group the results by 'cust_ID' to aggregate the loan counts for each customer.", "Use the HAVING clause to filter the groups to only include those customers who have taken out more than one loan."], "pred_sql": "SELECT c.cust_name FROM customer c JOIN loan l ON c.cust_ID = l.cust_ID GROUP BY c.cust_ID HAVING COUNT(l.loan_ID) > 1;", "gold_sql": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name HAVING count(*)  >  1", "source_tables": ["customer", "loan"]}
{"sample_id": 3064, "db_id": "loan_1", "question": "Find the name and account balance of the customers who have loans with a total amount of more than 5000.", "rationale": ["Identify the relevant tables: We need information from the 'customer' table for customer details and the 'loan' table for loan amounts.", "Determine the columns to select: We need the customer's name ('cust_name') and account balance ('acc_bal').", "Establish the relationship between tables: Customers and loans are related through 'cust_ID', so we will perform a JOIN on these tables using this key.", "Set the condition for the loan amount: We want to filter the results to include only those loans where the total amount is greater than 5000.", "Construct the SQL query: Combine the SELECT statement, JOIN condition, and WHERE clause to form the complete SQL query."], "pred_sql": "SELECT c.cust_name, c.acc_bal FROM customer c JOIN loan l ON c.cust_ID = l.cust_ID WHERE l.amount > 5000;", "gold_sql": "SELECT T1.cust_name ,  T1.acc_type FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name HAVING sum(T2.amount)  >  5000", "source_tables": ["customer", "loan"]}
{"sample_id": 3065, "db_id": "loan_1", "question": "What are the names and account balances for customers who have taken a total amount of more than 5000 in loans?", "rationale": ["Identify the relevant tables: We need to retrieve customer names and account balances, which are in the 'customer' table, and we need to consider loans, which are in the 'loan' table.", "Determine the relationship between tables: The 'customer' table and the 'loan' table are related through the 'cust_ID' field. We will need to join these tables on this field to access both customer and loan information.", "Select the required fields: We need to select 'cust_name' and 'acc_bal' from the 'customer' table.", "Aggregate loan amounts: We need to calculate the total loan amount for each customer, which requires grouping by 'cust_ID' and summing the 'amount' from the 'loan' table.", "Apply the condition: We only want customers whose total loan amount exceeds 5000, which can be enforced using the HAVING clause after the GROUP BY."], "pred_sql": "SELECT c.cust_name, c.acc_bal FROM customer c JOIN loan l ON c.cust_ID = l.cust_ID GROUP BY c.cust_ID HAVING SUM(l.amount) > 5000;", "gold_sql": "SELECT T1.cust_name ,  T1.acc_type FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id GROUP BY T1.cust_name HAVING sum(T2.amount)  >  5000", "source_tables": ["customer", "loan"]}
{"sample_id": 3066, "db_id": "loan_1", "question": "Find the name of bank branch that provided the greatest total amount of loans.", "rationale": ["Identify the relevant tables: We need to use the 'bank' and 'loan' tables to find the bank branch with the greatest total amount of loans.", "Join the tables: We will join the 'bank' table with the 'loan' table on the 'branch_ID' column, which is common to both tables.", "Group by branch: We need to group the results by the 'branch_ID' from the 'bank' table to aggregate the loan amounts for each branch.", "Calculate total loan amount: Use the SUM function to calculate the total amount of loans for each branch.", "Order the results: We will order the results in descending order based on the total loan amount to find the branch with the greatest total.", "Limit the results: Finally, we will limit the results to 1 to get only the branch with the greatest total amount of loans."], "pred_sql": "SELECT b.bname FROM bank b JOIN loan l ON b.branch_ID = l.branch_ID GROUP BY b.branch_ID ORDER BY SUM(l.amount) DESC LIMIT 1;", "gold_sql": "SELECT T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id  =  T2.branch_id GROUP BY T1.bname ORDER BY sum(T2.amount) DESC LIMIT 1", "source_tables": ["bank", "loan"]}
{"sample_id": 3067, "db_id": "loan_1", "question": "What is the name of the bank branch that has lent the greatest amount?", "rationale": ["Identify the relevant tables: We need to find information from the 'bank' and 'loan' tables.", "Determine the relationship: The 'loan' table has a foreign key 'branch_ID' that links to the 'bank' table's 'branch_ID'.", "We need to sum the loan amounts for each bank branch to find out which branch has lent the greatest amount.", "Use a JOIN to combine the 'bank' and 'loan' tables on 'branch_ID'.", "Group the results by 'branch_ID' to aggregate the loan amounts for each branch.", "Order the results by the total loan amount in descending order to get the branch with the highest total loan amount at the top.", "Limit the results to 1 to get only the branch with the greatest amount lent."], "pred_sql": "SELECT b.bname FROM bank b JOIN loan l ON b.branch_ID = l.branch_ID GROUP BY b.branch_ID ORDER BY SUM(l.amount) DESC LIMIT 1;", "gold_sql": "SELECT T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id  =  T2.branch_id GROUP BY T1.bname ORDER BY sum(T2.amount) DESC LIMIT 1", "source_tables": ["bank", "loan"]}
{"sample_id": 3068, "db_id": "loan_1", "question": "Find the name of bank branch that provided the greatest total amount of loans to customers with credit score is less than 100.", "rationale": ["Identify the relevant tables: bank, loan, and customer.", "We need to find the bank branch names, so we will select the 'bname' column from the bank table.", "To find the total amount of loans, we will join the loan table with the bank table on 'branch_ID'.", "We also need to filter customers based on their credit score, so we will join the customer table with the loan table on 'cust_ID'.", "The condition specifies that we only want customers with a credit score less than 100, so we will add a WHERE clause for this condition.", "To get the total amount of loans per branch, we will use GROUP BY on 'branch_ID' and calculate the SUM of the loan amounts.", "Finally, we want the branch that provided the greatest total amount of loans, so we will order the results by the total amount in descending order and limit the results to 1."], "pred_sql": "SELECT b.bname\nFROM bank b\nJOIN loan l ON b.branch_ID = l.branch_ID\nJOIN customer c ON l.cust_ID = c.cust_ID\nWHERE c.credit_score < 100\nGROUP BY b.branch_ID\nORDER BY SUM(l.amount) DESC\nLIMIT 1;", "gold_sql": "SELECT T2.bname FROM loan AS T1 JOIN bank AS T2 ON T1.branch_id  =  T2.branch_id JOIN customer AS T3 ON T1.cust_id  =  T3.cust_id WHERE T3.credit_score  <  100 GROUP BY T2.bname ORDER BY sum(T1.amount) DESC LIMIT 1", "source_tables": ["customer", "bank", "loan"]}
{"sample_id": 3069, "db_id": "loan_1", "question": "What is the name of the bank branch that has lended the largest total amount in loans, specifically to customers with credit scores below 100?", "rationale": ["Identify the relevant tables: bank, loan, and customer.", "We need to find the bank branch that has lent the largest total amount in loans, so we will join the bank and loan tables on branch_ID.", "We also need to filter the loans based on customers' credit scores, so we will join the loan table with the customer table on cust_ID.", "We will apply a condition to filter customers with credit scores below 100.", "We will group the results by bank branch to calculate the total loan amount for each branch.", "Finally, we will order the results by the total loan amount in descending order and limit the results to the top one branch."], "pred_sql": "SELECT b.bname FROM bank b JOIN loan l ON b.branch_ID = l.branch_ID JOIN customer c ON l.cust_ID = c.cust_ID WHERE c.credit_score < 100 GROUP BY b.branch_ID ORDER BY SUM(l.amount) DESC LIMIT 1;", "gold_sql": "SELECT T2.bname FROM loan AS T1 JOIN bank AS T2 ON T1.branch_id  =  T2.branch_id JOIN customer AS T3 ON T1.cust_id  =  T3.cust_id WHERE T3.credit_score  <  100 GROUP BY T2.bname ORDER BY sum(T1.amount) DESC LIMIT 1", "source_tables": ["customer", "bank", "loan"]}
{"sample_id": 3070, "db_id": "loan_1", "question": "Find the name of bank branches that provided some loans.", "rationale": ["Identify the relevant tables: We need information from the 'bank' and 'loan' tables.", "Determine the relationship: The 'loan' table has a foreign key 'branch_ID' that links to the 'bank' table's 'branch_ID'.", "Select the required fields: We need the name of the bank branches, which is in the 'bname' column of the 'bank' table.", "Use a JOIN operation: To find bank branches that provided loans, we will join the 'bank' table with the 'loan' table on the 'branch_ID'.", "Use DISTINCT: Since a branch may provide multiple loans, we use DISTINCT to ensure each branch name is listed only once."], "pred_sql": "SELECT DISTINCT b.bname FROM bank b JOIN loan l ON b.branch_ID = l.branch_ID;", "gold_sql": "SELECT DISTINCT T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id  =  T2.branch_id", "source_tables": ["bank", "loan"]}
{"sample_id": 3071, "db_id": "loan_1", "question": "What are the names of the different banks that have provided loans?", "rationale": ["Identify the relevant tables: We need information from the 'bank' and 'loan' tables.", "Determine the relationship: The 'loan' table has a foreign key 'branch_ID' that links to the 'bank' table's 'branch_ID'.", "Select the required fields: We need the names of the banks, which is in the 'bname' column of the 'bank' table.", "Use DISTINCT to ensure we only get unique bank names that have provided loans.", "Construct the SQL query using a JOIN to combine the 'bank' and 'loan' tables based on the 'branch_ID'."], "pred_sql": "SELECT DISTINCT b.bname FROM bank b JOIN loan l ON b.branch_ID = l.branch_ID;", "gold_sql": "SELECT DISTINCT T1.bname FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id  =  T2.branch_id", "source_tables": ["bank", "loan"]}
{"sample_id": 3072, "db_id": "loan_1", "question": "Find the name and credit score of the customers who have some loans.", "rationale": ["Identify the relevant tables: We need information from the 'customer' table for customer details and the 'loan' table to find customers who have loans.", "Determine the required fields: We need the 'cust_name' and 'credit_score' from the 'customer' table.", "Establish the relationship: Customers with loans can be found by joining the 'customer' table with the 'loan' table on 'cust_ID'.", "Construct the SQL query: Use a SELECT statement to retrieve the desired fields from the joined tables."], "pred_sql": "SELECT c.cust_name, c.credit_score FROM customer c JOIN loan l ON c.cust_ID = l.cust_ID;", "gold_sql": "SELECT DISTINCT T1.cust_name ,  T1.credit_score FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id", "source_tables": ["customer", "loan"]}
{"sample_id": 3073, "db_id": "loan_1", "question": "What are the different names and credit scores of customers who have taken a loan?", "rationale": ["Identify the relevant tables: We need information from the 'customer' table for customer names and credit scores, and the 'loan' table to find customers who have taken loans.", "Determine the relationship: The 'customer' table and 'loan' table are related through the 'cust_ID' field, which allows us to join these tables.", "Select the required fields: We need to select the distinct customer names and their credit scores from the 'customer' table.", "Construct the SQL query: Use a JOIN clause to combine the 'customer' and 'loan' tables based on the 'cust_ID', and select the distinct names and credit scores."], "pred_sql": "SELECT DISTINCT c.cust_name, c.credit_score \nFROM customer c \nJOIN loan l ON c.cust_ID = l.cust_ID;", "gold_sql": "SELECT DISTINCT T1.cust_name ,  T1.credit_score FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id", "source_tables": ["customer", "loan"]}
{"sample_id": 3074, "db_id": "loan_1", "question": "Find the the name of the customers who have a loan with amount more than 3000.", "rationale": ["Identify the tables involved: We need information from the 'customer' table for customer names and the 'loan' table for loan amounts.", "Determine the relationship between the tables: The 'customer' table and 'loan' table are related through 'cust_ID'.", "Specify the condition: We want to filter loans where the amount is greater than 3000.", "Construct the SQL query: Use a JOIN to combine the 'customer' and 'loan' tables, select the customer names, and apply the condition on loan amounts."], "pred_sql": "SELECT c.cust_name FROM customer c JOIN loan l ON c.cust_ID = l.cust_ID WHERE l.amount > 3000;", "gold_sql": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE amount  >  3000", "source_tables": ["customer", "loan"]}
{"sample_id": 3075, "db_id": "loan_1", "question": "What are the names of customers who have a loan of more than 3000 in amount?", "rationale": ["Identify the relevant tables: We need information from the 'customer' table for customer names and the 'loan' table for loan amounts.", "Determine the relationship: The 'customer' table and 'loan' table are related through 'cust_ID'.", "Specify the condition: We want to filter loans where the amount is greater than 3000.", "Construct the SQL query: Use a JOIN to combine the 'customer' and 'loan' tables, select the customer names, and apply the condition on loan amount."], "pred_sql": "SELECT c.cust_name FROM customer c JOIN loan l ON c.cust_ID = l.cust_ID WHERE l.amount > 3000;", "gold_sql": "SELECT T1.cust_name FROM customer AS T1 JOIN loan AS T2 ON T1.cust_id  =  T2.cust_id WHERE amount  >  3000", "source_tables": ["customer", "loan"]}
{"sample_id": 3076, "db_id": "loan_1", "question": "Find the city and name of bank branches that provide business loans.", "rationale": ["Identify the relevant tables: We need information from the 'bank' and 'loan' tables.", "Determine the columns needed: We need the 'city' and 'bname' from the 'bank' table.", "Establish the relationship: The 'loan' table has a foreign key 'branch_ID' that relates to the 'bank' table's 'branch_ID'.", "Filter the results: We only want branches that provide 'business' loans, so we will add a WHERE clause to filter by 'loan_type'.", "Construct the SQL query: Using a JOIN to combine the 'bank' and 'loan' tables, selecting the distinct 'city' and 'bname' where the loan type is 'business'."], "pred_sql": "SELECT DISTINCT b.city, b.bname FROM bank b JOIN loan l ON b.branch_ID = l.branch_ID WHERE l.loan_type = 'business';", "gold_sql": "SELECT T1.bname ,  T1.city FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id  =  T2.branch_id WHERE T2.loan_type  =  'Business'", "source_tables": ["bank", "loan"]}
{"sample_id": 3077, "db_id": "loan_1", "question": "What are the names and cities of bank branches that offer loans for business?", "rationale": ["Identify the relevant tables: We need information from the 'bank' and 'loan' tables.", "Determine the columns needed: We need the names of the bank branches (bname) and their cities (city).", "Establish the relationship: The 'loan' table has a foreign key 'branch_ID' that links to the 'bank' table's 'branch_ID'.", "Filter the loans: We want to filter the loans to only include those that are of type 'business'.", "Construct the SQL query: Use a JOIN to combine the 'bank' and 'loan' tables, select the required columns, and apply the filter for loan type."], "pred_sql": "SELECT DISTINCT b.bname, b.city FROM bank b JOIN loan l ON b.branch_ID = l.branch_ID WHERE l.loan_type = 'business';", "gold_sql": "SELECT T1.bname ,  T1.city FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id  =  T2.branch_id WHERE T2.loan_type  =  'Business'", "source_tables": ["bank", "loan"]}
{"sample_id": 3078, "db_id": "loan_1", "question": "Find the names of bank branches that have provided a loan to any customer whose credit score is below 100.", "rationale": ["Identify the relevant tables: bank, loan, and customer.", "We need to find bank branches that have issued loans, so we will join the bank and loan tables on branch_ID.", "Next, we need to filter customers based on their credit score, so we will join the loan table with the customer table on cust_ID.", "The condition specifies that we are only interested in customers with a credit score below 100, so we will add this condition in the WHERE clause.", "Finally, we select the distinct names of the bank branches that meet these criteria."], "pred_sql": "SELECT DISTINCT b.bname \nFROM bank b \nJOIN loan l ON b.branch_ID = l.branch_ID \nJOIN customer c ON l.cust_ID = c.cust_ID \nWHERE c.credit_score < 100;", "gold_sql": "SELECT T2.bname FROM loan AS T1 JOIN bank AS T2 ON T1.branch_id  =  T2.branch_id JOIN customer AS T3 ON T1.cust_id  =  T3.cust_id WHERE T3.credit_score  <  100", "source_tables": ["customer", "bank", "loan"]}
{"sample_id": 3079, "db_id": "loan_1", "question": "What are the names of banks that have loaned money to customers with credit scores below 100?", "rationale": ["Identify the relevant tables: bank, loan, and customer.", "We need to find banks that have loaned money, so we will join the bank and loan tables on branch_ID.", "Next, we need to filter customers based on their credit scores, so we will join the loan table with the customer table on cust_ID.", "The condition specifies that we are only interested in customers with credit scores below 100, so we will add a WHERE clause for this condition.", "Finally, we want the names of the banks, so we will select the distinct bank names from the result."], "pred_sql": "SELECT DISTINCT b.bname \nFROM bank b \nJOIN loan l ON b.branch_ID = l.branch_ID \nJOIN customer c ON l.cust_ID = c.cust_ID \nWHERE c.credit_score < 100;", "gold_sql": "SELECT T2.bname FROM loan AS T1 JOIN bank AS T2 ON T1.branch_id  =  T2.branch_id JOIN customer AS T3 ON T1.cust_id  =  T3.cust_id WHERE T3.credit_score  <  100", "source_tables": ["customer", "bank", "loan"]}
{"sample_id": 3080, "db_id": "loan_1", "question": "Find the total amount of loans provided by bank branches in the state of New York.", "rationale": ["Identify the relevant tables: We need data from the 'loan' table to get the loan amounts and the 'bank' table to filter by state.", "Determine the relationship: The 'loan' table has a foreign key 'branch_ID' that relates to the 'bank' table's 'branch_ID'.", "Formulate the selection criteria: We want to filter the results to only include branches located in the state of New York.", "Calculate the total amount of loans: We will use the SUM function to aggregate the loan amounts from the 'loan' table for the filtered branches."], "pred_sql": "SELECT SUM(loan.amount) AS total_loans FROM loan JOIN bank ON loan.branch_ID = bank.branch_ID WHERE bank.state = 'New York';", "gold_sql": "SELECT sum(T2.amount) FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id  =  T2.branch_id WHERE T1.state  =  'New York'", "source_tables": ["bank", "loan"]}
{"sample_id": 3081, "db_id": "loan_1", "question": "What is the total amount of money loaned by banks in New York state?", "rationale": ["Identify the relevant table for loans, which is the 'loan' table.", "We need to calculate the total amount of loans, so we will use the SUM function on the 'amount' column in the 'loan' table.", "To filter the loans by banks located in New York state, we need to join the 'loan' table with the 'bank' table based on the 'branch_ID'.", "We will create a subquery to select all 'branch_ID's from the 'bank' table where the 'state' is 'New York'.", "The final SQL query will sum the 'amount' of loans from the 'loan' table where the 'branch_ID' matches those from the subquery."], "pred_sql": "SELECT SUM(amount) AS total_loaned_amount FROM loan WHERE branch_ID IN (SELECT branch_ID FROM bank WHERE state = 'New York');", "gold_sql": "SELECT sum(T2.amount) FROM bank AS T1 JOIN loan AS T2 ON T1.branch_id  =  T2.branch_id WHERE T1.state  =  'New York'", "source_tables": ["bank", "loan"]}
{"sample_id": 3082, "db_id": "loan_1", "question": "Find the average credit score of the customers who have some loan.", "rationale": ["Identify the requirement: We need to find the average credit score of customers who have taken out loans.", "Determine the relevant tables: The 'customer' table contains credit scores, and the 'loan' table contains information about loans taken by customers.", "Establish the relationship: We need to join the 'customer' table with the 'loan' table on the 'cust_ID' field, as this is the common identifier between the two tables.", "Formulate the SQL query: We will select the average of the 'credit_score' from the 'customer' table where there is a corresponding entry in the 'loan' table."], "pred_sql": "SELECT AVG(c.credit_score) AS average_credit_score\nFROM customer c\nJOIN loan l ON c.cust_ID = l.cust_ID;", "gold_sql": "SELECT avg(credit_score) FROM customer WHERE cust_id IN (SELECT cust_id FROM loan)", "source_tables": ["customer", "loan"]}
{"sample_id": 3083, "db_id": "loan_1", "question": "What is the average credit score for customers who have taken a loan?", "rationale": ["Identify the relevant tables: We need data from the 'customer' table for credit scores and the 'loan' table to filter customers who have taken loans.", "Determine the relationship: The 'customer' table and 'loan' table are related through 'cust_ID'.", "Formulate the query: We need to calculate the average credit score of customers who have taken a loan, which requires joining the two tables on 'cust_ID'.", "Use the AVG() function: To get the average credit score, we will use the AVG() function on the 'credit_score' column from the 'customer' table."], "pred_sql": "SELECT AVG(c.credit_score) AS average_credit_score\nFROM customer c\nJOIN loan l ON c.cust_ID = l.cust_ID;", "gold_sql": "SELECT avg(credit_score) FROM customer WHERE cust_id IN (SELECT cust_id FROM loan)", "source_tables": ["customer", "loan"]}
{"sample_id": 3084, "db_id": "loan_1", "question": "Find the average credit score of the customers who do not have any loan.", "rationale": ["Identify the table that contains the credit score information, which is the 'customer' table.", "To find customers without any loans, we need to check the 'loan' table for any entries related to customers.", "We will use a subquery to select all 'cust_ID's from the 'loan' table.", "The main query will then select the average credit score from the 'customer' table where the 'cust_ID' is not in the list of 'cust_ID's obtained from the subquery."], "pred_sql": "SELECT AVG(credit_score) AS average_credit_score FROM customer WHERE cust_ID NOT IN (SELECT cust_ID FROM loan);", "gold_sql": "SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan)", "source_tables": ["customer", "loan"]}
{"sample_id": 3085, "db_id": "loan_1", "question": "What is the average credit score for customers who have never taken a loan?", "rationale": ["Identify the relevant table: The 'customer' table contains the credit scores of customers.", "Determine the condition: We need to find customers who have never taken a loan, which means their IDs should not be present in the 'loan' table.", "Use a subquery to find customers with loans: The subquery 'SELECT cust_ID FROM loan' retrieves all customer IDs that have taken loans.", "Filter the main query: The main query selects the average credit score from the 'customer' table where the customer ID is not in the list of IDs returned by the subquery.", "Calculate the average: Use the AVG() function to compute the average credit score of the filtered customers."], "pred_sql": "SELECT AVG(credit_score) AS average_credit_score FROM customer WHERE cust_ID NOT IN (SELECT cust_ID FROM loan);", "gold_sql": "SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan)", "source_tables": ["customer", "loan"]}
{"sample_id": 3086, "db_id": "behavior_monitoring", "question": "How many assessment notes are there in total?", "rationale": ["Identify the table that contains assessment notes, which is 'Assessment_Notes'.", "To find the total number of assessment notes, we need to count the records in this table.", "Use the COUNT() function to count all rows in the 'Assessment_Notes' table.", "Construct the SQL query to select the count and label it as 'total_assessment_notes'."], "pred_sql": "SELECT COUNT(*) AS total_assessment_notes FROM Assessment_Notes;", "gold_sql": "SELECT count(*) FROM ASSESSMENT_NOTES", "source_tables": ["assessment_notes"]}
{"sample_id": 3087, "db_id": "behavior_monitoring", "question": "What are the dates of the assessment notes?", "rationale": ["Identify the table that contains assessment notes, which is 'Assessment_Notes'.", "Determine the relevant column that holds the dates of the assessment notes, which is 'date_of_notes'.", "Construct a SQL query to select the 'date_of_notes' from the 'Assessment_Notes' table."], "pred_sql": "SELECT date_of_notes FROM Assessment_Notes;", "gold_sql": "SELECT date_of_notes FROM Assessment_Notes", "source_tables": ["assessment_notes"]}
{"sample_id": 3088, "db_id": "behavior_monitoring", "question": "How many addresses have zip code 197?", "rationale": ["Identify the table that contains the zip code information, which is the 'Addresses' table.", "Determine the specific column that holds the zip code, which is 'zip_postcode'.", "Formulate a query to count the number of records in the 'Addresses' table where the 'zip_postcode' matches '197'.", "Use the COUNT() function to get the total number of addresses with the specified zip code."], "pred_sql": "SELECT COUNT(*) AS address_count FROM Addresses WHERE zip_postcode = '197';", "gold_sql": "SELECT count(*) FROM ADDRESSES WHERE zip_postcode  =  '197'", "source_tables": ["addresses"]}
{"sample_id": 3089, "db_id": "behavior_monitoring", "question": "How many distinct incident type codes are there?", "rationale": ["Identify the table that contains the incident type codes, which is 'Ref_Incident_Type'.", "Determine the column that holds the incident type codes, which is 'incident_type_code'.", "To find the number of distinct incident type codes, use the COUNT function along with DISTINCT to count unique values in the 'incident_type_code' column.", "Construct the SQL query to select the count of distinct incident type codes from the 'Ref_Incident_Type' table."], "pred_sql": "SELECT COUNT(DISTINCT incident_type_code) AS distinct_incident_type_count FROM Ref_Incident_Type;", "gold_sql": "SELECT count(DISTINCT incident_type_code) FROM Behavior_Incident", "source_tables": ["behavior_incident"]}
{"sample_id": 3090, "db_id": "behavior_monitoring", "question": "Return all distinct detention type codes.", "rationale": ["Identify the table that contains the detention type codes, which is 'Ref_Detention_Type'.", "Determine the column that holds the detention type codes, which is 'detention_type_code'.", "Since the request is to return distinct values, use the DISTINCT keyword in the SQL query.", "Construct the SQL query to select distinct detention type codes from the specified table."], "pred_sql": "SELECT DISTINCT detention_type_code FROM Ref_Detention_Type;", "gold_sql": "SELECT DISTINCT detention_type_code FROM Detention", "source_tables": ["detention"]}
{"sample_id": 3091, "db_id": "behavior_monitoring", "question": "What are the start and end dates for incidents with incident type code \"NOISE\"?", "rationale": ["Identify the relevant table for incidents, which is Behavior_Incident.", "Determine the columns needed: date_incident_start and date_incident_end.", "Find the incident_type_code for the description 'NOISE' from the Ref_Incident_Type table.", "Construct a SQL query to select the start and end dates from Behavior_Incident where the incident_type_code matches the one found for 'NOISE'."], "pred_sql": "SELECT date_incident_start, date_incident_end FROM Behavior_Incident WHERE incident_type_code = (SELECT incident_type_code FROM Ref_Incident_Type WHERE incident_type_description = 'NOISE')", "gold_sql": "SELECT date_incident_start ,  date_incident_end FROM Behavior_Incident WHERE incident_type_code  =  'NOISE'", "source_tables": ["behavior_incident"]}
{"sample_id": 3092, "db_id": "behavior_monitoring", "question": "Return all detention summaries.", "rationale": ["Identify the table that contains the required information: the Detention table holds the detention summaries.", "Determine the specific column needed: the detention_summary column contains the summaries of detentions.", "Construct the SQL query to select the detention_summary from the Detention table."], "pred_sql": "SELECT detention_summary FROM Detention;", "gold_sql": "SELECT detention_summary FROM Detention", "source_tables": ["detention"]}
{"sample_id": 3093, "db_id": "behavior_monitoring", "question": "Return the cell phone number and email address for all students.", "rationale": ["Identify the required columns: cell_mobile_number and email_address from the Students table.", "Determine the table to query: Students.", "Construct the SQL SELECT statement to retrieve the specified columns from the Students table."], "pred_sql": "SELECT cell_mobile_number, email_address FROM Students;", "gold_sql": "SELECT cell_mobile_number ,  email_address FROM STUDENTS", "source_tables": ["students"]}
{"sample_id": 3094, "db_id": "behavior_monitoring", "question": "What is the email of the student with first name \"Emma\" and last name \"Rohan\"?", "rationale": ["Identify the table that contains student information, which is the 'Students' table.", "Determine the columns needed for the query: we need the 'email_address' of the student.", "Specify the conditions to filter the results: the student's first name must be 'Emma' and the last name must be 'Rohan'.", "Construct the SQL SELECT statement to retrieve the 'email_address' from the 'Students' table with the specified conditions."], "pred_sql": "SELECT email_address FROM Students WHERE first_name = 'Emma' AND last_name = 'Rohan';", "gold_sql": "SELECT email_address FROM Students WHERE first_name  =  'Emma' AND last_name  =  'Rohan'", "source_tables": ["students"]}
{"sample_id": 3095, "db_id": "behavior_monitoring", "question": "How many distinct students have been in detention?", "rationale": ["Identify the relevant table: Students_in_Detention, which links students to their detention records.", "To find the number of distinct students, we need to count unique student IDs in the Students_in_Detention table.", "Use the COUNT function with DISTINCT to ensure we only count each student once, regardless of how many detentions they have had."], "pred_sql": "SELECT COUNT(DISTINCT student_id) AS distinct_students_in_detention FROM Students_in_Detention;", "gold_sql": "SELECT count(DISTINCT student_id) FROM Students_in_Detention", "source_tables": ["students_in_detention"]}
{"sample_id": 3096, "db_id": "behavior_monitoring", "question": "What is the gender of the teacher with last name \"Medhurst\"?", "rationale": ["Identify the table that contains the information about teachers, which is the 'Teachers' table.", "Determine the column that holds the gender information, which is 'gender'.", "Identify the condition needed to filter the results, which is the last name of the teacher being 'Medhurst'.", "Construct the SQL query to select the 'gender' from the 'Teachers' table where the 'last_name' matches 'Medhurst'."], "pred_sql": "SELECT gender FROM Teachers WHERE last_name = 'Medhurst';", "gold_sql": "SELECT gender FROM TEACHERS WHERE last_name  =  'Medhurst'", "source_tables": ["teachers"]}
{"sample_id": 3097, "db_id": "behavior_monitoring", "question": "What is the incident type description for the incident type with code \"VIOLENCE\"?", "rationale": ["Identify the table that contains the incident type descriptions, which is 'Ref_Incident_Type'.", "Determine the column that holds the incident type description, which is 'incident_type_description'.", "Identify the column that contains the unique code for the incident type, which is 'incident_type_code'.", "Formulate the SQL query to select the 'incident_type_description' from 'Ref_Incident_Type' where 'incident_type_code' equals 'VIOLENCE'."], "pred_sql": "SELECT incident_type_description FROM Ref_Incident_Type WHERE incident_type_code = 'VIOLENCE';", "gold_sql": "SELECT incident_type_description FROM Ref_Incident_Type WHERE incident_type_code  =  'VIOLENCE'", "source_tables": ["ref_incident_type"]}
{"sample_id": 3098, "db_id": "behavior_monitoring", "question": "Find the maximum and minimum monthly rental for all student addresses.", "rationale": ["Identify the relevant table: The 'Student_Addresses' table contains the 'monthly_rental' column which is needed for the query.", "Determine the required calculations: We need to find both the maximum and minimum values of the 'monthly_rental' column.", "Construct the SQL query: Use the SELECT statement to retrieve the maximum and minimum values from the 'monthly_rental' column, using the MAX() and MIN() functions respectively."], "pred_sql": "SELECT MAX(monthly_rental) AS max_monthly_rental, MIN(monthly_rental) AS min_monthly_rental FROM Student_Addresses;", "gold_sql": "SELECT max(monthly_rental) ,  min(monthly_rental) FROM Student_Addresses", "source_tables": ["student_addresses"]}
{"sample_id": 3099, "db_id": "behavior_monitoring", "question": "Find the first names of teachers whose email address contains the word \"man\".", "rationale": ["Identify the table that contains the information needed: Teachers.", "Determine the specific column that holds the first names of teachers: first_name.", "Identify the column that contains the email addresses: email_address.", "Formulate a condition to filter teachers whose email address contains the word 'man'.", "Use the SQL LIKE operator with wildcards to match any email address containing 'man'.", "Construct the SQL SELECT statement to retrieve the first names based on the specified condition."], "pred_sql": "SELECT first_name FROM Teachers WHERE email_address LIKE '%man%';", "gold_sql": "SELECT first_name FROM Teachers WHERE email_address LIKE '%man%'", "source_tables": ["teachers"]}
{"sample_id": 3100, "db_id": "behavior_monitoring", "question": "List all information about the assessment notes sorted by date in ascending order.", "rationale": ["Identify the table that contains the required information: Assessment_Notes.", "Select all columns from the Assessment_Notes table using SELECT *.", "Specify the sorting order by the date_of_notes column in ascending order using ORDER BY date_of_notes ASC."], "pred_sql": "SELECT * FROM Assessment_Notes ORDER BY date_of_notes ASC;", "gold_sql": "SELECT * FROM Assessment_Notes ORDER BY date_of_notes ASC", "source_tables": ["assessment_notes"]}
{"sample_id": 3101, "db_id": "behavior_monitoring", "question": "List all cities of addresses in alphabetical order.", "rationale": ["Identify the table that contains the city information, which is the 'Addresses' table.", "Select the 'city' column from the 'Addresses' table.", "Use DISTINCT to ensure that each city is listed only once.", "Order the results in alphabetical order using ORDER BY city ASC."], "pred_sql": "SELECT DISTINCT city FROM Addresses ORDER BY city ASC;", "gold_sql": "SELECT city FROM Addresses ORDER BY city", "source_tables": ["addresses"]}
{"sample_id": 3102, "db_id": "behavior_monitoring", "question": "Find the first names and last names of teachers in alphabetical order of last name.", "rationale": ["Identify the required columns: first_name and last_name from the Teachers table.", "Determine the sorting requirement: alphabetical order of last names.", "Construct the SQL SELECT statement to retrieve the specified columns from the Teachers table.", "Add the ORDER BY clause to sort the results by last_name in ascending order."], "pred_sql": "SELECT first_name, last_name FROM Teachers ORDER BY last_name ASC;", "gold_sql": "SELECT first_name ,  last_name FROM Teachers ORDER BY last_name", "source_tables": ["teachers"]}
{"sample_id": 3103, "db_id": "behavior_monitoring", "question": "Find all information about student addresses, and sort by monthly rental in descending order.", "rationale": ["Identify the table that contains student address information, which is 'Student_Addresses'.", "Determine the columns needed; since the request is for all information, we will select all columns using '*'.", "The user wants the results sorted by 'monthly_rental', so we will include an ORDER BY clause.", "Specify that the sorting should be in descending order by using 'DESC'.", "Combine these elements to form the complete SQL query."], "pred_sql": "SELECT * FROM Student_Addresses ORDER BY monthly_rental DESC;", "gold_sql": "SELECT * FROM Student_Addresses ORDER BY monthly_rental DESC", "source_tables": ["student_addresses"]}
{"sample_id": 3104, "db_id": "behavior_monitoring", "question": "Find the id and first name of the student that has the most number of assessment notes?", "rationale": ["Identify the relevant tables: Students and Assessment_Notes.", "We need to find the student with the most assessment notes, so we will group the Assessment_Notes by student_id and count the number of notes for each student.", "Order the results by the count of notes in descending order to get the student with the most notes at the top.", "Limit the results to 1 to get only the top student.", "Now, we need to retrieve the student_id and first_name from the Students table for the student identified in the previous step.", "We will use a subquery to find the student_id of the student with the most assessment notes and then select the corresponding first_name from the Students table."], "pred_sql": "SELECT student_id, first_name FROM Students WHERE student_id = (SELECT student_id FROM Assessment_Notes GROUP BY student_id ORDER BY COUNT(*) DESC LIMIT 1)", "gold_sql": "SELECT T1.student_id ,  T2.first_name FROM Assessment_Notes AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["students", "assessment_notes"]}
{"sample_id": 3105, "db_id": "behavior_monitoring", "question": "Find the ids and first names of the 3 teachers that have the most number of assessment notes?", "rationale": ["Identify the relevant tables: Teachers and Assessment_Notes.", "We need to join these two tables on the teacher_id to link teachers with their assessment notes.", "Group the results by teacher_id and first_name to aggregate the count of assessment notes for each teacher.", "Order the results by the count of assessment notes in descending order to get the teachers with the most notes at the top.", "Limit the results to the top 3 teachers."], "pred_sql": "SELECT T.teacher_id, T.first_name\nFROM Teachers T\nJOIN Assessment_Notes AN ON T.teacher_id = AN.teacher_id\nGROUP BY T.teacher_id, T.first_name\nORDER BY COUNT(AN.notes_id) DESC\nLIMIT 3;", "gold_sql": "SELECT T1.teacher_id ,  T2.first_name FROM Assessment_Notes AS T1 JOIN Teachers AS T2 ON T1.teacher_id  =  T2.teacher_id GROUP BY T1.teacher_id ORDER BY count(*) DESC LIMIT 3", "source_tables": ["teachers", "assessment_notes"]}
{"sample_id": 3106, "db_id": "behavior_monitoring", "question": "Find the id and last name of the student that has the most behavior incidents?", "rationale": ["Identify the relevant tables: Students and Behavior_Incident.", "We need to find the student with the most behavior incidents, so we will count the number of incidents per student.", "Use a subquery to group the Behavior_Incident table by student_id and count the number of incidents for each student.", "Order the results of the subquery by the count of incidents in descending order to get the student with the most incidents at the top.", "Limit the subquery to 1 to get only the top student.", "Finally, select the student_id and last_name from the Students table where the student_id matches the one from the subquery."], "pred_sql": "SELECT student_id, last_name FROM Students WHERE student_id = (SELECT student_id FROM Behavior_Incident GROUP BY student_id ORDER BY COUNT(*) DESC LIMIT 1)", "gold_sql": "SELECT T1.student_id ,  T2.last_name FROM Behavior_Incident AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["behavior_incident", "students"]}
{"sample_id": 3107, "db_id": "behavior_monitoring", "question": "Find the id and last name of the teacher that has the most detentions with detention type code \"AFTER\"?", "rationale": ["Identify the relevant tables: Teachers and Detention.", "We need to find the teacher with the most detentions of a specific type, so we will join the Teachers table with the Detention table on the teacher_id.", "Filter the results to only include detentions with the detention type code 'AFTER'.", "Group the results by teacher_id and last_name to count the number of detentions for each teacher.", "Order the results by the count of detentions in descending order to get the teacher with the most detentions at the top.", "Limit the results to 1 to get only the teacher with the highest count."], "pred_sql": "SELECT t.teacher_id, t.last_name\nFROM Teachers t\nJOIN Detention d ON t.teacher_id = d.teacher_id\nWHERE d.detention_type_code = 'AFTER'\nGROUP BY t.teacher_id, t.last_name\nORDER BY COUNT(d.detention_id) DESC\nLIMIT 1;", "gold_sql": "SELECT T1.teacher_id ,  T2.last_name FROM Detention AS T1 JOIN Teachers AS T2 ON T1.teacher_id  =  T2.teacher_id WHERE T1.detention_type_code  =  'AFTER' GROUP BY T1.teacher_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["teachers", "detention"]}
{"sample_id": 3108, "db_id": "behavior_monitoring", "question": "What are the id and first name of the student whose addresses have the highest average monthly rental?", "rationale": ["Identify the relevant tables: Students and Student_Addresses.", "We need to find the average monthly rental for each student, so we will join the Students table with the Student_Addresses table on student_id.", "Group the results by student_id and first_name to calculate the average monthly rental for each student.", "Use the AVG function to calculate the average monthly rental.", "Order the results in descending order to get the student with the highest average monthly rental at the top.", "Limit the results to 1 to get only the student with the highest average monthly rental."], "pred_sql": "SELECT s.student_id, s.first_name\nFROM Students s\nJOIN Student_Addresses sa ON s.student_id = sa.student_id\nGROUP BY s.student_id, s.first_name\nORDER BY AVG(sa.monthly_rental) DESC\nLIMIT 1;", "gold_sql": "SELECT T1.student_id ,  T2.first_name FROM Student_Addresses AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY AVG(monthly_rental) DESC LIMIT 1", "source_tables": ["student_addresses", "students"]}
{"sample_id": 3109, "db_id": "behavior_monitoring", "question": "Find the id and city of the student address with the highest average monthly rental.", "rationale": ["Identify the relevant tables: We need to find information from the Student_Addresses and Addresses tables.", "Determine the columns needed: We need the student_id from Student_Addresses and the city from Addresses.", "Calculate the average monthly rental: We will order the results by the monthly rental in descending order to find the highest.", "Limit the results to one: Since we only want the address with the highest average monthly rental, we will use LIMIT 1."], "pred_sql": "SELECT sa.student_id, a.city\nFROM Student_Addresses sa\nJOIN Addresses a ON sa.address_id = a.address_id\nORDER BY sa.monthly_rental DESC\nLIMIT 1;", "gold_sql": "SELECT T2.address_id ,  T1.city FROM Addresses AS T1 JOIN Student_Addresses AS T2 ON T1.address_id  =  T2.address_id GROUP BY T2.address_id ORDER BY AVG(monthly_rental) DESC LIMIT 1", "source_tables": ["addresses", "student_addresses"]}
{"sample_id": 3110, "db_id": "behavior_monitoring", "question": "What are the code and description of the most frequent behavior incident type?", "rationale": ["Identify the table that contains the incident types, which is 'Ref_Incident_Type'.", "Identify the table that contains the behavior incidents, which is 'Behavior_Incident'.", "To find the most frequent incident type, I need to group the incidents by 'incident_type_code' and count them.", "Order the grouped results by the count in descending order to get the most frequent incident type at the top.", "Limit the results to 1 to get only the most frequent incident type code.", "Now, I need to select the 'incident_type_code' and its corresponding 'incident_type_description' from 'Ref_Incident_Type' where the 'incident_type_code' matches the most frequent one found in the previous step."], "pred_sql": "SELECT incident_type_code, incident_type_description\nFROM Ref_Incident_Type\nWHERE incident_type_code IN (\n    SELECT incident_type_code\n    FROM Behavior_Incident\n    GROUP BY incident_type_code\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)", "gold_sql": "SELECT T1.incident_type_code ,  T2.incident_type_description FROM Behavior_Incident AS T1 JOIN Ref_Incident_Type AS T2 ON T1.incident_type_code  =  T2.incident_type_code GROUP BY T1.incident_type_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["ref_incident_type", "behavior_incident"]}
{"sample_id": 3111, "db_id": "behavior_monitoring", "question": "What are the code and description of the least frequent detention type ?", "rationale": ["Identify the table that contains the detention types, which is Ref_Detention_Type.", "Determine that we need to find the least frequent detention type, which requires counting occurrences in the Detention table.", "Use a subquery to count the number of records for each detention type in the Detention table, grouping by detention_type_code.", "Order the results of the subquery by the count in ascending order to find the least frequent type.", "Limit the subquery to return only the least frequent detention type code.", "Finally, select the code and description of that detention type from the Ref_Detention_Type table."], "pred_sql": "SELECT detention_type_code, detention_type_description FROM Ref_Detention_Type WHERE detention_type_code = (SELECT detention_type_code FROM Detention GROUP BY detention_type_code ORDER BY COUNT(*) ASC LIMIT 1)", "gold_sql": "SELECT T1.detention_type_code ,  T2.detention_type_description FROM Detention AS T1 JOIN Ref_Detention_Type AS T2 ON T1.detention_type_code  =  T2.detention_type_code GROUP BY T1.detention_type_code ORDER BY count(*) ASC LIMIT 1", "source_tables": ["ref_detention_type", "detention"]}
{"sample_id": 3112, "db_id": "behavior_monitoring", "question": "Find the dates of assessment notes for students with first name \"Fanny\".", "rationale": ["Identify the relevant tables: Assessment_Notes and Students.", "Determine the columns needed: date_of_notes from Assessment_Notes and first_name from Students.", "Establish the relationship between the tables using the foreign key: Assessment_Notes.student_id links to Students.student_id.", "Filter the results to only include students with the first name 'Fanny'.", "Construct the SQL query to select the date_of_notes for the specified students."], "pred_sql": "SELECT Assessment_Notes.date_of_notes \nFROM Assessment_Notes \nJOIN Students ON Assessment_Notes.student_id = Students.student_id \nWHERE Students.first_name = 'Fanny';", "gold_sql": "SELECT T1.date_of_notes FROM Assessment_Notes AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id WHERE T2.first_name  =  'Fanny'", "source_tables": ["students", "assessment_notes"]}
{"sample_id": 3113, "db_id": "behavior_monitoring", "question": "Find the texts of assessment notes for teachers with last name \"Schuster\".", "rationale": ["Identify the relevant tables: Assessment_Notes and Teachers.", "Determine the relationship between the tables: Assessment_Notes has a foreign key (teacher_id) that links to Teachers.", "Select the column needed: text_of_notes from Assessment_Notes.", "Filter the results based on the last name of the teacher: 'Schuster'.", "Construct the SQL query using a JOIN to combine the two tables based on the teacher_id."], "pred_sql": "SELECT Assessment_Notes.text_of_notes \nFROM Assessment_Notes \nJOIN Teachers ON Assessment_Notes.teacher_id = Teachers.teacher_id \nWHERE Teachers.last_name = 'Schuster';", "gold_sql": "SELECT T1.text_of_notes FROM Assessment_Notes AS T1 JOIN Teachers AS T2 ON T1.teacher_id  =  T2.teacher_id WHERE T2.last_name  =  'Schuster'", "source_tables": ["teachers", "assessment_notes"]}
{"sample_id": 3114, "db_id": "behavior_monitoring", "question": "Find the start and end dates of behavior incidents of students with last name \"Fahey\".", "rationale": ["Identify the relevant tables: Behavior_Incident and Students.", "Determine the columns needed: date_incident_start and date_incident_end from Behavior_Incident.", "Establish the relationship between the tables: Behavior_Incident is linked to Students via student_id.", "Filter the results based on the last name of the students: last_name = 'Fahey'.", "Construct the SQL query using SELECT to retrieve the required columns, JOIN to connect the tables, and WHERE to apply the filter."], "pred_sql": "SELECT Behavior_Incident.date_incident_start, Behavior_Incident.date_incident_end \nFROM Behavior_Incident \nJOIN Students ON Behavior_Incident.student_id = Students.student_id \nWHERE Students.last_name = 'Fahey';", "gold_sql": "SELECT T1.date_incident_start ,  date_incident_end FROM Behavior_Incident AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id WHERE T2.last_name  =  'Fahey'", "source_tables": ["behavior_incident", "students"]}
{"sample_id": 3115, "db_id": "behavior_monitoring", "question": "Find the start and end dates of detentions of teachers with last name \"Schultz\".", "rationale": ["Identify the relevant tables: Detention and Teachers.", "Determine the columns needed: start and end dates of detentions from the Detention table.", "Establish the relationship between the Detention and Teachers tables using the teacher_id foreign key.", "Filter the results to include only those records where the last name of the teacher is 'Schultz'.", "Construct the SQL SELECT statement to retrieve the required columns with the appropriate JOIN and WHERE clause."], "pred_sql": "SELECT Detention.datetime_detention_start, Detention.datetime_detention_end \nFROM Detention \nJOIN Teachers ON Detention.teacher_id = Teachers.teacher_id \nWHERE Teachers.last_name = 'Schultz';", "gold_sql": "SELECT T1.datetime_detention_start ,  datetime_detention_end FROM Detention AS T1 JOIN Teachers AS T2 ON T1.teacher_id  =  T2.teacher_id WHERE T2.last_name  =  'Schultz'", "source_tables": ["teachers", "detention"]}
{"sample_id": 3116, "db_id": "behavior_monitoring", "question": "What are the id and zip code of the address with the highest monthly rental?", "rationale": ["Identify the relevant tables: We need to find the address with the highest monthly rental, which involves the Addresses and Student_Addresses tables.", "Determine the columns needed: We need the address_id from the Addresses table and the zip_postcode from the Addresses table.", "Join the tables: We will join Addresses with Student_Addresses on the address_id to access the monthly rental information.", "Sort the results: We will order the results by the monthly rental in descending order to get the highest rental first.", "Limit the results: We will limit the results to 1 to get only the address with the highest monthly rental."], "pred_sql": "SELECT a.address_id, a.zip_postcode\nFROM Addresses a\nJOIN Student_Addresses sa ON a.address_id = sa.address_id\nORDER BY sa.monthly_rental DESC\nLIMIT 1;", "gold_sql": "SELECT T2.address_id ,  T1.zip_postcode FROM Addresses AS T1 JOIN Student_Addresses AS T2 ON T1.address_id  =  T2.address_id ORDER BY monthly_rental DESC LIMIT 1", "source_tables": ["addresses", "student_addresses"]}
{"sample_id": 3117, "db_id": "behavior_monitoring", "question": "What is the cell phone number of the student whose address has the lowest monthly rental?", "rationale": ["Identify the relevant tables: Students, Student_Addresses, and Addresses.", "We need to find the cell phone number of a student, so we will select the 'cell_mobile_number' from the Students table.", "To find the student with the lowest monthly rental, we need to join the Students table with the Student_Addresses table to access the 'monthly_rental' column.", "We will also join the Addresses table to ensure we have the correct address information, although it's not directly needed for the rental amount.", "We will order the results by 'monthly_rental' in ascending order to get the lowest rental first.", "Finally, we will limit the results to 1 to get only the student with the lowest monthly rental."], "pred_sql": "SELECT S.cell_mobile_number \nFROM Students S \nJOIN Student_Addresses SA ON S.student_id = SA.student_id \nJOIN Addresses A ON SA.address_id = A.address_id \nORDER BY SA.monthly_rental ASC \nLIMIT 1;", "gold_sql": "SELECT T2.cell_mobile_number FROM Student_Addresses AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id ORDER BY T1.monthly_rental ASC LIMIT 1", "source_tables": ["student_addresses", "students"]}
{"sample_id": 3118, "db_id": "behavior_monitoring", "question": "What are the monthly rentals of student addresses in Texas state?", "rationale": ["Identify the relevant tables: We need to look at the Student_Addresses table for monthly rental information and the Addresses table for the state information.", "Determine the columns needed: We need the 'monthly_rental' from the Student_Addresses table and filter based on the 'state_province_county' from the Addresses table.", "Establish the relationship between tables: The Student_Addresses table has a foreign key 'address_id' that links to the Addresses table.", "Construct the SQL query: Use a SELECT statement to retrieve the 'monthly_rental' from Student_Addresses, join it with Addresses on 'address_id', and filter the results where 'state_province_county' is 'Texas'."], "pred_sql": "SELECT sa.monthly_rental \nFROM Student_Addresses sa \nJOIN Addresses a ON sa.address_id = a.address_id \nWHERE a.state_province_county = 'Texas';", "gold_sql": "SELECT T2.monthly_rental FROM Addresses AS T1 JOIN Student_Addresses AS T2 ON T1.address_id  =  T2.address_id WHERE T1.state_province_county  =  'Texas'", "source_tables": ["addresses", "student_addresses"]}
{"sample_id": 3119, "db_id": "behavior_monitoring", "question": "What are the first names and last names of students with address in Wisconsin state?", "rationale": ["Identify the relevant tables: Students and Addresses.", "Determine the columns needed: first_name and last_name from Students.", "Establish the relationship between Students and Addresses using the address_id foreign key.", "Filter the results to include only those addresses located in Wisconsin by using a WHERE clause on the state_province_county column."], "pred_sql": "SELECT first_name, last_name FROM Students JOIN Addresses ON Students.address_id = Addresses.address_id WHERE Addresses.state_province_county = 'Wisconsin';", "gold_sql": "SELECT T2.first_name ,  T2.last_name FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.address_id WHERE T1.state_province_county  =  'Wisconsin'", "source_tables": ["addresses", "students"]}
{"sample_id": 3120, "db_id": "behavior_monitoring", "question": "What are the line 1 and average monthly rentals of all student addresses?", "rationale": ["Identify the required columns: 'line_1' from the Addresses table and the average of 'monthly_rental' from the Student_Addresses table.", "Determine the relationship between the tables: Student_Addresses has a foreign key 'address_id' that links to Addresses.", "Use a JOIN clause to combine the Student_Addresses and Addresses tables based on the 'address_id'.", "Use the AVG() function to calculate the average monthly rental for each address.", "Group the results by 'line_1' to get the average monthly rental for each unique address line."], "pred_sql": "SELECT Addresses.line_1, AVG(Student_Addresses.monthly_rental) AS average_monthly_rental\nFROM Student_Addresses\nJOIN Addresses ON Student_Addresses.address_id = Addresses.address_id\nGROUP BY Addresses.line_1;", "gold_sql": "SELECT T1.line_1 ,  avg(T2.monthly_rental) FROM Addresses AS T1 JOIN Student_Addresses AS T2 ON T1.address_id  =  T2.address_id GROUP BY T2.address_id", "source_tables": ["addresses", "student_addresses"]}
{"sample_id": 3121, "db_id": "behavior_monitoring", "question": "What is the zip code of the address where the teacher with first name \"Lyla\" lives?", "rationale": ["Identify the relevant tables: Teachers and Addresses.", "Determine the relationship between Teachers and Addresses through the address_id foreign key.", "Select the zip_postcode from the Addresses table.", "Filter the results to find the address of the teacher with the first name 'Lyla'."], "pred_sql": "SELECT Addresses.zip_postcode \nFROM Teachers \nJOIN Addresses ON Teachers.address_id = Addresses.address_id \nWHERE Teachers.first_name = 'Lyla';", "gold_sql": "SELECT T1.zip_postcode FROM Addresses AS T1 JOIN Teachers AS T2 ON T1.address_id  =  T2.address_id WHERE T2.first_name  =  'Lyla'", "source_tables": ["addresses", "teachers"]}
{"sample_id": 3122, "db_id": "behavior_monitoring", "question": "What are the email addresses of teachers whose address has zip code \"918\"?", "rationale": ["Identify the relevant tables: Teachers and Addresses.", "Determine the relationship between the tables: Teachers have an address linked by address_id.", "Select the email_address from the Teachers table.", "Filter the results based on the zip_postcode from the Addresses table, specifically looking for '918'.", "Construct the SQL query using a JOIN to combine the Teachers and Addresses tables based on the address_id."], "pred_sql": "SELECT Teachers.email_address \nFROM Teachers \nJOIN Addresses ON Teachers.address_id = Addresses.address_id \nWHERE Addresses.zip_postcode = '918';", "gold_sql": "SELECT T2.email_address FROM Addresses AS T1 JOIN Teachers AS T2 ON T1.address_id  =  T2.address_id WHERE T1.zip_postcode  =  '918'", "source_tables": ["addresses", "teachers"]}
{"sample_id": 3123, "db_id": "behavior_monitoring", "question": "How many students are not involved in any behavior incident?", "rationale": ["Identify the main goal: Count the number of students not involved in any behavior incident.", "To find students not involved in behavior incidents, we need to check the Students table against the Behavior_Incident table.", "We can use a subquery to select all student_ids from the Behavior_Incident table.", "The main query will count all students whose student_id is not in the list obtained from the subquery."], "pred_sql": "SELECT COUNT(*) AS student_count FROM Students WHERE student_id NOT IN (SELECT student_id FROM Behavior_Incident)", "gold_sql": "SELECT count(*) FROM STUDENTS WHERE student_id NOT IN ( SELECT student_id FROM Behavior_Incident )", "source_tables": ["behavior_incident", "students"]}
{"sample_id": 3124, "db_id": "behavior_monitoring", "question": "Find the last names of teachers who are not involved in any detention.", "rationale": ["Identify the table that contains the last names of teachers, which is the Teachers table.", "Determine the condition for teachers who are not involved in any detention, which means we need to find teachers whose IDs are not present in the Detention table.", "Use a subquery to select all teacher_ids from the Detention table.", "Construct the main query to select last names from the Teachers table where the teacher_id is not in the list of teacher_ids from the Detention table."], "pred_sql": "SELECT last_name FROM Teachers WHERE teacher_id NOT IN (SELECT teacher_id FROM Detention)", "gold_sql": "SELECT last_name FROM Teachers EXCEPT SELECT T1.last_name FROM Teachers AS T1 JOIN Detention AS T2 ON T1.teacher_id  =  T2.teacher_id", "source_tables": ["teachers", "detention"]}
{"sample_id": 3125, "db_id": "behavior_monitoring", "question": "What are the line 1 of addresses shared by some students and some teachers?", "rationale": ["Identify the relevant tables: Addresses, Students, and Teachers.", "Determine the relationship between Students and Addresses through the address_id.", "Determine the relationship between Teachers and Addresses through the address_id.", "Use JOIN to combine these tables based on the address_id.", "Select the distinct line_1 values from the Addresses table that are shared by both Students and Teachers."], "pred_sql": "SELECT DISTINCT Addresses.line_1\nFROM Addresses\nJOIN Students ON Addresses.address_id = Students.address_id\nJOIN Teachers ON Addresses.address_id = Teachers.address_id;", "gold_sql": "SELECT T1.line_1 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.address_id INTERSECT SELECT T1.line_1 FROM Addresses AS T1 JOIN Teachers AS T2 ON T1.address_id  =  T2.address_id", "source_tables": ["addresses", "teachers", "students"]}
{"sample_id": 3126, "db_id": "assets_maintenance", "question": "Which assets have 2 parts and have less than 2 fault logs? List the asset id and detail.", "rationale": ["Identify the relevant tables: Assets, Asset_Parts, and Fault_Log.", "We need to find assets that have exactly 2 parts, so we will join Assets with Asset_Parts on asset_id.", "To count the number of fault logs for each asset, we will perform a LEFT JOIN with Fault_Log on asset_id.", "We will group the results by asset_id to aggregate the counts of parts and fault logs.", "Use the HAVING clause to filter for assets that have exactly 2 parts (COUNT(ap.part_id) = 2) and less than 2 fault logs (COUNT(fl.fault_log_entry_id) < 2).", "Select the required fields: asset_id and asset_details from the Assets table."], "pred_sql": "SELECT a.asset_id, a.asset_details \nFROM Assets a \nJOIN Asset_Parts ap ON a.asset_id = ap.asset_id \nLEFT JOIN Fault_Log fl ON a.asset_id = fl.asset_id \nGROUP BY a.asset_id \nHAVING COUNT(ap.part_id) = 2 AND COUNT(fl.fault_log_entry_id) < 2;", "gold_sql": "SELECT T1.asset_id ,  T1.asset_details FROM Assets AS T1 JOIN Asset_Parts AS T2 ON T1.asset_id  =  T2.asset_id GROUP BY T1.asset_id HAVING count(*)  =  2 INTERSECT SELECT T1.asset_id ,  T1.asset_details FROM Assets AS T1 JOIN Fault_Log AS T2 ON T1.asset_id  =  T2.asset_id GROUP BY T1.asset_id HAVING count(*)  <  2", "source_tables": ["assets", "asset_parts", "fault_log"]}
{"sample_id": 3127, "db_id": "assets_maintenance", "question": "How many assets does each maintenance contract contain? List the number and the contract id.", "rationale": ["Identify the relevant tables: We need to look at the Assets table to count the assets and the Maintenance_Contracts table to get the contract IDs.", "Determine the columns needed: We need the maintenance_contract_id from the Assets table and a count of asset_id to get the number of assets per contract.", "Use the COUNT() function: This function will help us count the number of assets associated with each maintenance contract.", "Group the results: We will use GROUP BY on maintenance_contract_id to aggregate the counts for each contract."], "pred_sql": "SELECT maintenance_contract_id, COUNT(asset_id) AS asset_count\nFROM Assets\nGROUP BY maintenance_contract_id;", "gold_sql": "SELECT count(*) ,  T1.maintenance_contract_id FROM Maintenance_Contracts AS T1 JOIN Assets AS T2 ON T1.maintenance_contract_id  =  T2.maintenance_contract_id GROUP BY T1.maintenance_contract_id", "source_tables": ["assets", "maintenance_contracts"]}
{"sample_id": 3128, "db_id": "assets_maintenance", "question": "How many assets does each third party company supply? List the count and the company id.", "rationale": ["Identify the relevant table: The query requires information about assets and their associated companies, so we will use the 'Assets' table.", "Determine the required columns: We need the 'supplier_company_id' to identify the company and a count of the 'asset_id' to determine how many assets each company supplies.", "Use the COUNT() function: To count the number of assets for each company, we will use the COUNT() function on 'asset_id'.", "Group the results: To get the count of assets per company, we will group the results by 'supplier_company_id'.", "Construct the SQL query: Combine all the elements into a complete SQL query."], "pred_sql": "SELECT supplier_company_id, COUNT(asset_id) AS asset_count FROM Assets GROUP BY supplier_company_id;", "gold_sql": "SELECT count(*) ,  T1.company_id FROM Third_Party_Companies AS T1 JOIN Assets AS T2 ON T1.company_id  =  T2.supplier_company_id GROUP BY T1.company_id", "source_tables": ["assets", "third_party_companies"]}
{"sample_id": 3129, "db_id": "assets_maintenance", "question": "Which third party companies have at least 2 maintenance engineers or have at least 2 maintenance contracts? List the company id and name.", "rationale": ["Identify the relevant tables: Third_Party_Companies, Maintenance_Engineers, and Maintenance_Contracts.", "We need to find companies that have at least 2 maintenance engineers or at least 2 maintenance contracts.", "To find companies with at least 2 maintenance engineers, we can group by company_id in the Maintenance_Engineers table and use HAVING COUNT(engineer_id) >= 2.", "To find companies with at least 2 maintenance contracts, we can group by maintenance_contract_company_id in the Maintenance_Contracts table and use HAVING COUNT(maintenance_contract_id) >= 2.", "We will use a UNION of the two subqueries to get the company_ids that meet either condition.", "Finally, we will select the company_id and company_name from the Third_Party_Companies table where the company_id is in the result of the UNION."], "pred_sql": "SELECT company_id, company_name FROM Third_Party_Companies WHERE company_id IN (SELECT company_id FROM Maintenance_Engineers GROUP BY company_id HAVING COUNT(engineer_id) >= 2) OR company_id IN (SELECT maintenance_contract_company_id FROM Maintenance_Contracts GROUP BY maintenance_contract_company_id HAVING COUNT(maintenance_contract_id) >= 2);", "gold_sql": "SELECT T1.company_id ,  T1.company_name FROM Third_Party_Companies AS T1 JOIN Maintenance_Engineers AS T2 ON T1.company_id  =  T2.company_id GROUP BY T1.company_id HAVING count(*)  >=  2 UNION SELECT T3.company_id ,  T3.company_name FROM Third_Party_Companies AS T3 JOIN Maintenance_Contracts AS T4 ON T3.company_id  =  T4.maintenance_contract_company_id GROUP BY T3.company_id HAVING count(*)  >=  2", "source_tables": ["maintenance_engineers", "maintenance_contracts", "third_party_companies"]}
{"sample_id": 3130, "db_id": "assets_maintenance", "question": "What is the name and id of the staff who recorded the fault log but has not contacted any visiting engineers?", "rationale": ["Identify the relevant tables: Staff and Fault_Log for staff details and fault recording, and Engineer_Visits for engineer visit contacts.", "We need to find staff members who recorded faults but have not contacted any engineers. This requires checking the Staff table against the Engineer_Visits table.", "First, we select the staff IDs from the Engineer_Visits table to find those who have contacted engineers.", "Next, we select the staff IDs from the Fault_Log table to find those who recorded faults.", "Finally, we select staff from the Staff table whose IDs are in the Fault_Log but not in the Engineer_Visits."], "pred_sql": "SELECT Staff.staff_id, Staff.staff_name \nFROM Staff \nWHERE Staff.staff_id NOT IN (\n    SELECT Engineer_Visits.contact_staff_id \n    FROM Engineer_Visits\n) \nAND Staff.staff_id IN (\n    SELECT Fault_Log.recorded_by_staff_id \n    FROM Fault_Log\n);", "gold_sql": "SELECT T1.staff_name ,  T1.staff_id FROM Staff AS T1 JOIN Fault_Log AS T2 ON T1.staff_id  =  T2.recorded_by_staff_id EXCEPT SELECT T3.staff_name ,  T3.staff_id FROM Staff AS T3 JOIN Engineer_Visits AS T4 ON T3.staff_id  =  T4.contact_staff_id", "source_tables": ["staff", "engineer_visits", "fault_log"]}
{"sample_id": 3131, "db_id": "assets_maintenance", "question": "Which engineer has visited the most times? Show the engineer id, first name and last name.", "rationale": ["Identify the relevant table: Engineer_Visits contains the visit records for engineers.", "We need to count the number of visits for each engineer, so we will group by engineer_id in the Engineer_Visits table.", "Order the results by the count of visits in descending order to find the engineer with the most visits.", "Limit the results to 1 to get only the engineer with the highest count.", "Join the result with the Maintenance_Engineers table to get the first name and last name of the engineer.", "Select the engineer_id, first_name, and last_name from the joined result."], "pred_sql": "SELECT engineer_id, first_name, last_name\nFROM Maintenance_Engineers\nWHERE engineer_id IN (\n    SELECT engineer_id\n    FROM Engineer_Visits\n    GROUP BY engineer_id\n    ORDER BY COUNT(engineer_visit_id) DESC\n    LIMIT 1\n)", "gold_sql": "SELECT T1.engineer_id ,  T1.first_name ,  T1.last_name FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2 GROUP BY T1.engineer_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["maintenance_engineers", "engineer_visits"]}
{"sample_id": 3132, "db_id": "assets_maintenance", "question": "Which parts have more than 2 faults? Show the part name and id.", "rationale": ["Identify the relevant tables: Parts and Part_Faults.", "We need to find parts that have more than 2 faults, so we will join the Parts table with the Part_Faults table on the part_id.", "Group the results by part_id and part_name to aggregate the fault counts for each part.", "Use the HAVING clause to filter groups that have a count of part_fault_id greater than 2."], "pred_sql": "SELECT p.part_id, p.part_name \nFROM Parts p \nJOIN Part_Faults pf ON p.part_id = pf.part_id \nGROUP BY p.part_id, p.part_name \nHAVING COUNT(pf.part_fault_id) > 2;", "gold_sql": "SELECT T1.part_name ,  T1.part_id FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id  =  T2.part_id GROUP BY T1.part_id HAVING count(*)  >  2", "source_tables": ["part_faults", "parts"]}
{"sample_id": 3133, "db_id": "assets_maintenance", "question": "List all every engineer's first name, last name, details and coresponding skill description.", "rationale": ["Identify the tables needed: Maintenance_Engineers for engineer details and Skills for skill descriptions.", "Determine the columns to select: first name, last name, other details from Maintenance_Engineers and skill description from Skills.", "Establish relationships between tables: Maintenance_Engineers is linked to Engineer_Skills through engineer_id, and Engineer_Skills is linked to Skills through skill_id.", "Construct the SQL query using JOINs to combine the necessary information from the identified tables."], "pred_sql": "SELECT me.first_name, me.last_name, me.other_details, s.skill_description \nFROM Maintenance_Engineers me \nJOIN Engineer_Skills es ON me.engineer_id = es.engineer_id \nJOIN Skills s ON es.skill_id = s.skill_id;", "gold_sql": "SELECT T1.first_name ,  T1.last_name ,  T1.other_details ,  T3.skill_description FROM Maintenance_Engineers AS T1 JOIN Engineer_Skills AS T2 ON T1.engineer_id  =  T2.engineer_id JOIN Skills AS T3 ON T2.skill_id  =  T3.skill_id", "source_tables": ["maintenance_engineers", "engineer_skills", "skills"]}
{"sample_id": 3134, "db_id": "assets_maintenance", "question": "For all the faults of different parts, what are all the decriptions of the skills required to fix them? List the name of the faults and the skill description.", "rationale": ["Identify the tables involved: We need to retrieve fault descriptions and skill descriptions, which are found in the Part_Faults and Skills tables respectively.", "Determine the relationships: The Skills_Required_To_Fix table links part faults to the skills required to fix them, so we will need to join this table with Part_Faults and Skills.", "Construct the SQL query: We will select the fault description from Part_Faults and the skill description from Skills, using JOINs to connect the tables based on their relationships."], "pred_sql": "SELECT pf.fault_description, s.skill_description \nFROM Part_Faults pf \nJOIN Skills_Required_To_Fix srf ON pf.part_fault_id = srf.part_fault_id \nJOIN Skills s ON srf.skill_id = s.skill_id;", "gold_sql": "SELECT T1.fault_short_name ,  T3.skill_description FROM Part_Faults AS T1 JOIN Skills_Required_To_Fix AS T2 ON T1.part_fault_id  =  T2.part_fault_id JOIN Skills AS T3 ON T2.skill_id  =  T3.skill_id", "source_tables": ["part_faults", "skills", "skills_required_to_fix"]}
{"sample_id": 3135, "db_id": "assets_maintenance", "question": "How many assets can each parts be used in? List the part name and the number.", "rationale": ["Identify the relevant tables: We need to use the 'Parts' table to get the part names and the 'Asset_Parts' table to count how many assets each part is associated with.", "Join the 'Parts' table with the 'Asset_Parts' table on the 'part_id' column to link parts with their corresponding assets.", "Use the COUNT() function to count the number of asset IDs associated with each part.", "Group the results by 'Parts.part_name' to get the count of assets for each part."], "pred_sql": "SELECT Parts.part_name, COUNT(Asset_Parts.asset_id) AS asset_count\nFROM Parts\nJOIN Asset_Parts ON Parts.part_id = Asset_Parts.part_id\nGROUP BY Parts.part_name;", "gold_sql": "SELECT T1.part_name ,  count(*) FROM Parts AS T1 JOIN Asset_Parts AS T2 ON T1.part_id  =  T2.part_id GROUP BY T1.part_name", "source_tables": ["asset_parts", "parts"]}
{"sample_id": 3136, "db_id": "assets_maintenance", "question": "What are all the fault descriptions and the fault status of all the faults recoreded in the logs?", "rationale": ["Identify the relevant table: Fault_Log contains the fault descriptions and statuses.", "Select the columns needed: fault_description and fault_status are the required fields.", "Construct the SQL query to retrieve these columns from the Fault_Log table."], "pred_sql": "SELECT fault_description, fault_status FROM Fault_Log", "gold_sql": "SELECT T1.fault_description ,  T2.fault_status FROM Fault_Log AS T1 JOIN Fault_Log_Parts AS T2 ON T1.fault_log_entry_id  =  T2.fault_log_entry_id", "source_tables": ["fault_log_parts", "fault_log"]}
{"sample_id": 3137, "db_id": "assets_maintenance", "question": "How many engineer visits are required at most for a single fault log? List the number and the log entry id.", "rationale": ["Identify the relevant table for engineer visits, which is 'Engineer_Visits'.", "We need to count the number of visits for each fault log entry, so we will use the COUNT() function on 'engineer_visit_id'.", "We will group the results by 'fault_log_entry_id' to get the count of visits for each log entry.", "To find the maximum number of visits, we will order the results in descending order based on the count of visits.", "Finally, we will limit the results to 1 to get the fault log entry with the most visits."], "pred_sql": "SELECT fault_log_entry_id, COUNT(engineer_visit_id) AS visit_count\nFROM Engineer_Visits\nGROUP BY fault_log_entry_id\nORDER BY visit_count DESC\nLIMIT 1;", "gold_sql": "SELECT count(*) ,  T1.fault_log_entry_id FROM Fault_Log AS T1 JOIN Engineer_Visits AS T2 ON T1.fault_log_entry_id  =  T2.fault_log_entry_id GROUP BY T1.fault_log_entry_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["engineer_visits", "fault_log"]}
{"sample_id": 3138, "db_id": "assets_maintenance", "question": "What are all the distinct last names of all the engineers?", "rationale": ["Identify the table that contains the information about engineers, which is 'Maintenance_Engineers'.", "Determine the column that holds the last names of the engineers, which is 'last_name'.", "Use the DISTINCT keyword to ensure that only unique last names are returned.", "Construct the SQL query to select distinct last names from the 'Maintenance_Engineers' table."], "pred_sql": "SELECT DISTINCT last_name FROM Maintenance_Engineers;", "gold_sql": "SELECT DISTINCT last_name FROM Maintenance_Engineers", "source_tables": ["maintenance_engineers"]}
{"sample_id": 3139, "db_id": "assets_maintenance", "question": "How many fault status codes are recorded in the fault log parts table?", "rationale": ["Identify the table of interest: Fault_Log_Parts.", "Determine the relevant column for fault status: fault_status.", "Count the distinct values in the fault_status column to find the number of unique fault status codes recorded."], "pred_sql": "SELECT COUNT(DISTINCT fault_status) AS unique_fault_status_count FROM Fault_Log_Parts;", "gold_sql": "SELECT DISTINCT fault_status FROM Fault_Log_Parts", "source_tables": ["fault_log_parts"]}
{"sample_id": 3140, "db_id": "assets_maintenance", "question": "Which engineers have never visited to maintain the assets? List the engineer first name and last name.", "rationale": ["Identify the relevant table: Maintenance_Engineers contains the information about engineers.", "We need to find engineers who have never visited to maintain assets, which means we need to check against the Engineer_Visits table.", "The Engineer_Visits table contains records of visits by engineers, so we can use a subquery to find all engineer_ids that have made visits.", "We will select the first_name and last_name of engineers whose engineer_id is not in the list of engineer_ids from the Engineer_Visits table."], "pred_sql": "SELECT first_name, last_name FROM Maintenance_Engineers WHERE engineer_id NOT IN (SELECT engineer_id FROM Engineer_Visits);", "gold_sql": "SELECT first_name ,  last_name FROM Maintenance_Engineers WHERE engineer_id NOT IN (SELECT engineer_id FROM Engineer_Visits)", "source_tables": ["maintenance_engineers", "engineer_visits"]}
{"sample_id": 3141, "db_id": "assets_maintenance", "question": "List the asset id, details, make and model for every asset.", "rationale": ["Identify the required columns: asset_id, asset_details, asset_make, and asset_model.", "Determine the table that contains these columns, which is the Assets table.", "Construct the SQL SELECT statement to retrieve the specified columns from the Assets table."], "pred_sql": "SELECT asset_id, asset_details, asset_make, asset_model FROM Assets;", "gold_sql": "SELECT asset_id ,  asset_details ,  asset_make ,  asset_model FROM Assets", "source_tables": ["assets"]}
{"sample_id": 3142, "db_id": "assets_maintenance", "question": "When was the first asset acquired?", "rationale": ["Identify the relevant table: The query is about assets, so we will use the 'Assets' table.", "Determine the required information: We need to find out when the first asset was acquired, which corresponds to the minimum acquisition date.", "Use the MIN() function: To get the earliest date, we will use the MIN() function on the 'asset_acquired_date' column.", "Construct the SQL query: The final SQL query will select the minimum acquisition date from the 'Assets' table."], "pred_sql": "SELECT MIN(asset_acquired_date) AS first_acquired_date FROM Assets;", "gold_sql": "SELECT asset_acquired_date FROM Assets ORDER BY asset_acquired_date ASC LIMIT 1", "source_tables": ["assets"]}
{"sample_id": 3143, "db_id": "assets_maintenance", "question": "Which part fault requires the most number of skills to fix? List part id and name.", "rationale": ["Identify the relevant tables: Part_Faults, Skills_Required_To_Fix, and Parts.", "Join Part_Faults with Skills_Required_To_Fix on part_fault_id to get the skills required for each part fault.", "Join the result with Parts on part_id to get the part name associated with each part fault.", "Group the results by part_id and part_name to count the number of skills required for each part fault.", "Order the results by the count of skills in descending order to find the part fault that requires the most skills.", "Limit the results to 1 to get only the part fault with the highest skill requirement."], "pred_sql": "SELECT pf.part_id, p.part_name, COUNT(sr.skill_id) AS skill_count\nFROM Part_Faults pf\nJOIN Skills_Required_To_Fix sr ON pf.part_fault_id = sr.part_fault_id\nJOIN Parts p ON pf.part_id = p.part_id\nGROUP BY pf.part_id, p.part_name\nORDER BY skill_count DESC\nLIMIT 1;", "gold_sql": "SELECT T1.part_id ,  T1.part_name FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id  =  T2.part_id JOIN Skills_Required_To_Fix AS T3 ON T2.part_fault_id  =  T3.part_fault_id GROUP BY T1.part_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["part_faults", "parts", "skills_required_to_fix"]}
{"sample_id": 3144, "db_id": "assets_maintenance", "question": "Which kind of part has the least number of faults? List the part name.", "rationale": ["Identify the relevant tables: Parts and Part_Faults.", "Join the Parts table with the Part_Faults table on the part_id column to associate parts with their faults.", "Group the results by part_id to count the number of faults for each part.", "Order the results by the count of faults in ascending order to find the part with the least number of faults.", "Limit the results to 1 to get only the part with the least number of faults."], "pred_sql": "SELECT p.part_name\nFROM Parts p\nJOIN Part_Faults pf ON p.part_id = pf.part_id\nGROUP BY p.part_id\nORDER BY COUNT(pf.part_fault_id) ASC\nLIMIT 1;", "gold_sql": "SELECT T1.part_name FROM Parts AS T1 JOIN Part_Faults AS T2 ON T1.part_id  =  T2.part_id GROUP BY T1.part_name ORDER BY count(*) ASC LIMIT 1", "source_tables": ["part_faults", "parts"]}
{"sample_id": 3145, "db_id": "assets_maintenance", "question": "Among those engineers who have visited, which engineer makes the least number of visits? List the engineer id, first name and last name.", "rationale": ["Identify the relevant table: Engineer_Visits to count the number of visits made by each engineer.", "Group the visits by engineer_id to count how many visits each engineer has made.", "Order the results by the count of visits in ascending order to find the engineer with the least visits.", "Limit the results to 1 to get only the engineer with the least number of visits.", "Select the engineer_id, first_name, and last_name from the Maintenance_Engineers table where the engineer_id matches the one found in the previous step."], "pred_sql": "SELECT engineer_id, first_name, last_name FROM Maintenance_Engineers WHERE engineer_id IN (SELECT engineer_id FROM Engineer_Visits GROUP BY engineer_id ORDER BY COUNT(engineer_visit_id) ASC LIMIT 1)", "gold_sql": "SELECT T1.engineer_id ,  T1.first_name ,  T1.last_name FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2 ON T1.engineer_id  =  T2.engineer_id GROUP BY T1.engineer_id ORDER BY count(*) ASC LIMIT 1", "source_tables": ["maintenance_engineers", "engineer_visits"]}
{"sample_id": 3146, "db_id": "assets_maintenance", "question": "Which staff have contacted which engineers? List the staff name and the engineer first name and last name.", "rationale": ["Identify the relevant tables: Engineer_Visits, Staff, and Maintenance_Engineers.", "We need to retrieve the staff name and the engineer's first and last name.", "Join the Engineer_Visits table with the Staff table on the contact_staff_id to get the staff names.", "Join the Engineer_Visits table with the Maintenance_Engineers table on the engineer_id to get the engineer names.", "Select the required columns: Staff.staff_name, Maintenance_Engineers.first_name, and Maintenance_Engineers.last_name."], "pred_sql": "SELECT Staff.staff_name, Maintenance_Engineers.first_name, Maintenance_Engineers.last_name\nFROM Engineer_Visits\nJOIN Staff ON Engineer_Visits.contact_staff_id = Staff.staff_id\nJOIN Maintenance_Engineers ON Engineer_Visits.engineer_id = Maintenance_Engineers.engineer_id;", "gold_sql": "SELECT T1.staff_name ,  T3.first_name ,  T3.last_name FROM Staff AS T1 JOIN Engineer_Visits AS T2 ON T1.staff_id  =  T2.contact_staff_id JOIN Maintenance_Engineers AS T3 ON T2.engineer_id  =  T3.engineer_id", "source_tables": ["maintenance_engineers", "staff", "engineer_visits"]}
{"sample_id": 3147, "db_id": "assets_maintenance", "question": "Which fault log included the most number of faulty parts? List the fault log id, description and record time.", "rationale": ["Identify the relevant tables: Fault_Log and Fault_Log_Parts are needed to get the fault log entries and their associated parts.", "Join the Fault_Log table with the Fault_Log_Parts table on the fault_log_entry_id to link each fault log with its parts.", "Group the results by fault_log_entry_id to aggregate the number of parts associated with each fault log.", "Count the number of part_fault_id entries for each fault log to determine how many parts are associated with each log.", "Order the results in descending order based on the count of parts to find the fault log with the most faulty parts.", "Limit the results to 1 to get only the fault log with the highest count of faulty parts."], "pred_sql": "SELECT fl.fault_log_entry_id, fl.fault_description, fl.fault_log_entry_datetime\nFROM Fault_Log fl\nJOIN Fault_Log_Parts flp ON fl.fault_log_entry_id = flp.fault_log_entry_id\nGROUP BY fl.fault_log_entry_id\nORDER BY COUNT(flp.part_fault_id) DESC\nLIMIT 1;", "gold_sql": "SELECT T1.fault_log_entry_id ,  T1.fault_description ,  T1.fault_log_entry_datetime FROM Fault_Log AS T1 JOIN Fault_Log_Parts AS T2 ON T1.fault_log_entry_id  =  T2.fault_log_entry_id GROUP BY T1.fault_log_entry_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["fault_log_parts", "fault_log"]}
{"sample_id": 3148, "db_id": "assets_maintenance", "question": "Which skill is used in fixing the most number of faults? List the skill id and description.", "rationale": ["Identify the relevant tables: Skills, Skills_Required_To_Fix, and Part_Faults are needed to find the skills associated with faults.", "Join the Skills table with Skills_Required_To_Fix on skill_id to get the skills required for fixing faults.", "Join the Skills_Required_To_Fix table with Part_Faults on part_fault_id to link skills to the faults they fix.", "Group the results by skill_id and skill_description to count how many faults each skill is associated with.", "Order the results by the count of faults in descending order to find the skill used in fixing the most faults.", "Limit the results to 1 to get only the top skill."], "pred_sql": "SELECT s.skill_id, s.skill_description\nFROM Skills s\nJOIN Skills_Required_To_Fix sr ON s.skill_id = sr.skill_id\nJOIN Part_Faults pf ON sr.part_fault_id = pf.part_fault_id\nGROUP BY s.skill_id, s.skill_description\nORDER BY COUNT(pf.part_fault_id) DESC\nLIMIT 1;", "gold_sql": "SELECT T1.skill_id ,  T1.skill_description FROM Skills AS T1 JOIN Skills_Required_To_Fix AS T2 ON T1.skill_id  =  T2.skill_id GROUP BY T1.skill_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["skills", "skills_required_to_fix"]}
{"sample_id": 3149, "db_id": "assets_maintenance", "question": "What are all the distinct asset models?", "rationale": ["Identify the table that contains the asset models, which is the 'Assets' table.", "Determine the specific column that holds the asset model information, which is 'asset_model'.", "Since the user wants distinct asset models, use the DISTINCT keyword to ensure that duplicate models are not included in the results.", "Construct the SQL query to select distinct asset models from the 'Assets' table."], "pred_sql": "SELECT DISTINCT asset_model FROM Assets;", "gold_sql": "SELECT DISTINCT asset_model FROM Assets", "source_tables": ["assets"]}
{"sample_id": 3150, "db_id": "assets_maintenance", "question": "List the all the assets make, model, details by the disposed date ascendingly.", "rationale": ["Identify the table that contains the required information: The 'Assets' table contains the columns 'asset_make', 'asset_model', and 'asset_details'.", "Determine the columns to select: We need to select 'asset_make', 'asset_model', and 'asset_details'.", "Specify the order of the results: The results should be ordered by 'asset_disposed_date' in ascending order.", "Construct the SQL query using the SELECT statement, specifying the columns and the ORDER BY clause."], "pred_sql": "SELECT asset_make, asset_model, asset_details FROM Assets ORDER BY asset_disposed_date ASC;", "gold_sql": "SELECT asset_make ,  asset_model ,  asset_details FROM Assets ORDER BY asset_disposed_date ASC", "source_tables": ["assets"]}
{"sample_id": 3151, "db_id": "assets_maintenance", "question": "Which part has the least chargeable amount? List the part id and amount.", "rationale": ["Identify the relevant table: The query is asking about parts and their chargeable amounts, so we will use the 'Parts' table.", "Select the required columns: We need to retrieve the 'part_id' and 'chargeable_amount' from the 'Parts' table.", "Order the results: To find the part with the least chargeable amount, we will order the results by 'chargeable_amount' in ascending order.", "Limit the results: Since we only want the part with the least chargeable amount, we will limit the results to 1."], "pred_sql": "SELECT part_id, chargeable_amount FROM Parts ORDER BY chargeable_amount ASC LIMIT 1;", "gold_sql": "SELECT part_id ,  chargeable_amount FROM Parts ORDER BY chargeable_amount ASC LIMIT 1", "source_tables": ["parts"]}
{"sample_id": 3152, "db_id": "assets_maintenance", "question": "Which company started the earliest the maintenance contract? Show the company name.", "rationale": ["Identify the relevant tables: Third_Party_Companies and Maintenance_Contracts.", "We need to find the company that started the earliest maintenance contract, so we will join these two tables on the company_id and maintenance_contract_company_id.", "We will select the company_name from the Third_Party_Companies table.", "To find the earliest contract, we will order the results by contract_start_date in ascending order.", "Finally, we will limit the results to 1 to get only the earliest contract."], "pred_sql": "SELECT tc.company_name\nFROM Third_Party_Companies tc\nJOIN Maintenance_Contracts mc ON tc.company_id = mc.maintenance_contract_company_id\nORDER BY mc.contract_start_date ASC\nLIMIT 1;", "gold_sql": "SELECT T1.company_name FROM Third_Party_Companies AS T1 JOIN Maintenance_Contracts AS T2 ON T1.company_id  =  T2.maintenance_contract_company_id ORDER BY T2.contract_start_date ASC LIMIT 1", "source_tables": ["maintenance_contracts", "third_party_companies"]}
{"sample_id": 3153, "db_id": "assets_maintenance", "question": "What is the description of the type of the company who concluded its contracts most recently?", "rationale": ["Identify the relevant tables: Third_Party_Companies and Maintenance_Contracts.", "We need to find the company type of the company that has the most recently concluded contract, which means we need to look for the maximum contract end date.", "Join the Third_Party_Companies table with the Maintenance_Contracts table on the company ID to get the company type associated with the contract.", "Use a subquery to find the maximum contract end date from the Maintenance_Contracts table.", "Select the company type from the Third_Party_Companies table where the contract end date matches the maximum found in the subquery."], "pred_sql": "SELECT t.company_type FROM Third_Party_Companies t JOIN Maintenance_Contracts m ON t.company_id = m.maintenance_contract_company_id WHERE m.contract_end_date = (SELECT MAX(contract_end_date) FROM Maintenance_Contracts)", "gold_sql": "SELECT T1.company_name FROM Third_Party_Companies AS T1 JOIN Maintenance_Contracts AS T2 ON T1.company_id  =  T2.maintenance_contract_company_id JOIN Ref_Company_Types AS T3 ON T1.company_type_code  =  T3.company_type_code ORDER BY T2.contract_end_date DESC LIMIT 1", "source_tables": ["ref_company_types", "maintenance_contracts", "third_party_companies"]}
{"sample_id": 3154, "db_id": "assets_maintenance", "question": "Which gender makes up the majority of the staff?", "rationale": ["Identify the relevant table: The query is about staff, so we will use the 'Staff' table.", "Determine the required information: We need to count the number of staff members by gender.", "Group the results by gender: This will allow us to count how many staff members there are for each gender.", "Order the results: We want to find out which gender has the highest count, so we will order the results in descending order.", "Limit the results: Since we only want the gender with the majority, we will limit the results to 1."], "pred_sql": "SELECT gender, COUNT(*) as count FROM Staff GROUP BY gender ORDER BY count DESC LIMIT 1;", "gold_sql": "SELECT gender FROM staff GROUP BY gender ORDER BY count(*) DESC LIMIT 1", "source_tables": ["staff"]}
{"sample_id": 3155, "db_id": "assets_maintenance", "question": "How many engineers did each staff contact? List both the contact staff name and number of engineers contacted.", "rationale": ["Identify the relevant tables: Engineer_Visits and Staff.", "We need to count the number of engineers contacted by each staff member, so we will use COUNT() function on engineer_id.", "Join the Engineer_Visits table with the Staff table on the contact_staff_id to get the staff names.", "Group the results by staff_name to get the count of engineers for each staff member."], "pred_sql": "SELECT Staff.staff_name, COUNT(Engineer_Visits.engineer_id) AS number_of_engineers_contacted\nFROM Engineer_Visits\nJOIN Staff ON Engineer_Visits.contact_staff_id = Staff.staff_id\nGROUP BY Staff.staff_name;", "gold_sql": "SELECT T1.staff_name ,  count(*) FROM Staff AS T1 JOIN Engineer_Visits AS T2 ON T1.staff_id  =  T2.contact_staff_id GROUP BY T1.staff_name", "source_tables": ["staff", "engineer_visits"]}
{"sample_id": 3156, "db_id": "assets_maintenance", "question": "Which assets did not incur any fault log? List the asset model.", "rationale": ["Identify the table that contains the asset information, which is the 'Assets' table.", "Determine the relevant column to retrieve, which is 'asset_model'.", "To find assets that did not incur any fault log, we need to check against the 'Fault_Log' table.", "Use a subquery to select all 'asset_id's from the 'Fault_Log' table, as these are the assets that have incurred faults.", "Use the NOT IN clause to filter out any assets that appear in the fault log, ensuring we only get assets without faults."], "pred_sql": "SELECT asset_model FROM Assets WHERE asset_id NOT IN (SELECT DISTINCT asset_id FROM Fault_Log)", "gold_sql": "SELECT asset_model FROM Assets WHERE asset_id NOT IN (SELECT asset_id FROM Fault_Log)", "source_tables": ["assets", "fault_log"]}
{"sample_id": 3157, "db_id": "station_weather", "question": "list the local authorities and services provided by all stations.", "rationale": ["Identify the required information: local authorities and services from the stations.", "Determine the relevant table: the 'station' table contains both 'local_authority' and 'services'.", "Construct the SQL SELECT statement to retrieve 'local_authority' and 'services' from the 'station' table."], "pred_sql": "SELECT local_authority, services FROM station;", "gold_sql": "SELECT local_authority ,  services FROM station", "source_tables": ["station"]}
{"sample_id": 3158, "db_id": "station_weather", "question": "show all train numbers and names ordered by their time from early to late.", "rationale": ["Identify the relevant table: The 'train' table contains the columns 'train_number' and 'name'.", "Determine the required columns: We need to select 'train_number' and 'name'.", "Specify the ordering: The results should be ordered by the 'time' column in ascending order (from early to late).", "Construct the SQL query using SELECT, specifying the columns and the ORDER BY clause."], "pred_sql": "SELECT train_number, name FROM train ORDER BY time ASC;", "gold_sql": "SELECT train_number ,  name FROM train ORDER BY TIME", "source_tables": ["train"]}
{"sample_id": 3159, "db_id": "station_weather", "question": "Give me the times and numbers of all trains that go to Chennai, ordered by time.", "rationale": ["Identify the relevant tables: 'train', 'route', and 'station' are needed to get train details and their destinations.", "We need to select the 'train_number' and 'time' from the 'train' table.", "To find trains going to Chennai, we need to join the 'train' table with the 'route' table to link trains to their respective stations.", "Next, we join the 'route' table with the 'station' table to filter for stations that have 'Chennai' as their destination.", "We will use a WHERE clause to specify that we are looking for stations with the name 'Chennai'.", "Finally, we will order the results by the 'time' column to get the trains in the correct order."], "pred_sql": "SELECT train.train_number, train.time FROM train JOIN route ON train.id = route.train_id JOIN station ON route.station_id = station.id WHERE station.network_name = 'Chennai' ORDER BY train.time;", "gold_sql": "SELECT TIME ,  train_number FROM train WHERE destination  =  'Chennai' ORDER BY TIME", "source_tables": ["train"]}
{"sample_id": 3160, "db_id": "station_weather", "question": "How many trains have 'Express' in their names?", "rationale": ["Identify the table that contains the train names, which is the 'train' table.", "Determine the column that holds the train names, which is 'name'.", "Formulate a query to count the number of records in the 'train' table where the 'name' column contains the substring 'Express'.", "Use the SQL COUNT function to get the total number of such trains and use the LIKE operator with wildcards to match any train names that include 'Express'."], "pred_sql": "SELECT COUNT(*) AS train_count FROM train WHERE name LIKE '%Express%';", "gold_sql": "SELECT count(*) FROM train WHERE name LIKE '%Express%'", "source_tables": ["train"]}
{"sample_id": 3161, "db_id": "station_weather", "question": "Find the number and time of the train that goes from Chennai to Guruvayur.", "rationale": ["Identify the relevant tables: We need information from the 'train' table for train number and time, and the 'route' and 'station' tables to filter by origin and destination.", "Join the 'train' table with the 'route' table on the train ID to link trains to their routes.", "Join the 'route' table with the 'station' table on the station ID to access station information.", "Filter the results where the origin is 'Chennai' and the destination is 'Guruvayur'.", "Select the train number and time from the resulting joined tables."], "pred_sql": "SELECT train.train_number, train.time FROM train JOIN route ON train.id = route.train_id JOIN station ON route.station_id = station.id WHERE train.origin = 'Chennai' AND train.destination = 'Guruvayur';", "gold_sql": "SELECT train_number ,  TIME FROM train WHERE origin  =  'Chennai' AND destination  =  'Guruvayur'", "source_tables": ["train"]}
{"sample_id": 3162, "db_id": "station_weather", "question": "Find the number of trains starting from each origin.", "rationale": ["Identify the relevant table: The 'train' table contains information about trains, including their origin.", "Determine the required output: We need to count the number of trains for each origin.", "Use the COUNT() function to count the number of trains for each origin.", "Group the results by the 'origin' column to get the count for each unique origin."], "pred_sql": "SELECT origin, COUNT(*) AS number_of_trains FROM train GROUP BY origin;", "gold_sql": "SELECT origin ,  count(*) FROM train GROUP BY origin", "source_tables": ["train"]}
{"sample_id": 3163, "db_id": "station_weather", "question": "Find the name of the train whose route runs through greatest number of stations.", "rationale": ["Identify the relevant tables: We need to find the train name, which is in the 'train' table, and we need to know the route, which is in the 'route' table.", "Join the 'train' and 'route' tables on the train's ID to link each train with its corresponding route.", "Group the results by train ID to count the number of stations each train route runs through.", "Use the COUNT function to count the number of stations for each train.", "Order the results in descending order based on the count of stations to find the train with the greatest number of stations.", "Limit the results to 1 to get only the train with the maximum number of stations."], "pred_sql": "SELECT train.name\nFROM train\nJOIN route ON train.id = route.train_id\nGROUP BY train.id\nORDER BY COUNT(route.station_id) DESC\nLIMIT 1;", "gold_sql": "SELECT t1.name FROM train AS t1 JOIN route AS t2 ON t1.id  =  t2.train_id GROUP BY t2.train_id ORDER BY count(*) DESC LIMIT 1", "source_tables": ["train", "route"]}
{"sample_id": 3164, "db_id": "station_weather", "question": "Find the number of trains for each station, as well as the station network name and services.", "rationale": ["We need to find the number of trains for each station, which suggests a count of train IDs associated with each station.", "To get the number of trains per station, we will use a COUNT function on the train_id from the route table.", "We need to join the station table with the route table to link each station with its corresponding trains.", "The join will be a LEFT JOIN to ensure we include stations even if they have no trains associated with them.", "We will select the network name and services from the station table along with the count of trains.", "Finally, we will group the results by station ID, network name, and services to get the count for each unique station."], "pred_sql": "SELECT s.network_name, s.services, COUNT(r.train_id) AS number_of_trains\nFROM station s\nLEFT JOIN route r ON s.id = r.station_id\nGROUP BY s.id, s.network_name, s.services;", "gold_sql": "SELECT count(*) ,  t1.network_name ,  t1.services FROM station AS t1 JOIN route AS t2 ON t1.id  =  t2.station_id GROUP BY t2.station_id", "source_tables": ["route", "station"]}
{"sample_id": 3165, "db_id": "station_weather", "question": "What is the average high temperature for each day of week?", "rationale": ["Identify the relevant table: The 'weekly_weather' table contains the temperature data.", "Determine the required calculation: We need to calculate the average high temperature.", "Select the appropriate columns: We will select 'day_of_week' and the average of 'high_temperature'.", "Group the results by 'day_of_week' to get the average for each day."], "pred_sql": "SELECT day_of_week, AVG(high_temperature) AS average_high_temperature FROM weekly_weather GROUP BY day_of_week;", "gold_sql": "SELECT avg(high_temperature) ,  day_of_week FROM weekly_weather GROUP BY day_of_week", "source_tables": ["weekly_weather"]}
{"sample_id": 3166, "db_id": "station_weather", "question": "Give me the maximum low temperature and average precipitation at the Amersham station.", "rationale": ["Identify the required data: maximum low temperature and average precipitation.", "Determine the relevant tables: weekly_weather for weather data and station for station details.", "Join the weekly_weather table with the station table on the station_id to filter by station name.", "Use the MAX function to get the maximum low temperature and the AVG function to calculate the average precipitation.", "Filter the results to only include data for the Amersham station using a WHERE clause."], "pred_sql": "SELECT MAX(weekly_weather.low_temperature) AS max_low_temp, AVG(weekly_weather.precipitation) AS avg_precipitation \nFROM weekly_weather \nJOIN station ON weekly_weather.station_id = station.id \nWHERE station.network_name = 'Amersham';", "gold_sql": "SELECT max(t1.low_temperature) ,  avg(t1.precipitation) FROM weekly_weather AS t1 JOIN station AS t2 ON t1.station_id  =  t2.id WHERE t2.network_name  =  'Amersham'", "source_tables": ["station", "weekly_weather"]}
{"sample_id": 3167, "db_id": "station_weather", "question": "Find names and times of trains that run through stations for the local authority Chiltern.", "rationale": ["Identify the relevant tables: train, route, and station are needed to get the train names and times along with the local authority information.", "We need to select the 'name' and 'time' columns from the train table.", "To find which trains run through stations for the local authority 'Chiltern', we need to join the train table with the route table on 'train.id' and 'route.train_id'.", "Next, we join the route table with the station table on 'route.station_id' and 'station.id' to access the local authority information.", "Finally, we filter the results where the local authority is 'Chiltern' using a WHERE clause."], "pred_sql": "SELECT train.name, train.time \nFROM train \nJOIN route ON train.id = route.train_id \nJOIN station ON route.station_id = station.id \nWHERE station.local_authority = 'Chiltern';", "gold_sql": "SELECT t3.name ,  t3.time FROM station AS t1 JOIN route AS t2 ON t1.id  =  t2.station_id JOIN train AS t3 ON t2.train_id  =  t3.id WHERE t1.local_authority  =  'Chiltern'", "source_tables": ["route", "station", "train"]}
{"sample_id": 3168, "db_id": "station_weather", "question": "How many different services are provided by all stations?", "rationale": ["Identify the table that contains the information about services, which is the 'station' table.", "Determine that we need to sum the 'services' column to get the total number of different services provided by all stations.", "Construct the SQL query to select the sum of the 'services' column from the 'station' table."], "pred_sql": "SELECT SUM(services) AS total_services FROM station;", "gold_sql": "SELECT count(DISTINCT services) FROM station", "source_tables": ["station"]}
{"sample_id": 3169, "db_id": "station_weather", "question": "Find the id and local authority of the station with has the highest average high temperature.", "rationale": ["Identify the relevant tables: 'station' and 'weekly_weather' are needed to get the station details and their corresponding weather data.", "We need to find the average high temperature for each station, so we will join the 'station' table with the 'weekly_weather' table on the station ID.", "We will group the results by the station ID and local authority to calculate the average high temperature for each station.", "To find the station with the highest average high temperature, we will order the results by the average high temperature in descending order.", "Finally, we will limit the results to only the top entry to get the station with the highest average high temperature."], "pred_sql": "SELECT station.id, station.local_authority \nFROM station \nJOIN weekly_weather ON station.id = weekly_weather.station_id \nGROUP BY station.id, station.local_authority \nORDER BY AVG(weekly_weather.high_temperature) DESC \nLIMIT 1;", "gold_sql": "SELECT t2.id ,  t2.local_authority FROM weekly_weather AS t1 JOIN station AS t2 ON t1.station_id  =  t2.id GROUP BY t1.station_id ORDER BY avg(high_temperature) DESC LIMIT 1", "source_tables": ["station", "weekly_weather"]}
{"sample_id": 3170, "db_id": "station_weather", "question": "Find the id and local authority of the station whose maximum precipitation is higher than 50.", "rationale": ["Identify the relevant tables: 'station' and 'weekly_weather' are needed to get the station details and weather data respectively.", "We need to select the 'id' and 'local_authority' from the 'station' table.", "To find the stations with maximum precipitation higher than 50, we need to join the 'station' table with the 'weekly_weather' table on the 'station_id'.", "The condition for filtering is that the 'precipitation' in the 'weekly_weather' table must be greater than 50.", "Construct the SQL query to select the required fields and apply the join and where conditions."], "pred_sql": "SELECT station.id, station.local_authority \nFROM station \nJOIN weekly_weather ON station.id = weekly_weather.station_id \nWHERE weekly_weather.precipitation > 50;", "gold_sql": "SELECT t2.id ,  t2.local_authority FROM weekly_weather AS t1 JOIN station AS t2 ON t1.station_id  =  t2.id GROUP BY t1.station_id HAVING max(t1.precipitation)  >  50", "source_tables": ["station", "weekly_weather"]}
{"sample_id": 3171, "db_id": "station_weather", "question": "show the lowest low temperature and highest wind speed in miles per hour.", "rationale": ["Identify the relevant table: weekly_weather contains the data for temperatures and wind speeds.", "Determine the required fields: we need the lowest low temperature and the highest wind speed.", "Use aggregate functions: MIN() to find the lowest low temperature and MAX() to find the highest wind speed.", "Construct the SQL query to select these values from the weekly_weather table."], "pred_sql": "SELECT MIN(low_temperature) AS lowest_low_temperature, MAX(wind_speed_mph) AS highest_wind_speed FROM weekly_weather;", "gold_sql": "SELECT min(low_temperature) ,  max(wind_speed_mph) FROM weekly_weather", "source_tables": ["weekly_weather"]}
{"sample_id": 3172, "db_id": "station_weather", "question": "Find the origins from which more than 1 train starts.", "rationale": ["Identify the relevant table: The 'train' table contains the 'origin' column which we need to analyze.", "We want to find origins with more than one train, so we will group the results by the 'origin' column.", "Using the COUNT function, we can count the number of trains for each origin.", "To filter the results to only those origins with more than one train, we will use the HAVING clause with a condition of COUNT(*) > 1."], "pred_sql": "SELECT origin FROM train GROUP BY origin HAVING COUNT(*) > 1;", "gold_sql": "SELECT origin FROM train GROUP BY origin HAVING count(*)  >  1", "source_tables": ["train"]}
{"sample_id": 3173, "db_id": "college_1", "question": "Find the number of professors in accounting department.", "rationale": ["Identify the relevant table: PROFESSOR, which contains information about professors including their department code.", "To find the number of professors in the accounting department, we need to filter the PROFESSOR table by the department code associated with accounting.", "The department code for accounting can be found in the DEPARTMENT table by filtering on the department name 'Accounting'.", "Use a subquery to get the DEPT_CODE for 'Accounting' from the DEPARTMENT table.", "Count the number of professors in the PROFESSOR table that match the DEPT_CODE obtained from the subquery."], "pred_sql": "SELECT COUNT(*) AS number_of_professors FROM PROFESSOR WHERE DEPT_CODE = (SELECT DEPT_CODE FROM DEPARTMENT WHERE DEPT_NAME = 'Accounting');", "gold_sql": "SELECT count(*) FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE DEPT_NAME  =  'Accounting'", "source_tables": ["department", "professor"]}
{"sample_id": 3174, "db_id": "college_1", "question": "How many professors are in the accounting dept?", "rationale": ["Identify the relevant tables: PROFESSOR and DEPARTMENT.", "Determine the relationship between the tables: PROFESSOR is linked to DEPARTMENT through DEPT_CODE.", "We need to count the number of professors, so we will use the COUNT() function.", "Filter the results to only include professors from the Accounting department by using a WHERE clause on DEPARTMENT.DEPT_NAME.", "Construct the SQL query to select the count of professors from the joined tables with the specified condition."], "pred_sql": "SELECT COUNT(*) AS professor_count FROM PROFESSOR INNER JOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE WHERE DEPARTMENT.DEPT_NAME = 'Accounting';", "gold_sql": "SELECT count(*) FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE DEPT_NAME  =  'Accounting'", "source_tables": ["department", "professor"]}
{"sample_id": 3175, "db_id": "college_1", "question": "How many professors are teaching class with code ACCT-211?", "rationale": ["Identify the relevant table: The CLASS table contains information about classes and the professors teaching them.", "Determine the specific class code: The user is interested in the class with the code 'ACCT-211'.", "Count the number of professors: Since each class is associated with a professor through the PROF_NUM column, we can count the number of entries in the CLASS table that match the specified class code.", "Construct the SQL query: Use the COUNT function to count the number of rows in the CLASS table where CLASS_CODE is 'ACCT-211'."], "pred_sql": "SELECT COUNT(*) AS professor_count FROM CLASS WHERE CLASS_CODE = 'ACCT-211';", "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"]}
{"sample_id": 3176, "db_id": "college_1", "question": "How many professors teach a class with the code ACCT-211?", "rationale": ["Identify the relevant tables: CLASS and PROFESSOR.", "We need to count the number of distinct professors teaching a specific class, so we will use the COUNT function.", "Join the CLASS table with the PROFESSOR table on the PROF_NUM column from CLASS and EMP_NUM column from PROFESSOR.", "Filter the results to only include the class with the code 'ACCT-211'.", "Select the count of distinct professors from the joined tables."], "pred_sql": "SELECT COUNT(DISTINCT p.EMP_NUM) AS professor_count\nFROM CLASS c\nJOIN PROFESSOR p ON c.PROF_NUM = p.EMP_NUM\nWHERE c.CLASS_CODE = 'ACCT-211';", "gold_sql": "SELECT count(DISTINCT PROF_NUM) FROM CLASS WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["class"]}
{"sample_id": 3177, "db_id": "college_1", "question": "What is the first and last name of the professor in biology department?", "rationale": ["Identify the relevant tables: EMPLOYEE, PROFESSOR, and DEPARTMENT are needed to get the professor's name and their department.", "Join the EMPLOYEE table with the PROFESSOR table on EMP_NUM to get the professor's first and last names.", "Join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE to filter by the biology department.", "Use a WHERE clause to specify that we want professors from the Biology department.", "Select the first name (EMP_FNAME) and last name (EMP_LNAME) of the professors."], "pred_sql": "SELECT EMP_FNAME, EMP_LNAME FROM EMPLOYEE INNER JOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM INNER JOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE WHERE DEPARTMENT.DEPT_NAME = 'Biology';", "gold_sql": "SELECT T3.EMP_FNAME ,  T3.EMP_LNAME FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code JOIN employee AS T3 ON T1.EMP_NUM  =  T3.EMP_NUM WHERE DEPT_NAME  =  'Biology'", "source_tables": ["department", "professor", "employee"]}
{"sample_id": 3178, "db_id": "college_1", "question": "What are the first and last name of all biology professors?", "rationale": ["Identify the tables needed: EMPLOYEE, PROFESSOR, and DEPARTMENT.", "We need to join these tables to get the first and last names of professors who belong to the Biology department.", "The EMPLOYEE table contains the first and last names of employees (professors).", "The PROFESSOR table links professors to their respective departments.", "The DEPARTMENT table contains the department names, including Biology.", "We will use INNER JOIN to connect these tables based on their foreign key relationships.", "Finally, we will filter the results to only include professors from the Biology department."], "pred_sql": "SELECT EMP_FNAME, EMP_LNAME FROM EMPLOYEE INNER JOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM INNER JOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE WHERE DEPARTMENT.DEPT_NAME = 'Biology';", "gold_sql": "SELECT T3.EMP_FNAME ,  T3.EMP_LNAME FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code JOIN employee AS T3 ON T1.EMP_NUM  =  T3.EMP_NUM WHERE DEPT_NAME  =  'Biology'", "source_tables": ["department", "professor", "employee"]}
{"sample_id": 3179, "db_id": "college_1", "question": "What are the first names and date of birth of professors teaching course ACCT-211?", "rationale": ["Identify the relevant tables: PROFESSOR, EMPLOYEE, and COURSE are needed to get the first names and date of birth of professors teaching a specific course.", "Determine the columns to select: We need the first names (EMP_FNAME) and date of birth (EMP_DOB) from the EMPLOYEE table.", "Establish the relationships: PROFESSOR is linked to EMPLOYEE through EMP_NUM, and PROFESSOR is linked to COURSE through DEPT_CODE.", "Filter the results: We need to filter the courses to only include those with the CRS_CODE 'ACCT-211'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses to retrieve the desired information."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, EMPLOYEE.EMP_DOB \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN COURSE ON PROFESSOR.DEPT_CODE = COURSE.DEPT_CODE \nWHERE COURSE.CRS_CODE = 'ACCT-211';", "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"]}
{"sample_id": 3180, "db_id": "college_1", "question": "What are the first names and birthdates of the professors in charge of ACCT-211?", "rationale": ["Identify the relevant tables: PROFESSOR, EMPLOYEE, and CLASS are needed to get the first names and birthdates of professors associated with a specific class.", "The EMPLOYEE table contains the first names and birthdates of professors, while the PROFESSOR table links professors to their departments and classes.", "The CLASS table contains the course codes, which we need to filter by 'ACCT-211'.", "We will perform a JOIN between the PROFESSOR and EMPLOYEE tables to get the first names and birthdates, and another JOIN with the CLASS table to filter by the course code 'ACCT-211'.", "The final SQL query will select the first names and birthdates of professors who teach the class with the course code 'ACCT-211'."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, EMPLOYEE.EMP_DOB \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CRS_CODE = 'ACCT-211';", "gold_sql": "SELECT DISTINCT T1.EMP_FNAME ,  T1.EMP_DOB FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE CRS_CODE  =  'ACCT-211'", "source_tables": ["employee", "class"]}
{"sample_id": 3181, "db_id": "college_1", "question": "How many classes are professor whose last name is Graztevski has?", "rationale": ["Identify the relevant table: The CLASS table contains information about classes and the professor teaching them.", "Determine the relationship: The CLASS table has a foreign key PROF_NUM that links to the EMPLOYEE table, which contains the professor's last name.", "Filter the professors: We need to find the EMP_NUM of the professor with the last name 'Graztevski'.", "Count the classes: We will count the number of classes in the CLASS table where the PROF_NUM matches the EMP_NUM of the identified professor."], "pred_sql": "SELECT COUNT(*) AS class_count \nFROM CLASS \nWHERE PROF_NUM IN (SELECT EMP_NUM FROM EMPLOYEE WHERE EMP_LNAME = 'Graztevski');", "gold_sql": "SELECT count(*) FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE T1.EMP_LNAME  =  'Graztevski'", "source_tables": ["employee", "class"]}
{"sample_id": 3182, "db_id": "college_1", "question": "How many classes does the professor whose last name is Graztevski teach?", "rationale": ["Identify the professor by their last name 'Graztevski'.", "To find the professor's unique identifier (EMP_NUM), I will query the EMPLOYEE table.", "Once I have the EMP_NUM, I will count the number of classes they teach by querying the CLASS table where PROF_NUM matches the EMP_NUM."], "pred_sql": "SELECT COUNT(*) AS class_count \nFROM CLASS \nWHERE PROF_NUM = (SELECT EMP_NUM FROM EMPLOYEE WHERE EMP_LNAME = 'Graztevski');", "gold_sql": "SELECT count(*) FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE T1.EMP_LNAME  =  'Graztevski'", "source_tables": ["employee", "class"]}
{"sample_id": 3183, "db_id": "college_1", "question": "What is the code of the school where the accounting department belongs to?", "rationale": ["Identify the relevant table: The question pertains to the department and its associated school, so we will focus on the DEPARTMENT table.", "Determine the required information: We need the SCHOOL_CODE for the accounting department.", "Identify the condition: We need to filter the DEPARTMENT table to find the row where the DEPT_NAME is 'Accounting'.", "Construct the SQL query: We will select the SCHOOL_CODE from the DEPARTMENT table with the specified condition."], "pred_sql": "SELECT SCHOOL_CODE FROM DEPARTMENT WHERE DEPT_NAME = 'Accounting';", "gold_sql": "SELECT school_code FROM department WHERE dept_name  =  'Accounting'", "source_tables": ["department"]}
{"sample_id": 3184, "db_id": "college_1", "question": "What is the school code of the accounting department?", "rationale": ["Identify the table that contains the department information, which is the DEPARTMENT table.", "Determine the relevant column that holds the school code, which is SCHOOL_CODE.", "Filter the results to find the specific department by its name, 'Accounting'.", "Construct the SQL query to select the SCHOOL_CODE from the DEPARTMENT table where the DEPT_NAME matches 'Accounting'."], "pred_sql": "SELECT SCHOOL_CODE FROM DEPARTMENT WHERE DEPT_NAME = 'Accounting';", "gold_sql": "SELECT school_code FROM department WHERE dept_name  =  'Accounting'", "source_tables": ["department"]}
{"sample_id": 3185, "db_id": "college_1", "question": "How many credits does course CIS-220 have, and what its description?", "rationale": ["Identify the table that contains the information about courses, which is the COURSE table.", "Determine the columns needed: CRS_CREDIT for the number of credits and CRS_DESCRIPTION for the course description.", "Specify the course of interest by filtering with the CRS_CODE 'CIS-220'.", "Construct the SQL SELECT statement to retrieve the required columns from the COURSE table with the appropriate WHERE clause."], "pred_sql": "SELECT CRS_CREDIT, CRS_DESCRIPTION FROM COURSE WHERE CRS_CODE = 'CIS-220';", "gold_sql": "SELECT crs_credit ,  crs_description FROM course WHERE crs_code  =  'CIS-220'", "source_tables": ["course"]}
{"sample_id": 3186, "db_id": "college_1", "question": "What is the description for the CIS-220 and how many credits does it have?", "rationale": ["Identify the table that contains the course description and credits, which is the COURSE table.", "Determine the columns needed: CRS_DESCRIPTION for the course description and CRS_CREDIT for the number of credits.", "Specify the course code we are interested in, which is 'CIS-220'.", "Construct the SQL SELECT statement to retrieve the required columns from the COURSE table where the CRS_CODE matches 'CIS-220'."], "pred_sql": "SELECT CRS_DESCRIPTION, CRS_CREDIT FROM COURSE WHERE CRS_CODE = 'CIS-220';", "gold_sql": "SELECT crs_credit ,  crs_description FROM course WHERE crs_code  =  'CIS-220'", "source_tables": ["course"]}
{"sample_id": 3187, "db_id": "college_1", "question": "what is the address of history department?", "rationale": ["Identify the table that contains department information, which is the DEPARTMENT table.", "Determine the column that holds the address of the department, which is DEPT_ADDRESS.", "The user is asking for the address of the History department, so we need to filter the results based on the department name.", "Construct the SQL query to select the DEPT_ADDRESS from the DEPARTMENT table where the DEPT_NAME is 'History'."], "pred_sql": "SELECT DEPT_ADDRESS FROM DEPARTMENT WHERE DEPT_NAME = 'History';", "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"]}
{"sample_id": 3188, "db_id": "college_1", "question": "Where is the history department?", "rationale": ["Identify the relevant table: The query is asking for information about a department, so we will use the DEPARTMENT table.", "Determine the columns needed: We need the name and address of the department, which are DEPT_NAME and DEPT_ADDRESS.", "Specify the condition: The query specifies the history department, so we will filter the results where DEPT_NAME is 'History'.", "Construct the SQL query: Combine the selected columns, table, and condition into a complete SQL statement."], "pred_sql": "SELECT DEPT_NAME, DEPT_ADDRESS FROM DEPARTMENT WHERE DEPT_NAME = 'History';", "gold_sql": "SELECT dept_address FROM department WHERE dept_name  =  'History'", "source_tables": ["department"]}
{"sample_id": 3189, "db_id": "college_1", "question": "How many different locations does the school with code BUS has?", "rationale": ["Identify the relevant tables: CLASS and DEPARTMENT are needed to find class locations and filter by school code.", "We need to count distinct class rooms, so we will use COUNT(DISTINCT CLASS_ROOM).", "To filter by the school code 'BUS', we will join the CLASS table with the DEPARTMENT table on the appropriate foreign key (PROF_NUM to EMP_NUM).", "The final SQL query will select the count of distinct class rooms from the CLASS table where the associated department's school code is 'BUS'."], "pred_sql": "SELECT COUNT(DISTINCT CLASS_ROOM) AS different_locations FROM CLASS JOIN DEPARTMENT ON CLASS.PROF_NUM = EMPLOYEE.EMP_NUM WHERE DEPARTMENT.SCHOOL_CODE = 'BUS';", "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"]}
{"sample_id": 3190, "db_id": "college_1", "question": "What are the different locations of the school with the code BUS?", "rationale": ["Identify the table that contains the school locations, which is the DEPARTMENT table.", "Determine the relevant column for the school code, which is SCHOOL_CODE in the DEPARTMENT table.", "Use the DISTINCT keyword to ensure that only unique addresses are returned.", "Construct the SQL query to select the DEPT_ADDRESS from the DEPARTMENT table where the SCHOOL_CODE is 'BUS'."], "pred_sql": "SELECT DISTINCT DEPT_ADDRESS FROM DEPARTMENT WHERE SCHOOL_CODE = 'BUS';", "gold_sql": "SELECT count(DISTINCT dept_address) FROM department WHERE school_code  =  'BUS'", "source_tables": ["department"]}
{"sample_id": 3191, "db_id": "college_1", "question": "How many different locations does each school have?", "rationale": ["Identify the relevant table: The DEPARTMENT table contains information about departments, including their addresses and associated school codes.", "Determine the required information: We need to count the distinct locations (addresses) for each school.", "Use COUNT(DISTINCT DEPT_ADDRESS) to count unique addresses for each school.", "Group the results by SCHOOL_CODE to get the count of locations for each school."], "pred_sql": "SELECT SCHOOL_CODE, COUNT(DISTINCT DEPT_ADDRESS) AS location_count FROM DEPARTMENT GROUP BY SCHOOL_CODE;", "gold_sql": "SELECT count(DISTINCT dept_address) ,  school_code FROM department GROUP BY school_code", "source_tables": ["department"]}
{"sample_id": 3192, "db_id": "college_1", "question": "Count different addresses of each school.", "rationale": ["Identify the relevant table: The DEPARTMENT table contains the addresses and school codes.", "Determine the required output: We need to count distinct addresses for each school.", "Use COUNT(DISTINCT ...) to count unique addresses.", "Group the results by SCHOOL_CODE to get the count for each school."], "pred_sql": "SELECT SCHOOL_CODE, COUNT(DISTINCT DEPT_ADDRESS) AS unique_addresses_count FROM DEPARTMENT GROUP BY SCHOOL_CODE;", "gold_sql": "SELECT count(DISTINCT dept_address) ,  school_code FROM department GROUP BY school_code", "source_tables": ["department"]}
{"sample_id": 3193, "db_id": "college_1", "question": "Find the description and credit for the course QM-261?", "rationale": ["Identify the table that contains the course information, which is the COURSE table.", "Determine the columns needed from the COURSE table, which are CRS_DESCRIPTION and CRS_CREDIT.", "Specify the condition to filter the results to only include the course with the code 'QM-261'.", "Construct the SQL SELECT statement to retrieve the specified columns from the COURSE table with the appropriate WHERE clause."], "pred_sql": "SELECT CRS_DESCRIPTION, CRS_CREDIT FROM COURSE WHERE CRS_CODE = 'QM-261';", "gold_sql": "SELECT crs_credit ,  crs_description FROM course WHERE crs_code  =  'QM-261'", "source_tables": ["course"]}
{"sample_id": 3194, "db_id": "college_1", "question": "What is the course description and number of credits for QM-261?", "rationale": ["Identify the relevant table: The course description and number of credits are found in the COURSE table.", "Determine the columns needed: We need 'CRS_DESCRIPTION' and 'CRS_CREDIT' from the COURSE table.", "Specify the condition: We are looking for the course with the code 'QM-261'.", "Construct the SQL SELECT statement: Use SELECT to retrieve the specified columns from the COURSE table where the CRS_CODE matches 'QM-261'."], "pred_sql": "SELECT CRS_DESCRIPTION, CRS_CREDIT FROM COURSE WHERE CRS_CODE = 'QM-261';", "gold_sql": "SELECT crs_credit ,  crs_description FROM course WHERE crs_code  =  'QM-261'", "source_tables": ["course"]}
{"sample_id": 3195, "db_id": "college_1", "question": "Find the number of departments in each school.", "rationale": ["Identify the relevant table: The DEPARTMENT table contains information about departments and their associated school codes.", "Determine the required output: We need to count the number of departments for each school, which suggests using the COUNT() function.", "Group the results by school: To get the count of departments per school, we will use the GROUP BY clause on the SCHOOL_CODE column.", "Construct the SQL query: Combine the SELECT statement with COUNT() and GROUP BY to form the complete SQL query."], "pred_sql": "SELECT SCHOOL_CODE, COUNT(DEPT_CODE) AS number_of_departments FROM DEPARTMENT GROUP BY SCHOOL_CODE;", "gold_sql": "SELECT count(DISTINCT dept_name) ,  school_code FROM department GROUP BY school_code", "source_tables": ["department"]}
{"sample_id": 3196, "db_id": "college_1", "question": "How many departments are in each school?", "rationale": ["Identify the relevant table: The DEPARTMENT table contains information about departments and their associated school codes.", "Determine the required information: We need to count the number of departments for each school.", "Use the COUNT function: This function will help us count the number of departments (DEPT_CODE) for each school (SCHOOL_CODE).", "Group the results: We will use GROUP BY to group the results by SCHOOL_CODE to get the count for each school."], "pred_sql": "SELECT SCHOOL_CODE, COUNT(DEPT_CODE) AS DEPARTMENT_COUNT FROM DEPARTMENT GROUP BY SCHOOL_CODE;", "gold_sql": "SELECT count(DISTINCT dept_name) ,  school_code FROM department GROUP BY school_code", "source_tables": ["department"]}
{"sample_id": 3197, "db_id": "college_1", "question": "Find the number of different departments in each school whose number of different departments is less than 5.", "rationale": ["Identify the relevant table: The DEPARTMENT table contains information about departments and their associated school codes.", "Count the number of distinct departments for each school: Use COUNT(DISTINCT DEPT_CODE) to count unique departments per school.", "Group the results by school: Use GROUP BY SCHOOL_CODE to aggregate the counts for each school.", "Filter the results: Use HAVING COUNT(DISTINCT DEPT_CODE) < 5 to only include schools with fewer than 5 distinct departments."], "pred_sql": "SELECT SCHOOL_CODE, COUNT(DISTINCT DEPT_CODE) AS num_departments\nFROM DEPARTMENT\nGROUP BY SCHOOL_CODE\nHAVING COUNT(DISTINCT DEPT_CODE) < 5;", "gold_sql": "SELECT count(DISTINCT dept_name) ,  school_code FROM department GROUP BY school_code HAVING count(DISTINCT dept_name)  <  5", "source_tables": ["department"]}
{"sample_id": 3198, "db_id": "college_1", "question": "How many different departments are there in each school that has less than 5 apartments?", "rationale": ["Identify the relevant table: The DEPARTMENT table contains information about departments and their associated school codes.", "Count distinct departments: Use COUNT(DISTINCT DEPT_CODE) to count the number of unique departments for each school.", "Group by school: Use GROUP BY SCHOOL_CODE to aggregate the results by each school.", "Filter schools with less than 5 departments: Use HAVING COUNT(DISTINCT DEPT_CODE) < 5 to filter the results to only include schools with fewer than 5 departments."], "pred_sql": "SELECT SCHOOL_CODE, COUNT(DISTINCT DEPT_CODE) AS department_count\nFROM DEPARTMENT\nGROUP BY SCHOOL_CODE\nHAVING COUNT(DISTINCT DEPT_CODE) < 5;", "gold_sql": "SELECT count(DISTINCT dept_name) ,  school_code FROM department GROUP BY school_code HAVING count(DISTINCT dept_name)  <  5", "source_tables": ["department"]}
{"sample_id": 3199, "db_id": "college_1", "question": "How many sections does each course has?", "rationale": ["Identify the relevant table: The CLASS table contains information about class sections and their associated courses.", "Determine the required information: We need to count the number of sections for each course.", "Use the COUNT function: This function will help us count the number of sections (CLASS_SECTION) for each course (CRS_CODE).", "Group the results: We will use GROUP BY on CRS_CODE to get the count of sections for each course.", "Construct the SQL query: Combine the SELECT statement with COUNT and GROUP BY to form the complete SQL query."], "pred_sql": "SELECT CRS_CODE, COUNT(CLASS_SECTION) AS SECTION_COUNT FROM CLASS GROUP BY CRS_CODE;", "gold_sql": "SELECT count(*) ,  crs_code FROM CLASS GROUP BY crs_code", "source_tables": ["class"]}
{"sample_id": 3200, "db_id": "college_1", "question": "How many sections does each course have?", "rationale": ["Identify the relevant table: The CLASS table contains information about class sections and their associated courses.", "Determine the required information: We need to count the number of sections for each course.", "Use the COUNT function: This function will help us count the number of sections (CLASS_SECTION) for each course (CRS_CODE).", "Group the results: We will use GROUP BY on CRS_CODE to get the count of sections for each course.", "Construct the SQL query: Combine the SELECT statement with COUNT and GROUP BY to form the complete SQL query."], "pred_sql": "SELECT CRS_CODE, COUNT(CLASS_SECTION) AS SECTION_COUNT FROM CLASS GROUP BY CRS_CODE;", "gold_sql": "SELECT count(*) ,  crs_code FROM CLASS GROUP BY crs_code", "source_tables": ["class"]}
{"sample_id": 3201, "db_id": "college_1", "question": "What is the total credit does each department offer?", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE are needed to get the department names and their associated course credits.", "Determine the relationship: The DEPARTMENT table is linked to the COURSE table through the DEPT_CODE foreign key.", "Select the required fields: We need the department name (DEPT_NAME) and the total credits offered by each department (SUM of CRS_CREDIT).", "Use the SUM function to calculate the total credits for each department.", "Group the results by department name to get the total credits per department."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, SUM(CAST(COURSE.CRS_CREDIT AS INTEGER)) AS TOTAL_CREDITS\nFROM DEPARTMENT\nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"]}
{"sample_id": 3202, "db_id": "college_1", "question": "How many credits does the department offer?", "rationale": ["Identify the relevant table that contains information about credits offered by courses, which is the COURSE table.", "Determine that the CRS_CREDIT column in the COURSE table holds the credit information for each course.", "To find out how many credits the department offers, we need to sum the CRS_CREDIT values for all courses in the COURSE table.", "Construct the SQL query to select the sum of the CRS_CREDIT column from the COURSE table."], "pred_sql": "SELECT SUM(CRS_CREDIT) AS total_credits FROM COURSE;", "gold_sql": "SELECT sum(crs_credit) ,  dept_code FROM course GROUP BY dept_code", "source_tables": ["course"]}
{"sample_id": 3203, "db_id": "college_1", "question": "Find the number of classes offered for all class rooms that held at least 2 classes.", "rationale": ["Identify the table that contains information about classes, which is the CLASS table.", "We need to count the number of classes offered in each classroom, so we will use the COUNT() function.", "To group the results by classroom, we will use the GROUP BY clause on the CLASS_ROOM column.", "We only want classrooms that have at least 2 classes, so we will use the HAVING clause to filter the results where the count is greater than or equal to 2."], "pred_sql": "SELECT CLASS_ROOM, COUNT(*) AS number_of_classes\nFROM CLASS\nGROUP BY CLASS_ROOM\nHAVING COUNT(*) >= 2;", "gold_sql": "SELECT count(*) ,  class_room FROM CLASS GROUP BY class_room HAVING count(*)  >=  2", "source_tables": ["class"]}
{"sample_id": 3204, "db_id": "college_1", "question": "For each classroom with at least 2 classes, how many classes are offered?", "rationale": ["Identify the relevant table: The CLASS table contains information about classes and their associated rooms.", "Determine the required information: We need to count the number of classes offered in each classroom.", "Group the results: Use GROUP BY to group the results by CLASS_ROOM to count the number of classes in each room.", "Filter the results: Use HAVING to filter the groups to only include those with a count of at least 2 classes."], "pred_sql": "SELECT CLASS_ROOM, COUNT(*) AS class_count\nFROM CLASS\nGROUP BY CLASS_ROOM\nHAVING COUNT(*) >= 2;", "gold_sql": "SELECT count(*) ,  class_room FROM CLASS GROUP BY class_room HAVING count(*)  >=  2", "source_tables": ["class"]}
{"sample_id": 3205, "db_id": "college_1", "question": "Find the number of classes in each department.", "rationale": ["Identify the tables needed: We need the DEPARTMENT table to get department names and the CLASS table to count the number of classes.", "Determine the relationship: The CLASS table has a foreign key that relates to the COURSE table, which in turn relates to the DEPARTMENT table through the DEPT_CODE.", "Use a LEFT JOIN to include all departments even if they have no classes: This ensures that departments with zero classes are still included in the results.", "Count the number of classes for each department: Use COUNT(CLASS.CLASS_CODE) to count the classes and GROUP BY DEPARTMENT.DEPT_NAME to group the results by department."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(CLASS.CLASS_CODE) AS NUMBER_OF_CLASSES \nFROM DEPARTMENT \nLEFT JOIN CLASS ON DEPARTMENT.DEPT_CODE = CLASS.CRS_CODE \nGROUP BY DEPARTMENT.DEPT_NAME;", "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"]}
{"sample_id": 3206, "db_id": "college_1", "question": "How many classes are held in each department?", "rationale": ["Identify the tables needed: We need the DEPARTMENT table to get department names and the CLASS table to count the classes.", "Determine the relationship: The CLASS table has a foreign key that relates to the COURSE table, which in turn relates to the DEPARTMENT table through the DEPT_CODE.", "Use a LEFT JOIN to include all departments even if they have no classes.", "Count the number of classes for each department using COUNT(CLASS.CLASS_CODE).", "Group the results by department name to get the count for each department."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(CLASS.CLASS_CODE) AS CLASS_COUNT\nFROM DEPARTMENT\nLEFT JOIN CLASS ON DEPARTMENT.DEPT_CODE = CLASS.CRS_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "gold_sql": "SELECT count(*) ,  dept_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY dept_code", "source_tables": ["course", "class"]}
{"sample_id": 3207, "db_id": "college_1", "question": "Find the number of classes in each school.", "rationale": ["Identify the tables needed: CLASS, COURSE, and DEPARTMENT are required to find the number of classes in each school.", "We need to count the number of classes, so we will use the COUNT() function on CLASS.CLASS_CODE.", "To associate classes with schools, we will join CLASS with COURSE on CRS_CODE, and then join COURSE with DEPARTMENT on DEPT_CODE.", "We will group the results by SCHOOL_CODE to get the count of classes for each school."], "pred_sql": "SELECT DEPARTMENT.SCHOOL_CODE, COUNT(CLASS.CLASS_CODE) AS number_of_classes\nFROM CLASS\nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE\nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.SCHOOL_CODE;", "gold_sql": "SELECT count(*) ,  T3.school_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T2.dept_code  =  T3.dept_code GROUP BY T3.school_code", "source_tables": ["course", "department", "class"]}
{"sample_id": 3208, "db_id": "college_1", "question": "How many classes exist for each school?", "rationale": ["Identify the relevant tables: CLASS, COURSE, and DEPARTMENT are needed to find the number of classes per school.", "Determine the relationship between the tables: CLASS is linked to COURSE via CRS_CODE, and COURSE is linked to DEPARTMENT via DEPT_CODE.", "Use COUNT to aggregate the number of classes for each school.", "Group the results by SCHOOL_CODE to get the count of classes for each school."], "pred_sql": "SELECT DEPARTMENT.SCHOOL_CODE, COUNT(CLASS.CLASS_CODE) AS class_count\nFROM CLASS\nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE\nJOIN DEPARTMENT ON COURSE.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.SCHOOL_CODE;", "gold_sql": "SELECT count(*) ,  T3.school_code FROM CLASS AS T1 JOIN course AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T2.dept_code  =  T3.dept_code GROUP BY T3.school_code", "source_tables": ["course", "department", "class"]}
{"sample_id": 3209, "db_id": "college_1", "question": "What is the number of professors for different school?", "rationale": ["Identify the relevant tables: DEPARTMENT and PROFESSOR.", "We need to count the number of professors, which requires the EMP_NUM from the PROFESSOR table.", "To group the professors by school, we need the SCHOOL_CODE from the DEPARTMENT table.", "Join the DEPARTMENT and PROFESSOR tables on the DEPT_CODE to associate professors with their respective departments.", "Use COUNT(DISTINCT EMP_NUM) to count unique professors for each school.", "Group the results by SCHOOL_CODE to get the count of professors for each school."], "pred_sql": "SELECT SCHOOL_CODE, COUNT(DISTINCT EMP_NUM) AS number_of_professors FROM DEPARTMENT JOIN PROFESSOR ON DEPARTMENT.DEPT_CODE = PROFESSOR.DEPT_CODE GROUP BY SCHOOL_CODE;", "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"]}
{"sample_id": 3210, "db_id": "college_1", "question": "How many different professors are there for the different schools?", "rationale": ["Identify the relevant tables: PROFESSOR and DEPARTMENT.", "We need to count distinct professors, so we will use COUNT(DISTINCT PROFESSOR.EMP_NUM).", "To relate professors to schools, we need to join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE.", "The final query will select the count of distinct professors from the joined tables."], "pred_sql": "SELECT COUNT(DISTINCT PROFESSOR.EMP_NUM) AS different_professors FROM PROFESSOR JOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE;", "gold_sql": "SELECT count(*) ,  T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code", "source_tables": ["department", "professor"]}
{"sample_id": 3211, "db_id": "college_1", "question": "Find the count and code of the job has most employees.", "rationale": ["Identify the table that contains job codes and employee information, which is the EMPLOYEE table.", "We need to count the number of employees for each job code, so we will use the COUNT() function and group the results by EMP_JOBCODE.", "To find the job code with the most employees, we will order the results in descending order based on the count of employees.", "Finally, we will limit the results to only the top entry to get the job code with the most employees."], "pred_sql": "SELECT EMP_JOBCODE, COUNT(*) AS employee_count FROM EMPLOYEE GROUP BY EMP_JOBCODE ORDER BY employee_count DESC LIMIT 1;", "gold_sql": "SELECT emp_jobcode ,  count(*) FROM employee GROUP BY emp_jobcode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee"]}
{"sample_id": 3212, "db_id": "college_1", "question": "What is the count and code of the job with the most employee?", "rationale": ["Identify the relevant table: The EMPLOYEE table contains the job codes and employee information.", "Count the number of employees for each job code: Use COUNT(*) to count the number of employees grouped by their job code.", "Group the results by job code: Use GROUP BY EMP_JOBCODE to aggregate the counts for each job code.", "Order the results by the count in descending order: Use ORDER BY employee_count DESC to sort the job codes by the number of employees.", "Limit the results to the top entry: Use LIMIT 1 to get only the job code with the most employees."], "pred_sql": "SELECT EMP_JOBCODE, COUNT(*) AS employee_count FROM EMPLOYEE GROUP BY EMP_JOBCODE ORDER BY employee_count DESC LIMIT 1;", "gold_sql": "SELECT emp_jobcode ,  count(*) FROM employee GROUP BY emp_jobcode ORDER BY count(*) DESC LIMIT 1", "source_tables": ["employee"]}
{"sample_id": 3213, "db_id": "college_1", "question": "Which school has the smallest amount of professors?", "rationale": ["Identify the relevant tables: PROFESSOR and DEPARTMENT, since we need to count professors and associate them with schools.", "Join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE to link professors to their respective schools.", "Group the results by SCHOOL_CODE to count the number of professors in each school.", "Use COUNT(PROF_NUM) to count the number of professors for each school.", "Order the results by the count of professors in ascending order to find the school with the smallest number of professors.", "Limit the results to 1 to get only the school with the smallest amount of professors."], "pred_sql": "SELECT SCHOOL_CODE, COUNT(PROF_NUM) AS professor_count \nFROM PROFESSOR \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nGROUP BY SCHOOL_CODE \nORDER BY professor_count ASC \nLIMIT 1;", "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"]}
{"sample_id": 3214, "db_id": "college_1", "question": "Which school has the fewest professors?", "rationale": ["Identify the relevant tables: PROFESSOR and DEPARTMENT, since we need to count professors and associate them with schools.", "Join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE to link professors to their respective schools.", "Group the results by SCHOOL_CODE to count the number of professors in each school.", "Use COUNT(PROF_NUM) to count the number of professors for each school.", "Order the results by the count of professors in ascending order to find the school with the fewest professors.", "Limit the results to 1 to get only the school with the fewest professors."], "pred_sql": "SELECT SCHOOL_CODE, COUNT(PROF_NUM) AS professor_count \nFROM PROFESSOR \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nGROUP BY SCHOOL_CODE \nORDER BY professor_count ASC \nLIMIT 1;", "gold_sql": "SELECT T1.school_code FROM department AS T1 JOIN professor AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.school_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"]}
{"sample_id": 3215, "db_id": "college_1", "question": "Find the number of professors with a Ph.D. degree in each department.", "rationale": ["Identify the tables needed: PROFESSOR and DEPARTMENT.", "We need to count the number of professors, so we will use COUNT() function on the EMP_NUM from the PROFESSOR table.", "To get the department names, we will select DEPT_NAME from the DEPARTMENT table.", "We need to join the PROFESSOR and DEPARTMENT tables on the DEPT_CODE to link professors to their respective departments.", "We need to filter the professors to only include those with a Ph.D. degree, so we will add a WHERE clause for PROF_HIGH_DEGREE = 'Ph.D.'", "Finally, we will group the results by DEPARTMENT.DEPT_NAME to get the count of professors per department."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(PROFESSOR.EMP_NUM) AS NumberOfProfessors\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nWHERE PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D.'\nGROUP BY DEPARTMENT.DEPT_NAME;", "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"]}
{"sample_id": 3216, "db_id": "college_1", "question": "How many professors have a Ph.D. in each department?", "rationale": ["Identify the relevant tables: PROFESSOR and DEPARTMENT.", "We need to count the number of professors with a Ph.D. in each department, so we will use COUNT() function.", "Join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE to associate professors with their respective departments.", "Filter the results to include only those professors whose highest degree is 'Ph.D.' using a WHERE clause.", "Group the results by department name to get the count of Ph.D. professors in each department."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(PROFESSOR.EMP_NUM) AS PhD_Professors\nFROM PROFESSOR\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nWHERE PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D.'\nGROUP BY DEPARTMENT.DEPT_NAME;", "gold_sql": "SELECT count(*) ,  dept_code FROM professor WHERE prof_high_degree  =  'Ph.D.' GROUP BY dept_code", "source_tables": ["professor"]}
{"sample_id": 3217, "db_id": "college_1", "question": "Find the number of students for each department.", "rationale": ["We need to find the number of students for each department, which requires us to count the students grouped by their department.", "The relevant tables are DEPARTMENT and STUDENT, as we need to get the department names and the count of students in each department.", "We will perform a LEFT JOIN between DEPARTMENT and STUDENT on the DEPT_CODE to ensure we include departments even if they have no students.", "We will use the COUNT function to count the number of students (STU_NUM) for each department.", "Finally, we will group the results by DEPARTMENT.DEPT_NAME to get the count for each department."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(STUDENT.STU_NUM) AS NUM_STUDENTS\nFROM DEPARTMENT\nLEFT JOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"]}
{"sample_id": 3218, "db_id": "college_1", "question": "How many students are in each department?", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT.", "We need to count the number of students in each department, so we will use the COUNT function on STUDENT.STU_NUM.", "To associate students with their respective departments, we will perform a LEFT JOIN between the DEPARTMENT and STUDENT tables on the DEPT_CODE column.", "We will group the results by DEPARTMENT.DEPT_NAME to get the count of students for each department.", "The final query will select the department name and the count of students, using an alias for the count."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, COUNT(STUDENT.STU_NUM) AS STUDENT_COUNT\nFROM DEPARTMENT\nLEFT JOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "gold_sql": "SELECT count(*) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"]}
{"sample_id": 3219, "db_id": "college_1", "question": "Find the total number of hours have done for all students in each department.", "rationale": ["Identify the tables needed: STUDENT and DEPARTMENT.", "We need to sum the total hours (STU_HRS) for each student, which is in the STUDENT table.", "We need to group the results by department, which is in the DEPARTMENT table.", "Join the STUDENT table with the DEPARTMENT table on the DEPT_CODE to associate students with their respective departments.", "Select the department name (DEPT_NAME) and the sum of student hours (SUM(STU_HRS)) for each department.", "Use GROUP BY to aggregate the results by department name."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, SUM(STUDENT.STU_HRS) AS TOTAL_HOURS\nFROM STUDENT\nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"]}
{"sample_id": 3220, "db_id": "college_1", "question": "How many hours do the students spend studying in each department?", "rationale": ["Identify the relevant tables: STUDENT and DEPARTMENT are needed to get the hours spent studying and the department names.", "Determine the relationship between the tables: STUDENT has a foreign key DEPT_CODE that links to DEPARTMENT's DEPT_CODE.", "Select the necessary columns: We need the department name (DEPARTMENT.DEPT_NAME) and the total hours (SUM(STUDENT.STU_HRS)).", "Use the SUM function to aggregate the total hours spent studying by students in each department.", "Group the results by department name to get the total hours for each department."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, SUM(STUDENT.STU_HRS) AS TOTAL_HOURS\nFROM STUDENT\nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "gold_sql": "SELECT sum(stu_hrs) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"]}
{"sample_id": 3221, "db_id": "college_1", "question": "Find the max, average, and minimum gpa of all students in each department.", "rationale": ["Identify the required data: We need to find the maximum, average, and minimum GPA of students, grouped by their department.", "Determine the tables involved: The STUDENT table contains the GPA information, and the DEPARTMENT table contains the department names.", "Establish the relationship between the tables: The STUDENT table has a foreign key DEPT_CODE that links to the DEPARTMENT table's DEPT_CODE.", "Construct the SQL query: We will use a SELECT statement to retrieve the department name and the GPA statistics, using aggregate functions (MAX, AVG, MIN).", "Group the results by department name to get the statistics for each department."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, MAX(STUDENT.STU_GPA) AS Max_GPA, AVG(STUDENT.STU_GPA) AS Average_GPA, MIN(STUDENT.STU_GPA) AS Min_GPA\nFROM STUDENT\nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "gold_sql": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"]}
{"sample_id": 3222, "db_id": "college_1", "question": "What is the highest, lowest, and average student GPA for every department?", "rationale": ["Identify the required information: highest, lowest, and average GPA of students for each department.", "Determine the relevant tables: STUDENT for GPA and DEPARTMENT for department names.", "Join the STUDENT table with the DEPARTMENT table on the DEPT_CODE to associate students with their respective departments.", "Use aggregate functions: MAX() for highest GPA, MIN() for lowest GPA, and AVG() for average GPA.", "Group the results by department name to get the statistics for each department."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, MAX(STUDENT.STU_GPA) AS Highest_GPA, MIN(STUDENT.STU_GPA) AS Lowest_GPA, AVG(STUDENT.STU_GPA) AS Average_GPA\nFROM STUDENT\nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "gold_sql": "SELECT max(stu_gpa) ,  avg(stu_gpa) ,  min(stu_gpa) ,  dept_code FROM student GROUP BY dept_code", "source_tables": ["student"]}
{"sample_id": 3223, "db_id": "college_1", "question": "What is the name and the average gpa of department whose students have the highest average gpa?", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT are needed to get the department names and student GPAs.", "Join the DEPARTMENT table with the STUDENT table on the DEPT_CODE to associate students with their respective departments.", "Use the AVG function to calculate the average GPA for each department.", "Group the results by department name to get the average GPA per department.", "Order the results by average GPA in descending order to find the department with the highest average GPA.", "Limit the results to 1 to get only the top department."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, AVG(STUDENT.STU_GPA) AS average_gpa\nFROM DEPARTMENT\nJOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME\nORDER BY average_gpa DESC\nLIMIT 1;", "gold_sql": "SELECT T2.dept_name ,  avg(T1.stu_gpa) FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY avg(T1.stu_gpa) DESC LIMIT 1", "source_tables": ["department", "student"]}
{"sample_id": 3224, "db_id": "college_1", "question": "Which department has the highest average student GPA, and what is the average gpa?", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT are needed to find the department and the average GPA of students.", "Join the DEPARTMENT table with the STUDENT table on the DEPT_CODE to associate students with their respective departments.", "Use the AVG() function to calculate the average GPA for each department.", "Group the results by department name to get the average GPA per department.", "Order the results in descending order based on the average GPA to find the highest average.", "Limit the results to 1 to get only the department with the highest average GPA."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, AVG(STUDENT.STU_GPA) AS average_gpa\nFROM DEPARTMENT\nJOIN STUDENT ON DEPARTMENT.DEPT_CODE = STUDENT.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME\nORDER BY average_gpa DESC\nLIMIT 1;", "gold_sql": "SELECT T2.dept_name ,  avg(T1.stu_gpa) FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY avg(T1.stu_gpa) DESC LIMIT 1", "source_tables": ["department", "student"]}
{"sample_id": 3225, "db_id": "college_1", "question": "how many schools exist in total?", "rationale": ["Identify the relevant table that contains information about schools, which is the DEPARTMENT table.", "Determine the column that represents the school code, which is SCHOOL_CODE in the DEPARTMENT table.", "Use the COUNT function to count the distinct SCHOOL_CODE values to get the total number of schools.", "Formulate the SQL query to select the count of distinct SCHOOL_CODE from the DEPARTMENT table."], "pred_sql": "SELECT COUNT(DISTINCT SCHOOL_CODE) AS total_schools FROM DEPARTMENT;", "gold_sql": "SELECT count(DISTINCT school_code) FROM department", "source_tables": ["department"]}
{"sample_id": 3226, "db_id": "college_1", "question": "How many schools are there in the department?", "rationale": ["Identify the relevant table: The question pertains to the number of schools in a department, which relates to the DEPARTMENT table.", "Determine the relevant column: The SCHOOL_CODE column in the DEPARTMENT table represents the schools.", "Count distinct schools: To find out how many unique schools there are, we need to count the distinct values in the SCHOOL_CODE column.", "Construct the SQL query: Use the COUNT function along with DISTINCT to count the unique SCHOOL_CODE values from the DEPARTMENT table."], "pred_sql": "SELECT COUNT(DISTINCT SCHOOL_CODE) AS number_of_schools FROM DEPARTMENT;", "gold_sql": "SELECT count(DISTINCT school_code) FROM department", "source_tables": ["department"]}
{"sample_id": 3227, "db_id": "college_1", "question": "How many different classes are there?", "rationale": ["Identify the table that contains class information, which is the CLASS table.", "To find the number of different classes, we need to count unique entries in the CLASS_CODE column.", "Use the COUNT function to count the distinct CLASS_CODE values.", "The final SQL query selects the count of distinct CLASS_CODE from the CLASS table."], "pred_sql": "SELECT COUNT(DISTINCT CLASS_CODE) AS different_classes FROM CLASS;", "gold_sql": "SELECT count(DISTINCT class_code) FROM CLASS", "source_tables": ["class"]}
{"sample_id": 3228, "db_id": "college_1", "question": "How many unique classes are offered?", "rationale": ["Identify the table that contains class information, which is the CLASS table.", "To find the number of unique classes, we need to count distinct CLASS_CODE values in the CLASS table.", "The SQL query will use the COUNT function along with DISTINCT to ensure we only count unique CLASS_CODEs."], "pred_sql": "SELECT COUNT(DISTINCT CLASS_CODE) AS unique_classes FROM CLASS;", "gold_sql": "SELECT count(DISTINCT class_code) FROM CLASS", "source_tables": ["class"]}
{"sample_id": 3229, "db_id": "college_1", "question": "How many courses are offered?", "rationale": ["Identify the table that contains information about courses, which is the COURSE table.", "To find out how many courses are offered, we need to count the number of entries in the COURSE table.", "Use the COUNT() function to count the total number of courses in the COURSE table.", "Construct the SQL query to select the count of courses from the COURSE table."], "pred_sql": "SELECT COUNT(*) AS total_courses FROM COURSE;", "gold_sql": "SELECT count(DISTINCT crs_code) FROM CLASS", "source_tables": ["class"]}
{"sample_id": 3230, "db_id": "college_1", "question": "What are the number of different course codes?", "rationale": ["Identify the table that contains course codes, which is the COURSE table.", "To find the number of different course codes, we need to count distinct values in the CRS_CODE column.", "The SQL query will use the COUNT function along with DISTINCT to ensure we only count unique course codes.", "The final SQL query will select the count of distinct CRS_CODE from the COURSE table."], "pred_sql": "SELECT COUNT(DISTINCT CRS_CODE) AS number_of_different_course_codes FROM COURSE;", "gold_sql": "SELECT count(DISTINCT crs_code) FROM CLASS", "source_tables": ["class"]}
{"sample_id": 3231, "db_id": "college_1", "question": "How many departments does the college has?", "rationale": ["Identify the table that contains department information, which is the DEPARTMENT table.", "To find out how many departments exist, we need to count the number of entries in the DEPARTMENT table.", "Use the COUNT() function to count the total number of rows in the DEPARTMENT table.", "Select the count with an alias 'department_count' for clarity."], "pred_sql": "SELECT COUNT(*) AS department_count FROM DEPARTMENT;", "gold_sql": "SELECT count(DISTINCT dept_name) FROM department", "source_tables": ["department"]}
{"sample_id": 3232, "db_id": "college_1", "question": "How many different departments are there?", "rationale": ["Identify the table that contains department information, which is the DEPARTMENT table.", "To find the number of different departments, we need to count distinct department codes (DEPT_CODE) in the DEPARTMENT table.", "Use the COUNT function to count the distinct DEPT_CODE values.", "Construct the SQL query to select the count of distinct DEPT_CODE from the DEPARTMENT table."], "pred_sql": "SELECT COUNT(DISTINCT DEPT_CODE) AS number_of_departments FROM DEPARTMENT;", "gold_sql": "SELECT count(DISTINCT dept_name) FROM department", "source_tables": ["department"]}
{"sample_id": 3233, "db_id": "college_1", "question": "How many courses are offered by the Computer Info. Systems department?", "rationale": ["Identify the department of interest: Computer Info. Systems.", "Find the DEPT_CODE associated with the Computer Info. Systems department from the DEPARTMENT table.", "Count the number of courses in the COURSE table that have the DEPT_CODE matching the one found in the previous step."], "pred_sql": "SELECT COUNT(*) AS course_count FROM COURSE WHERE DEPT_CODE = (SELECT DEPT_CODE FROM DEPARTMENT WHERE DEPT_NAME = 'Computer Info. Systems');", "gold_sql": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "department"]}
{"sample_id": 3234, "db_id": "college_1", "question": "How many courses does the department of Computer Information Systmes offer?", "rationale": ["Identify the relevant table: The question pertains to the number of courses offered by a specific department, which is found in the COURSE table.", "Determine the department: The department of interest is 'Computer Information Systems'. We need to find its corresponding DEPT_CODE from the DEPARTMENT table.", "Count the courses: We will count the number of entries in the COURSE table where the DEPT_CODE matches the one obtained from the previous step."], "pred_sql": "SELECT COUNT(*) AS course_count FROM COURSE WHERE DEPT_CODE = (SELECT DEPT_CODE FROM DEPARTMENT WHERE DEPT_NAME = 'Computer Information Systems');", "gold_sql": "SELECT count(*) FROM department AS T1 JOIN course AS T2 ON T1.dept_code  =  T2.dept_code WHERE dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "department"]}
{"sample_id": 3235, "db_id": "college_1", "question": "How many sections does course ACCT-211 has?", "rationale": ["Identify the table that contains information about class sections, which is the CLASS table.", "Determine the relevant column for course codes, which is CRS_CODE in the CLASS table.", "Use the COUNT function to count the distinct CLASS_SECTION values for the specified course code 'ACCT-211'.", "The query should filter the results to only include sections for the course ACCT-211."], "pred_sql": "SELECT COUNT(DISTINCT CLASS_SECTION) AS section_count FROM CLASS WHERE CRS_CODE = 'ACCT-211';", "gold_sql": "SELECT count(DISTINCT class_section) FROM CLASS WHERE crs_code  =  'ACCT-211'", "source_tables": ["class"]}
{"sample_id": 3236, "db_id": "college_1", "question": "What is the number of different class sections offered in the course ACCT-211?", "rationale": ["Identify the table that contains information about class sections, which is the CLASS table.", "Determine the relevant column for class sections, which is CLASS_SECTION.", "We need to count the distinct class sections, so we will use the COUNT function with DISTINCT.", "The course code we are interested in is ACCT-211, so we will filter the results using a WHERE clause on the CRS_CODE column."], "pred_sql": "SELECT COUNT(DISTINCT CLASS_SECTION) AS number_of_sections FROM CLASS WHERE CRS_CODE = 'ACCT-211';", "gold_sql": "SELECT count(DISTINCT class_section) FROM CLASS WHERE crs_code  =  'ACCT-211'", "source_tables": ["class"]}
{"sample_id": 3237, "db_id": "college_1", "question": "Find the total credits of all classes offered by each department.", "rationale": ["Identify the tables needed: DEPARTMENT, COURSE, and CLASS are required to find the total credits of classes offered by each department.", "Determine the relationship between the tables: DEPARTMENT is linked to COURSE through DEPT_CODE, and COURSE is linked to CLASS through CRS_CODE.", "Select the relevant columns: We need the department name (DEPT_NAME) and the sum of course credits (CRS_CREDIT).", "Use the SUM function to calculate the total credits for each department.", "Group the results by department name to get the total credits per department."], "pred_sql": "SELECT D.DEPT_NAME, SUM(C.CRS_CREDIT) AS TOTAL_CREDITS\nFROM DEPARTMENT D\nJOIN COURSE C ON D.DEPT_CODE = C.DEPT_CODE\nJOIN CLASS CL ON C.CRS_CODE = CL.CRS_CODE\nGROUP BY D.DEPT_NAME;", "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"]}
{"sample_id": 3238, "db_id": "college_1", "question": "What are the total number of credits offered by each department?", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE are needed to get department names and course credits.", "Determine the relationship: DEPARTMENT and COURSE are linked through the DEPT_CODE foreign key.", "Select the department name from the DEPARTMENT table and the sum of course credits from the COURSE table.", "Use the SUM function to calculate the total credits for each department.", "Group the results by department name to get the total credits per department."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, SUM(CAST(COURSE.CRS_CREDIT AS INTEGER)) AS TOTAL_CREDITS\nFROM DEPARTMENT\nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME;", "gold_sql": "SELECT sum(T1.crs_credit) ,  T1.dept_code FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code GROUP BY T1.dept_code", "source_tables": ["course", "class"]}
{"sample_id": 3239, "db_id": "college_1", "question": "Find the name of the department that offers the largest number of credits of all classes.", "rationale": ["Identify the relevant tables: DEPARTMENT, COURSE, and CLASS are needed to find the department and the credits associated with classes.", "Join the DEPARTMENT table with the COURSE table on DEPT_CODE to link courses to their respective departments.", "Join the resulting table with the CLASS table on CRS_CODE to associate classes with their courses.", "Group the results by department name to aggregate the total credits offered by each department.", "Use SUM to calculate the total credits for each department by summing the CRS_CREDIT from the COURSE table.", "Order the results in descending order based on the total credits to find the department with the largest number of credits.", "Limit the results to 1 to get only the department with the highest total credits."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME\nFROM DEPARTMENT\nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE\nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE\nGROUP BY DEPARTMENT.DEPT_NAME\nORDER BY SUM(CAST(COURSE.CRS_CREDIT AS INTEGER)) DESC\nLIMIT 1;", "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"]}
{"sample_id": 3240, "db_id": "college_1", "question": "Which department offers the most credits all together?", "rationale": ["Identify the relevant tables: DEPARTMENT and COURSE.", "We need to find the total credits offered by each department, so we will sum the CRS_CREDIT from the COURSE table.", "Join the DEPARTMENT table with the COURSE table on the DEPT_CODE to associate courses with their respective departments.", "Group the results by DEPARTMENT.DEPT_NAME to calculate the total credits for each department.", "Order the results by the total credits in descending order to find the department with the most credits.", "Limit the results to 1 to get only the department with the highest total credits."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, SUM(CAST(COURSE.CRS_CREDIT AS INTEGER)) AS TOTAL_CREDITS\nFROM DEPARTMENT\nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE\nGROUP BY DEPARTMENT.DEPT_NAME\nORDER BY TOTAL_CREDITS DESC\nLIMIT 1;", "gold_sql": "SELECT T3.dept_name FROM course AS T1 JOIN CLASS AS T2 ON T1.crs_code  =  T2.crs_code JOIN department AS T3 ON T1.dept_code  =  T3.dept_code GROUP BY T1.dept_code ORDER BY sum(T1.crs_credit) DESC LIMIT 1", "source_tables": ["course", "department", "class"]}
{"sample_id": 3241, "db_id": "college_1", "question": "How many students enrolled in class ACCT-211?", "rationale": ["Identify the relevant table: The ENROLL table contains information about student enrollments in classes.", "Determine the specific class: The class code provided is 'ACCT-211'.", "Formulate the SQL query: We need to count the number of students enrolled in this specific class, which can be done using the COUNT() function in SQL.", "Construct the SELECT statement: We select the count of students from the ENROLL table where the CLASS_CODE matches 'ACCT-211'."], "pred_sql": "SELECT COUNT(*) AS student_count FROM ENROLL WHERE CLASS_CODE = 'ACCT-211';", "gold_sql": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["class", "enroll"]}
{"sample_id": 3242, "db_id": "college_1", "question": "What are the total number of students enrolled in ACCT-211?", "rationale": ["Identify the course code for ACCT-211, which is 'ACCT-211'.", "Determine the class codes associated with the course 'ACCT-211' by querying the CLASS table.", "Count the number of students enrolled in those classes by querying the ENROLL table using the class codes obtained in the previous step."], "pred_sql": "SELECT COUNT(*) AS total_students FROM ENROLL WHERE CLASS_CODE IN (SELECT CLASS_CODE FROM CLASS WHERE CRS_CODE = 'ACCT-211');", "gold_sql": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["class", "enroll"]}
{"sample_id": 3243, "db_id": "college_1", "question": "What is the first name of each student enrolled in class ACCT-211?", "rationale": ["Identify the tables needed: STUDENT, ENROLL, and CLASS.", "We need to find the first names of students, so we will select STUDENT.STU_FNAME.", "Students are enrolled in classes, so we will join the STUDENT table with the ENROLL table on STUDENT.STU_NUM = ENROLL.STU_NUM.", "Next, we need to join the CLASS table to filter by the specific class code 'ACCT-211', so we join CLASS on ENROLL.CLASS_CODE = CLASS.CLASS_CODE.", "Finally, we add a WHERE clause to filter the results to only include those students enrolled in the class with CLASS_CODE 'ACCT-211'."], "pred_sql": "SELECT STUDENT.STU_FNAME FROM STUDENT JOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM JOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE WHERE CLASS.CLASS_CODE = 'ACCT-211';", "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"]}
{"sample_id": 3244, "db_id": "college_1", "question": "What are the first names of all students in course ACCT-211?", "rationale": ["Identify the tables needed: STUDENT, ENROLL, and CLASS.", "We need to find students enrolled in a specific course, so we will join the ENROLL table with the STUDENT table on the student number (STU_NUM).", "Next, we need to join the CLASS table to filter by the course code (CRS_CODE).", "The course code we are interested in is 'ACCT-211'.", "Finally, we select the first names (STU_FNAME) of the students who are enrolled in that course."], "pred_sql": "SELECT STUDENT.STU_FNAME FROM STUDENT JOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM JOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE WHERE CLASS.CRS_CODE = 'ACCT-211';", "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"]}
{"sample_id": 3245, "db_id": "college_1", "question": "What is the first name of students enrolled in class ACCT-211 and got grade C?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed to get student names and their enrollment details.", "Determine the relationship between the tables: STUDENT is linked to ENROLL through the STU_NUM column.", "Specify the conditions: We need to filter for students enrolled in the class with CLASS_CODE 'ACCT-211' and who received a grade of 'C'.", "Construct the SQL SELECT statement to retrieve the first names of the students that meet the criteria."], "pred_sql": "SELECT STUDENT.STU_FNAME FROM STUDENT JOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM WHERE ENROLL.CLASS_CODE = 'ACCT-211' AND ENROLL.ENROLL_GRADE = 'C';", "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"]}
{"sample_id": 3246, "db_id": "college_1", "question": "What are the first names of all students who took ACCT-211 and received a C?", "rationale": ["Identify the relevant tables: STUDENT, ENROLL, and CLASS are needed to get the first names of students who took a specific class and received a specific grade.", "Determine the relationship between the tables: STUDENT is linked to ENROLL through STU_NUM, and ENROLL is linked to CLASS through CLASS_CODE.", "Filter the results based on the course code 'ACCT-211' and the grade 'C'.", "Select the first names of the students from the STUDENT table."], "pred_sql": "SELECT STUDENT.STU_FNAME FROM STUDENT JOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM JOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE WHERE CLASS.CRS_CODE = 'ACCT-211' AND ENROLL.ENROLL_GRADE = 'C';", "gold_sql": "SELECT T3.stu_fname FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T2.stu_num  =  T3.stu_num WHERE T1.crs_code  =  'ACCT-211' AND T2.enroll_grade  =  'C'", "source_tables": ["student", "class", "enroll"]}
{"sample_id": 3247, "db_id": "college_1", "question": "Find the total number of employees.", "rationale": ["Identify the table that contains employee information, which is the EMPLOYEE table.", "To find the total number of employees, we need to count the number of records in the EMPLOYEE table.", "Use the COUNT() function to count all rows in the EMPLOYEE table.", "Select the count with an alias 'total_employees' for clarity."], "pred_sql": "SELECT COUNT(*) AS total_employees FROM EMPLOYEE;", "gold_sql": "SELECT count(*) FROM employee", "source_tables": ["employee"]}
{"sample_id": 3248, "db_id": "college_1", "question": "How many employees are there all together?", "rationale": ["Identify the table that contains employee information, which is the EMPLOYEE table.", "To find the total number of employees, we need to count the number of records in the EMPLOYEE table.", "Use the COUNT() function to count all rows in the EMPLOYEE table.", "Select the count with an alias 'total_employees' for clarity."], "pred_sql": "SELECT COUNT(*) AS total_employees FROM EMPLOYEE;", "gold_sql": "SELECT count(*) FROM employee", "source_tables": ["employee"]}
{"sample_id": 3249, "db_id": "college_1", "question": "How many professors do have a Ph.D. degree?", "rationale": ["Identify the table that contains information about professors, which is the PROFESSOR table.", "Determine the relevant column that indicates the highest degree obtained by the professors, which is PROF_HIGH_DEGREE.", "Formulate a query to count the number of professors where the PROF_HIGH_DEGREE is 'Ph.D.'.", "Use the COUNT() function to get the total number of professors with a Ph.D. degree."], "pred_sql": "SELECT COUNT(*) AS num_professors FROM PROFESSOR WHERE PROF_HIGH_DEGREE = 'Ph.D.';", "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.'", "source_tables": ["professor"]}
{"sample_id": 3250, "db_id": "college_1", "question": "What is the total number of professors with a Ph.D. ?", "rationale": ["Identify the table that contains information about professors, which is the PROFESSOR table.", "Determine the relevant column that indicates the highest degree obtained by the professor, which is PROF_HIGH_DEGREE.", "Formulate a query to count the number of professors where the PROF_HIGH_DEGREE is 'Ph.D.'.", "Use the COUNT() function to get the total number of professors with a Ph.D."], "pred_sql": "SELECT COUNT(*) AS total_professors_with_phd FROM PROFESSOR WHERE PROF_HIGH_DEGREE = 'Ph.D.';", "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.'", "source_tables": ["professor"]}
{"sample_id": 3251, "db_id": "college_1", "question": "How many students are enrolled in the class taught by some professor from the accounting department?", "rationale": ["Identify the relevant tables: ENROLL, CLASS, PROFESSOR, and DEPARTMENT.", "We need to count the number of distinct students enrolled in classes.", "Join the ENROLL table with the CLASS table on CLASS_CODE to get class information.", "Join the CLASS table with the PROFESSOR table on PROF_NUM to get professor information.", "Join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE to filter by the accounting department.", "Use a WHERE clause to specify that we are only interested in the accounting department.", "Use COUNT(DISTINCT ENROLL.STU_NUM) to count the unique students enrolled in those classes."], "pred_sql": "SELECT COUNT(DISTINCT ENROLL.STU_NUM) AS student_count\nFROM ENROLL\nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE\nJOIN PROFESSOR ON CLASS.PROF_NUM = PROFESSOR.EMP_NUM\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nWHERE DEPARTMENT.DEPT_NAME = 'Accounting';", "gold_sql": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code WHERE T4.dept_name  =  'Accounting'", "source_tables": ["course", "department", "class", "enroll"]}
{"sample_id": 3252, "db_id": "college_1", "question": "How many students are enrolled in some classes that are taught by an accounting professor?", "rationale": ["Identify the tables involved: ENROLL (for student enrollment), CLASS (for class details), PROFESSOR (for professor details), and DEPARTMENT (to filter by department).", "We need to count the distinct students enrolled in classes taught by professors from the Accounting department.", "Join the ENROLL table with CLASS on CLASS_CODE to get class details for each enrollment.", "Join the CLASS table with PROFESSOR on PROF_NUM to get the professor details for each class.", "Join the PROFESSOR table with DEPARTMENT on DEPT_CODE to filter professors by their department.", "Use a WHERE clause to specify that we are only interested in professors from the Accounting department.", "Finally, use COUNT(DISTINCT ENROLL.STU_NUM) to count the unique students enrolled in these classes."], "pred_sql": "SELECT COUNT(DISTINCT ENROLL.STU_NUM) AS student_count\nFROM ENROLL\nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE\nJOIN PROFESSOR ON CLASS.PROF_NUM = PROFESSOR.EMP_NUM\nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE\nWHERE DEPARTMENT.DEPT_NAME = 'Accounting';", "gold_sql": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code WHERE T4.dept_name  =  'Accounting'", "source_tables": ["course", "department", "class", "enroll"]}
{"sample_id": 3253, "db_id": "college_1", "question": "What is the name of the department that has the largest number of students enrolled?", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT.", "We need to find the department with the largest number of students enrolled, which means we need to count the number of students per department.", "Group the students by their department code (DEPT_CODE) and count the number of students (STU_NUM) in each department.", "Order the results by the count of students in descending order to get the department with the most students at the top.", "Limit the results to 1 to get only the department with the largest number of students.", "Finally, select the department name (DEPT_NAME) from the DEPARTMENT table using the department code obtained from the previous steps."], "pred_sql": "SELECT DEPT_NAME FROM DEPARTMENT WHERE DEPT_CODE = (SELECT DEPT_CODE FROM STUDENT GROUP BY DEPT_CODE ORDER BY COUNT(STU_NUM) DESC LIMIT 1);", "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"]}
{"sample_id": 3254, "db_id": "college_1", "question": "What is the name of the department with the most students enrolled?", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT.", "We need to find the department with the most students enrolled, which means we need to count the number of students in each department.", "Group the results by DEPT_CODE in the STUDENT table to get the count of students per department.", "Order the grouped results by the count of students in descending order to get the department with the most students at the top.", "Limit the results to 1 to get only the department with the highest count.", "Select the DEPT_NAME from the DEPARTMENT table where the DEPT_CODE matches the one with the highest student count."], "pred_sql": "SELECT DEPT_NAME FROM DEPARTMENT WHERE DEPT_CODE = (SELECT DEPT_CODE FROM STUDENT GROUP BY DEPT_CODE ORDER BY COUNT(STU_NUM) DESC LIMIT 1)", "gold_sql": "SELECT T4.dept_name FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code GROUP BY T3.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["course", "department", "class", "enroll"]}
{"sample_id": 3255, "db_id": "college_1", "question": "list names of all departments ordered by their names.", "rationale": ["Identify the table that contains department names, which is the DEPARTMENT table.", "Select the column DEPT_NAME from the DEPARTMENT table.", "Use the ORDER BY clause to sort the results by DEPT_NAME in ascending order."], "pred_sql": "SELECT DEPT_NAME FROM DEPARTMENT ORDER BY DEPT_NAME;", "gold_sql": "SELECT dept_name FROM department ORDER BY dept_name", "source_tables": ["department"]}
{"sample_id": 3256, "db_id": "college_1", "question": "What are the names of all departments in alphabetical order?", "rationale": ["Identify the table that contains department names, which is the DEPARTMENT table.", "Select the column DEPT_NAME from the DEPARTMENT table to get the names of the departments.", "To fulfill the requirement of ordering the results alphabetically, use the ORDER BY clause on the DEPT_NAME column in ascending order."], "pred_sql": "SELECT DEPT_NAME FROM DEPARTMENT ORDER BY DEPT_NAME ASC;", "gold_sql": "SELECT dept_name FROM department ORDER BY dept_name", "source_tables": ["department"]}
{"sample_id": 3257, "db_id": "college_1", "question": "List the codes of all courses that take place in room KLR209.", "rationale": ["Identify the table that contains information about classes, which is the CLASS table.", "Determine the relevant column that indicates the room where the class is held, which is CLASS_ROOM.", "Identify the column that represents the course code, which is CRS_CODE in the CLASS table.", "Formulate a SQL query to select distinct course codes (CRS_CODE) from the CLASS table where the CLASS_ROOM is 'KLR209'."], "pred_sql": "SELECT DISTINCT CLASS.CRS_CODE FROM CLASS WHERE CLASS.CLASS_ROOM = 'KLR209';", "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"]}
{"sample_id": 3258, "db_id": "college_1", "question": "What are the codes of all the courses that are located in room KLR209?", "rationale": ["Identify the relevant table: The CLASS table contains information about class locations, including the CLASS_ROOM and CRS_CODE.", "Determine the specific information needed: We need the CRS_CODE of courses located in a specific room, KLR209.", "Construct the SQL query: Use a SELECT statement to retrieve the CRS_CODE from the CLASS table where the CLASS_ROOM matches 'KLR209'."], "pred_sql": "SELECT CRS_CODE FROM CLASS WHERE CLASS_ROOM = 'KLR209';", "gold_sql": "SELECT class_code FROM CLASS WHERE class_room  =  'KLR209'", "source_tables": ["class"]}
{"sample_id": 3259, "db_id": "college_1", "question": "List the first name of all employees with job code PROF ordered by their date of birth.", "rationale": ["Identify the table that contains employee information, which is the EMPLOYEE table.", "Determine the column needed for the first name of employees, which is EMP_FNAME.", "Filter the results to include only those employees with the job code 'PROF', using the EMP_JOBCODE column.", "Order the results by the date of birth of the employees, which is in the EMP_DOB column."], "pred_sql": "SELECT EMP_FNAME FROM EMPLOYEE WHERE EMP_JOBCODE = 'PROF' ORDER BY EMP_DOB;", "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' ORDER BY emp_dob", "source_tables": ["employee"]}
{"sample_id": 3260, "db_id": "college_1", "question": "What are the first names of all employees that are professors ordered by date of birth?", "rationale": ["Identify the table that contains employee information, which is the EMPLOYEE table.", "Determine the relationship between employees and professors, which is established through the PROFESSOR table that references EMP_NUM from the EMPLOYEE table.", "To find the first names of employees who are professors, we need to select EMP_FNAME from the EMPLOYEE table where the EMP_NUM exists in the PROFESSOR table.", "Finally, we need to order the results by the date of birth (EMP_DOB) of the employees."], "pred_sql": "SELECT EMP_FNAME FROM EMPLOYEE WHERE EMP_NUM IN (SELECT EMP_NUM FROM PROFESSOR) ORDER BY EMP_DOB;", "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' ORDER BY emp_dob", "source_tables": ["employee"]}
{"sample_id": 3261, "db_id": "college_1", "question": "Find the first names and offices of all professors sorted by alphabetical order of their first name.", "rationale": ["Identify the tables needed: PROFESSOR for professor details and EMPLOYEE for first names and offices.", "Select the columns required: EMP_FNAME from EMPLOYEE and PROF_OFFICE from PROFESSOR.", "Join the PROFESSOR table with the EMPLOYEE table on the common key EMP_NUM to get the first names of professors.", "Sort the results by the first names in alphabetical order using ORDER BY clause."], "pred_sql": "SELECT EMP_FNAME, PROF_OFFICE FROM PROFESSOR JOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM ORDER BY EMP_FNAME ASC;", "gold_sql": "SELECT T2.emp_fname ,  T1.prof_office FROM professor AS T1 JOIN employee AS T2 ON T1.emp_num  =  T2.emp_num ORDER BY T2.emp_fname", "source_tables": ["employee", "professor"]}
{"sample_id": 3262, "db_id": "college_1", "question": "What are the first names and office locations for all professors sorted alphabetically by first name?", "rationale": ["Identify the required fields: first names of professors and their office locations.", "Determine the tables involved: PROFESSOR for office locations and EMPLOYEE for first names.", "Establish the relationship between the tables: PROFESSOR is linked to EMPLOYEE through the EMP_NUM field.", "Construct the SELECT statement to retrieve the EMP_FNAME from EMPLOYEE and PROF_OFFICE from PROFESSOR.", "Add a JOIN clause to combine the PROFESSOR and EMPLOYEE tables based on the EMP_NUM field.", "Include an ORDER BY clause to sort the results alphabetically by first name (EMP_FNAME)."], "pred_sql": "SELECT EMP_FNAME, PROF_OFFICE FROM PROFESSOR JOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM ORDER BY EMP_FNAME ASC;", "gold_sql": "SELECT T2.emp_fname ,  T1.prof_office FROM professor AS T1 JOIN employee AS T2 ON T1.emp_num  =  T2.emp_num ORDER BY T2.emp_fname", "source_tables": ["employee", "professor"]}
{"sample_id": 3263, "db_id": "college_1", "question": "What is the first and last name of the oldest employee?", "rationale": ["Identify the table that contains employee information, which is the EMPLOYEE table.", "We need to retrieve the first name (EMP_FNAME) and last name (EMP_LNAME) of the employees.", "To find the oldest employee, we need to sort the employees by their date of birth (EMP_DOB) in ascending order.", "Finally, we limit the results to only one record to get the oldest employee."], "pred_sql": "SELECT EMP_FNAME, EMP_LNAME FROM EMPLOYEE ORDER BY EMP_DOB ASC LIMIT 1;", "gold_sql": "SELECT emp_fname ,  emp_lname FROM employee ORDER BY emp_dob LIMIT 1", "source_tables": ["employee"]}
{"sample_id": 3264, "db_id": "college_1", "question": "What are the first and last names of the employee with the earliest date of birth?", "rationale": ["Identify the table that contains employee information, which is the EMPLOYEE table.", "Determine the columns needed for the output, which are the first name (EMP_FNAME) and last name (EMP_LNAME) of the employee.", "To find the employee with the earliest date of birth, we need to find the minimum date of birth in the EMPLOYEE table.", "Use a subquery to select the minimum date of birth from the EMPLOYEE table.", "Finally, select the first and last names of the employee whose date of birth matches the minimum date found in the subquery."], "pred_sql": "SELECT EMP_FNAME, EMP_LNAME FROM EMPLOYEE WHERE EMP_DOB = (SELECT MIN(EMP_DOB) FROM EMPLOYEE);", "gold_sql": "SELECT emp_fname ,  emp_lname FROM employee ORDER BY emp_dob LIMIT 1", "source_tables": ["employee"]}
{"sample_id": 3265, "db_id": "college_1", "question": "What is the first, last name, gpa of the youngest one among students whose GPA is above 3?", "rationale": ["Identify the relevant table: STUDENT, as it contains the required fields (first name, last name, GPA, and date of birth).", "Filter the students to include only those with a GPA greater than 3 using the condition 'STU_GPA > 3'.", "To find the youngest student, sort the results by date of birth (STU_DOB) in descending order, so the most recent (youngest) date comes first.", "Limit the results to 1 to get only the youngest student.", "Select the first name (STU_FNAME), last name (STU_LNAME), and GPA (STU_GPA) of the filtered and sorted results."], "pred_sql": "SELECT STU_FNAME, STU_LNAME, STU_GPA FROM STUDENT WHERE STU_GPA > 3 ORDER BY STU_DOB DESC LIMIT 1;", "gold_sql": "SELECT stu_fname ,  stu_lname ,  stu_gpa FROM student WHERE stu_gpa  >  3 ORDER BY stu_dob DESC LIMIT 1", "source_tables": ["student"]}
{"sample_id": 3266, "db_id": "college_1", "question": "What is the first and last name of the youngest student with a GPA above 3, and what is their GPA?", "rationale": ["Identify the relevant table: STUDENT, as it contains the information about students including their names and GPA.", "Select the columns needed: STU_FNAME (first name), STU_LNAME (last name), and STU_GPA (GPA).", "Add a condition to filter students with a GPA greater than 3: WHERE STU_GPA > 3.", "To find the youngest student, we need to order the results by date of birth (STU_DOB) in descending order: ORDER BY STU_DOB DESC.", "Limit the results to only the first record, which will be the youngest student: LIMIT 1."], "pred_sql": "SELECT STU_FNAME, STU_LNAME, STU_GPA FROM STUDENT WHERE STU_GPA > 3 ORDER BY STU_DOB DESC LIMIT 1;", "gold_sql": "SELECT stu_fname ,  stu_lname ,  stu_gpa FROM student WHERE stu_gpa  >  3 ORDER BY stu_dob DESC LIMIT 1", "source_tables": ["student"]}
{"sample_id": 3267, "db_id": "college_1", "question": "What is the first name of students who got grade C in any class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed since we want student names and their grades.", "Determine the relationship: STUDENT is linked to ENROLL through the STU_NUM column.", "Specify the condition: We need to filter for students who received a grade of 'C'.", "Select the desired output: We want the first names of the students, which is in the STUDENT table under the STU_FNAME column."], "pred_sql": "SELECT STUDENT.STU_FNAME FROM STUDENT JOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM WHERE ENROLL.ENROLL_GRADE = 'C';", "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"]}
{"sample_id": 3268, "db_id": "college_1", "question": "What are the first names of all students who got a grade C in a class?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed to find student names and their grades.", "Determine the relationship between the tables: STUDENT is linked to ENROLL through the STU_NUM column.", "Specify the required information: We need the first names of students, which is in the STUDENT table under the STU_FNAME column.", "Filter the results: We only want students who received a grade of 'C', which is specified in the ENROLL table under the ENROLL_GRADE column.", "Construct the SQL query: Use a SELECT statement to get the distinct first names from the STUDENT table, joining it with the ENROLL table and applying the grade filter."], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME FROM STUDENT JOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM WHERE ENROLL.ENROLL_GRADE = 'C';", "gold_sql": "SELECT DISTINCT stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE enroll_grade  =  'C'", "source_tables": ["enroll", "student"]}
{"sample_id": 3269, "db_id": "college_1", "question": "What is the name of department where has the smallest number of professors?", "rationale": ["Identify the relevant tables: DEPARTMENT and PROFESSOR.", "We need to find the department with the smallest number of professors, so we will count the number of professors in each department.", "Use a subquery to group the PROFESSOR table by DEPT_CODE and count the number of professors in each department.", "Order the results of the subquery by the count of professors in ascending order to get the department with the least number of professors at the top.", "Limit the results of the subquery to 1 to get only the department with the smallest number of professors.", "Finally, use the DEPT_CODE from the subquery to select the DEPT_NAME from the DEPARTMENT table."], "pred_sql": "SELECT DEPT_NAME FROM DEPARTMENT WHERE DEPT_CODE = (SELECT DEPT_CODE FROM PROFESSOR GROUP BY DEPT_CODE ORDER BY COUNT(*) ASC LIMIT 1);", "gold_sql": "SELECT T2.dept_name FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"]}
{"sample_id": 3270, "db_id": "college_1", "question": "What is the name of the department with the fewest professors?", "rationale": ["Identify the relevant table: We need to find the department with the fewest professors, so we will work with the DEPARTMENT and PROFESSOR tables.", "Count the number of professors in each department: We can use the COUNT function on the EMP_NUM column in the PROFESSOR table, grouping by DEPT_CODE to get the number of professors per department.", "Order the results: We will order the results of the count in ascending order to find the department with the fewest professors.", "Limit the results: We will limit the results to 1 to get only the department with the fewest professors.", "Select the department name: Finally, we will select the DEPT_NAME from the DEPARTMENT table where the DEPT_CODE matches the one with the fewest professors."], "pred_sql": "SELECT DEPT_NAME FROM DEPARTMENT WHERE DEPT_CODE = (SELECT DEPT_CODE FROM PROFESSOR GROUP BY DEPT_CODE ORDER BY COUNT(EMP_NUM) ASC LIMIT 1);", "gold_sql": "SELECT T2.dept_name FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY count(*) LIMIT 1", "source_tables": ["department", "professor"]}
{"sample_id": 3271, "db_id": "college_1", "question": "What is the name of department where has the largest number of professors with a Ph.D. degree?", "rationale": ["Identify the relevant tables: DEPARTMENT and PROFESSOR.", "We need to find departments with professors who have a Ph.D. degree, so we will filter the PROFESSOR table by the highest degree.", "Group the results by DEPT_CODE to count the number of professors with a Ph.D. in each department.", "Order the grouped results by the count of professors in descending order to find the department with the most professors with a Ph.D.", "Select the DEPT_NAME from the DEPARTMENT table where the DEPT_CODE matches the one with the highest count of Ph.D. professors."], "pred_sql": "SELECT DEPT_NAME FROM DEPARTMENT WHERE DEPT_CODE IN (SELECT DEPT_CODE FROM PROFESSOR WHERE PROF_HIGH_DEGREE = 'Ph.D.' GROUP BY DEPT_CODE ORDER BY COUNT(*) DESC LIMIT 1)", "gold_sql": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  'Ph.D.' GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["department", "professor"]}
{"sample_id": 3272, "db_id": "college_1", "question": "Which department has the most professors with a Ph.D.?", "rationale": ["Identify the relevant tables: DEPARTMENT and PROFESSOR.", "We need to count the number of professors with a Ph.D. in each department.", "Join the DEPARTMENT table with the PROFESSOR table on the DEPT_CODE.", "Filter the results to include only those professors whose highest degree is a Ph.D.", "Group the results by department name to get the count of professors per department.", "Order the results by the count of professors in descending order to find the department with the most professors.", "Limit the results to 1 to get only the department with the highest count."], "pred_sql": "SELECT D.DEPT_NAME, COUNT(P.EMP_NUM) AS Professor_Count\nFROM DEPARTMENT D\nJOIN PROFESSOR P ON D.DEPT_CODE = P.DEPT_CODE\nWHERE P.PROF_HIGH_DEGREE = 'Ph.D.'\nGROUP BY D.DEPT_NAME\nORDER BY Professor_Count DESC\nLIMIT 1;", "gold_sql": "SELECT T2.dept_name ,  T1.dept_code FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.prof_high_degree  =  'Ph.D.' GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["department", "professor"]}
{"sample_id": 3273, "db_id": "college_1", "question": "What are the first names of the professors who do not teach a class.", "rationale": ["Identify the table that contains professor information, which is the EMPLOYEE table.", "We need to find professors who do not teach any class, so we will look for professors whose EMP_NUM is not present in the CLASS table's PROF_NUM column.", "Construct a subquery that selects all PROF_NUM from the CLASS table to find all professors who are teaching classes.", "Use the NOT IN clause to filter out those professors from the EMPLOYEE table, selecting only their first names (EMP_FNAME)."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME FROM EMPLOYEE WHERE EMPLOYEE.EMP_NUM NOT IN (SELECT CLASS.PROF_NUM FROM CLASS)", "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"]}
{"sample_id": 3274, "db_id": "college_1", "question": "What are the first names of all professors not teaching any classes?", "rationale": ["Identify the relevant tables: EMPLOYEE and CLASS, as we need to find professors and their teaching status.", "We need to select the first names of professors, which is in the EMPLOYEE table under the column EMP_FNAME.", "To find professors not teaching any classes, we can use a subquery to get the PROF_NUM from the CLASS table.", "The main query will select EMP_FNAME from the EMPLOYEE table where the EMP_NUM is not in the list of PROF_NUMs from the CLASS table.", "Additionally, we need to ensure that the EMP_NUM is present in the PROFESSOR table to confirm they are indeed professors."], "pred_sql": "SELECT EMP_FNAME FROM EMPLOYEE WHERE EMP_NUM NOT IN (SELECT PROF_NUM FROM CLASS) AND EMP_NUM IN (SELECT EMP_NUM FROM PROFESSOR);", "gold_sql": "SELECT emp_fname FROM employee WHERE emp_jobcode  =  'PROF' EXCEPT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num", "source_tables": ["employee", "class"]}
{"sample_id": 3275, "db_id": "college_1", "question": "What is the first names of the professors from the history department who do not teach a class.", "rationale": ["Identify the relevant tables: EMPLOYEE, PROFESSOR, and DEPARTMENT.", "Join the EMPLOYEE table with the PROFESSOR table on EMP_NUM to get professor details.", "Join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE to filter by department.", "Filter the results to include only professors from the 'History' department.", "Use a subquery to find professors who do not teach any class by checking if their EMP_NUM is not in the CLASS table's PROF_NUM column."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'History' \nAND PROFESSOR.EMP_NUM NOT IN (SELECT CLASS.PROF_NUM FROM CLASS)", "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T2.dept_code  =  T3.dept_code WHERE T3.dept_name  =  'History' EXCEPT SELECT T4.emp_fname FROM employee AS T4 JOIN CLASS AS T5 ON T4.emp_num  =  T5.prof_num", "source_tables": ["employee", "professor", "class", "department"]}
{"sample_id": 3276, "db_id": "college_1", "question": "What are the first names of all history professors who do not teach?", "rationale": ["Identify the relevant tables: EMPLOYEE, PROFESSOR, and DEPARTMENT are needed to find professors and their department names.", "Join the EMPLOYEE table with the PROFESSOR table on EMP_NUM to get the first names of professors.", "Join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE to filter for history professors.", "Use a WHERE clause to specify that we are only interested in professors from the History department.", "To find professors who do not teach, we need to check which professors are not present in the CLASS table. This can be done using a subquery that selects distinct PROF_NUM from the CLASS table.", "Combine all these conditions to form the final SQL query."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'History' AND PROFESSOR.EMP_NUM NOT IN (SELECT DISTINCT CLASS.PROF_NUM FROM CLASS)", "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T2.dept_code  =  T3.dept_code WHERE T3.dept_name  =  'History' EXCEPT SELECT T4.emp_fname FROM employee AS T4 JOIN CLASS AS T5 ON T4.emp_num  =  T5.prof_num", "source_tables": ["employee", "professor", "class", "department"]}
{"sample_id": 3277, "db_id": "college_1", "question": "What is the last name and office of the professor from the history department?", "rationale": ["Identify the relevant tables: PROFESSOR, EMPLOYEE, and DEPARTMENT are needed to get the professor's last name and office location.", "Determine the columns to select: We need the last name (EMP_LNAME) from the EMPLOYEE table and the office (PROF_OFFICE) from the PROFESSOR table.", "Establish the relationships: PROFESSOR is linked to EMPLOYEE through EMP_NUM, and PROFESSOR is linked to DEPARTMENT through DEPT_CODE.", "Filter the results: We need to filter the results to only include professors from the History department, which requires a WHERE clause on the DEPARTMENT table's DEPT_NAME column."], "pred_sql": "SELECT EMPLOYEE.EMP_LNAME, PROFESSOR.PROF_OFFICE \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'History';", "gold_sql": "SELECT T1.emp_lname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T2.dept_code  =  T3.dept_code WHERE T3.dept_name  =  'History'", "source_tables": ["employee", "professor", "department"]}
{"sample_id": 3278, "db_id": "college_1", "question": "What are the last name and office of all history professors?", "rationale": ["Identify the relevant tables: PROFESSOR, EMPLOYEE, and DEPARTMENT are needed to get the last names and offices of professors.", "Select the columns needed: We need the last name (EMP_LNAME) from the EMPLOYEE table and the office (PROF_OFFICE) from the PROFESSOR table.", "Join the tables: We need to join PROFESSOR with EMPLOYEE on EMP_NUM to get the last names, and join PROFESSOR with DEPARTMENT on DEPT_CODE to filter by department.", "Filter for history professors: We need to add a WHERE clause to filter the results to only include professors from the History department."], "pred_sql": "SELECT EMPLOYEE.EMP_LNAME, PROFESSOR.PROF_OFFICE \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'History';", "gold_sql": "SELECT T1.emp_lname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T2.dept_code  =  T3.dept_code WHERE T3.dept_name  =  'History'", "source_tables": ["employee", "professor", "department"]}
{"sample_id": 3279, "db_id": "college_1", "question": "What is department name and office for the professor whose last name is Heffington?", "rationale": ["Identify the tables needed: PROFESSOR for professor details and DEPARTMENT for department details.", "We need to retrieve the department name and office location for a specific professor.", "The professor is identified by their last name, which is stored in the EMPLOYEE table.", "Join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE to get the department name.", "Use a subquery to find the EMP_NUM of the professor with the last name 'Heffington'.", "Construct the SELECT statement to retrieve DEPT_NAME and PROF_OFFICE based on the conditions."], "pred_sql": "SELECT D.DEPT_NAME, P.PROF_OFFICE \nFROM PROFESSOR P \nJOIN DEPARTMENT D ON P.DEPT_CODE = D.DEPT_CODE \nWHERE P.EMP_NUM = (SELECT EMP_NUM FROM EMPLOYEE WHERE EMP_LNAME = 'Heffington')", "gold_sql": "SELECT T3.dept_name  ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T2.dept_code  =  T3.dept_code WHERE T1.emp_lname  =  'Heffington'", "source_tables": ["employee", "professor", "department"]}
{"sample_id": 3280, "db_id": "college_1", "question": "What is the name of the department and office location for the professor with the last name of Heffington?", "rationale": ["Identify the tables needed: We need information from the PROFESSOR and DEPARTMENT tables, and we also need to access the EMPLOYEE table to filter by the professor's last name.", "Determine the columns to select: We want the department name (DEPARTMENT.DEPT_NAME) and the office location (PROFESSOR.PROF_OFFICE).", "Establish the relationships: PROFESSOR is linked to DEPARTMENT through DEPT_CODE, and PROFESSOR is linked to EMPLOYEE through EMP_NUM.", "Construct the SQL query: Use JOIN to combine the tables based on the relationships identified, and filter the results using a WHERE clause to find the professor with the last name 'Heffington'."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME, PROFESSOR.PROF_OFFICE \nFROM PROFESSOR \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nWHERE EMPLOYEE.EMP_LNAME = 'Heffington';", "gold_sql": "SELECT T3.dept_name  ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T2.dept_code  =  T3.dept_code WHERE T1.emp_lname  =  'Heffington'", "source_tables": ["employee", "professor", "department"]}
{"sample_id": 3281, "db_id": "college_1", "question": "Find the last name and hire date of the professor who is in office DRE 102.", "rationale": ["Identify the relevant tables: We need information from the EMPLOYEE table for the last name and hire date, and from the PROFESSOR table to filter by office location.", "Determine the relationship between the tables: The EMPLOYEE table is linked to the PROFESSOR table through the EMP_NUM column.", "Construct the SELECT statement: We want to select the last name (EMP_LNAME) and hire date (EMP_HIREDATE) from the EMPLOYEE table.", "Add the JOIN clause: We need to join the EMPLOYEE table with the PROFESSOR table on the EMP_NUM column to access the office information.", "Add the WHERE clause: We need to filter the results to only include professors who are in office DRE 102."], "pred_sql": "SELECT EMPLOYEE.EMP_LNAME, EMPLOYEE.EMP_HIREDATE \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nWHERE PROFESSOR.PROF_OFFICE = 'DRE 102';", "gold_sql": "SELECT T1.emp_lname ,  T1.emp_hiredate FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num WHERE T2.prof_office  =  'DRE 102'", "source_tables": ["employee", "professor"]}
{"sample_id": 3282, "db_id": "college_1", "question": "What is the last name of the professor whose office is located in DRE 102, and when were they hired?", "rationale": ["Identify the relevant tables: We need information from the EMPLOYEE and PROFESSOR tables.", "Determine the columns needed: We need the last name of the professor (EMP_LNAME) and their hire date (EMP_HIREDATE).", "Establish the relationship between tables: The EMPLOYEE table is linked to the PROFESSOR table through the EMP_NUM column.", "Formulate the SQL query: Use a SELECT statement to retrieve the required columns, and join the EMPLOYEE and PROFESSOR tables on the EMP_NUM column. Add a WHERE clause to filter for the specific office location 'DRE 102'."], "pred_sql": "SELECT EMPLOYEE.EMP_LNAME, EMPLOYEE.EMP_HIREDATE \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nWHERE PROFESSOR.PROF_OFFICE = 'DRE 102';", "gold_sql": "SELECT T1.emp_lname ,  T1.emp_hiredate FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num WHERE T2.prof_office  =  'DRE 102'", "source_tables": ["employee", "professor"]}
{"sample_id": 3283, "db_id": "college_1", "question": "What is the code of the course which the student whose last name is Smithson took?", "rationale": ["Identify the relevant tables: CLASS, ENROLL, and STUDENT are needed to find the course code for a specific student.", "The CLASS table contains the course codes, the ENROLL table links students to classes, and the STUDENT table contains student information including last names.", "Join the CLASS and ENROLL tables on CLASS.CLASS_CODE = ENROLL.CLASS_CODE to connect classes with enrollments.", "Join the resulting table with the STUDENT table on ENROLL.STU_NUM = STUDENT.STU_NUM to connect enrollments with student details.", "Filter the results where STUDENT.STU_LNAME = 'Smithson' to find the specific student.", "Select CLASS.CRS_CODE to retrieve the course code associated with the specified student."], "pred_sql": "SELECT CLASS.CRS_CODE FROM CLASS JOIN ENROLL ON CLASS.CLASS_CODE = ENROLL.CLASS_CODE JOIN STUDENT ON ENROLL.STU_NUM = STUDENT.STU_NUM WHERE STUDENT.STU_LNAME = 'Smithson';", "gold_sql": "SELECT T1.crs_code FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T3.stu_num  =  T2.stu_num WHERE T3.stu_lname  =  'Smithson'", "source_tables": ["student", "class", "enroll"]}
{"sample_id": 3284, "db_id": "college_1", "question": "What are the course codes for every class that the student with the last name Smithson took?", "rationale": ["Identify the relevant tables: CLASS, ENROLL, and STUDENT are needed to find the course codes for classes taken by a specific student.", "Determine the relationship between the tables: CLASS is linked to ENROLL through CLASS_CODE, and ENROLL is linked to STUDENT through STU_NUM.", "Formulate the SQL query: We need to select the CRS_CODE from CLASS where the student\u2019s last name matches 'Smithson'.", "Use JOINs to connect the tables based on their relationships: CLASS JOIN ENROLL ON CLASS.CLASS_CODE = ENROLL.CLASS_CODE JOIN STUDENT ON ENROLL.STU_NUM = STUDENT.STU_NUM.", "Add the WHERE clause to filter results for the student with the last name 'Smithson'."], "pred_sql": "SELECT CLASS.CRS_CODE FROM CLASS JOIN ENROLL ON CLASS.CLASS_CODE = ENROLL.CLASS_CODE JOIN STUDENT ON ENROLL.STU_NUM = STUDENT.STU_NUM WHERE STUDENT.STU_LNAME = 'Smithson';", "gold_sql": "SELECT T1.crs_code FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T3.stu_num  =  T2.stu_num WHERE T3.stu_lname  =  'Smithson'", "source_tables": ["student", "class", "enroll"]}
{"sample_id": 3285, "db_id": "college_1", "question": "What are the description and credit of the course which the student whose last name is Smithson took?", "rationale": ["Identify the information needed: course description and credit hours for a specific student.", "Determine the tables involved: COURSE, CLASS, ENROLL, and STUDENT.", "Establish relationships between the tables: CLASS is linked to COURSE via CRS_CODE, ENROLL is linked to CLASS via CLASS_CODE, and STUDENT is linked to ENROLL via STU_NUM.", "Construct the SQL query to select the desired columns (CRS_DESCRIPTION and CRS_CREDIT) from the COURSE table.", "Use JOIN clauses to connect the tables based on their relationships.", "Add a WHERE clause to filter results for the student with the last name 'Smithson'."], "pred_sql": "SELECT COURSE.CRS_DESCRIPTION, COURSE.CRS_CREDIT \nFROM COURSE \nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE \nJOIN ENROLL ON CLASS.CLASS_CODE = ENROLL.CLASS_CODE \nJOIN STUDENT ON ENROLL.STU_NUM = STUDENT.STU_NUM \nWHERE STUDENT.STU_LNAME = 'Smithson';", "gold_sql": "SELECT T4.crs_description ,  T4.crs_credit FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T3.stu_num  =  T2.stu_num JOIN course AS T4 ON T4.crs_code  =  T1.crs_code WHERE T3.stu_lname  =  'Smithson'", "source_tables": ["course", "student", "class", "enroll"]}
{"sample_id": 3286, "db_id": "college_1", "question": "How many credits is the course that the student with the last name Smithson took, and what is its description?", "rationale": ["Identify the relevant tables: STUDENT, ENROLL, CLASS, and COURSE are needed to get the required information about the course taken by the student.", "The STUDENT table contains the last name of the student, so we will filter by 'Smithson'.", "The ENROLL table links students to the classes they are enrolled in, so we will join STUDENT with ENROLL on STU_NUM.", "The CLASS table contains the course codes for the classes, so we will join ENROLL with CLASS on CLASS_CODE.", "The COURSE table contains the course credits and descriptions, so we will join CLASS with COURSE on CRS_CODE.", "Finally, we will select the CRS_CREDIT and CRS_DESCRIPTION from the COURSE table where the last name of the student is 'Smithson'."], "pred_sql": "SELECT COURSE.CRS_CREDIT, COURSE.CRS_DESCRIPTION \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nWHERE STUDENT.STU_LNAME = 'Smithson';", "gold_sql": "SELECT T4.crs_description ,  T4.crs_credit FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN student AS T3 ON T3.stu_num  =  T2.stu_num JOIN course AS T4 ON T4.crs_code  =  T1.crs_code WHERE T3.stu_lname  =  'Smithson'", "source_tables": ["course", "student", "class", "enroll"]}
{"sample_id": 3287, "db_id": "college_1", "question": "How many professors who has a either Ph.D. or MA degree?", "rationale": ["Identify the table that contains information about professors, which is the PROFESSOR table.", "Determine the relevant column that indicates the highest degree obtained by the professors, which is PROF_HIGH_DEGREE.", "Formulate a query to count the number of professors whose highest degree is either 'Ph.D.' or 'MA'.", "Use the COUNT function to get the total number of professors that meet the criteria.", "Construct the final SQL query using the SELECT statement with the appropriate WHERE clause."], "pred_sql": "SELECT COUNT(*) AS professor_count FROM PROFESSOR WHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'MA');", "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"]}
{"sample_id": 3288, "db_id": "college_1", "question": "How many professors attained either Ph.D. or Masters degrees?", "rationale": ["Identify the table that contains information about professors, which is the PROFESSOR table.", "Determine the relevant column that indicates the highest degree obtained by professors, which is PROF_HIGH_DEGREE.", "Formulate a query to count the number of professors whose highest degree is either 'Ph.D.' or 'Masters'.", "Use the COUNT() function to get the total number of professors meeting the criteria.", "Construct the final SQL query using the SELECT statement with the appropriate WHERE clause."], "pred_sql": "SELECT COUNT(*) AS number_of_professors FROM PROFESSOR WHERE PROF_HIGH_DEGREE IN ('Ph.D.', 'Masters');", "gold_sql": "SELECT count(*) FROM professor WHERE prof_high_degree  =  'Ph.D.' OR prof_high_degree  =  'MA'", "source_tables": ["professor"]}
{"sample_id": 3289, "db_id": "college_1", "question": "How many professors who are from either Accounting or Biology department?", "rationale": ["Identify the tables needed: PROFESSOR and DEPARTMENT.", "We need to count the number of professors, so we will use the COUNT() function.", "To find professors from specific departments, we will join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE.", "We will filter the results to include only those professors whose department name is either 'Accounting' or 'Biology' using the WHERE clause with IN operator."], "pred_sql": "SELECT COUNT(*) AS professor_count FROM PROFESSOR P JOIN DEPARTMENT D ON P.DEPT_CODE = D.DEPT_CODE WHERE D.DEPT_NAME IN ('Accounting', 'Biology');", "gold_sql": "SELECT count(*) FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T2.dept_name  =  'Accounting' OR T2.dept_name  =  'Biology'", "source_tables": ["department", "professor"]}
{"sample_id": 3290, "db_id": "college_1", "question": "What is the number of professors who are in the Accounting or Biology departments?", "rationale": ["Identify the relevant tables: PROFESSOR and DEPARTMENT.", "We need to count the number of professors, so we will use the COUNT() function.", "To find professors in specific departments, we will join the PROFESSOR table with the DEPARTMENT table on the DEPT_CODE.", "We will filter the results to include only those departments that are 'Accounting' or 'Biology' using the WHERE clause with the IN operator."], "pred_sql": "SELECT COUNT(*) AS number_of_professors FROM PROFESSOR JOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE WHERE DEPARTMENT.DEPT_NAME IN ('Accounting', 'Biology');", "gold_sql": "SELECT count(*) FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T2.dept_name  =  'Accounting' OR T2.dept_name  =  'Biology'", "source_tables": ["department", "professor"]}
{"sample_id": 3291, "db_id": "college_1", "question": "Find the first name of the professor who is teaching two courses with code CIS-220 and QM-261.", "rationale": ["Identify the tables involved: We need information from the EMPLOYEE and PROFESSOR tables to get the professor's first name, and the CLASS table to find the courses they are teaching.", "Join the EMPLOYEE and PROFESSOR tables on the EMP_NUM to get the professor's details.", "Join the CLASS table to link the professor to the courses they are teaching using the PROF_NUM foreign key.", "Filter the results to include only the courses with codes 'CIS-220' and 'QM-261' using the WHERE clause.", "Group the results by the professor's first name to aggregate the courses they teach.", "Use the HAVING clause to ensure that we only select professors who are teaching exactly two distinct courses."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE CLASS.CRS_CODE IN ('CIS-220', 'QM-261') \nGROUP BY EMPLOYEE.EMP_FNAME \nHAVING COUNT(DISTINCT CLASS.CRS_CODE) = 2;", "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"]}
{"sample_id": 3292, "db_id": "college_1", "question": "What is the first name of the professor who is teaching CIS-220 and QM-261?", "rationale": ["Identify the tables needed: EMPLOYEE, PROFESSOR, and CLASS.", "We need to find the first name of the professor, so we will select EMPLOYEE.EMP_FNAME.", "Join the EMPLOYEE table with the PROFESSOR table on EMP_NUM to get the professor's details.", "Join the PROFESSOR table with the CLASS table on PROF_NUM to link professors to the classes they teach.", "Filter the results to include only the classes with CRS_CODE 'CIS-220' and 'QM-261' using the WHERE clause."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME FROM EMPLOYEE JOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM JOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM WHERE CLASS.CRS_CODE IN ('CIS-220', 'QM-261');", "gold_sql": "SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'CIS-220' INTERSECT SELECT T1.emp_fname FROM employee AS T1 JOIN CLASS AS T2 ON T1.emp_num  =  T2.prof_num WHERE crs_code  =  'QM-261'", "source_tables": ["employee", "class"]}
{"sample_id": 3293, "db_id": "college_1", "question": "Find the first name of student who is taking classes from accounting and Computer Info. Systems departments", "rationale": ["Identify the tables needed: STUDENT for student names, DEPARTMENT for department names, CLASS for class information, and COURSE for course details.", "Join the STUDENT table with the DEPARTMENT table on DEPT_CODE to filter students by their department.", "Join the CLASS table to link students to the classes they are taking.", "Join the COURSE table to access course information related to the classes.", "Use a WHERE clause to filter departments to 'Accounting' and 'Computer Info. Systems'.", "Select the distinct first names of students to avoid duplicates."], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE \nJOIN CLASS ON STUDENT.PROF_NUM = CLASS.PROF_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nWHERE DEPARTMENT.DEPT_NAME IN ('Accounting', 'Computer Info. Systems');", "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"]}
{"sample_id": 3294, "db_id": "college_1", "question": "What are the first names of all students taking accoutning and Computer Information Systems classes?", "rationale": ["Identify the tables needed: STUDENT, ENROLL, CLASS, and COURSE are required to get the first names of students enrolled in specific classes.", "Use the ENROLL table to link STUDENT and CLASS, as it contains the relationship between students and the classes they are enrolled in.", "Join the CLASS table to get the course codes associated with each class.", "Join the COURSE table to filter the classes based on their descriptions (accounting and Computer Information Systems).", "Select the distinct first names of students from the STUDENT table who are enrolled in the specified courses."], "pred_sql": "SELECT DISTINCT STUDENT.STU_FNAME \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nWHERE COURSE.CRS_DESCRIPTION IN ('accounting', 'Computer Information Systems');", "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Accounting' INTERSECT SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code JOIN department AS T5 ON T5.dept_code  =  T4.dept_code WHERE T5.dept_name  =  'Computer Info. Systems'", "source_tables": ["course", "enroll", "department", "class", "student"]}
{"sample_id": 3295, "db_id": "college_1", "question": "What is the average gpa of the students enrolled in the course with code ACCT-211?", "rationale": ["Identify the relevant tables: STUDENT, ENROLL, and CLASS are needed to find the average GPA of students enrolled in a specific course.", "The STUDENT table contains the GPA information (STU_GPA).", "The ENROLL table links students to classes they are enrolled in (using STU_NUM and CLASS_CODE).", "The CLASS table contains the course code (CRS_CODE) for each class.", "To find the average GPA for students in the course ACCT-211, we need to join these tables on their respective keys: ENROLL.STU_NUM with STUDENT.STU_NUM and ENROLL.CLASS_CODE with CLASS.CLASS_CODE.", "Filter the results to only include classes where CLASS.CRS_CODE is 'ACCT-211'.", "Use the AVG() function to calculate the average GPA from the filtered results."], "pred_sql": "SELECT AVG(STU_GPA) AS average_gpa\nFROM STUDENT\nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM\nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE\nWHERE CLASS.CRS_CODE = 'ACCT-211';", "gold_sql": "SELECT avg(T2.stu_gpa) FROM enroll AS T1 JOIN student AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T1.class_code  =  T3.class_code WHERE T3.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"]}
{"sample_id": 3296, "db_id": "college_1", "question": "What is the average GPA of students taking ACCT-211?", "rationale": ["Identify the relevant tables: STUDENT, ENROLL, and CLASS are needed to find the average GPA of students enrolled in a specific class.", "The STUDENT table contains the GPA information, while the ENROLL table links students to classes, and the CLASS table provides the course code.", "To find the average GPA, we need to calculate the average of the STU_GPA column from the STUDENT table.", "We will join the STUDENT table with the ENROLL table on the STU_NUM column to get the classes each student is enrolled in.", "Next, we will join the resulting table with the CLASS table on the CLASS_CODE column to filter for the specific course code 'ACCT-211'.", "Finally, we will use the AVG() function to calculate the average GPA of the students who are enrolled in the ACCT-211 class."], "pred_sql": "SELECT AVG(STU_GPA) AS average_gpa FROM STUDENT INNER JOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM INNER JOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE WHERE CLASS.CRS_CODE = 'ACCT-211';", "gold_sql": "SELECT avg(T2.stu_gpa) FROM enroll AS T1 JOIN student AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T1.class_code  =  T3.class_code WHERE T3.crs_code  =  'ACCT-211'", "source_tables": ["student", "class", "enroll"]}
{"sample_id": 3297, "db_id": "college_1", "question": "What is the first name, gpa and phone number of the top 5 students with highest gpa?", "rationale": ["Identify the columns needed: first name (STU_FNAME), GPA (STU_GPA), and phone number (STU_PHONE) from the STUDENT table.", "Determine the requirement to find the top 5 students with the highest GPA, which involves sorting the results by STU_GPA in descending order.", "Use the LIMIT clause to restrict the results to the top 5 entries after sorting."], "pred_sql": "SELECT STU_FNAME, STU_GPA, STU_PHONE FROM STUDENT ORDER BY STU_GPA DESC LIMIT 5;", "gold_sql": "SELECT stu_gpa ,  stu_phone ,  stu_fname FROM student ORDER BY stu_gpa DESC LIMIT 5", "source_tables": ["student"]}
{"sample_id": 3298, "db_id": "college_1", "question": "What is the first name, GPA, and phone number of the students with the top 5 GPAs?", "rationale": ["Identify the columns needed: first name (STU_FNAME), GPA (STU_GPA), and phone number (STU_PHONE) from the STUDENT table.", "Determine the requirement to find the top 5 GPAs, which means we need to order the results by STU_GPA in descending order.", "Use the LIMIT clause to restrict the results to the top 5 entries after ordering."], "pred_sql": "SELECT STU_FNAME, STU_GPA, STU_PHONE FROM STUDENT ORDER BY STU_GPA DESC LIMIT 5;", "gold_sql": "SELECT stu_gpa ,  stu_phone ,  stu_fname FROM student ORDER BY stu_gpa DESC LIMIT 5", "source_tables": ["student"]}
{"sample_id": 3299, "db_id": "college_1", "question": "What is the department name of the students with lowest gpa belongs to?", "rationale": ["Identify the relevant tables: STUDENT and DEPARTMENT.", "We need to find the department name associated with students, so we will join the STUDENT table with the DEPARTMENT table using the DEPT_CODE.", "To find the students with the lowest GPA, we will use a subquery to get the minimum GPA from the STUDENT table.", "The main query will select the DEPT_NAME from the DEPARTMENT table where the GPA of the student matches the minimum GPA found in the subquery."], "pred_sql": "SELECT D.DEPT_NAME \nFROM STUDENT S \nJOIN DEPARTMENT D ON S.DEPT_CODE = D.DEPT_CODE \nWHERE S.STU_GPA = (SELECT MIN(STU_GPA) FROM STUDENT);", "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"]}
{"sample_id": 3300, "db_id": "college_1", "question": "What is the name of the department with the student that has the lowest GPA?", "rationale": ["Identify the relevant tables: STUDENT and DEPARTMENT.", "We need to find the student with the lowest GPA, so we will use the MIN function on the STU_GPA column in the STUDENT table.", "To get the department name, we need to join the STUDENT table with the DEPARTMENT table on the DEPT_CODE column.", "The final query will select the DEPT_NAME from the DEPARTMENT table where the STU_GPA matches the minimum GPA found in the previous step."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME \nFROM STUDENT \nJOIN DEPARTMENT ON STUDENT.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE STUDENT.STU_GPA = (SELECT MIN(STU_GPA) FROM STUDENT);", "gold_sql": "SELECT T2.dept_name FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code ORDER BY stu_gpa LIMIT 1", "source_tables": ["department", "student"]}
{"sample_id": 3301, "db_id": "college_1", "question": "Find the first name and gpa of the students whose gpa is lower than the average gpa of all students.", "rationale": ["Identify the columns needed: first name (STU_FNAME) and GPA (STU_GPA) from the STUDENT table.", "Determine the condition: we need students whose GPA is lower than the average GPA of all students.", "To find the average GPA, we will use a subquery: SELECT AVG(STU_GPA) FROM STUDENT.", "Combine the selection of first names and GPAs with the condition using a WHERE clause.", "Construct the final SQL query to select the required fields from the STUDENT table where the GPA is less than the average GPA."], "pred_sql": "SELECT STU_FNAME, STU_GPA FROM STUDENT WHERE STU_GPA < (SELECT AVG(STU_GPA) FROM STUDENT);", "gold_sql": "SELECT stu_fname ,  stu_gpa FROM student WHERE stu_gpa  <  (SELECT avg(stu_gpa) FROM student)", "source_tables": ["student"]}
{"sample_id": 3302, "db_id": "college_1", "question": "What is the first name and GPA of every student that has a GPA lower than average?", "rationale": ["Identify the columns needed: first name (STU_FNAME) and GPA (STU_GPA) of students.", "Determine the condition: we need students with a GPA lower than the average GPA.", "To find the average GPA, we will use a subquery: SELECT AVG(STU_GPA) FROM STUDENT.", "Combine the selection of first names and GPAs with the condition using a WHERE clause."], "pred_sql": "SELECT STU_FNAME, STU_GPA FROM STUDENT WHERE STU_GPA < (SELECT AVG(STU_GPA) FROM STUDENT);", "gold_sql": "SELECT stu_fname ,  stu_gpa FROM student WHERE stu_gpa  <  (SELECT avg(stu_gpa) FROM student)", "source_tables": ["student"]}
{"sample_id": 3303, "db_id": "college_1", "question": "Find the name and address of the department that has the highest number of students.", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT.", "We need to find the department with the highest number of students, so we will join the DEPARTMENT table with the STUDENT table on the DEPT_CODE.", "We will group the results by DEPT_CODE to count the number of students in each department.", "We will order the results in descending order based on the count of students to get the department with the highest number of students at the top.", "Finally, we will limit the results to 1 to get only the department with the highest count.", "Select the DEPT_NAME and DEPT_ADDRESS from the DEPARTMENT table."], "pred_sql": "SELECT D.DEPT_NAME, D.DEPT_ADDRESS\nFROM DEPARTMENT D\nJOIN STUDENT S ON D.DEPT_CODE = S.DEPT_CODE\nGROUP BY D.DEPT_CODE\nORDER BY COUNT(S.STU_NUM) DESC\nLIMIT 1;", "gold_sql": "SELECT T2.dept_name ,  T2.dept_address FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["department", "student"]}
{"sample_id": 3304, "db_id": "college_1", "question": "What is the name and address of the department with the most students?", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT.", "We need to find the department with the most students, so we will join the DEPARTMENT table with the STUDENT table on the DEPT_CODE.", "We will group the results by DEPT_CODE to count the number of students in each department.", "We will order the results by the count of students in descending order to get the department with the most students at the top.", "Finally, we will limit the results to 1 to get only the department with the most students.", "Select the DEPT_NAME and DEPT_ADDRESS from the DEPARTMENT table."], "pred_sql": "SELECT D.DEPT_NAME, D.DEPT_ADDRESS\nFROM DEPARTMENT D\nJOIN STUDENT S ON D.DEPT_CODE = S.DEPT_CODE\nGROUP BY D.DEPT_CODE\nORDER BY COUNT(S.STU_NUM) DESC\nLIMIT 1;", "gold_sql": "SELECT T2.dept_name ,  T2.dept_address FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 1", "source_tables": ["department", "student"]}
{"sample_id": 3305, "db_id": "college_1", "question": "Find the name, address, number of students in the departments that have the top 3 highest number of students.", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT.", "We need to find the department name and address, which are in the DEPARTMENT table.", "We need to count the number of students, which requires joining the STUDENT table with the DEPARTMENT table on the DEPT_CODE.", "Use COUNT(S.STU_NUM) to count the number of students in each department.", "Group the results by department to get the count per department.", "Order the results by the number of students in descending order to get the top departments.", "Limit the results to the top 3 departments."], "pred_sql": "SELECT D.DEPT_NAME, D.DEPT_ADDRESS, COUNT(S.STU_NUM) AS NUM_STUDENTS\nFROM DEPARTMENT D\nJOIN STUDENT S ON D.DEPT_CODE = S.DEPT_CODE\nGROUP BY D.DEPT_CODE\nORDER BY NUM_STUDENTS DESC\nLIMIT 3;", "gold_sql": "SELECT T2.dept_name ,  T2.dept_address ,  count(*) FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 3", "source_tables": ["department", "student"]}
{"sample_id": 3306, "db_id": "college_1", "question": "What is the name, address, and number of students in the departments that have the 3 most students?", "rationale": ["Identify the relevant tables: DEPARTMENT and STUDENT are needed to get department names, addresses, and student counts.", "Join the DEPARTMENT table with the STUDENT table on the DEPT_CODE to associate students with their respective departments.", "Use COUNT(S.STU_NUM) to count the number of students in each department.", "Group the results by department using GROUP BY D.DEPT_CODE to aggregate student counts per department.", "Order the results by the number of students in descending order using ORDER BY NUM_STUDENTS DESC to get the departments with the most students at the top.", "Limit the results to the top 3 departments using LIMIT 3."], "pred_sql": "SELECT D.DEPT_NAME, D.DEPT_ADDRESS, COUNT(S.STU_NUM) AS NUM_STUDENTS\nFROM DEPARTMENT D\nJOIN STUDENT S ON D.DEPT_CODE = S.DEPT_CODE\nGROUP BY D.DEPT_CODE\nORDER BY NUM_STUDENTS DESC\nLIMIT 3;", "gold_sql": "SELECT T2.dept_name ,  T2.dept_address ,  count(*) FROM student AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code GROUP BY T1.dept_code ORDER BY count(*) DESC LIMIT 3", "source_tables": ["department", "student"]}
{"sample_id": 3307, "db_id": "college_1", "question": "Find the first name and office of the professor who is in the history department and has a Ph.D. degree.", "rationale": ["Identify the tables needed: PROFESSOR for professor details, EMPLOYEE for employee details, and DEPARTMENT for department details.", "We need to select the first name of the professor (EMP_FNAME) and their office (PROF_OFFICE).", "Join the PROFESSOR table with the EMPLOYEE table on EMP_NUM to get the first name of the professor.", "Join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE to filter by department.", "Add a WHERE clause to filter for the History department and for professors with a Ph.D. degree."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'History' AND PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D.';", "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"]}
{"sample_id": 3308, "db_id": "college_1", "question": "What are the first names and office of the professors who are in the history department and have a Ph.D?", "rationale": ["Identify the relevant tables: PROFESSOR, EMPLOYEE, and DEPARTMENT are needed to get the professors' first names and offices, as well as their department information.", "Determine the columns to select: We need the first names (EMP_FNAME) from the EMPLOYEE table and the office (PROF_OFFICE) from the PROFESSOR table.", "Establish the relationships: PROFESSOR is linked to EMPLOYEE through EMP_NUM, and PROFESSOR is linked to DEPARTMENT through DEPT_CODE.", "Filter the results: We need to filter for professors in the 'History' department and those who have a 'Ph.D'.", "Construct the SQL query using SELECT, JOIN, and WHERE clauses to retrieve the desired information."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'History' AND PROFESSOR.PROF_HIGH_DEGREE = 'Ph.D';", "gold_sql": "SELECT T1.emp_fname ,  T2.prof_office FROM employee AS T1 JOIN professor AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T3.dept_code  =  T2.dept_code WHERE T3.dept_name  =  'History' AND T2.prof_high_degree  =  'Ph.D.'", "source_tables": ["employee", "professor", "department"]}
{"sample_id": 3309, "db_id": "college_1", "question": "Find the first names of all instructors who have taught some course and the course code.", "rationale": ["Identify the relevant tables: EMPLOYEE for instructor information and CLASS for course information.", "We need to find instructors who have taught courses, which means we need to join the EMPLOYEE table with the CLASS table on the professor's identifier (EMP_NUM).", "Select the first names of the instructors (EMP_FNAME) and the course codes (CRS_CODE) from the joined tables.", "Use a JOIN operation to combine the EMPLOYEE and CLASS tables based on the matching PROF_NUM and EMP_NUM.", "Group the results by instructor's first name and course code to ensure distinct entries."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, CLASS.CRS_CODE \nFROM EMPLOYEE \nJOIN CLASS ON EMPLOYEE.EMP_NUM = CLASS.PROF_NUM \nGROUP BY EMPLOYEE.EMP_FNAME, CLASS.CRS_CODE;", "gold_sql": "SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num", "source_tables": ["employee", "class"]}
{"sample_id": 3310, "db_id": "college_1", "question": "What are the first names of all teachers who have taught a course and the corresponding course codes?", "rationale": ["Identify the relevant tables: EMPLOYEE (for teacher information), CLASS (for class information), and COURSE (for course codes).", "We need to retrieve the first names of teachers, which are stored in the EMPLOYEE table under the column EMP_FNAME.", "We also need the course codes, which are stored in the CLASS table under the column CRS_CODE.", "To find teachers who have taught a course, we need to join the EMPLOYEE table with the CLASS table on the condition that EMPLOYEE.EMP_NUM matches CLASS.PROF_NUM.", "Next, we join the CLASS table with the COURSE table to get the course codes, ensuring that CLASS.CRS_CODE matches COURSE.CRS_CODE.", "Finally, we select the EMP_FNAME from the EMPLOYEE table and the CRS_CODE from the CLASS table."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, CLASS.CRS_CODE \nFROM EMPLOYEE \nJOIN CLASS ON EMPLOYEE.EMP_NUM = CLASS.PROF_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE;", "gold_sql": "SELECT T2.emp_fname ,  T1.crs_code FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num", "source_tables": ["employee", "class"]}
{"sample_id": 3311, "db_id": "college_1", "question": "Find the first names of all instructors who have taught some course and the course description.", "rationale": ["Identify the tables needed: EMPLOYEE for instructor names, PROFESSOR to link instructors to classes, CLASS to link classes to courses, and COURSE for course descriptions.", "Join the EMPLOYEE table with the PROFESSOR table on EMP_NUM to get the first names of instructors.", "Join the PROFESSOR table with the CLASS table on EMP_NUM to find the classes taught by each instructor.", "Join the CLASS table with the COURSE table on CRS_CODE to get the course descriptions associated with each class.", "Select the EMP_FNAME from EMPLOYEE and CRS_DESCRIPTION from COURSE to get the desired output."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, COURSE.CRS_DESCRIPTION \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE;", "gold_sql": "SELECT T2.emp_fname ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code", "source_tables": ["course", "employee", "class"]}
{"sample_id": 3312, "db_id": "college_1", "question": "What are the first names of all teachers who have taught a course and the corresponding descriptions?", "rationale": ["Identify the relevant tables: EMPLOYEE (for teacher names), PROFESSOR (to link employees to their teaching roles), CLASS (to find which classes they taught), and COURSE (to get course descriptions).", "Join the EMPLOYEE table with the PROFESSOR table on EMP_NUM to get the first names of the professors.", "Join the PROFESSOR table with the CLASS table on EMP_NUM to find the classes taught by each professor.", "Join the CLASS table with the COURSE table on CRS_CODE to get the descriptions of the courses associated with those classes.", "Select the EMP_FNAME from EMPLOYEE and CRS_DESCRIPTION from COURSE to get the desired output."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, COURSE.CRS_DESCRIPTION \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE;", "gold_sql": "SELECT T2.emp_fname ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code", "source_tables": ["course", "employee", "class"]}
{"sample_id": 3313, "db_id": "college_1", "question": "Find the first names and offices of all instructors who have taught some course and also find the course description.", "rationale": ["Identify the required fields: first names of instructors (EMP_FNAME), their office locations (PROF_OFFICE), and course descriptions (CRS_DESCRIPTION).", "Determine the tables needed: EMPLOYEE for instructor names, PROFESSOR for office locations, CLASS to link professors to courses, and COURSE for course descriptions.", "Establish relationships between the tables using JOINs: EMPLOYEE to PROFESSOR on EMP_NUM, PROFESSOR to CLASS on EMP_NUM, and CLASS to COURSE on CRS_CODE.", "Construct the SQL SELECT statement to retrieve the desired fields from the joined tables."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE, COURSE.CRS_DESCRIPTION \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE;", "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num", "source_tables": ["course", "employee", "professor", "class"]}
{"sample_id": 3314, "db_id": "college_1", "question": "What are the first names, office locations of all lecturers who have taught some course?", "rationale": ["Identify the relevant tables: EMPLOYEE and PROFESSOR for lecturer details, and CLASS to ensure they have taught a course.", "Select the first names and office locations of the professors, which are in the EMPLOYEE and PROFESSOR tables respectively.", "Join the EMPLOYEE table with the PROFESSOR table on the EMP_NUM to get the first names of the professors.", "Join the PROFESSOR table with the CLASS table on the EMP_NUM to ensure that we only get professors who have taught a course.", "Use GROUP BY to avoid duplicate entries for professors who may have taught multiple classes."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nGROUP BY EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE;", "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num", "source_tables": ["course", "employee", "professor", "class"]}
{"sample_id": 3315, "db_id": "college_1", "question": "Find the first names and offices of all instructors who have taught some course and the course description and the department name.", "rationale": ["Identify the required fields: first names of instructors, their office locations, course descriptions, and department names.", "The instructors are represented in the PROFESSOR table, which links to the EMPLOYEE table for their first names and office locations.", "The COURSE table contains course descriptions and is linked to the DEPARTMENT table for department names.", "The CLASS table connects courses to professors, indicating which instructors have taught which courses.", "Use JOIN operations to connect these tables based on their foreign key relationships: EMPLOYEE to PROFESSOR, PROFESSOR to DEPARTMENT, and COURSE to CLASS.", "Select the distinct combinations of the required fields to avoid duplicates, as multiple instructors may teach the same course."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE, COURSE.CRS_DESCRIPTION, DEPARTMENT.DEPT_NAME \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nJOIN COURSE ON PROFESSOR.DEPT_CODE = COURSE.DEPT_CODE \nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE \nGROUP BY EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE, COURSE.CRS_DESCRIPTION, DEPARTMENT.DEPT_NAME;", "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code", "source_tables": ["course", "department", "professor", "class", "employee"]}
{"sample_id": 3316, "db_id": "college_1", "question": "What are the first names, office locations, and departments of all instructors, and also what are the descriptions of the courses they teach?", "rationale": ["Identify the required fields: first names of instructors, office locations, department names, and course descriptions.", "The first names of instructors are in the EMPLOYEE table under EMP_FNAME.", "The office locations of instructors are in the PROFESSOR table under PROF_OFFICE.", "The department names are in the DEPARTMENT table under DEPT_NAME.", "The course descriptions are in the COURSE table under CRS_DESCRIPTION.", "To get this information, we need to join multiple tables: EMPLOYEE, PROFESSOR, DEPARTMENT, CLASS, and COURSE.", "Join EMPLOYEE with PROFESSOR on EMP_NUM to get the instructors' details.", "Join PROFESSOR with DEPARTMENT on DEPT_CODE to get the department names.", "Join CLASS with PROFESSOR on PROF_NUM to link classes taught by instructors.", "Join CLASS with COURSE on CRS_CODE to get the course descriptions.", "Select the required fields from the resulting joined tables."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE, DEPARTMENT.DEPT_NAME, COURSE.CRS_DESCRIPTION \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE;", "gold_sql": "SELECT T2.emp_fname ,  T4.prof_office ,  T3.crs_description ,  T5.dept_name FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN professor AS T4 ON T2.emp_num  =  T4.emp_num JOIN department AS T5 ON T4.dept_code  =  T5.dept_code", "source_tables": ["course", "department", "professor", "class", "employee"]}
{"sample_id": 3317, "db_id": "college_1", "question": "Find names of all students who took some course and the course description.", "rationale": ["Identify the tables needed: STUDENT for student names, ENROLL for enrollment records, CLASS for class information, and COURSE for course descriptions.", "Join the STUDENT table with the ENROLL table on the student number (STU_NUM) to get the courses they are enrolled in.", "Join the ENROLL table with the CLASS table on the class code (CLASS_CODE) to link enrollments to specific classes.", "Join the CLASS table with the COURSE table on the course code (CRS_CODE) to get the course descriptions associated with each class.", "Select the first name (STU_FNAME) and last name (STU_LNAME) of the students along with the course description (CRS_DESCRIPTION) from the resulting joined tables."], "pred_sql": "SELECT STUDENT.STU_FNAME, STUDENT.STU_LNAME, COURSE.CRS_DESCRIPTION \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE;", "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname ,  T4.crs_description FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code", "source_tables": ["enroll", "course", "class", "student"]}
{"sample_id": 3318, "db_id": "college_1", "question": "What are the names of all students who took a class and the corresponding course descriptions?", "rationale": ["Identify the tables needed: STUDENT for student names, ENROLL for enrollment records, CLASS for class information, and COURSE for course descriptions.", "Determine the relationships: STUDENT is linked to ENROLL through STU_NUM, ENROLL is linked to CLASS through CLASS_CODE, and CLASS is linked to COURSE through CRS_CODE.", "Select the required fields: We need the first name and last name of the students (STU_FNAME, STU_LNAME) and the course description (CRS_DESCRIPTION).", "Construct the SQL query using JOINs to connect the tables based on the identified relationships."], "pred_sql": "SELECT STUDENT.STU_FNAME, STUDENT.STU_LNAME, COURSE.CRS_DESCRIPTION \nFROM STUDENT \nJOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM \nJOIN CLASS ON ENROLL.CLASS_CODE = CLASS.CLASS_CODE \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE;", "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname ,  T4.crs_description FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code JOIN course AS T4 ON T3.crs_code  =  T4.crs_code", "source_tables": ["enroll", "course", "class", "student"]}
{"sample_id": 3319, "db_id": "college_1", "question": "Find names of all students who took some course and got A or C.", "rationale": ["Identify the tables needed: STUDENT for student names and ENROLL for enrollment details including grades.", "Join the STUDENT table with the ENROLL table on the student number (STU_NUM) to link students with their grades.", "Filter the results to include only those students who received grades 'A' or 'C' by using a WHERE clause with the IN operator.", "Select the distinct first and last names of the students to avoid duplicates in the result."], "pred_sql": "SELECT DISTINCT S.STU_FNAME, S.STU_LNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nWHERE E.ENROLL_GRADE IN ('A', 'C');", "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"]}
{"sample_id": 3320, "db_id": "college_1", "question": "What are the names of all students taking a course who received an A or C?", "rationale": ["Identify the tables needed: STUDENT for student names, ENROLL for enrollment details, and CLASS for class information.", "We need to join the STUDENT table with the ENROLL table on the student number (STU_NUM) to get the grades for each student.", "Next, join the ENROLL table with the CLASS table on the class code (CLASS_CODE) to access the course information.", "Filter the results to include only those students who received an 'A' or 'C' by using a WHERE clause with the IN operator.", "Select the first name (STU_FNAME) and last name (STU_LNAME) of the students who meet the criteria."], "pred_sql": "SELECT S.STU_FNAME, S.STU_LNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nJOIN CLASS C ON E.CLASS_CODE = C.CLASS_CODE \nWHERE E.ENROLL_GRADE IN ('A', 'C');", "gold_sql": "SELECT T1.stu_fname ,  T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'C' OR T2.enroll_grade  =  'A'", "source_tables": ["enroll", "student"]}
{"sample_id": 3321, "db_id": "college_1", "question": "Find the first names of all professors in the Accounting department who is teaching some course and the class room.", "rationale": ["Identify the tables needed: PROFESSOR, EMPLOYEE, DEPARTMENT, and CLASS.", "We need to find professors, so we start with the PROFESSOR table.", "Join the EMPLOYEE table to get the first names of the professors using the EMP_NUM foreign key.", "Join the DEPARTMENT table to filter professors by the Accounting department using the DEPT_CODE foreign key.", "Join the CLASS table to ensure that we only get professors who are teaching some course using the PROF_NUM foreign key.", "Select the EMP_FNAME from the EMPLOYEE table and CLASS_ROOM from the CLASS table.", "Add a WHERE clause to filter results to only include professors from the Accounting department."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, CLASS.CLASS_ROOM \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE DEPARTMENT.DEPT_NAME = 'Accounting';", "gold_sql": "SELECT T2.emp_fname ,  T1.class_room FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Accounting'", "source_tables": ["employee", "professor", "class", "department"]}
{"sample_id": 3322, "db_id": "college_1", "question": "What are the first names of all Accounting professors who teach and what are the classrooms of the courses they teach?", "rationale": ["Identify the relevant tables: EMPLOYEE, PROFESSOR, DEPARTMENT, CLASS, and COURSE.", "We need to get the first names of professors, which are in the EMPLOYEE table, and the classrooms from the CLASS table.", "Join the EMPLOYEE table with the PROFESSOR table on EMP_NUM to get the professors' details.", "Join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE to filter for Accounting professors.", "Join the CLASS table to get the classrooms where these professors teach.", "Join the COURSE table to ensure we are linking the correct courses to the classes.", "Filter the results to only include professors from the Accounting department."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, CLASS.CLASS_ROOM \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nJOIN COURSE ON CLASS.CRS_CODE = COURSE.CRS_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'Accounting';", "gold_sql": "SELECT T2.emp_fname ,  T1.class_room FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Accounting'", "source_tables": ["employee", "professor", "class", "department"]}
{"sample_id": 3323, "db_id": "college_1", "question": "Find the first names and degree of all professors who are teaching some class in Computer Info. Systems department.", "rationale": ["Identify the tables needed: PROFESSOR for professor details, DEPARTMENT for department details, and CLASS for class details.", "We need to select the first names and degrees of professors, so we will select EMPLOYEE.EMP_FNAME and PROFESSOR.PROF_HIGH_DEGREE.", "To find professors teaching classes in the Computer Info. Systems department, we need to join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE.", "We also need to join the CLASS table to ensure that the professors are teaching classes.", "Finally, we filter the results to include only those professors who are in the 'Computer Info. Systems' department."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_HIGH_DEGREE \nFROM PROFESSOR \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nWHERE DEPARTMENT.DEPT_NAME = 'Computer Info. Systems';", "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"]}
{"sample_id": 3324, "db_id": "college_1", "question": "What are the different first names and highest degree attained for professors teaching in the Computer Information Systems department?", "rationale": ["Identify the relevant tables: PROFESSOR, DEPARTMENT, and EMPLOYEE are needed to get the first names and highest degrees of professors.", "Determine the columns to select: We need the first names (EMP_FNAME) from the EMPLOYEE table and the highest degree (PROF_HIGH_DEGREE) from the PROFESSOR table.", "Establish the relationships: PROFESSOR is linked to DEPARTMENT through DEPT_CODE, and PROFESSOR is linked to EMPLOYEE through EMP_NUM.", "Filter the results: We need to filter the results to only include professors from the 'Computer Information Systems' department by using the DEPT_NAME column in the DEPARTMENT table."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_HIGH_DEGREE \nFROM PROFESSOR \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nWHERE DEPARTMENT.DEPT_NAME = 'Computer Information Systems';", "gold_sql": "SELECT DISTINCT T2.emp_fname ,  T3.prof_high_degree FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num JOIN professor AS T3 ON T2.emp_num  =  T3.emp_num JOIN department AS T4 ON T4.dept_code  =  T3.dept_code WHERE T4.dept_name  =  'Computer Info. Systems'", "source_tables": ["employee", "professor", "class", "department"]}
{"sample_id": 3325, "db_id": "college_1", "question": "What is the last name of the student who got a grade A in the class with code 10018.", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed to find the student's last name and their grade in a specific class.", "Determine the relationship between the tables: STUDENT is linked to ENROLL through the STU_NUM column.", "Specify the conditions: We need to filter for the class with code '10018' and the grade 'A'.", "Construct the SQL query: Use a SELECT statement to retrieve the last name from the STUDENT table, joining it with the ENROLL table based on the student number, and applying the necessary WHERE conditions."], "pred_sql": "SELECT STUDENT.STU_LNAME FROM STUDENT JOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM WHERE ENROLL.CLASS_CODE = '10018' AND ENROLL.ENROLL_GRADE = 'A';", "gold_sql": "SELECT T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'A' AND T2.class_code  =  10018", "source_tables": ["enroll", "student"]}
{"sample_id": 3326, "db_id": "college_1", "question": "What is the last name of the student who received an A in the class with the code 10018?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed to find the student's last name based on their enrollment and grades.", "Determine the relationship between the tables: STUDENT is linked to ENROLL through the STU_NUM column.", "Specify the conditions: We need to filter for the class code '10018' and the grade 'A'.", "Construct the SQL query: Use a SELECT statement to retrieve the last name from the STUDENT table, joining it with the ENROLL table based on the student number, and applying the necessary filters."], "pred_sql": "SELECT STUDENT.STU_LNAME FROM STUDENT JOIN ENROLL ON STUDENT.STU_NUM = ENROLL.STU_NUM WHERE ENROLL.CLASS_CODE = '10018' AND ENROLL.ENROLL_GRADE = 'A';", "gold_sql": "SELECT T1.stu_lname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num WHERE T2.enroll_grade  =  'A' AND T2.class_code  =  10018", "source_tables": ["enroll", "student"]}
{"sample_id": 3327, "db_id": "college_1", "question": "Find the first name and office of history professor who did not get a Ph.D. degree.", "rationale": ["Identify the relevant tables: PROFESSOR and EMPLOYEE, since we need the first name and office of the professor.", "We need to join the PROFESSOR table with the EMPLOYEE table to get the first name of the professor.", "Filter the results to only include professors who do not have a Ph.D. degree by checking the PROF_HIGH_DEGREE column.", "Additionally, we need to ensure that the professor belongs to the History department, which requires a subquery to find the DEPT_CODE for the History department from the DEPARTMENT table."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nWHERE PROFESSOR.PROF_HIGH_DEGREE != 'Ph.D.' \nAND PROFESSOR.DEPT_CODE IN (SELECT DEPT_CODE FROM DEPARTMENT WHERE DEPT_NAME = 'History');", "gold_sql": "SELECT T2.emp_fname ,  T1.prof_office FROM professor AS T1 JOIN employee AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T1.dept_code  =  T3.dept_code WHERE T3.dept_name  =  'History' AND T1.prof_high_degree != 'Ph.D.'", "source_tables": ["employee", "professor", "department"]}
{"sample_id": 3328, "db_id": "college_1", "question": "What are the first names and offices of history professors who don't have Ph.D.s?", "rationale": ["Identify the relevant tables: PROFESSOR for professor details, EMPLOYEE for employee details, and DEPARTMENT for department details.", "We need to select the first names and office locations of professors, so we will select EMPLOYEE.EMP_FNAME and PROFESSOR.PROF_OFFICE.", "To find history professors, we will join the PROFESSOR table with the DEPARTMENT table on DEPT_CODE and filter for DEPARTMENT.DEPT_NAME = 'History'.", "We also need to filter out professors who have a Ph.D., so we will add a condition to check that PROFESSOR.PROF_HIGH_DEGREE is not equal to 'Ph.D.'.", "Finally, we will construct the SQL query using the selected columns and the necessary joins and conditions."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME, PROFESSOR.PROF_OFFICE \nFROM PROFESSOR \nJOIN EMPLOYEE ON PROFESSOR.EMP_NUM = EMPLOYEE.EMP_NUM \nJOIN DEPARTMENT ON PROFESSOR.DEPT_CODE = DEPARTMENT.DEPT_CODE \nWHERE DEPARTMENT.DEPT_NAME = 'History' AND PROFESSOR.PROF_HIGH_DEGREE != 'Ph.D.';", "gold_sql": "SELECT T2.emp_fname ,  T1.prof_office FROM professor AS T1 JOIN employee AS T2 ON T1.emp_num  =  T2.emp_num JOIN department AS T3 ON T1.dept_code  =  T3.dept_code WHERE T3.dept_name  =  'History' AND T1.prof_high_degree != 'Ph.D.'", "source_tables": ["employee", "professor", "department"]}
{"sample_id": 3329, "db_id": "college_1", "question": "Find the first names of professors who are teaching more than one class.", "rationale": ["We need to find professors who are teaching more than one class.", "To do this, we will join the EMPLOYEE table with the PROFESSOR table on the EMP_NUM column, as this will give us access to the first names of the professors.", "Next, we will join the CLASS table to the PROFESSOR table on the PROF_NUM column to link professors to the classes they are teaching.", "We will group the results by the EMP_NUM to aggregate the classes taught by each professor.", "Finally, we will use the HAVING clause to filter the groups to only include those professors who are teaching more than one class, which is indicated by a count of CLASS_CODE greater than 1."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME\nFROM EMPLOYEE\nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM\nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM\nGROUP BY EMPLOYEE.EMP_NUM\nHAVING COUNT(CLASS.CLASS_CODE) > 1;", "gold_sql": "SELECT T2.emp_fname FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num GROUP BY T1.prof_num HAVING count(*)  >  1", "source_tables": ["employee", "class"]}
{"sample_id": 3330, "db_id": "college_1", "question": "What are the first names of all professors who teach more than one class?", "rationale": ["We need to find the first names of professors who teach more than one class.", "To do this, we will join the EMPLOYEE table with the PROFESSOR table on the EMP_NUM field to get the professors' details.", "Next, we will join the CLASS table to the PROFESSOR table on the PROF_NUM field to get the classes taught by each professor.", "We will group the results by the professor's EMP_NUM to count the number of classes each professor teaches.", "Finally, we will use the HAVING clause to filter the groups to only include those professors who teach more than one class."], "pred_sql": "SELECT EMPLOYEE.EMP_FNAME \nFROM EMPLOYEE \nJOIN PROFESSOR ON EMPLOYEE.EMP_NUM = PROFESSOR.EMP_NUM \nJOIN CLASS ON PROFESSOR.EMP_NUM = CLASS.PROF_NUM \nGROUP BY EMPLOYEE.EMP_NUM \nHAVING COUNT(CLASS.CLASS_CODE) > 1;", "gold_sql": "SELECT T2.emp_fname FROM CLASS AS T1 JOIN employee AS T2 ON T1.prof_num  =  T2.emp_num GROUP BY T1.prof_num HAVING count(*)  >  1", "source_tables": ["employee", "class"]}
{"sample_id": 3331, "db_id": "college_1", "question": "Find the first names of students who took exactly one class.", "rationale": ["We need to find students who took exactly one class, so we will focus on the STUDENT and ENROLL tables.", "We will join the STUDENT table with the ENROLL table on the student number (STU_NUM) to link students with their enrolled classes.", "Next, we will group the results by the student number (STU_NUM) to aggregate the data for each student.", "To filter for students who took exactly one class, we will use the HAVING clause with COUNT(E.CLASS_CODE) = 1, which counts the number of classes each student is enrolled in.", "Finally, we will select the first names of these students from the STUDENT table."], "pred_sql": "SELECT S.STU_FNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nGROUP BY S.STU_NUM \nHAVING COUNT(E.CLASS_CODE) = 1;", "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num GROUP BY T2.stu_num HAVING count(*)  =  1", "source_tables": ["enroll", "student"]}
{"sample_id": 3332, "db_id": "college_1", "question": "What are the first names of student who only took one course?", "rationale": ["Identify the relevant tables: STUDENT and ENROLL are needed to find students and their enrolled courses.", "Join the STUDENT table with the ENROLL table on the student number (STU_NUM) to link students with their courses.", "Group the results by student number (STU_NUM) to aggregate the courses taken by each student.", "Use the HAVING clause to filter the groups to only those students who have taken exactly one course (COUNT(E.CLASS_CODE) = 1).", "Select the first names of the students (S.STU_FNAME) from the filtered results."], "pred_sql": "SELECT S.STU_FNAME \nFROM STUDENT S \nJOIN ENROLL E ON S.STU_NUM = E.STU_NUM \nGROUP BY S.STU_NUM \nHAVING COUNT(E.CLASS_CODE) = 1;", "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num GROUP BY T2.stu_num HAVING count(*)  =  1", "source_tables": ["enroll", "student"]}
{"sample_id": 3333, "db_id": "college_1", "question": "Find the name of department that offers the class whose description has the word \"Statistics\".", "rationale": ["Identify the relevant tables: We need to find the department name, which is in the DEPARTMENT table, and we need to relate it to the class description, which is in the COURSE table, and the CLASS table.", "Determine the relationships: The DEPARTMENT table is related to the COURSE table through DEPT_CODE, and the COURSE table is related to the CLASS table through CRS_CODE.", "Construct the SQL query: We will select the DEPT_NAME from the DEPARTMENT table, joining it with the COURSE table on DEPT_CODE, and then joining with the CLASS table on CRS_CODE.", "Add the condition: We need to filter the results where the COURSE description contains the word 'Statistics', using the LIKE operator."], "pred_sql": "SELECT DEPARTMENT.DEPT_NAME \nFROM DEPARTMENT \nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE \nJOIN CLASS ON COURSE.CRS_CODE = CLASS.CRS_CODE \nWHERE COURSE.CRS_DESCRIPTION LIKE '%Statistics%';", "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"]}
{"sample_id": 3334, "db_id": "college_1", "question": "What is the name of the department that offers a course that has a description including the word \"Statistics\"?", "rationale": ["Identify the relevant tables: We need to find the department name, which is in the DEPARTMENT table, and we need to check the course description, which is in the COURSE table.", "Determine the relationship between the tables: The DEPARTMENT table is related to the COURSE table through the DEPT_CODE column.", "Formulate the SQL query: We will select the DEPT_NAME from the DEPARTMENT table and join it with the COURSE table on the DEPT_CODE. We will filter the results to include only those courses whose description contains the word 'Statistics'.", "Use the LIKE operator to search for the word 'Statistics' in the CRS_DESCRIPTION column of the COURSE table."], "pred_sql": "SELECT DISTINCT DEPARTMENT.DEPT_NAME \nFROM DEPARTMENT \nJOIN COURSE ON DEPARTMENT.DEPT_CODE = COURSE.DEPT_CODE \nWHERE COURSE.CRS_DESCRIPTION LIKE '%Statistics%';", "gold_sql": "SELECT T2.dept_name FROM course AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T1.crs_description LIKE '%Statistics%'", "source_tables": ["course", "department"]}
{"sample_id": 3335, "db_id": "college_1", "question": "What is the first name of the student whose last name starting with the letter S and is taking ACCT-211 class?", "rationale": ["Identify the relevant tables: STUDENT, ENROLL, and CLASS are needed to find the student's first name based on the class they are enrolled in.", "The STUDENT table contains the first name (STU_FNAME) and last name (STU_LNAME) of the students.", "The ENROLL table links students to the classes they are taking through STU_NUM and CLASS_CODE.", "The CLASS table contains the class information, including the CRS_CODE for the specific class (ACCT-211).", "To find students whose last name starts with 'S', we will use a LIKE clause with 'S%'.", "We will join the STUDENT table with the ENROLL table on STU_NUM, and then join the ENROLL table with the CLASS table on CLASS_CODE.", "Finally, we will filter the results to only include students taking the ACCT-211 class and whose last name starts with 'S'."], "pred_sql": "SELECT STU_FNAME FROM STUDENT S JOIN ENROLL E ON S.STU_NUM = E.STU_NUM JOIN CLASS C ON E.CLASS_CODE = C.CLASS_CODE WHERE S.STU_LNAME LIKE 'S%' AND C.CRS_CODE = 'ACCT-211';", "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code WHERE T3.crs_code  =  'ACCT-211' AND T1.stu_lname LIKE 'S%'", "source_tables": ["enroll", "class", "student"]}
{"sample_id": 3336, "db_id": "college_1", "question": "What is the first name of the student whose last name starts with the letter S and is taking ACCT-211?", "rationale": ["Identify the relevant tables: STUDENT, ENROLL, and CLASS are needed to find the student's first name based on the last name and course code.", "The STUDENT table contains the first name (STU_FNAME) and last name (STU_LNAME) of the students.", "The ENROLL table links students to classes they are enrolled in, using STU_NUM and CLASS_CODE.", "The CLASS table contains the course code (CRS_CODE) for each class.", "To find students whose last name starts with 'S', we will use a LIKE clause with 'S%'.", "We need to filter the results to only include students enrolled in the course with the code 'ACCT-211'.", "Join the STUDENT table with the ENROLL table on STU_NUM, and then join the ENROLL table with the CLASS table on CLASS_CODE to access the course information.", "Construct the SQL query to select the first name of the student based on the specified conditions."], "pred_sql": "SELECT STU_FNAME FROM STUDENT S JOIN ENROLL E ON S.STU_NUM = E.STU_NUM JOIN CLASS C ON E.CLASS_CODE = C.CLASS_CODE WHERE S.STU_LNAME LIKE 'S%' AND C.CRS_CODE = 'ACCT-211';", "gold_sql": "SELECT T1.stu_fname FROM student AS T1 JOIN enroll AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T2.class_code  =  T3.class_code WHERE T3.crs_code  =  'ACCT-211' AND T1.stu_lname LIKE 'S%'", "source_tables": ["enroll", "class", "student"]}
{"sample_id": 3337, "db_id": "sports_competition", "question": "How many clubs are there?", "rationale": ["Identify the requirement: We need to find out how many clubs exist in the database.", "Determine the relevant table: The 'club' table contains the information about clubs.", "Use the COUNT() function to count the number of entries in the 'club' table.", "Construct the SQL query to select the count of clubs from the 'club' table."], "pred_sql": "SELECT COUNT(*) AS total_clubs FROM club;", "gold_sql": "SELECT count(*) FROM club", "source_tables": ["club"]}
{"sample_id": 3338, "db_id": "sports_competition", "question": "What is the total number of clubs?", "rationale": ["Identify the requirement: We need to find the total number of clubs.", "Determine the appropriate table: The 'club' table contains the information about clubs.", "Use the COUNT() function to count the number of entries in the 'club' table.", "Construct the SQL query to select the count from the 'club' table."], "pred_sql": "SELECT COUNT(*) AS total_clubs FROM club;", "gold_sql": "SELECT count(*) FROM club", "source_tables": ["club"]}
{"sample_id": 3339, "db_id": "sports_competition", "question": "List the distinct region of clubs in ascending alphabetical order.", "rationale": ["Identify the table that contains the region information, which is the 'club' table.", "Use the SELECT statement to retrieve the 'Region' column from the 'club' table.", "To ensure that only unique regions are listed, use the DISTINCT keyword.", "To sort the results in ascending alphabetical order, use the ORDER BY clause with 'Region' and specify ASC for ascending order."], "pred_sql": "SELECT DISTINCT Region FROM club ORDER BY Region ASC;", "gold_sql": "SELECT DISTINCT Region FROM club ORDER BY Region ASC", "source_tables": ["club"]}
{"sample_id": 3340, "db_id": "sports_competition", "question": "What are the different regions of clubs in ascending alphabetical order?", "rationale": ["Identify the table that contains the information about clubs and their regions, which is the 'club' table.", "To get the different regions, we need to select the 'Region' column from the 'club' table.", "Since we want only unique regions, we will use the DISTINCT keyword.", "Finally, to sort the results in ascending alphabetical order, we will use the ORDER BY clause with 'Region' and specify ASC for ascending order."], "pred_sql": "SELECT DISTINCT Region FROM club ORDER BY Region ASC;", "gold_sql": "SELECT DISTINCT Region FROM club ORDER BY Region ASC", "source_tables": ["club"]}
{"sample_id": 3341, "db_id": "sports_competition", "question": "What is the average number of gold medals for clubs?", "rationale": ["Identify the relevant table: The 'club_rank' table contains the 'Gold' column which is needed to calculate the average number of gold medals.", "Use the AVG() function: To find the average, we will use the AVG() function on the 'Gold' column.", "Select the average: We will select the average value and give it an alias 'Average_Gold_Medals' for clarity.", "Construct the SQL query: Combine the above steps into a complete SQL query that selects the average number of gold medals from the 'club_rank' table."], "pred_sql": "SELECT AVG(Gold) AS Average_Gold_Medals FROM club_rank;", "gold_sql": "SELECT avg(Gold) FROM club_rank", "source_tables": ["club_rank"]}
{"sample_id": 3342, "db_id": "sports_competition", "question": "What is the average number of gold medals for a club?", "rationale": ["Identify the relevant table: The 'club_rank' table contains the information about the number of gold medals won by clubs.", "Determine the required calculation: We need to calculate the average number of gold medals.", "Use the AVG() function: This function will help us compute the average of the 'Gold' column in the 'club_rank' table.", "Construct the SQL query: The query will select the average of the 'Gold' column and label it as 'Average_Gold_Medals'."], "pred_sql": "SELECT AVG(Gold) AS Average_Gold_Medals FROM club_rank;", "gold_sql": "SELECT avg(Gold) FROM club_rank", "source_tables": ["club_rank"]}
{"sample_id": 3343, "db_id": "sports_competition", "question": "What are the types and countries of competitions?", "rationale": ["Identify the relevant table: The query is asking for information about competitions, which is found in the 'competition' table.", "Determine the required columns: The user wants to know the types and countries of competitions, so we need to select 'Competition_type' and 'Country'.", "Use DISTINCT to avoid duplicate entries: Since the user may want unique combinations of competition types and countries, we will use the DISTINCT keyword.", "Construct the SQL query: Combine the selected columns and the table name into a complete SQL query."], "pred_sql": "SELECT DISTINCT Competition_type, Country FROM competition;", "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"]}
{"sample_id": 3344, "db_id": "sports_competition", "question": "What are the types of every competition and in which countries are they located?", "rationale": ["Identify the relevant table: The 'competition' table contains the information about competition types and their respective countries.", "Select the columns needed: We need 'Competition_type' and 'Country' from the 'competition' table.", "Use DISTINCT to ensure that we get unique combinations of competition types and countries.", "Construct the SQL query to select the distinct competition types and their countries from the competition table."], "pred_sql": "SELECT DISTINCT Competition_type, Country FROM competition;", "gold_sql": "SELECT Competition_type ,  Country FROM competition", "source_tables": ["competition"]}
{"sample_id": 3345, "db_id": "sports_competition", "question": "What are the distinct years in which the competitions type is not \"Tournament\"?", "rationale": ["Identify the table that contains the relevant data: the 'competition' table.", "Determine the column that holds the year of the competition: the 'Year' column.", "Identify the condition to filter the results: the competition type should not be 'Tournament'.", "Use the DISTINCT keyword to ensure that only unique years are returned.", "Construct the SQL query to select the distinct years from the 'competition' table where the competition type is not 'Tournament'."], "pred_sql": "SELECT DISTINCT Year FROM competition WHERE Competition_type != 'Tournament';", "gold_sql": "SELECT DISTINCT YEAR FROM competition WHERE Competition_type != 'Tournament'", "source_tables": ["competition"]}
{"sample_id": 3346, "db_id": "sports_competition", "question": "What are the different years for all competitions that are not of type equal to tournament?", "rationale": ["Identify the table that contains the competition data, which is the 'competition' table.", "Determine the relevant column that contains the year of the competition, which is 'Year'.", "Identify the condition that needs to be applied, which is to exclude competitions of type 'tournament'.", "Use the DISTINCT keyword to ensure that only unique years are returned.", "Construct the SQL query to select the distinct years from the 'competition' table where the 'Competition_type' is not equal to 'tournament'."], "pred_sql": "SELECT DISTINCT Year FROM competition WHERE Competition_type != 'tournament';", "gold_sql": "SELECT DISTINCT YEAR FROM competition WHERE Competition_type != 'Tournament'", "source_tables": ["competition"]}
{"sample_id": 3347, "db_id": "sports_competition", "question": "What are the maximum and minimum number of silver medals for clubs.", "rationale": ["Identify the relevant table: The 'club_rank' table contains the data about the number of silver medals won by clubs.", "Determine the required calculations: We need to find the maximum and minimum number of silver medals.", "Use aggregate functions: Use the MAX() function to find the maximum silver medals and the MIN() function to find the minimum silver medals.", "Construct the SQL query: Combine the aggregate functions in a SELECT statement from the 'club_rank' table."], "pred_sql": "SELECT MAX(Silver) AS Max_Silver, MIN(Silver) AS Min_Silver FROM club_rank;", "gold_sql": "SELECT max(Silver) ,  min(Silver) FROM club_rank", "source_tables": ["club_rank"]}
{"sample_id": 3348, "db_id": "sports_competition", "question": "What are the maximum and minimum number of silver medals for all the clubs?", "rationale": ["Identify the relevant table: The 'club_rank' table contains the data about the number of silver medals won by clubs.", "Determine the required calculations: We need to find the maximum and minimum number of silver medals.", "Use the SQL aggregate functions: Use MAX() to find the maximum silver medals and MIN() to find the minimum silver medals.", "Construct the SQL query: The query will select the maximum and minimum silver medal counts from the 'club_rank' table."], "pred_sql": "SELECT MAX(Silver) AS Max_Silver, MIN(Silver) AS Min_Silver FROM club_rank;", "gold_sql": "SELECT max(Silver) ,  min(Silver) FROM club_rank", "source_tables": ["club_rank"]}
{"sample_id": 3349, "db_id": "sports_competition", "question": "How many clubs have total medals less than 10?", "rationale": ["Identify the relevant table: The 'club_rank' table contains the 'Total' column which represents the total number of medals won by each club.", "Formulate the condition: We need to count the clubs where the total medals are less than 10.", "Use the COUNT function: To get the number of clubs meeting the condition, we will use the COUNT(*) function.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter clubs with total medals less than 10."], "pred_sql": "SELECT COUNT(*) AS club_count FROM club_rank WHERE Total < 10;", "gold_sql": "SELECT count(*) FROM club_rank WHERE Total  <  10", "source_tables": ["club_rank"]}
{"sample_id": 3350, "db_id": "sports_competition", "question": "What is the total number of clubs that have less than 10 medals in total?", "rationale": ["Identify the table that contains the total number of medals for each club, which is the 'club_rank' table.", "Determine the condition for filtering clubs, which is having less than 10 medals in total (Total < 10).", "Use the COUNT() function to count the number of clubs that meet this condition.", "Construct the SQL query to select the count of clubs from the 'club_rank' table where the total medals are less than 10."], "pred_sql": "SELECT COUNT(*) AS total_clubs FROM club_rank WHERE Total < 10;", "gold_sql": "SELECT count(*) FROM club_rank WHERE Total  <  10", "source_tables": ["club_rank"]}
{"sample_id": 3351, "db_id": "sports_competition", "question": "List all club names in ascending order of start year.", "rationale": ["Identify the table that contains the club names, which is the 'club' table.", "Determine the column that contains the club names, which is 'name'.", "Identify the column that contains the start year of the clubs, which is 'Start_year'.", "Construct the SQL query to select the 'name' column from the 'club' table.", "Add an ORDER BY clause to sort the results by 'Start_year' in ascending order."], "pred_sql": "SELECT name FROM club ORDER BY Start_year ASC;", "gold_sql": "SELECT name FROM club ORDER BY Start_year ASC", "source_tables": ["club"]}
{"sample_id": 3352, "db_id": "sports_competition", "question": "What are the names of all the clubs starting with the oldest?", "rationale": ["Identify the table that contains the club names, which is the 'club' table.", "Determine the column that holds the club names, which is 'name'.", "Identify the column that indicates the establishment year of the clubs, which is 'Start_year'.", "To get the clubs starting with the oldest, we need to order the results by 'Start_year' in ascending order.", "Construct the SQL query to select the 'name' from the 'club' table and order by 'Start_year' in ascending order."], "pred_sql": "SELECT name FROM club ORDER BY Start_year ASC;", "gold_sql": "SELECT name FROM club ORDER BY Start_year ASC", "source_tables": ["club"]}
{"sample_id": 3353, "db_id": "sports_competition", "question": "List all club names in descending alphabetical order.", "rationale": ["Identify the table that contains the club names, which is the 'club' table.", "Determine the column that holds the names of the clubs, which is 'name'.", "Specify that we want to select the 'name' column from the 'club' table.", "To list the names in descending alphabetical order, use the ORDER BY clause with DESC."], "pred_sql": "SELECT name FROM club ORDER BY name DESC;", "gold_sql": "SELECT name FROM club ORDER BY name DESC", "source_tables": ["club"]}
{"sample_id": 3354, "db_id": "sports_competition", "question": "What are the names of all the clubs ordered in descending alphabetical order?", "rationale": ["Identify the table that contains the club names, which is the 'club' table.", "Select the 'name' column from the 'club' table to get the names of the clubs.", "Use the ORDER BY clause to sort the results in descending order based on the club names."], "pred_sql": "SELECT name FROM club ORDER BY name DESC;", "gold_sql": "SELECT name FROM club ORDER BY name DESC", "source_tables": ["club"]}
{"sample_id": 3355, "db_id": "sports_competition", "question": "Please show the names and the players of clubs.", "rationale": ["Identify the tables needed: 'club' for club names and 'player' for player names.", "Determine the relationship between the tables: 'club' and 'player' are related through 'Club_ID'.", "Select the columns to display: 'club.name' for club names and 'player.name' for player names.", "Construct the SQL query using a JOIN to combine data from both tables based on the 'Club_ID' relationship."], "pred_sql": "SELECT club.name, player.name FROM club JOIN player ON club.Club_ID = player.Club_ID;", "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"]}
{"sample_id": 3356, "db_id": "sports_competition", "question": "What are the names and players of all the clubs?", "rationale": ["Identify the tables needed: 'club' for club names and 'player' for player names.", "Determine the relationship between the tables: 'player' has a foreign key 'Club_ID' that references 'club'.", "Use a JOIN operation to combine data from both tables based on the 'Club_ID'.", "Select the 'name' column from both 'club' and 'player' to get the desired output."], "pred_sql": "SELECT club.name, player.name FROM club JOIN player ON club.Club_ID = player.Club_ID;", "gold_sql": "SELECT T1.name ,  T2.Player_id FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "source_tables": ["club", "player"]}
{"sample_id": 3357, "db_id": "sports_competition", "question": "Show the names of clubs that have players with position \"Right Wing\".", "rationale": ["Identify the relevant tables: 'club' and 'player'.", "We need to retrieve the names of clubs, so we will select the 'name' column from the 'club' table.", "To find clubs with players in the position 'Right Wing', we need to join the 'club' table with the 'player' table on the 'Club_ID' column.", "Apply a filter to the results to only include players whose position is 'Right Wing'.", "Use DISTINCT to ensure that each club name is listed only once, even if multiple players from the same club are in the specified position."], "pred_sql": "SELECT DISTINCT club.name FROM club JOIN player ON club.Club_ID = player.Club_ID WHERE player.Position = 'Right Wing';", "gold_sql": "SELECT T1.name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID WHERE T2.Position  =  'Right Wing'", "source_tables": ["club", "player"]}
{"sample_id": 3358, "db_id": "sports_competition", "question": "What are the names of the clubs that have players in the position of \"Right Wing\"?", "rationale": ["Identify the relevant tables: We need to retrieve club names, so we will use the 'club' table. Since we are interested in players' positions, we will also use the 'player' table.", "Determine the relationship: The 'player' table has a foreign key 'Club_ID' that links to the 'club' table's 'Club_ID'. This means we can join these two tables on 'Club_ID'.", "Specify the condition: We need to filter the players based on their position, specifically those who play as 'Right Wing'.", "Select the required data: We want the names of the clubs, so we will select the 'name' column from the 'club' table. We also use DISTINCT to ensure we get unique club names in case multiple players from the same club are in the specified position."], "pred_sql": "SELECT DISTINCT c.name FROM club c JOIN player p ON c.Club_ID = p.Club_ID WHERE p.Position = 'Right Wing';", "gold_sql": "SELECT T1.name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID WHERE T2.Position  =  'Right Wing'", "source_tables": ["club", "player"]}
{"sample_id": 3359, "db_id": "sports_competition", "question": "What is the average points of players from club with name \"AIB\".", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine that we need to calculate the average points of players, so we will use the AVG() function on the 'Points' column.", "Since 'Points' is stored as text, we need to cast it to an integer for accurate calculations.", "We need to filter players based on the club name 'AIB'.", "To find the Club_ID for 'AIB', we will perform a subquery on the 'club' table to get the Club_ID where the name is 'AIB'.", "Combine these elements into a single SQL query that calculates the average points for players from the specified club."], "pred_sql": "SELECT AVG(CAST(Points AS INTEGER)) AS Average_Points FROM player WHERE Club_ID = (SELECT Club_ID FROM club WHERE name = 'AIB');", "gold_sql": "SELECT avg(T2.Points) FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID WHERE T1.name  =  'AIB'", "source_tables": ["club", "player"]}
{"sample_id": 3360, "db_id": "sports_competition", "question": "What is the average number of points for players from the \"AIB\" club?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the column that holds the points scored by players, which is 'Points'.", "To find the average points, we will use the AVG() function.", "We need to filter the players by their club, which requires us to find the Club_ID for the 'AIB' club from the 'club' table.", "Use a subquery to select the Club_ID from the 'club' table where the name is 'AIB'.", "Combine these elements to form the SQL query that calculates the average points for players from the 'AIB' club."], "pred_sql": "SELECT AVG(Points) AS Average_Points FROM player WHERE Club_ID = (SELECT Club_ID FROM club WHERE name = 'AIB');", "gold_sql": "SELECT avg(T2.Points) FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID WHERE T1.name  =  'AIB'", "source_tables": ["club", "player"]}
{"sample_id": 3361, "db_id": "sports_competition", "question": "List the position of players and the average number of points of players of each position.", "rationale": ["Identify the relevant table: The 'player' table contains the information about players, including their positions and points.", "Determine the required fields: We need the 'Position' of players and the average of 'Points' scored by players in each position.", "Use the AVG() function to calculate the average points for each position.", "Group the results by 'Position' to get the average points for each distinct position.", "Construct the SQL query using SELECT, AVG(), and GROUP BY clauses."], "pred_sql": "SELECT Position, AVG(Points) AS Average_Points FROM player GROUP BY Position;", "gold_sql": "SELECT POSITION ,  avg(Points) FROM player GROUP BY POSITION", "source_tables": ["player"]}
{"sample_id": 3362, "db_id": "sports_competition", "question": "For each position, what is the average number of points for players in that position?", "rationale": ["Identify the relevant table: The 'player' table contains the information about players and their points.", "Determine the required fields: We need the 'Position' of the players and the average of their 'Points'.", "Use the AVG() function to calculate the average points for each position.", "Group the results by 'Position' to get the average points for each distinct playing position."], "pred_sql": "SELECT Position, AVG(Points) AS Average_Points\nFROM player\nGROUP BY Position;", "gold_sql": "SELECT POSITION ,  avg(Points) FROM player GROUP BY POSITION", "source_tables": ["player"]}
{"sample_id": 3363, "db_id": "sports_competition", "question": "List the position of players with average number of points scored by players of that position bigger than 20.", "rationale": ["We need to list the positions of players.", "We also need to calculate the average number of points scored by players in each position.", "To do this, we will use the AVG() function on the Points column from the player table.", "We will group the results by the Position column to get the average points for each position.", "Finally, we will filter the results to only include positions where the average points are greater than 20 using the HAVING clause."], "pred_sql": "SELECT Position, AVG(Points) AS Average_Points\nFROM player\nGROUP BY Position\nHAVING AVG(Points) > 20;", "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"]}
{"sample_id": 3364, "db_id": "sports_competition", "question": "What are the positions of players whose average number of points scored by that position is larger than 20?", "rationale": ["Identify the relevant table: The 'player' table contains the information about players and their positions.", "Determine the required data: We need to find the positions of players where the average points scored is greater than 20.", "Use the AVG() function: To calculate the average points scored by players in each position, we will use the AVG() function on the 'Points' column.", "Group the results: We will group the results by 'Position' to calculate the average points for each position.", "Apply the HAVING clause: To filter the groups where the average points are greater than 20, we will use the HAVING clause."], "pred_sql": "SELECT Position FROM player GROUP BY Position HAVING AVG(Points) > 20;", "gold_sql": "SELECT POSITION FROM player GROUP BY name HAVING avg(Points)  >=  20", "source_tables": ["player"]}
{"sample_id": 3365, "db_id": "sports_competition", "question": "List the types of competition and the number of competitions of each type.", "rationale": ["Identify the relevant table: The 'competition' table contains the information about the types of competitions.", "Determine the columns needed: We need 'Competition_type' to list the types and we need to count the number of competitions for each type.", "Use the COUNT() function to count the number of competitions for each type.", "Group the results by 'Competition_type' to get the count for each distinct type.", "Construct the SQL query using SELECT, COUNT(), and GROUP BY clauses."], "pred_sql": "SELECT Competition_type, COUNT(*) AS Number_of_Competitions FROM competition GROUP BY Competition_type;", "gold_sql": "SELECT Competition_type ,  COUNT(*) FROM competition GROUP BY Competition_type", "source_tables": ["competition"]}
{"sample_id": 3366, "db_id": "sports_competition", "question": "What are the types of competition and number of competitions for that type?", "rationale": ["Identify the relevant table: The 'competition' table contains the 'Competition_type' and we need to count the number of competitions for each type.", "Use the COUNT() function to count the number of entries for each competition type.", "Group the results by 'Competition_type' to get the count for each distinct type of competition."], "pred_sql": "SELECT Competition_type, COUNT(*) AS Number_of_Competitions FROM competition GROUP BY Competition_type;", "gold_sql": "SELECT Competition_type ,  COUNT(*) FROM competition GROUP BY Competition_type", "source_tables": ["competition"]}
{"sample_id": 3367, "db_id": "sports_competition", "question": "List the most common type of competition.", "rationale": ["Identify the table that contains the competition types, which is the 'competition' table.", "We need to count the occurrences of each type of competition, so we will use the COUNT() function.", "Group the results by 'Competition_type' to aggregate the counts for each type.", "Order the results in descending order based on the count to find the most common type.", "Limit the results to 1 to get only the most common type of competition."], "pred_sql": "SELECT Competition_type, COUNT(*) as count FROM competition GROUP BY Competition_type ORDER BY count DESC LIMIT 1;", "gold_sql": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["competition"]}
{"sample_id": 3368, "db_id": "sports_competition", "question": "What is the most common competition type?", "rationale": ["Identify the relevant table: The query is asking about competition types, so we will use the 'competition' table.", "Determine the required information: We need to find the most common competition type, which involves counting occurrences of each type.", "Use the COUNT function: We will count the number of occurrences of each competition type.", "Group the results: We will group the results by 'Competition_type' to aggregate the counts for each type.", "Order the results: We will order the results in descending order based on the count to get the most common type at the top.", "Limit the results: We will limit the results to 1 to get only the most common competition type."], "pred_sql": "SELECT Competition_type, COUNT(*) as count FROM competition GROUP BY Competition_type ORDER BY count DESC LIMIT 1;", "gold_sql": "SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1", "source_tables": ["competition"]}
{"sample_id": 3369, "db_id": "sports_competition", "question": "List the types of competition that have at most five competitions of that type.", "rationale": ["Identify the relevant table: The query requires information about competitions, so we will use the 'competition' table.", "Select the column: We need to list the types of competitions, which corresponds to the 'Competition_type' column.", "Group the results: To count the number of competitions for each type, we will use the GROUP BY clause on 'Competition_type'.", "Filter the results: We want only those competition types that have at most five competitions, so we will use the HAVING clause with COUNT(Competition_ID) <= 5."], "pred_sql": "SELECT Competition_type FROM competition GROUP BY Competition_type HAVING COUNT(Competition_ID) <= 5;", "gold_sql": "SELECT Competition_type FROM competition GROUP BY Competition_type HAVING COUNT(*)  <=  5", "source_tables": ["competition"]}
{"sample_id": 3370, "db_id": "sports_competition", "question": "What are the types of competition that have most 5 competitions for that type?", "rationale": ["Identify the relevant table: The query is about competitions, so we will use the 'competition' table.", "Determine the required columns: We need the 'Competition_type' and a count of competitions for each type.", "Group the results: We will group the results by 'Competition_type' to count how many competitions exist for each type.", "Count the competitions: Use COUNT(*) to count the number of competitions for each type.", "Order the results: We will order the results in descending order based on the count of competitions to get the types with the most competitions first.", "Limit the results: Finally, we will limit the results to the top 5 competition types."], "pred_sql": "SELECT Competition_type, COUNT(*) as Competition_Count\nFROM competition\nGROUP BY Competition_type\nORDER BY Competition_Count DESC\nLIMIT 5;", "gold_sql": "SELECT Competition_type FROM competition GROUP BY Competition_type HAVING COUNT(*)  <=  5", "source_tables": ["competition"]}
{"sample_id": 3371, "db_id": "sports_competition", "question": "List the names of clubs that do not have any players.", "rationale": ["Identify the table that contains club information, which is the 'club' table.", "Identify the table that contains player information, which is the 'player' table.", "To find clubs without players, we need to select clubs whose Club_ID is not present in the player table.", "Use a subquery to select all Club_IDs from the player table.", "The main query will select the names of clubs from the club table where the Club_ID is not in the list of Club_IDs from the player table."], "pred_sql": "SELECT name FROM club WHERE Club_ID NOT IN (SELECT Club_ID FROM player);", "gold_sql": "SELECT name FROM CLub WHERE Club_ID NOT IN (SELECT Club_ID FROM player)", "source_tables": ["club", "player"]}
{"sample_id": 3372, "db_id": "sports_competition", "question": "What are the names of all clubs that do not have any players?", "rationale": ["Identify the table that contains club information, which is the 'club' table.", "Determine the relevant column for club names, which is 'name'.", "Identify the table that contains player information, which is the 'player' table.", "To find clubs without players, we need to check which Club_IDs in the 'club' table do not exist in the 'player' table.", "Use a subquery to select all Club_IDs from the 'player' table and use the NOT IN clause to filter out those clubs from the 'club' table."], "pred_sql": "SELECT name FROM club WHERE Club_ID NOT IN (SELECT Club_ID FROM player);", "gold_sql": "SELECT name FROM CLub WHERE Club_ID NOT IN (SELECT Club_ID FROM player)", "source_tables": ["club", "player"]}
{"sample_id": 3373, "db_id": "sports_competition", "question": "What are the positions with both players having more than 20 points and less than 10 points.", "rationale": ["Identify the requirement to find positions of players based on their points.", "We need to find pairs of players (p1 and p2) who share the same position.", "Filter p1 to have more than 20 points and p2 to have less than 10 points.", "Use a self-join on the player table to compare players with the same position.", "Select distinct positions to avoid duplicates in the result."], "pred_sql": "SELECT DISTINCT p1.Position\nFROM player p1\nJOIN player p2 ON p1.Position = p2.Position\nWHERE p1.Points > 20 AND p2.Points < 10;", "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"]}
{"sample_id": 3374, "db_id": "sports_competition", "question": "What are the positions of both players that have more than 20 20 points and less than 10 points?", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant column for player positions, which is 'Position'.", "Identify the column that contains the points scored by players, which is 'Points'.", "Formulate the condition to filter players based on their points: greater than 20 or less than 10.", "Construct the SQL SELECT statement to retrieve the 'Position' of players that meet the specified conditions."], "pred_sql": "SELECT Position FROM player WHERE Points > 20 OR Points < 10;", "gold_sql": "SELECT POSITION FROM player WHERE Points  >  20 INTERSECT SELECT POSITION FROM player WHERE Points  <  10", "source_tables": ["player"]}
{"sample_id": 3375, "db_id": "sports_competition", "question": "Show total points of all players.", "rationale": ["Identify the table that contains the required data: The 'player' table contains the 'Points' column which holds the total points scored by each player.", "Determine the operation needed: We need to calculate the total points of all players, which requires summing up the 'Points' column.", "Construct the SQL query: Use the SUM() function to aggregate the points from the 'Points' column in the 'player' table."], "pred_sql": "SELECT SUM(Points) AS Total_Points FROM player;", "gold_sql": "SELECT sum(Points) FROM player", "source_tables": ["player"]}
{"sample_id": 3376, "db_id": "sports_competition", "question": "What is the total number of points for all players?", "rationale": ["Identify the table that contains the relevant data: The 'player' table contains the 'Points' column which holds the total points scored by each player.", "Determine the operation needed: We need to calculate the total number of points for all players, which requires summing the 'Points' column.", "Construct the SQL query: Use the SUM() function to add up all the values in the 'Points' column and select it as 'Total_Points'."], "pred_sql": "SELECT SUM(Points) AS Total_Points FROM player;", "gold_sql": "SELECT sum(Points) FROM player", "source_tables": ["player"]}
{"sample_id": 3377, "db_id": "sports_competition", "question": "how many different positions are there?", "rationale": ["Identify the table that contains the information about player positions, which is the 'player' table.", "To find the number of different positions, we need to count distinct values in the 'Position' column.", "The SQL query will use the COUNT function along with DISTINCT to get the unique positions.", "The final SQL query will select the count of distinct positions from the player table."], "pred_sql": "SELECT COUNT(DISTINCT Position) AS Different_Positions FROM player;", "gold_sql": "SELECT count(DISTINCT POSITION) FROM player", "source_tables": ["player"]}
{"sample_id": 3378, "db_id": "sports_competition", "question": "How many different position for players are listed?", "rationale": ["Identify the table that contains player positions, which is the 'player' table.", "To find the number of different positions, we need to count distinct values in the 'Position' column.", "The SQL query will use the COUNT function along with DISTINCT to count unique positions.", "The final SQL query will select the count of distinct positions from the 'player' table."], "pred_sql": "SELECT COUNT(DISTINCT Position) AS Different_Positions FROM player;", "gold_sql": "SELECT count(DISTINCT POSITION) FROM player", "source_tables": ["player"]}
{"sample_id": 3379, "db_id": "sports_competition", "question": "what are the name of players who get more than the average points.", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant column for player names, which is 'name'.", "Calculate the average points scored by players using the AVG() function on the 'Points' column.", "Formulate the SQL query to select player names where their points are greater than the calculated average points."], "pred_sql": "SELECT name FROM player WHERE Points > (SELECT AVG(Points) FROM player)", "gold_sql": "SELECT name FROM player WHERE points  >  (SELECT avg(points) FROM player)", "source_tables": ["player"]}
{"sample_id": 3380, "db_id": "sports_competition", "question": "What are the names of all players that got more than the average number of points?", "rationale": ["Identify the relevant table: The 'player' table contains the information about players and their points.", "Determine the condition: We need players whose points are greater than the average points.", "Calculate the average points: Use a subquery to calculate the average of the 'Points' column in the 'player' table.", "Formulate the SQL query: Select the 'name' of players from the 'player' table where their 'Points' exceed the calculated average."], "pred_sql": "SELECT name FROM player WHERE Points > (SELECT AVG(Points) FROM player)", "gold_sql": "SELECT name FROM player WHERE points  >  (SELECT avg(points) FROM player)", "source_tables": ["player"]}
{"sample_id": 3381, "db_id": "sports_competition", "question": "find the number of players whose points are lower than 30 in each position.", "rationale": ["Identify the table that contains player information, which is the 'player' table.", "Determine the relevant columns needed for the query: 'Position' and 'Points'.", "Filter the players whose 'Points' are lower than 30 using a WHERE clause.", "Count the number of players for each position using COUNT(*) and group the results by 'Position' using GROUP BY."], "pred_sql": "SELECT Position, COUNT(*) AS Number_of_Players FROM player WHERE Points < '30' GROUP BY Position;", "gold_sql": "SELECT count(*) ,  POSITION FROM player WHERE points  <  30 GROUP BY POSITION", "source_tables": ["player"]}
{"sample_id": 3382, "db_id": "sports_competition", "question": "What is the number of players who have points less than 30 for each position?", "rationale": ["Identify the relevant table: The 'player' table contains the information about players and their points.", "Determine the condition: We need to filter players with points less than 30.", "Select the required columns: We need the 'Position' of the players and a count of players for each position.", "Group the results: To get the count of players for each position, we will use the GROUP BY clause on the 'Position' column."], "pred_sql": "SELECT Position, COUNT(*) AS Number_of_Players FROM player WHERE Points < '30' GROUP BY Position;", "gold_sql": "SELECT count(*) ,  POSITION FROM player WHERE points  <  30 GROUP BY POSITION", "source_tables": ["player"]}
{"sample_id": 3383, "db_id": "sports_competition", "question": "which country did participated in the most number of Tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competitions, including their type and country.", "Filter for tournament competitions: We need to focus on rows where the 'Competition_type' is 'tournament'.", "Count the number of tournaments per country: Use the COUNT function to count the number of occurrences for each country.", "Group the results by country: Use GROUP BY to aggregate the counts for each country.", "Order the results: Sort the results in descending order based on the count of tournaments.", "Limit the results to the top entry: Use LIMIT 1 to get the country with the most tournaments."], "pred_sql": "SELECT Country, COUNT(*) AS Tournament_Count \nFROM competition \nWHERE Competition_type = 'tournament' \nGROUP BY Country \nORDER BY Tournament_Count DESC \nLIMIT 1;", "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"]}
{"sample_id": 3384, "db_id": "sports_competition", "question": "what is the name of the country that participated in the most tournament competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competitions, including the type and country.", "Filter for tournament competitions: We need to focus on rows where the 'Competition_type' is 'tournament'.", "Group by country: To find out how many tournaments each country participated in, we will group the results by the 'Country' column.", "Count the number of tournaments: We will count the number of entries for each country to determine participation.", "Order the results: We will order the results in descending order based on the count of tournaments to find the country with the most participation.", "Limit the results: Since we only want the country with the most tournaments, we will limit the results to 1."], "pred_sql": "SELECT Country FROM competition WHERE Competition_type = 'tournament' GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1;", "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Tournament' GROUP BY country ORDER BY count(*) DESC LIMIT 1", "source_tables": ["competition"]}
{"sample_id": 3385, "db_id": "sports_competition", "question": "which countries did participated in both Friendly and Tournament type competitions.", "rationale": ["Identify the relevant tables: We need to look at the 'competition' table for competition types and the 'competition_result' table to link competitions with countries.", "We need to find countries that participated in both 'Friendly' and 'Tournament' types of competitions.", "Use a JOIN between 'competition' and 'competition_result' to connect competitions with their respective countries.", "Filter the results to include only those competitions that are of type 'Friendly' or 'Tournament'.", "Group the results by country and use HAVING to ensure that only countries that have participated in both types of competitions are included."], "pred_sql": "SELECT DISTINCT c.Country\nFROM competition c\nJOIN competition_result cr ON c.Competition_ID = cr.Competition_ID\nWHERE c.Competition_type IN ('Friendly', 'Tournament')\nGROUP BY c.Country\nHAVING COUNT(DISTINCT c.Competition_type) = 2;", "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Friendly' INTERSECT SELECT country FROM competition WHERE competition_type  =  'Tournament'", "source_tables": ["competition"]}
{"sample_id": 3386, "db_id": "sports_competition", "question": "What are the countries that participated in both friendly and tournament type competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about the competitions, including their types and countries.", "Determine the required competition types: We need to filter for competitions that are either 'friendly' or 'tournament'.", "Use the DISTINCT keyword: To ensure that we only get unique countries, we will use the DISTINCT keyword in our SELECT statement.", "Construct the SQL query: Combine the selected columns, the table name, and the WHERE clause to filter by competition type."], "pred_sql": "SELECT DISTINCT Country FROM competition WHERE Competition_type IN ('friendly', 'tournament')", "gold_sql": "SELECT country FROM competition WHERE competition_type  =  'Friendly' INTERSECT SELECT country FROM competition WHERE competition_type  =  'Tournament'", "source_tables": ["competition"]}
{"sample_id": 3387, "db_id": "sports_competition", "question": "Find the countries that have never participated in any competition with Friendly type.", "rationale": ["Identify the table that contains the country information, which is the 'competition' table.", "We need to find countries that have never participated in any competition of type 'Friendly'.", "To do this, we will select distinct countries from the 'competition' table where the competition ID is not in a subquery.", "The subquery will select competition IDs from the 'competition_result' table that are associated with 'Friendly' type competitions.", "We will join the 'competition_result' table with the 'competition' table to filter by competition type.", "Finally, we will ensure that the main query only returns countries that do not appear in the results of the subquery."], "pred_sql": "SELECT DISTINCT c.Country \nFROM competition c \nWHERE c.Competition_ID NOT IN (\n    SELECT cr.Competition_ID \n    FROM competition_result cr \n    JOIN competition co ON cr.Competition_ID = co.Competition_ID \n    WHERE co.Competition_type = 'Friendly'\n)", "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"]}
{"sample_id": 3388, "db_id": "sports_competition", "question": "What are the countries that have never participated in any friendly-type competitions?", "rationale": ["Identify the relevant table: The 'competition' table contains information about competitions, including their type and country.", "Determine the condition: We need to find countries that have never participated in friendly-type competitions.", "Use a subquery: Create a subquery to select all Competition_IDs from the 'competition' table where the Competition_type is 'friendly'.", "Select distinct countries: Use the main query to select distinct countries from the 'competition' table where the Competition_ID is not in the list of friendly competitions from the subquery."], "pred_sql": "SELECT DISTINCT Country FROM competition WHERE Competition_ID NOT IN (SELECT Competition_ID FROM competition WHERE Competition_type = 'friendly')", "gold_sql": "SELECT country FROM competition EXCEPT SELECT country FROM competition WHERE competition_type  =  'Friendly'", "source_tables": ["competition"]}
{"sample_id": 3389, "db_id": "manufacturer", "question": "How many furniture components are there in total?", "rationale": ["Identify the table that contains the information about furniture components, which is the 'furniture' table.", "Determine the column that holds the number of components for each furniture item, which is 'Num_of_Component'.", "To find the total number of components, use the SUM() function to aggregate the values in the 'Num_of_Component' column.", "Construct the SQL query to select the sum of 'Num_of_Component' from the 'furniture' table."], "pred_sql": "SELECT SUM(Num_of_Component) AS Total_Components FROM furniture;", "gold_sql": "SELECT sum(num_of_component) FROM furniture", "source_tables": ["furniture"]}
{"sample_id": 3390, "db_id": "manufacturer", "question": "Return the name and id of the furniture with the highest market rate.", "rationale": ["Identify the table that contains the required information: the 'furniture' table has the 'Furniture_ID', 'Name', and 'Market_Rate' columns.", "To find the furniture with the highest market rate, we need to sort the results by 'Market_Rate' in descending order.", "We will select the 'Furniture_ID' and 'Name' columns from the 'furniture' table.", "To get only the top result (the highest market rate), we will use 'LIMIT 1' to restrict the output to a single row."], "pred_sql": "SELECT Furniture_ID, Name FROM furniture ORDER BY Market_Rate DESC LIMIT 1;", "gold_sql": "SELECT name ,  furniture_id FROM furniture ORDER BY market_rate DESC LIMIT 1", "source_tables": ["furniture"]}
{"sample_id": 3391, "db_id": "manufacturer", "question": "find the total market rate of the furnitures that have the top 2 market shares.", "rationale": ["Identify the relevant tables: 'furniture' for market rates and 'furniture_manufacte' for linking furniture to manufacturers.", "We need to calculate the total market rate of the furniture items, so we will use the SUM function on the 'Market_Rate' column from the 'furniture' table.", "To find the top 2 market shares, we will join the 'furniture' table with the 'furniture_manufacte' table on 'Furniture_ID'.", "We will group the results by 'Furniture_ID' to aggregate the market rates for each furniture item.", "Next, we will order the results by the total price in dollars (from 'furniture_manufacte') in descending order to get the top market shares.", "Finally, we will limit the results to the top 2 entries to get the total market rate for those items."], "pred_sql": "SELECT SUM(f.Market_Rate) AS Total_Market_Rate\nFROM furniture f\nJOIN furniture_manufacte fm ON f.Furniture_ID = fm.Furniture_ID\nGROUP BY fm.Furniture_ID\nORDER BY SUM(fm.Price_in_Dollar) DESC\nLIMIT 2;", "gold_sql": "SELECT sum(market_rate) FROM furniture ORDER BY market_rate DESC LIMIT 2", "source_tables": ["furniture"]}
{"sample_id": 3392, "db_id": "manufacturer", "question": "Find the component amounts and names of all furnitures that have more than 10 components.", "rationale": ["Identify the table that contains the relevant data: the 'furniture' table holds information about furniture items, including their names and the number of components.", "Determine the specific columns needed for the output: we need 'Name' for the furniture name and 'Num_of_Component' for the number of components.", "Formulate the condition for filtering the results: we want only those furniture items that have more than 10 components, which translates to a condition in the SQL query.", "Construct the SQL SELECT statement to retrieve the desired columns from the 'furniture' table, applying the condition to filter the results."], "pred_sql": "SELECT Name, Num_of_Component FROM furniture WHERE Num_of_Component > 10;", "gold_sql": "SELECT Num_of_Component ,  name FROM furniture WHERE Num_of_Component  >  10", "source_tables": ["furniture"]}
{"sample_id": 3393, "db_id": "manufacturer", "question": "Find the name and component amount of the least popular furniture.", "rationale": ["Identify the relevant tables: 'furniture' for furniture details and 'furniture_manufacte' for linking furniture to manufacturers.", "To find the least popular furniture, we need to count how many manufacturers produce each piece of furniture. This can be done by joining the 'furniture' and 'furniture_manufacte' tables on 'Furniture_ID'.", "We will group the results by 'Furniture_ID' to aggregate the counts of manufacturers for each furniture item.", "Next, we will order the results by the count of manufacturers in ascending order to get the least popular furniture at the top.", "Finally, we will select the 'Name' and 'Num_of_Component' from the 'furniture' table and limit the results to 1 to get only the least popular furniture."], "pred_sql": "SELECT f.Name, f.Num_of_Component FROM furniture f JOIN furniture_manufacte fm ON f.Furniture_ID = fm.Furniture_ID GROUP BY f.Furniture_ID ORDER BY COUNT(fm.Manufacturer_ID) ASC LIMIT 1;", "gold_sql": "SELECT name ,  Num_of_Component FROM furniture ORDER BY market_rate LIMIT 1", "source_tables": ["furniture"]}
{"sample_id": 3394, "db_id": "manufacturer", "question": "Find the names of furnitures whose prices are lower than the highest price.", "rationale": ["Identify the table that contains the furniture names and their prices, which is the 'furniture' table.", "To find the names of furniture items with prices lower than the highest price, we need to first determine the highest price in the 'furniture' table.", "Use a subquery to select the maximum market rate from the 'furniture' table: (SELECT MAX(Market_Rate) FROM furniture).", "Then, we can select the names of the furniture items where their market rate is less than this maximum value.", "Combine these elements into a complete SQL query that selects the 'Name' from the 'furniture' table where the 'Market_Rate' is less than the result of the subquery."], "pred_sql": "SELECT Name FROM furniture WHERE Market_Rate < (SELECT MAX(Market_Rate) FROM furniture);", "gold_sql": "SELECT t1.name FROM furniture AS t1 JOIN furniture_manufacte AS t2 ON t1.Furniture_ID  =  t2.Furniture_ID WHERE t2.Price_in_Dollar  <  (SELECT max(Price_in_Dollar) FROM furniture_manufacte)", "source_tables": ["furniture_manufacte", "furniture"]}
{"sample_id": 3395, "db_id": "manufacturer", "question": "Which manufacturer has the most number of shops? List its name and year of opening.", "rationale": ["Identify the relevant table: The query requires information about manufacturers, so we will use the 'manufacturer' table.", "Determine the columns needed: We need the 'Name' and 'Open_Year' of the manufacturer with the most shops.", "Find the manufacturer with the most shops: We will order the results by 'Num_of_Shops' in descending order to get the manufacturer with the highest number of shops at the top.", "Limit the results to one: Since we only need the manufacturer with the most shops, we will use 'LIMIT 1' to return only the top result."], "pred_sql": "SELECT Name, Open_Year FROM manufacturer ORDER BY Num_of_Shops DESC LIMIT 1;", "gold_sql": "SELECT open_year ,  name FROM manufacturer ORDER BY num_of_shops DESC LIMIT 1", "source_tables": ["manufacturer"]}
{"sample_id": 3396, "db_id": "manufacturer", "question": "Find the average number of factories for the manufacturers that have more than 20 shops.", "rationale": ["Identify the table that contains the relevant data: the 'manufacturer' table has the number of factories and shops.", "We need to calculate the average number of factories, so we will use the AVG() function.", "We need to filter the manufacturers that have more than 20 shops, which requires a WHERE clause.", "The 'Num_of_Factories' and 'Num_of_Shops' columns are stored as text, so we need to cast them to INTEGER for accurate calculations and comparisons.", "Construct the SQL query to select the average number of factories from the manufacturer table where the number of shops is greater than 20."], "pred_sql": "SELECT AVG(CAST(Num_of_Factories AS INTEGER)) AS Average_Factories\nFROM manufacturer\nWHERE CAST(Num_of_Shops AS INTEGER) > 20;", "gold_sql": "SELECT avg(Num_of_Factories) FROM manufacturer WHERE num_of_shops  >  20", "source_tables": ["manufacturer"]}
{"sample_id": 3397, "db_id": "manufacturer", "question": "List all manufacturer names and ids ordered by their opening year.", "rationale": ["Identify the table that contains the required information: the 'manufacturer' table has the 'Manufacturer_ID' and 'Name' columns.", "Select the columns needed: 'Manufacturer_ID' and 'Name'.", "Specify the order in which to sort the results: order by 'Open_Year' in ascending order.", "Construct the SQL query using the SELECT statement, specifying the columns and the table, and including the ORDER BY clause."], "pred_sql": "SELECT Manufacturer_ID, Name FROM manufacturer ORDER BY Open_Year;", "gold_sql": "SELECT name ,  manufacturer_id FROM manufacturer ORDER BY open_year", "source_tables": ["manufacturer"]}
{"sample_id": 3398, "db_id": "manufacturer", "question": "Give me the name and year of opening of the manufacturers that have either less than 10 factories or more than 10 shops.", "rationale": ["Identify the columns needed: 'Name' and 'Open_Year' from the 'manufacturer' table.", "Determine the conditions for filtering: manufacturers with less than 10 factories or more than 10 shops.", "Use the WHERE clause to apply these conditions: 'Num_of_Factories < 10' OR 'Num_of_Shops > 10'.", "Construct the SQL SELECT statement to retrieve the specified columns from the 'manufacturer' table based on the conditions."], "pred_sql": "SELECT Name, Open_Year FROM manufacturer WHERE Num_of_Factories < '10' OR Num_of_Shops > '10';", "gold_sql": "SELECT name ,  open_year FROM manufacturer WHERE num_of_shops  >  10 OR Num_of_Factories  <  10", "source_tables": ["manufacturer"]}
{"sample_id": 3399, "db_id": "manufacturer", "question": "what is the average number of factories and maximum number of shops for manufacturers that opened before 1990.", "rationale": ["Identify the relevant table: The 'manufacturer' table contains the necessary columns for this query.", "Determine the required calculations: We need to calculate the average number of factories and the maximum number of shops.", "Filter the manufacturers: We need to include only those manufacturers that opened before 1990, which requires a WHERE clause to filter based on the 'Open_Year' column.", "Convert the text fields to integers: Since 'Num_of_Factories' and 'Num_of_Shops' are stored as text, we need to cast them to integers for accurate calculations.", "Construct the SQL query: Combine the SELECT statement with the AVG and MAX functions, the necessary columns, and the WHERE clause to filter the results."], "pred_sql": "SELECT AVG(CAST(Num_of_Factories AS INTEGER)) AS Average_Factories, MAX(CAST(Num_of_Shops AS INTEGER)) AS Max_Shops FROM manufacturer WHERE CAST(Open_Year AS INTEGER) < 1990;", "gold_sql": "SELECT max(num_of_shops) ,  avg(Num_of_Factories) FROM manufacturer WHERE open_year  <  1990", "source_tables": ["manufacturer"]}
{"sample_id": 3400, "db_id": "manufacturer", "question": "Find the id and number of shops for the company that produces the most expensive furniture.", "rationale": ["Identify the tables involved: manufacturer, furniture, and furniture_manufacte.", "Determine the required fields: Manufacturer_ID and Num_of_Shops from the manufacturer table.", "Find the most expensive furniture by using the Market_Rate field from the furniture table.", "Join the manufacturer table with the furniture_manufacte table to link manufacturers to their furniture.", "Join the furniture table to access the Market_Rate of the furniture items.", "Use a subquery to find the maximum Market_Rate from the furniture table.", "Filter the results to only include the manufacturer that produces the furniture with the maximum Market_Rate."], "pred_sql": "SELECT m.Manufacturer_ID, m.Num_of_Shops FROM manufacturer m JOIN furniture_manufacte fm ON m.Manufacturer_ID = fm.Manufacturer_ID JOIN furniture f ON fm.Furniture_ID = f.Furniture_ID WHERE f.Market_Rate = (SELECT MAX(Market_Rate) FROM furniture)", "gold_sql": "SELECT t1.manufacturer_id ,  t1.num_of_shops FROM manufacturer AS t1 JOIN furniture_manufacte AS t2 ON t1.manufacturer_id  =  t2.manufacturer_id ORDER BY t2.Price_in_Dollar DESC LIMIT 1", "source_tables": ["furniture_manufacte", "manufacturer"]}
{"sample_id": 3401, "db_id": "manufacturer", "question": "Find the number of funiture types produced by each manufacturer as well as the company names.", "rationale": ["We need to find the number of furniture types produced by each manufacturer along with the company names.", "To achieve this, we will select the manufacturer name from the 'manufacturer' table.", "We will count the number of distinct furniture types associated with each manufacturer, which can be done using the COUNT function on the 'Furniture_ID' from the 'furniture' table.", "To link the manufacturers with their furniture, we will use the 'furniture_manufacte' table, which serves as a junction table between 'manufacturer' and 'furniture'.", "We will perform a JOIN operation between the 'manufacturer' table and the 'furniture_manufacte' table on 'Manufacturer_ID', and then another JOIN with the 'furniture' table on 'Furniture_ID'.", "Finally, we will group the results by the manufacturer name to get the count of furniture types for each manufacturer."], "pred_sql": "SELECT m.Name, COUNT(f.Furniture_ID) AS Number_of_Furniture_Types\nFROM manufacturer m\nJOIN furniture_manufacte fm ON m.Manufacturer_ID = fm.Manufacturer_ID\nJOIN furniture f ON fm.Furniture_ID = f.Furniture_ID\nGROUP BY m.Name;", "gold_sql": "SELECT count(*) ,  t1.name FROM manufacturer AS t1 JOIN furniture_manufacte AS t2 ON t1.manufacturer_id  =  t2.manufacturer_id GROUP BY t1.manufacturer_id", "source_tables": ["furniture_manufacte", "manufacturer"]}
{"sample_id": 3402, "db_id": "manufacturer", "question": "Give me the names and prices of furnitures which some companies are manufacturing.", "rationale": ["Identify the required information: names and prices of furniture.", "Determine the relevant tables: 'furniture' for furniture names and 'furniture_manufacte' for prices.", "Establish the relationship between the tables using the foreign key: 'furniture.Furniture_ID' links to 'furniture_manufacte.Furniture_ID'.", "Construct the SQL SELECT statement to retrieve the 'Name' from the 'furniture' table and 'Price_in_Dollar' from the 'furniture_manufacte' table.", "Use a JOIN clause to combine the two tables based on the foreign key relationship."], "pred_sql": "SELECT furniture.Name, furniture_manufacte.Price_in_Dollar FROM furniture JOIN furniture_manufacte ON furniture.Furniture_ID = furniture_manufacte.Furniture_ID;", "gold_sql": "SELECT t1.name ,  t2.price_in_dollar FROM furniture AS t1 JOIN furniture_manufacte AS t2 ON t1.Furniture_ID  =  t2.Furniture_ID", "source_tables": ["furniture_manufacte", "furniture"]}
{"sample_id": 3403, "db_id": "manufacturer", "question": "Find the market shares and names of furnitures which no any company is producing in our records.", "rationale": ["We need to find furniture items that are not being produced by any manufacturer.", "To do this, we will select from the 'furniture' table.", "We will perform a LEFT JOIN with the 'furniture_manufacte' table on the 'Furniture_ID' to find any associated manufacturers.", "We will filter the results where the 'Furniture_ID' in the 'furniture_manufacte' table is NULL, indicating that no manufacturer is producing that furniture item."], "pred_sql": "SELECT f.Name AS Furniture_Name, f.Market_Rate AS Market_Rate\nFROM furniture f\nLEFT JOIN furniture_manufacte fm ON f.Furniture_ID = fm.Furniture_ID\nWHERE fm.Furniture_ID IS NULL;", "gold_sql": "SELECT Market_Rate ,  name FROM furniture WHERE Furniture_ID NOT IN (SELECT Furniture_ID FROM furniture_manufacte)", "source_tables": ["furniture_manufacte", "furniture"]}
{"sample_id": 3404, "db_id": "manufacturer", "question": "Find the name of the company that produces both furnitures with less than 6 components and furnitures with more than 10 components.", "rationale": ["Identify the tables involved: manufacturer, furniture, and furniture_manufacte.", "We need to find manufacturers that produce furniture with two different component counts: less than 6 and more than 10.", "Start by selecting the manufacturer name from the manufacturer table.", "Join the furniture_manufacte table to link manufacturers with their furniture items.", "Join the furniture table to access the number of components for each furniture item.", "Use a WHERE clause to filter for furniture with less than 6 components.", "Use a subquery to find manufacturers that also produce furniture with more than 10 components, ensuring we only select those manufacturers that meet both criteria."], "pred_sql": "SELECT DISTINCT m.Name \nFROM manufacturer m \nJOIN furniture_manufacte fm ON m.Manufacturer_ID = fm.Manufacturer_ID \nJOIN furniture f ON fm.Furniture_ID = f.Furniture_ID \nWHERE f.Num_of_Component < 6 \nAND m.Manufacturer_ID IN (\n    SELECT fm2.Manufacturer_ID \n    FROM furniture_manufacte fm2 \n    JOIN furniture f2 ON fm2.Furniture_ID = f2.Furniture_ID \n    WHERE f2.Num_of_Component > 10\n)", "gold_sql": "SELECT t3.name FROM furniture AS t1 JOIN furniture_manufacte AS t2 ON t1.Furniture_ID  =  t2.Furniture_ID JOIN manufacturer AS t3 ON t2.manufacturer_id  =  t3.manufacturer_id WHERE t1.num_of_component  <  6 INTERSECT SELECT t3.name FROM furniture AS t1 JOIN furniture_manufacte AS t2 ON t1.Furniture_ID  =  t2.Furniture_ID JOIN manufacturer AS t3 ON t2.manufacturer_id  =  t3.manufacturer_id WHERE t1.num_of_component  >  10", "source_tables": ["furniture_manufacte", "manufacturer", "furniture"]}
{"sample_id": 3405, "db_id": "hr_1", "question": "Display the first name and department name for each employee.", "rationale": ["Identify the required columns: FIRST_NAME from employees and DEPARTMENT_NAME from departments.", "Determine the tables involved: employees and departments.", "Establish the relationship between the tables: employees are linked to departments through DEPARTMENT_ID.", "Use a JOIN clause to combine the employees and departments tables based on the DEPARTMENT_ID.", "Construct the SELECT statement to retrieve the desired columns from the joined tables."], "pred_sql": "SELECT employees.FIRST_NAME, departments.DEPARTMENT_NAME \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID;", "gold_sql": "SELECT T1.first_name ,  T2.department_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id", "source_tables": ["employees", "departments"]}
{"sample_id": 3406, "db_id": "hr_1", "question": "What are the first name and department name of all employees?", "rationale": ["Identify the columns needed: FIRST_NAME from employees and DEPARTMENT_NAME from departments.", "Determine the tables involved: employees and departments.", "Establish the relationship between the tables: employees are linked to departments through DEPARTMENT_ID.", "Use a JOIN clause to combine the employees and departments tables based on the DEPARTMENT_ID.", "Select the required columns from the combined result."], "pred_sql": "SELECT employees.FIRST_NAME, departments.DEPARTMENT_NAME FROM employees JOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID;", "gold_sql": "SELECT T1.first_name ,  T2.department_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id", "source_tables": ["employees", "departments"]}
{"sample_id": 3407, "db_id": "hr_1", "question": "List the full name (first and last name), and salary for those employees who earn below 6000.", "rationale": ["Identify the required fields: full name (first and last name) and salary.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter the employees based on the salary condition (less than 6000).", "Construct the SQL SELECT statement to retrieve the desired fields from the employees table."], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, SALARY FROM employees WHERE SALARY < 6000;", "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"]}
{"sample_id": 3408, "db_id": "hr_1", "question": "What are the full names and salaries for any employees earning less than 6000?", "rationale": ["Identify the required fields: full names and salaries of employees.", "To get the full names, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter the employees based on the salary condition (less than 6000).", "Construct the SQL SELECT statement to retrieve the desired fields from the employees table."], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, SALARY FROM employees WHERE SALARY < 6000;", "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE salary  <  6000", "source_tables": ["employees"]}
{"sample_id": 3409, "db_id": "hr_1", "question": "Display the first name, and department number for all employees whose last name is \"McEwen\".", "rationale": ["Identify the columns needed: FIRST_NAME and DEPARTMENT_ID from the employees table.", "Determine the table to query: employees.", "Specify the condition: last name should be 'McEwen'.", "Construct the SQL SELECT statement to retrieve the specified columns with the condition."], "pred_sql": "SELECT employees.FIRST_NAME, employees.DEPARTMENT_ID FROM employees WHERE employees.LAST_NAME = 'McEwen';", "gold_sql": "SELECT first_name ,  department_id FROM employees WHERE last_name  =  'McEwen'", "source_tables": ["employees"]}
{"sample_id": 3410, "db_id": "hr_1", "question": "What are the first names and department numbers for employees with last name McEwen?", "rationale": ["Identify the columns needed: FIRST_NAME and DEPARTMENT_ID from the employees table.", "Determine the table to query: employees.", "Specify the condition to filter results: LAST_NAME should be 'McEwen'.", "Construct the SQL SELECT statement to retrieve the specified columns with the given condition."], "pred_sql": "SELECT FIRST_NAME, DEPARTMENT_ID FROM employees WHERE LAST_NAME = 'McEwen';", "gold_sql": "SELECT first_name ,  department_id FROM employees WHERE last_name  =  'McEwen'", "source_tables": ["employees"]}
{"sample_id": 3411, "db_id": "hr_1", "question": "Return all the information for all employees without any department number.", "rationale": ["Identify the table needed: The 'employees' table contains all the information about employees.", "Determine the requirement: We need to return all information for employees without any department number.", "Translate 'without any department number' to SQL: This means we need to filter employees where the DEPARTMENT_ID is NULL.", "Construct the SQL query: Use SELECT * to get all columns from the employees table and add a WHERE clause to filter for NULL DEPARTMENT_ID."], "pred_sql": "SELECT * FROM employees WHERE DEPARTMENT_ID IS NULL;", "gold_sql": "SELECT * FROM employees WHERE department_id  =  'null'", "source_tables": ["employees"]}
{"sample_id": 3412, "db_id": "hr_1", "question": "What are all the employees without a department number?", "rationale": ["Identify the table that contains employee information, which is the 'employees' table.", "Determine the condition to find employees without a department number, which means the 'DEPARTMENT_ID' should be NULL.", "Construct the SQL query to select all columns from the 'employees' table where 'DEPARTMENT_ID' is NULL."], "pred_sql": "SELECT * FROM employees WHERE DEPARTMENT_ID IS NULL;", "gold_sql": "SELECT * FROM employees WHERE department_id  =  'null'", "source_tables": ["employees"]}
{"sample_id": 3413, "db_id": "hr_1", "question": "Display all the information about the department Marketing.", "rationale": ["Identify the table that contains department information, which is the 'departments' table.", "Determine the specific department we want to query, which is 'Marketing'.", "Construct a SQL SELECT statement to retrieve all columns from the 'departments' table where the 'DEPARTMENT_NAME' matches 'Marketing'."], "pred_sql": "SELECT * FROM departments WHERE DEPARTMENT_NAME = 'Marketing';", "gold_sql": "SELECT * FROM  departments WHERE department_name  =  'Marketing'", "source_tables": ["departments"]}
{"sample_id": 3414, "db_id": "hr_1", "question": "What is all the information about the Marketing department?", "rationale": ["Identify the table that contains information about departments, which is the 'departments' table.", "Determine the specific department we are interested in, which is the 'Marketing' department.", "Construct a SQL query to select all columns from the 'departments' table where the 'DEPARTMENT_NAME' matches 'Marketing'."], "pred_sql": "SELECT * FROM departments WHERE DEPARTMENT_NAME = 'Marketing';", "gold_sql": "SELECT * FROM  departments WHERE department_name  =  'Marketing'", "source_tables": ["departments"]}
{"sample_id": 3415, "db_id": "hr_1", "question": "when is the hire date for those employees whose first name does not containing the letter M?", "rationale": ["Identify the table that contains the hire date of employees, which is the 'employees' table.", "Determine the condition for filtering employees based on their first name, specifically those whose first name does not contain the letter 'M'.", "Use the SQL 'NOT LIKE' operator to filter out first names containing 'M'.", "Select the 'HIRE_DATE' column from the 'employees' table where the condition is met."], "pred_sql": "SELECT HIRE_DATE FROM employees WHERE FIRST_NAME NOT LIKE '%M%';", "gold_sql": "SELECT hire_date FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"]}
{"sample_id": 3416, "db_id": "hr_1", "question": "On what dates were employees without the letter M in their first names hired?", "rationale": ["Identify the table that contains the hiring information, which is the 'employees' table.", "Determine the relevant column for the hiring date, which is 'HIRE_DATE'.", "Identify the condition to filter employees based on their first names, specifically those without the letter 'M'.", "Construct the SQL query to select the 'HIRE_DATE' from the 'employees' table where 'FIRST_NAME' does not contain the letter 'M'."], "pred_sql": "SELECT HIRE_DATE FROM employees WHERE FIRST_NAME NOT LIKE '%M%';", "gold_sql": "SELECT hire_date FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"]}
{"sample_id": 3417, "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M.", "rationale": ["Identify the columns needed: FULL_NAME (first and last), HIRE_DATE, SALARY, and DEPARTMENT_ID.", "To get the full name, concatenate FIRST_NAME and LAST_NAME with a space in between.", "Filter the employees whose FIRST_NAME does not contain the letter 'M'.", "Use the SQL SELECT statement to retrieve the specified columns from the employees table."], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID FROM employees WHERE FIRST_NAME NOT LIKE '%M%';", "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"]}
{"sample_id": 3418, "db_id": "hr_1", "question": "What are the full name, hire date, salary, and department id for employees without the letter M in their first name?", "rationale": ["Identify the required fields: FULL_NAME (concatenation of FIRST_NAME and LAST_NAME), HIRE_DATE, SALARY, and DEPARTMENT_ID.", "Use the employees table as it contains all the necessary information about employees.", "To create the FULL_NAME, concatenate FIRST_NAME and LAST_NAME using '||' operator.", "Filter the results to exclude employees whose FIRST_NAME contains the letter 'M' using the NOT LIKE operator."], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID FROM employees WHERE FIRST_NAME NOT LIKE '%M%';", "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%'", "source_tables": ["employees"]}
{"sample_id": 3419, "db_id": "hr_1", "question": "display the full name (first and last), hire date, salary, and department number for those employees whose first name does not containing the letter M and make the result set in ascending order by department number.", "rationale": ["Identify the columns needed: FULL_NAME (concatenation of FIRST_NAME and LAST_NAME), HIRE_DATE, SALARY, and DEPARTMENT_ID.", "Use the employees table since it contains all the required information about employees.", "Filter the results to exclude employees whose FIRST_NAME contains the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Sort the results in ascending order by DEPARTMENT_ID using the ORDER BY clause."], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID FROM employees WHERE FIRST_NAME NOT LIKE '%M%' ORDER BY DEPARTMENT_ID ASC;", "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"]}
{"sample_id": 3420, "db_id": "hr_1", "question": "What are the full name, hire data, salary and department id for employees without the letter M in their first name, ordered by ascending department id?", "rationale": ["Identify the columns needed: FULL_NAME (concatenation of FIRST_NAME and LAST_NAME), HIRE_DATE, SALARY, and DEPARTMENT_ID.", "Filter the employees whose FIRST_NAME does not contain the letter 'M'. This can be done using the NOT LIKE operator with a wildcard.", "Order the results by DEPARTMENT_ID in ascending order.", "Construct the SQL SELECT statement with the identified columns, the WHERE clause for filtering, and the ORDER BY clause."], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, HIRE_DATE, SALARY, DEPARTMENT_ID FROM employees WHERE FIRST_NAME NOT LIKE '%M%' ORDER BY DEPARTMENT_ID ASC;", "gold_sql": "SELECT first_name ,  last_name ,  hire_date ,  salary ,  department_id FROM employees WHERE first_name NOT LIKE '%M%' ORDER BY department_id", "source_tables": ["employees"]}
{"sample_id": 3421, "db_id": "hr_1", "question": "what is the phone number of employees whose salary is in the range of 8000 and 12000?", "rationale": ["Identify the table that contains the phone numbers of employees, which is the 'employees' table.", "Determine the column that holds the salary information, which is the 'SALARY' column in the 'employees' table.", "Formulate a query to select the 'PHONE_NUMBER' from the 'employees' table where the 'SALARY' is between 8000 and 12000, using the BETWEEN clause."], "pred_sql": "SELECT PHONE_NUMBER FROM employees WHERE SALARY BETWEEN '8000' AND '12000';", "gold_sql": "SELECT phone_number FROM employees WHERE salary BETWEEN 8000 AND 12000", "source_tables": ["employees"]}
{"sample_id": 3422, "db_id": "hr_1", "question": "Return the phone numbers of employees with salaries between 8000 and 12000.", "rationale": ["Identify the table that contains the phone numbers of employees, which is the 'employees' table.", "Determine the relevant column for phone numbers, which is 'PHONE_NUMBER'.", "Identify the column that contains salary information, which is 'SALARY'.", "Specify the condition for the salary to be between 8000 and 12000 using the BETWEEN clause.", "Construct the SQL query to select the phone numbers from the 'employees' table where the salary meets the specified condition."], "pred_sql": "SELECT PHONE_NUMBER FROM employees WHERE SALARY BETWEEN 8000 AND 12000;", "gold_sql": "SELECT phone_number FROM employees WHERE salary BETWEEN 8000 AND 12000", "source_tables": ["employees"]}
{"sample_id": 3423, "db_id": "hr_1", "question": "display all the information of employees whose salary is in the range of 8000 and 12000 and commission is not null or department number does not equal to 40.", "rationale": ["Identify the table to query: employees.", "Determine the conditions for filtering: salary between 8000 and 12000, commission not null, and department ID not equal to 40.", "Use the SQL SELECT statement to retrieve all columns from the employees table.", "Apply the WHERE clause to filter employees based on the specified conditions: (salary between 8000 and 12000 AND commission is not null) OR (department ID is not 40).", "Construct the final SQL query."], "pred_sql": "SELECT * FROM employees WHERE (SALARY BETWEEN 8000 AND 12000 AND COMMISSION_PCT IS NOT NULL) OR DEPARTMENT_ID != '40';", "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN 8000 AND 12000 AND commission_pct != 'null' OR  department_id != 40", "source_tables": ["employees"]}
{"sample_id": 3424, "db_id": "hr_1", "question": "Return all information about employees with salaries between 8000 and 12000 for which commission is not null or where their department id is not 40.", "rationale": ["Identify the table to query: employees.", "Determine the conditions for filtering: salaries between 8000 and 12000, commission not null, and department id not equal to 40.", "Construct the SQL query using the SELECT statement to retrieve all columns from the employees table.", "Use the WHERE clause to apply the specified conditions, combining them with OR to ensure either condition can be true."], "pred_sql": "SELECT * FROM employees WHERE (SALARY BETWEEN 8000 AND 12000 AND COMMISSION_PCT IS NOT NULL) OR DEPARTMENT_ID != '40';", "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN 8000 AND 12000 AND commission_pct != 'null' OR  department_id != 40", "source_tables": ["employees"]}
{"sample_id": 3425, "db_id": "hr_1", "question": "What are the full name (first and last name) and salary for all employees who does not have any value for commission?", "rationale": ["Identify the required fields: first name, last name, and salary of employees.", "Determine the table to query: the 'employees' table contains the necessary information.", "Filter the results to include only those employees who do not have a commission value, which means the COMMISSION_PCT field should be NULL.", "Construct the SQL SELECT statement to retrieve the specified fields from the employees table with the appropriate WHERE clause."], "pred_sql": "SELECT FIRST_NAME, LAST_NAME, SALARY FROM employees WHERE COMMISSION_PCT IS NULL", "gold_sql": "SELECT first_name ,  last_name ,  salary FROM  employees WHERE commission_pct  =  'null'", "source_tables": ["employees"]}
{"sample_id": 3426, "db_id": "hr_1", "question": "Return the full names and salaries of employees with null commissions.", "rationale": ["Identify the table that contains employee information, which is the 'employees' table.", "Determine the columns needed: the full name of the employee (which can be constructed by concatenating 'FIRST_NAME' and 'LAST_NAME') and the 'SALARY'.", "Use the SQL SELECT statement to retrieve the required columns.", "Apply a WHERE clause to filter the results to only include employees where 'COMMISSION_PCT' is NULL."], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, SALARY FROM employees WHERE COMMISSION_PCT IS NULL;", "gold_sql": "SELECT first_name ,  last_name ,  salary FROM  employees WHERE commission_pct  =  'null'", "source_tables": ["employees"]}
{"sample_id": 3427, "db_id": "hr_1", "question": "Display the first and last name, and salary for those employees whose first name is ending with the letter m.", "rationale": ["Identify the columns needed: FIRST_NAME, LAST_NAME, and SALARY from the employees table.", "Determine the condition: we need employees whose FIRST_NAME ends with the letter 'm'.", "In SQL, to check if a string ends with a certain character, we can use the LIKE operator with a wildcard '%'.", "Construct the SQL SELECT statement to retrieve the specified columns from the employees table with the appropriate WHERE clause."], "pred_sql": "SELECT FIRST_NAME, LAST_NAME, SALARY FROM employees WHERE FIRST_NAME LIKE '%m';", "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE '%m'", "source_tables": ["employees"]}
{"sample_id": 3428, "db_id": "hr_1", "question": "Return the full names and salaries for employees with first names that end with the letter m.", "rationale": ["Identify the table that contains employee information, which is the 'employees' table.", "Determine the columns needed: 'FIRST_NAME', 'LAST_NAME', and 'SALARY'.", "To get the full name, concatenate 'FIRST_NAME' and 'LAST_NAME' with a space in between.", "Filter the results to include only those employees whose 'FIRST_NAME' ends with the letter 'm'.", "Use the SQL LIKE operator with the pattern '%m' to achieve this."], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME, SALARY FROM employees WHERE FIRST_NAME LIKE '%m';", "gold_sql": "SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE '%m'", "source_tables": ["employees"]}
{"sample_id": 3429, "db_id": "hr_1", "question": "Find job id and date of hire for those employees who was hired between November 5th, 2007 and July 5th, 2009.", "rationale": ["Identify the relevant table: The 'employees' table contains the information about employees, including their job IDs and hire dates.", "Determine the columns needed: We need 'JOB_ID' and 'HIRE_DATE' from the 'employees' table.", "Specify the condition for hire dates: We need to filter employees who were hired between November 5th, 2007 and July 5th, 2009.", "Construct the SQL query: Use the SELECT statement to retrieve the required columns and apply the WHERE clause to filter based on the hire date range."], "pred_sql": "SELECT JOB_ID, HIRE_DATE FROM employees WHERE HIRE_DATE BETWEEN '2007-11-05' AND '2009-07-05';", "gold_sql": "SELECT job_id ,  hire_date FROM employees WHERE hire_date BETWEEN '2007-11-05' AND '2009-07-05'", "source_tables": ["employees"]}
{"sample_id": 3430, "db_id": "hr_1", "question": "What are the job ids and dates of hire for employees hired after November 5th, 2007 and before July 5th, 2009?", "rationale": ["Identify the relevant table: The 'employees' table contains the information about employees, including their job IDs and hire dates.", "Determine the columns needed: We need 'JOB_ID' and 'HIRE_DATE' from the 'employees' table.", "Set the conditions for the query: We want to filter employees hired after November 5th, 2007 and before July 5th, 2009.", "Construct the SQL query: Use a SELECT statement to retrieve the required columns with the specified conditions using a WHERE clause."], "pred_sql": "SELECT JOB_ID, HIRE_DATE FROM employees WHERE HIRE_DATE > '2007-11-05' AND HIRE_DATE < '2009-07-05';", "gold_sql": "SELECT job_id ,  hire_date FROM employees WHERE hire_date BETWEEN '2007-11-05' AND '2009-07-05'", "source_tables": ["employees"]}
{"sample_id": 3431, "db_id": "hr_1", "question": "What are the first and last name for those employees who works either in department 70 or 90?", "rationale": ["Identify the relevant table: The 'employees' table contains the first and last names of employees along with their department IDs.", "Determine the columns needed: We need 'FIRST_NAME' and 'LAST_NAME' from the 'employees' table.", "Specify the condition: We want employees who work in department 70 or 90, which means we need to filter the results based on the 'DEPARTMENT_ID' column.", "Use the IN clause: To check for multiple values (70 and 90), we can use the IN clause in the WHERE condition.", "Construct the SQL query: Combine the SELECT statement with the WHERE condition to form the complete SQL query."], "pred_sql": "SELECT FIRST_NAME, LAST_NAME FROM employees WHERE DEPARTMENT_ID IN ('70', '90');", "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE department_id  =  70 OR department_id  =  90", "source_tables": ["employees"]}
{"sample_id": 3432, "db_id": "hr_1", "question": "What are the full names of employees who with in department 70 or 90?", "rationale": ["Identify the relevant table: The 'employees' table contains the employee names and department information.", "Determine the required fields: We need the full names of employees, which can be constructed by concatenating 'FIRST_NAME' and 'LAST_NAME'.", "Filter the results: We need to include only those employees who belong to department 70 or 90. This can be done using the 'DEPARTMENT_ID' column with an IN clause.", "Construct the SQL query: Combine the SELECT statement with the WHERE clause to filter by department."], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME FROM employees WHERE DEPARTMENT_ID IN ('70', '90');", "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE department_id  =  70 OR department_id  =  90", "source_tables": ["employees"]}
{"sample_id": 3433, "db_id": "hr_1", "question": "Find the salary and manager number for those employees who is working under a manager.", "rationale": ["Identify the relevant table: The 'employees' table contains the salary and manager information.", "Select the required columns: We need to retrieve 'SALARY' and 'MANAGER_ID' from the 'employees' table.", "Filter the results: We want only those employees who are working under a manager, which means their 'MANAGER_ID' should not be null."], "pred_sql": "SELECT SALARY, MANAGER_ID FROM employees WHERE MANAGER_ID IS NOT NULL;", "gold_sql": "SELECT salary ,  manager_id FROM employees WHERE manager_id != 'null'", "source_tables": ["employees"]}
{"sample_id": 3434, "db_id": "hr_1", "question": "What are the salaries and manager ids for employees who have managers?", "rationale": ["Identify the relevant table: The 'employees' table contains the salary and manager ID information.", "Select the required columns: We need to retrieve 'SALARY' and 'MANAGER_ID' from the 'employees' table.", "Filter the results: We only want employees who have managers, which means we need to check that 'MANAGER_ID' is not null."], "pred_sql": "SELECT SALARY, MANAGER_ID FROM employees WHERE MANAGER_ID IS NOT NULL;", "gold_sql": "SELECT salary ,  manager_id FROM employees WHERE manager_id != 'null'", "source_tables": ["employees"]}
{"sample_id": 3435, "db_id": "hr_1", "question": "display all the details from Employees table for those employees who was hired before 2002-06-21.", "rationale": ["Identify the table to query: The request is to display details from the Employees table, so we will use the 'employees' table.", "Determine the columns to select: The request is to display all details, which means we will use '*' to select all columns from the employees table.", "Identify the condition: The request specifies a condition that employees must have been hired before '2002-06-21'. This will be applied in the WHERE clause.", "Construct the SQL query: Combine the SELECT statement with the FROM clause and the WHERE condition to form the complete SQL query."], "pred_sql": "SELECT * FROM employees WHERE HIRE_DATE < '2002-06-21';", "gold_sql": "SELECT * FROM employees WHERE hire_date  <  '2002-06-21'", "source_tables": ["employees"]}
{"sample_id": 3436, "db_id": "hr_1", "question": "What is all the information about employees hired before June 21, 2002?", "rationale": ["Identify the table that contains employee information, which is the 'employees' table.", "Determine the relevant column for the hire date, which is 'HIRE_DATE'.", "Specify the condition to filter employees hired before June 21, 2002, using the '<' operator.", "Construct the SQL query to select all columns from the 'employees' table where the 'HIRE_DATE' is less than '2002-06-21'."], "pred_sql": "SELECT * FROM employees WHERE HIRE_DATE < '2002-06-21';", "gold_sql": "SELECT * FROM employees WHERE hire_date  <  '2002-06-21'", "source_tables": ["employees"]}
{"sample_id": 3437, "db_id": "hr_1", "question": "display all the information for all employees who have the letters D or S in their first name and also arrange the result in descending order by salary.", "rationale": ["Identify the table needed: The 'employees' table contains the information about employees.", "Determine the filtering condition: We need to filter employees whose first names contain the letters 'D' or 'S'. This can be done using the LIKE operator with wildcards.", "Construct the WHERE clause: The condition will be 'FIRST_NAME LIKE '%D%' OR FIRST_NAME LIKE '%S%'', which checks for the presence of 'D' or 'S' in the first name.", "Specify the sorting requirement: The results should be sorted in descending order by salary, which can be done using 'ORDER BY SALARY DESC'.", "Combine all parts to form the complete SQL query: SELECT * FROM employees WHERE FIRST_NAME LIKE '%D%' OR FIRST_NAME LIKE '%S%' ORDER BY SALARY DESC."], "pred_sql": "SELECT * FROM employees WHERE FIRST_NAME LIKE '%D%' OR FIRST_NAME LIKE '%S%' ORDER BY SALARY DESC;", "gold_sql": "SELECT * FROM employees WHERE first_name LIKE '%D%' OR first_name LIKE '%S%' ORDER BY salary DESC", "source_tables": ["employees"]}
{"sample_id": 3438, "db_id": "hr_1", "question": "What is all the information about employees with D or S in their first name, ordered by salary descending?", "rationale": ["Identify the table needed: The 'employees' table contains all the information about employees.", "Determine the filtering condition: We need to filter employees whose first name contains 'D' or 'S'. This can be done using the LIKE operator with wildcards.", "Construct the WHERE clause: The condition will be 'FIRST_NAME LIKE '%D%' OR FIRST_NAME LIKE '%S%''.", "Specify the ordering requirement: The results should be ordered by the 'SALARY' column in descending order.", "Combine all parts to form the complete SQL query."], "pred_sql": "SELECT * FROM employees WHERE FIRST_NAME LIKE '%D%' OR FIRST_NAME LIKE '%S%' ORDER BY SALARY DESC;", "gold_sql": "SELECT * FROM employees WHERE first_name LIKE '%D%' OR first_name LIKE '%S%' ORDER BY salary DESC", "source_tables": ["employees"]}
{"sample_id": 3439, "db_id": "hr_1", "question": "display those employees who joined after 7th September, 1987.", "rationale": ["Identify the table that contains employee information, which is the 'employees' table.", "Determine the relevant column for the hire date, which is 'HIRE_DATE'.", "Formulate a condition to filter employees based on their hire date, specifically those who joined after September 7, 1987.", "Construct the SQL SELECT statement to retrieve all columns from the 'employees' table where the 'HIRE_DATE' is greater than '1987-09-07'."], "pred_sql": "SELECT * FROM employees WHERE HIRE_DATE > '1987-09-07';", "gold_sql": "SELECT * FROM employees WHERE hire_date  >  '1987-09-07'", "source_tables": ["employees"]}
{"sample_id": 3440, "db_id": "hr_1", "question": "Which employees were hired after September 7th, 1987?", "rationale": ["Identify the table that contains employee hiring information, which is the 'employees' table.", "Determine the relevant column for the hire date, which is 'HIRE_DATE'.", "Formulate a condition to filter employees hired after a specific date, in this case, September 7th, 1987.", "Construct the SQL SELECT statement to retrieve all columns from the 'employees' table where the 'HIRE_DATE' is greater than '1987-09-07'."], "pred_sql": "SELECT * FROM employees WHERE HIRE_DATE > '1987-09-07';", "gold_sql": "SELECT * FROM employees WHERE hire_date  >  '1987-09-07'", "source_tables": ["employees"]}
{"sample_id": 3441, "db_id": "hr_1", "question": "display the job title of jobs which minimum salary is greater than 9000.", "rationale": ["Identify the table that contains job information, which is the 'jobs' table.", "Determine the relevant columns needed for the query: 'JOB_TITLE' for the output and 'MIN_SALARY' for the condition.", "Construct the SQL SELECT statement to retrieve 'JOB_TITLE' from the 'jobs' table.", "Add a WHERE clause to filter the results where 'MIN_SALARY' is greater than 9000."], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MIN_SALARY > 9000;", "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"]}
{"sample_id": 3442, "db_id": "hr_1", "question": "Which job titles correspond to jobs with salaries over 9000?", "rationale": ["Identify the relevant table: The query is about job titles and salaries, so we will focus on the 'jobs' table.", "Determine the columns needed: We need the 'JOB_TITLE' column to get the job titles and the 'MIN_SALARY' and 'MAX_SALARY' columns to filter jobs with salaries over 9000.", "Construct the SQL query: We will select 'JOB_TITLE' from the 'jobs' table where either 'MIN_SALARY' or 'MAX_SALARY' is greater than 9000."], "pred_sql": "SELECT JOB_TITLE FROM jobs WHERE MIN_SALARY > 9000 OR MAX_SALARY > 9000;", "gold_sql": "SELECT job_title FROM jobs WHERE min_salary  >  9000", "source_tables": ["jobs"]}
{"sample_id": 3443, "db_id": "hr_1", "question": "display job Title, the difference between minimum and maximum salaries for those jobs which max salary within the range 12000 to 18000.", "rationale": ["Identify the required columns: JOB_TITLE and the difference between MAX_SALARY and MIN_SALARY.", "Calculate the difference between MAX_SALARY and MIN_SALARY using the expression (MAX_SALARY - MIN_SALARY).", "Filter the results to include only those jobs where MAX_SALARY is between 12000 and 18000 using the WHERE clause with the BETWEEN operator.", "Construct the SQL SELECT statement to retrieve the specified columns from the jobs table."], "pred_sql": "SELECT JOB_TITLE, (MAX_SALARY - MIN_SALARY) AS SALARY_DIFFERENCE \nFROM jobs \nWHERE MAX_SALARY BETWEEN 12000 AND 18000;", "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"]}
{"sample_id": 3444, "db_id": "hr_1", "question": "What are the job titles, and range of salaries for jobs with maximum salary between 12000 and 18000?", "rationale": ["Identify the relevant table: The query requires information about job titles and salary ranges, which are found in the 'jobs' table.", "Determine the columns needed: The columns needed are 'JOB_TITLE', 'MIN_SALARY', and 'MAX_SALARY'.", "Specify the condition: The query specifies that we need jobs with a maximum salary between 12000 and 18000.", "Construct the SQL query: Using the SELECT statement to retrieve the specified columns from the 'jobs' table with the appropriate WHERE clause to filter the maximum salary."], "pred_sql": "SELECT JOB_TITLE, MIN_SALARY, MAX_SALARY FROM jobs WHERE MAX_SALARY BETWEEN 12000 AND 18000;", "gold_sql": "SELECT job_title ,  max_salary - min_salary FROM jobs WHERE max_salary BETWEEN 12000 AND 18000", "source_tables": ["jobs"]}
{"sample_id": 3445, "db_id": "hr_1", "question": "display the emails of the employees who have no commission percentage and salary within the range 7000 to 12000 and works in that department which number is 50.", "rationale": ["Identify the table that contains the required information: the 'employees' table holds employee details including email, commission percentage, salary, and department ID.", "Filter employees who have no commission percentage: this can be done using 'COMMISSION_PCT IS NULL'.", "Filter employees whose salary is within the specified range: use 'SALARY BETWEEN 7000 AND 12000'.", "Filter employees who work in department number 50: this is done by adding 'DEPARTMENT_ID = '50''.", "Combine all these conditions in the WHERE clause of the SQL query.", "Select the EMAIL column from the employees table as the final output."], "pred_sql": "SELECT EMAIL FROM employees WHERE COMMISSION_PCT IS NULL AND SALARY BETWEEN 7000 AND 12000 AND DEPARTMENT_ID = '50';", "gold_sql": "SELECT email FROM employees WHERE commission_pct  =  'null' AND salary BETWEEN 7000 AND 12000 AND department_id = 50", "source_tables": ["employees"]}
{"sample_id": 3446, "db_id": "hr_1", "question": "What are the emails of employees with null commission, salary between 7000 and 12000, and who work in department 50?", "rationale": ["Identify the table that contains the required information: the 'employees' table holds employee details including email, commission percentage, salary, and department ID.", "Filter for employees with a null commission percentage: this is done using the condition 'COMMISSION_PCT IS NULL'.", "Filter for employees with a salary between 7000 and 12000: this is done using the condition 'SALARY BETWEEN 7000 AND 12000'.", "Filter for employees who work in department 50: this is done using the condition 'DEPARTMENT_ID = '50''.", "Combine all the conditions using the WHERE clause to retrieve the desired emails of employees."], "pred_sql": "SELECT EMAIL FROM employees WHERE COMMISSION_PCT IS NULL AND SALARY BETWEEN 7000 AND 12000 AND DEPARTMENT_ID = '50';", "gold_sql": "SELECT email FROM employees WHERE commission_pct  =  'null' AND salary BETWEEN 7000 AND 12000 AND department_id = 50", "source_tables": ["employees"]}
{"sample_id": 3447, "db_id": "hr_1", "question": "display the employee ID for each employee and the date on which he ended his previous job.", "rationale": ["Identify the required information: employee ID and the end date of their previous job.", "The employee ID is found in the 'employees' table and the end date of the previous job is found in the 'job_history' table.", "To get the end date of the previous job for each employee, we need to join the 'employees' table with the 'job_history' table on the common column 'EMPLOYEE_ID'.", "Construct the SQL SELECT statement to retrieve 'EMPLOYEE_ID' from the 'employees' table and 'END_DATE' from the 'job_history' table."], "pred_sql": "SELECT e.EMPLOYEE_ID, jh.END_DATE\nFROM employees e\nJOIN job_history jh ON e.EMPLOYEE_ID = jh.EMPLOYEE_ID;", "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"]}
{"sample_id": 3448, "db_id": "hr_1", "question": "What are the employee ids for each employee and final dates of employment at their last job?", "rationale": ["Identify the relevant tables: employees and job_history.", "We need to retrieve employee IDs and the final dates of employment, which are found in the employees and job_history tables respectively.", "Join the employees table with the job_history table on the EMPLOYEE_ID column to link employees with their job history.", "To get the final date of employment for each employee, we need to filter the job_history records to only include the maximum END_DATE for each employee.", "Use a subquery to find the maximum END_DATE for each employee in the job_history table.", "Select the EMPLOYEE_ID from the employees table and the corresponding maximum END_DATE from the job_history table."], "pred_sql": "SELECT e.EMPLOYEE_ID, jh.END_DATE \nFROM employees e \nJOIN job_history jh ON e.EMPLOYEE_ID = jh.EMPLOYEE_ID \nWHERE jh.END_DATE = (SELECT MAX(END_DATE) FROM job_history WHERE EMPLOYEE_ID = e.EMPLOYEE_ID)", "gold_sql": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id", "source_tables": ["job_history"]}
{"sample_id": 3449, "db_id": "hr_1", "question": "display those departments where more than ten employees work who got a commission percentage.", "rationale": ["Identify the relevant tables: departments and employees.", "We need to join the departments table with the employees table on the DEPARTMENT_ID column.", "Filter employees who have a non-null COMMISSION_PCT to ensure they receive a commission.", "Group the results by department name to count the number of employees in each department.", "Use the HAVING clause to filter groups (departments) that have more than ten employees."], "pred_sql": "SELECT d.DEPARTMENT_NAME\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nWHERE e.COMMISSION_PCT IS NOT NULL\nGROUP BY d.DEPARTMENT_NAME\nHAVING COUNT(e.EMPLOYEE_ID) > 10;", "gold_sql": "SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > 10", "source_tables": ["employees"]}
{"sample_id": 3450, "db_id": "hr_1", "question": "What are the department ids for which more than 10 employees had a commission?", "rationale": ["Identify the relevant table: The 'employees' table contains information about employees, including their department IDs and commission percentages.", "Determine the condition: We need to find departments where more than 10 employees have a non-null commission percentage.", "Use GROUP BY: We will group the results by 'DEPARTMENT_ID' to count the number of employees in each department with a commission.", "Use HAVING clause: We will use the HAVING clause to filter groups that have more than 10 employees with a commission (i.e., where COUNT(EMPLOYEE_ID) > 10).", "Select the required column: Finally, we will select the 'DEPARTMENT_ID' from the filtered results."], "pred_sql": "SELECT DEPARTMENT_ID FROM employees WHERE COMMISSION_PCT IS NOT NULL GROUP BY DEPARTMENT_ID HAVING COUNT(EMPLOYEE_ID) > 10;", "gold_sql": "SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(commission_pct) > 10", "source_tables": ["employees"]}
{"sample_id": 3451, "db_id": "hr_1", "question": "Find the ids of the departments where any manager is managing 4 or more employees.", "rationale": ["Identify the relevant tables: departments and employees.", "We need to find departments where the manager manages 4 or more employees.", "Join the departments table with the employees table on the MANAGER_ID column to link managers to their employees.", "Group the results by DEPARTMENT_ID to aggregate the number of employees per department.", "Use the COUNT function to count the number of employees for each manager.", "Filter the results using HAVING to only include departments where the count of employees is 4 or more."], "pred_sql": "SELECT d.DEPARTMENT_ID\nFROM departments d\nJOIN employees e ON d.MANAGER_ID = e.MANAGER_ID\nGROUP BY d.DEPARTMENT_ID\nHAVING COUNT(e.EMPLOYEE_ID) >= 4;", "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"]}
{"sample_id": 3452, "db_id": "hr_1", "question": "What are department ids for departments with managers managing more than 3 employees?", "rationale": ["Identify the relevant tables: We need to look at the 'departments' table for department IDs and the 'employees' table to count the number of employees per department.", "Join the 'departments' table with the 'employees' table on the DEPARTMENT_ID to associate each department with its employees.", "Group the results by DEPARTMENT_ID to aggregate the employee counts for each department.", "Use the HAVING clause to filter the groups where the count of employees is greater than 3."], "pred_sql": "SELECT d.DEPARTMENT_ID \nFROM departments d \nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nGROUP BY d.DEPARTMENT_ID \nHAVING COUNT(e.EMPLOYEE_ID) > 3;", "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"]}
{"sample_id": 3453, "db_id": "hr_1", "question": "display the average salary of employees for each department who gets a commission percentage.", "rationale": ["Identify the tables needed: We need data from the 'employees' table for salaries and commission percentages, and the 'departments' table for department names.", "Join the 'employees' table with the 'departments' table on the 'DEPARTMENT_ID' to associate employees with their respective departments.", "Filter the results to include only those employees who have a non-null commission percentage, indicating they receive a commission.", "Use the AVG() function to calculate the average salary of the filtered employees for each department.", "Group the results by department name to get the average salary for each department."], "pred_sql": "SELECT d.DEPARTMENT_NAME, AVG(e.SALARY) AS average_salary\nFROM employees e\nJOIN departments d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID\nWHERE e.COMMISSION_PCT IS NOT NULL\nGROUP BY d.DEPARTMENT_NAME;", "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"]}
{"sample_id": 3454, "db_id": "hr_1", "question": "What is the average salary of employees who have a commission percentage that is not null?", "rationale": ["Identify the table that contains salary information, which is the 'employees' table.", "Determine the specific column for salary, which is 'SALARY'.", "Identify the condition that needs to be applied, which is that 'COMMISSION_PCT' should not be null.", "Construct the SQL query to calculate the average salary using the AVG() function, applying the condition in the WHERE clause."], "pred_sql": "SELECT AVG(SALARY) AS average_salary FROM employees WHERE COMMISSION_PCT IS NOT NULL;", "gold_sql": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != 'null' GROUP BY department_id", "source_tables": ["employees"]}
{"sample_id": 3455, "db_id": "hr_1", "question": "display the country ID and number of cities for each country.", "rationale": ["Identify the required columns: COUNTRY_ID from countries and the count of cities from locations.", "To get the number of cities for each country, we need to join the countries table with the locations table on the COUNTRY_ID.", "Use the COUNT function to count the number of cities for each country.", "Group the results by COUNTRY_ID to ensure we get a count for each country."], "pred_sql": "SELECT countries.COUNTRY_ID, COUNT(locations.CITY) AS number_of_cities\nFROM countries\nJOIN locations ON countries.COUNTRY_ID = locations.COUNTRY_ID\nGROUP BY countries.COUNTRY_ID;", "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"]}
{"sample_id": 3456, "db_id": "hr_1", "question": "Give the country id and corresponding count of cities in each country.", "rationale": ["Identify the tables needed: countries and locations.", "Determine the relationship between countries and locations: countries have a COUNTRY_ID that links to locations.", "Select the COUNTRY_ID from the countries table and count the number of cities from the locations table.", "Use a JOIN to combine the countries and locations tables on the COUNTRY_ID.", "Group the results by COUNTRY_ID to get the count of cities for each country."], "pred_sql": "SELECT countries.COUNTRY_ID, COUNT(locations.CITY) AS city_count\nFROM countries\nJOIN locations ON countries.COUNTRY_ID = locations.COUNTRY_ID\nGROUP BY countries.COUNTRY_ID;", "gold_sql": "SELECT country_id ,  COUNT(*) FROM locations GROUP BY country_id", "source_tables": ["locations"]}
{"sample_id": 3457, "db_id": "hr_1", "question": "display job ID for those jobs that were done by two or more for more than 300 days.", "rationale": ["Identify the relevant tables: job_history and jobs.", "We need to find jobs that have been held by two or more employees, so we will group by JOB_ID in the job_history table.", "To count the number of distinct employees for each job, we will use COUNT(DISTINCT jh.EMPLOYEE_ID).", "We need to filter the results to only include jobs that have been held for more than 300 days, which can be done using the HAVING clause.", "Join the job_history table with the jobs table to get the JOB_ID for the results.", "Construct the final SQL query to select the JOB_ID from the jobs table where the conditions are met."], "pred_sql": "SELECT j.JOB_ID\nFROM job_history jh\nJOIN jobs j ON jh.JOB_ID = j.JOB_ID\nGROUP BY jh.JOB_ID\nHAVING COUNT(DISTINCT jh.EMPLOYEE_ID) >= 2 AND (j.END_DATE - j.START_DATE) > 300;", "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"]}
{"sample_id": 3458, "db_id": "hr_1", "question": "What are the job ids for jobs done more than once for a period of more than 300 days?", "rationale": ["Identify the relevant table: job_history, as it contains records of jobs held by employees over time.", "We need to find job IDs that have been held more than once, which can be determined using the COUNT function on JOB_ID, grouping by JOB_ID.", "To ensure that the job was held for a period of more than 300 days, we need to calculate the duration for each job held using the difference between END_DATE and START_DATE.", "The duration can be calculated using the JULIANDAY function to convert the dates into a format that allows for subtraction, giving us the number of days.", "We will use the SUM function to aggregate the total duration for each job ID and apply a HAVING clause to filter for those with a total duration greater than 300 days."], "pred_sql": "SELECT JOB_ID FROM job_history GROUP BY JOB_ID HAVING COUNT(*) > 1 AND SUM(JULIANDAY(END_DATE) - JULIANDAY(START_DATE)) > 300;", "gold_sql": "SELECT job_id FROM job_history WHERE end_date - start_date  > 300 GROUP BY job_id HAVING COUNT(*) >= 2", "source_tables": ["job_history"]}
{"sample_id": 3459, "db_id": "hr_1", "question": "display the ID for those employees who did two or more jobs in the past.", "rationale": ["Identify the relevant table: The 'job_history' table contains records of employees' job history.", "Determine the required information: We need the 'EMPLOYEE_ID' of employees who have held two or more jobs.", "Group the results: Use GROUP BY to group the records by 'EMPLOYEE_ID'.", "Count the distinct jobs: Use COUNT(DISTINCT JOB_ID) to count the number of different jobs held by each employee.", "Filter the results: Use HAVING to filter groups where the count of distinct jobs is 2 or more."], "pred_sql": "SELECT EMPLOYEE_ID FROM job_history GROUP BY EMPLOYEE_ID HAVING COUNT(DISTINCT JOB_ID) >= 2;", "gold_sql": "SELECT employee_id FROM job_history GROUP BY employee_id HAVING COUNT(*)  >= 2", "source_tables": ["job_history"]}
{"sample_id": 3460, "db_id": "hr_1", "question": "What are the employee ids for employees who have held two or more jobs?", "rationale": ["Identify the relevant table: job_history contains the job records for employees.", "We need to find employees who have held two or more jobs, which means we need to count the distinct JOB_IDs for each EMPLOYEE_ID.", "Use GROUP BY to group the records by EMPLOYEE_ID so we can count the number of distinct JOB_IDs for each employee.", "Use HAVING to filter the results to only include those employees who have held two or more distinct jobs (i.e., COUNT(DISTINCT JOB_ID) >= 2).", "Select the EMPLOYEE_IDs of those employees who meet the criteria."], "pred_sql": "SELECT EMPLOYEE_ID FROM job_history GROUP BY EMPLOYEE_ID HAVING COUNT(DISTINCT JOB_ID) >= 2;", "gold_sql": "SELECT employee_id FROM job_history GROUP BY employee_id HAVING COUNT(*)  >= 2", "source_tables": ["job_history"]}
{"sample_id": 3461, "db_id": "hr_1", "question": "Find employee with ID and name of the country presently where (s)he is working.", "rationale": ["Identify the required information: employee ID and country name.", "The employee ID is found in the 'employees' table.", "The country name is found in the 'countries' table.", "To link employees to their respective countries, we need to join the 'departments' table (which links employees to departments) and the 'locations' table (which links departments to locations).", "The 'locations' table contains the 'COUNTRY_ID' which can be used to join with the 'countries' table to get the country name.", "Construct the SQL query using JOIN statements to connect these tables appropriately."], "pred_sql": "SELECT employees.EMPLOYEE_ID, countries.COUNTRY_NAME \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID \nJOIN countries ON locations.COUNTRY_ID = countries.COUNTRY_ID;", "gold_sql": "SELECT T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"]}
{"sample_id": 3462, "db_id": "hr_1", "question": "What are all the employee ids and the names of the countries in which they work?", "rationale": ["Identify the required data: employee IDs and country names.", "The employee IDs are in the 'employees' table and the country names are in the 'countries' table.", "To link employees to their countries, we need to go through the 'departments' and 'locations' tables.", "Join the 'employees' table with the 'departments' table on 'DEPARTMENT_ID'.", "Join the 'departments' table with the 'locations' table on 'LOCATION_ID'.", "Join the 'locations' table with the 'countries' table on 'COUNTRY_ID'.", "Select the 'EMPLOYEE_ID' from the 'employees' table and 'COUNTRY_NAME' from the 'countries' table."], "pred_sql": "SELECT employees.EMPLOYEE_ID, countries.COUNTRY_NAME \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nJOIN locations ON departments.LOCATION_ID = locations.LOCATION_ID \nJOIN countries ON locations.COUNTRY_ID = countries.COUNTRY_ID;", "gold_sql": "SELECT T1.employee_id ,  T4.country_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id JOIN locations AS T3 ON T2.location_id  =  T3.location_id JOIN countries AS T4 ON T3.country_id  =  T4.country_id", "source_tables": ["countries", "employees", "departments", "locations"]}
{"sample_id": 3463, "db_id": "hr_1", "question": "display the department name and number of employees in each of the department.", "rationale": ["Identify the tables needed: We need the 'departments' table for department names and the 'employees' table to count the number of employees.", "Join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' to associate employees with their respective departments.", "Use a LEFT JOIN to ensure that departments with no employees are still included in the results with a count of zero.", "Use the COUNT function to count the number of employees in each department.", "Group the results by department name to get the count of employees per department."], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"]}
{"sample_id": 3464, "db_id": "hr_1", "question": "Give the name of each department and the number of employees in each.", "rationale": ["Identify the tables needed: We need the 'departments' table for department names and the 'employees' table to count the number of employees.", "Join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' to associate employees with their respective departments.", "Use a LEFT JOIN to ensure that departments with no employees are still included in the results.", "Count the number of employees for each department using COUNT(e.EMPLOYEE_ID).", "Group the results by department name to get the count of employees per department."], "pred_sql": "SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS NUMBER_OF_EMPLOYEES\nFROM departments d\nLEFT JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "gold_sql": "SELECT T2.department_name ,  COUNT(*) FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T2.department_name", "source_tables": ["employees", "departments"]}
{"sample_id": 3465, "db_id": "hr_1", "question": "Can you return all detailed info of jobs which was done by any of the employees who is presently earning a salary on and above 12000?", "rationale": ["Identify the relevant tables: jobs and employees.", "We need to retrieve all details from the jobs table, so we will select all columns from jobs.", "We need to filter jobs based on employees' salaries, specifically those earning 12000 or more.", "To do this, we will join the jobs table with the employees table on the JOB_ID column, as this is the common identifier between the two tables.", "Finally, we will apply a WHERE clause to filter employees with a salary of 12000 or more."], "pred_sql": "SELECT jobs.* FROM jobs JOIN employees ON jobs.JOB_ID = employees.JOB_ID WHERE employees.SALARY >= 12000;", "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"]}
{"sample_id": 3466, "db_id": "hr_1", "question": "What is all the job history info done by employees earning a salary greater than or equal to 12000?", "rationale": ["Identify the relevant tables: job_history and employees.", "We need to retrieve all job history information, so we will select all columns from the job_history table.", "To filter employees based on their salary, we will join the employees table with the job_history table using the EMPLOYEE_ID column.", "The condition for filtering is that the salary of employees should be greater than or equal to 12000."], "pred_sql": "SELECT jh.* FROM job_history jh JOIN employees e ON jh.EMPLOYEE_ID = e.EMPLOYEE_ID WHERE e.SALARY >= 12000;", "gold_sql": "SELECT * FROM  job_history AS T1 JOIN employees AS T2 ON T1.employee_id  =  T2.employee_id WHERE T2.salary  >=  12000", "source_tables": ["job_history", "employees"]}
{"sample_id": 3467, "db_id": "hr_1", "question": "display job title and average salary of employees.", "rationale": ["Identify the required fields: job title and average salary of employees.", "The job title is stored in the 'jobs' table under the 'JOB_TITLE' column.", "The salary of employees is stored in the 'employees' table under the 'SALARY' column.", "To calculate the average salary, we will use the AVG() function.", "We need to join the 'jobs' table with the 'employees' table on the 'JOB_ID' column, as it links jobs to employees.", "We will group the results by 'JOB_TITLE' to get the average salary for each job title."], "pred_sql": "SELECT j.JOB_TITLE, AVG(e.SALARY) AS AVERAGE_SALARY\nFROM jobs j\nJOIN employees e ON j.JOB_ID = e.JOB_ID\nGROUP BY j.JOB_TITLE;", "gold_sql": "SELECT job_title ,  AVG(salary) FROM employees AS T1 JOIN jobs AS T2 ON T1.job_id  =  T2.job_id GROUP BY T2.job_title", "source_tables": ["employees", "jobs"]}
{"sample_id": 3468, "db_id": "hr_1", "question": "What is the average salary for each job title?", "rationale": ["Identify the relevant tables: jobs and employees.", "Determine the columns needed: JOB_TITLE from jobs and SALARY from employees.", "Use the AVG() function to calculate the average salary.", "Join the jobs and employees tables on JOB_ID to associate job titles with their respective salaries.", "Group the results by JOB_TITLE to get the average salary for each job title."], "pred_sql": "SELECT j.JOB_TITLE, AVG(e.SALARY) AS AVERAGE_SALARY\nFROM jobs j\nJOIN employees e ON j.JOB_ID = e.JOB_ID\nGROUP BY j.JOB_TITLE;", "gold_sql": "SELECT job_title ,  AVG(salary) FROM employees AS T1 JOIN jobs AS T2 ON T1.job_id  =  T2.job_id GROUP BY T2.job_title", "source_tables": ["employees", "jobs"]}
{"sample_id": 3469, "db_id": "hr_1", "question": "What is the full name ( first name and last name ) for those employees who gets more salary than the employee whose id is 163?", "rationale": ["Identify the table that contains employee information, which is the 'employees' table.", "We need to select the first name and last name of employees, so we will select 'FIRST_NAME' and 'LAST_NAME' columns from the 'employees' table.", "We need to filter employees based on their salary being greater than a specific employee's salary.", "To find the salary of the employee with ID 163, we will use a subquery that selects 'SALARY' from the 'employees' table where 'EMPLOYEE_ID' is '163'.", "The main query will compare the salary of each employee to the salary obtained from the subquery."], "pred_sql": "SELECT FIRST_NAME, LAST_NAME FROM employees WHERE SALARY > (SELECT SALARY FROM employees WHERE EMPLOYEE_ID = '163')", "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = 163 )", "source_tables": ["employees"]}
{"sample_id": 3470, "db_id": "hr_1", "question": "Provide the full names of employees earning more than the employee with id 163.", "rationale": ["Identify the requirement: We need to find the full names of employees whose salary is greater than that of the employee with ID 163.", "To get the full names, we need to concatenate the FIRST_NAME and LAST_NAME columns from the employees table.", "We need to filter the employees based on their salary. This requires a subquery to first find the salary of the employee with ID 163.", "The subquery will select the SALARY from the employees table where EMPLOYEE_ID is '163'.", "The main query will select the full names of employees where their salary is greater than the result of the subquery."], "pred_sql": "SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME \nFROM employees \nWHERE SALARY > (SELECT SALARY FROM employees WHERE EMPLOYEE_ID = '163')", "gold_sql": "SELECT first_name ,  last_name FROM employees WHERE salary  >  (SELECT salary FROM employees WHERE employee_id = 163 )", "source_tables": ["employees"]}
{"sample_id": 3471, "db_id": "hr_1", "question": "return the smallest salary for every departments.", "rationale": ["Identify the tables involved: We need to get salary information from the 'employees' table and department names from the 'departments' table.", "Determine the relationship between the tables: The 'employees' table has a foreign key 'DEPARTMENT_ID' that links to the 'departments' table.", "We need to find the smallest salary for each department, which requires grouping the results by department name.", "Use the MIN() function to get the smallest salary for each department.", "Construct the SQL query to select the department name and the minimum salary, joining the two tables on the department ID, and grouping by department name."], "pred_sql": "SELECT d.DEPARTMENT_NAME, MIN(e.SALARY) AS SMALLEST_SALARY\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"]}
{"sample_id": 3472, "db_id": "hr_1", "question": "What is the minimum salary in each department?", "rationale": ["Identify the tables needed: We need the 'departments' table to get department names and the 'employees' table to get employee salaries.", "Determine the relationship: The 'employees' table has a foreign key 'DEPARTMENT_ID' that links to the 'departments' table.", "Select the required columns: We need the department name from 'departments' and the minimum salary from 'employees'.", "Use the MIN() function to calculate the minimum salary for each department.", "Group the results by department name to get the minimum salary for each department."], "pred_sql": "SELECT d.DEPARTMENT_NAME, MIN(e.SALARY) AS MIN_SALARY\nFROM departments d\nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID\nGROUP BY d.DEPARTMENT_NAME;", "gold_sql": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id", "source_tables": ["employees"]}
{"sample_id": 3473, "db_id": "hr_1", "question": "Find the first name and last name and department id for those employees who earn such amount of salary which is the smallest salary of any of the departments.", "rationale": ["Identify the columns needed: FIRST_NAME, LAST_NAME, and DEPARTMENT_ID from the employees table.", "Determine the condition for the salary: it should be equal to the smallest salary of any department.", "To find the smallest salary, a subquery is needed that selects the minimum salary from the employees table.", "Combine the selection of employee details with the condition on salary using a WHERE clause."], "pred_sql": "SELECT FIRST_NAME, LAST_NAME, DEPARTMENT_ID FROM employees WHERE SALARY = (SELECT MIN(SALARY) FROM employees);", "gold_sql": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)", "source_tables": ["employees"]}
{"sample_id": 3474, "db_id": "hr_1", "question": "What are the full names and department ids for the lowest paid employees across all departments.", "rationale": ["Identify the required information: full names and department ids of the lowest paid employees.", "To get the full names, we need to concatenate the FIRST_NAME and LAST_NAME from the employees table.", "We need to find the lowest salary across all employees, which can be done using a subquery that selects the minimum salary from the employees table.", "We will filter the employees to only those whose salary matches the minimum salary found in the subquery.", "Finally, we will select the concatenated full name and the department id from the employees table."], "pred_sql": "SELECT e.FIRST_NAME || ' ' || e.LAST_NAME AS FULL_NAME, e.DEPARTMENT_ID \nFROM employees e \nWHERE e.SALARY = (SELECT MIN(SALARY) FROM employees)", "gold_sql": "SELECT first_name ,  last_name ,  department_id FROM employees WHERE salary IN (SELECT MIN(salary) FROM employees GROUP BY department_id)", "source_tables": ["employees"]}
{"sample_id": 3475, "db_id": "hr_1", "question": "Find the employee id for all employees who earn more than the average salary.", "rationale": ["Identify the table that contains employee salary information, which is the 'employees' table.", "Determine the condition for filtering employees, which is to find those earning more than the average salary.", "To find the average salary, a subquery is needed that calculates the average from the 'employees' table.", "Construct the main query to select the 'EMPLOYEE_ID' from the 'employees' table where the salary is greater than the result of the subquery calculating the average salary."], "pred_sql": "SELECT EMPLOYEE_ID FROM employees WHERE SALARY > (SELECT AVG(SALARY) FROM employees);", "gold_sql": "SELECT employee_id FROM employees WHERE salary  >  (SELECT AVG(salary) FROM employees)", "source_tables": ["employees"]}
{"sample_id": 3476, "db_id": "hr_1", "question": "What are the employee ids for employees who make more than the average?", "rationale": ["Identify the table that contains employee salary information, which is the 'employees' table.", "Determine the condition for filtering employees, which is to find those with a salary greater than the average salary.", "To find the average salary, a subquery is needed that calculates the average from the 'employees' table.", "Construct the main query to select the 'EMPLOYEE_ID' from the 'employees' table where the salary is greater than the result of the subquery calculating the average salary."], "pred_sql": "SELECT EMPLOYEE_ID FROM employees WHERE SALARY > (SELECT AVG(SALARY) FROM employees);", "gold_sql": "SELECT employee_id FROM employees WHERE salary  >  (SELECT AVG(salary) FROM employees)", "source_tables": ["employees"]}
{"sample_id": 3477, "db_id": "hr_1", "question": "display the employee id and salary of all employees who report to Payam (first name).", "rationale": ["Identify the relevant table: The 'employees' table contains the information about employees, including their IDs, salaries, and managers.", "Determine the condition: We need to find employees who report to a manager named 'Payam'. This means we need to find the EMPLOYEE_ID of 'Payam' first.", "Create a subquery: The subquery will select the EMPLOYEE_ID of the employee whose FIRST_NAME is 'Payam'.", "Use the result of the subquery: The main query will select EMPLOYEE_ID and SALARY from the 'employees' table where the MANAGER_ID matches the EMPLOYEE_ID obtained from the subquery."], "pred_sql": "SELECT EMPLOYEE_ID, SALARY FROM employees WHERE MANAGER_ID = (SELECT EMPLOYEE_ID FROM employees WHERE FIRST_NAME = 'Payam')", "gold_sql": "SELECT employee_id ,  salary FROM employees WHERE manager_id  =  (SELECT employee_id FROM employees WHERE first_name  =  'Payam' )", "source_tables": ["employees"]}
{"sample_id": 3478, "db_id": "hr_1", "question": "What are the employee ids of employees who report to Payam, and what are their salaries?", "rationale": ["Identify the requirement: We need to find employee IDs and their salaries for employees who report to a manager named Payam.", "To find employees reporting to Payam, we need to first find Payam's employee ID. This requires a subquery that selects the EMPLOYEE_ID from the employees table where the FIRST_NAME is 'Payam'.", "Once we have Payam's EMPLOYEE_ID, we can then select the EMPLOYEE_ID and SALARY from the employees table where the MANAGER_ID matches Payam's EMPLOYEE_ID.", "Construct the SQL query using a subquery to find Payam's EMPLOYEE_ID and then use it to filter the employees who report to him."], "pred_sql": "SELECT EMPLOYEE_ID, SALARY FROM employees WHERE MANAGER_ID = (SELECT EMPLOYEE_ID FROM employees WHERE FIRST_NAME = 'Payam')", "gold_sql": "SELECT employee_id ,  salary FROM employees WHERE manager_id  =  (SELECT employee_id FROM employees WHERE first_name  =  'Payam' )", "source_tables": ["employees"]}
{"sample_id": 3479, "db_id": "hr_1", "question": "find the name of all departments that do actually have one or more employees assigned to them.", "rationale": ["We need to find the names of departments that have employees assigned to them.", "To do this, we will join the 'departments' table with the 'employees' table on the 'DEPARTMENT_ID' column, which is common to both tables.", "We will select the 'DEPARTMENT_NAME' from the 'departments' table.", "Using DISTINCT ensures that we only get unique department names, even if multiple employees are assigned to the same department."], "pred_sql": "SELECT DISTINCT d.DEPARTMENT_NAME \nFROM departments d \nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID;", "gold_sql": "SELECT DISTINCT T2.department_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id", "source_tables": ["employees", "departments"]}
{"sample_id": 3480, "db_id": "hr_1", "question": "What are the names of departments that have at least one employee.", "rationale": ["Identify the relevant tables: 'departments' and 'employees'.", "We need to find departments that have at least one employee, which means we need to join these two tables on the 'DEPARTMENT_ID'.", "Use a JOIN operation to combine the 'departments' table with the 'employees' table based on the matching 'DEPARTMENT_ID'.", "Select the distinct department names from the result to avoid duplicates, as multiple employees can belong to the same department."], "pred_sql": "SELECT DISTINCT d.DEPARTMENT_NAME FROM departments d JOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID;", "gold_sql": "SELECT DISTINCT T2.department_name FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id", "source_tables": ["employees", "departments"]}
{"sample_id": 3481, "db_id": "hr_1", "question": "get the details of employees who manage a department.", "rationale": ["Identify the requirement: We need to get details of employees who manage a department.", "Understand the relationship: An employee manages a department if their EMPLOYEE_ID matches the MANAGER_ID in the departments table.", "Construct the SQL query: We will select all columns from the employees table where there is a join with the departments table on the condition that the employee's ID matches the manager ID of the department."], "pred_sql": "SELECT e.* FROM employees e JOIN departments d ON e.EMPLOYEE_ID = d.MANAGER_ID;", "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"]}
{"sample_id": 3482, "db_id": "hr_1", "question": "What is all the information regarding employees who are managers?", "rationale": ["Identify the requirement: We need to find all information regarding employees who are managers.", "To determine who the managers are, we need to look at the 'MANAGER_ID' field in the 'employees' table.", "We can find distinct 'MANAGER_ID's from the 'employees' table to identify all employees who are managers.", "Next, we will use these distinct 'MANAGER_ID's to filter the 'employees' table to get all information about these employees.", "The final SQL query will select all columns from the 'employees' table where the 'EMPLOYEE_ID' matches any of the distinct 'MANAGER_ID's."], "pred_sql": "SELECT * FROM employees WHERE EMPLOYEE_ID IN (SELECT DISTINCT MANAGER_ID FROM employees WHERE MANAGER_ID IS NOT NULL);", "gold_sql": "SELECT DISTINCT * FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T1.employee_id  =  T2.manager_id", "source_tables": ["employees", "departments"]}
{"sample_id": 3483, "db_id": "hr_1", "question": "display all the information about the department Marketing.", "rationale": ["Identify the table that contains department information, which is the 'departments' table.", "Determine the specific department we want to query, which is 'Marketing'.", "Construct a SQL SELECT statement to retrieve all columns from the 'departments' table where the 'DEPARTMENT_NAME' matches 'Marketing'."], "pred_sql": "SELECT * FROM departments WHERE DEPARTMENT_NAME = 'Marketing';", "gold_sql": "SELECT * FROM  departments WHERE department_name  =  'Marketing'", "source_tables": ["departments"]}
{"sample_id": 3484, "db_id": "hr_1", "question": "What is all the information about the Marketing department?", "rationale": ["Identify the table that contains information about departments, which is the 'departments' table.", "Determine the specific department we are interested in, which is the 'Marketing' department.", "Construct a SQL query to select all columns from the 'departments' table where the 'DEPARTMENT_NAME' matches 'Marketing'."], "pred_sql": "SELECT * FROM departments WHERE DEPARTMENT_NAME = 'Marketing';", "gold_sql": "SELECT * FROM  departments WHERE department_name  =  'Marketing'", "source_tables": ["departments"]}
{"sample_id": 3485, "db_id": "hr_1", "question": "display the ID for those employees who did two or more jobs in the past.", "rationale": ["Identify the relevant table: job_history contains the job history of employees.", "We need to find employees who have held two or more jobs, so we will group the records by EMPLOYEE_ID.", "Using COUNT(DISTINCT JOB_ID) will allow us to count the number of unique jobs held by each employee.", "We will use the HAVING clause to filter the groups to only include those with a count of 2 or more."], "pred_sql": "SELECT EMPLOYEE_ID FROM job_history GROUP BY EMPLOYEE_ID HAVING COUNT(DISTINCT JOB_ID) >= 2;", "gold_sql": "SELECT employee_id FROM job_history GROUP BY employee_id HAVING COUNT(*)  >= 2", "source_tables": ["job_history"]}
{"sample_id": 3486, "db_id": "hr_1", "question": "What are the employee ids for those who had two or more jobs.", "rationale": ["Identify the relevant table: job_history contains the job records for employees.", "We need to find employees who have held two or more jobs, which means we need to count the number of distinct JOB_IDs for each EMPLOYEE_ID.", "Use the GROUP BY clause to group the results by EMPLOYEE_ID.", "Use the HAVING clause to filter the groups to only include those with a count of JOB_IDs that is 2 or more."], "pred_sql": "SELECT EMPLOYEE_ID FROM job_history GROUP BY EMPLOYEE_ID HAVING COUNT(JOB_ID) >= 2;", "gold_sql": "SELECT employee_id FROM job_history GROUP BY employee_id HAVING COUNT(*)  >= 2", "source_tables": ["job_history"]}
{"sample_id": 3487, "db_id": "hr_1", "question": "What are the unique ids of those departments where any manager is managing 4 or more employees.", "rationale": ["Identify the departments and their managers from the 'departments' table.", "Join the 'departments' table with the 'employees' table on the MANAGER_ID to link managers to their employees.", "Group the results by DEPARTMENT_ID to aggregate the number of employees managed by each manager.", "Use the HAVING clause to filter groups where the count of employees is 4 or more."], "pred_sql": "SELECT d.DEPARTMENT_ID\nFROM departments d\nJOIN employees e ON d.MANAGER_ID = e.MANAGER_ID\nGROUP BY d.DEPARTMENT_ID\nHAVING COUNT(e.EMPLOYEE_ID) >= 4;", "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"]}
{"sample_id": 3488, "db_id": "hr_1", "question": "Give the distinct department ids of departments in which a manager is in charge of 4 or more employees?", "rationale": ["We need to find distinct department IDs where a manager oversees 4 or more employees.", "To do this, we will first identify managers who have 4 or more employees reporting to them. This can be done by grouping the employees by their MANAGER_ID and counting the number of employees for each manager.", "We will use a subquery to get the MANAGER_IDs that have 4 or more employees.", "Next, we will join the departments table with the employees table on the DEPARTMENT_ID to link departments with their respective employees.", "Finally, we will select the distinct DEPARTMENT_IDs from the departments where the MANAGER_ID is in the list of managers identified in the subquery."], "pred_sql": "SELECT DISTINCT d.DEPARTMENT_ID \nFROM departments d \nJOIN employees e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID \nWHERE d.MANAGER_ID IN (\n    SELECT MANAGER_ID \n    FROM employees \n    GROUP BY MANAGER_ID \n    HAVING COUNT(EMPLOYEE_ID) >= 4\n)", "gold_sql": "SELECT DISTINCT department_id FROM employees GROUP BY department_id ,  manager_id HAVING COUNT(employee_id)  >= 4", "source_tables": ["employees"]}
{"sample_id": 3489, "db_id": "hr_1", "question": "Find the job ID for those jobs which average salary is above 8000.", "rationale": ["Identify the requirement: We need to find job IDs where the average salary is above 8000.", "Determine the relevant table: The 'employees' table contains the salary information and job IDs.", "Use the AVG() function to calculate the average salary for each job ID.", "Group the results by JOB_ID to calculate the average salary for each job.", "Use the HAVING clause to filter the results to only include job IDs with an average salary greater than 8000."], "pred_sql": "SELECT JOB_ID FROM employees GROUP BY JOB_ID HAVING AVG(SALARY) > 8000;", "gold_sql": "SELECT job_id FROM employees GROUP BY job_id HAVING AVG(salary) > 8000", "source_tables": ["employees"]}
{"sample_id": 3490, "db_id": "hr_1", "question": "What are the job ids corresponding to jobs with average salary above 8000?", "rationale": ["Identify the table that contains job information, which is the 'jobs' table.", "Determine the relevant column for job identification, which is 'JOB_ID'.", "To find jobs with an average salary above 8000, we need to calculate the average salary for each job.", "This requires a subquery that selects the average salary from the 'employees' table, grouped by 'JOB_ID'.", "The main query will select 'JOB_ID' from the 'jobs' table where the average salary from the subquery is greater than 8000."], "pred_sql": "SELECT JOB_ID FROM jobs WHERE (SELECT AVG(SALARY) FROM employees WHERE employees.JOB_ID = jobs.JOB_ID) > 8000;", "gold_sql": "SELECT job_id FROM employees GROUP BY job_id HAVING AVG(salary) > 8000", "source_tables": ["employees"]}
{"sample_id": 3491, "db_id": "hr_1", "question": "display the employee ID and job name for all those jobs in department 80.", "rationale": ["Identify the required columns: employee ID and job name.", "The employee ID is in the 'employees' table and the job name (job title) is in the 'jobs' table.", "To get the job name for each employee, we need to join the 'employees' table with the 'jobs' table on the JOB_ID column.", "We need to filter the results to include only those employees who belong to department 80, which is done using a WHERE clause."], "pred_sql": "SELECT employees.EMPLOYEE_ID, jobs.JOB_TITLE \nFROM employees \nJOIN jobs ON employees.JOB_ID = jobs.JOB_ID \nWHERE employees.DEPARTMENT_ID = '80';", "gold_sql": "SELECT T1.employee_id ,  T2.job_title FROM employees AS T1 JOIN jobs AS T2 ON T1.job_id  =  T2.job_id WHERE T1.department_id = 80", "source_tables": ["employees", "jobs"]}
{"sample_id": 3492, "db_id": "hr_1", "question": "what are the employee ids and job titles for employees in department 80?", "rationale": ["Identify the relevant tables: 'employees' for employee details and 'jobs' for job titles.", "Determine the columns needed: 'EMPLOYEE_ID' from 'employees' and 'JOB_TITLE' from 'jobs'.", "Establish the relationship between the tables: 'employees' has a foreign key 'JOB_ID' that links to 'jobs'.", "Filter the results to include only those employees who belong to department 80 by using a WHERE clause on 'DEPARTMENT_ID'.", "Construct the SQL query using a JOIN to combine 'employees' and 'jobs' based on the 'JOB_ID' and apply the filter for department 80."], "pred_sql": "SELECT employees.EMPLOYEE_ID, jobs.JOB_TITLE \nFROM employees \nJOIN jobs ON employees.JOB_ID = jobs.JOB_ID \nWHERE employees.DEPARTMENT_ID = '80';", "gold_sql": "SELECT T1.employee_id ,  T2.job_title FROM employees AS T1 JOIN jobs AS T2 ON T1.job_id  =  T2.job_id WHERE T1.department_id = 80", "source_tables": ["employees", "jobs"]}
{"sample_id": 3493, "db_id": "hr_1", "question": "What is the first name and job id for all employees in the Finance department?", "rationale": ["Identify the required columns: FIRST_NAME and JOB_ID from the employees table.", "Determine the relationship between employees and departments: employees are linked to departments through DEPARTMENT_ID.", "Use a JOIN operation to combine the employees and departments tables based on DEPARTMENT_ID.", "Filter the results to include only those employees who belong to the Finance department by specifying the condition in the WHERE clause."], "pred_sql": "SELECT employees.FIRST_NAME, employees.JOB_ID \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nWHERE departments.DEPARTMENT_NAME = 'Finance';", "gold_sql": "SELECT T1.first_name ,  T1.job_id FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T2.department_name  =  'Finance'", "source_tables": ["employees", "departments"]}
{"sample_id": 3494, "db_id": "hr_1", "question": "Give the first name and job id for all employees in the Finance department.", "rationale": ["Identify the required columns: FIRST_NAME and JOB_ID from the employees table.", "Determine the relationship between employees and departments: employees are linked to departments through DEPARTMENT_ID.", "Filter the results to include only those employees who belong to the Finance department by using a WHERE clause on the DEPARTMENT_NAME column in the departments table."], "pred_sql": "SELECT employees.FIRST_NAME, employees.JOB_ID \nFROM employees \nJOIN departments ON employees.DEPARTMENT_ID = departments.DEPARTMENT_ID \nWHERE departments.DEPARTMENT_NAME = 'Finance';", "gold_sql": "SELECT T1.first_name ,  T1.job_id FROM employees AS T1 JOIN departments AS T2 ON T1.department_id  =  T2.department_id WHERE T2.department_name  =  'Finance'", "source_tables": ["employees", "departments"]}
{"sample_id": 3495, "db_id": "hr_1", "question": "display all the information of the employees whose salary if within the range of smallest salary and 2500.", "rationale": ["Identify the table to query: employees.", "Determine the condition for salary: it should be between the smallest salary from the jobs table and 2500.", "To find the smallest salary, use a subquery to select the minimum salary from the jobs table.", "Construct the SQL query to select all columns from the employees table where the salary is within the specified range."], "pred_sql": "SELECT * FROM employees WHERE SALARY BETWEEN (SELECT MIN(MIN_SALARY) FROM jobs) AND 2500;", "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"]}
{"sample_id": 3496, "db_id": "hr_1", "question": "What is all the information regarding employees with salaries above the minimum and under 2500?", "rationale": ["Identify the table that contains employee information, which is the 'employees' table.", "Determine the condition for salaries: we need employees with salaries above the minimum salary for their job and below 2500.", "To find the minimum salary for each employee's job, we will use a subquery that selects the MIN_SALARY from the 'jobs' table where the JOB_ID matches the employee's JOB_ID.", "Combine the conditions using a WHERE clause to filter the employees based on the specified salary criteria."], "pred_sql": "SELECT * FROM employees WHERE SALARY > (SELECT MIN_SALARY FROM jobs WHERE JOB_ID = employees.JOB_ID) AND SALARY < 2500;", "gold_sql": "SELECT * FROM employees WHERE salary BETWEEN (SELECT MIN(salary) FROM employees) AND 2500", "source_tables": ["employees"]}
{"sample_id": 3497, "db_id": "hr_1", "question": "Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.", "rationale": ["Identify the employees who do not work in certain departments.", "We need to find departments where some employees have a manager ID in the range of 100 to 200.", "This requires a subquery to select distinct department IDs from the employees table where the manager ID is between 100 and 200.", "The main query will then select employee IDs from the employees table where their department ID is not in the list of department IDs returned by the subquery."], "pred_sql": "SELECT EMPLOYEE_ID FROM employees WHERE DEPARTMENT_ID NOT IN (SELECT DISTINCT DEPARTMENT_ID FROM employees WHERE MANAGER_ID BETWEEN '100' AND '200');", "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"]}
{"sample_id": 3498, "db_id": "hr_1", "question": "What are the ids for employees who do not work in departments with managers that have ids between 100 and 200?", "rationale": ["Identify the main requirement: We need to find employee IDs.", "We need to filter employees based on their department's manager ID.", "The relevant tables are 'employees' and 'departments'.", "We will use a subquery to find all department IDs where the manager ID is between 100 and 200.", "The subquery will return a list of department IDs that we want to exclude from our main query.", "The main query will select employee IDs from the 'employees' table where their department ID is not in the list returned by the subquery."], "pred_sql": "SELECT EMPLOYEE_ID FROM employees WHERE DEPARTMENT_ID NOT IN (SELECT DEPARTMENT_ID FROM departments WHERE MANAGER_ID BETWEEN '100' AND '200');", "gold_sql": "SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)", "source_tables": ["employees", "departments"]}
{"sample_id": 3499, "db_id": "hr_1", "question": "display the employee name ( first name and last name ) and hire date for all employees in the same department as Clara.", "rationale": ["Identify the information needed: employee names (first and last) and hire date for employees in the same department as Clara.", "Determine the table to query: the 'employees' table contains the required information about employees.", "To find employees in the same department as Clara, we need to join the 'employees' table with itself (self-join).", "In the self-join, one instance of the 'employees' table (aliased as 'c') will represent Clara, and the other instance (aliased as 'e') will represent other employees.", "The join condition will be that both employees must have the same DEPARTMENT_ID.", "Finally, filter the results to only include employees from the same department as Clara by using a WHERE clause that checks Clara's first name."], "pred_sql": "SELECT e.FIRST_NAME, e.LAST_NAME, e.HIRE_DATE \nFROM employees e \nJOIN employees c ON e.DEPARTMENT_ID = c.DEPARTMENT_ID \nWHERE c.FIRST_NAME = 'Clara'", "gold_sql": "SELECT first_name ,  last_name ,  hire_date FROM employees WHERE department_id  =  (SELECT department_id FROM employees WHERE first_name  =  'Clara')", "source_tables": ["employees"]}
